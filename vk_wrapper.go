package vks

//#cgo LDFLAGS: -lvulkan
//#include <stdlib.h>
//#include <string.h>
//#include "vk_wrapper.h"
import "C"
import (
	"bytes"
	"fmt"
	"unsafe"
)

// Init loads the Vulkan library.
func Init() Result {
	ret := C.vksDynamicLoad()
	ptr := (*Result)(&ret)
	return *ptr
}

// Destroy unloads the Vulkan Library.
func Destroy() {
	C.vksDynamicUnload()
}

// Freer represents types that can Free resources
type Freer interface {
	Free()
}

// CCloner represents types that can clone themselves into the C heap.
type CCloner[OUT any] interface {
	ArpPtr(*AutoReleasePool) OUT
}

// AutoReleasePool is a collection of pointers that will all be released at
// once.
type AutoReleasePool struct {
	ptrs []Freer
}

// NewAutoReleaser creates a new AutoReleasePool. This is normally followed by
// a deferred call to AutoReleasePool.Release.
func NewAutoReleaser() *AutoReleasePool {
	return &AutoReleasePool{}
}

// Release releases all the pointers attached to the pool. This is normally
// invoked in a defer to release all the pointers when the scope exits.
func (arp *AutoReleasePool) Release() {
	for _, v := range arp.ptrs {
		v.Free()
	}
	arp.ptrs = nil
}

// Add adds pointers to the AutoReleasePool.
func (arp *AutoReleasePool) Add(ptr ...Freer) {
	arp.ptrs = append(arp.ptrs, ptr...)
}

// NewCStr allocates the provided string on the C heap. The AutoReleasePool is responsible for
// releasing the memory.
func NewCStr(arp *AutoReleasePool, s string) *byte {
	b := nullTerminatedBuffer(s).Bytes()
	ptr := C.malloc(C.ulong(len(b)))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	C.memcpy(ptr, unsafe.Pointer(&b[0]), C.ulong(len(b)))
	return (*byte)(ptr)
}

// NewCString allocates the provided string on the C heap. FreeCString must be
// called when the string is no longer needed.
func NewCString(s string) *byte {
	b := nullTerminatedBuffer(s).Bytes()
	ptr := C.malloc(C.ulong(len(b)))
	C.memcpy(ptr, unsafe.Pointer(&b[0]), C.ulong(len(b)))
	return (*byte)(ptr)
}

// FreeCString releases the C heap memory allocated by NewCString.
func FreeCString(ptr *byte) {
	if ptr != nil {
		C.free(unsafe.Pointer(ptr))
	}
}

// These are API constants.
const (
	VK_MAX_PHYSICAL_DEVICE_NAME_SIZE                       = 256
	VK_UUID_SIZE                                           = 16
	VK_LUID_SIZE                                           = 8
	VK_LUID_SIZE_KHR                                       = VK_LUID_SIZE
	VK_MAX_EXTENSION_NAME_SIZE                             = 256
	VK_MAX_DESCRIPTION_SIZE                                = 256
	VK_MAX_MEMORY_TYPES                                    = 32
	VK_MAX_MEMORY_HEAPS                                    = 16
	VK_LOD_CLAMP_NONE                                      = 1000.0
	VK_REMAINING_MIP_LEVELS                                = ^uint32(0)
	VK_REMAINING_ARRAY_LAYERS                              = ^uint32(0)
	VK_REMAINING_3D_SLICES_EXT                             = ^uint32(0)
	VK_WHOLE_SIZE                                          = ^uint64(0)
	VK_ATTACHMENT_UNUSED                                   = ^uint32(0)
	VK_TRUE                                                = 1
	VK_FALSE                                               = 0
	VK_QUEUE_FAMILY_IGNORED                                = ^uint32(0)
	VK_QUEUE_FAMILY_EXTERNAL                               = ^uint32(1)
	VK_QUEUE_FAMILY_EXTERNAL_KHR                           = VK_QUEUE_FAMILY_EXTERNAL
	VK_QUEUE_FAMILY_FOREIGN_EXT                            = ^uint32(2)
	VK_SUBPASS_EXTERNAL                                    = ^uint32(0)
	VK_MAX_DEVICE_GROUP_SIZE                               = 32
	VK_MAX_DEVICE_GROUP_SIZE_KHR                           = VK_MAX_DEVICE_GROUP_SIZE
	VK_MAX_DRIVER_NAME_SIZE                                = 256
	VK_MAX_DRIVER_NAME_SIZE_KHR                            = VK_MAX_DRIVER_NAME_SIZE
	VK_MAX_DRIVER_INFO_SIZE                                = 256
	VK_MAX_DRIVER_INFO_SIZE_KHR                            = VK_MAX_DRIVER_INFO_SIZE
	VK_SHADER_UNUSED_KHR                                   = ^uint32(0)
	VK_SHADER_UNUSED_NV                                    = VK_SHADER_UNUSED_KHR
	VK_MAX_GLOBAL_PRIORITY_SIZE_KHR                        = 16
	VK_MAX_GLOBAL_PRIORITY_SIZE_EXT                        = VK_MAX_GLOBAL_PRIORITY_SIZE_KHR
	VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT               = 32
	VK_SHADER_INDEX_UNUSED_AMDX                            = ^uint32(0)
	VK_EXT_DEBUG_REPORT_SPEC_VERSION                       = 10
	VK_EXT_DEBUG_REPORT_EXTENSION_NAME                     = "VK_EXT_debug_report"
	VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION   = 2
	VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME = "VK_KHR_get_physical_device_properties2"
	VK_KHR_PORTABILITY_ENUMERATION_SPEC_VERSION            = 1
	VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME          = "VK_KHR_portability_enumeration"
	VK_KHR_SURFACE_SPEC_VERSION                            = 25
	VK_KHR_SURFACE_EXTENSION_NAME                          = "VK_KHR_surface"
	VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION         = 1
	VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME       = "VK_KHR_get_surface_capabilities2"
	VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION     = 1
	VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME   = "VK_KHR_surface_protected_capabilities"
	VK_KHR_SWAPCHAIN_SPEC_VERSION                          = 70
	VK_KHR_SWAPCHAIN_EXTENSION_NAME                        = "VK_KHR_swapchain"
	VK_KHR_DISPLAY_SPEC_VERSION                            = 23
	VK_KHR_DISPLAY_EXTENSION_NAME                          = "VK_KHR_display"
	VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION           = 1
	VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME         = "VK_KHR_get_display_properties2"
	VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION                  = 10
	VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME                = "VK_KHR_display_swapchain"
	VK_KHR_FORMAT_FEATURE_FLAGS_2_SPEC_VERSION             = 2
	VK_KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME           = "VK_KHR_format_feature_flags2"
	VK_KHR_PORTABILITY_SUBSET_SPEC_VERSION                 = 1
	VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME               = "VK_KHR_portability_subset"
)

// HeaderVersion is the version of the vk specification used to generate this.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_API_VERSION.html
const HeaderVersion = 273

// ApiVersion is an implementation of the Vulkan Make Api Version
// defines. See
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_MAKE_API_VERSION.html
type ApiVersion uint32

// MakeApiVersion creates a ApiVersion based on the provided Variant, maJor, miNor,
// and Patch.
func MakeApiVersion(v, j, n, p int) ApiVersion {
	return ApiVersion((uint32(v) << 29) | (uint32(j) << 22) | (uint32(n) << 12) | (uint32(p)))
}

func (v ApiVersion) Major() uint32   { return uint32((v >> 22) & 0x7F) }
func (v ApiVersion) Minor() uint32   { return uint32((v >> 12) & 0x3FF) }
func (v ApiVersion) Patch() uint32   { return uint32(v & 0xFFF) }
func (v ApiVersion) Variant() uint32 { return uint32(v >> 29) }
func (v ApiVersion) String() string {
	return fmt.Sprintf("%d[v.%d.%d.%d.%d]", v, v.Variant(), v.Major(), v.Minor(), v.Patch())
}

var (
	VK_API_VERSION_1_0         ApiVersion = MakeApiVersion(0, 1, 0, 0)
	VK_API_VERSION_1_1         ApiVersion = MakeApiVersion(0, 1, 1, 0)
	VK_API_VERSION_1_2         ApiVersion = MakeApiVersion(0, 1, 2, 0)
	VK_API_VERSION_1_3         ApiVersion = MakeApiVersion(0, 1, 3, 0)
	VK_HEADER_VERSION_COMPLETE ApiVersion = MakeApiVersion(0, 1, 3, HeaderVersion)
)

// Bool32 basetype
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBool32.html
type Bool32 uint32

// Flags basetype
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFlags.html
type Flags uint32

// DeviceSize basetype
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceSize.html
type DeviceSize uint64

// DeviceAddress basetype
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceAddress.html
type DeviceAddress uint64

// SampleMask basetype
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSampleMask.html
type SampleMask uint32

// Instance is a Handle to a vulkan resource.
//
// Use MakeInstanceFacade to create a facade around this object to invoke methods.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInstance.html
type Instance C.VkInstance

// NullInstance is a typed Null value for the Instance type.
var NullInstance Instance

// MakeInstanceFacadeFacade provides a facade interface to the handle. It loads the proc
// addresses for the provided Instance handle.
func MakeInstanceFacade(x Instance) InstanceFacade {
	var addrs C.vksProcAddr
	C.vksLoadInstanceProcAddrs(x, &addrs)
	return InstanceFacade{
		H:     x,
		procs: &addrs,
	}
}

// InstanceFacade is a Instance handle with the proc addresses pointer. It allows
// the invocation of methods against the handle. In the vulkan spec, these would be the functions
// that take the handle as the first parameter.
//
// Use the H field to get the handle back.
type InstanceFacade struct {
	H     Instance       // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// PhysicalDevice is a Handle to a vulkan resource.
// PhysicalDevice is a child of Instance.
//
// Use InstanceFacade.MakePhysicalDeviceFacade to create a facade around this object to invoke methods.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html
type PhysicalDevice C.VkPhysicalDevice

// NullPhysicalDevice is a typed Null value for the PhysicalDevice type.
var NullPhysicalDevice PhysicalDevice

// MakePhysicalDeviceFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent InstanceFacade) MakePhysicalDeviceFacade(x PhysicalDevice) PhysicalDeviceFacade {
	return PhysicalDeviceFacade{
		H:     x,
		procs: parent.procs,
	}
}

// PhysicalDeviceFacade is a PhysicalDevice handle with the proc addresses pointer. It allows
// the invocation of methods against the handle. In the vulkan spec, these would be the functions
// that take the handle as the first parameter.
//
// Use the H field to get the handle back.
type PhysicalDeviceFacade struct {
	H     PhysicalDevice // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// Device is a Handle to a vulkan resource.
// Device is a child of PhysicalDevice.
//
// Use PhysicalDeviceFacade.MakeDeviceFacade to create a facade around this object to invoke methods.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDevice.html
type Device C.VkDevice

// NullDevice is a typed Null value for the Device type.
var NullDevice Device

// MakeDeviceFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent PhysicalDeviceFacade) MakeDeviceFacade(x Device) DeviceFacade {
	return DeviceFacade{
		H:     x,
		procs: parent.procs,
	}
}

// DeviceFacade is a Device handle with the proc addresses pointer. It allows
// the invocation of methods against the handle. In the vulkan spec, these would be the functions
// that take the handle as the first parameter.
//
// Use the H field to get the handle back.
type DeviceFacade struct {
	H     Device         // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// ShaderModule is a Handle to a vulkan resource.
// ShaderModule is a child of Device.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html
type ShaderModule C.VkShaderModule

// NullShaderModule is a typed Null value for the ShaderModule type.
var NullShaderModule ShaderModule

// DescriptorSetLayout is a Handle to a vulkan resource.
// DescriptorSetLayout is a child of Device.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayout.html
type DescriptorSetLayout C.VkDescriptorSetLayout

// NullDescriptorSetLayout is a typed Null value for the DescriptorSetLayout type.
var NullDescriptorSetLayout DescriptorSetLayout

// RenderPass is a Handle to a vulkan resource.
// RenderPass is a child of Device.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPass.html
type RenderPass C.VkRenderPass

// NullRenderPass is a typed Null value for the RenderPass type.
var NullRenderPass RenderPass

// PipelineCache is a Handle to a vulkan resource.
// PipelineCache is a child of Device.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCache.html
type PipelineCache C.VkPipelineCache

// NullPipelineCache is a typed Null value for the PipelineCache type.
var NullPipelineCache PipelineCache

// Framebuffer is a Handle to a vulkan resource.
// Framebuffer is a child of Device.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebuffer.html
type Framebuffer C.VkFramebuffer

// NullFramebuffer is a typed Null value for the Framebuffer type.
var NullFramebuffer Framebuffer

// Pipeline is a Handle to a vulkan resource.
// Pipeline is a child of Device.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipeline.html
type Pipeline C.VkPipeline

// NullPipeline is a typed Null value for the Pipeline type.
var NullPipeline Pipeline

// CommandPool is a Handle to a vulkan resource.
// CommandPool is a child of Device.
//
// Use DeviceFacade.MakeCommandPoolFacade to create a facade around this object to invoke methods.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPool.html
type CommandPool C.VkCommandPool

// NullCommandPool is a typed Null value for the CommandPool type.
var NullCommandPool CommandPool

// MakeCommandPoolFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DeviceFacade) MakeCommandPoolFacade(x CommandPool) CommandPoolFacade {
	return CommandPoolFacade{
		H:     x,
		procs: parent.procs,
	}
}

// CommandPoolFacade is a CommandPool handle with the proc addresses pointer. It allows
// the invocation of methods against the handle. In the vulkan spec, these would be the functions
// that take the handle as the first parameter.
//
// Use the H field to get the handle back.
type CommandPoolFacade struct {
	H     CommandPool    // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// PipelineLayout is a Handle to a vulkan resource.
// PipelineLayout is a child of Device.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineLayout.html
type PipelineLayout C.VkPipelineLayout

// NullPipelineLayout is a typed Null value for the PipelineLayout type.
var NullPipelineLayout PipelineLayout

// Sampler is a Handle to a vulkan resource.
// Sampler is a child of Device.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSampler.html
type Sampler C.VkSampler

// NullSampler is a typed Null value for the Sampler type.
var NullSampler Sampler

// Image is a Handle to a vulkan resource.
// Image is a child of Device.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImage.html
type Image C.VkImage

// NullImage is a typed Null value for the Image type.
var NullImage Image

// CommandBuffer is a Handle to a vulkan resource.
// CommandBuffer is a child of CommandPool.
//
// Use CommandPoolFacade.MakeCommandBufferFacade to create a facade around this object to invoke methods.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBuffer.html
type CommandBuffer C.VkCommandBuffer

// NullCommandBuffer is a typed Null value for the CommandBuffer type.
var NullCommandBuffer CommandBuffer

// MakeCommandBufferFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent CommandPoolFacade) MakeCommandBufferFacade(x CommandBuffer) CommandBufferFacade {
	return CommandBufferFacade{
		H:     x,
		procs: parent.procs,
	}
}

// CommandBufferFacade is a CommandBuffer handle with the proc addresses pointer. It allows
// the invocation of methods against the handle. In the vulkan spec, these would be the functions
// that take the handle as the first parameter.
//
// Use the H field to get the handle back.
type CommandBufferFacade struct {
	H     CommandBuffer  // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// ImageView is a Handle to a vulkan resource.
// ImageView is a child of Device.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageView.html
type ImageView C.VkImageView

// NullImageView is a typed Null value for the ImageView type.
var NullImageView ImageView

// DescriptorPool is a Handle to a vulkan resource.
// DescriptorPool is a child of Device.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPool.html
type DescriptorPool C.VkDescriptorPool

// NullDescriptorPool is a typed Null value for the DescriptorPool type.
var NullDescriptorPool DescriptorPool

// DescriptorSet is a Handle to a vulkan resource.
// DescriptorSet is a child of DescriptorPool.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSet.html
type DescriptorSet C.VkDescriptorSet

// NullDescriptorSet is a typed Null value for the DescriptorSet type.
var NullDescriptorSet DescriptorSet

// BufferView is a Handle to a vulkan resource.
// BufferView is a child of Device.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferView.html
type BufferView C.VkBufferView

// NullBufferView is a typed Null value for the BufferView type.
var NullBufferView BufferView

// Buffer is a Handle to a vulkan resource.
// Buffer is a child of Device.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBuffer.html
type Buffer C.VkBuffer

// NullBuffer is a typed Null value for the Buffer type.
var NullBuffer Buffer

// QueryPool is a Handle to a vulkan resource.
// QueryPool is a child of Device.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPool.html
type QueryPool C.VkQueryPool

// NullQueryPool is a typed Null value for the QueryPool type.
var NullQueryPool QueryPool

// Event is a Handle to a vulkan resource.
// Event is a child of Device.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkEvent.html
type Event C.VkEvent

// NullEvent is a typed Null value for the Event type.
var NullEvent Event

// Semaphore is a Handle to a vulkan resource.
// Semaphore is a child of Device.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphore.html
type Semaphore C.VkSemaphore

// NullSemaphore is a typed Null value for the Semaphore type.
var NullSemaphore Semaphore

// Fence is a Handle to a vulkan resource.
// Fence is a child of Device.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFence.html
type Fence C.VkFence

// NullFence is a typed Null value for the Fence type.
var NullFence Fence

// DeviceMemory is a Handle to a vulkan resource.
// DeviceMemory is a child of Device.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceMemory.html
type DeviceMemory C.VkDeviceMemory

// NullDeviceMemory is a typed Null value for the DeviceMemory type.
var NullDeviceMemory DeviceMemory

// Queue is a Handle to a vulkan resource.
// Queue is a child of Device.
//
// Use DeviceFacade.MakeQueueFacade to create a facade around this object to invoke methods.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueue.html
type Queue C.VkQueue

// NullQueue is a typed Null value for the Queue type.
var NullQueue Queue

// MakeQueueFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DeviceFacade) MakeQueueFacade(x Queue) QueueFacade {
	return QueueFacade{
		H:     x,
		procs: parent.procs,
	}
}

// QueueFacade is a Queue handle with the proc addresses pointer. It allows
// the invocation of methods against the handle. In the vulkan spec, these would be the functions
// that take the handle as the first parameter.
//
// Use the H field to get the handle back.
type QueueFacade struct {
	H     Queue          // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// VertexInputRate enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVertexInputRate.html
type VertexInputRate uint32

const (
	VK_VERTEX_INPUT_RATE_VERTEX   VertexInputRate = 0
	VK_VERTEX_INPUT_RATE_INSTANCE VertexInputRate = 1
)

var (
	reverseVertexInputRate map[VertexInputRate]string = map[VertexInputRate]string{
		VK_VERTEX_INPUT_RATE_VERTEX:   "VK_VERTEX_INPUT_RATE_VERTEX",
		VK_VERTEX_INPUT_RATE_INSTANCE: "VK_VERTEX_INPUT_RATE_INSTANCE",
	}
)

func (x VertexInputRate) String() string {
	if s, ok := reverseVertexInputRate[x]; ok {
		return s
	}
	return fmt.Sprintf("VertexInputRate=%d", x)
}

// FramebufferCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebufferCreateFlagBits.html
type FramebufferCreateFlagBits uint32

const (
	VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT FramebufferCreateFlagBits = (1 << 0)
)

var (
	reverseFramebufferCreateFlagBits map[FramebufferCreateFlagBits]string = map[FramebufferCreateFlagBits]string{
		VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT: "VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT",
	}
)

func (x FramebufferCreateFlagBits) String() string {
	if s, ok := reverseFramebufferCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("FramebufferCreateFlagBits=%d", x)
}

// SamplerMipmapMode enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerMipmapMode.html
type SamplerMipmapMode uint32

const (
	VK_SAMPLER_MIPMAP_MODE_NEAREST SamplerMipmapMode = 0
	VK_SAMPLER_MIPMAP_MODE_LINEAR  SamplerMipmapMode = 1
)

var (
	reverseSamplerMipmapMode map[SamplerMipmapMode]string = map[SamplerMipmapMode]string{
		VK_SAMPLER_MIPMAP_MODE_NEAREST: "VK_SAMPLER_MIPMAP_MODE_NEAREST",
		VK_SAMPLER_MIPMAP_MODE_LINEAR:  "VK_SAMPLER_MIPMAP_MODE_LINEAR",
	}
)

func (x SamplerMipmapMode) String() string {
	if s, ok := reverseSamplerMipmapMode[x]; ok {
		return s
	}
	return fmt.Sprintf("SamplerMipmapMode=%d", x)
}

// ObjectType enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkObjectType.html
type ObjectType uint32

const (
	VK_OBJECT_TYPE_UNKNOWN                    ObjectType = 0
	VK_OBJECT_TYPE_INSTANCE                   ObjectType = 1
	VK_OBJECT_TYPE_PHYSICAL_DEVICE            ObjectType = 2
	VK_OBJECT_TYPE_DEVICE                     ObjectType = 3
	VK_OBJECT_TYPE_QUEUE                      ObjectType = 4
	VK_OBJECT_TYPE_SEMAPHORE                  ObjectType = 5
	VK_OBJECT_TYPE_COMMAND_BUFFER             ObjectType = 6
	VK_OBJECT_TYPE_FENCE                      ObjectType = 7
	VK_OBJECT_TYPE_DEVICE_MEMORY              ObjectType = 8
	VK_OBJECT_TYPE_BUFFER                     ObjectType = 9
	VK_OBJECT_TYPE_IMAGE                      ObjectType = 10
	VK_OBJECT_TYPE_EVENT                      ObjectType = 11
	VK_OBJECT_TYPE_QUERY_POOL                 ObjectType = 12
	VK_OBJECT_TYPE_BUFFER_VIEW                ObjectType = 13
	VK_OBJECT_TYPE_IMAGE_VIEW                 ObjectType = 14
	VK_OBJECT_TYPE_SHADER_MODULE              ObjectType = 15
	VK_OBJECT_TYPE_PIPELINE_CACHE             ObjectType = 16
	VK_OBJECT_TYPE_PIPELINE_LAYOUT            ObjectType = 17
	VK_OBJECT_TYPE_RENDER_PASS                ObjectType = 18
	VK_OBJECT_TYPE_PIPELINE                   ObjectType = 19
	VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT      ObjectType = 20
	VK_OBJECT_TYPE_SAMPLER                    ObjectType = 21
	VK_OBJECT_TYPE_DESCRIPTOR_POOL            ObjectType = 22
	VK_OBJECT_TYPE_DESCRIPTOR_SET             ObjectType = 23
	VK_OBJECT_TYPE_FRAMEBUFFER                ObjectType = 24
	VK_OBJECT_TYPE_COMMAND_POOL               ObjectType = 25
	VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION   ObjectType = 1000156000
	VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE ObjectType = 1000085000
	VK_OBJECT_TYPE_PRIVATE_DATA_SLOT          ObjectType = 1000295000
	VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT  ObjectType = 1000011000
	VK_OBJECT_TYPE_SURFACE_KHR                ObjectType = 1000000000
	VK_OBJECT_TYPE_SWAPCHAIN_KHR              ObjectType = 1000001000
	VK_OBJECT_TYPE_DISPLAY_KHR                ObjectType = 1000002000
	VK_OBJECT_TYPE_DISPLAY_MODE_KHR           ObjectType = 1000002001
)

var (
	reverseObjectType map[ObjectType]string = map[ObjectType]string{
		VK_OBJECT_TYPE_UNKNOWN:                    "VK_OBJECT_TYPE_UNKNOWN",
		VK_OBJECT_TYPE_INSTANCE:                   "VK_OBJECT_TYPE_INSTANCE",
		VK_OBJECT_TYPE_PHYSICAL_DEVICE:            "VK_OBJECT_TYPE_PHYSICAL_DEVICE",
		VK_OBJECT_TYPE_DEVICE:                     "VK_OBJECT_TYPE_DEVICE",
		VK_OBJECT_TYPE_QUEUE:                      "VK_OBJECT_TYPE_QUEUE",
		VK_OBJECT_TYPE_SEMAPHORE:                  "VK_OBJECT_TYPE_SEMAPHORE",
		VK_OBJECT_TYPE_COMMAND_BUFFER:             "VK_OBJECT_TYPE_COMMAND_BUFFER",
		VK_OBJECT_TYPE_FENCE:                      "VK_OBJECT_TYPE_FENCE",
		VK_OBJECT_TYPE_DEVICE_MEMORY:              "VK_OBJECT_TYPE_DEVICE_MEMORY",
		VK_OBJECT_TYPE_BUFFER:                     "VK_OBJECT_TYPE_BUFFER",
		VK_OBJECT_TYPE_IMAGE:                      "VK_OBJECT_TYPE_IMAGE",
		VK_OBJECT_TYPE_EVENT:                      "VK_OBJECT_TYPE_EVENT",
		VK_OBJECT_TYPE_QUERY_POOL:                 "VK_OBJECT_TYPE_QUERY_POOL",
		VK_OBJECT_TYPE_BUFFER_VIEW:                "VK_OBJECT_TYPE_BUFFER_VIEW",
		VK_OBJECT_TYPE_IMAGE_VIEW:                 "VK_OBJECT_TYPE_IMAGE_VIEW",
		VK_OBJECT_TYPE_SHADER_MODULE:              "VK_OBJECT_TYPE_SHADER_MODULE",
		VK_OBJECT_TYPE_PIPELINE_CACHE:             "VK_OBJECT_TYPE_PIPELINE_CACHE",
		VK_OBJECT_TYPE_PIPELINE_LAYOUT:            "VK_OBJECT_TYPE_PIPELINE_LAYOUT",
		VK_OBJECT_TYPE_RENDER_PASS:                "VK_OBJECT_TYPE_RENDER_PASS",
		VK_OBJECT_TYPE_PIPELINE:                   "VK_OBJECT_TYPE_PIPELINE",
		VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT:      "VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT",
		VK_OBJECT_TYPE_SAMPLER:                    "VK_OBJECT_TYPE_SAMPLER",
		VK_OBJECT_TYPE_DESCRIPTOR_POOL:            "VK_OBJECT_TYPE_DESCRIPTOR_POOL",
		VK_OBJECT_TYPE_DESCRIPTOR_SET:             "VK_OBJECT_TYPE_DESCRIPTOR_SET",
		VK_OBJECT_TYPE_FRAMEBUFFER:                "VK_OBJECT_TYPE_FRAMEBUFFER",
		VK_OBJECT_TYPE_COMMAND_POOL:               "VK_OBJECT_TYPE_COMMAND_POOL",
		VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION:   "VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION",
		VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE: "VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE",
		VK_OBJECT_TYPE_PRIVATE_DATA_SLOT:          "VK_OBJECT_TYPE_PRIVATE_DATA_SLOT",
		VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT:  "VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT",
		VK_OBJECT_TYPE_SURFACE_KHR:                "VK_OBJECT_TYPE_SURFACE_KHR",
		VK_OBJECT_TYPE_SWAPCHAIN_KHR:              "VK_OBJECT_TYPE_SWAPCHAIN_KHR",
		VK_OBJECT_TYPE_DISPLAY_KHR:                "VK_OBJECT_TYPE_DISPLAY_KHR",
		VK_OBJECT_TYPE_DISPLAY_MODE_KHR:           "VK_OBJECT_TYPE_DISPLAY_MODE_KHR",
	}
)

func (x ObjectType) String() string {
	if s, ok := reverseObjectType[x]; ok {
		return s
	}
	return fmt.Sprintf("ObjectType=%d", x)
}

// DescriptorPoolCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolCreateFlagBits.html
type DescriptorPoolCreateFlagBits uint32

const (
	VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT DescriptorPoolCreateFlagBits = (1 << 0)
	VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT   DescriptorPoolCreateFlagBits = (1 << 1)
)

var (
	reverseDescriptorPoolCreateFlagBits map[DescriptorPoolCreateFlagBits]string = map[DescriptorPoolCreateFlagBits]string{
		VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT: "VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT",
		VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT:   "VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT",
	}
)

func (x DescriptorPoolCreateFlagBits) String() string {
	if s, ok := reverseDescriptorPoolCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("DescriptorPoolCreateFlagBits=%d", x)
}

// DescriptorSetLayoutCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutCreateFlagBits.html
type DescriptorSetLayoutCreateFlagBits uint32

const (
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT DescriptorSetLayoutCreateFlagBits = (1 << 1)
)

var (
	reverseDescriptorSetLayoutCreateFlagBits map[DescriptorSetLayoutCreateFlagBits]string = map[DescriptorSetLayoutCreateFlagBits]string{
		VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT: "VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT",
	}
)

func (x DescriptorSetLayoutCreateFlagBits) String() string {
	if s, ok := reverseDescriptorSetLayoutCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("DescriptorSetLayoutCreateFlagBits=%d", x)
}

// DescriptorType enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorType.html
type DescriptorType uint32

const (
	VK_DESCRIPTOR_TYPE_SAMPLER                DescriptorType = 0
	VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER DescriptorType = 1
	VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE          DescriptorType = 2
	VK_DESCRIPTOR_TYPE_STORAGE_IMAGE          DescriptorType = 3
	VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER   DescriptorType = 4
	VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER   DescriptorType = 5
	VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER         DescriptorType = 6
	VK_DESCRIPTOR_TYPE_STORAGE_BUFFER         DescriptorType = 7
	VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC DescriptorType = 8
	VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC DescriptorType = 9
	VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT       DescriptorType = 10
	VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK   DescriptorType = 1000138000
)

var (
	reverseDescriptorType map[DescriptorType]string = map[DescriptorType]string{
		VK_DESCRIPTOR_TYPE_SAMPLER:                "VK_DESCRIPTOR_TYPE_SAMPLER",
		VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER: "VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER",
		VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE:          "VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE",
		VK_DESCRIPTOR_TYPE_STORAGE_IMAGE:          "VK_DESCRIPTOR_TYPE_STORAGE_IMAGE",
		VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER:   "VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER",
		VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER:   "VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER",
		VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER:         "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER",
		VK_DESCRIPTOR_TYPE_STORAGE_BUFFER:         "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER",
		VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC: "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC",
		VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC: "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC",
		VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:       "VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT",
		VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK:   "VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK",
	}
)

func (x DescriptorType) String() string {
	if s, ok := reverseDescriptorType[x]; ok {
		return s
	}
	return fmt.Sprintf("DescriptorType=%d", x)
}

// AccessFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccessFlagBits.html
type AccessFlagBits uint32

const (
	VK_ACCESS_INDIRECT_COMMAND_READ_BIT          AccessFlagBits = (1 << 0)
	VK_ACCESS_INDEX_READ_BIT                     AccessFlagBits = (1 << 1)
	VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT          AccessFlagBits = (1 << 2)
	VK_ACCESS_UNIFORM_READ_BIT                   AccessFlagBits = (1 << 3)
	VK_ACCESS_INPUT_ATTACHMENT_READ_BIT          AccessFlagBits = (1 << 4)
	VK_ACCESS_SHADER_READ_BIT                    AccessFlagBits = (1 << 5)
	VK_ACCESS_SHADER_WRITE_BIT                   AccessFlagBits = (1 << 6)
	VK_ACCESS_COLOR_ATTACHMENT_READ_BIT          AccessFlagBits = (1 << 7)
	VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT         AccessFlagBits = (1 << 8)
	VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT  AccessFlagBits = (1 << 9)
	VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT AccessFlagBits = (1 << 10)
	VK_ACCESS_TRANSFER_READ_BIT                  AccessFlagBits = (1 << 11)
	VK_ACCESS_TRANSFER_WRITE_BIT                 AccessFlagBits = (1 << 12)
	VK_ACCESS_HOST_READ_BIT                      AccessFlagBits = (1 << 13)
	VK_ACCESS_HOST_WRITE_BIT                     AccessFlagBits = (1 << 14)
	VK_ACCESS_MEMORY_READ_BIT                    AccessFlagBits = (1 << 15)
	VK_ACCESS_MEMORY_WRITE_BIT                   AccessFlagBits = (1 << 16)
	VK_ACCESS_NONE                               AccessFlagBits = 0
)

var (
	reverseAccessFlagBits map[AccessFlagBits]string = map[AccessFlagBits]string{
		VK_ACCESS_INDIRECT_COMMAND_READ_BIT:          "VK_ACCESS_INDIRECT_COMMAND_READ_BIT",
		VK_ACCESS_INDEX_READ_BIT:                     "VK_ACCESS_INDEX_READ_BIT",
		VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT:          "VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT",
		VK_ACCESS_UNIFORM_READ_BIT:                   "VK_ACCESS_UNIFORM_READ_BIT",
		VK_ACCESS_INPUT_ATTACHMENT_READ_BIT:          "VK_ACCESS_INPUT_ATTACHMENT_READ_BIT",
		VK_ACCESS_SHADER_READ_BIT:                    "VK_ACCESS_SHADER_READ_BIT",
		VK_ACCESS_SHADER_WRITE_BIT:                   "VK_ACCESS_SHADER_WRITE_BIT",
		VK_ACCESS_COLOR_ATTACHMENT_READ_BIT:          "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT",
		VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT:         "VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT",
		VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT:  "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT",
		VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT: "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT",
		VK_ACCESS_TRANSFER_READ_BIT:                  "VK_ACCESS_TRANSFER_READ_BIT",
		VK_ACCESS_TRANSFER_WRITE_BIT:                 "VK_ACCESS_TRANSFER_WRITE_BIT",
		VK_ACCESS_HOST_READ_BIT:                      "VK_ACCESS_HOST_READ_BIT",
		VK_ACCESS_HOST_WRITE_BIT:                     "VK_ACCESS_HOST_WRITE_BIT",
		VK_ACCESS_MEMORY_READ_BIT:                    "VK_ACCESS_MEMORY_READ_BIT",
		VK_ACCESS_MEMORY_WRITE_BIT:                   "VK_ACCESS_MEMORY_WRITE_BIT",
		VK_ACCESS_NONE:                               "VK_ACCESS_NONE",
	}
)

func (x AccessFlagBits) String() string {
	if s, ok := reverseAccessFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("AccessFlagBits=%d", x)
}

// SamplerCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerCreateFlagBits.html
type SamplerCreateFlagBits uint32

// SamplerAddressMode enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerAddressMode.html
type SamplerAddressMode uint32

const (
	VK_SAMPLER_ADDRESS_MODE_REPEAT               SamplerAddressMode = 0
	VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT      SamplerAddressMode = 1
	VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE        SamplerAddressMode = 2
	VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER      SamplerAddressMode = 3
	VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE SamplerAddressMode = 4
)

var (
	reverseSamplerAddressMode map[SamplerAddressMode]string = map[SamplerAddressMode]string{
		VK_SAMPLER_ADDRESS_MODE_REPEAT:               "VK_SAMPLER_ADDRESS_MODE_REPEAT",
		VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT:      "VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT",
		VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE:        "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE",
		VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER:      "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER",
		VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE: "VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE",
	}
)

func (x SamplerAddressMode) String() string {
	if s, ok := reverseSamplerAddressMode[x]; ok {
		return s
	}
	return fmt.Sprintf("SamplerAddressMode=%d", x)
}

// AttachmentDescriptionFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentDescriptionFlagBits.html
type AttachmentDescriptionFlagBits uint32

const (
	VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT AttachmentDescriptionFlagBits = (1 << 0)
)

var (
	reverseAttachmentDescriptionFlagBits map[AttachmentDescriptionFlagBits]string = map[AttachmentDescriptionFlagBits]string{
		VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT: "VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT",
	}
)

func (x AttachmentDescriptionFlagBits) String() string {
	if s, ok := reverseAttachmentDescriptionFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("AttachmentDescriptionFlagBits=%d", x)
}

// Filter enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFilter.html
type Filter uint32

const (
	VK_FILTER_NEAREST Filter = 0
	VK_FILTER_LINEAR  Filter = 1
)

var (
	reverseFilter map[Filter]string = map[Filter]string{
		VK_FILTER_NEAREST: "VK_FILTER_NEAREST",
		VK_FILTER_LINEAR:  "VK_FILTER_LINEAR",
	}
)

func (x Filter) String() string {
	if s, ok := reverseFilter[x]; ok {
		return s
	}
	return fmt.Sprintf("Filter=%d", x)
}

// BorderColor enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBorderColor.html
type BorderColor uint32

const (
	VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK BorderColor = 0
	VK_BORDER_COLOR_INT_TRANSPARENT_BLACK   BorderColor = 1
	VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK      BorderColor = 2
	VK_BORDER_COLOR_INT_OPAQUE_BLACK        BorderColor = 3
	VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE      BorderColor = 4
	VK_BORDER_COLOR_INT_OPAQUE_WHITE        BorderColor = 5
)

var (
	reverseBorderColor map[BorderColor]string = map[BorderColor]string{
		VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK: "VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK",
		VK_BORDER_COLOR_INT_TRANSPARENT_BLACK:   "VK_BORDER_COLOR_INT_TRANSPARENT_BLACK",
		VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK:      "VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK",
		VK_BORDER_COLOR_INT_OPAQUE_BLACK:        "VK_BORDER_COLOR_INT_OPAQUE_BLACK",
		VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE:      "VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE",
		VK_BORDER_COLOR_INT_OPAQUE_WHITE:        "VK_BORDER_COLOR_INT_OPAQUE_WHITE",
	}
)

func (x BorderColor) String() string {
	if s, ok := reverseBorderColor[x]; ok {
		return s
	}
	return fmt.Sprintf("BorderColor=%d", x)
}

// AttachmentLoadOp enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentLoadOp.html
type AttachmentLoadOp uint32

const (
	VK_ATTACHMENT_LOAD_OP_LOAD      AttachmentLoadOp = 0
	VK_ATTACHMENT_LOAD_OP_CLEAR     AttachmentLoadOp = 1
	VK_ATTACHMENT_LOAD_OP_DONT_CARE AttachmentLoadOp = 2
)

var (
	reverseAttachmentLoadOp map[AttachmentLoadOp]string = map[AttachmentLoadOp]string{
		VK_ATTACHMENT_LOAD_OP_LOAD:      "VK_ATTACHMENT_LOAD_OP_LOAD",
		VK_ATTACHMENT_LOAD_OP_CLEAR:     "VK_ATTACHMENT_LOAD_OP_CLEAR",
		VK_ATTACHMENT_LOAD_OP_DONT_CARE: "VK_ATTACHMENT_LOAD_OP_DONT_CARE",
	}
)

func (x AttachmentLoadOp) String() string {
	if s, ok := reverseAttachmentLoadOp[x]; ok {
		return s
	}
	return fmt.Sprintf("AttachmentLoadOp=%d", x)
}

// PipelineStageFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineStageFlagBits.html
type PipelineStageFlagBits uint32

const (
	VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT                    PipelineStageFlagBits = (1 << 0)
	VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT                  PipelineStageFlagBits = (1 << 1)
	VK_PIPELINE_STAGE_VERTEX_INPUT_BIT                   PipelineStageFlagBits = (1 << 2)
	VK_PIPELINE_STAGE_VERTEX_SHADER_BIT                  PipelineStageFlagBits = (1 << 3)
	VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT    PipelineStageFlagBits = (1 << 4)
	VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT PipelineStageFlagBits = (1 << 5)
	VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT                PipelineStageFlagBits = (1 << 6)
	VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT                PipelineStageFlagBits = (1 << 7)
	VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT           PipelineStageFlagBits = (1 << 8)
	VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT            PipelineStageFlagBits = (1 << 9)
	VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT        PipelineStageFlagBits = (1 << 10)
	VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT                 PipelineStageFlagBits = (1 << 11)
	VK_PIPELINE_STAGE_TRANSFER_BIT                       PipelineStageFlagBits = (1 << 12)
	VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT                 PipelineStageFlagBits = (1 << 13)
	VK_PIPELINE_STAGE_HOST_BIT                           PipelineStageFlagBits = (1 << 14)
	VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT                   PipelineStageFlagBits = (1 << 15)
	VK_PIPELINE_STAGE_ALL_COMMANDS_BIT                   PipelineStageFlagBits = (1 << 16)
	VK_PIPELINE_STAGE_NONE                               PipelineStageFlagBits = 0
)

var (
	reversePipelineStageFlagBits map[PipelineStageFlagBits]string = map[PipelineStageFlagBits]string{
		VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT:                    "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT",
		VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT:                  "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT",
		VK_PIPELINE_STAGE_VERTEX_INPUT_BIT:                   "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT",
		VK_PIPELINE_STAGE_VERTEX_SHADER_BIT:                  "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT",
		VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT:    "VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT",
		VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT: "VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT",
		VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT:                "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT",
		VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT:                "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT",
		VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT:           "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT",
		VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT:            "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT",
		VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT:        "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT",
		VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT:                 "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT",
		VK_PIPELINE_STAGE_TRANSFER_BIT:                       "VK_PIPELINE_STAGE_TRANSFER_BIT",
		VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT:                 "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT",
		VK_PIPELINE_STAGE_HOST_BIT:                           "VK_PIPELINE_STAGE_HOST_BIT",
		VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT:                   "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT",
		VK_PIPELINE_STAGE_ALL_COMMANDS_BIT:                   "VK_PIPELINE_STAGE_ALL_COMMANDS_BIT",
		VK_PIPELINE_STAGE_NONE:                               "VK_PIPELINE_STAGE_NONE",
	}
)

func (x PipelineStageFlagBits) String() string {
	if s, ok := reversePipelineStageFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("PipelineStageFlagBits=%d", x)
}

// StencilOp enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkStencilOp.html
type StencilOp uint32

const (
	VK_STENCIL_OP_KEEP                StencilOp = 0
	VK_STENCIL_OP_ZERO                StencilOp = 1
	VK_STENCIL_OP_REPLACE             StencilOp = 2
	VK_STENCIL_OP_INCREMENT_AND_CLAMP StencilOp = 3
	VK_STENCIL_OP_DECREMENT_AND_CLAMP StencilOp = 4
	VK_STENCIL_OP_INVERT              StencilOp = 5
	VK_STENCIL_OP_INCREMENT_AND_WRAP  StencilOp = 6
	VK_STENCIL_OP_DECREMENT_AND_WRAP  StencilOp = 7
)

var (
	reverseStencilOp map[StencilOp]string = map[StencilOp]string{
		VK_STENCIL_OP_KEEP:                "VK_STENCIL_OP_KEEP",
		VK_STENCIL_OP_ZERO:                "VK_STENCIL_OP_ZERO",
		VK_STENCIL_OP_REPLACE:             "VK_STENCIL_OP_REPLACE",
		VK_STENCIL_OP_INCREMENT_AND_CLAMP: "VK_STENCIL_OP_INCREMENT_AND_CLAMP",
		VK_STENCIL_OP_DECREMENT_AND_CLAMP: "VK_STENCIL_OP_DECREMENT_AND_CLAMP",
		VK_STENCIL_OP_INVERT:              "VK_STENCIL_OP_INVERT",
		VK_STENCIL_OP_INCREMENT_AND_WRAP:  "VK_STENCIL_OP_INCREMENT_AND_WRAP",
		VK_STENCIL_OP_DECREMENT_AND_WRAP:  "VK_STENCIL_OP_DECREMENT_AND_WRAP",
	}
)

func (x StencilOp) String() string {
	if s, ok := reverseStencilOp[x]; ok {
		return s
	}
	return fmt.Sprintf("StencilOp=%d", x)
}

// ShaderStageFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderStageFlagBits.html
type ShaderStageFlagBits uint32

const (
	VK_SHADER_STAGE_VERTEX_BIT                  ShaderStageFlagBits = (1 << 0)
	VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT    ShaderStageFlagBits = (1 << 1)
	VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT ShaderStageFlagBits = (1 << 2)
	VK_SHADER_STAGE_GEOMETRY_BIT                ShaderStageFlagBits = (1 << 3)
	VK_SHADER_STAGE_FRAGMENT_BIT                ShaderStageFlagBits = (1 << 4)
	VK_SHADER_STAGE_COMPUTE_BIT                 ShaderStageFlagBits = (1 << 5)
	VK_SHADER_STAGE_ALL_GRAPHICS                ShaderStageFlagBits = 0x0000001F
	VK_SHADER_STAGE_ALL                         ShaderStageFlagBits = 0x7FFFFFFF
)

var (
	reverseShaderStageFlagBits map[ShaderStageFlagBits]string = map[ShaderStageFlagBits]string{
		VK_SHADER_STAGE_VERTEX_BIT:                  "VK_SHADER_STAGE_VERTEX_BIT",
		VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT:    "VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT",
		VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT: "VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT",
		VK_SHADER_STAGE_GEOMETRY_BIT:                "VK_SHADER_STAGE_GEOMETRY_BIT",
		VK_SHADER_STAGE_FRAGMENT_BIT:                "VK_SHADER_STAGE_FRAGMENT_BIT",
		VK_SHADER_STAGE_COMPUTE_BIT:                 "VK_SHADER_STAGE_COMPUTE_BIT",
		VK_SHADER_STAGE_ALL_GRAPHICS:                "VK_SHADER_STAGE_ALL_GRAPHICS",
		VK_SHADER_STAGE_ALL:                         "VK_SHADER_STAGE_ALL",
	}
)

func (x ShaderStageFlagBits) String() string {
	if s, ok := reverseShaderStageFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ShaderStageFlagBits=%d", x)
}

// AttachmentStoreOp enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentStoreOp.html
type AttachmentStoreOp uint32

const (
	VK_ATTACHMENT_STORE_OP_STORE     AttachmentStoreOp = 0
	VK_ATTACHMENT_STORE_OP_DONT_CARE AttachmentStoreOp = 1
	VK_ATTACHMENT_STORE_OP_NONE      AttachmentStoreOp = 1000301000
)

var (
	reverseAttachmentStoreOp map[AttachmentStoreOp]string = map[AttachmentStoreOp]string{
		VK_ATTACHMENT_STORE_OP_STORE:     "VK_ATTACHMENT_STORE_OP_STORE",
		VK_ATTACHMENT_STORE_OP_DONT_CARE: "VK_ATTACHMENT_STORE_OP_DONT_CARE",
		VK_ATTACHMENT_STORE_OP_NONE:      "VK_ATTACHMENT_STORE_OP_NONE",
	}
)

func (x AttachmentStoreOp) String() string {
	if s, ok := reverseAttachmentStoreOp[x]; ok {
		return s
	}
	return fmt.Sprintf("AttachmentStoreOp=%d", x)
}

// PrimitiveTopology enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPrimitiveTopology.html
type PrimitiveTopology uint32

const (
	VK_PRIMITIVE_TOPOLOGY_POINT_LIST                    PrimitiveTopology = 0
	VK_PRIMITIVE_TOPOLOGY_LINE_LIST                     PrimitiveTopology = 1
	VK_PRIMITIVE_TOPOLOGY_LINE_STRIP                    PrimitiveTopology = 2
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST                 PrimitiveTopology = 3
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP                PrimitiveTopology = 4
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN                  PrimitiveTopology = 5
	VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY      PrimitiveTopology = 6
	VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY     PrimitiveTopology = 7
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY  PrimitiveTopology = 8
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY PrimitiveTopology = 9
	VK_PRIMITIVE_TOPOLOGY_PATCH_LIST                    PrimitiveTopology = 10
)

var (
	reversePrimitiveTopology map[PrimitiveTopology]string = map[PrimitiveTopology]string{
		VK_PRIMITIVE_TOPOLOGY_POINT_LIST:                    "VK_PRIMITIVE_TOPOLOGY_POINT_LIST",
		VK_PRIMITIVE_TOPOLOGY_LINE_LIST:                     "VK_PRIMITIVE_TOPOLOGY_LINE_LIST",
		VK_PRIMITIVE_TOPOLOGY_LINE_STRIP:                    "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP",
		VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST:                 "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST",
		VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP:                "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP",
		VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN:                  "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN",
		VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY:      "VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY",
		VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY:     "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY",
		VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY:  "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY",
		VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY: "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY",
		VK_PRIMITIVE_TOPOLOGY_PATCH_LIST:                    "VK_PRIMITIVE_TOPOLOGY_PATCH_LIST",
	}
)

func (x PrimitiveTopology) String() string {
	if s, ok := reversePrimitiveTopology[x]; ok {
		return s
	}
	return fmt.Sprintf("PrimitiveTopology=%d", x)
}

// PolygonMode enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPolygonMode.html
type PolygonMode uint32

const (
	VK_POLYGON_MODE_FILL  PolygonMode = 0
	VK_POLYGON_MODE_LINE  PolygonMode = 1
	VK_POLYGON_MODE_POINT PolygonMode = 2
)

var (
	reversePolygonMode map[PolygonMode]string = map[PolygonMode]string{
		VK_POLYGON_MODE_FILL:  "VK_POLYGON_MODE_FILL",
		VK_POLYGON_MODE_LINE:  "VK_POLYGON_MODE_LINE",
		VK_POLYGON_MODE_POINT: "VK_POLYGON_MODE_POINT",
	}
)

func (x PolygonMode) String() string {
	if s, ok := reversePolygonMode[x]; ok {
		return s
	}
	return fmt.Sprintf("PolygonMode=%d", x)
}

// PipelineShaderStageCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageCreateFlagBits.html
type PipelineShaderStageCreateFlagBits uint32

const (
	VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT PipelineShaderStageCreateFlagBits = (1 << 0)
	VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT      PipelineShaderStageCreateFlagBits = (1 << 1)
)

var (
	reversePipelineShaderStageCreateFlagBits map[PipelineShaderStageCreateFlagBits]string = map[PipelineShaderStageCreateFlagBits]string{
		VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT: "VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT",
		VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT:      "VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT",
	}
)

func (x PipelineShaderStageCreateFlagBits) String() string {
	if s, ok := reversePipelineShaderStageCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("PipelineShaderStageCreateFlagBits=%d", x)
}

// PipelineCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreateFlagBits.html
type PipelineCreateFlagBits uint32

const (
	VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT              PipelineCreateFlagBits = (1 << 0)
	VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT                 PipelineCreateFlagBits = (1 << 1)
	VK_PIPELINE_CREATE_DERIVATIVE_BIT                        PipelineCreateFlagBits = (1 << 2)
	VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT      PipelineCreateFlagBits = (1 << 3)
	VK_PIPELINE_CREATE_DISPATCH_BASE_BIT                     PipelineCreateFlagBits = (1 << 4)
	VK_PIPELINE_CREATE_DISPATCH_BASE                         PipelineCreateFlagBits = VK_PIPELINE_CREATE_DISPATCH_BASE_BIT
	VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT PipelineCreateFlagBits = (1 << 8)
	VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT           PipelineCreateFlagBits = (1 << 9)
)

var (
	reversePipelineCreateFlagBits map[PipelineCreateFlagBits]string = map[PipelineCreateFlagBits]string{
		VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT:              "VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT",
		VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT:                 "VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT",
		VK_PIPELINE_CREATE_DERIVATIVE_BIT:                        "VK_PIPELINE_CREATE_DERIVATIVE_BIT",
		VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT:      "VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT",
		VK_PIPELINE_CREATE_DISPATCH_BASE_BIT:                     "VK_PIPELINE_CREATE_DISPATCH_BASE_BIT",
		VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT: "VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT",
		VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT:           "VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT",
	}
)

func (x PipelineCreateFlagBits) String() string {
	if s, ok := reversePipelineCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("PipelineCreateFlagBits=%d", x)
}

// DependencyFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDependencyFlagBits.html
type DependencyFlagBits uint32

const (
	VK_DEPENDENCY_BY_REGION_BIT    DependencyFlagBits = (1 << 0)
	VK_DEPENDENCY_DEVICE_GROUP_BIT DependencyFlagBits = (1 << 2)
	VK_DEPENDENCY_VIEW_LOCAL_BIT   DependencyFlagBits = (1 << 1)
)

var (
	reverseDependencyFlagBits map[DependencyFlagBits]string = map[DependencyFlagBits]string{
		VK_DEPENDENCY_BY_REGION_BIT:    "VK_DEPENDENCY_BY_REGION_BIT",
		VK_DEPENDENCY_DEVICE_GROUP_BIT: "VK_DEPENDENCY_DEVICE_GROUP_BIT",
		VK_DEPENDENCY_VIEW_LOCAL_BIT:   "VK_DEPENDENCY_VIEW_LOCAL_BIT",
	}
)

func (x DependencyFlagBits) String() string {
	if s, ok := reverseDependencyFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("DependencyFlagBits=%d", x)
}

// LogicOp enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkLogicOp.html
type LogicOp uint32

const (
	VK_LOGIC_OP_CLEAR         LogicOp = 0
	VK_LOGIC_OP_AND           LogicOp = 1
	VK_LOGIC_OP_AND_REVERSE   LogicOp = 2
	VK_LOGIC_OP_COPY          LogicOp = 3
	VK_LOGIC_OP_AND_INVERTED  LogicOp = 4
	VK_LOGIC_OP_NO_OP         LogicOp = 5
	VK_LOGIC_OP_XOR           LogicOp = 6
	VK_LOGIC_OP_OR            LogicOp = 7
	VK_LOGIC_OP_NOR           LogicOp = 8
	VK_LOGIC_OP_EQUIVALENT    LogicOp = 9
	VK_LOGIC_OP_INVERT        LogicOp = 10
	VK_LOGIC_OP_OR_REVERSE    LogicOp = 11
	VK_LOGIC_OP_COPY_INVERTED LogicOp = 12
	VK_LOGIC_OP_OR_INVERTED   LogicOp = 13
	VK_LOGIC_OP_NAND          LogicOp = 14
	VK_LOGIC_OP_SET           LogicOp = 15
)

var (
	reverseLogicOp map[LogicOp]string = map[LogicOp]string{
		VK_LOGIC_OP_CLEAR:         "VK_LOGIC_OP_CLEAR",
		VK_LOGIC_OP_AND:           "VK_LOGIC_OP_AND",
		VK_LOGIC_OP_AND_REVERSE:   "VK_LOGIC_OP_AND_REVERSE",
		VK_LOGIC_OP_COPY:          "VK_LOGIC_OP_COPY",
		VK_LOGIC_OP_AND_INVERTED:  "VK_LOGIC_OP_AND_INVERTED",
		VK_LOGIC_OP_NO_OP:         "VK_LOGIC_OP_NO_OP",
		VK_LOGIC_OP_XOR:           "VK_LOGIC_OP_XOR",
		VK_LOGIC_OP_OR:            "VK_LOGIC_OP_OR",
		VK_LOGIC_OP_NOR:           "VK_LOGIC_OP_NOR",
		VK_LOGIC_OP_EQUIVALENT:    "VK_LOGIC_OP_EQUIVALENT",
		VK_LOGIC_OP_INVERT:        "VK_LOGIC_OP_INVERT",
		VK_LOGIC_OP_OR_REVERSE:    "VK_LOGIC_OP_OR_REVERSE",
		VK_LOGIC_OP_COPY_INVERTED: "VK_LOGIC_OP_COPY_INVERTED",
		VK_LOGIC_OP_OR_INVERTED:   "VK_LOGIC_OP_OR_INVERTED",
		VK_LOGIC_OP_NAND:          "VK_LOGIC_OP_NAND",
		VK_LOGIC_OP_SET:           "VK_LOGIC_OP_SET",
	}
)

func (x LogicOp) String() string {
	if s, ok := reverseLogicOp[x]; ok {
		return s
	}
	return fmt.Sprintf("LogicOp=%d", x)
}

// FrontFace enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFrontFace.html
type FrontFace uint32

const (
	VK_FRONT_FACE_COUNTER_CLOCKWISE FrontFace = 0
	VK_FRONT_FACE_CLOCKWISE         FrontFace = 1
)

var (
	reverseFrontFace map[FrontFace]string = map[FrontFace]string{
		VK_FRONT_FACE_COUNTER_CLOCKWISE: "VK_FRONT_FACE_COUNTER_CLOCKWISE",
		VK_FRONT_FACE_CLOCKWISE:         "VK_FRONT_FACE_CLOCKWISE",
	}
)

func (x FrontFace) String() string {
	if s, ok := reverseFrontFace[x]; ok {
		return s
	}
	return fmt.Sprintf("FrontFace=%d", x)
}

// DynamicState enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDynamicState.html
type DynamicState uint32

const (
	VK_DYNAMIC_STATE_VIEWPORT                    DynamicState = 0
	VK_DYNAMIC_STATE_SCISSOR                     DynamicState = 1
	VK_DYNAMIC_STATE_LINE_WIDTH                  DynamicState = 2
	VK_DYNAMIC_STATE_DEPTH_BIAS                  DynamicState = 3
	VK_DYNAMIC_STATE_BLEND_CONSTANTS             DynamicState = 4
	VK_DYNAMIC_STATE_DEPTH_BOUNDS                DynamicState = 5
	VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK        DynamicState = 6
	VK_DYNAMIC_STATE_STENCIL_WRITE_MASK          DynamicState = 7
	VK_DYNAMIC_STATE_STENCIL_REFERENCE           DynamicState = 8
	VK_DYNAMIC_STATE_CULL_MODE                   DynamicState = 1000267000
	VK_DYNAMIC_STATE_FRONT_FACE                  DynamicState = 1000267001
	VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY          DynamicState = 1000267002
	VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT         DynamicState = 1000267003
	VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT          DynamicState = 1000267004
	VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE DynamicState = 1000267005
	VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE           DynamicState = 1000267006
	VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE          DynamicState = 1000267007
	VK_DYNAMIC_STATE_DEPTH_COMPARE_OP            DynamicState = 1000267008
	VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE    DynamicState = 1000267009
	VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE         DynamicState = 1000267010
	VK_DYNAMIC_STATE_STENCIL_OP                  DynamicState = 1000267011
	VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE   DynamicState = 1000377001
	VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE           DynamicState = 1000377002
	VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE    DynamicState = 1000377004
)

var (
	reverseDynamicState map[DynamicState]string = map[DynamicState]string{
		VK_DYNAMIC_STATE_VIEWPORT:                    "VK_DYNAMIC_STATE_VIEWPORT",
		VK_DYNAMIC_STATE_SCISSOR:                     "VK_DYNAMIC_STATE_SCISSOR",
		VK_DYNAMIC_STATE_LINE_WIDTH:                  "VK_DYNAMIC_STATE_LINE_WIDTH",
		VK_DYNAMIC_STATE_DEPTH_BIAS:                  "VK_DYNAMIC_STATE_DEPTH_BIAS",
		VK_DYNAMIC_STATE_BLEND_CONSTANTS:             "VK_DYNAMIC_STATE_BLEND_CONSTANTS",
		VK_DYNAMIC_STATE_DEPTH_BOUNDS:                "VK_DYNAMIC_STATE_DEPTH_BOUNDS",
		VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK:        "VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK",
		VK_DYNAMIC_STATE_STENCIL_WRITE_MASK:          "VK_DYNAMIC_STATE_STENCIL_WRITE_MASK",
		VK_DYNAMIC_STATE_STENCIL_REFERENCE:           "VK_DYNAMIC_STATE_STENCIL_REFERENCE",
		VK_DYNAMIC_STATE_CULL_MODE:                   "VK_DYNAMIC_STATE_CULL_MODE",
		VK_DYNAMIC_STATE_FRONT_FACE:                  "VK_DYNAMIC_STATE_FRONT_FACE",
		VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY:          "VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY",
		VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT:         "VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT",
		VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT:          "VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT",
		VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE: "VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE",
		VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE:           "VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE",
		VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE:          "VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE",
		VK_DYNAMIC_STATE_DEPTH_COMPARE_OP:            "VK_DYNAMIC_STATE_DEPTH_COMPARE_OP",
		VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE:    "VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE",
		VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE:         "VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE",
		VK_DYNAMIC_STATE_STENCIL_OP:                  "VK_DYNAMIC_STATE_STENCIL_OP",
		VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE:   "VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE",
		VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE:           "VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE",
		VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE:    "VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE",
	}
)

func (x DynamicState) String() string {
	if s, ok := reverseDynamicState[x]; ok {
		return s
	}
	return fmt.Sprintf("DynamicState=%d", x)
}

// CullModeFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCullModeFlagBits.html
type CullModeFlagBits uint32

const (
	VK_CULL_MODE_NONE           CullModeFlagBits = 0
	VK_CULL_MODE_FRONT_BIT      CullModeFlagBits = (1 << 0)
	VK_CULL_MODE_BACK_BIT       CullModeFlagBits = (1 << 1)
	VK_CULL_MODE_FRONT_AND_BACK CullModeFlagBits = 0x00000003
)

var (
	reverseCullModeFlagBits map[CullModeFlagBits]string = map[CullModeFlagBits]string{
		VK_CULL_MODE_NONE:           "VK_CULL_MODE_NONE",
		VK_CULL_MODE_FRONT_BIT:      "VK_CULL_MODE_FRONT_BIT",
		VK_CULL_MODE_BACK_BIT:       "VK_CULL_MODE_BACK_BIT",
		VK_CULL_MODE_FRONT_AND_BACK: "VK_CULL_MODE_FRONT_AND_BACK",
	}
)

func (x CullModeFlagBits) String() string {
	if s, ok := reverseCullModeFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("CullModeFlagBits=%d", x)
}

// Format enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormat.html
type Format uint32

const (
	VK_FORMAT_UNDEFINED                                  Format = 0
	VK_FORMAT_R4G4_UNORM_PACK8                           Format = 1
	VK_FORMAT_R4G4B4A4_UNORM_PACK16                      Format = 2
	VK_FORMAT_B4G4R4A4_UNORM_PACK16                      Format = 3
	VK_FORMAT_R5G6B5_UNORM_PACK16                        Format = 4
	VK_FORMAT_B5G6R5_UNORM_PACK16                        Format = 5
	VK_FORMAT_R5G5B5A1_UNORM_PACK16                      Format = 6
	VK_FORMAT_B5G5R5A1_UNORM_PACK16                      Format = 7
	VK_FORMAT_A1R5G5B5_UNORM_PACK16                      Format = 8
	VK_FORMAT_R8_UNORM                                   Format = 9
	VK_FORMAT_R8_SNORM                                   Format = 10
	VK_FORMAT_R8_USCALED                                 Format = 11
	VK_FORMAT_R8_SSCALED                                 Format = 12
	VK_FORMAT_R8_UINT                                    Format = 13
	VK_FORMAT_R8_SINT                                    Format = 14
	VK_FORMAT_R8_SRGB                                    Format = 15
	VK_FORMAT_R8G8_UNORM                                 Format = 16
	VK_FORMAT_R8G8_SNORM                                 Format = 17
	VK_FORMAT_R8G8_USCALED                               Format = 18
	VK_FORMAT_R8G8_SSCALED                               Format = 19
	VK_FORMAT_R8G8_UINT                                  Format = 20
	VK_FORMAT_R8G8_SINT                                  Format = 21
	VK_FORMAT_R8G8_SRGB                                  Format = 22
	VK_FORMAT_R8G8B8_UNORM                               Format = 23
	VK_FORMAT_R8G8B8_SNORM                               Format = 24
	VK_FORMAT_R8G8B8_USCALED                             Format = 25
	VK_FORMAT_R8G8B8_SSCALED                             Format = 26
	VK_FORMAT_R8G8B8_UINT                                Format = 27
	VK_FORMAT_R8G8B8_SINT                                Format = 28
	VK_FORMAT_R8G8B8_SRGB                                Format = 29
	VK_FORMAT_B8G8R8_UNORM                               Format = 30
	VK_FORMAT_B8G8R8_SNORM                               Format = 31
	VK_FORMAT_B8G8R8_USCALED                             Format = 32
	VK_FORMAT_B8G8R8_SSCALED                             Format = 33
	VK_FORMAT_B8G8R8_UINT                                Format = 34
	VK_FORMAT_B8G8R8_SINT                                Format = 35
	VK_FORMAT_B8G8R8_SRGB                                Format = 36
	VK_FORMAT_R8G8B8A8_UNORM                             Format = 37
	VK_FORMAT_R8G8B8A8_SNORM                             Format = 38
	VK_FORMAT_R8G8B8A8_USCALED                           Format = 39
	VK_FORMAT_R8G8B8A8_SSCALED                           Format = 40
	VK_FORMAT_R8G8B8A8_UINT                              Format = 41
	VK_FORMAT_R8G8B8A8_SINT                              Format = 42
	VK_FORMAT_R8G8B8A8_SRGB                              Format = 43
	VK_FORMAT_B8G8R8A8_UNORM                             Format = 44
	VK_FORMAT_B8G8R8A8_SNORM                             Format = 45
	VK_FORMAT_B8G8R8A8_USCALED                           Format = 46
	VK_FORMAT_B8G8R8A8_SSCALED                           Format = 47
	VK_FORMAT_B8G8R8A8_UINT                              Format = 48
	VK_FORMAT_B8G8R8A8_SINT                              Format = 49
	VK_FORMAT_B8G8R8A8_SRGB                              Format = 50
	VK_FORMAT_A8B8G8R8_UNORM_PACK32                      Format = 51
	VK_FORMAT_A8B8G8R8_SNORM_PACK32                      Format = 52
	VK_FORMAT_A8B8G8R8_USCALED_PACK32                    Format = 53
	VK_FORMAT_A8B8G8R8_SSCALED_PACK32                    Format = 54
	VK_FORMAT_A8B8G8R8_UINT_PACK32                       Format = 55
	VK_FORMAT_A8B8G8R8_SINT_PACK32                       Format = 56
	VK_FORMAT_A8B8G8R8_SRGB_PACK32                       Format = 57
	VK_FORMAT_A2R10G10B10_UNORM_PACK32                   Format = 58
	VK_FORMAT_A2R10G10B10_SNORM_PACK32                   Format = 59
	VK_FORMAT_A2R10G10B10_USCALED_PACK32                 Format = 60
	VK_FORMAT_A2R10G10B10_SSCALED_PACK32                 Format = 61
	VK_FORMAT_A2R10G10B10_UINT_PACK32                    Format = 62
	VK_FORMAT_A2R10G10B10_SINT_PACK32                    Format = 63
	VK_FORMAT_A2B10G10R10_UNORM_PACK32                   Format = 64
	VK_FORMAT_A2B10G10R10_SNORM_PACK32                   Format = 65
	VK_FORMAT_A2B10G10R10_USCALED_PACK32                 Format = 66
	VK_FORMAT_A2B10G10R10_SSCALED_PACK32                 Format = 67
	VK_FORMAT_A2B10G10R10_UINT_PACK32                    Format = 68
	VK_FORMAT_A2B10G10R10_SINT_PACK32                    Format = 69
	VK_FORMAT_R16_UNORM                                  Format = 70
	VK_FORMAT_R16_SNORM                                  Format = 71
	VK_FORMAT_R16_USCALED                                Format = 72
	VK_FORMAT_R16_SSCALED                                Format = 73
	VK_FORMAT_R16_UINT                                   Format = 74
	VK_FORMAT_R16_SINT                                   Format = 75
	VK_FORMAT_R16_SFLOAT                                 Format = 76
	VK_FORMAT_R16G16_UNORM                               Format = 77
	VK_FORMAT_R16G16_SNORM                               Format = 78
	VK_FORMAT_R16G16_USCALED                             Format = 79
	VK_FORMAT_R16G16_SSCALED                             Format = 80
	VK_FORMAT_R16G16_UINT                                Format = 81
	VK_FORMAT_R16G16_SINT                                Format = 82
	VK_FORMAT_R16G16_SFLOAT                              Format = 83
	VK_FORMAT_R16G16B16_UNORM                            Format = 84
	VK_FORMAT_R16G16B16_SNORM                            Format = 85
	VK_FORMAT_R16G16B16_USCALED                          Format = 86
	VK_FORMAT_R16G16B16_SSCALED                          Format = 87
	VK_FORMAT_R16G16B16_UINT                             Format = 88
	VK_FORMAT_R16G16B16_SINT                             Format = 89
	VK_FORMAT_R16G16B16_SFLOAT                           Format = 90
	VK_FORMAT_R16G16B16A16_UNORM                         Format = 91
	VK_FORMAT_R16G16B16A16_SNORM                         Format = 92
	VK_FORMAT_R16G16B16A16_USCALED                       Format = 93
	VK_FORMAT_R16G16B16A16_SSCALED                       Format = 94
	VK_FORMAT_R16G16B16A16_UINT                          Format = 95
	VK_FORMAT_R16G16B16A16_SINT                          Format = 96
	VK_FORMAT_R16G16B16A16_SFLOAT                        Format = 97
	VK_FORMAT_R32_UINT                                   Format = 98
	VK_FORMAT_R32_SINT                                   Format = 99
	VK_FORMAT_R32_SFLOAT                                 Format = 100
	VK_FORMAT_R32G32_UINT                                Format = 101
	VK_FORMAT_R32G32_SINT                                Format = 102
	VK_FORMAT_R32G32_SFLOAT                              Format = 103
	VK_FORMAT_R32G32B32_UINT                             Format = 104
	VK_FORMAT_R32G32B32_SINT                             Format = 105
	VK_FORMAT_R32G32B32_SFLOAT                           Format = 106
	VK_FORMAT_R32G32B32A32_UINT                          Format = 107
	VK_FORMAT_R32G32B32A32_SINT                          Format = 108
	VK_FORMAT_R32G32B32A32_SFLOAT                        Format = 109
	VK_FORMAT_R64_UINT                                   Format = 110
	VK_FORMAT_R64_SINT                                   Format = 111
	VK_FORMAT_R64_SFLOAT                                 Format = 112
	VK_FORMAT_R64G64_UINT                                Format = 113
	VK_FORMAT_R64G64_SINT                                Format = 114
	VK_FORMAT_R64G64_SFLOAT                              Format = 115
	VK_FORMAT_R64G64B64_UINT                             Format = 116
	VK_FORMAT_R64G64B64_SINT                             Format = 117
	VK_FORMAT_R64G64B64_SFLOAT                           Format = 118
	VK_FORMAT_R64G64B64A64_UINT                          Format = 119
	VK_FORMAT_R64G64B64A64_SINT                          Format = 120
	VK_FORMAT_R64G64B64A64_SFLOAT                        Format = 121
	VK_FORMAT_B10G11R11_UFLOAT_PACK32                    Format = 122
	VK_FORMAT_E5B9G9R9_UFLOAT_PACK32                     Format = 123
	VK_FORMAT_D16_UNORM                                  Format = 124
	VK_FORMAT_X8_D24_UNORM_PACK32                        Format = 125
	VK_FORMAT_D32_SFLOAT                                 Format = 126
	VK_FORMAT_S8_UINT                                    Format = 127
	VK_FORMAT_D16_UNORM_S8_UINT                          Format = 128
	VK_FORMAT_D24_UNORM_S8_UINT                          Format = 129
	VK_FORMAT_D32_SFLOAT_S8_UINT                         Format = 130
	VK_FORMAT_BC1_RGB_UNORM_BLOCK                        Format = 131
	VK_FORMAT_BC1_RGB_SRGB_BLOCK                         Format = 132
	VK_FORMAT_BC1_RGBA_UNORM_BLOCK                       Format = 133
	VK_FORMAT_BC1_RGBA_SRGB_BLOCK                        Format = 134
	VK_FORMAT_BC2_UNORM_BLOCK                            Format = 135
	VK_FORMAT_BC2_SRGB_BLOCK                             Format = 136
	VK_FORMAT_BC3_UNORM_BLOCK                            Format = 137
	VK_FORMAT_BC3_SRGB_BLOCK                             Format = 138
	VK_FORMAT_BC4_UNORM_BLOCK                            Format = 139
	VK_FORMAT_BC4_SNORM_BLOCK                            Format = 140
	VK_FORMAT_BC5_UNORM_BLOCK                            Format = 141
	VK_FORMAT_BC5_SNORM_BLOCK                            Format = 142
	VK_FORMAT_BC6H_UFLOAT_BLOCK                          Format = 143
	VK_FORMAT_BC6H_SFLOAT_BLOCK                          Format = 144
	VK_FORMAT_BC7_UNORM_BLOCK                            Format = 145
	VK_FORMAT_BC7_SRGB_BLOCK                             Format = 146
	VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK                    Format = 147
	VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK                     Format = 148
	VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK                  Format = 149
	VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK                   Format = 150
	VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK                  Format = 151
	VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK                   Format = 152
	VK_FORMAT_EAC_R11_UNORM_BLOCK                        Format = 153
	VK_FORMAT_EAC_R11_SNORM_BLOCK                        Format = 154
	VK_FORMAT_EAC_R11G11_UNORM_BLOCK                     Format = 155
	VK_FORMAT_EAC_R11G11_SNORM_BLOCK                     Format = 156
	VK_FORMAT_ASTC_4x4_UNORM_BLOCK                       Format = 157
	VK_FORMAT_ASTC_4x4_SRGB_BLOCK                        Format = 158
	VK_FORMAT_ASTC_5x4_UNORM_BLOCK                       Format = 159
	VK_FORMAT_ASTC_5x4_SRGB_BLOCK                        Format = 160
	VK_FORMAT_ASTC_5x5_UNORM_BLOCK                       Format = 161
	VK_FORMAT_ASTC_5x5_SRGB_BLOCK                        Format = 162
	VK_FORMAT_ASTC_6x5_UNORM_BLOCK                       Format = 163
	VK_FORMAT_ASTC_6x5_SRGB_BLOCK                        Format = 164
	VK_FORMAT_ASTC_6x6_UNORM_BLOCK                       Format = 165
	VK_FORMAT_ASTC_6x6_SRGB_BLOCK                        Format = 166
	VK_FORMAT_ASTC_8x5_UNORM_BLOCK                       Format = 167
	VK_FORMAT_ASTC_8x5_SRGB_BLOCK                        Format = 168
	VK_FORMAT_ASTC_8x6_UNORM_BLOCK                       Format = 169
	VK_FORMAT_ASTC_8x6_SRGB_BLOCK                        Format = 170
	VK_FORMAT_ASTC_8x8_UNORM_BLOCK                       Format = 171
	VK_FORMAT_ASTC_8x8_SRGB_BLOCK                        Format = 172
	VK_FORMAT_ASTC_10x5_UNORM_BLOCK                      Format = 173
	VK_FORMAT_ASTC_10x5_SRGB_BLOCK                       Format = 174
	VK_FORMAT_ASTC_10x6_UNORM_BLOCK                      Format = 175
	VK_FORMAT_ASTC_10x6_SRGB_BLOCK                       Format = 176
	VK_FORMAT_ASTC_10x8_UNORM_BLOCK                      Format = 177
	VK_FORMAT_ASTC_10x8_SRGB_BLOCK                       Format = 178
	VK_FORMAT_ASTC_10x10_UNORM_BLOCK                     Format = 179
	VK_FORMAT_ASTC_10x10_SRGB_BLOCK                      Format = 180
	VK_FORMAT_ASTC_12x10_UNORM_BLOCK                     Format = 181
	VK_FORMAT_ASTC_12x10_SRGB_BLOCK                      Format = 182
	VK_FORMAT_ASTC_12x12_UNORM_BLOCK                     Format = 183
	VK_FORMAT_ASTC_12x12_SRGB_BLOCK                      Format = 184
	VK_FORMAT_G8B8G8R8_422_UNORM                         Format = 1000156000
	VK_FORMAT_B8G8R8G8_422_UNORM                         Format = 1000156001
	VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM                  Format = 1000156002
	VK_FORMAT_G8_B8R8_2PLANE_420_UNORM                   Format = 1000156003
	VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM                  Format = 1000156004
	VK_FORMAT_G8_B8R8_2PLANE_422_UNORM                   Format = 1000156005
	VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM                  Format = 1000156006
	VK_FORMAT_R10X6_UNORM_PACK16                         Format = 1000156007
	VK_FORMAT_R10X6G10X6_UNORM_2PACK16                   Format = 1000156008
	VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16         Format = 1000156009
	VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16     Format = 1000156010
	VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16     Format = 1000156011
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 Format = 1000156012
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16  Format = 1000156013
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 Format = 1000156014
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16  Format = 1000156015
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 Format = 1000156016
	VK_FORMAT_R12X4_UNORM_PACK16                         Format = 1000156017
	VK_FORMAT_R12X4G12X4_UNORM_2PACK16                   Format = 1000156018
	VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16         Format = 1000156019
	VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16     Format = 1000156020
	VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16     Format = 1000156021
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 Format = 1000156022
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16  Format = 1000156023
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 Format = 1000156024
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16  Format = 1000156025
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 Format = 1000156026
	VK_FORMAT_G16B16G16R16_422_UNORM                     Format = 1000156027
	VK_FORMAT_B16G16R16G16_422_UNORM                     Format = 1000156028
	VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM               Format = 1000156029
	VK_FORMAT_G16_B16R16_2PLANE_420_UNORM                Format = 1000156030
	VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM               Format = 1000156031
	VK_FORMAT_G16_B16R16_2PLANE_422_UNORM                Format = 1000156032
	VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM               Format = 1000156033
	VK_FORMAT_G8_B8R8_2PLANE_444_UNORM                   Format = 1000330000
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16  Format = 1000330001
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16  Format = 1000330002
	VK_FORMAT_G16_B16R16_2PLANE_444_UNORM                Format = 1000330003
	VK_FORMAT_A4R4G4B4_UNORM_PACK16                      Format = 1000340000
	VK_FORMAT_A4B4G4R4_UNORM_PACK16                      Format = 1000340001
	VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK                      Format = 1000066000
	VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK                      Format = 1000066001
	VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK                      Format = 1000066002
	VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK                      Format = 1000066003
	VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK                      Format = 1000066004
	VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK                      Format = 1000066005
	VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK                      Format = 1000066006
	VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK                      Format = 1000066007
	VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK                     Format = 1000066008
	VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK                     Format = 1000066009
	VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK                     Format = 1000066010
	VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK                    Format = 1000066011
	VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK                    Format = 1000066012
	VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK                    Format = 1000066013
)

var (
	reverseFormat map[Format]string = map[Format]string{
		VK_FORMAT_UNDEFINED:                                  "VK_FORMAT_UNDEFINED",
		VK_FORMAT_R4G4_UNORM_PACK8:                           "VK_FORMAT_R4G4_UNORM_PACK8",
		VK_FORMAT_R4G4B4A4_UNORM_PACK16:                      "VK_FORMAT_R4G4B4A4_UNORM_PACK16",
		VK_FORMAT_B4G4R4A4_UNORM_PACK16:                      "VK_FORMAT_B4G4R4A4_UNORM_PACK16",
		VK_FORMAT_R5G6B5_UNORM_PACK16:                        "VK_FORMAT_R5G6B5_UNORM_PACK16",
		VK_FORMAT_B5G6R5_UNORM_PACK16:                        "VK_FORMAT_B5G6R5_UNORM_PACK16",
		VK_FORMAT_R5G5B5A1_UNORM_PACK16:                      "VK_FORMAT_R5G5B5A1_UNORM_PACK16",
		VK_FORMAT_B5G5R5A1_UNORM_PACK16:                      "VK_FORMAT_B5G5R5A1_UNORM_PACK16",
		VK_FORMAT_A1R5G5B5_UNORM_PACK16:                      "VK_FORMAT_A1R5G5B5_UNORM_PACK16",
		VK_FORMAT_R8_UNORM:                                   "VK_FORMAT_R8_UNORM",
		VK_FORMAT_R8_SNORM:                                   "VK_FORMAT_R8_SNORM",
		VK_FORMAT_R8_USCALED:                                 "VK_FORMAT_R8_USCALED",
		VK_FORMAT_R8_SSCALED:                                 "VK_FORMAT_R8_SSCALED",
		VK_FORMAT_R8_UINT:                                    "VK_FORMAT_R8_UINT",
		VK_FORMAT_R8_SINT:                                    "VK_FORMAT_R8_SINT",
		VK_FORMAT_R8_SRGB:                                    "VK_FORMAT_R8_SRGB",
		VK_FORMAT_R8G8_UNORM:                                 "VK_FORMAT_R8G8_UNORM",
		VK_FORMAT_R8G8_SNORM:                                 "VK_FORMAT_R8G8_SNORM",
		VK_FORMAT_R8G8_USCALED:                               "VK_FORMAT_R8G8_USCALED",
		VK_FORMAT_R8G8_SSCALED:                               "VK_FORMAT_R8G8_SSCALED",
		VK_FORMAT_R8G8_UINT:                                  "VK_FORMAT_R8G8_UINT",
		VK_FORMAT_R8G8_SINT:                                  "VK_FORMAT_R8G8_SINT",
		VK_FORMAT_R8G8_SRGB:                                  "VK_FORMAT_R8G8_SRGB",
		VK_FORMAT_R8G8B8_UNORM:                               "VK_FORMAT_R8G8B8_UNORM",
		VK_FORMAT_R8G8B8_SNORM:                               "VK_FORMAT_R8G8B8_SNORM",
		VK_FORMAT_R8G8B8_USCALED:                             "VK_FORMAT_R8G8B8_USCALED",
		VK_FORMAT_R8G8B8_SSCALED:                             "VK_FORMAT_R8G8B8_SSCALED",
		VK_FORMAT_R8G8B8_UINT:                                "VK_FORMAT_R8G8B8_UINT",
		VK_FORMAT_R8G8B8_SINT:                                "VK_FORMAT_R8G8B8_SINT",
		VK_FORMAT_R8G8B8_SRGB:                                "VK_FORMAT_R8G8B8_SRGB",
		VK_FORMAT_B8G8R8_UNORM:                               "VK_FORMAT_B8G8R8_UNORM",
		VK_FORMAT_B8G8R8_SNORM:                               "VK_FORMAT_B8G8R8_SNORM",
		VK_FORMAT_B8G8R8_USCALED:                             "VK_FORMAT_B8G8R8_USCALED",
		VK_FORMAT_B8G8R8_SSCALED:                             "VK_FORMAT_B8G8R8_SSCALED",
		VK_FORMAT_B8G8R8_UINT:                                "VK_FORMAT_B8G8R8_UINT",
		VK_FORMAT_B8G8R8_SINT:                                "VK_FORMAT_B8G8R8_SINT",
		VK_FORMAT_B8G8R8_SRGB:                                "VK_FORMAT_B8G8R8_SRGB",
		VK_FORMAT_R8G8B8A8_UNORM:                             "VK_FORMAT_R8G8B8A8_UNORM",
		VK_FORMAT_R8G8B8A8_SNORM:                             "VK_FORMAT_R8G8B8A8_SNORM",
		VK_FORMAT_R8G8B8A8_USCALED:                           "VK_FORMAT_R8G8B8A8_USCALED",
		VK_FORMAT_R8G8B8A8_SSCALED:                           "VK_FORMAT_R8G8B8A8_SSCALED",
		VK_FORMAT_R8G8B8A8_UINT:                              "VK_FORMAT_R8G8B8A8_UINT",
		VK_FORMAT_R8G8B8A8_SINT:                              "VK_FORMAT_R8G8B8A8_SINT",
		VK_FORMAT_R8G8B8A8_SRGB:                              "VK_FORMAT_R8G8B8A8_SRGB",
		VK_FORMAT_B8G8R8A8_UNORM:                             "VK_FORMAT_B8G8R8A8_UNORM",
		VK_FORMAT_B8G8R8A8_SNORM:                             "VK_FORMAT_B8G8R8A8_SNORM",
		VK_FORMAT_B8G8R8A8_USCALED:                           "VK_FORMAT_B8G8R8A8_USCALED",
		VK_FORMAT_B8G8R8A8_SSCALED:                           "VK_FORMAT_B8G8R8A8_SSCALED",
		VK_FORMAT_B8G8R8A8_UINT:                              "VK_FORMAT_B8G8R8A8_UINT",
		VK_FORMAT_B8G8R8A8_SINT:                              "VK_FORMAT_B8G8R8A8_SINT",
		VK_FORMAT_B8G8R8A8_SRGB:                              "VK_FORMAT_B8G8R8A8_SRGB",
		VK_FORMAT_A8B8G8R8_UNORM_PACK32:                      "VK_FORMAT_A8B8G8R8_UNORM_PACK32",
		VK_FORMAT_A8B8G8R8_SNORM_PACK32:                      "VK_FORMAT_A8B8G8R8_SNORM_PACK32",
		VK_FORMAT_A8B8G8R8_USCALED_PACK32:                    "VK_FORMAT_A8B8G8R8_USCALED_PACK32",
		VK_FORMAT_A8B8G8R8_SSCALED_PACK32:                    "VK_FORMAT_A8B8G8R8_SSCALED_PACK32",
		VK_FORMAT_A8B8G8R8_UINT_PACK32:                       "VK_FORMAT_A8B8G8R8_UINT_PACK32",
		VK_FORMAT_A8B8G8R8_SINT_PACK32:                       "VK_FORMAT_A8B8G8R8_SINT_PACK32",
		VK_FORMAT_A8B8G8R8_SRGB_PACK32:                       "VK_FORMAT_A8B8G8R8_SRGB_PACK32",
		VK_FORMAT_A2R10G10B10_UNORM_PACK32:                   "VK_FORMAT_A2R10G10B10_UNORM_PACK32",
		VK_FORMAT_A2R10G10B10_SNORM_PACK32:                   "VK_FORMAT_A2R10G10B10_SNORM_PACK32",
		VK_FORMAT_A2R10G10B10_USCALED_PACK32:                 "VK_FORMAT_A2R10G10B10_USCALED_PACK32",
		VK_FORMAT_A2R10G10B10_SSCALED_PACK32:                 "VK_FORMAT_A2R10G10B10_SSCALED_PACK32",
		VK_FORMAT_A2R10G10B10_UINT_PACK32:                    "VK_FORMAT_A2R10G10B10_UINT_PACK32",
		VK_FORMAT_A2R10G10B10_SINT_PACK32:                    "VK_FORMAT_A2R10G10B10_SINT_PACK32",
		VK_FORMAT_A2B10G10R10_UNORM_PACK32:                   "VK_FORMAT_A2B10G10R10_UNORM_PACK32",
		VK_FORMAT_A2B10G10R10_SNORM_PACK32:                   "VK_FORMAT_A2B10G10R10_SNORM_PACK32",
		VK_FORMAT_A2B10G10R10_USCALED_PACK32:                 "VK_FORMAT_A2B10G10R10_USCALED_PACK32",
		VK_FORMAT_A2B10G10R10_SSCALED_PACK32:                 "VK_FORMAT_A2B10G10R10_SSCALED_PACK32",
		VK_FORMAT_A2B10G10R10_UINT_PACK32:                    "VK_FORMAT_A2B10G10R10_UINT_PACK32",
		VK_FORMAT_A2B10G10R10_SINT_PACK32:                    "VK_FORMAT_A2B10G10R10_SINT_PACK32",
		VK_FORMAT_R16_UNORM:                                  "VK_FORMAT_R16_UNORM",
		VK_FORMAT_R16_SNORM:                                  "VK_FORMAT_R16_SNORM",
		VK_FORMAT_R16_USCALED:                                "VK_FORMAT_R16_USCALED",
		VK_FORMAT_R16_SSCALED:                                "VK_FORMAT_R16_SSCALED",
		VK_FORMAT_R16_UINT:                                   "VK_FORMAT_R16_UINT",
		VK_FORMAT_R16_SINT:                                   "VK_FORMAT_R16_SINT",
		VK_FORMAT_R16_SFLOAT:                                 "VK_FORMAT_R16_SFLOAT",
		VK_FORMAT_R16G16_UNORM:                               "VK_FORMAT_R16G16_UNORM",
		VK_FORMAT_R16G16_SNORM:                               "VK_FORMAT_R16G16_SNORM",
		VK_FORMAT_R16G16_USCALED:                             "VK_FORMAT_R16G16_USCALED",
		VK_FORMAT_R16G16_SSCALED:                             "VK_FORMAT_R16G16_SSCALED",
		VK_FORMAT_R16G16_UINT:                                "VK_FORMAT_R16G16_UINT",
		VK_FORMAT_R16G16_SINT:                                "VK_FORMAT_R16G16_SINT",
		VK_FORMAT_R16G16_SFLOAT:                              "VK_FORMAT_R16G16_SFLOAT",
		VK_FORMAT_R16G16B16_UNORM:                            "VK_FORMAT_R16G16B16_UNORM",
		VK_FORMAT_R16G16B16_SNORM:                            "VK_FORMAT_R16G16B16_SNORM",
		VK_FORMAT_R16G16B16_USCALED:                          "VK_FORMAT_R16G16B16_USCALED",
		VK_FORMAT_R16G16B16_SSCALED:                          "VK_FORMAT_R16G16B16_SSCALED",
		VK_FORMAT_R16G16B16_UINT:                             "VK_FORMAT_R16G16B16_UINT",
		VK_FORMAT_R16G16B16_SINT:                             "VK_FORMAT_R16G16B16_SINT",
		VK_FORMAT_R16G16B16_SFLOAT:                           "VK_FORMAT_R16G16B16_SFLOAT",
		VK_FORMAT_R16G16B16A16_UNORM:                         "VK_FORMAT_R16G16B16A16_UNORM",
		VK_FORMAT_R16G16B16A16_SNORM:                         "VK_FORMAT_R16G16B16A16_SNORM",
		VK_FORMAT_R16G16B16A16_USCALED:                       "VK_FORMAT_R16G16B16A16_USCALED",
		VK_FORMAT_R16G16B16A16_SSCALED:                       "VK_FORMAT_R16G16B16A16_SSCALED",
		VK_FORMAT_R16G16B16A16_UINT:                          "VK_FORMAT_R16G16B16A16_UINT",
		VK_FORMAT_R16G16B16A16_SINT:                          "VK_FORMAT_R16G16B16A16_SINT",
		VK_FORMAT_R16G16B16A16_SFLOAT:                        "VK_FORMAT_R16G16B16A16_SFLOAT",
		VK_FORMAT_R32_UINT:                                   "VK_FORMAT_R32_UINT",
		VK_FORMAT_R32_SINT:                                   "VK_FORMAT_R32_SINT",
		VK_FORMAT_R32_SFLOAT:                                 "VK_FORMAT_R32_SFLOAT",
		VK_FORMAT_R32G32_UINT:                                "VK_FORMAT_R32G32_UINT",
		VK_FORMAT_R32G32_SINT:                                "VK_FORMAT_R32G32_SINT",
		VK_FORMAT_R32G32_SFLOAT:                              "VK_FORMAT_R32G32_SFLOAT",
		VK_FORMAT_R32G32B32_UINT:                             "VK_FORMAT_R32G32B32_UINT",
		VK_FORMAT_R32G32B32_SINT:                             "VK_FORMAT_R32G32B32_SINT",
		VK_FORMAT_R32G32B32_SFLOAT:                           "VK_FORMAT_R32G32B32_SFLOAT",
		VK_FORMAT_R32G32B32A32_UINT:                          "VK_FORMAT_R32G32B32A32_UINT",
		VK_FORMAT_R32G32B32A32_SINT:                          "VK_FORMAT_R32G32B32A32_SINT",
		VK_FORMAT_R32G32B32A32_SFLOAT:                        "VK_FORMAT_R32G32B32A32_SFLOAT",
		VK_FORMAT_R64_UINT:                                   "VK_FORMAT_R64_UINT",
		VK_FORMAT_R64_SINT:                                   "VK_FORMAT_R64_SINT",
		VK_FORMAT_R64_SFLOAT:                                 "VK_FORMAT_R64_SFLOAT",
		VK_FORMAT_R64G64_UINT:                                "VK_FORMAT_R64G64_UINT",
		VK_FORMAT_R64G64_SINT:                                "VK_FORMAT_R64G64_SINT",
		VK_FORMAT_R64G64_SFLOAT:                              "VK_FORMAT_R64G64_SFLOAT",
		VK_FORMAT_R64G64B64_UINT:                             "VK_FORMAT_R64G64B64_UINT",
		VK_FORMAT_R64G64B64_SINT:                             "VK_FORMAT_R64G64B64_SINT",
		VK_FORMAT_R64G64B64_SFLOAT:                           "VK_FORMAT_R64G64B64_SFLOAT",
		VK_FORMAT_R64G64B64A64_UINT:                          "VK_FORMAT_R64G64B64A64_UINT",
		VK_FORMAT_R64G64B64A64_SINT:                          "VK_FORMAT_R64G64B64A64_SINT",
		VK_FORMAT_R64G64B64A64_SFLOAT:                        "VK_FORMAT_R64G64B64A64_SFLOAT",
		VK_FORMAT_B10G11R11_UFLOAT_PACK32:                    "VK_FORMAT_B10G11R11_UFLOAT_PACK32",
		VK_FORMAT_E5B9G9R9_UFLOAT_PACK32:                     "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32",
		VK_FORMAT_D16_UNORM:                                  "VK_FORMAT_D16_UNORM",
		VK_FORMAT_X8_D24_UNORM_PACK32:                        "VK_FORMAT_X8_D24_UNORM_PACK32",
		VK_FORMAT_D32_SFLOAT:                                 "VK_FORMAT_D32_SFLOAT",
		VK_FORMAT_S8_UINT:                                    "VK_FORMAT_S8_UINT",
		VK_FORMAT_D16_UNORM_S8_UINT:                          "VK_FORMAT_D16_UNORM_S8_UINT",
		VK_FORMAT_D24_UNORM_S8_UINT:                          "VK_FORMAT_D24_UNORM_S8_UINT",
		VK_FORMAT_D32_SFLOAT_S8_UINT:                         "VK_FORMAT_D32_SFLOAT_S8_UINT",
		VK_FORMAT_BC1_RGB_UNORM_BLOCK:                        "VK_FORMAT_BC1_RGB_UNORM_BLOCK",
		VK_FORMAT_BC1_RGB_SRGB_BLOCK:                         "VK_FORMAT_BC1_RGB_SRGB_BLOCK",
		VK_FORMAT_BC1_RGBA_UNORM_BLOCK:                       "VK_FORMAT_BC1_RGBA_UNORM_BLOCK",
		VK_FORMAT_BC1_RGBA_SRGB_BLOCK:                        "VK_FORMAT_BC1_RGBA_SRGB_BLOCK",
		VK_FORMAT_BC2_UNORM_BLOCK:                            "VK_FORMAT_BC2_UNORM_BLOCK",
		VK_FORMAT_BC2_SRGB_BLOCK:                             "VK_FORMAT_BC2_SRGB_BLOCK",
		VK_FORMAT_BC3_UNORM_BLOCK:                            "VK_FORMAT_BC3_UNORM_BLOCK",
		VK_FORMAT_BC3_SRGB_BLOCK:                             "VK_FORMAT_BC3_SRGB_BLOCK",
		VK_FORMAT_BC4_UNORM_BLOCK:                            "VK_FORMAT_BC4_UNORM_BLOCK",
		VK_FORMAT_BC4_SNORM_BLOCK:                            "VK_FORMAT_BC4_SNORM_BLOCK",
		VK_FORMAT_BC5_UNORM_BLOCK:                            "VK_FORMAT_BC5_UNORM_BLOCK",
		VK_FORMAT_BC5_SNORM_BLOCK:                            "VK_FORMAT_BC5_SNORM_BLOCK",
		VK_FORMAT_BC6H_UFLOAT_BLOCK:                          "VK_FORMAT_BC6H_UFLOAT_BLOCK",
		VK_FORMAT_BC6H_SFLOAT_BLOCK:                          "VK_FORMAT_BC6H_SFLOAT_BLOCK",
		VK_FORMAT_BC7_UNORM_BLOCK:                            "VK_FORMAT_BC7_UNORM_BLOCK",
		VK_FORMAT_BC7_SRGB_BLOCK:                             "VK_FORMAT_BC7_SRGB_BLOCK",
		VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK:                    "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK",
		VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK:                     "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK",
		VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK:                  "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK",
		VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK:                   "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK",
		VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK:                  "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK",
		VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK:                   "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK",
		VK_FORMAT_EAC_R11_UNORM_BLOCK:                        "VK_FORMAT_EAC_R11_UNORM_BLOCK",
		VK_FORMAT_EAC_R11_SNORM_BLOCK:                        "VK_FORMAT_EAC_R11_SNORM_BLOCK",
		VK_FORMAT_EAC_R11G11_UNORM_BLOCK:                     "VK_FORMAT_EAC_R11G11_UNORM_BLOCK",
		VK_FORMAT_EAC_R11G11_SNORM_BLOCK:                     "VK_FORMAT_EAC_R11G11_SNORM_BLOCK",
		VK_FORMAT_ASTC_4x4_UNORM_BLOCK:                       "VK_FORMAT_ASTC_4x4_UNORM_BLOCK",
		VK_FORMAT_ASTC_4x4_SRGB_BLOCK:                        "VK_FORMAT_ASTC_4x4_SRGB_BLOCK",
		VK_FORMAT_ASTC_5x4_UNORM_BLOCK:                       "VK_FORMAT_ASTC_5x4_UNORM_BLOCK",
		VK_FORMAT_ASTC_5x4_SRGB_BLOCK:                        "VK_FORMAT_ASTC_5x4_SRGB_BLOCK",
		VK_FORMAT_ASTC_5x5_UNORM_BLOCK:                       "VK_FORMAT_ASTC_5x5_UNORM_BLOCK",
		VK_FORMAT_ASTC_5x5_SRGB_BLOCK:                        "VK_FORMAT_ASTC_5x5_SRGB_BLOCK",
		VK_FORMAT_ASTC_6x5_UNORM_BLOCK:                       "VK_FORMAT_ASTC_6x5_UNORM_BLOCK",
		VK_FORMAT_ASTC_6x5_SRGB_BLOCK:                        "VK_FORMAT_ASTC_6x5_SRGB_BLOCK",
		VK_FORMAT_ASTC_6x6_UNORM_BLOCK:                       "VK_FORMAT_ASTC_6x6_UNORM_BLOCK",
		VK_FORMAT_ASTC_6x6_SRGB_BLOCK:                        "VK_FORMAT_ASTC_6x6_SRGB_BLOCK",
		VK_FORMAT_ASTC_8x5_UNORM_BLOCK:                       "VK_FORMAT_ASTC_8x5_UNORM_BLOCK",
		VK_FORMAT_ASTC_8x5_SRGB_BLOCK:                        "VK_FORMAT_ASTC_8x5_SRGB_BLOCK",
		VK_FORMAT_ASTC_8x6_UNORM_BLOCK:                       "VK_FORMAT_ASTC_8x6_UNORM_BLOCK",
		VK_FORMAT_ASTC_8x6_SRGB_BLOCK:                        "VK_FORMAT_ASTC_8x6_SRGB_BLOCK",
		VK_FORMAT_ASTC_8x8_UNORM_BLOCK:                       "VK_FORMAT_ASTC_8x8_UNORM_BLOCK",
		VK_FORMAT_ASTC_8x8_SRGB_BLOCK:                        "VK_FORMAT_ASTC_8x8_SRGB_BLOCK",
		VK_FORMAT_ASTC_10x5_UNORM_BLOCK:                      "VK_FORMAT_ASTC_10x5_UNORM_BLOCK",
		VK_FORMAT_ASTC_10x5_SRGB_BLOCK:                       "VK_FORMAT_ASTC_10x5_SRGB_BLOCK",
		VK_FORMAT_ASTC_10x6_UNORM_BLOCK:                      "VK_FORMAT_ASTC_10x6_UNORM_BLOCK",
		VK_FORMAT_ASTC_10x6_SRGB_BLOCK:                       "VK_FORMAT_ASTC_10x6_SRGB_BLOCK",
		VK_FORMAT_ASTC_10x8_UNORM_BLOCK:                      "VK_FORMAT_ASTC_10x8_UNORM_BLOCK",
		VK_FORMAT_ASTC_10x8_SRGB_BLOCK:                       "VK_FORMAT_ASTC_10x8_SRGB_BLOCK",
		VK_FORMAT_ASTC_10x10_UNORM_BLOCK:                     "VK_FORMAT_ASTC_10x10_UNORM_BLOCK",
		VK_FORMAT_ASTC_10x10_SRGB_BLOCK:                      "VK_FORMAT_ASTC_10x10_SRGB_BLOCK",
		VK_FORMAT_ASTC_12x10_UNORM_BLOCK:                     "VK_FORMAT_ASTC_12x10_UNORM_BLOCK",
		VK_FORMAT_ASTC_12x10_SRGB_BLOCK:                      "VK_FORMAT_ASTC_12x10_SRGB_BLOCK",
		VK_FORMAT_ASTC_12x12_UNORM_BLOCK:                     "VK_FORMAT_ASTC_12x12_UNORM_BLOCK",
		VK_FORMAT_ASTC_12x12_SRGB_BLOCK:                      "VK_FORMAT_ASTC_12x12_SRGB_BLOCK",
		VK_FORMAT_G8B8G8R8_422_UNORM:                         "VK_FORMAT_G8B8G8R8_422_UNORM",
		VK_FORMAT_B8G8R8G8_422_UNORM:                         "VK_FORMAT_B8G8R8G8_422_UNORM",
		VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM:                  "VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM",
		VK_FORMAT_G8_B8R8_2PLANE_420_UNORM:                   "VK_FORMAT_G8_B8R8_2PLANE_420_UNORM",
		VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM:                  "VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM",
		VK_FORMAT_G8_B8R8_2PLANE_422_UNORM:                   "VK_FORMAT_G8_B8R8_2PLANE_422_UNORM",
		VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM:                  "VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM",
		VK_FORMAT_R10X6_UNORM_PACK16:                         "VK_FORMAT_R10X6_UNORM_PACK16",
		VK_FORMAT_R10X6G10X6_UNORM_2PACK16:                   "VK_FORMAT_R10X6G10X6_UNORM_2PACK16",
		VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16:         "VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16",
		VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16:     "VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16",
		VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16:     "VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16",
		VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16: "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16",
		VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16:  "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16",
		VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16: "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16",
		VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16:  "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16",
		VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16: "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16",
		VK_FORMAT_R12X4_UNORM_PACK16:                         "VK_FORMAT_R12X4_UNORM_PACK16",
		VK_FORMAT_R12X4G12X4_UNORM_2PACK16:                   "VK_FORMAT_R12X4G12X4_UNORM_2PACK16",
		VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16:         "VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16",
		VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16:     "VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16",
		VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16:     "VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16",
		VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16: "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16",
		VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16:  "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16",
		VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16: "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16",
		VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16:  "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16",
		VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16: "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16",
		VK_FORMAT_G16B16G16R16_422_UNORM:                     "VK_FORMAT_G16B16G16R16_422_UNORM",
		VK_FORMAT_B16G16R16G16_422_UNORM:                     "VK_FORMAT_B16G16R16G16_422_UNORM",
		VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM:               "VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM",
		VK_FORMAT_G16_B16R16_2PLANE_420_UNORM:                "VK_FORMAT_G16_B16R16_2PLANE_420_UNORM",
		VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM:               "VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM",
		VK_FORMAT_G16_B16R16_2PLANE_422_UNORM:                "VK_FORMAT_G16_B16R16_2PLANE_422_UNORM",
		VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM:               "VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM",
		VK_FORMAT_G8_B8R8_2PLANE_444_UNORM:                   "VK_FORMAT_G8_B8R8_2PLANE_444_UNORM",
		VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16:  "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16",
		VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16:  "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16",
		VK_FORMAT_G16_B16R16_2PLANE_444_UNORM:                "VK_FORMAT_G16_B16R16_2PLANE_444_UNORM",
		VK_FORMAT_A4R4G4B4_UNORM_PACK16:                      "VK_FORMAT_A4R4G4B4_UNORM_PACK16",
		VK_FORMAT_A4B4G4R4_UNORM_PACK16:                      "VK_FORMAT_A4B4G4R4_UNORM_PACK16",
		VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK:                      "VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK",
		VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK:                      "VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK",
		VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK:                      "VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK",
		VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK:                      "VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK",
		VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK:                      "VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK",
		VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK:                      "VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK",
		VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK:                      "VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK",
		VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK:                      "VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK",
		VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK:                     "VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK",
		VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK:                     "VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK",
		VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK:                     "VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK",
		VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK:                    "VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK",
		VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK:                    "VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK",
		VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK:                    "VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK",
	}
)

func (x Format) String() string {
	if s, ok := reverseFormat[x]; ok {
		return s
	}
	return fmt.Sprintf("Format=%d", x)
}

// FormatFeatureFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatFeatureFlagBits.html
type FormatFeatureFlagBits uint32

const (
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT                                                           FormatFeatureFlagBits = (1 << 0)
	VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT                                                           FormatFeatureFlagBits = (1 << 1)
	VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT                                                    FormatFeatureFlagBits = (1 << 2)
	VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT                                                    FormatFeatureFlagBits = (1 << 3)
	VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT                                                    FormatFeatureFlagBits = (1 << 4)
	VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT                                             FormatFeatureFlagBits = (1 << 5)
	VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT                                                           FormatFeatureFlagBits = (1 << 6)
	VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT                                                        FormatFeatureFlagBits = (1 << 7)
	VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT                                                  FormatFeatureFlagBits = (1 << 8)
	VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT                                                FormatFeatureFlagBits = (1 << 9)
	VK_FORMAT_FEATURE_BLIT_SRC_BIT                                                                FormatFeatureFlagBits = (1 << 10)
	VK_FORMAT_FEATURE_BLIT_DST_BIT                                                                FormatFeatureFlagBits = (1 << 11)
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT                                             FormatFeatureFlagBits = (1 << 12)
	VK_FORMAT_FEATURE_TRANSFER_SRC_BIT                                                            FormatFeatureFlagBits = (1 << 14)
	VK_FORMAT_FEATURE_TRANSFER_DST_BIT                                                            FormatFeatureFlagBits = (1 << 15)
	VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT                                                 FormatFeatureFlagBits = (1 << 17)
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT                            FormatFeatureFlagBits = (1 << 18)
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT           FormatFeatureFlagBits = (1 << 19)
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT           FormatFeatureFlagBits = (1 << 20)
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT FormatFeatureFlagBits = (1 << 21)
	VK_FORMAT_FEATURE_DISJOINT_BIT                                                                FormatFeatureFlagBits = (1 << 22)
	VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT                                                  FormatFeatureFlagBits = (1 << 23)
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT                                             FormatFeatureFlagBits = (1 << 16)
)

var (
	reverseFormatFeatureFlagBits map[FormatFeatureFlagBits]string = map[FormatFeatureFlagBits]string{
		VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT:                                                           "VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT",
		VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT:                                                           "VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT",
		VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT:                                                    "VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT",
		VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT:                                                    "VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT",
		VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT:                                                    "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT",
		VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT:                                             "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT",
		VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT:                                                           "VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT",
		VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT:                                                        "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT",
		VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT:                                                  "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT",
		VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT:                                                "VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT",
		VK_FORMAT_FEATURE_BLIT_SRC_BIT:                                                                "VK_FORMAT_FEATURE_BLIT_SRC_BIT",
		VK_FORMAT_FEATURE_BLIT_DST_BIT:                                                                "VK_FORMAT_FEATURE_BLIT_DST_BIT",
		VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT:                                             "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT",
		VK_FORMAT_FEATURE_TRANSFER_SRC_BIT:                                                            "VK_FORMAT_FEATURE_TRANSFER_SRC_BIT",
		VK_FORMAT_FEATURE_TRANSFER_DST_BIT:                                                            "VK_FORMAT_FEATURE_TRANSFER_DST_BIT",
		VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT:                                                 "VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT",
		VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT:                            "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT",
		VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT:           "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT",
		VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT:           "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT",
		VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT: "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT",
		VK_FORMAT_FEATURE_DISJOINT_BIT:                                                                "VK_FORMAT_FEATURE_DISJOINT_BIT",
		VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT:                                                  "VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT",
		VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT:                                             "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT",
	}
)

func (x FormatFeatureFlagBits) String() string {
	if s, ok := reverseFormatFeatureFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("FormatFeatureFlagBits=%d", x)
}

// CompareOp enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCompareOp.html
type CompareOp uint32

const (
	VK_COMPARE_OP_NEVER            CompareOp = 0
	VK_COMPARE_OP_LESS             CompareOp = 1
	VK_COMPARE_OP_EQUAL            CompareOp = 2
	VK_COMPARE_OP_LESS_OR_EQUAL    CompareOp = 3
	VK_COMPARE_OP_GREATER          CompareOp = 4
	VK_COMPARE_OP_NOT_EQUAL        CompareOp = 5
	VK_COMPARE_OP_GREATER_OR_EQUAL CompareOp = 6
	VK_COMPARE_OP_ALWAYS           CompareOp = 7
)

var (
	reverseCompareOp map[CompareOp]string = map[CompareOp]string{
		VK_COMPARE_OP_NEVER:            "VK_COMPARE_OP_NEVER",
		VK_COMPARE_OP_LESS:             "VK_COMPARE_OP_LESS",
		VK_COMPARE_OP_EQUAL:            "VK_COMPARE_OP_EQUAL",
		VK_COMPARE_OP_LESS_OR_EQUAL:    "VK_COMPARE_OP_LESS_OR_EQUAL",
		VK_COMPARE_OP_GREATER:          "VK_COMPARE_OP_GREATER",
		VK_COMPARE_OP_NOT_EQUAL:        "VK_COMPARE_OP_NOT_EQUAL",
		VK_COMPARE_OP_GREATER_OR_EQUAL: "VK_COMPARE_OP_GREATER_OR_EQUAL",
		VK_COMPARE_OP_ALWAYS:           "VK_COMPARE_OP_ALWAYS",
	}
)

func (x CompareOp) String() string {
	if s, ok := reverseCompareOp[x]; ok {
		return s
	}
	return fmt.Sprintf("CompareOp=%d", x)
}

// ColorComponentFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkColorComponentFlagBits.html
type ColorComponentFlagBits uint32

const (
	VK_COLOR_COMPONENT_R_BIT ColorComponentFlagBits = (1 << 0)
	VK_COLOR_COMPONENT_G_BIT ColorComponentFlagBits = (1 << 1)
	VK_COLOR_COMPONENT_B_BIT ColorComponentFlagBits = (1 << 2)
	VK_COLOR_COMPONENT_A_BIT ColorComponentFlagBits = (1 << 3)
)

var (
	reverseColorComponentFlagBits map[ColorComponentFlagBits]string = map[ColorComponentFlagBits]string{
		VK_COLOR_COMPONENT_R_BIT: "VK_COLOR_COMPONENT_R_BIT",
		VK_COLOR_COMPONENT_G_BIT: "VK_COLOR_COMPONENT_G_BIT",
		VK_COLOR_COMPONENT_B_BIT: "VK_COLOR_COMPONENT_B_BIT",
		VK_COLOR_COMPONENT_A_BIT: "VK_COLOR_COMPONENT_A_BIT",
	}
)

func (x ColorComponentFlagBits) String() string {
	if s, ok := reverseColorComponentFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ColorComponentFlagBits=%d", x)
}

// ImageCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCreateFlagBits.html
type ImageCreateFlagBits uint32

const (
	VK_IMAGE_CREATE_SPARSE_BINDING_BIT              ImageCreateFlagBits = (1 << 0)
	VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT            ImageCreateFlagBits = (1 << 1)
	VK_IMAGE_CREATE_SPARSE_ALIASED_BIT              ImageCreateFlagBits = (1 << 2)
	VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT              ImageCreateFlagBits = (1 << 3)
	VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT             ImageCreateFlagBits = (1 << 4)
	VK_IMAGE_CREATE_ALIAS_BIT                       ImageCreateFlagBits = (1 << 10)
	VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT ImageCreateFlagBits = (1 << 6)
	VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT         ImageCreateFlagBits = (1 << 5)
	VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT ImageCreateFlagBits = (1 << 7)
	VK_IMAGE_CREATE_EXTENDED_USAGE_BIT              ImageCreateFlagBits = (1 << 8)
	VK_IMAGE_CREATE_PROTECTED_BIT                   ImageCreateFlagBits = (1 << 11)
	VK_IMAGE_CREATE_DISJOINT_BIT                    ImageCreateFlagBits = (1 << 9)
)

var (
	reverseImageCreateFlagBits map[ImageCreateFlagBits]string = map[ImageCreateFlagBits]string{
		VK_IMAGE_CREATE_SPARSE_BINDING_BIT:              "VK_IMAGE_CREATE_SPARSE_BINDING_BIT",
		VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT:            "VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT",
		VK_IMAGE_CREATE_SPARSE_ALIASED_BIT:              "VK_IMAGE_CREATE_SPARSE_ALIASED_BIT",
		VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT:              "VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT",
		VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT:             "VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT",
		VK_IMAGE_CREATE_ALIAS_BIT:                       "VK_IMAGE_CREATE_ALIAS_BIT",
		VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT: "VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT",
		VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT:         "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT",
		VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT: "VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT",
		VK_IMAGE_CREATE_EXTENDED_USAGE_BIT:              "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT",
		VK_IMAGE_CREATE_PROTECTED_BIT:                   "VK_IMAGE_CREATE_PROTECTED_BIT",
		VK_IMAGE_CREATE_DISJOINT_BIT:                    "VK_IMAGE_CREATE_DISJOINT_BIT",
	}
)

func (x ImageCreateFlagBits) String() string {
	if s, ok := reverseImageCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ImageCreateFlagBits=%d", x)
}

// BlendOp enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBlendOp.html
type BlendOp uint32

const (
	VK_BLEND_OP_ADD              BlendOp = 0
	VK_BLEND_OP_SUBTRACT         BlendOp = 1
	VK_BLEND_OP_REVERSE_SUBTRACT BlendOp = 2
	VK_BLEND_OP_MIN              BlendOp = 3
	VK_BLEND_OP_MAX              BlendOp = 4
)

var (
	reverseBlendOp map[BlendOp]string = map[BlendOp]string{
		VK_BLEND_OP_ADD:              "VK_BLEND_OP_ADD",
		VK_BLEND_OP_SUBTRACT:         "VK_BLEND_OP_SUBTRACT",
		VK_BLEND_OP_REVERSE_SUBTRACT: "VK_BLEND_OP_REVERSE_SUBTRACT",
		VK_BLEND_OP_MIN:              "VK_BLEND_OP_MIN",
		VK_BLEND_OP_MAX:              "VK_BLEND_OP_MAX",
	}
)

func (x BlendOp) String() string {
	if s, ok := reverseBlendOp[x]; ok {
		return s
	}
	return fmt.Sprintf("BlendOp=%d", x)
}

// BlendFactor enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBlendFactor.html
type BlendFactor uint32

const (
	VK_BLEND_FACTOR_ZERO                     BlendFactor = 0
	VK_BLEND_FACTOR_ONE                      BlendFactor = 1
	VK_BLEND_FACTOR_SRC_COLOR                BlendFactor = 2
	VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR      BlendFactor = 3
	VK_BLEND_FACTOR_DST_COLOR                BlendFactor = 4
	VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR      BlendFactor = 5
	VK_BLEND_FACTOR_SRC_ALPHA                BlendFactor = 6
	VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA      BlendFactor = 7
	VK_BLEND_FACTOR_DST_ALPHA                BlendFactor = 8
	VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA      BlendFactor = 9
	VK_BLEND_FACTOR_CONSTANT_COLOR           BlendFactor = 10
	VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR BlendFactor = 11
	VK_BLEND_FACTOR_CONSTANT_ALPHA           BlendFactor = 12
	VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA BlendFactor = 13
	VK_BLEND_FACTOR_SRC_ALPHA_SATURATE       BlendFactor = 14
	VK_BLEND_FACTOR_SRC1_COLOR               BlendFactor = 15
	VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR     BlendFactor = 16
	VK_BLEND_FACTOR_SRC1_ALPHA               BlendFactor = 17
	VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA     BlendFactor = 18
)

var (
	reverseBlendFactor map[BlendFactor]string = map[BlendFactor]string{
		VK_BLEND_FACTOR_ZERO:                     "VK_BLEND_FACTOR_ZERO",
		VK_BLEND_FACTOR_ONE:                      "VK_BLEND_FACTOR_ONE",
		VK_BLEND_FACTOR_SRC_COLOR:                "VK_BLEND_FACTOR_SRC_COLOR",
		VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR:      "VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR",
		VK_BLEND_FACTOR_DST_COLOR:                "VK_BLEND_FACTOR_DST_COLOR",
		VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR:      "VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR",
		VK_BLEND_FACTOR_SRC_ALPHA:                "VK_BLEND_FACTOR_SRC_ALPHA",
		VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA:      "VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA",
		VK_BLEND_FACTOR_DST_ALPHA:                "VK_BLEND_FACTOR_DST_ALPHA",
		VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA:      "VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA",
		VK_BLEND_FACTOR_CONSTANT_COLOR:           "VK_BLEND_FACTOR_CONSTANT_COLOR",
		VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR: "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR",
		VK_BLEND_FACTOR_CONSTANT_ALPHA:           "VK_BLEND_FACTOR_CONSTANT_ALPHA",
		VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA: "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA",
		VK_BLEND_FACTOR_SRC_ALPHA_SATURATE:       "VK_BLEND_FACTOR_SRC_ALPHA_SATURATE",
		VK_BLEND_FACTOR_SRC1_COLOR:               "VK_BLEND_FACTOR_SRC1_COLOR",
		VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR:     "VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR",
		VK_BLEND_FACTOR_SRC1_ALPHA:               "VK_BLEND_FACTOR_SRC1_ALPHA",
		VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA:     "VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA",
	}
)

func (x BlendFactor) String() string {
	if s, ok := reverseBlendFactor[x]; ok {
		return s
	}
	return fmt.Sprintf("BlendFactor=%d", x)
}

// ImageTiling enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageTiling.html
type ImageTiling uint32

const (
	VK_IMAGE_TILING_OPTIMAL ImageTiling = 0
	VK_IMAGE_TILING_LINEAR  ImageTiling = 1
)

var (
	reverseImageTiling map[ImageTiling]string = map[ImageTiling]string{
		VK_IMAGE_TILING_OPTIMAL: "VK_IMAGE_TILING_OPTIMAL",
		VK_IMAGE_TILING_LINEAR:  "VK_IMAGE_TILING_LINEAR",
	}
)

func (x ImageTiling) String() string {
	if s, ok := reverseImageTiling[x]; ok {
		return s
	}
	return fmt.Sprintf("ImageTiling=%d", x)
}

// ImageType enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageType.html
type ImageType uint32

const (
	VK_IMAGE_TYPE_1D ImageType = 0
	VK_IMAGE_TYPE_2D ImageType = 1
	VK_IMAGE_TYPE_3D ImageType = 2
)

var (
	reverseImageType map[ImageType]string = map[ImageType]string{
		VK_IMAGE_TYPE_1D: "VK_IMAGE_TYPE_1D",
		VK_IMAGE_TYPE_2D: "VK_IMAGE_TYPE_2D",
		VK_IMAGE_TYPE_3D: "VK_IMAGE_TYPE_3D",
	}
)

func (x ImageType) String() string {
	if s, ok := reverseImageType[x]; ok {
		return s
	}
	return fmt.Sprintf("ImageType=%d", x)
}

// ImageUsageFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageUsageFlagBits.html
type ImageUsageFlagBits uint32

const (
	VK_IMAGE_USAGE_TRANSFER_SRC_BIT             ImageUsageFlagBits = (1 << 0)
	VK_IMAGE_USAGE_TRANSFER_DST_BIT             ImageUsageFlagBits = (1 << 1)
	VK_IMAGE_USAGE_SAMPLED_BIT                  ImageUsageFlagBits = (1 << 2)
	VK_IMAGE_USAGE_STORAGE_BIT                  ImageUsageFlagBits = (1 << 3)
	VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT         ImageUsageFlagBits = (1 << 4)
	VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT ImageUsageFlagBits = (1 << 5)
	VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT     ImageUsageFlagBits = (1 << 6)
	VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT         ImageUsageFlagBits = (1 << 7)
)

var (
	reverseImageUsageFlagBits map[ImageUsageFlagBits]string = map[ImageUsageFlagBits]string{
		VK_IMAGE_USAGE_TRANSFER_SRC_BIT:             "VK_IMAGE_USAGE_TRANSFER_SRC_BIT",
		VK_IMAGE_USAGE_TRANSFER_DST_BIT:             "VK_IMAGE_USAGE_TRANSFER_DST_BIT",
		VK_IMAGE_USAGE_SAMPLED_BIT:                  "VK_IMAGE_USAGE_SAMPLED_BIT",
		VK_IMAGE_USAGE_STORAGE_BIT:                  "VK_IMAGE_USAGE_STORAGE_BIT",
		VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT:         "VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT",
		VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT: "VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT",
		VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT:     "VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT",
		VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT:         "VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT",
	}
)

func (x ImageUsageFlagBits) String() string {
	if s, ok := reverseImageUsageFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ImageUsageFlagBits=%d", x)
}

// VendorId enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVendorId.html
type VendorId uint32

const (
	VK_VENDOR_ID_VIV      VendorId = 0x10001
	VK_VENDOR_ID_VSI      VendorId = 0x10002
	VK_VENDOR_ID_KAZAN    VendorId = 0x10003
	VK_VENDOR_ID_CODEPLAY VendorId = 0x10004
	VK_VENDOR_ID_MESA     VendorId = 0x10005
	VK_VENDOR_ID_POCL     VendorId = 0x10006
	VK_VENDOR_ID_MOBILEYE VendorId = 0x10007
)

var (
	reverseVendorId map[VendorId]string = map[VendorId]string{
		VK_VENDOR_ID_VIV:      "VK_VENDOR_ID_VIV",
		VK_VENDOR_ID_VSI:      "VK_VENDOR_ID_VSI",
		VK_VENDOR_ID_KAZAN:    "VK_VENDOR_ID_KAZAN",
		VK_VENDOR_ID_CODEPLAY: "VK_VENDOR_ID_CODEPLAY",
		VK_VENDOR_ID_MESA:     "VK_VENDOR_ID_MESA",
		VK_VENDOR_ID_POCL:     "VK_VENDOR_ID_POCL",
		VK_VENDOR_ID_MOBILEYE: "VK_VENDOR_ID_MOBILEYE",
	}
)

func (x VendorId) String() string {
	if s, ok := reverseVendorId[x]; ok {
		return s
	}
	return fmt.Sprintf("VendorId=%d", x)
}

// PipelineBindPoint enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineBindPoint.html
type PipelineBindPoint uint32

const (
	VK_PIPELINE_BIND_POINT_GRAPHICS PipelineBindPoint = 0
	VK_PIPELINE_BIND_POINT_COMPUTE  PipelineBindPoint = 1
)

var (
	reversePipelineBindPoint map[PipelineBindPoint]string = map[PipelineBindPoint]string{
		VK_PIPELINE_BIND_POINT_GRAPHICS: "VK_PIPELINE_BIND_POINT_GRAPHICS",
		VK_PIPELINE_BIND_POINT_COMPUTE:  "VK_PIPELINE_BIND_POINT_COMPUTE",
	}
)

func (x PipelineBindPoint) String() string {
	if s, ok := reversePipelineBindPoint[x]; ok {
		return s
	}
	return fmt.Sprintf("PipelineBindPoint=%d", x)
}

// RenderPassCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreateFlagBits.html
type RenderPassCreateFlagBits uint32

// InstanceCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateFlagBits.html
type InstanceCreateFlagBits uint32

const (
	VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR InstanceCreateFlagBits = (1 << 0)
)

var (
	reverseInstanceCreateFlagBits map[InstanceCreateFlagBits]string = map[InstanceCreateFlagBits]string{
		VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR: "VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR",
	}
)

func (x InstanceCreateFlagBits) String() string {
	if s, ok := reverseInstanceCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("InstanceCreateFlagBits=%d", x)
}

// ImageViewType enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewType.html
type ImageViewType uint32

const (
	VK_IMAGE_VIEW_TYPE_1D         ImageViewType = 0
	VK_IMAGE_VIEW_TYPE_2D         ImageViewType = 1
	VK_IMAGE_VIEW_TYPE_3D         ImageViewType = 2
	VK_IMAGE_VIEW_TYPE_CUBE       ImageViewType = 3
	VK_IMAGE_VIEW_TYPE_1D_ARRAY   ImageViewType = 4
	VK_IMAGE_VIEW_TYPE_2D_ARRAY   ImageViewType = 5
	VK_IMAGE_VIEW_TYPE_CUBE_ARRAY ImageViewType = 6
)

var (
	reverseImageViewType map[ImageViewType]string = map[ImageViewType]string{
		VK_IMAGE_VIEW_TYPE_1D:         "VK_IMAGE_VIEW_TYPE_1D",
		VK_IMAGE_VIEW_TYPE_2D:         "VK_IMAGE_VIEW_TYPE_2D",
		VK_IMAGE_VIEW_TYPE_3D:         "VK_IMAGE_VIEW_TYPE_3D",
		VK_IMAGE_VIEW_TYPE_CUBE:       "VK_IMAGE_VIEW_TYPE_CUBE",
		VK_IMAGE_VIEW_TYPE_1D_ARRAY:   "VK_IMAGE_VIEW_TYPE_1D_ARRAY",
		VK_IMAGE_VIEW_TYPE_2D_ARRAY:   "VK_IMAGE_VIEW_TYPE_2D_ARRAY",
		VK_IMAGE_VIEW_TYPE_CUBE_ARRAY: "VK_IMAGE_VIEW_TYPE_CUBE_ARRAY",
	}
)

func (x ImageViewType) String() string {
	if s, ok := reverseImageViewType[x]; ok {
		return s
	}
	return fmt.Sprintf("ImageViewType=%d", x)
}

// InternalAllocationType enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInternalAllocationType.html
type InternalAllocationType uint32

const (
	VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE InternalAllocationType = 0
)

var (
	reverseInternalAllocationType map[InternalAllocationType]string = map[InternalAllocationType]string{
		VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE: "VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE",
	}
)

func (x InternalAllocationType) String() string {
	if s, ok := reverseInternalAllocationType[x]; ok {
		return s
	}
	return fmt.Sprintf("InternalAllocationType=%d", x)
}

// ImageViewCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateFlagBits.html
type ImageViewCreateFlagBits uint32

// MemoryHeapFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryHeapFlagBits.html
type MemoryHeapFlagBits uint32

const (
	VK_MEMORY_HEAP_DEVICE_LOCAL_BIT   MemoryHeapFlagBits = (1 << 0)
	VK_MEMORY_HEAP_MULTI_INSTANCE_BIT MemoryHeapFlagBits = (1 << 1)
)

var (
	reverseMemoryHeapFlagBits map[MemoryHeapFlagBits]string = map[MemoryHeapFlagBits]string{
		VK_MEMORY_HEAP_DEVICE_LOCAL_BIT:   "VK_MEMORY_HEAP_DEVICE_LOCAL_BIT",
		VK_MEMORY_HEAP_MULTI_INSTANCE_BIT: "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT",
	}
)

func (x MemoryHeapFlagBits) String() string {
	if s, ok := reverseMemoryHeapFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("MemoryHeapFlagBits=%d", x)
}

// SubpassDescriptionFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDescriptionFlagBits.html
type SubpassDescriptionFlagBits uint32

// MemoryPropertyFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryPropertyFlagBits.html
type MemoryPropertyFlagBits uint32

const (
	VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT     MemoryPropertyFlagBits = (1 << 0)
	VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT     MemoryPropertyFlagBits = (1 << 1)
	VK_MEMORY_PROPERTY_HOST_COHERENT_BIT    MemoryPropertyFlagBits = (1 << 2)
	VK_MEMORY_PROPERTY_HOST_CACHED_BIT      MemoryPropertyFlagBits = (1 << 3)
	VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT MemoryPropertyFlagBits = (1 << 4)
	VK_MEMORY_PROPERTY_PROTECTED_BIT        MemoryPropertyFlagBits = (1 << 5)
)

var (
	reverseMemoryPropertyFlagBits map[MemoryPropertyFlagBits]string = map[MemoryPropertyFlagBits]string{
		VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT:     "VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT",
		VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT:     "VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT",
		VK_MEMORY_PROPERTY_HOST_COHERENT_BIT:    "VK_MEMORY_PROPERTY_HOST_COHERENT_BIT",
		VK_MEMORY_PROPERTY_HOST_CACHED_BIT:      "VK_MEMORY_PROPERTY_HOST_CACHED_BIT",
		VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT: "VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT",
		VK_MEMORY_PROPERTY_PROTECTED_BIT:        "VK_MEMORY_PROPERTY_PROTECTED_BIT",
	}
)

func (x MemoryPropertyFlagBits) String() string {
	if s, ok := reverseMemoryPropertyFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("MemoryPropertyFlagBits=%d", x)
}

// ComponentSwizzle enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkComponentSwizzle.html
type ComponentSwizzle uint32

const (
	VK_COMPONENT_SWIZZLE_IDENTITY ComponentSwizzle = 0
	VK_COMPONENT_SWIZZLE_ZERO     ComponentSwizzle = 1
	VK_COMPONENT_SWIZZLE_ONE      ComponentSwizzle = 2
	VK_COMPONENT_SWIZZLE_R        ComponentSwizzle = 3
	VK_COMPONENT_SWIZZLE_G        ComponentSwizzle = 4
	VK_COMPONENT_SWIZZLE_B        ComponentSwizzle = 5
	VK_COMPONENT_SWIZZLE_A        ComponentSwizzle = 6
)

var (
	reverseComponentSwizzle map[ComponentSwizzle]string = map[ComponentSwizzle]string{
		VK_COMPONENT_SWIZZLE_IDENTITY: "VK_COMPONENT_SWIZZLE_IDENTITY",
		VK_COMPONENT_SWIZZLE_ZERO:     "VK_COMPONENT_SWIZZLE_ZERO",
		VK_COMPONENT_SWIZZLE_ONE:      "VK_COMPONENT_SWIZZLE_ONE",
		VK_COMPONENT_SWIZZLE_R:        "VK_COMPONENT_SWIZZLE_R",
		VK_COMPONENT_SWIZZLE_G:        "VK_COMPONENT_SWIZZLE_G",
		VK_COMPONENT_SWIZZLE_B:        "VK_COMPONENT_SWIZZLE_B",
		VK_COMPONENT_SWIZZLE_A:        "VK_COMPONENT_SWIZZLE_A",
	}
)

func (x ComponentSwizzle) String() string {
	if s, ok := reverseComponentSwizzle[x]; ok {
		return s
	}
	return fmt.Sprintf("ComponentSwizzle=%d", x)
}

// ImageLayout enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageLayout.html
type ImageLayout uint32

const (
	VK_IMAGE_LAYOUT_UNDEFINED                                  ImageLayout = 0
	VK_IMAGE_LAYOUT_GENERAL                                    ImageLayout = 1
	VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL                   ImageLayout = 2
	VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL           ImageLayout = 3
	VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL            ImageLayout = 4
	VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL                   ImageLayout = 5
	VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL                       ImageLayout = 6
	VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL                       ImageLayout = 7
	VK_IMAGE_LAYOUT_PREINITIALIZED                             ImageLayout = 8
	VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL ImageLayout = 1000117000
	VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL ImageLayout = 1000117001
	VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL                   ImageLayout = 1000241000
	VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL                    ImageLayout = 1000241001
	VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL                 ImageLayout = 1000241002
	VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL                  ImageLayout = 1000241003
	VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL                          ImageLayout = 1000314000
	VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL                         ImageLayout = 1000314001
	VK_IMAGE_LAYOUT_PRESENT_SRC_KHR                            ImageLayout = 1000001002
)

var (
	reverseImageLayout map[ImageLayout]string = map[ImageLayout]string{
		VK_IMAGE_LAYOUT_UNDEFINED:                                  "VK_IMAGE_LAYOUT_UNDEFINED",
		VK_IMAGE_LAYOUT_GENERAL:                                    "VK_IMAGE_LAYOUT_GENERAL",
		VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL:                   "VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL",
		VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL:           "VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL",
		VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL:            "VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL",
		VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL:                   "VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL",
		VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL:                       "VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL",
		VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL:                       "VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL",
		VK_IMAGE_LAYOUT_PREINITIALIZED:                             "VK_IMAGE_LAYOUT_PREINITIALIZED",
		VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL: "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL",
		VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL: "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL",
		VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL:                   "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL",
		VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL:                    "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL",
		VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL:                 "VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL",
		VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL:                  "VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL",
		VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL:                          "VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL",
		VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL:                         "VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL",
		VK_IMAGE_LAYOUT_PRESENT_SRC_KHR:                            "VK_IMAGE_LAYOUT_PRESENT_SRC_KHR",
	}
)

func (x ImageLayout) String() string {
	if s, ok := reverseImageLayout[x]; ok {
		return s
	}
	return fmt.Sprintf("ImageLayout=%d", x)
}

// CommandPoolCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolCreateFlagBits.html
type CommandPoolCreateFlagBits uint32

const (
	VK_COMMAND_POOL_CREATE_TRANSIENT_BIT            CommandPoolCreateFlagBits = (1 << 0)
	VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT CommandPoolCreateFlagBits = (1 << 1)
	VK_COMMAND_POOL_CREATE_PROTECTED_BIT            CommandPoolCreateFlagBits = (1 << 2)
)

var (
	reverseCommandPoolCreateFlagBits map[CommandPoolCreateFlagBits]string = map[CommandPoolCreateFlagBits]string{
		VK_COMMAND_POOL_CREATE_TRANSIENT_BIT:            "VK_COMMAND_POOL_CREATE_TRANSIENT_BIT",
		VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT: "VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT",
		VK_COMMAND_POOL_CREATE_PROTECTED_BIT:            "VK_COMMAND_POOL_CREATE_PROTECTED_BIT",
	}
)

func (x CommandPoolCreateFlagBits) String() string {
	if s, ok := reverseCommandPoolCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("CommandPoolCreateFlagBits=%d", x)
}

// CommandPoolResetFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolResetFlagBits.html
type CommandPoolResetFlagBits uint32

const (
	VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT CommandPoolResetFlagBits = (1 << 0)
)

var (
	reverseCommandPoolResetFlagBits map[CommandPoolResetFlagBits]string = map[CommandPoolResetFlagBits]string{
		VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT: "VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT",
	}
)

func (x CommandPoolResetFlagBits) String() string {
	if s, ok := reverseCommandPoolResetFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("CommandPoolResetFlagBits=%d", x)
}

// CommandBufferLevel enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferLevel.html
type CommandBufferLevel uint32

const (
	VK_COMMAND_BUFFER_LEVEL_PRIMARY   CommandBufferLevel = 0
	VK_COMMAND_BUFFER_LEVEL_SECONDARY CommandBufferLevel = 1
)

var (
	reverseCommandBufferLevel map[CommandBufferLevel]string = map[CommandBufferLevel]string{
		VK_COMMAND_BUFFER_LEVEL_PRIMARY:   "VK_COMMAND_BUFFER_LEVEL_PRIMARY",
		VK_COMMAND_BUFFER_LEVEL_SECONDARY: "VK_COMMAND_BUFFER_LEVEL_SECONDARY",
	}
)

func (x CommandBufferLevel) String() string {
	if s, ok := reverseCommandBufferLevel[x]; ok {
		return s
	}
	return fmt.Sprintf("CommandBufferLevel=%d", x)
}

// SharingMode enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html
type SharingMode uint32

const (
	VK_SHARING_MODE_EXCLUSIVE  SharingMode = 0
	VK_SHARING_MODE_CONCURRENT SharingMode = 1
)

var (
	reverseSharingMode map[SharingMode]string = map[SharingMode]string{
		VK_SHARING_MODE_EXCLUSIVE:  "VK_SHARING_MODE_EXCLUSIVE",
		VK_SHARING_MODE_CONCURRENT: "VK_SHARING_MODE_CONCURRENT",
	}
)

func (x SharingMode) String() string {
	if s, ok := reverseSharingMode[x]; ok {
		return s
	}
	return fmt.Sprintf("SharingMode=%d", x)
}

// BufferUsageFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferUsageFlagBits.html
type BufferUsageFlagBits uint32

const (
	VK_BUFFER_USAGE_TRANSFER_SRC_BIT          BufferUsageFlagBits = (1 << 0)
	VK_BUFFER_USAGE_TRANSFER_DST_BIT          BufferUsageFlagBits = (1 << 1)
	VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT  BufferUsageFlagBits = (1 << 2)
	VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT  BufferUsageFlagBits = (1 << 3)
	VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT        BufferUsageFlagBits = (1 << 4)
	VK_BUFFER_USAGE_STORAGE_BUFFER_BIT        BufferUsageFlagBits = (1 << 5)
	VK_BUFFER_USAGE_INDEX_BUFFER_BIT          BufferUsageFlagBits = (1 << 6)
	VK_BUFFER_USAGE_VERTEX_BUFFER_BIT         BufferUsageFlagBits = (1 << 7)
	VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT       BufferUsageFlagBits = (1 << 8)
	VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT BufferUsageFlagBits = (1 << 17)
)

var (
	reverseBufferUsageFlagBits map[BufferUsageFlagBits]string = map[BufferUsageFlagBits]string{
		VK_BUFFER_USAGE_TRANSFER_SRC_BIT:          "VK_BUFFER_USAGE_TRANSFER_SRC_BIT",
		VK_BUFFER_USAGE_TRANSFER_DST_BIT:          "VK_BUFFER_USAGE_TRANSFER_DST_BIT",
		VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT:  "VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT",
		VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT:  "VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT",
		VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT:        "VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT",
		VK_BUFFER_USAGE_STORAGE_BUFFER_BIT:        "VK_BUFFER_USAGE_STORAGE_BUFFER_BIT",
		VK_BUFFER_USAGE_INDEX_BUFFER_BIT:          "VK_BUFFER_USAGE_INDEX_BUFFER_BIT",
		VK_BUFFER_USAGE_VERTEX_BUFFER_BIT:         "VK_BUFFER_USAGE_VERTEX_BUFFER_BIT",
		VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT:       "VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT",
		VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT: "VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT",
	}
)

func (x BufferUsageFlagBits) String() string {
	if s, ok := reverseBufferUsageFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("BufferUsageFlagBits=%d", x)
}

// BufferCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCreateFlagBits.html
type BufferCreateFlagBits uint32

const (
	VK_BUFFER_CREATE_SPARSE_BINDING_BIT                BufferCreateFlagBits = (1 << 0)
	VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT              BufferCreateFlagBits = (1 << 1)
	VK_BUFFER_CREATE_SPARSE_ALIASED_BIT                BufferCreateFlagBits = (1 << 2)
	VK_BUFFER_CREATE_PROTECTED_BIT                     BufferCreateFlagBits = (1 << 3)
	VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT BufferCreateFlagBits = (1 << 4)
)

var (
	reverseBufferCreateFlagBits map[BufferCreateFlagBits]string = map[BufferCreateFlagBits]string{
		VK_BUFFER_CREATE_SPARSE_BINDING_BIT:                "VK_BUFFER_CREATE_SPARSE_BINDING_BIT",
		VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT:              "VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT",
		VK_BUFFER_CREATE_SPARSE_ALIASED_BIT:                "VK_BUFFER_CREATE_SPARSE_ALIASED_BIT",
		VK_BUFFER_CREATE_PROTECTED_BIT:                     "VK_BUFFER_CREATE_PROTECTED_BIT",
		VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT: "VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT",
	}
)

func (x BufferCreateFlagBits) String() string {
	if s, ok := reverseBufferCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("BufferCreateFlagBits=%d", x)
}

// PhysicalDeviceType enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceType.html
type PhysicalDeviceType uint32

const (
	VK_PHYSICAL_DEVICE_TYPE_OTHER          PhysicalDeviceType = 0
	VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU PhysicalDeviceType = 1
	VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU   PhysicalDeviceType = 2
	VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU    PhysicalDeviceType = 3
	VK_PHYSICAL_DEVICE_TYPE_CPU            PhysicalDeviceType = 4
)

var (
	reversePhysicalDeviceType map[PhysicalDeviceType]string = map[PhysicalDeviceType]string{
		VK_PHYSICAL_DEVICE_TYPE_OTHER:          "VK_PHYSICAL_DEVICE_TYPE_OTHER",
		VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU: "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU",
		VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU:   "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU",
		VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU:    "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU",
		VK_PHYSICAL_DEVICE_TYPE_CPU:            "VK_PHYSICAL_DEVICE_TYPE_CPU",
	}
)

func (x PhysicalDeviceType) String() string {
	if s, ok := reversePhysicalDeviceType[x]; ok {
		return s
	}
	return fmt.Sprintf("PhysicalDeviceType=%d", x)
}

// CommandBufferResetFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferResetFlagBits.html
type CommandBufferResetFlagBits uint32

const (
	VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT CommandBufferResetFlagBits = (1 << 0)
)

var (
	reverseCommandBufferResetFlagBits map[CommandBufferResetFlagBits]string = map[CommandBufferResetFlagBits]string{
		VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT: "VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT",
	}
)

func (x CommandBufferResetFlagBits) String() string {
	if s, ok := reverseCommandBufferResetFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("CommandBufferResetFlagBits=%d", x)
}

// QueueFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFlagBits.html
type QueueFlagBits uint32

const (
	VK_QUEUE_GRAPHICS_BIT       QueueFlagBits = (1 << 0)
	VK_QUEUE_COMPUTE_BIT        QueueFlagBits = (1 << 1)
	VK_QUEUE_TRANSFER_BIT       QueueFlagBits = (1 << 2)
	VK_QUEUE_SPARSE_BINDING_BIT QueueFlagBits = (1 << 3)
	VK_QUEUE_PROTECTED_BIT      QueueFlagBits = (1 << 4)
)

var (
	reverseQueueFlagBits map[QueueFlagBits]string = map[QueueFlagBits]string{
		VK_QUEUE_GRAPHICS_BIT:       "VK_QUEUE_GRAPHICS_BIT",
		VK_QUEUE_COMPUTE_BIT:        "VK_QUEUE_COMPUTE_BIT",
		VK_QUEUE_TRANSFER_BIT:       "VK_QUEUE_TRANSFER_BIT",
		VK_QUEUE_SPARSE_BINDING_BIT: "VK_QUEUE_SPARSE_BINDING_BIT",
		VK_QUEUE_PROTECTED_BIT:      "VK_QUEUE_PROTECTED_BIT",
	}
)

func (x QueueFlagBits) String() string {
	if s, ok := reverseQueueFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("QueueFlagBits=%d", x)
}

// QueryType enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryType.html
type QueryType uint32

const (
	VK_QUERY_TYPE_OCCLUSION           QueryType = 0
	VK_QUERY_TYPE_PIPELINE_STATISTICS QueryType = 1
	VK_QUERY_TYPE_TIMESTAMP           QueryType = 2
)

var (
	reverseQueryType map[QueryType]string = map[QueryType]string{
		VK_QUERY_TYPE_OCCLUSION:           "VK_QUERY_TYPE_OCCLUSION",
		VK_QUERY_TYPE_PIPELINE_STATISTICS: "VK_QUERY_TYPE_PIPELINE_STATISTICS",
		VK_QUERY_TYPE_TIMESTAMP:           "VK_QUERY_TYPE_TIMESTAMP",
	}
)

func (x QueryType) String() string {
	if s, ok := reverseQueryType[x]; ok {
		return s
	}
	return fmt.Sprintf("QueryType=%d", x)
}

// SampleCountFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSampleCountFlagBits.html
type SampleCountFlagBits uint32

const (
	VK_SAMPLE_COUNT_1_BIT  SampleCountFlagBits = (1 << 0)
	VK_SAMPLE_COUNT_2_BIT  SampleCountFlagBits = (1 << 1)
	VK_SAMPLE_COUNT_4_BIT  SampleCountFlagBits = (1 << 2)
	VK_SAMPLE_COUNT_8_BIT  SampleCountFlagBits = (1 << 3)
	VK_SAMPLE_COUNT_16_BIT SampleCountFlagBits = (1 << 4)
	VK_SAMPLE_COUNT_32_BIT SampleCountFlagBits = (1 << 5)
	VK_SAMPLE_COUNT_64_BIT SampleCountFlagBits = (1 << 6)
)

var (
	reverseSampleCountFlagBits map[SampleCountFlagBits]string = map[SampleCountFlagBits]string{
		VK_SAMPLE_COUNT_1_BIT:  "VK_SAMPLE_COUNT_1_BIT",
		VK_SAMPLE_COUNT_2_BIT:  "VK_SAMPLE_COUNT_2_BIT",
		VK_SAMPLE_COUNT_4_BIT:  "VK_SAMPLE_COUNT_4_BIT",
		VK_SAMPLE_COUNT_8_BIT:  "VK_SAMPLE_COUNT_8_BIT",
		VK_SAMPLE_COUNT_16_BIT: "VK_SAMPLE_COUNT_16_BIT",
		VK_SAMPLE_COUNT_32_BIT: "VK_SAMPLE_COUNT_32_BIT",
		VK_SAMPLE_COUNT_64_BIT: "VK_SAMPLE_COUNT_64_BIT",
	}
)

func (x SampleCountFlagBits) String() string {
	if s, ok := reverseSampleCountFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("SampleCountFlagBits=%d", x)
}

// QueryResultFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryResultFlagBits.html
type QueryResultFlagBits uint32

const (
	VK_QUERY_RESULT_64_BIT                QueryResultFlagBits = (1 << 0)
	VK_QUERY_RESULT_WAIT_BIT              QueryResultFlagBits = (1 << 1)
	VK_QUERY_RESULT_WITH_AVAILABILITY_BIT QueryResultFlagBits = (1 << 2)
	VK_QUERY_RESULT_PARTIAL_BIT           QueryResultFlagBits = (1 << 3)
)

var (
	reverseQueryResultFlagBits map[QueryResultFlagBits]string = map[QueryResultFlagBits]string{
		VK_QUERY_RESULT_64_BIT:                "VK_QUERY_RESULT_64_BIT",
		VK_QUERY_RESULT_WAIT_BIT:              "VK_QUERY_RESULT_WAIT_BIT",
		VK_QUERY_RESULT_WITH_AVAILABILITY_BIT: "VK_QUERY_RESULT_WITH_AVAILABILITY_BIT",
		VK_QUERY_RESULT_PARTIAL_BIT:           "VK_QUERY_RESULT_PARTIAL_BIT",
	}
)

func (x QueryResultFlagBits) String() string {
	if s, ok := reverseQueryResultFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("QueryResultFlagBits=%d", x)
}

// SystemAllocationScope enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSystemAllocationScope.html
type SystemAllocationScope uint32

const (
	VK_SYSTEM_ALLOCATION_SCOPE_COMMAND  SystemAllocationScope = 0
	VK_SYSTEM_ALLOCATION_SCOPE_OBJECT   SystemAllocationScope = 1
	VK_SYSTEM_ALLOCATION_SCOPE_CACHE    SystemAllocationScope = 2
	VK_SYSTEM_ALLOCATION_SCOPE_DEVICE   SystemAllocationScope = 3
	VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE SystemAllocationScope = 4
)

var (
	reverseSystemAllocationScope map[SystemAllocationScope]string = map[SystemAllocationScope]string{
		VK_SYSTEM_ALLOCATION_SCOPE_COMMAND:  "VK_SYSTEM_ALLOCATION_SCOPE_COMMAND",
		VK_SYSTEM_ALLOCATION_SCOPE_OBJECT:   "VK_SYSTEM_ALLOCATION_SCOPE_OBJECT",
		VK_SYSTEM_ALLOCATION_SCOPE_CACHE:    "VK_SYSTEM_ALLOCATION_SCOPE_CACHE",
		VK_SYSTEM_ALLOCATION_SCOPE_DEVICE:   "VK_SYSTEM_ALLOCATION_SCOPE_DEVICE",
		VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE: "VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE",
	}
)

func (x SystemAllocationScope) String() string {
	if s, ok := reverseSystemAllocationScope[x]; ok {
		return s
	}
	return fmt.Sprintf("SystemAllocationScope=%d", x)
}

// PipelineCacheHeaderVersion enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCacheHeaderVersion.html
type PipelineCacheHeaderVersion uint32

const (
	VK_PIPELINE_CACHE_HEADER_VERSION_ONE PipelineCacheHeaderVersion = 1
)

var (
	reversePipelineCacheHeaderVersion map[PipelineCacheHeaderVersion]string = map[PipelineCacheHeaderVersion]string{
		VK_PIPELINE_CACHE_HEADER_VERSION_ONE: "VK_PIPELINE_CACHE_HEADER_VERSION_ONE",
	}
)

func (x PipelineCacheHeaderVersion) String() string {
	if s, ok := reversePipelineCacheHeaderVersion[x]; ok {
		return s
	}
	return fmt.Sprintf("PipelineCacheHeaderVersion=%d", x)
}

// QueryPipelineStatisticFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPipelineStatisticFlagBits.html
type QueryPipelineStatisticFlagBits uint32

const (
	VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT                    QueryPipelineStatisticFlagBits = (1 << 0)
	VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT                  QueryPipelineStatisticFlagBits = (1 << 1)
	VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT                  QueryPipelineStatisticFlagBits = (1 << 2)
	VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT                QueryPipelineStatisticFlagBits = (1 << 3)
	VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT                 QueryPipelineStatisticFlagBits = (1 << 4)
	VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT                       QueryPipelineStatisticFlagBits = (1 << 5)
	VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT                        QueryPipelineStatisticFlagBits = (1 << 6)
	VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT                QueryPipelineStatisticFlagBits = (1 << 7)
	VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT        QueryPipelineStatisticFlagBits = (1 << 8)
	VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT QueryPipelineStatisticFlagBits = (1 << 9)
	VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT                 QueryPipelineStatisticFlagBits = (1 << 10)
)

var (
	reverseQueryPipelineStatisticFlagBits map[QueryPipelineStatisticFlagBits]string = map[QueryPipelineStatisticFlagBits]string{
		VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT:                    "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT",
		VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT:                  "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT",
		VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT:                  "VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT",
		VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT:                "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT",
		VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT:                 "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT",
		VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT:                       "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT",
		VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT:                        "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT",
		VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT:                "VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT",
		VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT:        "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT",
		VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT: "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT",
		VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT:                 "VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT",
	}
)

func (x QueryPipelineStatisticFlagBits) String() string {
	if s, ok := reverseQueryPipelineStatisticFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("QueryPipelineStatisticFlagBits=%d", x)
}

// StructureType enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkStructureType.html
type StructureType uint32

const (
	VK_STRUCTURE_TYPE_APPLICATION_INFO                                            StructureType = 0
	VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO                                        StructureType = 1
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO                                    StructureType = 2
	VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO                                          StructureType = 3
	VK_STRUCTURE_TYPE_SUBMIT_INFO                                                 StructureType = 4
	VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO                                        StructureType = 5
	VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE                                         StructureType = 6
	VK_STRUCTURE_TYPE_BIND_SPARSE_INFO                                            StructureType = 7
	VK_STRUCTURE_TYPE_FENCE_CREATE_INFO                                           StructureType = 8
	VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO                                       StructureType = 9
	VK_STRUCTURE_TYPE_EVENT_CREATE_INFO                                           StructureType = 10
	VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO                                      StructureType = 11
	VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO                                          StructureType = 12
	VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO                                     StructureType = 13
	VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO                                           StructureType = 14
	VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO                                      StructureType = 15
	VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO                                   StructureType = 16
	VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO                                  StructureType = 17
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO                           StructureType = 18
	VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO                     StructureType = 19
	VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO                   StructureType = 20
	VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO                     StructureType = 21
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO                         StructureType = 22
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO                    StructureType = 23
	VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO                      StructureType = 24
	VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO                    StructureType = 25
	VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO                      StructureType = 26
	VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO                          StructureType = 27
	VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO                               StructureType = 28
	VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO                                StructureType = 29
	VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO                                 StructureType = 30
	VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO                                         StructureType = 31
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO                           StructureType = 32
	VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO                                 StructureType = 33
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO                                StructureType = 34
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET                                        StructureType = 35
	VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET                                         StructureType = 36
	VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO                                     StructureType = 37
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO                                     StructureType = 38
	VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO                                    StructureType = 39
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO                                StructureType = 40
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO                             StructureType = 41
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO                                   StructureType = 42
	VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO                                      StructureType = 43
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER                                       StructureType = 44
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER                                        StructureType = 45
	VK_STRUCTURE_TYPE_MEMORY_BARRIER                                              StructureType = 46
	VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO                                 StructureType = 47
	VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO                                   StructureType = 48
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES                         StructureType = 1000094000
	VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO                                     StructureType = 1000157000
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO                                      StructureType = 1000157001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES                      StructureType = 1000083000
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS                               StructureType = 1000127000
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO                              StructureType = 1000127001
	VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO                                  StructureType = 1000060000
	VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO                         StructureType = 1000060003
	VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO                      StructureType = 1000060004
	VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO                                    StructureType = 1000060005
	VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO                               StructureType = 1000060006
	VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO                        StructureType = 1000060013
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO                         StructureType = 1000060014
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES                            StructureType = 1000070000
	VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO                             StructureType = 1000070001
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2                           StructureType = 1000146000
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2                            StructureType = 1000146001
	VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2                     StructureType = 1000146002
	VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2                                       StructureType = 1000146003
	VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2                          StructureType = 1000146004
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2                                  StructureType = 1000059000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2                                StructureType = 1000059001
	VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2                                         StructureType = 1000059002
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2                                   StructureType = 1000059003
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2                         StructureType = 1000059004
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2                                   StructureType = 1000059005
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2                         StructureType = 1000059006
	VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2                            StructureType = 1000059007
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2                  StructureType = 1000059008
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES                   StructureType = 1000117000
	VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO             StructureType = 1000117001
	VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO                                StructureType = 1000117002
	VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO       StructureType = 1000117003
	VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO                           StructureType = 1000053000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES                          StructureType = 1000053001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES                        StructureType = 1000053002
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES                  StructureType = 1000120000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES                   StructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES
	VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO                                       StructureType = 1000145000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES                   StructureType = 1000145001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES                 StructureType = 1000145002
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2                                         StructureType = 1000145003
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO                        StructureType = 1000156000
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO                               StructureType = 1000156001
	VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO                                StructureType = 1000156002
	VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO                        StructureType = 1000156003
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES           StructureType = 1000156004
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES            StructureType = 1000156005
	VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO                      StructureType = 1000085000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO                  StructureType = 1000071000
	VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES                            StructureType = 1000071001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO                        StructureType = 1000071002
	VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES                                  StructureType = 1000071003
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES                               StructureType = 1000071004
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO                          StructureType = 1000072000
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO                           StructureType = 1000072001
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO                                 StructureType = 1000072002
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO                         StructureType = 1000112000
	VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES                                   StructureType = 1000112001
	VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO                                    StructureType = 1000113000
	VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO                                StructureType = 1000077000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO                     StructureType = 1000076000
	VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES                               StructureType = 1000076001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES                    StructureType = 1000168000
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT                               StructureType = 1000168001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES             StructureType = 1000063000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES              StructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES                         StructureType = 49
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES                       StructureType = 50
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES                         StructureType = 51
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES                       StructureType = 52
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO                               StructureType = 1000147000
	VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2                                    StructureType = 1000109000
	VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2                                      StructureType = 1000109001
	VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2                                       StructureType = 1000109002
	VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2                                        StructureType = 1000109003
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2                                   StructureType = 1000109004
	VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO                                          StructureType = 1000109005
	VK_STRUCTURE_TYPE_SUBPASS_END_INFO                                            StructureType = 1000109006
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES                       StructureType = 1000177000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES                           StructureType = 1000196000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES                StructureType = 1000180000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES                StructureType = 1000082000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES                   StructureType = 1000197000
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO             StructureType = 1000161000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES                StructureType = 1000161001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES              StructureType = 1000161002
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO      StructureType = 1000161003
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT     StructureType = 1000161004
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES            StructureType = 1000199000
	VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE                   StructureType = 1000199001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES                StructureType = 1000221000
	VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO                             StructureType = 1000246000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES            StructureType = 1000130000
	VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO                          StructureType = 1000130001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES                StructureType = 1000211000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES              StructureType = 1000108000
	VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO                         StructureType = 1000108001
	VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO                           StructureType = 1000108002
	VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO                           StructureType = 1000108003
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES     StructureType = 1000253000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES     StructureType = 1000175000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES     StructureType = 1000241000
	VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT                         StructureType = 1000241001
	VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT                       StructureType = 1000241002
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES                   StructureType = 1000261000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES                 StructureType = 1000207000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES               StructureType = 1000207001
	VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO                                  StructureType = 1000207002
	VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO                              StructureType = 1000207003
	VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO                                         StructureType = 1000207004
	VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO                                       StructureType = 1000207005
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES              StructureType = 1000257000
	VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO                                  StructureType = 1000244001
	VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO                   StructureType = 1000257002
	VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO                 StructureType = 1000257003
	VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO                   StructureType = 1000257004
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES                         StructureType = 53
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES                       StructureType = 54
	VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO                      StructureType = 1000192000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES        StructureType = 1000215000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES                             StructureType = 1000245000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES StructureType = 1000276000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES                       StructureType = 1000295000
	VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO                             StructureType = 1000295001
	VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO                               StructureType = 1000295002
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES    StructureType = 1000297000
	VK_STRUCTURE_TYPE_MEMORY_BARRIER_2                                            StructureType = 1000314000
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2                                     StructureType = 1000314001
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2                                      StructureType = 1000314002
	VK_STRUCTURE_TYPE_DEPENDENCY_INFO                                             StructureType = 1000314003
	VK_STRUCTURE_TYPE_SUBMIT_INFO_2                                               StructureType = 1000314004
	VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO                                       StructureType = 1000314005
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO                                  StructureType = 1000314006
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES                  StructureType = 1000314007
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES   StructureType = 1000325000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES                   StructureType = 1000335000
	VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2                                          StructureType = 1000337000
	VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2                                           StructureType = 1000337001
	VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2                                 StructureType = 1000337002
	VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2                                 StructureType = 1000337003
	VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2                                           StructureType = 1000337004
	VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2                                        StructureType = 1000337005
	VK_STRUCTURE_TYPE_BUFFER_COPY_2                                               StructureType = 1000337006
	VK_STRUCTURE_TYPE_IMAGE_COPY_2                                                StructureType = 1000337007
	VK_STRUCTURE_TYPE_IMAGE_BLIT_2                                                StructureType = 1000337008
	VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2                                         StructureType = 1000337009
	VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2                                             StructureType = 1000337010
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES            StructureType = 1000225000
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO    StructureType = 1000225001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES              StructureType = 1000225002
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES               StructureType = 1000138000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES             StructureType = 1000138001
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK                   StructureType = 1000138002
	VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO            StructureType = 1000138003
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES       StructureType = 1000066000
	VK_STRUCTURE_TYPE_RENDERING_INFO                                              StructureType = 1000044000
	VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO                                   StructureType = 1000044001
	VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO                              StructureType = 1000044002
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES                  StructureType = 1000044003
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO                   StructureType = 1000044004
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES         StructureType = 1000280000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES       StructureType = 1000280001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES           StructureType = 1000281001
	VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3                                         StructureType = 1000360000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES                      StructureType = 1000413000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES                    StructureType = 1000413001
	VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS                           StructureType = 1000413002
	VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS                            StructureType = 1000413003
	VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT                       StructureType = 1000011000
	VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT                                StructureType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR                              StructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR                            StructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2
	VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR                                     StructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR                               StructureType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR                     StructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR                               StructureType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR                     StructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2
	VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR                        StructureType = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR              StructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR                          StructureType = 1000119000
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR                                  StructureType = 1000119001
	VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR                                        StructureType = 1000119002
	VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR                          StructureType = 1000239000
	VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR                                   StructureType = 1000001000
	VK_STRUCTURE_TYPE_PRESENT_INFO_KHR                                            StructureType = 1000001001
	VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR                       StructureType = 1000060007
	VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR                             StructureType = 1000060008
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR                        StructureType = 1000060009
	VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR                                 StructureType = 1000060010
	VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR                               StructureType = 1000060011
	VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR                      StructureType = 1000060012
	VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR                                StructureType = 1000002000
	VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR                             StructureType = 1000002001
	VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR                                    StructureType = 1000121000
	VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR                              StructureType = 1000121001
	VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR                               StructureType = 1000121002
	VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR                                    StructureType = 1000121003
	VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR                            StructureType = 1000121004
	VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR                                    StructureType = 1000003000
	VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR                                     StructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR             StructureType = 1000163000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR           StructureType = 1000163001
)

var (
	reverseStructureType map[StructureType]string = map[StructureType]string{
		VK_STRUCTURE_TYPE_APPLICATION_INFO:                                            "VK_STRUCTURE_TYPE_APPLICATION_INFO",
		VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO:                                        "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO",
		VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO:                                    "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO",
		VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO:                                          "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO",
		VK_STRUCTURE_TYPE_SUBMIT_INFO:                                                 "VK_STRUCTURE_TYPE_SUBMIT_INFO",
		VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO:                                        "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO",
		VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE:                                         "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE",
		VK_STRUCTURE_TYPE_BIND_SPARSE_INFO:                                            "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO",
		VK_STRUCTURE_TYPE_FENCE_CREATE_INFO:                                           "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO",
		VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO:                                       "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO",
		VK_STRUCTURE_TYPE_EVENT_CREATE_INFO:                                           "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO",
		VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO:                                      "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO",
		VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO:                                          "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO",
		VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO:                                     "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO",
		VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO:                                           "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO",
		VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO:                                      "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO",
		VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO:                                   "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO:                                  "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO:                           "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO:                     "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO:                   "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO:                     "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO:                         "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO:                    "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO:                      "VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO:                    "VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO:                      "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO:                          "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO:                               "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO",
		VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO:                                "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO:                                 "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO",
		VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO:                                         "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO",
		VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO:                           "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO",
		VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO:                                 "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO",
		VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO:                                "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO",
		VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET:                                        "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET",
		VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET:                                         "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET",
		VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO:                                     "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO",
		VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO:                                     "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO",
		VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO:                                    "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO",
		VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO:                                "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO",
		VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO:                             "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO",
		VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO:                                   "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO",
		VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO:                                      "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO",
		VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER:                                       "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER",
		VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER:                                        "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER",
		VK_STRUCTURE_TYPE_MEMORY_BARRIER:                                              "VK_STRUCTURE_TYPE_MEMORY_BARRIER",
		VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO:                                 "VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO",
		VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO:                                   "VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:                         "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES",
		VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO:                                     "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO",
		VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO:                                      "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:                      "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES",
		VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:                               "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS",
		VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:                              "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO",
		VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:                                  "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO",
		VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:                         "VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO",
		VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:                      "VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO",
		VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:                                    "VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO",
		VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:                               "VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO",
		VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:                        "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO",
		VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:                         "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES:                            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES",
		VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:                             "VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO",
		VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2:                           "VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2",
		VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2:                            "VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2",
		VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2:                     "VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2",
		VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2:                                       "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2",
		VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2:                          "VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:                                  "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2:                                "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2",
		VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2:                                         "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2",
		VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2:                                   "VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2:                         "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2",
		VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2:                                   "VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2:                         "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2",
		VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2:                            "VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2:                  "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:                   "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES",
		VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:             "VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO",
		VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:                                "VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:       "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:                           "VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:                          "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:                        "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:                  "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES",
		VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:                                       "VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:                   "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:                 "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES",
		VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2:                                         "VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2",
		VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO:                        "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO",
		VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:                               "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO",
		VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:                                "VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO",
		VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:                        "VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:           "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES",
		VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:            "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES",
		VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO:                      "VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:                  "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO",
		VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:                            "VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO:                        "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO",
		VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES:                                  "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:                               "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES",
		VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:                          "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO",
		VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:                           "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO",
		VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:                                 "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO:                         "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO",
		VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES:                                   "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES",
		VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:                                    "VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO",
		VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:                                "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO:                     "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO",
		VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES:                               "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:                    "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES",
		VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT:                               "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:             "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:                         "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES:                       "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES:                         "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES:                       "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES",
		VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:                               "VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO",
		VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2:                                    "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2",
		VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2:                                      "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2",
		VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2:                                       "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2",
		VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2:                                        "VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2",
		VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2:                                   "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2",
		VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO:                                          "VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO",
		VK_STRUCTURE_TYPE_SUBPASS_END_INFO:                                            "VK_STRUCTURE_TYPE_SUBPASS_END_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES:                       "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES:                           "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:                "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:                "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES:                   "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES",
		VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO:             "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:                "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES:              "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES",
		VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO:      "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO",
		VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT:     "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES:            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES",
		VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE:                   "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:                "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES",
		VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:                             "VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES:            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES",
		VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO:                          "VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:                "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:              "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES",
		VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO:                         "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO",
		VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO:                           "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO",
		VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO:                           "VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES:     "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES:     "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES:     "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES",
		VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT:                         "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT",
		VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT:                       "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:                   "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:                 "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES:               "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES",
		VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO:                                  "VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO",
		VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO:                              "VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO",
		VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO:                                         "VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO",
		VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO:                                       "VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:              "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES",
		VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO:                                  "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO",
		VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO:                   "VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO",
		VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO:                 "VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO",
		VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO:                   "VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES:                         "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES:                       "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES",
		VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:                      "VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES:        "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES:                             "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES:                       "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES",
		VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO:                             "VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO",
		VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO:                               "VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES:    "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES",
		VK_STRUCTURE_TYPE_MEMORY_BARRIER_2:                                            "VK_STRUCTURE_TYPE_MEMORY_BARRIER_2",
		VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2:                                     "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2",
		VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2:                                      "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2",
		VK_STRUCTURE_TYPE_DEPENDENCY_INFO:                                             "VK_STRUCTURE_TYPE_DEPENDENCY_INFO",
		VK_STRUCTURE_TYPE_SUBMIT_INFO_2:                                               "VK_STRUCTURE_TYPE_SUBMIT_INFO_2",
		VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO:                                       "VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO",
		VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO:                                  "VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES:                  "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES:   "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES:                   "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES",
		VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2:                                          "VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2",
		VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2:                                           "VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2",
		VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2:                                 "VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2",
		VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2:                                 "VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2",
		VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2:                                           "VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2",
		VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2:                                        "VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2",
		VK_STRUCTURE_TYPE_BUFFER_COPY_2:                                               "VK_STRUCTURE_TYPE_BUFFER_COPY_2",
		VK_STRUCTURE_TYPE_IMAGE_COPY_2:                                                "VK_STRUCTURE_TYPE_IMAGE_COPY_2",
		VK_STRUCTURE_TYPE_IMAGE_BLIT_2:                                                "VK_STRUCTURE_TYPE_IMAGE_BLIT_2",
		VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2:                                         "VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2",
		VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2:                                             "VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES:            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES",
		VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO:    "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES:              "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES:               "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES:             "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES",
		VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK:                   "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK",
		VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO:            "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES:       "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES",
		VK_STRUCTURE_TYPE_RENDERING_INFO:                                              "VK_STRUCTURE_TYPE_RENDERING_INFO",
		VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO:                                   "VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO:                              "VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES:                  "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES",
		VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO:                   "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES:         "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES:       "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES:           "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES",
		VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3:                                         "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES:                      "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES:                    "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES",
		VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS:                           "VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS",
		VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS:                            "VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS",
		VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:                       "VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR:                          "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR",
		VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR:                                  "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR",
		VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR:                                        "VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR",
		VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR:                          "VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR",
		VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR:                                   "VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR",
		VK_STRUCTURE_TYPE_PRESENT_INFO_KHR:                                            "VK_STRUCTURE_TYPE_PRESENT_INFO_KHR",
		VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR:                       "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR",
		VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:                             "VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR",
		VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:                        "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR",
		VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR:                                 "VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR",
		VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:                               "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR",
		VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:                      "VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR",
		VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR:                                "VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR",
		VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR:                             "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR",
		VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR:                                    "VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR",
		VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR:                              "VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR",
		VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR:                               "VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR",
		VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR:                                    "VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR",
		VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR:                            "VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR",
		VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:                                    "VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR:             "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR:           "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR",
	}
)

func (x StructureType) String() string {
	if s, ok := reverseStructureType[x]; ok {
		return s
	}
	return fmt.Sprintf("StructureType=%d", x)
}

// Result enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkResult.html
type Result int32

const (
	VK_SUCCESS                              Result = 0
	VK_NOT_READY                            Result = 1
	VK_TIMEOUT                              Result = 2
	VK_EVENT_SET                            Result = 3
	VK_EVENT_RESET                          Result = 4
	VK_INCOMPLETE                           Result = 5
	VK_ERROR_OUT_OF_HOST_MEMORY             Result = -1
	VK_ERROR_OUT_OF_DEVICE_MEMORY           Result = -2
	VK_ERROR_INITIALIZATION_FAILED          Result = -3
	VK_ERROR_DEVICE_LOST                    Result = -4
	VK_ERROR_MEMORY_MAP_FAILED              Result = -5
	VK_ERROR_LAYER_NOT_PRESENT              Result = -6
	VK_ERROR_EXTENSION_NOT_PRESENT          Result = -7
	VK_ERROR_FEATURE_NOT_PRESENT            Result = -8
	VK_ERROR_INCOMPATIBLE_DRIVER            Result = -9
	VK_ERROR_TOO_MANY_OBJECTS               Result = -10
	VK_ERROR_FORMAT_NOT_SUPPORTED           Result = -11
	VK_ERROR_FRAGMENTED_POOL                Result = -12
	VK_ERROR_UNKNOWN                        Result = -13
	VK_ERROR_OUT_OF_POOL_MEMORY             Result = 1000069000
	VK_ERROR_INVALID_EXTERNAL_HANDLE        Result = 1000072003
	VK_ERROR_FRAGMENTATION                  Result = 1000161000
	VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS Result = 1000257000
	VK_PIPELINE_COMPILE_REQUIRED            Result = 1000297000
	VK_ERROR_VALIDATION_FAILED_EXT          Result = 1000011001
	VK_ERROR_SURFACE_LOST_KHR               Result = 1000000000
	VK_ERROR_NATIVE_WINDOW_IN_USE_KHR       Result = 1000000001
	VK_SUBOPTIMAL_KHR                       Result = 1000001003
	VK_ERROR_OUT_OF_DATE_KHR                Result = 1000001004
	VK_ERROR_INCOMPATIBLE_DISPLAY_KHR       Result = 1000003001
)

var (
	reverseResult map[Result]string = map[Result]string{
		VK_SUCCESS:                              "VK_SUCCESS",
		VK_NOT_READY:                            "VK_NOT_READY",
		VK_TIMEOUT:                              "VK_TIMEOUT",
		VK_EVENT_SET:                            "VK_EVENT_SET",
		VK_EVENT_RESET:                          "VK_EVENT_RESET",
		VK_INCOMPLETE:                           "VK_INCOMPLETE",
		VK_ERROR_OUT_OF_HOST_MEMORY:             "VK_ERROR_OUT_OF_HOST_MEMORY",
		VK_ERROR_OUT_OF_DEVICE_MEMORY:           "VK_ERROR_OUT_OF_DEVICE_MEMORY",
		VK_ERROR_INITIALIZATION_FAILED:          "VK_ERROR_INITIALIZATION_FAILED",
		VK_ERROR_DEVICE_LOST:                    "VK_ERROR_DEVICE_LOST",
		VK_ERROR_MEMORY_MAP_FAILED:              "VK_ERROR_MEMORY_MAP_FAILED",
		VK_ERROR_LAYER_NOT_PRESENT:              "VK_ERROR_LAYER_NOT_PRESENT",
		VK_ERROR_EXTENSION_NOT_PRESENT:          "VK_ERROR_EXTENSION_NOT_PRESENT",
		VK_ERROR_FEATURE_NOT_PRESENT:            "VK_ERROR_FEATURE_NOT_PRESENT",
		VK_ERROR_INCOMPATIBLE_DRIVER:            "VK_ERROR_INCOMPATIBLE_DRIVER",
		VK_ERROR_TOO_MANY_OBJECTS:               "VK_ERROR_TOO_MANY_OBJECTS",
		VK_ERROR_FORMAT_NOT_SUPPORTED:           "VK_ERROR_FORMAT_NOT_SUPPORTED",
		VK_ERROR_FRAGMENTED_POOL:                "VK_ERROR_FRAGMENTED_POOL",
		VK_ERROR_UNKNOWN:                        "VK_ERROR_UNKNOWN",
		VK_ERROR_OUT_OF_POOL_MEMORY:             "VK_ERROR_OUT_OF_POOL_MEMORY",
		VK_ERROR_INVALID_EXTERNAL_HANDLE:        "VK_ERROR_INVALID_EXTERNAL_HANDLE",
		VK_ERROR_FRAGMENTATION:                  "VK_ERROR_FRAGMENTATION",
		VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS: "VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS",
		VK_PIPELINE_COMPILE_REQUIRED:            "VK_PIPELINE_COMPILE_REQUIRED",
		VK_ERROR_VALIDATION_FAILED_EXT:          "VK_ERROR_VALIDATION_FAILED_EXT",
		VK_ERROR_SURFACE_LOST_KHR:               "VK_ERROR_SURFACE_LOST_KHR",
		VK_ERROR_NATIVE_WINDOW_IN_USE_KHR:       "VK_ERROR_NATIVE_WINDOW_IN_USE_KHR",
		VK_SUBOPTIMAL_KHR:                       "VK_SUBOPTIMAL_KHR",
		VK_ERROR_OUT_OF_DATE_KHR:                "VK_ERROR_OUT_OF_DATE_KHR",
		VK_ERROR_INCOMPATIBLE_DISPLAY_KHR:       "VK_ERROR_INCOMPATIBLE_DISPLAY_KHR",
	}
)

func (x Result) String() string {
	if s, ok := reverseResult[x]; ok {
		return s
	}
	return fmt.Sprintf("Result=%d", x)
}

// EventCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkEventCreateFlagBits.html
type EventCreateFlagBits uint32

const (
	VK_EVENT_CREATE_DEVICE_ONLY_BIT EventCreateFlagBits = (1 << 0)
)

var (
	reverseEventCreateFlagBits map[EventCreateFlagBits]string = map[EventCreateFlagBits]string{
		VK_EVENT_CREATE_DEVICE_ONLY_BIT: "VK_EVENT_CREATE_DEVICE_ONLY_BIT",
	}
)

func (x EventCreateFlagBits) String() string {
	if s, ok := reverseEventCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("EventCreateFlagBits=%d", x)
}

// CommandBufferUsageFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferUsageFlagBits.html
type CommandBufferUsageFlagBits uint32

const (
	VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT      CommandBufferUsageFlagBits = (1 << 0)
	VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT CommandBufferUsageFlagBits = (1 << 1)
	VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT     CommandBufferUsageFlagBits = (1 << 2)
)

var (
	reverseCommandBufferUsageFlagBits map[CommandBufferUsageFlagBits]string = map[CommandBufferUsageFlagBits]string{
		VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT:      "VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT",
		VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT: "VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT",
		VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT:     "VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT",
	}
)

func (x CommandBufferUsageFlagBits) String() string {
	if s, ok := reverseCommandBufferUsageFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("CommandBufferUsageFlagBits=%d", x)
}

// QueryControlFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryControlFlagBits.html
type QueryControlFlagBits uint32

const (
	VK_QUERY_CONTROL_PRECISE_BIT QueryControlFlagBits = (1 << 0)
)

var (
	reverseQueryControlFlagBits map[QueryControlFlagBits]string = map[QueryControlFlagBits]string{
		VK_QUERY_CONTROL_PRECISE_BIT: "VK_QUERY_CONTROL_PRECISE_BIT",
	}
)

func (x QueryControlFlagBits) String() string {
	if s, ok := reverseQueryControlFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("QueryControlFlagBits=%d", x)
}

// FenceCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFenceCreateFlagBits.html
type FenceCreateFlagBits uint32

const (
	VK_FENCE_CREATE_SIGNALED_BIT FenceCreateFlagBits = (1 << 0)
)

var (
	reverseFenceCreateFlagBits map[FenceCreateFlagBits]string = map[FenceCreateFlagBits]string{
		VK_FENCE_CREATE_SIGNALED_BIT: "VK_FENCE_CREATE_SIGNALED_BIT",
	}
)

func (x FenceCreateFlagBits) String() string {
	if s, ok := reverseFenceCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("FenceCreateFlagBits=%d", x)
}

// IndexType enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkIndexType.html
type IndexType uint32

const (
	VK_INDEX_TYPE_UINT16 IndexType = 0
	VK_INDEX_TYPE_UINT32 IndexType = 1
)

var (
	reverseIndexType map[IndexType]string = map[IndexType]string{
		VK_INDEX_TYPE_UINT16: "VK_INDEX_TYPE_UINT16",
		VK_INDEX_TYPE_UINT32: "VK_INDEX_TYPE_UINT32",
	}
)

func (x IndexType) String() string {
	if s, ok := reverseIndexType[x]; ok {
		return s
	}
	return fmt.Sprintf("IndexType=%d", x)
}

// SparseMemoryBindFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseMemoryBindFlagBits.html
type SparseMemoryBindFlagBits uint32

const (
	VK_SPARSE_MEMORY_BIND_METADATA_BIT SparseMemoryBindFlagBits = (1 << 0)
)

var (
	reverseSparseMemoryBindFlagBits map[SparseMemoryBindFlagBits]string = map[SparseMemoryBindFlagBits]string{
		VK_SPARSE_MEMORY_BIND_METADATA_BIT: "VK_SPARSE_MEMORY_BIND_METADATA_BIT",
	}
)

func (x SparseMemoryBindFlagBits) String() string {
	if s, ok := reverseSparseMemoryBindFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("SparseMemoryBindFlagBits=%d", x)
}

// SparseImageFormatFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageFormatFlagBits.html
type SparseImageFormatFlagBits uint32

const (
	VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT         SparseImageFormatFlagBits = (1 << 0)
	VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT       SparseImageFormatFlagBits = (1 << 1)
	VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT SparseImageFormatFlagBits = (1 << 2)
)

var (
	reverseSparseImageFormatFlagBits map[SparseImageFormatFlagBits]string = map[SparseImageFormatFlagBits]string{
		VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT:         "VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT",
		VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT:       "VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT",
		VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT: "VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT",
	}
)

func (x SparseImageFormatFlagBits) String() string {
	if s, ok := reverseSparseImageFormatFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("SparseImageFormatFlagBits=%d", x)
}

// ImageAspectFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageAspectFlagBits.html
type ImageAspectFlagBits uint32

const (
	VK_IMAGE_ASPECT_COLOR_BIT    ImageAspectFlagBits = (1 << 0)
	VK_IMAGE_ASPECT_DEPTH_BIT    ImageAspectFlagBits = (1 << 1)
	VK_IMAGE_ASPECT_STENCIL_BIT  ImageAspectFlagBits = (1 << 2)
	VK_IMAGE_ASPECT_METADATA_BIT ImageAspectFlagBits = (1 << 3)
	VK_IMAGE_ASPECT_PLANE_0_BIT  ImageAspectFlagBits = (1 << 4)
	VK_IMAGE_ASPECT_PLANE_1_BIT  ImageAspectFlagBits = (1 << 5)
	VK_IMAGE_ASPECT_PLANE_2_BIT  ImageAspectFlagBits = (1 << 6)
	VK_IMAGE_ASPECT_NONE         ImageAspectFlagBits = 0
)

var (
	reverseImageAspectFlagBits map[ImageAspectFlagBits]string = map[ImageAspectFlagBits]string{
		VK_IMAGE_ASPECT_COLOR_BIT:    "VK_IMAGE_ASPECT_COLOR_BIT",
		VK_IMAGE_ASPECT_DEPTH_BIT:    "VK_IMAGE_ASPECT_DEPTH_BIT",
		VK_IMAGE_ASPECT_STENCIL_BIT:  "VK_IMAGE_ASPECT_STENCIL_BIT",
		VK_IMAGE_ASPECT_METADATA_BIT: "VK_IMAGE_ASPECT_METADATA_BIT",
		VK_IMAGE_ASPECT_PLANE_0_BIT:  "VK_IMAGE_ASPECT_PLANE_0_BIT",
		VK_IMAGE_ASPECT_PLANE_1_BIT:  "VK_IMAGE_ASPECT_PLANE_1_BIT",
		VK_IMAGE_ASPECT_PLANE_2_BIT:  "VK_IMAGE_ASPECT_PLANE_2_BIT",
		VK_IMAGE_ASPECT_NONE:         "VK_IMAGE_ASPECT_NONE",
	}
)

func (x ImageAspectFlagBits) String() string {
	if s, ok := reverseImageAspectFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ImageAspectFlagBits=%d", x)
}

// StencilFaceFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkStencilFaceFlagBits.html
type StencilFaceFlagBits uint32

const (
	VK_STENCIL_FACE_FRONT_BIT      StencilFaceFlagBits = (1 << 0)
	VK_STENCIL_FACE_BACK_BIT       StencilFaceFlagBits = (1 << 1)
	VK_STENCIL_FACE_FRONT_AND_BACK StencilFaceFlagBits = 0x00000003
	VK_STENCIL_FRONT_AND_BACK      StencilFaceFlagBits = VK_STENCIL_FACE_FRONT_AND_BACK
)

var (
	reverseStencilFaceFlagBits map[StencilFaceFlagBits]string = map[StencilFaceFlagBits]string{
		VK_STENCIL_FACE_FRONT_BIT:      "VK_STENCIL_FACE_FRONT_BIT",
		VK_STENCIL_FACE_BACK_BIT:       "VK_STENCIL_FACE_BACK_BIT",
		VK_STENCIL_FACE_FRONT_AND_BACK: "VK_STENCIL_FACE_FRONT_AND_BACK",
	}
)

func (x StencilFaceFlagBits) String() string {
	if s, ok := reverseStencilFaceFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("StencilFaceFlagBits=%d", x)
}

// SubpassContents enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassContents.html
type SubpassContents uint32

const (
	VK_SUBPASS_CONTENTS_INLINE                    SubpassContents = 0
	VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS SubpassContents = 1
)

var (
	reverseSubpassContents map[SubpassContents]string = map[SubpassContents]string{
		VK_SUBPASS_CONTENTS_INLINE:                    "VK_SUBPASS_CONTENTS_INLINE",
		VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS: "VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS",
	}
)

func (x SubpassContents) String() string {
	if s, ok := reverseSubpassContents[x]; ok {
		return s
	}
	return fmt.Sprintf("SubpassContents=%d", x)
}

// DeviceCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceCreateFlags.html
type DeviceCreateFlags Flags

// PipelineDynamicStateCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineDynamicStateCreateFlags.html
type PipelineDynamicStateCreateFlags Flags

// StencilFaceFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkStencilFaceFlags.html
type StencilFaceFlags Flags

// QueryControlFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryControlFlags.html
type QueryControlFlags Flags

// PipelineStageFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineStageFlags.html
type PipelineStageFlags Flags

// CommandBufferUsageFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferUsageFlags.html
type CommandBufferUsageFlags Flags

// CommandBufferResetFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferResetFlags.html
type CommandBufferResetFlags Flags

// CommandPoolResetFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolResetFlags.html
type CommandPoolResetFlags Flags

// CommandPoolCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolCreateFlags.html
type CommandPoolCreateFlags Flags

// SubpassDescriptionFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDescriptionFlags.html
type SubpassDescriptionFlags Flags

// RenderPassCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreateFlags.html
type RenderPassCreateFlags Flags

// FramebufferCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebufferCreateFlags.html
type FramebufferCreateFlags Flags

// DependencyFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDependencyFlags.html
type DependencyFlags Flags

// AttachmentDescriptionFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentDescriptionFlags.html
type AttachmentDescriptionFlags Flags

// AccessFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccessFlags.html
type AccessFlags Flags

// DescriptorSetLayoutCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutCreateFlags.html
type DescriptorSetLayoutCreateFlags Flags

// MemoryMapFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryMapFlags.html
type MemoryMapFlags Flags

// DescriptorPoolResetFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolResetFlags.html
type DescriptorPoolResetFlags Flags

// DescriptorPoolCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolCreateFlags.html
type DescriptorPoolCreateFlags Flags

// SamplerCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerCreateFlags.html
type SamplerCreateFlags Flags

// ShaderStageFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderStageFlags.html
type ShaderStageFlags Flags

// PipelineViewportStateCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportStateCreateFlags.html
type PipelineViewportStateCreateFlags Flags

// PipelineVertexInputStateCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineVertexInputStateCreateFlags.html
type PipelineVertexInputStateCreateFlags Flags

// PipelineTessellationStateCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineTessellationStateCreateFlags.html
type PipelineTessellationStateCreateFlags Flags

// PipelineShaderStageCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageCreateFlags.html
type PipelineShaderStageCreateFlags Flags

// PipelineRasterizationStateCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationStateCreateFlags.html
type PipelineRasterizationStateCreateFlags Flags

// ImageAspectFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageAspectFlags.html
type ImageAspectFlags Flags

// PipelineMultisampleStateCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineMultisampleStateCreateFlags.html
type PipelineMultisampleStateCreateFlags Flags

// PipelineLayoutCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineLayoutCreateFlagBits.html
type PipelineLayoutCreateFlagBits uint32

// PipelineLayoutCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineLayoutCreateFlags.html
type PipelineLayoutCreateFlags Flags

// PipelineInputAssemblyStateCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineInputAssemblyStateCreateFlags.html
type PipelineInputAssemblyStateCreateFlags Flags

// SparseImageFormatFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageFormatFlags.html
type SparseImageFormatFlags Flags

// QueryPipelineStatisticFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPipelineStatisticFlags.html
type QueryPipelineStatisticFlags Flags

// PipelineDepthStencilStateCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineDepthStencilStateCreateFlagBits.html
type PipelineDepthStencilStateCreateFlagBits uint32

// PipelineDepthStencilStateCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineDepthStencilStateCreateFlags.html
type PipelineDepthStencilStateCreateFlags Flags

// PipelineCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreateFlags.html
type PipelineCreateFlags Flags

// PipelineColorBlendStateCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineColorBlendStateCreateFlagBits.html
type PipelineColorBlendStateCreateFlagBits uint32

// PipelineColorBlendStateCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineColorBlendStateCreateFlags.html
type PipelineColorBlendStateCreateFlags Flags

// SparseMemoryBindFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseMemoryBindFlags.html
type SparseMemoryBindFlags Flags

// QueryPoolCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPoolCreateFlags.html
type QueryPoolCreateFlags Flags

// SampleCountFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSampleCountFlags.html
type SampleCountFlags Flags

// EventCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkEventCreateFlags.html
type EventCreateFlags Flags

// DeviceQueueCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateFlagBits.html
type DeviceQueueCreateFlagBits uint32

const (
	VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT DeviceQueueCreateFlagBits = (1 << 0)
)

var (
	reverseDeviceQueueCreateFlagBits map[DeviceQueueCreateFlagBits]string = map[DeviceQueueCreateFlagBits]string{
		VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT: "VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT",
	}
)

func (x DeviceQueueCreateFlagBits) String() string {
	if s, ok := reverseDeviceQueueCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("DeviceQueueCreateFlagBits=%d", x)
}

// DeviceQueueCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateFlags.html
type DeviceQueueCreateFlags Flags

// QueryResultFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryResultFlags.html
type QueryResultFlags Flags

// QueueFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFlags.html
type QueueFlags Flags

// CullModeFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCullModeFlags.html
type CullModeFlags Flags

// FormatFeatureFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatFeatureFlags.html
type FormatFeatureFlags Flags

// ColorComponentFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkColorComponentFlags.html
type ColorComponentFlags Flags

// ImageCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCreateFlags.html
type ImageCreateFlags Flags

// PipelineCacheCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCacheCreateFlagBits.html
type PipelineCacheCreateFlagBits uint32

const (
	VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT PipelineCacheCreateFlagBits = (1 << 0)
)

var (
	reversePipelineCacheCreateFlagBits map[PipelineCacheCreateFlagBits]string = map[PipelineCacheCreateFlagBits]string{
		VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT: "VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT",
	}
)

func (x PipelineCacheCreateFlagBits) String() string {
	if s, ok := reversePipelineCacheCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("PipelineCacheCreateFlagBits=%d", x)
}

// PipelineCacheCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCacheCreateFlags.html
type PipelineCacheCreateFlags Flags

// ImageUsageFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageUsageFlags.html
type ImageUsageFlags Flags

// FenceCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFenceCreateFlags.html
type FenceCreateFlags Flags

// ShaderModuleCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderModuleCreateFlags.html
type ShaderModuleCreateFlags Flags

// InstanceCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateFlags.html
type InstanceCreateFlags Flags

// ImageViewCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateFlags.html
type ImageViewCreateFlags Flags

// MemoryHeapFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryHeapFlags.html
type MemoryHeapFlags Flags

// SemaphoreCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreCreateFlags.html
type SemaphoreCreateFlags Flags

// MemoryPropertyFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryPropertyFlags.html
type MemoryPropertyFlags Flags

// BufferViewCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferViewCreateFlags.html
type BufferViewCreateFlags Flags

// BufferUsageFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferUsageFlags.html
type BufferUsageFlags Flags

// BufferCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCreateFlags.html
type BufferCreateFlags Flags

// PFN_vkVoidFunction function pointer
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkVoidFunction.html
type PFN_vkVoidFunction C.PFN_vkVoidFunction

// PFN_vkReallocationFunction function pointer
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkReallocationFunction.html
type PFN_vkReallocationFunction C.PFN_vkReallocationFunction

// PFN_vkInternalFreeNotification function pointer
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkInternalFreeNotification.html
type PFN_vkInternalFreeNotification C.PFN_vkInternalFreeNotification

// PFN_vkInternalAllocationNotification function pointer
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkInternalAllocationNotification.html
type PFN_vkInternalAllocationNotification C.PFN_vkInternalAllocationNotification

// PFN_vkFreeFunction function pointer
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkFreeFunction.html
type PFN_vkFreeFunction C.PFN_vkFreeFunction

// PFN_vkAllocationFunction function pointer
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkAllocationFunction.html
type PFN_vkAllocationFunction C.PFN_vkAllocationFunction

// SpecializationMapEntry provides a go interface for VkSpecializationMapEntry.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSpecializationMapEntry.html
type SpecializationMapEntry C.struct_VkSpecializationMapEntry

// SizeofSpecializationMapEntry is the memory size of a SpecializationMapEntry
var SizeofSpecializationMapEntry int = int(unsafe.Sizeof(SpecializationMapEntry{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SpecializationMapEntry) ArpPtr(arp *AutoReleasePool) *SpecializationMapEntry {
	ptr := newCBlock(cULong(SizeofSpecializationMapEntry))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SpecializationMapEntry)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SpecializationMapEntry) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SpecializationMapEntry) AsCPtr() *SpecializationMapEntry {
	clone := (*SpecializationMapEntry)(newCBlock(cULong(SizeofSpecializationMapEntry)))
	*clone = x
	return clone
}

// SpecializationMapEntryCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SpecializationMapEntryCSlice(arp *AutoReleasePool, x ...SpecializationMapEntry) []SpecializationMapEntry {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSpecializationMapEntry * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SpecializationMapEntry)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SpecializationMapEntryFreeCSlice releases the memory allocated by SpecializationMapEntryMakeCSlice.
// It does not free pointers stored inside the slice.
func SpecializationMapEntryFreeCSlice(x []SpecializationMapEntry) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SpecializationMapEntryMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SpecializationMapEntryFreeCSlice must be called on the returned slice.
func SpecializationMapEntryMakeCSlice(x ...SpecializationMapEntry) []SpecializationMapEntry {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSpecializationMapEntry * len(x)
	dst := unsafe.Slice((*SpecializationMapEntry)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// ConstantID returns the value of constantID from VkSpecializationMapEntry
func (x SpecializationMapEntry) ConstantID() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.constantID)
	return *ptr
}

// WithConstantID clones a new SpecializationMapEntry with the value of
// ConstantID updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SpecializationMapEntry) WithConstantID(y uint32) SpecializationMapEntry {
	x.constantID = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SpecializationMapEntry) SetConstantID(y uint32) {
	x.constantID = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// Offset returns the value of offset from VkSpecializationMapEntry
func (x SpecializationMapEntry) Offset() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.offset)
	return *ptr
}

// WithOffset clones a new SpecializationMapEntry with the value of
// Offset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SpecializationMapEntry) WithOffset(y uint32) SpecializationMapEntry {
	x.offset = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SpecializationMapEntry) SetOffset(y uint32) {
	x.offset = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// Size returns the value of size from VkSpecializationMapEntry
func (x SpecializationMapEntry) Size() uint64 {
	ptr := func(x *C.size_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.size)
	return *ptr
}

// WithSize clones a new SpecializationMapEntry with the value of
// Size updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SpecializationMapEntry) WithSize(y uint64) SpecializationMapEntry {
	x.size = *(func(x *uint64) *C.size_t { /* Scalar */ g2c := C.size_t(*x); return &g2c }(&y))
	return x
}
func (x *SpecializationMapEntry) SetSize(y uint64) {
	x.size = *(func(x *uint64) *C.size_t { /* Scalar */ g2c := C.size_t(*x); return &g2c }(&y))
}

// SpecializationInfo provides a go interface for VkSpecializationInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSpecializationInfo.html
type SpecializationInfo C.struct_VkSpecializationInfo

// SizeofSpecializationInfo is the memory size of a SpecializationInfo
var SizeofSpecializationInfo int = int(unsafe.Sizeof(SpecializationInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SpecializationInfo) ArpPtr(arp *AutoReleasePool) *SpecializationInfo {
	ptr := newCBlock(cULong(SizeofSpecializationInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SpecializationInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SpecializationInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SpecializationInfo) AsCPtr() *SpecializationInfo {
	clone := (*SpecializationInfo)(newCBlock(cULong(SizeofSpecializationInfo)))
	*clone = x
	return clone
}

// SpecializationInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SpecializationInfoCSlice(arp *AutoReleasePool, x ...SpecializationInfo) []SpecializationInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSpecializationInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SpecializationInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SpecializationInfoFreeCSlice releases the memory allocated by SpecializationInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SpecializationInfoFreeCSlice(x []SpecializationInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SpecializationInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SpecializationInfoFreeCSlice must be called on the returned slice.
func SpecializationInfoMakeCSlice(x ...SpecializationInfo) []SpecializationInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSpecializationInfo * len(x)
	dst := unsafe.Slice((*SpecializationInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// MapEntryCount returns the value of mapEntryCount from VkSpecializationInfo
func (x SpecializationInfo) MapEntryCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.mapEntryCount)
	return *ptr
}

// WithMapEntryCount clones a new SpecializationInfo with the value of
// MapEntryCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SpecializationInfo) WithMapEntryCount(y uint32) SpecializationInfo {
	x.mapEntryCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SpecializationInfo) SetMapEntryCount(y uint32) {
	x.mapEntryCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PMapEntries returns the value of pMapEntries from VkSpecializationInfo
func (x SpecializationInfo) PMapEntries() []SpecializationMapEntry {
	ptr := func(x **C.struct_VkSpecializationMapEntry) *[]SpecializationMapEntry { /* Slice */
		slc := unsafe.Slice((*SpecializationMapEntry)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pMapEntries)
	return *ptr
}

// WithPMapEntries clones a new SpecializationInfo with the value of
// PMapEntries updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines MapEntryCount as the length of this field.
// MapEntryCount is updated with the length of the new value.
func (x SpecializationInfo) WithPMapEntries(y []SpecializationMapEntry) SpecializationInfo {
	x.pMapEntries = *(func(x *[]SpecializationMapEntry) **C.struct_VkSpecializationMapEntry { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSpecializationMapEntry)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSpecializationMapEntry)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithMapEntryCount(uint32(len(y)))
}
func (x *SpecializationInfo) SetPMapEntries(y []SpecializationMapEntry) {
	x.pMapEntries = *(func(x *[]SpecializationMapEntry) **C.struct_VkSpecializationMapEntry { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSpecializationMapEntry)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSpecializationMapEntry)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetMapEntryCount(uint32(len(y)))
}

// DataSize returns the value of dataSize from VkSpecializationInfo
func (x SpecializationInfo) DataSize() uint64 {
	ptr := func(x *C.size_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.dataSize)
	return *ptr
}

// WithDataSize clones a new SpecializationInfo with the value of
// DataSize updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SpecializationInfo) WithDataSize(y uint64) SpecializationInfo {
	x.dataSize = *(func(x *uint64) *C.size_t { /* Scalar */ g2c := C.size_t(*x); return &g2c }(&y))
	return x
}
func (x *SpecializationInfo) SetDataSize(y uint64) {
	x.dataSize = *(func(x *uint64) *C.size_t { /* Scalar */ g2c := C.size_t(*x); return &g2c }(&y))
}

// PData returns the value of pData from VkSpecializationInfo
func (x SpecializationInfo) PData() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pData)
	return *ptr
}

// WithPData clones a new SpecializationInfo with the value of
// PData updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SpecializationInfo) WithPData(y unsafe.Pointer) SpecializationInfo {
	x.pData = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *SpecializationInfo) SetPData(y unsafe.Pointer) {
	x.pData = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// DescriptorBufferInfo provides a go interface for VkDescriptorBufferInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorBufferInfo.html
type DescriptorBufferInfo C.struct_VkDescriptorBufferInfo

// SizeofDescriptorBufferInfo is the memory size of a DescriptorBufferInfo
var SizeofDescriptorBufferInfo int = int(unsafe.Sizeof(DescriptorBufferInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DescriptorBufferInfo) ArpPtr(arp *AutoReleasePool) *DescriptorBufferInfo {
	ptr := newCBlock(cULong(SizeofDescriptorBufferInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DescriptorBufferInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorBufferInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorBufferInfo) AsCPtr() *DescriptorBufferInfo {
	clone := (*DescriptorBufferInfo)(newCBlock(cULong(SizeofDescriptorBufferInfo)))
	*clone = x
	return clone
}

// DescriptorBufferInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DescriptorBufferInfoCSlice(arp *AutoReleasePool, x ...DescriptorBufferInfo) []DescriptorBufferInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorBufferInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DescriptorBufferInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DescriptorBufferInfoFreeCSlice releases the memory allocated by DescriptorBufferInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorBufferInfoFreeCSlice(x []DescriptorBufferInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorBufferInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorBufferInfoFreeCSlice must be called on the returned slice.
func DescriptorBufferInfoMakeCSlice(x ...DescriptorBufferInfo) []DescriptorBufferInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorBufferInfo * len(x)
	dst := unsafe.Slice((*DescriptorBufferInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Buffer returns the value of buffer from VkDescriptorBufferInfo
func (x DescriptorBufferInfo) Buffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.buffer)
	return *ptr
}

// WithBuffer clones a new DescriptorBufferInfo with the value of
// Buffer updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorBufferInfo) WithBuffer(y Buffer) DescriptorBufferInfo {
	x.buffer = *( /* handle */ (*C.VkBuffer)(&y))
	return x
}
func (x *DescriptorBufferInfo) SetBuffer(y Buffer) {
	x.buffer = *( /* handle */ (*C.VkBuffer)(&y))
}

// Offset returns the value of offset from VkDescriptorBufferInfo
func (x DescriptorBufferInfo) Offset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.offset)
	return *ptr
}

// WithOffset clones a new DescriptorBufferInfo with the value of
// Offset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorBufferInfo) WithOffset(y DeviceSize) DescriptorBufferInfo {
	x.offset = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *DescriptorBufferInfo) SetOffset(y DeviceSize) {
	x.offset = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// Range_ returns the value of range from VkDescriptorBufferInfo
func (x DescriptorBufferInfo) Range_() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x._range)
	return *ptr
}

// WithRange_ clones a new DescriptorBufferInfo with the value of
// Range_ updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorBufferInfo) WithRange_(y DeviceSize) DescriptorBufferInfo {
	x._range = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *DescriptorBufferInfo) SetRange_(y DeviceSize) {
	x._range = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// Extent2D provides a go interface for VkExtent2D.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExtent2D.html
type Extent2D C.struct_VkExtent2D

// SizeofExtent2D is the memory size of a Extent2D
var SizeofExtent2D int = int(unsafe.Sizeof(Extent2D{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x Extent2D) ArpPtr(arp *AutoReleasePool) *Extent2D {
	ptr := newCBlock(cULong(SizeofExtent2D))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*Extent2D)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *Extent2D) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x Extent2D) AsCPtr() *Extent2D {
	clone := (*Extent2D)(newCBlock(cULong(SizeofExtent2D)))
	*clone = x
	return clone
}

// Extent2DCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func Extent2DCSlice(arp *AutoReleasePool, x ...Extent2D) []Extent2D {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExtent2D * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*Extent2D)(ptr), len(x))
	copy(dst, x)
	return dst
}

// Extent2DFreeCSlice releases the memory allocated by Extent2DMakeCSlice.
// It does not free pointers stored inside the slice.
func Extent2DFreeCSlice(x []Extent2D) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// Extent2DMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. Extent2DFreeCSlice must be called on the returned slice.
func Extent2DMakeCSlice(x ...Extent2D) []Extent2D {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExtent2D * len(x)
	dst := unsafe.Slice((*Extent2D)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Width returns the value of width from VkExtent2D
func (x Extent2D) Width() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.width)
	return *ptr
}

// WithWidth clones a new Extent2D with the value of
// Width updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Extent2D) WithWidth(y uint32) Extent2D {
	x.width = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *Extent2D) SetWidth(y uint32) {
	x.width = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// Height returns the value of height from VkExtent2D
func (x Extent2D) Height() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.height)
	return *ptr
}

// WithHeight clones a new Extent2D with the value of
// Height updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Extent2D) WithHeight(y uint32) Extent2D {
	x.height = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *Extent2D) SetHeight(y uint32) {
	x.height = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// Extent3D provides a go interface for VkExtent3D.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExtent3D.html
type Extent3D C.struct_VkExtent3D

// SizeofExtent3D is the memory size of a Extent3D
var SizeofExtent3D int = int(unsafe.Sizeof(Extent3D{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x Extent3D) ArpPtr(arp *AutoReleasePool) *Extent3D {
	ptr := newCBlock(cULong(SizeofExtent3D))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*Extent3D)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *Extent3D) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x Extent3D) AsCPtr() *Extent3D {
	clone := (*Extent3D)(newCBlock(cULong(SizeofExtent3D)))
	*clone = x
	return clone
}

// Extent3DCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func Extent3DCSlice(arp *AutoReleasePool, x ...Extent3D) []Extent3D {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExtent3D * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*Extent3D)(ptr), len(x))
	copy(dst, x)
	return dst
}

// Extent3DFreeCSlice releases the memory allocated by Extent3DMakeCSlice.
// It does not free pointers stored inside the slice.
func Extent3DFreeCSlice(x []Extent3D) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// Extent3DMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. Extent3DFreeCSlice must be called on the returned slice.
func Extent3DMakeCSlice(x ...Extent3D) []Extent3D {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExtent3D * len(x)
	dst := unsafe.Slice((*Extent3D)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Width returns the value of width from VkExtent3D
func (x Extent3D) Width() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.width)
	return *ptr
}

// WithWidth clones a new Extent3D with the value of
// Width updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Extent3D) WithWidth(y uint32) Extent3D {
	x.width = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *Extent3D) SetWidth(y uint32) {
	x.width = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// Height returns the value of height from VkExtent3D
func (x Extent3D) Height() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.height)
	return *ptr
}

// WithHeight clones a new Extent3D with the value of
// Height updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Extent3D) WithHeight(y uint32) Extent3D {
	x.height = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *Extent3D) SetHeight(y uint32) {
	x.height = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// Depth returns the value of depth from VkExtent3D
func (x Extent3D) Depth() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.depth)
	return *ptr
}

// WithDepth clones a new Extent3D with the value of
// Depth updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Extent3D) WithDepth(y uint32) Extent3D {
	x.depth = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *Extent3D) SetDepth(y uint32) {
	x.depth = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// ClearDepthStencilValue provides a go interface for VkClearDepthStencilValue.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearDepthStencilValue.html
type ClearDepthStencilValue C.struct_VkClearDepthStencilValue

// SizeofClearDepthStencilValue is the memory size of a ClearDepthStencilValue
var SizeofClearDepthStencilValue int = int(unsafe.Sizeof(ClearDepthStencilValue{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ClearDepthStencilValue) ArpPtr(arp *AutoReleasePool) *ClearDepthStencilValue {
	ptr := newCBlock(cULong(SizeofClearDepthStencilValue))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ClearDepthStencilValue)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ClearDepthStencilValue) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ClearDepthStencilValue) AsCPtr() *ClearDepthStencilValue {
	clone := (*ClearDepthStencilValue)(newCBlock(cULong(SizeofClearDepthStencilValue)))
	*clone = x
	return clone
}

// ClearDepthStencilValueCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ClearDepthStencilValueCSlice(arp *AutoReleasePool, x ...ClearDepthStencilValue) []ClearDepthStencilValue {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofClearDepthStencilValue * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ClearDepthStencilValue)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ClearDepthStencilValueFreeCSlice releases the memory allocated by ClearDepthStencilValueMakeCSlice.
// It does not free pointers stored inside the slice.
func ClearDepthStencilValueFreeCSlice(x []ClearDepthStencilValue) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ClearDepthStencilValueMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ClearDepthStencilValueFreeCSlice must be called on the returned slice.
func ClearDepthStencilValueMakeCSlice(x ...ClearDepthStencilValue) []ClearDepthStencilValue {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofClearDepthStencilValue * len(x)
	dst := unsafe.Slice((*ClearDepthStencilValue)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Depth returns the value of depth from VkClearDepthStencilValue
func (x ClearDepthStencilValue) Depth() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.depth)
	return *ptr
}

// WithDepth clones a new ClearDepthStencilValue with the value of
// Depth updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ClearDepthStencilValue) WithDepth(y float32) ClearDepthStencilValue {
	x.depth = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}
func (x *ClearDepthStencilValue) SetDepth(y float32) {
	x.depth = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
}

// Stencil returns the value of stencil from VkClearDepthStencilValue
func (x ClearDepthStencilValue) Stencil() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.stencil)
	return *ptr
}

// WithStencil clones a new ClearDepthStencilValue with the value of
// Stencil updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ClearDepthStencilValue) WithStencil(y uint32) ClearDepthStencilValue {
	x.stencil = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *ClearDepthStencilValue) SetStencil(y uint32) {
	x.stencil = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// ClearColorValue union
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearColorValue.html
type ClearColorValue C.VkClearColorValue

// ClearValue union
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearValue.html
type ClearValue C.VkClearValue

// Offset2D provides a go interface for VkOffset2D.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkOffset2D.html
type Offset2D C.struct_VkOffset2D

// SizeofOffset2D is the memory size of a Offset2D
var SizeofOffset2D int = int(unsafe.Sizeof(Offset2D{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x Offset2D) ArpPtr(arp *AutoReleasePool) *Offset2D {
	ptr := newCBlock(cULong(SizeofOffset2D))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*Offset2D)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *Offset2D) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x Offset2D) AsCPtr() *Offset2D {
	clone := (*Offset2D)(newCBlock(cULong(SizeofOffset2D)))
	*clone = x
	return clone
}

// Offset2DCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func Offset2DCSlice(arp *AutoReleasePool, x ...Offset2D) []Offset2D {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofOffset2D * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*Offset2D)(ptr), len(x))
	copy(dst, x)
	return dst
}

// Offset2DFreeCSlice releases the memory allocated by Offset2DMakeCSlice.
// It does not free pointers stored inside the slice.
func Offset2DFreeCSlice(x []Offset2D) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// Offset2DMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. Offset2DFreeCSlice must be called on the returned slice.
func Offset2DMakeCSlice(x ...Offset2D) []Offset2D {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofOffset2D * len(x)
	dst := unsafe.Slice((*Offset2D)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// X returns the value of x from VkOffset2D
func (x Offset2D) X() int32 {
	ptr := func(x *C.int32_t) *int32 { /* Scalar */ c2g := int32(*x); return &c2g }(&x.x)
	return *ptr
}

// WithX clones a new Offset2D with the value of
// X updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Offset2D) WithX(y int32) Offset2D {
	x.x = *(func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&y))
	return x
}
func (x *Offset2D) SetX(y int32) {
	x.x = *(func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&y))
}

// Y returns the value of y from VkOffset2D
func (x Offset2D) Y() int32 {
	ptr := func(x *C.int32_t) *int32 { /* Scalar */ c2g := int32(*x); return &c2g }(&x.y)
	return *ptr
}

// WithY clones a new Offset2D with the value of
// Y updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Offset2D) WithY(y int32) Offset2D {
	x.y = *(func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&y))
	return x
}
func (x *Offset2D) SetY(y int32) {
	x.y = *(func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&y))
}

// Rect2D provides a go interface for VkRect2D.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRect2D.html
type Rect2D C.struct_VkRect2D

// SizeofRect2D is the memory size of a Rect2D
var SizeofRect2D int = int(unsafe.Sizeof(Rect2D{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x Rect2D) ArpPtr(arp *AutoReleasePool) *Rect2D {
	ptr := newCBlock(cULong(SizeofRect2D))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*Rect2D)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *Rect2D) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x Rect2D) AsCPtr() *Rect2D {
	clone := (*Rect2D)(newCBlock(cULong(SizeofRect2D)))
	*clone = x
	return clone
}

// Rect2DCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func Rect2DCSlice(arp *AutoReleasePool, x ...Rect2D) []Rect2D {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRect2D * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*Rect2D)(ptr), len(x))
	copy(dst, x)
	return dst
}

// Rect2DFreeCSlice releases the memory allocated by Rect2DMakeCSlice.
// It does not free pointers stored inside the slice.
func Rect2DFreeCSlice(x []Rect2D) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// Rect2DMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. Rect2DFreeCSlice must be called on the returned slice.
func Rect2DMakeCSlice(x ...Rect2D) []Rect2D {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRect2D * len(x)
	dst := unsafe.Slice((*Rect2D)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Offset returns the value of offset from VkRect2D
func (x Rect2D) Offset() Offset2D {
	ptr := /* typedef */ (*Offset2D)(&x.offset)
	return *ptr
}

// WithOffset clones a new Rect2D with the value of
// Offset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Rect2D) WithOffset(y Offset2D) Rect2D {
	x.offset = *( /* typedef */ (*C.struct_VkOffset2D)(&y))
	return x
}
func (x *Rect2D) SetOffset(y Offset2D) {
	x.offset = *( /* typedef */ (*C.struct_VkOffset2D)(&y))
}

// Extent returns the value of extent from VkRect2D
func (x Rect2D) Extent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.extent)
	return *ptr
}

// WithExtent clones a new Rect2D with the value of
// Extent updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Rect2D) WithExtent(y Extent2D) Rect2D {
	x.extent = *( /* typedef */ (*C.struct_VkExtent2D)(&y))
	return x
}
func (x *Rect2D) SetExtent(y Extent2D) {
	x.extent = *( /* typedef */ (*C.struct_VkExtent2D)(&y))
}

// RenderPassBeginInfo provides a go interface for VkRenderPassBeginInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassBeginInfo.html
type RenderPassBeginInfo C.struct_VkRenderPassBeginInfo

// SizeofRenderPassBeginInfo is the memory size of a RenderPassBeginInfo
var SizeofRenderPassBeginInfo int = int(unsafe.Sizeof(RenderPassBeginInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x RenderPassBeginInfo) ArpPtr(arp *AutoReleasePool) *RenderPassBeginInfo {
	ptr := newCBlock(cULong(SizeofRenderPassBeginInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*RenderPassBeginInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *RenderPassBeginInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x RenderPassBeginInfo) AsCPtr() *RenderPassBeginInfo {
	clone := (*RenderPassBeginInfo)(newCBlock(cULong(SizeofRenderPassBeginInfo)))
	*clone = x
	return clone
}

// RenderPassBeginInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func RenderPassBeginInfoCSlice(arp *AutoReleasePool, x ...RenderPassBeginInfo) []RenderPassBeginInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderPassBeginInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*RenderPassBeginInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// RenderPassBeginInfoFreeCSlice releases the memory allocated by RenderPassBeginInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func RenderPassBeginInfoFreeCSlice(x []RenderPassBeginInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// RenderPassBeginInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. RenderPassBeginInfoFreeCSlice must be called on the returned slice.
func RenderPassBeginInfoMakeCSlice(x ...RenderPassBeginInfo) []RenderPassBeginInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderPassBeginInfo * len(x)
	dst := unsafe.Slice((*RenderPassBeginInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkRenderPassBeginInfo
func (x RenderPassBeginInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new RenderPassBeginInfo with the value of
// SType to the value provided in the specification.
func (x RenderPassBeginInfo) WithDefaultSType() RenderPassBeginInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *RenderPassBeginInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO)
}

// WithSType clones a new RenderPassBeginInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassBeginInfo) WithSType(y StructureType) RenderPassBeginInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *RenderPassBeginInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkRenderPassBeginInfo
func (x RenderPassBeginInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new RenderPassBeginInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassBeginInfo) WithPNext(y unsafe.Pointer) RenderPassBeginInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *RenderPassBeginInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// RenderPass returns the value of renderPass from VkRenderPassBeginInfo
func (x RenderPassBeginInfo) RenderPass() RenderPass {
	ptr := /* handle */ (*RenderPass)(&x.renderPass)
	return *ptr
}

// WithRenderPass clones a new RenderPassBeginInfo with the value of
// RenderPass updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassBeginInfo) WithRenderPass(y RenderPass) RenderPassBeginInfo {
	x.renderPass = *( /* handle */ (*C.VkRenderPass)(&y))
	return x
}
func (x *RenderPassBeginInfo) SetRenderPass(y RenderPass) {
	x.renderPass = *( /* handle */ (*C.VkRenderPass)(&y))
}

// Framebuffer returns the value of framebuffer from VkRenderPassBeginInfo
func (x RenderPassBeginInfo) Framebuffer() Framebuffer {
	ptr := /* handle */ (*Framebuffer)(&x.framebuffer)
	return *ptr
}

// WithFramebuffer clones a new RenderPassBeginInfo with the value of
// Framebuffer updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassBeginInfo) WithFramebuffer(y Framebuffer) RenderPassBeginInfo {
	x.framebuffer = *( /* handle */ (*C.VkFramebuffer)(&y))
	return x
}
func (x *RenderPassBeginInfo) SetFramebuffer(y Framebuffer) {
	x.framebuffer = *( /* handle */ (*C.VkFramebuffer)(&y))
}

// RenderArea returns the value of renderArea from VkRenderPassBeginInfo
func (x RenderPassBeginInfo) RenderArea() Rect2D {
	ptr := /* typedef */ (*Rect2D)(&x.renderArea)
	return *ptr
}

// WithRenderArea clones a new RenderPassBeginInfo with the value of
// RenderArea updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassBeginInfo) WithRenderArea(y Rect2D) RenderPassBeginInfo {
	x.renderArea = *( /* typedef */ (*C.struct_VkRect2D)(&y))
	return x
}
func (x *RenderPassBeginInfo) SetRenderArea(y Rect2D) {
	x.renderArea = *( /* typedef */ (*C.struct_VkRect2D)(&y))
}

// ClearValueCount returns the value of clearValueCount from VkRenderPassBeginInfo
func (x RenderPassBeginInfo) ClearValueCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.clearValueCount)
	return *ptr
}

// WithClearValueCount clones a new RenderPassBeginInfo with the value of
// ClearValueCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassBeginInfo) WithClearValueCount(y uint32) RenderPassBeginInfo {
	x.clearValueCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *RenderPassBeginInfo) SetClearValueCount(y uint32) {
	x.clearValueCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PClearValues returns the value of pClearValues from VkRenderPassBeginInfo
func (x RenderPassBeginInfo) PClearValues() []ClearValue {
	ptr := func(x **C.VkClearValue) *[]ClearValue { /* Slice */
		slc := unsafe.Slice((*ClearValue)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pClearValues)
	return *ptr
}

// WithPClearValues clones a new RenderPassBeginInfo with the value of
// PClearValues updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines ClearValueCount as the length of this field.
// ClearValueCount is updated with the length of the new value.
func (x RenderPassBeginInfo) WithPClearValues(y []ClearValue) RenderPassBeginInfo {
	x.pClearValues = *(func(x *[]ClearValue) **C.VkClearValue { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkClearValue)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkClearValue)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithClearValueCount(uint32(len(y)))
}
func (x *RenderPassBeginInfo) SetPClearValues(y []ClearValue) {
	x.pClearValues = *(func(x *[]ClearValue) **C.VkClearValue { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkClearValue)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkClearValue)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetClearValueCount(uint32(len(y)))
}

// EventCreateInfo provides a go interface for VkEventCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkEventCreateInfo.html
type EventCreateInfo C.struct_VkEventCreateInfo

// SizeofEventCreateInfo is the memory size of a EventCreateInfo
var SizeofEventCreateInfo int = int(unsafe.Sizeof(EventCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x EventCreateInfo) ArpPtr(arp *AutoReleasePool) *EventCreateInfo {
	ptr := newCBlock(cULong(SizeofEventCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*EventCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *EventCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x EventCreateInfo) AsCPtr() *EventCreateInfo {
	clone := (*EventCreateInfo)(newCBlock(cULong(SizeofEventCreateInfo)))
	*clone = x
	return clone
}

// EventCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func EventCreateInfoCSlice(arp *AutoReleasePool, x ...EventCreateInfo) []EventCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofEventCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*EventCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// EventCreateInfoFreeCSlice releases the memory allocated by EventCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func EventCreateInfoFreeCSlice(x []EventCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// EventCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. EventCreateInfoFreeCSlice must be called on the returned slice.
func EventCreateInfoMakeCSlice(x ...EventCreateInfo) []EventCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofEventCreateInfo * len(x)
	dst := unsafe.Slice((*EventCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkEventCreateInfo
func (x EventCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new EventCreateInfo with the value of
// SType to the value provided in the specification.
func (x EventCreateInfo) WithDefaultSType() EventCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_EVENT_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *EventCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_EVENT_CREATE_INFO)
}

// WithSType clones a new EventCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x EventCreateInfo) WithSType(y StructureType) EventCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *EventCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkEventCreateInfo
func (x EventCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new EventCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x EventCreateInfo) WithPNext(y unsafe.Pointer) EventCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *EventCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkEventCreateInfo
func (x EventCreateInfo) Flags() EventCreateFlags {
	ptr := /* typedef */ (*EventCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new EventCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x EventCreateInfo) WithFlags(y EventCreateFlags) EventCreateInfo {
	x.flags = *( /* typedef */ (*C.VkEventCreateFlags)(&y))
	return x
}
func (x *EventCreateInfo) SetFlags(y EventCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkEventCreateFlags)(&y))
}

// QueryPoolCreateInfo provides a go interface for VkQueryPoolCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPoolCreateInfo.html
type QueryPoolCreateInfo C.struct_VkQueryPoolCreateInfo

// SizeofQueryPoolCreateInfo is the memory size of a QueryPoolCreateInfo
var SizeofQueryPoolCreateInfo int = int(unsafe.Sizeof(QueryPoolCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x QueryPoolCreateInfo) ArpPtr(arp *AutoReleasePool) *QueryPoolCreateInfo {
	ptr := newCBlock(cULong(SizeofQueryPoolCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*QueryPoolCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *QueryPoolCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x QueryPoolCreateInfo) AsCPtr() *QueryPoolCreateInfo {
	clone := (*QueryPoolCreateInfo)(newCBlock(cULong(SizeofQueryPoolCreateInfo)))
	*clone = x
	return clone
}

// QueryPoolCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func QueryPoolCreateInfoCSlice(arp *AutoReleasePool, x ...QueryPoolCreateInfo) []QueryPoolCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofQueryPoolCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*QueryPoolCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// QueryPoolCreateInfoFreeCSlice releases the memory allocated by QueryPoolCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func QueryPoolCreateInfoFreeCSlice(x []QueryPoolCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// QueryPoolCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. QueryPoolCreateInfoFreeCSlice must be called on the returned slice.
func QueryPoolCreateInfoMakeCSlice(x ...QueryPoolCreateInfo) []QueryPoolCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofQueryPoolCreateInfo * len(x)
	dst := unsafe.Slice((*QueryPoolCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkQueryPoolCreateInfo
func (x QueryPoolCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new QueryPoolCreateInfo with the value of
// SType to the value provided in the specification.
func (x QueryPoolCreateInfo) WithDefaultSType() QueryPoolCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *QueryPoolCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO)
}

// WithSType clones a new QueryPoolCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x QueryPoolCreateInfo) WithSType(y StructureType) QueryPoolCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *QueryPoolCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkQueryPoolCreateInfo
func (x QueryPoolCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new QueryPoolCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x QueryPoolCreateInfo) WithPNext(y unsafe.Pointer) QueryPoolCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *QueryPoolCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkQueryPoolCreateInfo
func (x QueryPoolCreateInfo) Flags() QueryPoolCreateFlags {
	ptr := /* typedef */ (*QueryPoolCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new QueryPoolCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x QueryPoolCreateInfo) WithFlags(y QueryPoolCreateFlags) QueryPoolCreateInfo {
	x.flags = *( /* typedef */ (*C.VkQueryPoolCreateFlags)(&y))
	return x
}
func (x *QueryPoolCreateInfo) SetFlags(y QueryPoolCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkQueryPoolCreateFlags)(&y))
}

// QueryType returns the value of queryType from VkQueryPoolCreateInfo
func (x QueryPoolCreateInfo) QueryType() QueryType {
	ptr := /* typedef */ (*QueryType)(&x.queryType)
	return *ptr
}

// WithQueryType clones a new QueryPoolCreateInfo with the value of
// QueryType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x QueryPoolCreateInfo) WithQueryType(y QueryType) QueryPoolCreateInfo {
	x.queryType = *( /* typedef */ (*C.VkQueryType)(&y))
	return x
}
func (x *QueryPoolCreateInfo) SetQueryType(y QueryType) {
	x.queryType = *( /* typedef */ (*C.VkQueryType)(&y))
}

// QueryCount returns the value of queryCount from VkQueryPoolCreateInfo
func (x QueryPoolCreateInfo) QueryCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.queryCount)
	return *ptr
}

// WithQueryCount clones a new QueryPoolCreateInfo with the value of
// QueryCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x QueryPoolCreateInfo) WithQueryCount(y uint32) QueryPoolCreateInfo {
	x.queryCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *QueryPoolCreateInfo) SetQueryCount(y uint32) {
	x.queryCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PipelineStatistics returns the value of pipelineStatistics from VkQueryPoolCreateInfo
func (x QueryPoolCreateInfo) PipelineStatistics() QueryPipelineStatisticFlags {
	ptr := /* typedef */ (*QueryPipelineStatisticFlags)(&x.pipelineStatistics)
	return *ptr
}

// WithPipelineStatistics clones a new QueryPoolCreateInfo with the value of
// PipelineStatistics updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x QueryPoolCreateInfo) WithPipelineStatistics(y QueryPipelineStatisticFlags) QueryPoolCreateInfo {
	x.pipelineStatistics = *( /* typedef */ (*C.VkQueryPipelineStatisticFlags)(&y))
	return x
}
func (x *QueryPoolCreateInfo) SetPipelineStatistics(y QueryPipelineStatisticFlags) {
	x.pipelineStatistics = *( /* typedef */ (*C.VkQueryPipelineStatisticFlags)(&y))
}

// PhysicalDeviceFeatures provides a go interface for VkPhysicalDeviceFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html
type PhysicalDeviceFeatures C.struct_VkPhysicalDeviceFeatures

// SizeofPhysicalDeviceFeatures is the memory size of a PhysicalDeviceFeatures
var SizeofPhysicalDeviceFeatures int = int(unsafe.Sizeof(PhysicalDeviceFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceFeatures) AsCPtr() *PhysicalDeviceFeatures {
	clone := (*PhysicalDeviceFeatures)(newCBlock(cULong(SizeofPhysicalDeviceFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceFeatures) []PhysicalDeviceFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceFeaturesFreeCSlice(x []PhysicalDeviceFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceFeaturesMakeCSlice(x ...PhysicalDeviceFeatures) []PhysicalDeviceFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// RobustBufferAccess returns the value of robustBufferAccess from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) RobustBufferAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.robustBufferAccess)
	return *ptr
}

// WithRobustBufferAccess clones a new PhysicalDeviceFeatures with the value of
// RobustBufferAccess updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithRobustBufferAccess(y Bool32) PhysicalDeviceFeatures {
	x.robustBufferAccess = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetRobustBufferAccess(y Bool32) {
	x.robustBufferAccess = *( /* typedef */ (*C.VkBool32)(&y))
}

// FullDrawIndexUint32 returns the value of fullDrawIndexUint32 from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) FullDrawIndexUint32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.fullDrawIndexUint32)
	return *ptr
}

// WithFullDrawIndexUint32 clones a new PhysicalDeviceFeatures with the value of
// FullDrawIndexUint32 updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithFullDrawIndexUint32(y Bool32) PhysicalDeviceFeatures {
	x.fullDrawIndexUint32 = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetFullDrawIndexUint32(y Bool32) {
	x.fullDrawIndexUint32 = *( /* typedef */ (*C.VkBool32)(&y))
}

// ImageCubeArray returns the value of imageCubeArray from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ImageCubeArray() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.imageCubeArray)
	return *ptr
}

// WithImageCubeArray clones a new PhysicalDeviceFeatures with the value of
// ImageCubeArray updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithImageCubeArray(y Bool32) PhysicalDeviceFeatures {
	x.imageCubeArray = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetImageCubeArray(y Bool32) {
	x.imageCubeArray = *( /* typedef */ (*C.VkBool32)(&y))
}

// IndependentBlend returns the value of independentBlend from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) IndependentBlend() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.independentBlend)
	return *ptr
}

// WithIndependentBlend clones a new PhysicalDeviceFeatures with the value of
// IndependentBlend updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithIndependentBlend(y Bool32) PhysicalDeviceFeatures {
	x.independentBlend = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetIndependentBlend(y Bool32) {
	x.independentBlend = *( /* typedef */ (*C.VkBool32)(&y))
}

// GeometryShader returns the value of geometryShader from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) GeometryShader() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.geometryShader)
	return *ptr
}

// WithGeometryShader clones a new PhysicalDeviceFeatures with the value of
// GeometryShader updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithGeometryShader(y Bool32) PhysicalDeviceFeatures {
	x.geometryShader = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetGeometryShader(y Bool32) {
	x.geometryShader = *( /* typedef */ (*C.VkBool32)(&y))
}

// TessellationShader returns the value of tessellationShader from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) TessellationShader() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.tessellationShader)
	return *ptr
}

// WithTessellationShader clones a new PhysicalDeviceFeatures with the value of
// TessellationShader updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithTessellationShader(y Bool32) PhysicalDeviceFeatures {
	x.tessellationShader = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetTessellationShader(y Bool32) {
	x.tessellationShader = *( /* typedef */ (*C.VkBool32)(&y))
}

// SampleRateShading returns the value of sampleRateShading from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SampleRateShading() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sampleRateShading)
	return *ptr
}

// WithSampleRateShading clones a new PhysicalDeviceFeatures with the value of
// SampleRateShading updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSampleRateShading(y Bool32) PhysicalDeviceFeatures {
	x.sampleRateShading = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetSampleRateShading(y Bool32) {
	x.sampleRateShading = *( /* typedef */ (*C.VkBool32)(&y))
}

// DualSrcBlend returns the value of dualSrcBlend from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) DualSrcBlend() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.dualSrcBlend)
	return *ptr
}

// WithDualSrcBlend clones a new PhysicalDeviceFeatures with the value of
// DualSrcBlend updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithDualSrcBlend(y Bool32) PhysicalDeviceFeatures {
	x.dualSrcBlend = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetDualSrcBlend(y Bool32) {
	x.dualSrcBlend = *( /* typedef */ (*C.VkBool32)(&y))
}

// LogicOp returns the value of logicOp from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) LogicOp() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.logicOp)
	return *ptr
}

// WithLogicOp clones a new PhysicalDeviceFeatures with the value of
// LogicOp updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithLogicOp(y Bool32) PhysicalDeviceFeatures {
	x.logicOp = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetLogicOp(y Bool32) {
	x.logicOp = *( /* typedef */ (*C.VkBool32)(&y))
}

// MultiDrawIndirect returns the value of multiDrawIndirect from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) MultiDrawIndirect() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.multiDrawIndirect)
	return *ptr
}

// WithMultiDrawIndirect clones a new PhysicalDeviceFeatures with the value of
// MultiDrawIndirect updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithMultiDrawIndirect(y Bool32) PhysicalDeviceFeatures {
	x.multiDrawIndirect = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetMultiDrawIndirect(y Bool32) {
	x.multiDrawIndirect = *( /* typedef */ (*C.VkBool32)(&y))
}

// DrawIndirectFirstInstance returns the value of drawIndirectFirstInstance from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) DrawIndirectFirstInstance() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.drawIndirectFirstInstance)
	return *ptr
}

// WithDrawIndirectFirstInstance clones a new PhysicalDeviceFeatures with the value of
// DrawIndirectFirstInstance updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithDrawIndirectFirstInstance(y Bool32) PhysicalDeviceFeatures {
	x.drawIndirectFirstInstance = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetDrawIndirectFirstInstance(y Bool32) {
	x.drawIndirectFirstInstance = *( /* typedef */ (*C.VkBool32)(&y))
}

// DepthClamp returns the value of depthClamp from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) DepthClamp() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.depthClamp)
	return *ptr
}

// WithDepthClamp clones a new PhysicalDeviceFeatures with the value of
// DepthClamp updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithDepthClamp(y Bool32) PhysicalDeviceFeatures {
	x.depthClamp = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetDepthClamp(y Bool32) {
	x.depthClamp = *( /* typedef */ (*C.VkBool32)(&y))
}

// DepthBiasClamp returns the value of depthBiasClamp from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) DepthBiasClamp() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.depthBiasClamp)
	return *ptr
}

// WithDepthBiasClamp clones a new PhysicalDeviceFeatures with the value of
// DepthBiasClamp updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithDepthBiasClamp(y Bool32) PhysicalDeviceFeatures {
	x.depthBiasClamp = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetDepthBiasClamp(y Bool32) {
	x.depthBiasClamp = *( /* typedef */ (*C.VkBool32)(&y))
}

// FillModeNonSolid returns the value of fillModeNonSolid from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) FillModeNonSolid() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.fillModeNonSolid)
	return *ptr
}

// WithFillModeNonSolid clones a new PhysicalDeviceFeatures with the value of
// FillModeNonSolid updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithFillModeNonSolid(y Bool32) PhysicalDeviceFeatures {
	x.fillModeNonSolid = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetFillModeNonSolid(y Bool32) {
	x.fillModeNonSolid = *( /* typedef */ (*C.VkBool32)(&y))
}

// DepthBounds returns the value of depthBounds from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) DepthBounds() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.depthBounds)
	return *ptr
}

// WithDepthBounds clones a new PhysicalDeviceFeatures with the value of
// DepthBounds updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithDepthBounds(y Bool32) PhysicalDeviceFeatures {
	x.depthBounds = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetDepthBounds(y Bool32) {
	x.depthBounds = *( /* typedef */ (*C.VkBool32)(&y))
}

// WideLines returns the value of wideLines from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) WideLines() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.wideLines)
	return *ptr
}

// WithWideLines clones a new PhysicalDeviceFeatures with the value of
// WideLines updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithWideLines(y Bool32) PhysicalDeviceFeatures {
	x.wideLines = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetWideLines(y Bool32) {
	x.wideLines = *( /* typedef */ (*C.VkBool32)(&y))
}

// LargePoints returns the value of largePoints from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) LargePoints() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.largePoints)
	return *ptr
}

// WithLargePoints clones a new PhysicalDeviceFeatures with the value of
// LargePoints updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithLargePoints(y Bool32) PhysicalDeviceFeatures {
	x.largePoints = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetLargePoints(y Bool32) {
	x.largePoints = *( /* typedef */ (*C.VkBool32)(&y))
}

// AlphaToOne returns the value of alphaToOne from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) AlphaToOne() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.alphaToOne)
	return *ptr
}

// WithAlphaToOne clones a new PhysicalDeviceFeatures with the value of
// AlphaToOne updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithAlphaToOne(y Bool32) PhysicalDeviceFeatures {
	x.alphaToOne = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetAlphaToOne(y Bool32) {
	x.alphaToOne = *( /* typedef */ (*C.VkBool32)(&y))
}

// MultiViewport returns the value of multiViewport from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) MultiViewport() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.multiViewport)
	return *ptr
}

// WithMultiViewport clones a new PhysicalDeviceFeatures with the value of
// MultiViewport updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithMultiViewport(y Bool32) PhysicalDeviceFeatures {
	x.multiViewport = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetMultiViewport(y Bool32) {
	x.multiViewport = *( /* typedef */ (*C.VkBool32)(&y))
}

// SamplerAnisotropy returns the value of samplerAnisotropy from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SamplerAnisotropy() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.samplerAnisotropy)
	return *ptr
}

// WithSamplerAnisotropy clones a new PhysicalDeviceFeatures with the value of
// SamplerAnisotropy updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSamplerAnisotropy(y Bool32) PhysicalDeviceFeatures {
	x.samplerAnisotropy = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetSamplerAnisotropy(y Bool32) {
	x.samplerAnisotropy = *( /* typedef */ (*C.VkBool32)(&y))
}

// TextureCompressionETC2 returns the value of textureCompressionETC2 from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) TextureCompressionETC2() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.textureCompressionETC2)
	return *ptr
}

// WithTextureCompressionETC2 clones a new PhysicalDeviceFeatures with the value of
// TextureCompressionETC2 updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithTextureCompressionETC2(y Bool32) PhysicalDeviceFeatures {
	x.textureCompressionETC2 = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetTextureCompressionETC2(y Bool32) {
	x.textureCompressionETC2 = *( /* typedef */ (*C.VkBool32)(&y))
}

// TextureCompressionASTC_LDR returns the value of textureCompressionASTC_LDR from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) TextureCompressionASTC_LDR() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.textureCompressionASTC_LDR)
	return *ptr
}

// WithTextureCompressionASTC_LDR clones a new PhysicalDeviceFeatures with the value of
// TextureCompressionASTC_LDR updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithTextureCompressionASTC_LDR(y Bool32) PhysicalDeviceFeatures {
	x.textureCompressionASTC_LDR = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetTextureCompressionASTC_LDR(y Bool32) {
	x.textureCompressionASTC_LDR = *( /* typedef */ (*C.VkBool32)(&y))
}

// TextureCompressionBC returns the value of textureCompressionBC from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) TextureCompressionBC() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.textureCompressionBC)
	return *ptr
}

// WithTextureCompressionBC clones a new PhysicalDeviceFeatures with the value of
// TextureCompressionBC updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithTextureCompressionBC(y Bool32) PhysicalDeviceFeatures {
	x.textureCompressionBC = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetTextureCompressionBC(y Bool32) {
	x.textureCompressionBC = *( /* typedef */ (*C.VkBool32)(&y))
}

// OcclusionQueryPrecise returns the value of occlusionQueryPrecise from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) OcclusionQueryPrecise() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.occlusionQueryPrecise)
	return *ptr
}

// WithOcclusionQueryPrecise clones a new PhysicalDeviceFeatures with the value of
// OcclusionQueryPrecise updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithOcclusionQueryPrecise(y Bool32) PhysicalDeviceFeatures {
	x.occlusionQueryPrecise = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetOcclusionQueryPrecise(y Bool32) {
	x.occlusionQueryPrecise = *( /* typedef */ (*C.VkBool32)(&y))
}

// PipelineStatisticsQuery returns the value of pipelineStatisticsQuery from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) PipelineStatisticsQuery() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.pipelineStatisticsQuery)
	return *ptr
}

// WithPipelineStatisticsQuery clones a new PhysicalDeviceFeatures with the value of
// PipelineStatisticsQuery updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithPipelineStatisticsQuery(y Bool32) PhysicalDeviceFeatures {
	x.pipelineStatisticsQuery = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetPipelineStatisticsQuery(y Bool32) {
	x.pipelineStatisticsQuery = *( /* typedef */ (*C.VkBool32)(&y))
}

// VertexPipelineStoresAndAtomics returns the value of vertexPipelineStoresAndAtomics from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) VertexPipelineStoresAndAtomics() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.vertexPipelineStoresAndAtomics)
	return *ptr
}

// WithVertexPipelineStoresAndAtomics clones a new PhysicalDeviceFeatures with the value of
// VertexPipelineStoresAndAtomics updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithVertexPipelineStoresAndAtomics(y Bool32) PhysicalDeviceFeatures {
	x.vertexPipelineStoresAndAtomics = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetVertexPipelineStoresAndAtomics(y Bool32) {
	x.vertexPipelineStoresAndAtomics = *( /* typedef */ (*C.VkBool32)(&y))
}

// FragmentStoresAndAtomics returns the value of fragmentStoresAndAtomics from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) FragmentStoresAndAtomics() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.fragmentStoresAndAtomics)
	return *ptr
}

// WithFragmentStoresAndAtomics clones a new PhysicalDeviceFeatures with the value of
// FragmentStoresAndAtomics updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithFragmentStoresAndAtomics(y Bool32) PhysicalDeviceFeatures {
	x.fragmentStoresAndAtomics = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetFragmentStoresAndAtomics(y Bool32) {
	x.fragmentStoresAndAtomics = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderTessellationAndGeometryPointSize returns the value of shaderTessellationAndGeometryPointSize from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderTessellationAndGeometryPointSize() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderTessellationAndGeometryPointSize)
	return *ptr
}

// WithShaderTessellationAndGeometryPointSize clones a new PhysicalDeviceFeatures with the value of
// ShaderTessellationAndGeometryPointSize updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderTessellationAndGeometryPointSize(y Bool32) PhysicalDeviceFeatures {
	x.shaderTessellationAndGeometryPointSize = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetShaderTessellationAndGeometryPointSize(y Bool32) {
	x.shaderTessellationAndGeometryPointSize = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderImageGatherExtended returns the value of shaderImageGatherExtended from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderImageGatherExtended() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderImageGatherExtended)
	return *ptr
}

// WithShaderImageGatherExtended clones a new PhysicalDeviceFeatures with the value of
// ShaderImageGatherExtended updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderImageGatherExtended(y Bool32) PhysicalDeviceFeatures {
	x.shaderImageGatherExtended = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetShaderImageGatherExtended(y Bool32) {
	x.shaderImageGatherExtended = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderStorageImageExtendedFormats returns the value of shaderStorageImageExtendedFormats from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderStorageImageExtendedFormats() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageImageExtendedFormats)
	return *ptr
}

// WithShaderStorageImageExtendedFormats clones a new PhysicalDeviceFeatures with the value of
// ShaderStorageImageExtendedFormats updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderStorageImageExtendedFormats(y Bool32) PhysicalDeviceFeatures {
	x.shaderStorageImageExtendedFormats = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetShaderStorageImageExtendedFormats(y Bool32) {
	x.shaderStorageImageExtendedFormats = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderStorageImageMultisample returns the value of shaderStorageImageMultisample from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderStorageImageMultisample() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageImageMultisample)
	return *ptr
}

// WithShaderStorageImageMultisample clones a new PhysicalDeviceFeatures with the value of
// ShaderStorageImageMultisample updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderStorageImageMultisample(y Bool32) PhysicalDeviceFeatures {
	x.shaderStorageImageMultisample = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetShaderStorageImageMultisample(y Bool32) {
	x.shaderStorageImageMultisample = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderStorageImageReadWithoutFormat returns the value of shaderStorageImageReadWithoutFormat from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderStorageImageReadWithoutFormat() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageImageReadWithoutFormat)
	return *ptr
}

// WithShaderStorageImageReadWithoutFormat clones a new PhysicalDeviceFeatures with the value of
// ShaderStorageImageReadWithoutFormat updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderStorageImageReadWithoutFormat(y Bool32) PhysicalDeviceFeatures {
	x.shaderStorageImageReadWithoutFormat = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetShaderStorageImageReadWithoutFormat(y Bool32) {
	x.shaderStorageImageReadWithoutFormat = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderStorageImageWriteWithoutFormat returns the value of shaderStorageImageWriteWithoutFormat from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderStorageImageWriteWithoutFormat() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageImageWriteWithoutFormat)
	return *ptr
}

// WithShaderStorageImageWriteWithoutFormat clones a new PhysicalDeviceFeatures with the value of
// ShaderStorageImageWriteWithoutFormat updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderStorageImageWriteWithoutFormat(y Bool32) PhysicalDeviceFeatures {
	x.shaderStorageImageWriteWithoutFormat = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetShaderStorageImageWriteWithoutFormat(y Bool32) {
	x.shaderStorageImageWriteWithoutFormat = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderUniformBufferArrayDynamicIndexing returns the value of shaderUniformBufferArrayDynamicIndexing from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderUniformBufferArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderUniformBufferArrayDynamicIndexing)
	return *ptr
}

// WithShaderUniformBufferArrayDynamicIndexing clones a new PhysicalDeviceFeatures with the value of
// ShaderUniformBufferArrayDynamicIndexing updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderUniformBufferArrayDynamicIndexing(y Bool32) PhysicalDeviceFeatures {
	x.shaderUniformBufferArrayDynamicIndexing = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetShaderUniformBufferArrayDynamicIndexing(y Bool32) {
	x.shaderUniformBufferArrayDynamicIndexing = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderSampledImageArrayDynamicIndexing returns the value of shaderSampledImageArrayDynamicIndexing from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderSampledImageArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSampledImageArrayDynamicIndexing)
	return *ptr
}

// WithShaderSampledImageArrayDynamicIndexing clones a new PhysicalDeviceFeatures with the value of
// ShaderSampledImageArrayDynamicIndexing updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderSampledImageArrayDynamicIndexing(y Bool32) PhysicalDeviceFeatures {
	x.shaderSampledImageArrayDynamicIndexing = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetShaderSampledImageArrayDynamicIndexing(y Bool32) {
	x.shaderSampledImageArrayDynamicIndexing = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderStorageBufferArrayDynamicIndexing returns the value of shaderStorageBufferArrayDynamicIndexing from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderStorageBufferArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageBufferArrayDynamicIndexing)
	return *ptr
}

// WithShaderStorageBufferArrayDynamicIndexing clones a new PhysicalDeviceFeatures with the value of
// ShaderStorageBufferArrayDynamicIndexing updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderStorageBufferArrayDynamicIndexing(y Bool32) PhysicalDeviceFeatures {
	x.shaderStorageBufferArrayDynamicIndexing = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetShaderStorageBufferArrayDynamicIndexing(y Bool32) {
	x.shaderStorageBufferArrayDynamicIndexing = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderStorageImageArrayDynamicIndexing returns the value of shaderStorageImageArrayDynamicIndexing from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderStorageImageArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageImageArrayDynamicIndexing)
	return *ptr
}

// WithShaderStorageImageArrayDynamicIndexing clones a new PhysicalDeviceFeatures with the value of
// ShaderStorageImageArrayDynamicIndexing updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderStorageImageArrayDynamicIndexing(y Bool32) PhysicalDeviceFeatures {
	x.shaderStorageImageArrayDynamicIndexing = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetShaderStorageImageArrayDynamicIndexing(y Bool32) {
	x.shaderStorageImageArrayDynamicIndexing = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderClipDistance returns the value of shaderClipDistance from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderClipDistance() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderClipDistance)
	return *ptr
}

// WithShaderClipDistance clones a new PhysicalDeviceFeatures with the value of
// ShaderClipDistance updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderClipDistance(y Bool32) PhysicalDeviceFeatures {
	x.shaderClipDistance = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetShaderClipDistance(y Bool32) {
	x.shaderClipDistance = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderCullDistance returns the value of shaderCullDistance from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderCullDistance() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderCullDistance)
	return *ptr
}

// WithShaderCullDistance clones a new PhysicalDeviceFeatures with the value of
// ShaderCullDistance updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderCullDistance(y Bool32) PhysicalDeviceFeatures {
	x.shaderCullDistance = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetShaderCullDistance(y Bool32) {
	x.shaderCullDistance = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderFloat64 returns the value of shaderFloat64 from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderFloat64)
	return *ptr
}

// WithShaderFloat64 clones a new PhysicalDeviceFeatures with the value of
// ShaderFloat64 updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderFloat64(y Bool32) PhysicalDeviceFeatures {
	x.shaderFloat64 = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetShaderFloat64(y Bool32) {
	x.shaderFloat64 = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderInt64 returns the value of shaderInt64 from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderInt64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInt64)
	return *ptr
}

// WithShaderInt64 clones a new PhysicalDeviceFeatures with the value of
// ShaderInt64 updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderInt64(y Bool32) PhysicalDeviceFeatures {
	x.shaderInt64 = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetShaderInt64(y Bool32) {
	x.shaderInt64 = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderInt16 returns the value of shaderInt16 from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderInt16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInt16)
	return *ptr
}

// WithShaderInt16 clones a new PhysicalDeviceFeatures with the value of
// ShaderInt16 updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderInt16(y Bool32) PhysicalDeviceFeatures {
	x.shaderInt16 = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetShaderInt16(y Bool32) {
	x.shaderInt16 = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderResourceResidency returns the value of shaderResourceResidency from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderResourceResidency() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderResourceResidency)
	return *ptr
}

// WithShaderResourceResidency clones a new PhysicalDeviceFeatures with the value of
// ShaderResourceResidency updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderResourceResidency(y Bool32) PhysicalDeviceFeatures {
	x.shaderResourceResidency = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetShaderResourceResidency(y Bool32) {
	x.shaderResourceResidency = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderResourceMinLod returns the value of shaderResourceMinLod from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderResourceMinLod() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderResourceMinLod)
	return *ptr
}

// WithShaderResourceMinLod clones a new PhysicalDeviceFeatures with the value of
// ShaderResourceMinLod updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderResourceMinLod(y Bool32) PhysicalDeviceFeatures {
	x.shaderResourceMinLod = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetShaderResourceMinLod(y Bool32) {
	x.shaderResourceMinLod = *( /* typedef */ (*C.VkBool32)(&y))
}

// SparseBinding returns the value of sparseBinding from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SparseBinding() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sparseBinding)
	return *ptr
}

// WithSparseBinding clones a new PhysicalDeviceFeatures with the value of
// SparseBinding updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSparseBinding(y Bool32) PhysicalDeviceFeatures {
	x.sparseBinding = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetSparseBinding(y Bool32) {
	x.sparseBinding = *( /* typedef */ (*C.VkBool32)(&y))
}

// SparseResidencyBuffer returns the value of sparseResidencyBuffer from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SparseResidencyBuffer() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sparseResidencyBuffer)
	return *ptr
}

// WithSparseResidencyBuffer clones a new PhysicalDeviceFeatures with the value of
// SparseResidencyBuffer updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSparseResidencyBuffer(y Bool32) PhysicalDeviceFeatures {
	x.sparseResidencyBuffer = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetSparseResidencyBuffer(y Bool32) {
	x.sparseResidencyBuffer = *( /* typedef */ (*C.VkBool32)(&y))
}

// SparseResidencyImage2D returns the value of sparseResidencyImage2D from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SparseResidencyImage2D() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sparseResidencyImage2D)
	return *ptr
}

// WithSparseResidencyImage2D clones a new PhysicalDeviceFeatures with the value of
// SparseResidencyImage2D updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSparseResidencyImage2D(y Bool32) PhysicalDeviceFeatures {
	x.sparseResidencyImage2D = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetSparseResidencyImage2D(y Bool32) {
	x.sparseResidencyImage2D = *( /* typedef */ (*C.VkBool32)(&y))
}

// SparseResidencyImage3D returns the value of sparseResidencyImage3D from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SparseResidencyImage3D() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sparseResidencyImage3D)
	return *ptr
}

// WithSparseResidencyImage3D clones a new PhysicalDeviceFeatures with the value of
// SparseResidencyImage3D updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSparseResidencyImage3D(y Bool32) PhysicalDeviceFeatures {
	x.sparseResidencyImage3D = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetSparseResidencyImage3D(y Bool32) {
	x.sparseResidencyImage3D = *( /* typedef */ (*C.VkBool32)(&y))
}

// SparseResidency2Samples returns the value of sparseResidency2Samples from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SparseResidency2Samples() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sparseResidency2Samples)
	return *ptr
}

// WithSparseResidency2Samples clones a new PhysicalDeviceFeatures with the value of
// SparseResidency2Samples updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSparseResidency2Samples(y Bool32) PhysicalDeviceFeatures {
	x.sparseResidency2Samples = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetSparseResidency2Samples(y Bool32) {
	x.sparseResidency2Samples = *( /* typedef */ (*C.VkBool32)(&y))
}

// SparseResidency4Samples returns the value of sparseResidency4Samples from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SparseResidency4Samples() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sparseResidency4Samples)
	return *ptr
}

// WithSparseResidency4Samples clones a new PhysicalDeviceFeatures with the value of
// SparseResidency4Samples updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSparseResidency4Samples(y Bool32) PhysicalDeviceFeatures {
	x.sparseResidency4Samples = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetSparseResidency4Samples(y Bool32) {
	x.sparseResidency4Samples = *( /* typedef */ (*C.VkBool32)(&y))
}

// SparseResidency8Samples returns the value of sparseResidency8Samples from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SparseResidency8Samples() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sparseResidency8Samples)
	return *ptr
}

// WithSparseResidency8Samples clones a new PhysicalDeviceFeatures with the value of
// SparseResidency8Samples updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSparseResidency8Samples(y Bool32) PhysicalDeviceFeatures {
	x.sparseResidency8Samples = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetSparseResidency8Samples(y Bool32) {
	x.sparseResidency8Samples = *( /* typedef */ (*C.VkBool32)(&y))
}

// SparseResidency16Samples returns the value of sparseResidency16Samples from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SparseResidency16Samples() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sparseResidency16Samples)
	return *ptr
}

// WithSparseResidency16Samples clones a new PhysicalDeviceFeatures with the value of
// SparseResidency16Samples updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSparseResidency16Samples(y Bool32) PhysicalDeviceFeatures {
	x.sparseResidency16Samples = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetSparseResidency16Samples(y Bool32) {
	x.sparseResidency16Samples = *( /* typedef */ (*C.VkBool32)(&y))
}

// SparseResidencyAliased returns the value of sparseResidencyAliased from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SparseResidencyAliased() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sparseResidencyAliased)
	return *ptr
}

// WithSparseResidencyAliased clones a new PhysicalDeviceFeatures with the value of
// SparseResidencyAliased updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSparseResidencyAliased(y Bool32) PhysicalDeviceFeatures {
	x.sparseResidencyAliased = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetSparseResidencyAliased(y Bool32) {
	x.sparseResidencyAliased = *( /* typedef */ (*C.VkBool32)(&y))
}

// VariableMultisampleRate returns the value of variableMultisampleRate from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) VariableMultisampleRate() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.variableMultisampleRate)
	return *ptr
}

// WithVariableMultisampleRate clones a new PhysicalDeviceFeatures with the value of
// VariableMultisampleRate updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithVariableMultisampleRate(y Bool32) PhysicalDeviceFeatures {
	x.variableMultisampleRate = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetVariableMultisampleRate(y Bool32) {
	x.variableMultisampleRate = *( /* typedef */ (*C.VkBool32)(&y))
}

// InheritedQueries returns the value of inheritedQueries from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) InheritedQueries() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.inheritedQueries)
	return *ptr
}

// WithInheritedQueries clones a new PhysicalDeviceFeatures with the value of
// InheritedQueries updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithInheritedQueries(y Bool32) PhysicalDeviceFeatures {
	x.inheritedQueries = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceFeatures) SetInheritedQueries(y Bool32) {
	x.inheritedQueries = *( /* typedef */ (*C.VkBool32)(&y))
}

// DeviceQueueCreateInfo provides a go interface for VkDeviceQueueCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateInfo.html
type DeviceQueueCreateInfo C.struct_VkDeviceQueueCreateInfo

// SizeofDeviceQueueCreateInfo is the memory size of a DeviceQueueCreateInfo
var SizeofDeviceQueueCreateInfo int = int(unsafe.Sizeof(DeviceQueueCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DeviceQueueCreateInfo) ArpPtr(arp *AutoReleasePool) *DeviceQueueCreateInfo {
	ptr := newCBlock(cULong(SizeofDeviceQueueCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DeviceQueueCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceQueueCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceQueueCreateInfo) AsCPtr() *DeviceQueueCreateInfo {
	clone := (*DeviceQueueCreateInfo)(newCBlock(cULong(SizeofDeviceQueueCreateInfo)))
	*clone = x
	return clone
}

// DeviceQueueCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DeviceQueueCreateInfoCSlice(arp *AutoReleasePool, x ...DeviceQueueCreateInfo) []DeviceQueueCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceQueueCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DeviceQueueCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DeviceQueueCreateInfoFreeCSlice releases the memory allocated by DeviceQueueCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceQueueCreateInfoFreeCSlice(x []DeviceQueueCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceQueueCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceQueueCreateInfoFreeCSlice must be called on the returned slice.
func DeviceQueueCreateInfoMakeCSlice(x ...DeviceQueueCreateInfo) []DeviceQueueCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceQueueCreateInfo * len(x)
	dst := unsafe.Slice((*DeviceQueueCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceQueueCreateInfo
func (x DeviceQueueCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DeviceQueueCreateInfo with the value of
// SType to the value provided in the specification.
func (x DeviceQueueCreateInfo) WithDefaultSType() DeviceQueueCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DeviceQueueCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO)
}

// WithSType clones a new DeviceQueueCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueCreateInfo) WithSType(y StructureType) DeviceQueueCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DeviceQueueCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDeviceQueueCreateInfo
func (x DeviceQueueCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DeviceQueueCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueCreateInfo) WithPNext(y unsafe.Pointer) DeviceQueueCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DeviceQueueCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkDeviceQueueCreateInfo
func (x DeviceQueueCreateInfo) Flags() DeviceQueueCreateFlags {
	ptr := /* typedef */ (*DeviceQueueCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new DeviceQueueCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueCreateInfo) WithFlags(y DeviceQueueCreateFlags) DeviceQueueCreateInfo {
	x.flags = *( /* typedef */ (*C.VkDeviceQueueCreateFlags)(&y))
	return x
}
func (x *DeviceQueueCreateInfo) SetFlags(y DeviceQueueCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkDeviceQueueCreateFlags)(&y))
}

// QueueFamilyIndex returns the value of queueFamilyIndex from VkDeviceQueueCreateInfo
func (x DeviceQueueCreateInfo) QueueFamilyIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.queueFamilyIndex)
	return *ptr
}

// WithQueueFamilyIndex clones a new DeviceQueueCreateInfo with the value of
// QueueFamilyIndex updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueCreateInfo) WithQueueFamilyIndex(y uint32) DeviceQueueCreateInfo {
	x.queueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DeviceQueueCreateInfo) SetQueueFamilyIndex(y uint32) {
	x.queueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// QueueCount returns the value of queueCount from VkDeviceQueueCreateInfo
func (x DeviceQueueCreateInfo) QueueCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.queueCount)
	return *ptr
}

// WithQueueCount clones a new DeviceQueueCreateInfo with the value of
// QueueCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueCreateInfo) WithQueueCount(y uint32) DeviceQueueCreateInfo {
	x.queueCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DeviceQueueCreateInfo) SetQueueCount(y uint32) {
	x.queueCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PQueuePriorities returns the value of pQueuePriorities from VkDeviceQueueCreateInfo
func (x DeviceQueueCreateInfo) PQueuePriorities() []float32 {
	ptr := func(x **C.float) *[]float32 { /* Slice */
		slc := unsafe.Slice((*float32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pQueuePriorities)
	return *ptr
}

// WithPQueuePriorities clones a new DeviceQueueCreateInfo with the value of
// PQueuePriorities updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines QueueCount as the length of this field.
// QueueCount is updated with the length of the new value.
func (x DeviceQueueCreateInfo) WithPQueuePriorities(y []float32) DeviceQueueCreateInfo {
	x.pQueuePriorities = *(func(x *[]float32) **C.float { /* Slice */
		if len(*x) > 0 {
			slc := (*C.float)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.float)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithQueueCount(uint32(len(y)))
}
func (x *DeviceQueueCreateInfo) SetPQueuePriorities(y []float32) {
	x.pQueuePriorities = *(func(x *[]float32) **C.float { /* Slice */
		if len(*x) > 0 {
			slc := (*C.float)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.float)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetQueueCount(uint32(len(y)))
}

// DeviceCreateInfo provides a go interface for VkDeviceCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceCreateInfo.html
type DeviceCreateInfo C.struct_VkDeviceCreateInfo

// SizeofDeviceCreateInfo is the memory size of a DeviceCreateInfo
var SizeofDeviceCreateInfo int = int(unsafe.Sizeof(DeviceCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DeviceCreateInfo) ArpPtr(arp *AutoReleasePool) *DeviceCreateInfo {
	ptr := newCBlock(cULong(SizeofDeviceCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DeviceCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceCreateInfo) AsCPtr() *DeviceCreateInfo {
	clone := (*DeviceCreateInfo)(newCBlock(cULong(SizeofDeviceCreateInfo)))
	*clone = x
	return clone
}

// DeviceCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DeviceCreateInfoCSlice(arp *AutoReleasePool, x ...DeviceCreateInfo) []DeviceCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DeviceCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DeviceCreateInfoFreeCSlice releases the memory allocated by DeviceCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceCreateInfoFreeCSlice(x []DeviceCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceCreateInfoFreeCSlice must be called on the returned slice.
func DeviceCreateInfoMakeCSlice(x ...DeviceCreateInfo) []DeviceCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceCreateInfo * len(x)
	dst := unsafe.Slice((*DeviceCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceCreateInfo
func (x DeviceCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DeviceCreateInfo with the value of
// SType to the value provided in the specification.
func (x DeviceCreateInfo) WithDefaultSType() DeviceCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DeviceCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO)
}

// WithSType clones a new DeviceCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceCreateInfo) WithSType(y StructureType) DeviceCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DeviceCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDeviceCreateInfo
func (x DeviceCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DeviceCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceCreateInfo) WithPNext(y unsafe.Pointer) DeviceCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DeviceCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkDeviceCreateInfo
func (x DeviceCreateInfo) Flags() DeviceCreateFlags {
	ptr := /* typedef */ (*DeviceCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new DeviceCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceCreateInfo) WithFlags(y DeviceCreateFlags) DeviceCreateInfo {
	x.flags = *( /* typedef */ (*C.VkDeviceCreateFlags)(&y))
	return x
}
func (x *DeviceCreateInfo) SetFlags(y DeviceCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkDeviceCreateFlags)(&y))
}

// QueueCreateInfoCount returns the value of queueCreateInfoCount from VkDeviceCreateInfo
func (x DeviceCreateInfo) QueueCreateInfoCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.queueCreateInfoCount)
	return *ptr
}

// WithQueueCreateInfoCount clones a new DeviceCreateInfo with the value of
// QueueCreateInfoCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceCreateInfo) WithQueueCreateInfoCount(y uint32) DeviceCreateInfo {
	x.queueCreateInfoCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DeviceCreateInfo) SetQueueCreateInfoCount(y uint32) {
	x.queueCreateInfoCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PQueueCreateInfos returns the value of pQueueCreateInfos from VkDeviceCreateInfo
func (x DeviceCreateInfo) PQueueCreateInfos() []DeviceQueueCreateInfo {
	ptr := func(x **C.struct_VkDeviceQueueCreateInfo) *[]DeviceQueueCreateInfo { /* Slice */
		slc := unsafe.Slice((*DeviceQueueCreateInfo)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pQueueCreateInfos)
	return *ptr
}

// WithPQueueCreateInfos clones a new DeviceCreateInfo with the value of
// PQueueCreateInfos updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines QueueCreateInfoCount as the length of this field.
// QueueCreateInfoCount is updated with the length of the new value.
func (x DeviceCreateInfo) WithPQueueCreateInfos(y []DeviceQueueCreateInfo) DeviceCreateInfo {
	x.pQueueCreateInfos = *(func(x *[]DeviceQueueCreateInfo) **C.struct_VkDeviceQueueCreateInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDeviceQueueCreateInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDeviceQueueCreateInfo)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithQueueCreateInfoCount(uint32(len(y)))
}
func (x *DeviceCreateInfo) SetPQueueCreateInfos(y []DeviceQueueCreateInfo) {
	x.pQueueCreateInfos = *(func(x *[]DeviceQueueCreateInfo) **C.struct_VkDeviceQueueCreateInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDeviceQueueCreateInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDeviceQueueCreateInfo)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetQueueCreateInfoCount(uint32(len(y)))
}

// EnabledLayerCount returns the value of enabledLayerCount from VkDeviceCreateInfo
func (x DeviceCreateInfo) EnabledLayerCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.enabledLayerCount)
	return *ptr
}

// WithEnabledLayerCount clones a new DeviceCreateInfo with the value of
// EnabledLayerCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceCreateInfo) WithEnabledLayerCount(y uint32) DeviceCreateInfo {
	x.enabledLayerCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DeviceCreateInfo) SetEnabledLayerCount(y uint32) {
	x.enabledLayerCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PpEnabledLayerNames returns the value of ppEnabledLayerNames from VkDeviceCreateInfo
func (x DeviceCreateInfo) PpEnabledLayerNames() []*byte {
	ptr := func(x ***C.char) *[]*byte { /* Slice */
		slc := unsafe.Slice((**byte)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.ppEnabledLayerNames)
	return *ptr
}

// WithPpEnabledLayerNames clones a new DeviceCreateInfo with the value of
// PpEnabledLayerNames updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceCreateInfo) WithPpEnabledLayerNames(y []*byte) DeviceCreateInfo {
	x.ppEnabledLayerNames = *(func(x *[]*byte) ***C.char { /* Slice */
		if len(*x) > 0 {
			slc := (**C.char)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (***C.char)(unsafe.Pointer((&ptr)))
	}(&y))
	return x
}
func (x *DeviceCreateInfo) SetPpEnabledLayerNames(y []*byte) {
	x.ppEnabledLayerNames = *(func(x *[]*byte) ***C.char { /* Slice */
		if len(*x) > 0 {
			slc := (**C.char)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (***C.char)(unsafe.Pointer((&ptr)))
	}(&y))
}

// EnabledExtensionCount returns the value of enabledExtensionCount from VkDeviceCreateInfo
func (x DeviceCreateInfo) EnabledExtensionCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.enabledExtensionCount)
	return *ptr
}

// WithEnabledExtensionCount clones a new DeviceCreateInfo with the value of
// EnabledExtensionCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceCreateInfo) WithEnabledExtensionCount(y uint32) DeviceCreateInfo {
	x.enabledExtensionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DeviceCreateInfo) SetEnabledExtensionCount(y uint32) {
	x.enabledExtensionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PpEnabledExtensionNames returns the value of ppEnabledExtensionNames from VkDeviceCreateInfo
func (x DeviceCreateInfo) PpEnabledExtensionNames() []*byte {
	ptr := func(x ***C.char) *[]*byte { /* Slice */
		slc := unsafe.Slice((**byte)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.ppEnabledExtensionNames)
	return *ptr
}

// WithPpEnabledExtensionNames clones a new DeviceCreateInfo with the value of
// PpEnabledExtensionNames updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceCreateInfo) WithPpEnabledExtensionNames(y []*byte) DeviceCreateInfo {
	x.ppEnabledExtensionNames = *(func(x *[]*byte) ***C.char { /* Slice */
		if len(*x) > 0 {
			slc := (**C.char)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (***C.char)(unsafe.Pointer((&ptr)))
	}(&y))
	return x
}
func (x *DeviceCreateInfo) SetPpEnabledExtensionNames(y []*byte) {
	x.ppEnabledExtensionNames = *(func(x *[]*byte) ***C.char { /* Slice */
		if len(*x) > 0 {
			slc := (**C.char)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (***C.char)(unsafe.Pointer((&ptr)))
	}(&y))
}

// PEnabledFeatures returns the value of pEnabledFeatures from VkDeviceCreateInfo
func (x DeviceCreateInfo) PEnabledFeatures() *PhysicalDeviceFeatures {
	ptr := func(x **C.struct_VkPhysicalDeviceFeatures) **PhysicalDeviceFeatures { /* Pointer */
		c2g := (*PhysicalDeviceFeatures)(*x)
		return &c2g
	}(&x.pEnabledFeatures)
	return *ptr
}

// WithPEnabledFeatures clones a new DeviceCreateInfo with the value of
// PEnabledFeatures updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceCreateInfo) WithPEnabledFeatures(y *PhysicalDeviceFeatures) DeviceCreateInfo {
	x.pEnabledFeatures = *(func(x **PhysicalDeviceFeatures) **C.struct_VkPhysicalDeviceFeatures { /* Pointer */
		g2c := (*C.struct_VkPhysicalDeviceFeatures)(*x)
		return &g2c
	}(&y))
	return x
}
func (x *DeviceCreateInfo) SetPEnabledFeatures(y *PhysicalDeviceFeatures) {
	x.pEnabledFeatures = *(func(x **PhysicalDeviceFeatures) **C.struct_VkPhysicalDeviceFeatures { /* Pointer */
		g2c := (*C.struct_VkPhysicalDeviceFeatures)(*x)
		return &g2c
	}(&y))
}

// ImageSubresourceLayers provides a go interface for VkImageSubresourceLayers.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSubresourceLayers.html
type ImageSubresourceLayers C.struct_VkImageSubresourceLayers

// SizeofImageSubresourceLayers is the memory size of a ImageSubresourceLayers
var SizeofImageSubresourceLayers int = int(unsafe.Sizeof(ImageSubresourceLayers{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ImageSubresourceLayers) ArpPtr(arp *AutoReleasePool) *ImageSubresourceLayers {
	ptr := newCBlock(cULong(SizeofImageSubresourceLayers))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ImageSubresourceLayers)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageSubresourceLayers) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageSubresourceLayers) AsCPtr() *ImageSubresourceLayers {
	clone := (*ImageSubresourceLayers)(newCBlock(cULong(SizeofImageSubresourceLayers)))
	*clone = x
	return clone
}

// ImageSubresourceLayersCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ImageSubresourceLayersCSlice(arp *AutoReleasePool, x ...ImageSubresourceLayers) []ImageSubresourceLayers {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageSubresourceLayers * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ImageSubresourceLayers)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ImageSubresourceLayersFreeCSlice releases the memory allocated by ImageSubresourceLayersMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageSubresourceLayersFreeCSlice(x []ImageSubresourceLayers) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageSubresourceLayersMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageSubresourceLayersFreeCSlice must be called on the returned slice.
func ImageSubresourceLayersMakeCSlice(x ...ImageSubresourceLayers) []ImageSubresourceLayers {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageSubresourceLayers * len(x)
	dst := unsafe.Slice((*ImageSubresourceLayers)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// AspectMask returns the value of aspectMask from VkImageSubresourceLayers
func (x ImageSubresourceLayers) AspectMask() ImageAspectFlags {
	ptr := /* typedef */ (*ImageAspectFlags)(&x.aspectMask)
	return *ptr
}

// WithAspectMask clones a new ImageSubresourceLayers with the value of
// AspectMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresourceLayers) WithAspectMask(y ImageAspectFlags) ImageSubresourceLayers {
	x.aspectMask = *( /* typedef */ (*C.VkImageAspectFlags)(&y))
	return x
}
func (x *ImageSubresourceLayers) SetAspectMask(y ImageAspectFlags) {
	x.aspectMask = *( /* typedef */ (*C.VkImageAspectFlags)(&y))
}

// MipLevel returns the value of mipLevel from VkImageSubresourceLayers
func (x ImageSubresourceLayers) MipLevel() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.mipLevel)
	return *ptr
}

// WithMipLevel clones a new ImageSubresourceLayers with the value of
// MipLevel updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresourceLayers) WithMipLevel(y uint32) ImageSubresourceLayers {
	x.mipLevel = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *ImageSubresourceLayers) SetMipLevel(y uint32) {
	x.mipLevel = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// BaseArrayLayer returns the value of baseArrayLayer from VkImageSubresourceLayers
func (x ImageSubresourceLayers) BaseArrayLayer() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.baseArrayLayer)
	return *ptr
}

// WithBaseArrayLayer clones a new ImageSubresourceLayers with the value of
// BaseArrayLayer updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresourceLayers) WithBaseArrayLayer(y uint32) ImageSubresourceLayers {
	x.baseArrayLayer = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *ImageSubresourceLayers) SetBaseArrayLayer(y uint32) {
	x.baseArrayLayer = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// LayerCount returns the value of layerCount from VkImageSubresourceLayers
func (x ImageSubresourceLayers) LayerCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.layerCount)
	return *ptr
}

// WithLayerCount clones a new ImageSubresourceLayers with the value of
// LayerCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresourceLayers) WithLayerCount(y uint32) ImageSubresourceLayers {
	x.layerCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *ImageSubresourceLayers) SetLayerCount(y uint32) {
	x.layerCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// Offset3D provides a go interface for VkOffset3D.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkOffset3D.html
type Offset3D C.struct_VkOffset3D

// SizeofOffset3D is the memory size of a Offset3D
var SizeofOffset3D int = int(unsafe.Sizeof(Offset3D{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x Offset3D) ArpPtr(arp *AutoReleasePool) *Offset3D {
	ptr := newCBlock(cULong(SizeofOffset3D))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*Offset3D)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *Offset3D) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x Offset3D) AsCPtr() *Offset3D {
	clone := (*Offset3D)(newCBlock(cULong(SizeofOffset3D)))
	*clone = x
	return clone
}

// Offset3DCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func Offset3DCSlice(arp *AutoReleasePool, x ...Offset3D) []Offset3D {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofOffset3D * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*Offset3D)(ptr), len(x))
	copy(dst, x)
	return dst
}

// Offset3DFreeCSlice releases the memory allocated by Offset3DMakeCSlice.
// It does not free pointers stored inside the slice.
func Offset3DFreeCSlice(x []Offset3D) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// Offset3DMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. Offset3DFreeCSlice must be called on the returned slice.
func Offset3DMakeCSlice(x ...Offset3D) []Offset3D {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofOffset3D * len(x)
	dst := unsafe.Slice((*Offset3D)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// X returns the value of x from VkOffset3D
func (x Offset3D) X() int32 {
	ptr := func(x *C.int32_t) *int32 { /* Scalar */ c2g := int32(*x); return &c2g }(&x.x)
	return *ptr
}

// WithX clones a new Offset3D with the value of
// X updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Offset3D) WithX(y int32) Offset3D {
	x.x = *(func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&y))
	return x
}
func (x *Offset3D) SetX(y int32) {
	x.x = *(func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&y))
}

// Y returns the value of y from VkOffset3D
func (x Offset3D) Y() int32 {
	ptr := func(x *C.int32_t) *int32 { /* Scalar */ c2g := int32(*x); return &c2g }(&x.y)
	return *ptr
}

// WithY clones a new Offset3D with the value of
// Y updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Offset3D) WithY(y int32) Offset3D {
	x.y = *(func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&y))
	return x
}
func (x *Offset3D) SetY(y int32) {
	x.y = *(func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&y))
}

// Z returns the value of z from VkOffset3D
func (x Offset3D) Z() int32 {
	ptr := func(x *C.int32_t) *int32 { /* Scalar */ c2g := int32(*x); return &c2g }(&x.z)
	return *ptr
}

// WithZ clones a new Offset3D with the value of
// Z updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Offset3D) WithZ(y int32) Offset3D {
	x.z = *(func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&y))
	return x
}
func (x *Offset3D) SetZ(y int32) {
	x.z = *(func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&y))
}

// ImageResolve provides a go interface for VkImageResolve.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageResolve.html
type ImageResolve C.struct_VkImageResolve

// SizeofImageResolve is the memory size of a ImageResolve
var SizeofImageResolve int = int(unsafe.Sizeof(ImageResolve{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ImageResolve) ArpPtr(arp *AutoReleasePool) *ImageResolve {
	ptr := newCBlock(cULong(SizeofImageResolve))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ImageResolve)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageResolve) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageResolve) AsCPtr() *ImageResolve {
	clone := (*ImageResolve)(newCBlock(cULong(SizeofImageResolve)))
	*clone = x
	return clone
}

// ImageResolveCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ImageResolveCSlice(arp *AutoReleasePool, x ...ImageResolve) []ImageResolve {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageResolve * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ImageResolve)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ImageResolveFreeCSlice releases the memory allocated by ImageResolveMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageResolveFreeCSlice(x []ImageResolve) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageResolveMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageResolveFreeCSlice must be called on the returned slice.
func ImageResolveMakeCSlice(x ...ImageResolve) []ImageResolve {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageResolve * len(x)
	dst := unsafe.Slice((*ImageResolve)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SrcSubresource returns the value of srcSubresource from VkImageResolve
func (x ImageResolve) SrcSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.srcSubresource)
	return *ptr
}

// WithSrcSubresource clones a new ImageResolve with the value of
// SrcSubresource updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve) WithSrcSubresource(y ImageSubresourceLayers) ImageResolve {
	x.srcSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}
func (x *ImageResolve) SetSrcSubresource(y ImageSubresourceLayers) {
	x.srcSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
}

// SrcOffset returns the value of srcOffset from VkImageResolve
func (x ImageResolve) SrcOffset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.srcOffset)
	return *ptr
}

// WithSrcOffset clones a new ImageResolve with the value of
// SrcOffset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve) WithSrcOffset(y Offset3D) ImageResolve {
	x.srcOffset = *( /* typedef */ (*C.struct_VkOffset3D)(&y))
	return x
}
func (x *ImageResolve) SetSrcOffset(y Offset3D) {
	x.srcOffset = *( /* typedef */ (*C.struct_VkOffset3D)(&y))
}

// DstSubresource returns the value of dstSubresource from VkImageResolve
func (x ImageResolve) DstSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.dstSubresource)
	return *ptr
}

// WithDstSubresource clones a new ImageResolve with the value of
// DstSubresource updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve) WithDstSubresource(y ImageSubresourceLayers) ImageResolve {
	x.dstSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}
func (x *ImageResolve) SetDstSubresource(y ImageSubresourceLayers) {
	x.dstSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
}

// DstOffset returns the value of dstOffset from VkImageResolve
func (x ImageResolve) DstOffset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.dstOffset)
	return *ptr
}

// WithDstOffset clones a new ImageResolve with the value of
// DstOffset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve) WithDstOffset(y Offset3D) ImageResolve {
	x.dstOffset = *( /* typedef */ (*C.struct_VkOffset3D)(&y))
	return x
}
func (x *ImageResolve) SetDstOffset(y Offset3D) {
	x.dstOffset = *( /* typedef */ (*C.struct_VkOffset3D)(&y))
}

// Extent returns the value of extent from VkImageResolve
func (x ImageResolve) Extent() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.extent)
	return *ptr
}

// WithExtent clones a new ImageResolve with the value of
// Extent updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve) WithExtent(y Extent3D) ImageResolve {
	x.extent = *( /* typedef */ (*C.struct_VkExtent3D)(&y))
	return x
}
func (x *ImageResolve) SetExtent(y Extent3D) {
	x.extent = *( /* typedef */ (*C.struct_VkExtent3D)(&y))
}

// ImageCopy provides a go interface for VkImageCopy.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCopy.html
type ImageCopy C.struct_VkImageCopy

// SizeofImageCopy is the memory size of a ImageCopy
var SizeofImageCopy int = int(unsafe.Sizeof(ImageCopy{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ImageCopy) ArpPtr(arp *AutoReleasePool) *ImageCopy {
	ptr := newCBlock(cULong(SizeofImageCopy))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ImageCopy)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageCopy) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageCopy) AsCPtr() *ImageCopy {
	clone := (*ImageCopy)(newCBlock(cULong(SizeofImageCopy)))
	*clone = x
	return clone
}

// ImageCopyCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ImageCopyCSlice(arp *AutoReleasePool, x ...ImageCopy) []ImageCopy {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageCopy * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ImageCopy)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ImageCopyFreeCSlice releases the memory allocated by ImageCopyMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageCopyFreeCSlice(x []ImageCopy) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageCopyMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageCopyFreeCSlice must be called on the returned slice.
func ImageCopyMakeCSlice(x ...ImageCopy) []ImageCopy {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageCopy * len(x)
	dst := unsafe.Slice((*ImageCopy)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SrcSubresource returns the value of srcSubresource from VkImageCopy
func (x ImageCopy) SrcSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.srcSubresource)
	return *ptr
}

// WithSrcSubresource clones a new ImageCopy with the value of
// SrcSubresource updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy) WithSrcSubresource(y ImageSubresourceLayers) ImageCopy {
	x.srcSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}
func (x *ImageCopy) SetSrcSubresource(y ImageSubresourceLayers) {
	x.srcSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
}

// SrcOffset returns the value of srcOffset from VkImageCopy
func (x ImageCopy) SrcOffset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.srcOffset)
	return *ptr
}

// WithSrcOffset clones a new ImageCopy with the value of
// SrcOffset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy) WithSrcOffset(y Offset3D) ImageCopy {
	x.srcOffset = *( /* typedef */ (*C.struct_VkOffset3D)(&y))
	return x
}
func (x *ImageCopy) SetSrcOffset(y Offset3D) {
	x.srcOffset = *( /* typedef */ (*C.struct_VkOffset3D)(&y))
}

// DstSubresource returns the value of dstSubresource from VkImageCopy
func (x ImageCopy) DstSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.dstSubresource)
	return *ptr
}

// WithDstSubresource clones a new ImageCopy with the value of
// DstSubresource updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy) WithDstSubresource(y ImageSubresourceLayers) ImageCopy {
	x.dstSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}
func (x *ImageCopy) SetDstSubresource(y ImageSubresourceLayers) {
	x.dstSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
}

// DstOffset returns the value of dstOffset from VkImageCopy
func (x ImageCopy) DstOffset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.dstOffset)
	return *ptr
}

// WithDstOffset clones a new ImageCopy with the value of
// DstOffset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy) WithDstOffset(y Offset3D) ImageCopy {
	x.dstOffset = *( /* typedef */ (*C.struct_VkOffset3D)(&y))
	return x
}
func (x *ImageCopy) SetDstOffset(y Offset3D) {
	x.dstOffset = *( /* typedef */ (*C.struct_VkOffset3D)(&y))
}

// Extent returns the value of extent from VkImageCopy
func (x ImageCopy) Extent() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.extent)
	return *ptr
}

// WithExtent clones a new ImageCopy with the value of
// Extent updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy) WithExtent(y Extent3D) ImageCopy {
	x.extent = *( /* typedef */ (*C.struct_VkExtent3D)(&y))
	return x
}
func (x *ImageCopy) SetExtent(y Extent3D) {
	x.extent = *( /* typedef */ (*C.struct_VkExtent3D)(&y))
}

// ImageBlit provides a go interface for VkImageBlit.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageBlit.html
type ImageBlit C.struct_VkImageBlit

// SizeofImageBlit is the memory size of a ImageBlit
var SizeofImageBlit int = int(unsafe.Sizeof(ImageBlit{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ImageBlit) ArpPtr(arp *AutoReleasePool) *ImageBlit {
	ptr := newCBlock(cULong(SizeofImageBlit))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ImageBlit)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageBlit) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageBlit) AsCPtr() *ImageBlit {
	clone := (*ImageBlit)(newCBlock(cULong(SizeofImageBlit)))
	*clone = x
	return clone
}

// ImageBlitCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ImageBlitCSlice(arp *AutoReleasePool, x ...ImageBlit) []ImageBlit {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageBlit * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ImageBlit)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ImageBlitFreeCSlice releases the memory allocated by ImageBlitMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageBlitFreeCSlice(x []ImageBlit) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageBlitMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageBlitFreeCSlice must be called on the returned slice.
func ImageBlitMakeCSlice(x ...ImageBlit) []ImageBlit {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageBlit * len(x)
	dst := unsafe.Slice((*ImageBlit)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SrcSubresource returns the value of srcSubresource from VkImageBlit
func (x ImageBlit) SrcSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.srcSubresource)
	return *ptr
}

// WithSrcSubresource clones a new ImageBlit with the value of
// SrcSubresource updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageBlit) WithSrcSubresource(y ImageSubresourceLayers) ImageBlit {
	x.srcSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}
func (x *ImageBlit) SetSrcSubresource(y ImageSubresourceLayers) {
	x.srcSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
}

// SrcOffsets returns the value of srcOffsets from VkImageBlit
func (x ImageBlit) SrcOffsets() []Offset3D {
	ptr := func(x *[2]C.struct_VkOffset3D) *[]Offset3D { /* Array */
		slc := unsafe.Slice((*Offset3D)(unsafe.Pointer(x)), 2)
		return &slc
	}(&x.srcOffsets)
	return *ptr
}

// WithSrcOffsets clones a new ImageBlit with the value of
// SrcOffsets updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageBlit) WithSrcOffsets(y []Offset3D) ImageBlit {
	ptr := func(x *[]Offset3D) **C.struct_VkOffset3D { /* Array */
		if len(*x) > 0 {
			slc := (*C.struct_VkOffset3D)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkOffset3D)(unsafe.Pointer((&ptr)))
	}(&y)
	copy(x.srcOffsets[:], unsafe.Slice(*ptr, len(y)))
	return x
}
func (x *ImageBlit) SetSrcOffsets(y []Offset3D) {
	ptr := func(x *[]Offset3D) **C.struct_VkOffset3D { /* Array */
		if len(*x) > 0 {
			slc := (*C.struct_VkOffset3D)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkOffset3D)(unsafe.Pointer((&ptr)))
	}(&y)
	copy(x.srcOffsets[:], unsafe.Slice(*ptr, len(y)))
}

// DstSubresource returns the value of dstSubresource from VkImageBlit
func (x ImageBlit) DstSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.dstSubresource)
	return *ptr
}

// WithDstSubresource clones a new ImageBlit with the value of
// DstSubresource updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageBlit) WithDstSubresource(y ImageSubresourceLayers) ImageBlit {
	x.dstSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}
func (x *ImageBlit) SetDstSubresource(y ImageSubresourceLayers) {
	x.dstSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
}

// DstOffsets returns the value of dstOffsets from VkImageBlit
func (x ImageBlit) DstOffsets() []Offset3D {
	ptr := func(x *[2]C.struct_VkOffset3D) *[]Offset3D { /* Array */
		slc := unsafe.Slice((*Offset3D)(unsafe.Pointer(x)), 2)
		return &slc
	}(&x.dstOffsets)
	return *ptr
}

// WithDstOffsets clones a new ImageBlit with the value of
// DstOffsets updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageBlit) WithDstOffsets(y []Offset3D) ImageBlit {
	ptr := func(x *[]Offset3D) **C.struct_VkOffset3D { /* Array */
		if len(*x) > 0 {
			slc := (*C.struct_VkOffset3D)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkOffset3D)(unsafe.Pointer((&ptr)))
	}(&y)
	copy(x.dstOffsets[:], unsafe.Slice(*ptr, len(y)))
	return x
}
func (x *ImageBlit) SetDstOffsets(y []Offset3D) {
	ptr := func(x *[]Offset3D) **C.struct_VkOffset3D { /* Array */
		if len(*x) > 0 {
			slc := (*C.struct_VkOffset3D)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkOffset3D)(unsafe.Pointer((&ptr)))
	}(&y)
	copy(x.dstOffsets[:], unsafe.Slice(*ptr, len(y)))
}

// QueueFamilyProperties provides a go interface for VkQueueFamilyProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFamilyProperties.html
type QueueFamilyProperties C.struct_VkQueueFamilyProperties

// SizeofQueueFamilyProperties is the memory size of a QueueFamilyProperties
var SizeofQueueFamilyProperties int = int(unsafe.Sizeof(QueueFamilyProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x QueueFamilyProperties) ArpPtr(arp *AutoReleasePool) *QueueFamilyProperties {
	ptr := newCBlock(cULong(SizeofQueueFamilyProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*QueueFamilyProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *QueueFamilyProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x QueueFamilyProperties) AsCPtr() *QueueFamilyProperties {
	clone := (*QueueFamilyProperties)(newCBlock(cULong(SizeofQueueFamilyProperties)))
	*clone = x
	return clone
}

// QueueFamilyPropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func QueueFamilyPropertiesCSlice(arp *AutoReleasePool, x ...QueueFamilyProperties) []QueueFamilyProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofQueueFamilyProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*QueueFamilyProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// QueueFamilyPropertiesFreeCSlice releases the memory allocated by QueueFamilyPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func QueueFamilyPropertiesFreeCSlice(x []QueueFamilyProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// QueueFamilyPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. QueueFamilyPropertiesFreeCSlice must be called on the returned slice.
func QueueFamilyPropertiesMakeCSlice(x ...QueueFamilyProperties) []QueueFamilyProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofQueueFamilyProperties * len(x)
	dst := unsafe.Slice((*QueueFamilyProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// QueueFlags returns the value of queueFlags from VkQueueFamilyProperties
func (x QueueFamilyProperties) QueueFlags() QueueFlags {
	ptr := /* typedef */ (*QueueFlags)(&x.queueFlags)
	return *ptr
}

// QueueCount returns the value of queueCount from VkQueueFamilyProperties
func (x QueueFamilyProperties) QueueCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.queueCount)
	return *ptr
}

// TimestampValidBits returns the value of timestampValidBits from VkQueueFamilyProperties
func (x QueueFamilyProperties) TimestampValidBits() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.timestampValidBits)
	return *ptr
}

// MinImageTransferGranularity returns the value of minImageTransferGranularity from VkQueueFamilyProperties
func (x QueueFamilyProperties) MinImageTransferGranularity() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.minImageTransferGranularity)
	return *ptr
}

// PhysicalDeviceSparseProperties provides a go interface for VkPhysicalDeviceSparseProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSparseProperties.html
type PhysicalDeviceSparseProperties C.struct_VkPhysicalDeviceSparseProperties

// SizeofPhysicalDeviceSparseProperties is the memory size of a PhysicalDeviceSparseProperties
var SizeofPhysicalDeviceSparseProperties int = int(unsafe.Sizeof(PhysicalDeviceSparseProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceSparseProperties) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceSparseProperties {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceSparseProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceSparseProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceSparseProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceSparseProperties) AsCPtr() *PhysicalDeviceSparseProperties {
	clone := (*PhysicalDeviceSparseProperties)(newCBlock(cULong(SizeofPhysicalDeviceSparseProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceSparsePropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceSparsePropertiesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceSparseProperties) []PhysicalDeviceSparseProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSparseProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceSparseProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceSparsePropertiesFreeCSlice releases the memory allocated by PhysicalDeviceSparsePropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceSparsePropertiesFreeCSlice(x []PhysicalDeviceSparseProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceSparsePropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceSparsePropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceSparsePropertiesMakeCSlice(x ...PhysicalDeviceSparseProperties) []PhysicalDeviceSparseProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSparseProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceSparseProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// ResidencyStandard2DBlockShape returns the value of residencyStandard2DBlockShape from VkPhysicalDeviceSparseProperties
func (x PhysicalDeviceSparseProperties) ResidencyStandard2DBlockShape() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.residencyStandard2DBlockShape)
	return *ptr
}

// ResidencyStandard2DMultisampleBlockShape returns the value of residencyStandard2DMultisampleBlockShape from VkPhysicalDeviceSparseProperties
func (x PhysicalDeviceSparseProperties) ResidencyStandard2DMultisampleBlockShape() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.residencyStandard2DMultisampleBlockShape)
	return *ptr
}

// ResidencyStandard3DBlockShape returns the value of residencyStandard3DBlockShape from VkPhysicalDeviceSparseProperties
func (x PhysicalDeviceSparseProperties) ResidencyStandard3DBlockShape() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.residencyStandard3DBlockShape)
	return *ptr
}

// ResidencyAlignedMipSize returns the value of residencyAlignedMipSize from VkPhysicalDeviceSparseProperties
func (x PhysicalDeviceSparseProperties) ResidencyAlignedMipSize() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.residencyAlignedMipSize)
	return *ptr
}

// ResidencyNonResidentStrict returns the value of residencyNonResidentStrict from VkPhysicalDeviceSparseProperties
func (x PhysicalDeviceSparseProperties) ResidencyNonResidentStrict() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.residencyNonResidentStrict)
	return *ptr
}

// ClearRect provides a go interface for VkClearRect.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearRect.html
type ClearRect C.struct_VkClearRect

// SizeofClearRect is the memory size of a ClearRect
var SizeofClearRect int = int(unsafe.Sizeof(ClearRect{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ClearRect) ArpPtr(arp *AutoReleasePool) *ClearRect {
	ptr := newCBlock(cULong(SizeofClearRect))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ClearRect)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ClearRect) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ClearRect) AsCPtr() *ClearRect {
	clone := (*ClearRect)(newCBlock(cULong(SizeofClearRect)))
	*clone = x
	return clone
}

// ClearRectCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ClearRectCSlice(arp *AutoReleasePool, x ...ClearRect) []ClearRect {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofClearRect * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ClearRect)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ClearRectFreeCSlice releases the memory allocated by ClearRectMakeCSlice.
// It does not free pointers stored inside the slice.
func ClearRectFreeCSlice(x []ClearRect) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ClearRectMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ClearRectFreeCSlice must be called on the returned slice.
func ClearRectMakeCSlice(x ...ClearRect) []ClearRect {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofClearRect * len(x)
	dst := unsafe.Slice((*ClearRect)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Rect returns the value of rect from VkClearRect
func (x ClearRect) Rect() Rect2D {
	ptr := /* typedef */ (*Rect2D)(&x.rect)
	return *ptr
}

// WithRect clones a new ClearRect with the value of
// Rect updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ClearRect) WithRect(y Rect2D) ClearRect {
	x.rect = *( /* typedef */ (*C.struct_VkRect2D)(&y))
	return x
}
func (x *ClearRect) SetRect(y Rect2D) {
	x.rect = *( /* typedef */ (*C.struct_VkRect2D)(&y))
}

// BaseArrayLayer returns the value of baseArrayLayer from VkClearRect
func (x ClearRect) BaseArrayLayer() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.baseArrayLayer)
	return *ptr
}

// WithBaseArrayLayer clones a new ClearRect with the value of
// BaseArrayLayer updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ClearRect) WithBaseArrayLayer(y uint32) ClearRect {
	x.baseArrayLayer = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *ClearRect) SetBaseArrayLayer(y uint32) {
	x.baseArrayLayer = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// LayerCount returns the value of layerCount from VkClearRect
func (x ClearRect) LayerCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.layerCount)
	return *ptr
}

// WithLayerCount clones a new ClearRect with the value of
// LayerCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ClearRect) WithLayerCount(y uint32) ClearRect {
	x.layerCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *ClearRect) SetLayerCount(y uint32) {
	x.layerCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// BufferCreateInfo provides a go interface for VkBufferCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCreateInfo.html
type BufferCreateInfo C.struct_VkBufferCreateInfo

// SizeofBufferCreateInfo is the memory size of a BufferCreateInfo
var SizeofBufferCreateInfo int = int(unsafe.Sizeof(BufferCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x BufferCreateInfo) ArpPtr(arp *AutoReleasePool) *BufferCreateInfo {
	ptr := newCBlock(cULong(SizeofBufferCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*BufferCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferCreateInfo) AsCPtr() *BufferCreateInfo {
	clone := (*BufferCreateInfo)(newCBlock(cULong(SizeofBufferCreateInfo)))
	*clone = x
	return clone
}

// BufferCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func BufferCreateInfoCSlice(arp *AutoReleasePool, x ...BufferCreateInfo) []BufferCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*BufferCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// BufferCreateInfoFreeCSlice releases the memory allocated by BufferCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BufferCreateInfoFreeCSlice(x []BufferCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferCreateInfoFreeCSlice must be called on the returned slice.
func BufferCreateInfoMakeCSlice(x ...BufferCreateInfo) []BufferCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferCreateInfo * len(x)
	dst := unsafe.Slice((*BufferCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBufferCreateInfo
func (x BufferCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new BufferCreateInfo with the value of
// SType to the value provided in the specification.
func (x BufferCreateInfo) WithDefaultSType() BufferCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *BufferCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO)
}

// WithSType clones a new BufferCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCreateInfo) WithSType(y StructureType) BufferCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *BufferCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkBufferCreateInfo
func (x BufferCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new BufferCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCreateInfo) WithPNext(y unsafe.Pointer) BufferCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *BufferCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkBufferCreateInfo
func (x BufferCreateInfo) Flags() BufferCreateFlags {
	ptr := /* typedef */ (*BufferCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new BufferCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCreateInfo) WithFlags(y BufferCreateFlags) BufferCreateInfo {
	x.flags = *( /* typedef */ (*C.VkBufferCreateFlags)(&y))
	return x
}
func (x *BufferCreateInfo) SetFlags(y BufferCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkBufferCreateFlags)(&y))
}

// Size returns the value of size from VkBufferCreateInfo
func (x BufferCreateInfo) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size)
	return *ptr
}

// WithSize clones a new BufferCreateInfo with the value of
// Size updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCreateInfo) WithSize(y DeviceSize) BufferCreateInfo {
	x.size = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *BufferCreateInfo) SetSize(y DeviceSize) {
	x.size = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// Usage returns the value of usage from VkBufferCreateInfo
func (x BufferCreateInfo) Usage() BufferUsageFlags {
	ptr := /* typedef */ (*BufferUsageFlags)(&x.usage)
	return *ptr
}

// WithUsage clones a new BufferCreateInfo with the value of
// Usage updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCreateInfo) WithUsage(y BufferUsageFlags) BufferCreateInfo {
	x.usage = *( /* typedef */ (*C.VkBufferUsageFlags)(&y))
	return x
}
func (x *BufferCreateInfo) SetUsage(y BufferUsageFlags) {
	x.usage = *( /* typedef */ (*C.VkBufferUsageFlags)(&y))
}

// SharingMode returns the value of sharingMode from VkBufferCreateInfo
func (x BufferCreateInfo) SharingMode() SharingMode {
	ptr := /* typedef */ (*SharingMode)(&x.sharingMode)
	return *ptr
}

// WithSharingMode clones a new BufferCreateInfo with the value of
// SharingMode updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCreateInfo) WithSharingMode(y SharingMode) BufferCreateInfo {
	x.sharingMode = *( /* typedef */ (*C.VkSharingMode)(&y))
	return x
}
func (x *BufferCreateInfo) SetSharingMode(y SharingMode) {
	x.sharingMode = *( /* typedef */ (*C.VkSharingMode)(&y))
}

// QueueFamilyIndexCount returns the value of queueFamilyIndexCount from VkBufferCreateInfo
func (x BufferCreateInfo) QueueFamilyIndexCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.queueFamilyIndexCount)
	return *ptr
}

// WithQueueFamilyIndexCount clones a new BufferCreateInfo with the value of
// QueueFamilyIndexCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCreateInfo) WithQueueFamilyIndexCount(y uint32) BufferCreateInfo {
	x.queueFamilyIndexCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *BufferCreateInfo) SetQueueFamilyIndexCount(y uint32) {
	x.queueFamilyIndexCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PQueueFamilyIndices returns the value of pQueueFamilyIndices from VkBufferCreateInfo
func (x BufferCreateInfo) PQueueFamilyIndices() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pQueueFamilyIndices)
	return *ptr
}

// WithPQueueFamilyIndices clones a new BufferCreateInfo with the value of
// PQueueFamilyIndices updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines QueueFamilyIndexCount as the length of this field.
// QueueFamilyIndexCount is updated with the length of the new value.
func (x BufferCreateInfo) WithPQueueFamilyIndices(y []uint32) BufferCreateInfo {
	x.pQueueFamilyIndices = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithQueueFamilyIndexCount(uint32(len(y)))
}
func (x *BufferCreateInfo) SetPQueueFamilyIndices(y []uint32) {
	x.pQueueFamilyIndices = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetQueueFamilyIndexCount(uint32(len(y)))
}

// PhysicalDeviceLimits provides a go interface for VkPhysicalDeviceLimits.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLimits.html
type PhysicalDeviceLimits C.struct_VkPhysicalDeviceLimits

// SizeofPhysicalDeviceLimits is the memory size of a PhysicalDeviceLimits
var SizeofPhysicalDeviceLimits int = int(unsafe.Sizeof(PhysicalDeviceLimits{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceLimits) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceLimits {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceLimits))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceLimits)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceLimits) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceLimits) AsCPtr() *PhysicalDeviceLimits {
	clone := (*PhysicalDeviceLimits)(newCBlock(cULong(SizeofPhysicalDeviceLimits)))
	*clone = x
	return clone
}

// PhysicalDeviceLimitsCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceLimitsCSlice(arp *AutoReleasePool, x ...PhysicalDeviceLimits) []PhysicalDeviceLimits {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceLimits * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceLimits)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceLimitsFreeCSlice releases the memory allocated by PhysicalDeviceLimitsMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceLimitsFreeCSlice(x []PhysicalDeviceLimits) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceLimitsMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceLimitsFreeCSlice must be called on the returned slice.
func PhysicalDeviceLimitsMakeCSlice(x ...PhysicalDeviceLimits) []PhysicalDeviceLimits {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceLimits * len(x)
	dst := unsafe.Slice((*PhysicalDeviceLimits)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// MaxImageDimension1D returns the value of maxImageDimension1D from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxImageDimension1D() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxImageDimension1D)
	return *ptr
}

// MaxImageDimension2D returns the value of maxImageDimension2D from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxImageDimension2D() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxImageDimension2D)
	return *ptr
}

// MaxImageDimension3D returns the value of maxImageDimension3D from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxImageDimension3D() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxImageDimension3D)
	return *ptr
}

// MaxImageDimensionCube returns the value of maxImageDimensionCube from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxImageDimensionCube() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxImageDimensionCube)
	return *ptr
}

// MaxImageArrayLayers returns the value of maxImageArrayLayers from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxImageArrayLayers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxImageArrayLayers)
	return *ptr
}

// MaxTexelBufferElements returns the value of maxTexelBufferElements from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTexelBufferElements() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxTexelBufferElements)
	return *ptr
}

// MaxUniformBufferRange returns the value of maxUniformBufferRange from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxUniformBufferRange() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxUniformBufferRange)
	return *ptr
}

// MaxStorageBufferRange returns the value of maxStorageBufferRange from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxStorageBufferRange() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxStorageBufferRange)
	return *ptr
}

// MaxPushConstantsSize returns the value of maxPushConstantsSize from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxPushConstantsSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPushConstantsSize)
	return *ptr
}

// MaxMemoryAllocationCount returns the value of maxMemoryAllocationCount from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxMemoryAllocationCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxMemoryAllocationCount)
	return *ptr
}

// MaxSamplerAllocationCount returns the value of maxSamplerAllocationCount from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxSamplerAllocationCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxSamplerAllocationCount)
	return *ptr
}

// BufferImageGranularity returns the value of bufferImageGranularity from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) BufferImageGranularity() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.bufferImageGranularity)
	return *ptr
}

// SparseAddressSpaceSize returns the value of sparseAddressSpaceSize from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) SparseAddressSpaceSize() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.sparseAddressSpaceSize)
	return *ptr
}

// MaxBoundDescriptorSets returns the value of maxBoundDescriptorSets from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxBoundDescriptorSets() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxBoundDescriptorSets)
	return *ptr
}

// MaxPerStageDescriptorSamplers returns the value of maxPerStageDescriptorSamplers from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxPerStageDescriptorSamplers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorSamplers)
	return *ptr
}

// MaxPerStageDescriptorUniformBuffers returns the value of maxPerStageDescriptorUniformBuffers from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxPerStageDescriptorUniformBuffers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUniformBuffers)
	return *ptr
}

// MaxPerStageDescriptorStorageBuffers returns the value of maxPerStageDescriptorStorageBuffers from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxPerStageDescriptorStorageBuffers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorStorageBuffers)
	return *ptr
}

// MaxPerStageDescriptorSampledImages returns the value of maxPerStageDescriptorSampledImages from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxPerStageDescriptorSampledImages() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorSampledImages)
	return *ptr
}

// MaxPerStageDescriptorStorageImages returns the value of maxPerStageDescriptorStorageImages from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxPerStageDescriptorStorageImages() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorStorageImages)
	return *ptr
}

// MaxPerStageDescriptorInputAttachments returns the value of maxPerStageDescriptorInputAttachments from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxPerStageDescriptorInputAttachments() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorInputAttachments)
	return *ptr
}

// MaxPerStageResources returns the value of maxPerStageResources from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxPerStageResources() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageResources)
	return *ptr
}

// MaxDescriptorSetSamplers returns the value of maxDescriptorSetSamplers from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDescriptorSetSamplers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetSamplers)
	return *ptr
}

// MaxDescriptorSetUniformBuffers returns the value of maxDescriptorSetUniformBuffers from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDescriptorSetUniformBuffers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUniformBuffers)
	return *ptr
}

// MaxDescriptorSetUniformBuffersDynamic returns the value of maxDescriptorSetUniformBuffersDynamic from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDescriptorSetUniformBuffersDynamic() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUniformBuffersDynamic)
	return *ptr
}

// MaxDescriptorSetStorageBuffers returns the value of maxDescriptorSetStorageBuffers from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDescriptorSetStorageBuffers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetStorageBuffers)
	return *ptr
}

// MaxDescriptorSetStorageBuffersDynamic returns the value of maxDescriptorSetStorageBuffersDynamic from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDescriptorSetStorageBuffersDynamic() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetStorageBuffersDynamic)
	return *ptr
}

// MaxDescriptorSetSampledImages returns the value of maxDescriptorSetSampledImages from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDescriptorSetSampledImages() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetSampledImages)
	return *ptr
}

// MaxDescriptorSetStorageImages returns the value of maxDescriptorSetStorageImages from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDescriptorSetStorageImages() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetStorageImages)
	return *ptr
}

// MaxDescriptorSetInputAttachments returns the value of maxDescriptorSetInputAttachments from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDescriptorSetInputAttachments() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetInputAttachments)
	return *ptr
}

// MaxVertexInputAttributes returns the value of maxVertexInputAttributes from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxVertexInputAttributes() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxVertexInputAttributes)
	return *ptr
}

// MaxVertexInputBindings returns the value of maxVertexInputBindings from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxVertexInputBindings() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxVertexInputBindings)
	return *ptr
}

// MaxVertexInputAttributeOffset returns the value of maxVertexInputAttributeOffset from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxVertexInputAttributeOffset() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxVertexInputAttributeOffset)
	return *ptr
}

// MaxVertexInputBindingStride returns the value of maxVertexInputBindingStride from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxVertexInputBindingStride() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxVertexInputBindingStride)
	return *ptr
}

// MaxVertexOutputComponents returns the value of maxVertexOutputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxVertexOutputComponents() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxVertexOutputComponents)
	return *ptr
}

// MaxTessellationGenerationLevel returns the value of maxTessellationGenerationLevel from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTessellationGenerationLevel() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxTessellationGenerationLevel)
	return *ptr
}

// MaxTessellationPatchSize returns the value of maxTessellationPatchSize from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTessellationPatchSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxTessellationPatchSize)
	return *ptr
}

// MaxTessellationControlPerVertexInputComponents returns the value of maxTessellationControlPerVertexInputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTessellationControlPerVertexInputComponents() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxTessellationControlPerVertexInputComponents)
	return *ptr
}

// MaxTessellationControlPerVertexOutputComponents returns the value of maxTessellationControlPerVertexOutputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTessellationControlPerVertexOutputComponents() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxTessellationControlPerVertexOutputComponents)
	return *ptr
}

// MaxTessellationControlPerPatchOutputComponents returns the value of maxTessellationControlPerPatchOutputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTessellationControlPerPatchOutputComponents() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxTessellationControlPerPatchOutputComponents)
	return *ptr
}

// MaxTessellationControlTotalOutputComponents returns the value of maxTessellationControlTotalOutputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTessellationControlTotalOutputComponents() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxTessellationControlTotalOutputComponents)
	return *ptr
}

// MaxTessellationEvaluationInputComponents returns the value of maxTessellationEvaluationInputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTessellationEvaluationInputComponents() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxTessellationEvaluationInputComponents)
	return *ptr
}

// MaxTessellationEvaluationOutputComponents returns the value of maxTessellationEvaluationOutputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTessellationEvaluationOutputComponents() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxTessellationEvaluationOutputComponents)
	return *ptr
}

// MaxGeometryShaderInvocations returns the value of maxGeometryShaderInvocations from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxGeometryShaderInvocations() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxGeometryShaderInvocations)
	return *ptr
}

// MaxGeometryInputComponents returns the value of maxGeometryInputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxGeometryInputComponents() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxGeometryInputComponents)
	return *ptr
}

// MaxGeometryOutputComponents returns the value of maxGeometryOutputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxGeometryOutputComponents() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxGeometryOutputComponents)
	return *ptr
}

// MaxGeometryOutputVertices returns the value of maxGeometryOutputVertices from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxGeometryOutputVertices() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxGeometryOutputVertices)
	return *ptr
}

// MaxGeometryTotalOutputComponents returns the value of maxGeometryTotalOutputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxGeometryTotalOutputComponents() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxGeometryTotalOutputComponents)
	return *ptr
}

// MaxFragmentInputComponents returns the value of maxFragmentInputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxFragmentInputComponents() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxFragmentInputComponents)
	return *ptr
}

// MaxFragmentOutputAttachments returns the value of maxFragmentOutputAttachments from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxFragmentOutputAttachments() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxFragmentOutputAttachments)
	return *ptr
}

// MaxFragmentDualSrcAttachments returns the value of maxFragmentDualSrcAttachments from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxFragmentDualSrcAttachments() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxFragmentDualSrcAttachments)
	return *ptr
}

// MaxFragmentCombinedOutputResources returns the value of maxFragmentCombinedOutputResources from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxFragmentCombinedOutputResources() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxFragmentCombinedOutputResources)
	return *ptr
}

// MaxComputeSharedMemorySize returns the value of maxComputeSharedMemorySize from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxComputeSharedMemorySize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxComputeSharedMemorySize)
	return *ptr
}

// MaxComputeWorkGroupCount returns the value of maxComputeWorkGroupCount from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxComputeWorkGroupCount() []uint32 {
	ptr := func(x *[3]C.uint32_t) *[]uint32 { /* Array */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), 3)
		return &slc
	}(&x.maxComputeWorkGroupCount)
	return *ptr
}

// MaxComputeWorkGroupInvocations returns the value of maxComputeWorkGroupInvocations from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxComputeWorkGroupInvocations() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxComputeWorkGroupInvocations)
	return *ptr
}

// MaxComputeWorkGroupSize returns the value of maxComputeWorkGroupSize from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxComputeWorkGroupSize() []uint32 {
	ptr := func(x *[3]C.uint32_t) *[]uint32 { /* Array */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), 3)
		return &slc
	}(&x.maxComputeWorkGroupSize)
	return *ptr
}

// SubPixelPrecisionBits returns the value of subPixelPrecisionBits from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) SubPixelPrecisionBits() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.subPixelPrecisionBits)
	return *ptr
}

// SubTexelPrecisionBits returns the value of subTexelPrecisionBits from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) SubTexelPrecisionBits() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.subTexelPrecisionBits)
	return *ptr
}

// MipmapPrecisionBits returns the value of mipmapPrecisionBits from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MipmapPrecisionBits() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.mipmapPrecisionBits)
	return *ptr
}

// MaxDrawIndexedIndexValue returns the value of maxDrawIndexedIndexValue from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDrawIndexedIndexValue() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDrawIndexedIndexValue)
	return *ptr
}

// MaxDrawIndirectCount returns the value of maxDrawIndirectCount from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDrawIndirectCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDrawIndirectCount)
	return *ptr
}

// MaxSamplerLodBias returns the value of maxSamplerLodBias from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxSamplerLodBias() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.maxSamplerLodBias)
	return *ptr
}

// MaxSamplerAnisotropy returns the value of maxSamplerAnisotropy from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxSamplerAnisotropy() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.maxSamplerAnisotropy)
	return *ptr
}

// MaxViewports returns the value of maxViewports from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxViewports() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxViewports)
	return *ptr
}

// MaxViewportDimensions returns the value of maxViewportDimensions from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxViewportDimensions() []uint32 {
	ptr := func(x *[2]C.uint32_t) *[]uint32 { /* Array */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), 2)
		return &slc
	}(&x.maxViewportDimensions)
	return *ptr
}

// ViewportBoundsRange returns the value of viewportBoundsRange from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) ViewportBoundsRange() []float32 {
	ptr := func(x *[2]C.float) *[]float32 { /* Array */
		slc := unsafe.Slice((*float32)(unsafe.Pointer(x)), 2)
		return &slc
	}(&x.viewportBoundsRange)
	return *ptr
}

// ViewportSubPixelBits returns the value of viewportSubPixelBits from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) ViewportSubPixelBits() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.viewportSubPixelBits)
	return *ptr
}

// MinMemoryMapAlignment returns the value of minMemoryMapAlignment from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MinMemoryMapAlignment() uint64 {
	ptr := func(x *C.size_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.minMemoryMapAlignment)
	return *ptr
}

// MinTexelBufferOffsetAlignment returns the value of minTexelBufferOffsetAlignment from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MinTexelBufferOffsetAlignment() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.minTexelBufferOffsetAlignment)
	return *ptr
}

// MinUniformBufferOffsetAlignment returns the value of minUniformBufferOffsetAlignment from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MinUniformBufferOffsetAlignment() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.minUniformBufferOffsetAlignment)
	return *ptr
}

// MinStorageBufferOffsetAlignment returns the value of minStorageBufferOffsetAlignment from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MinStorageBufferOffsetAlignment() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.minStorageBufferOffsetAlignment)
	return *ptr
}

// MinTexelOffset returns the value of minTexelOffset from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MinTexelOffset() int32 {
	ptr := func(x *C.int32_t) *int32 { /* Scalar */ c2g := int32(*x); return &c2g }(&x.minTexelOffset)
	return *ptr
}

// MaxTexelOffset returns the value of maxTexelOffset from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTexelOffset() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxTexelOffset)
	return *ptr
}

// MinTexelGatherOffset returns the value of minTexelGatherOffset from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MinTexelGatherOffset() int32 {
	ptr := func(x *C.int32_t) *int32 { /* Scalar */ c2g := int32(*x); return &c2g }(&x.minTexelGatherOffset)
	return *ptr
}

// MaxTexelGatherOffset returns the value of maxTexelGatherOffset from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTexelGatherOffset() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxTexelGatherOffset)
	return *ptr
}

// MinInterpolationOffset returns the value of minInterpolationOffset from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MinInterpolationOffset() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.minInterpolationOffset)
	return *ptr
}

// MaxInterpolationOffset returns the value of maxInterpolationOffset from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxInterpolationOffset() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.maxInterpolationOffset)
	return *ptr
}

// SubPixelInterpolationOffsetBits returns the value of subPixelInterpolationOffsetBits from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) SubPixelInterpolationOffsetBits() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.subPixelInterpolationOffsetBits)
	return *ptr
}

// MaxFramebufferWidth returns the value of maxFramebufferWidth from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxFramebufferWidth() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxFramebufferWidth)
	return *ptr
}

// MaxFramebufferHeight returns the value of maxFramebufferHeight from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxFramebufferHeight() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxFramebufferHeight)
	return *ptr
}

// MaxFramebufferLayers returns the value of maxFramebufferLayers from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxFramebufferLayers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxFramebufferLayers)
	return *ptr
}

// FramebufferColorSampleCounts returns the value of framebufferColorSampleCounts from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) FramebufferColorSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.framebufferColorSampleCounts)
	return *ptr
}

// FramebufferDepthSampleCounts returns the value of framebufferDepthSampleCounts from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) FramebufferDepthSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.framebufferDepthSampleCounts)
	return *ptr
}

// FramebufferStencilSampleCounts returns the value of framebufferStencilSampleCounts from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) FramebufferStencilSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.framebufferStencilSampleCounts)
	return *ptr
}

// FramebufferNoAttachmentsSampleCounts returns the value of framebufferNoAttachmentsSampleCounts from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) FramebufferNoAttachmentsSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.framebufferNoAttachmentsSampleCounts)
	return *ptr
}

// MaxColorAttachments returns the value of maxColorAttachments from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxColorAttachments() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxColorAttachments)
	return *ptr
}

// SampledImageColorSampleCounts returns the value of sampledImageColorSampleCounts from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) SampledImageColorSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.sampledImageColorSampleCounts)
	return *ptr
}

// SampledImageIntegerSampleCounts returns the value of sampledImageIntegerSampleCounts from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) SampledImageIntegerSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.sampledImageIntegerSampleCounts)
	return *ptr
}

// SampledImageDepthSampleCounts returns the value of sampledImageDepthSampleCounts from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) SampledImageDepthSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.sampledImageDepthSampleCounts)
	return *ptr
}

// SampledImageStencilSampleCounts returns the value of sampledImageStencilSampleCounts from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) SampledImageStencilSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.sampledImageStencilSampleCounts)
	return *ptr
}

// StorageImageSampleCounts returns the value of storageImageSampleCounts from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) StorageImageSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.storageImageSampleCounts)
	return *ptr
}

// MaxSampleMaskWords returns the value of maxSampleMaskWords from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxSampleMaskWords() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxSampleMaskWords)
	return *ptr
}

// TimestampComputeAndGraphics returns the value of timestampComputeAndGraphics from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) TimestampComputeAndGraphics() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.timestampComputeAndGraphics)
	return *ptr
}

// TimestampPeriod returns the value of timestampPeriod from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) TimestampPeriod() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.timestampPeriod)
	return *ptr
}

// MaxClipDistances returns the value of maxClipDistances from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxClipDistances() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxClipDistances)
	return *ptr
}

// MaxCullDistances returns the value of maxCullDistances from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxCullDistances() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxCullDistances)
	return *ptr
}

// MaxCombinedClipAndCullDistances returns the value of maxCombinedClipAndCullDistances from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxCombinedClipAndCullDistances() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxCombinedClipAndCullDistances)
	return *ptr
}

// DiscreteQueuePriorities returns the value of discreteQueuePriorities from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) DiscreteQueuePriorities() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.discreteQueuePriorities)
	return *ptr
}

// PointSizeRange returns the value of pointSizeRange from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) PointSizeRange() []float32 {
	ptr := func(x *[2]C.float) *[]float32 { /* Array */
		slc := unsafe.Slice((*float32)(unsafe.Pointer(x)), 2)
		return &slc
	}(&x.pointSizeRange)
	return *ptr
}

// LineWidthRange returns the value of lineWidthRange from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) LineWidthRange() []float32 {
	ptr := func(x *[2]C.float) *[]float32 { /* Array */
		slc := unsafe.Slice((*float32)(unsafe.Pointer(x)), 2)
		return &slc
	}(&x.lineWidthRange)
	return *ptr
}

// PointSizeGranularity returns the value of pointSizeGranularity from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) PointSizeGranularity() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.pointSizeGranularity)
	return *ptr
}

// LineWidthGranularity returns the value of lineWidthGranularity from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) LineWidthGranularity() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.lineWidthGranularity)
	return *ptr
}

// StrictLines returns the value of strictLines from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) StrictLines() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.strictLines)
	return *ptr
}

// StandardSampleLocations returns the value of standardSampleLocations from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) StandardSampleLocations() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.standardSampleLocations)
	return *ptr
}

// OptimalBufferCopyOffsetAlignment returns the value of optimalBufferCopyOffsetAlignment from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) OptimalBufferCopyOffsetAlignment() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.optimalBufferCopyOffsetAlignment)
	return *ptr
}

// OptimalBufferCopyRowPitchAlignment returns the value of optimalBufferCopyRowPitchAlignment from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) OptimalBufferCopyRowPitchAlignment() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.optimalBufferCopyRowPitchAlignment)
	return *ptr
}

// NonCoherentAtomSize returns the value of nonCoherentAtomSize from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) NonCoherentAtomSize() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.nonCoherentAtomSize)
	return *ptr
}

// PhysicalDeviceProperties provides a go interface for VkPhysicalDeviceProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProperties.html
type PhysicalDeviceProperties C.struct_VkPhysicalDeviceProperties

// SizeofPhysicalDeviceProperties is the memory size of a PhysicalDeviceProperties
var SizeofPhysicalDeviceProperties int = int(unsafe.Sizeof(PhysicalDeviceProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceProperties) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceProperties {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceProperties) AsCPtr() *PhysicalDeviceProperties {
	clone := (*PhysicalDeviceProperties)(newCBlock(cULong(SizeofPhysicalDeviceProperties)))
	*clone = x
	return clone
}

// PhysicalDevicePropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDevicePropertiesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceProperties) []PhysicalDeviceProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDevicePropertiesFreeCSlice releases the memory allocated by PhysicalDevicePropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDevicePropertiesFreeCSlice(x []PhysicalDeviceProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDevicePropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDevicePropertiesFreeCSlice must be called on the returned slice.
func PhysicalDevicePropertiesMakeCSlice(x ...PhysicalDeviceProperties) []PhysicalDeviceProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// ApiVersion returns the value of apiVersion from VkPhysicalDeviceProperties
func (x PhysicalDeviceProperties) ApiVersion() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.apiVersion)
	return *ptr
}

// DriverVersion returns the value of driverVersion from VkPhysicalDeviceProperties
func (x PhysicalDeviceProperties) DriverVersion() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.driverVersion)
	return *ptr
}

// VendorID returns the value of vendorID from VkPhysicalDeviceProperties
func (x PhysicalDeviceProperties) VendorID() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.vendorID)
	return *ptr
}

// DeviceID returns the value of deviceID from VkPhysicalDeviceProperties
func (x PhysicalDeviceProperties) DeviceID() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.deviceID)
	return *ptr
}

// DeviceType returns the value of deviceType from VkPhysicalDeviceProperties
func (x PhysicalDeviceProperties) DeviceType() PhysicalDeviceType {
	ptr := /* typedef */ (*PhysicalDeviceType)(&x.deviceType)
	return *ptr
}

// DeviceName returns the value of deviceName from VkPhysicalDeviceProperties
func (x PhysicalDeviceProperties) DeviceName() []byte {
	ptr := func(x *[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE]C.char) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_PHYSICAL_DEVICE_NAME_SIZE)
		return &slc
	}(&x.deviceName)
	return *ptr
}

// PipelineCacheUUID returns the value of pipelineCacheUUID from VkPhysicalDeviceProperties
func (x PhysicalDeviceProperties) PipelineCacheUUID() []byte {
	ptr := func(x *[VK_UUID_SIZE]C.uint8_t) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_UUID_SIZE)
		return &slc
	}(&x.pipelineCacheUUID)
	return *ptr
}

// Limits returns the value of limits from VkPhysicalDeviceProperties
func (x PhysicalDeviceProperties) Limits() PhysicalDeviceLimits {
	ptr := /* typedef */ (*PhysicalDeviceLimits)(&x.limits)
	return *ptr
}

// SparseProperties returns the value of sparseProperties from VkPhysicalDeviceProperties
func (x PhysicalDeviceProperties) SparseProperties() PhysicalDeviceSparseProperties {
	ptr := /* typedef */ (*PhysicalDeviceSparseProperties)(&x.sparseProperties)
	return *ptr
}

// MemoryHeap provides a go interface for VkMemoryHeap.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryHeap.html
type MemoryHeap C.struct_VkMemoryHeap

// SizeofMemoryHeap is the memory size of a MemoryHeap
var SizeofMemoryHeap int = int(unsafe.Sizeof(MemoryHeap{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x MemoryHeap) ArpPtr(arp *AutoReleasePool) *MemoryHeap {
	ptr := newCBlock(cULong(SizeofMemoryHeap))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*MemoryHeap)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryHeap) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryHeap) AsCPtr() *MemoryHeap {
	clone := (*MemoryHeap)(newCBlock(cULong(SizeofMemoryHeap)))
	*clone = x
	return clone
}

// MemoryHeapCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func MemoryHeapCSlice(arp *AutoReleasePool, x ...MemoryHeap) []MemoryHeap {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryHeap * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*MemoryHeap)(ptr), len(x))
	copy(dst, x)
	return dst
}

// MemoryHeapFreeCSlice releases the memory allocated by MemoryHeapMakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryHeapFreeCSlice(x []MemoryHeap) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryHeapMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryHeapFreeCSlice must be called on the returned slice.
func MemoryHeapMakeCSlice(x ...MemoryHeap) []MemoryHeap {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryHeap * len(x)
	dst := unsafe.Slice((*MemoryHeap)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Size returns the value of size from VkMemoryHeap
func (x MemoryHeap) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size)
	return *ptr
}

// Flags returns the value of flags from VkMemoryHeap
func (x MemoryHeap) Flags() MemoryHeapFlags {
	ptr := /* typedef */ (*MemoryHeapFlags)(&x.flags)
	return *ptr
}

// MemoryType provides a go interface for VkMemoryType.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryType.html
type MemoryType C.struct_VkMemoryType

// SizeofMemoryType is the memory size of a MemoryType
var SizeofMemoryType int = int(unsafe.Sizeof(MemoryType{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x MemoryType) ArpPtr(arp *AutoReleasePool) *MemoryType {
	ptr := newCBlock(cULong(SizeofMemoryType))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*MemoryType)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryType) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryType) AsCPtr() *MemoryType {
	clone := (*MemoryType)(newCBlock(cULong(SizeofMemoryType)))
	*clone = x
	return clone
}

// MemoryTypeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func MemoryTypeCSlice(arp *AutoReleasePool, x ...MemoryType) []MemoryType {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryType * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*MemoryType)(ptr), len(x))
	copy(dst, x)
	return dst
}

// MemoryTypeFreeCSlice releases the memory allocated by MemoryTypeMakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryTypeFreeCSlice(x []MemoryType) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryTypeMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryTypeFreeCSlice must be called on the returned slice.
func MemoryTypeMakeCSlice(x ...MemoryType) []MemoryType {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryType * len(x)
	dst := unsafe.Slice((*MemoryType)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// PropertyFlags returns the value of propertyFlags from VkMemoryType
func (x MemoryType) PropertyFlags() MemoryPropertyFlags {
	ptr := /* typedef */ (*MemoryPropertyFlags)(&x.propertyFlags)
	return *ptr
}

// HeapIndex returns the value of heapIndex from VkMemoryType
func (x MemoryType) HeapIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.heapIndex)
	return *ptr
}

// PhysicalDeviceMemoryProperties provides a go interface for VkPhysicalDeviceMemoryProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryProperties.html
type PhysicalDeviceMemoryProperties C.struct_VkPhysicalDeviceMemoryProperties

// SizeofPhysicalDeviceMemoryProperties is the memory size of a PhysicalDeviceMemoryProperties
var SizeofPhysicalDeviceMemoryProperties int = int(unsafe.Sizeof(PhysicalDeviceMemoryProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceMemoryProperties) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceMemoryProperties {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceMemoryProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceMemoryProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceMemoryProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceMemoryProperties) AsCPtr() *PhysicalDeviceMemoryProperties {
	clone := (*PhysicalDeviceMemoryProperties)(newCBlock(cULong(SizeofPhysicalDeviceMemoryProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceMemoryPropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceMemoryPropertiesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceMemoryProperties) []PhysicalDeviceMemoryProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceMemoryProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceMemoryProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceMemoryPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceMemoryPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceMemoryPropertiesFreeCSlice(x []PhysicalDeviceMemoryProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceMemoryPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceMemoryPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceMemoryPropertiesMakeCSlice(x ...PhysicalDeviceMemoryProperties) []PhysicalDeviceMemoryProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceMemoryProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceMemoryProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// MemoryTypeCount returns the value of memoryTypeCount from VkPhysicalDeviceMemoryProperties
func (x PhysicalDeviceMemoryProperties) MemoryTypeCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.memoryTypeCount)
	return *ptr
}

// MemoryTypes returns the value of memoryTypes from VkPhysicalDeviceMemoryProperties
func (x PhysicalDeviceMemoryProperties) MemoryTypes() []MemoryType {
	ptr := func(x *[VK_MAX_MEMORY_TYPES]C.struct_VkMemoryType) *[]MemoryType { /* Array */
		slc := unsafe.Slice((*MemoryType)(unsafe.Pointer(x)), VK_MAX_MEMORY_TYPES)
		return &slc
	}(&x.memoryTypes)
	return *ptr
}

// MemoryHeapCount returns the value of memoryHeapCount from VkPhysicalDeviceMemoryProperties
func (x PhysicalDeviceMemoryProperties) MemoryHeapCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.memoryHeapCount)
	return *ptr
}

// MemoryHeaps returns the value of memoryHeaps from VkPhysicalDeviceMemoryProperties
func (x PhysicalDeviceMemoryProperties) MemoryHeaps() []MemoryHeap {
	ptr := func(x *[VK_MAX_MEMORY_HEAPS]C.struct_VkMemoryHeap) *[]MemoryHeap { /* Array */
		slc := unsafe.Slice((*MemoryHeap)(unsafe.Pointer(x)), VK_MAX_MEMORY_HEAPS)
		return &slc
	}(&x.memoryHeaps)
	return *ptr
}

// ClearAttachment provides a go interface for VkClearAttachment.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearAttachment.html
type ClearAttachment C.struct_VkClearAttachment

// SizeofClearAttachment is the memory size of a ClearAttachment
var SizeofClearAttachment int = int(unsafe.Sizeof(ClearAttachment{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ClearAttachment) ArpPtr(arp *AutoReleasePool) *ClearAttachment {
	ptr := newCBlock(cULong(SizeofClearAttachment))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ClearAttachment)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ClearAttachment) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ClearAttachment) AsCPtr() *ClearAttachment {
	clone := (*ClearAttachment)(newCBlock(cULong(SizeofClearAttachment)))
	*clone = x
	return clone
}

// ClearAttachmentCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ClearAttachmentCSlice(arp *AutoReleasePool, x ...ClearAttachment) []ClearAttachment {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofClearAttachment * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ClearAttachment)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ClearAttachmentFreeCSlice releases the memory allocated by ClearAttachmentMakeCSlice.
// It does not free pointers stored inside the slice.
func ClearAttachmentFreeCSlice(x []ClearAttachment) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ClearAttachmentMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ClearAttachmentFreeCSlice must be called on the returned slice.
func ClearAttachmentMakeCSlice(x ...ClearAttachment) []ClearAttachment {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofClearAttachment * len(x)
	dst := unsafe.Slice((*ClearAttachment)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// AspectMask returns the value of aspectMask from VkClearAttachment
func (x ClearAttachment) AspectMask() ImageAspectFlags {
	ptr := /* typedef */ (*ImageAspectFlags)(&x.aspectMask)
	return *ptr
}

// WithAspectMask clones a new ClearAttachment with the value of
// AspectMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ClearAttachment) WithAspectMask(y ImageAspectFlags) ClearAttachment {
	x.aspectMask = *( /* typedef */ (*C.VkImageAspectFlags)(&y))
	return x
}
func (x *ClearAttachment) SetAspectMask(y ImageAspectFlags) {
	x.aspectMask = *( /* typedef */ (*C.VkImageAspectFlags)(&y))
}

// ColorAttachment returns the value of colorAttachment from VkClearAttachment
func (x ClearAttachment) ColorAttachment() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.colorAttachment)
	return *ptr
}

// WithColorAttachment clones a new ClearAttachment with the value of
// ColorAttachment updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ClearAttachment) WithColorAttachment(y uint32) ClearAttachment {
	x.colorAttachment = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *ClearAttachment) SetColorAttachment(y uint32) {
	x.colorAttachment = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// ClearValue returns the value of clearValue from VkClearAttachment
func (x ClearAttachment) ClearValue() ClearValue {
	ptr := /* typedef */ (*ClearValue)(&x.clearValue)
	return *ptr
}

// WithClearValue clones a new ClearAttachment with the value of
// ClearValue updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ClearAttachment) WithClearValue(y ClearValue) ClearAttachment {
	x.clearValue = *( /* typedef */ (*C.VkClearValue)(&y))
	return x
}
func (x *ClearAttachment) SetClearValue(y ClearValue) {
	x.clearValue = *( /* typedef */ (*C.VkClearValue)(&y))
}

// BufferImageCopy provides a go interface for VkBufferImageCopy.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferImageCopy.html
type BufferImageCopy C.struct_VkBufferImageCopy

// SizeofBufferImageCopy is the memory size of a BufferImageCopy
var SizeofBufferImageCopy int = int(unsafe.Sizeof(BufferImageCopy{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x BufferImageCopy) ArpPtr(arp *AutoReleasePool) *BufferImageCopy {
	ptr := newCBlock(cULong(SizeofBufferImageCopy))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*BufferImageCopy)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferImageCopy) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferImageCopy) AsCPtr() *BufferImageCopy {
	clone := (*BufferImageCopy)(newCBlock(cULong(SizeofBufferImageCopy)))
	*clone = x
	return clone
}

// BufferImageCopyCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func BufferImageCopyCSlice(arp *AutoReleasePool, x ...BufferImageCopy) []BufferImageCopy {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferImageCopy * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*BufferImageCopy)(ptr), len(x))
	copy(dst, x)
	return dst
}

// BufferImageCopyFreeCSlice releases the memory allocated by BufferImageCopyMakeCSlice.
// It does not free pointers stored inside the slice.
func BufferImageCopyFreeCSlice(x []BufferImageCopy) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferImageCopyMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferImageCopyFreeCSlice must be called on the returned slice.
func BufferImageCopyMakeCSlice(x ...BufferImageCopy) []BufferImageCopy {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferImageCopy * len(x)
	dst := unsafe.Slice((*BufferImageCopy)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// BufferOffset returns the value of bufferOffset from VkBufferImageCopy
func (x BufferImageCopy) BufferOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.bufferOffset)
	return *ptr
}

// WithBufferOffset clones a new BufferImageCopy with the value of
// BufferOffset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy) WithBufferOffset(y DeviceSize) BufferImageCopy {
	x.bufferOffset = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *BufferImageCopy) SetBufferOffset(y DeviceSize) {
	x.bufferOffset = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// BufferRowLength returns the value of bufferRowLength from VkBufferImageCopy
func (x BufferImageCopy) BufferRowLength() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.bufferRowLength)
	return *ptr
}

// WithBufferRowLength clones a new BufferImageCopy with the value of
// BufferRowLength updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy) WithBufferRowLength(y uint32) BufferImageCopy {
	x.bufferRowLength = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *BufferImageCopy) SetBufferRowLength(y uint32) {
	x.bufferRowLength = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// BufferImageHeight returns the value of bufferImageHeight from VkBufferImageCopy
func (x BufferImageCopy) BufferImageHeight() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.bufferImageHeight)
	return *ptr
}

// WithBufferImageHeight clones a new BufferImageCopy with the value of
// BufferImageHeight updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy) WithBufferImageHeight(y uint32) BufferImageCopy {
	x.bufferImageHeight = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *BufferImageCopy) SetBufferImageHeight(y uint32) {
	x.bufferImageHeight = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// ImageSubresource returns the value of imageSubresource from VkBufferImageCopy
func (x BufferImageCopy) ImageSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.imageSubresource)
	return *ptr
}

// WithImageSubresource clones a new BufferImageCopy with the value of
// ImageSubresource updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy) WithImageSubresource(y ImageSubresourceLayers) BufferImageCopy {
	x.imageSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}
func (x *BufferImageCopy) SetImageSubresource(y ImageSubresourceLayers) {
	x.imageSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
}

// ImageOffset returns the value of imageOffset from VkBufferImageCopy
func (x BufferImageCopy) ImageOffset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.imageOffset)
	return *ptr
}

// WithImageOffset clones a new BufferImageCopy with the value of
// ImageOffset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy) WithImageOffset(y Offset3D) BufferImageCopy {
	x.imageOffset = *( /* typedef */ (*C.struct_VkOffset3D)(&y))
	return x
}
func (x *BufferImageCopy) SetImageOffset(y Offset3D) {
	x.imageOffset = *( /* typedef */ (*C.struct_VkOffset3D)(&y))
}

// ImageExtent returns the value of imageExtent from VkBufferImageCopy
func (x BufferImageCopy) ImageExtent() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.imageExtent)
	return *ptr
}

// WithImageExtent clones a new BufferImageCopy with the value of
// ImageExtent updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy) WithImageExtent(y Extent3D) BufferImageCopy {
	x.imageExtent = *( /* typedef */ (*C.struct_VkExtent3D)(&y))
	return x
}
func (x *BufferImageCopy) SetImageExtent(y Extent3D) {
	x.imageExtent = *( /* typedef */ (*C.struct_VkExtent3D)(&y))
}

// BufferCopy provides a go interface for VkBufferCopy.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCopy.html
type BufferCopy C.struct_VkBufferCopy

// SizeofBufferCopy is the memory size of a BufferCopy
var SizeofBufferCopy int = int(unsafe.Sizeof(BufferCopy{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x BufferCopy) ArpPtr(arp *AutoReleasePool) *BufferCopy {
	ptr := newCBlock(cULong(SizeofBufferCopy))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*BufferCopy)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferCopy) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferCopy) AsCPtr() *BufferCopy {
	clone := (*BufferCopy)(newCBlock(cULong(SizeofBufferCopy)))
	*clone = x
	return clone
}

// BufferCopyCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func BufferCopyCSlice(arp *AutoReleasePool, x ...BufferCopy) []BufferCopy {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferCopy * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*BufferCopy)(ptr), len(x))
	copy(dst, x)
	return dst
}

// BufferCopyFreeCSlice releases the memory allocated by BufferCopyMakeCSlice.
// It does not free pointers stored inside the slice.
func BufferCopyFreeCSlice(x []BufferCopy) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferCopyMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferCopyFreeCSlice must be called on the returned slice.
func BufferCopyMakeCSlice(x ...BufferCopy) []BufferCopy {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferCopy * len(x)
	dst := unsafe.Slice((*BufferCopy)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SrcOffset returns the value of srcOffset from VkBufferCopy
func (x BufferCopy) SrcOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.srcOffset)
	return *ptr
}

// WithSrcOffset clones a new BufferCopy with the value of
// SrcOffset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCopy) WithSrcOffset(y DeviceSize) BufferCopy {
	x.srcOffset = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *BufferCopy) SetSrcOffset(y DeviceSize) {
	x.srcOffset = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// DstOffset returns the value of dstOffset from VkBufferCopy
func (x BufferCopy) DstOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.dstOffset)
	return *ptr
}

// WithDstOffset clones a new BufferCopy with the value of
// DstOffset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCopy) WithDstOffset(y DeviceSize) BufferCopy {
	x.dstOffset = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *BufferCopy) SetDstOffset(y DeviceSize) {
	x.dstOffset = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// Size returns the value of size from VkBufferCopy
func (x BufferCopy) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size)
	return *ptr
}

// WithSize clones a new BufferCopy with the value of
// Size updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCopy) WithSize(y DeviceSize) BufferCopy {
	x.size = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *BufferCopy) SetSize(y DeviceSize) {
	x.size = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// BufferViewCreateInfo provides a go interface for VkBufferViewCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferViewCreateInfo.html
type BufferViewCreateInfo C.struct_VkBufferViewCreateInfo

// SizeofBufferViewCreateInfo is the memory size of a BufferViewCreateInfo
var SizeofBufferViewCreateInfo int = int(unsafe.Sizeof(BufferViewCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x BufferViewCreateInfo) ArpPtr(arp *AutoReleasePool) *BufferViewCreateInfo {
	ptr := newCBlock(cULong(SizeofBufferViewCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*BufferViewCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferViewCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferViewCreateInfo) AsCPtr() *BufferViewCreateInfo {
	clone := (*BufferViewCreateInfo)(newCBlock(cULong(SizeofBufferViewCreateInfo)))
	*clone = x
	return clone
}

// BufferViewCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func BufferViewCreateInfoCSlice(arp *AutoReleasePool, x ...BufferViewCreateInfo) []BufferViewCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferViewCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*BufferViewCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// BufferViewCreateInfoFreeCSlice releases the memory allocated by BufferViewCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BufferViewCreateInfoFreeCSlice(x []BufferViewCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferViewCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferViewCreateInfoFreeCSlice must be called on the returned slice.
func BufferViewCreateInfoMakeCSlice(x ...BufferViewCreateInfo) []BufferViewCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferViewCreateInfo * len(x)
	dst := unsafe.Slice((*BufferViewCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBufferViewCreateInfo
func (x BufferViewCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new BufferViewCreateInfo with the value of
// SType to the value provided in the specification.
func (x BufferViewCreateInfo) WithDefaultSType() BufferViewCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *BufferViewCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO)
}

// WithSType clones a new BufferViewCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferViewCreateInfo) WithSType(y StructureType) BufferViewCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *BufferViewCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkBufferViewCreateInfo
func (x BufferViewCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new BufferViewCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferViewCreateInfo) WithPNext(y unsafe.Pointer) BufferViewCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *BufferViewCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkBufferViewCreateInfo
func (x BufferViewCreateInfo) Flags() BufferViewCreateFlags {
	ptr := /* typedef */ (*BufferViewCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new BufferViewCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferViewCreateInfo) WithFlags(y BufferViewCreateFlags) BufferViewCreateInfo {
	x.flags = *( /* typedef */ (*C.VkBufferViewCreateFlags)(&y))
	return x
}
func (x *BufferViewCreateInfo) SetFlags(y BufferViewCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkBufferViewCreateFlags)(&y))
}

// Buffer returns the value of buffer from VkBufferViewCreateInfo
func (x BufferViewCreateInfo) Buffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.buffer)
	return *ptr
}

// WithBuffer clones a new BufferViewCreateInfo with the value of
// Buffer updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferViewCreateInfo) WithBuffer(y Buffer) BufferViewCreateInfo {
	x.buffer = *( /* handle */ (*C.VkBuffer)(&y))
	return x
}
func (x *BufferViewCreateInfo) SetBuffer(y Buffer) {
	x.buffer = *( /* handle */ (*C.VkBuffer)(&y))
}

// Format returns the value of format from VkBufferViewCreateInfo
func (x BufferViewCreateInfo) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format)
	return *ptr
}

// WithFormat clones a new BufferViewCreateInfo with the value of
// Format updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferViewCreateInfo) WithFormat(y Format) BufferViewCreateInfo {
	x.format = *( /* typedef */ (*C.VkFormat)(&y))
	return x
}
func (x *BufferViewCreateInfo) SetFormat(y Format) {
	x.format = *( /* typedef */ (*C.VkFormat)(&y))
}

// Offset returns the value of offset from VkBufferViewCreateInfo
func (x BufferViewCreateInfo) Offset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.offset)
	return *ptr
}

// WithOffset clones a new BufferViewCreateInfo with the value of
// Offset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferViewCreateInfo) WithOffset(y DeviceSize) BufferViewCreateInfo {
	x.offset = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *BufferViewCreateInfo) SetOffset(y DeviceSize) {
	x.offset = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// Range_ returns the value of range from VkBufferViewCreateInfo
func (x BufferViewCreateInfo) Range_() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x._range)
	return *ptr
}

// WithRange_ clones a new BufferViewCreateInfo with the value of
// Range_ updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferViewCreateInfo) WithRange_(y DeviceSize) BufferViewCreateInfo {
	x._range = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *BufferViewCreateInfo) SetRange_(y DeviceSize) {
	x._range = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// SubmitInfo provides a go interface for VkSubmitInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubmitInfo.html
type SubmitInfo C.struct_VkSubmitInfo

// SizeofSubmitInfo is the memory size of a SubmitInfo
var SizeofSubmitInfo int = int(unsafe.Sizeof(SubmitInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SubmitInfo) ArpPtr(arp *AutoReleasePool) *SubmitInfo {
	ptr := newCBlock(cULong(SizeofSubmitInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SubmitInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubmitInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubmitInfo) AsCPtr() *SubmitInfo {
	clone := (*SubmitInfo)(newCBlock(cULong(SizeofSubmitInfo)))
	*clone = x
	return clone
}

// SubmitInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SubmitInfoCSlice(arp *AutoReleasePool, x ...SubmitInfo) []SubmitInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubmitInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SubmitInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SubmitInfoFreeCSlice releases the memory allocated by SubmitInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SubmitInfoFreeCSlice(x []SubmitInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubmitInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubmitInfoFreeCSlice must be called on the returned slice.
func SubmitInfoMakeCSlice(x ...SubmitInfo) []SubmitInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubmitInfo * len(x)
	dst := unsafe.Slice((*SubmitInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSubmitInfo
func (x SubmitInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new SubmitInfo with the value of
// SType to the value provided in the specification.
func (x SubmitInfo) WithDefaultSType() SubmitInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SUBMIT_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *SubmitInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_SUBMIT_INFO)
}

// WithSType clones a new SubmitInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubmitInfo) WithSType(y StructureType) SubmitInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *SubmitInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkSubmitInfo
func (x SubmitInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new SubmitInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubmitInfo) WithPNext(y unsafe.Pointer) SubmitInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *SubmitInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// WaitSemaphoreCount returns the value of waitSemaphoreCount from VkSubmitInfo
func (x SubmitInfo) WaitSemaphoreCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.waitSemaphoreCount)
	return *ptr
}

// WithWaitSemaphoreCount clones a new SubmitInfo with the value of
// WaitSemaphoreCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubmitInfo) WithWaitSemaphoreCount(y uint32) SubmitInfo {
	x.waitSemaphoreCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SubmitInfo) SetWaitSemaphoreCount(y uint32) {
	x.waitSemaphoreCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PWaitSemaphores returns the value of pWaitSemaphores from VkSubmitInfo
func (x SubmitInfo) PWaitSemaphores() []Semaphore {
	ptr := func(x **C.VkSemaphore) *[]Semaphore { /* Slice */
		slc := unsafe.Slice((*Semaphore)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pWaitSemaphores)
	return *ptr
}

// WithPWaitSemaphores clones a new SubmitInfo with the value of
// PWaitSemaphores updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines WaitSemaphoreCount as the length of this field.
// WaitSemaphoreCount is updated with the length of the new value.
func (x SubmitInfo) WithPWaitSemaphores(y []Semaphore) SubmitInfo {
	x.pWaitSemaphores = *(func(x *[]Semaphore) **C.VkSemaphore { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSemaphore)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSemaphore)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithWaitSemaphoreCount(uint32(len(y)))
}
func (x *SubmitInfo) SetPWaitSemaphores(y []Semaphore) {
	x.pWaitSemaphores = *(func(x *[]Semaphore) **C.VkSemaphore { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSemaphore)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSemaphore)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetWaitSemaphoreCount(uint32(len(y)))
}

// PWaitDstStageMask returns the value of pWaitDstStageMask from VkSubmitInfo
func (x SubmitInfo) PWaitDstStageMask() []PipelineStageFlags {
	ptr := func(x **C.VkPipelineStageFlags) *[]PipelineStageFlags { /* Slice */
		slc := unsafe.Slice((*PipelineStageFlags)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pWaitDstStageMask)
	return *ptr
}

// WithPWaitDstStageMask clones a new SubmitInfo with the value of
// PWaitDstStageMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines WaitSemaphoreCount as the length of this field.
// WaitSemaphoreCount is updated with the length of the new value.
func (x SubmitInfo) WithPWaitDstStageMask(y []PipelineStageFlags) SubmitInfo {
	x.pWaitDstStageMask = *(func(x *[]PipelineStageFlags) **C.VkPipelineStageFlags { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkPipelineStageFlags)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkPipelineStageFlags)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithWaitSemaphoreCount(uint32(len(y)))
}
func (x *SubmitInfo) SetPWaitDstStageMask(y []PipelineStageFlags) {
	x.pWaitDstStageMask = *(func(x *[]PipelineStageFlags) **C.VkPipelineStageFlags { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkPipelineStageFlags)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkPipelineStageFlags)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetWaitSemaphoreCount(uint32(len(y)))
}

// CommandBufferCount returns the value of commandBufferCount from VkSubmitInfo
func (x SubmitInfo) CommandBufferCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.commandBufferCount)
	return *ptr
}

// WithCommandBufferCount clones a new SubmitInfo with the value of
// CommandBufferCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubmitInfo) WithCommandBufferCount(y uint32) SubmitInfo {
	x.commandBufferCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SubmitInfo) SetCommandBufferCount(y uint32) {
	x.commandBufferCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PCommandBuffers returns the value of pCommandBuffers from VkSubmitInfo
func (x SubmitInfo) PCommandBuffers() []CommandBuffer {
	ptr := func(x **C.VkCommandBuffer) *[]CommandBuffer { /* Slice */
		slc := unsafe.Slice((*CommandBuffer)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pCommandBuffers)
	return *ptr
}

// WithPCommandBuffers clones a new SubmitInfo with the value of
// PCommandBuffers updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines CommandBufferCount as the length of this field.
// CommandBufferCount is updated with the length of the new value.
func (x SubmitInfo) WithPCommandBuffers(y []CommandBuffer) SubmitInfo {
	x.pCommandBuffers = *(func(x *[]CommandBuffer) **C.VkCommandBuffer { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkCommandBuffer)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkCommandBuffer)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithCommandBufferCount(uint32(len(y)))
}
func (x *SubmitInfo) SetPCommandBuffers(y []CommandBuffer) {
	x.pCommandBuffers = *(func(x *[]CommandBuffer) **C.VkCommandBuffer { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkCommandBuffer)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkCommandBuffer)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetCommandBufferCount(uint32(len(y)))
}

// SignalSemaphoreCount returns the value of signalSemaphoreCount from VkSubmitInfo
func (x SubmitInfo) SignalSemaphoreCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.signalSemaphoreCount)
	return *ptr
}

// WithSignalSemaphoreCount clones a new SubmitInfo with the value of
// SignalSemaphoreCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubmitInfo) WithSignalSemaphoreCount(y uint32) SubmitInfo {
	x.signalSemaphoreCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SubmitInfo) SetSignalSemaphoreCount(y uint32) {
	x.signalSemaphoreCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PSignalSemaphores returns the value of pSignalSemaphores from VkSubmitInfo
func (x SubmitInfo) PSignalSemaphores() []Semaphore {
	ptr := func(x **C.VkSemaphore) *[]Semaphore { /* Slice */
		slc := unsafe.Slice((*Semaphore)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pSignalSemaphores)
	return *ptr
}

// WithPSignalSemaphores clones a new SubmitInfo with the value of
// PSignalSemaphores updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SignalSemaphoreCount as the length of this field.
// SignalSemaphoreCount is updated with the length of the new value.
func (x SubmitInfo) WithPSignalSemaphores(y []Semaphore) SubmitInfo {
	x.pSignalSemaphores = *(func(x *[]Semaphore) **C.VkSemaphore { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSemaphore)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSemaphore)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithSignalSemaphoreCount(uint32(len(y)))
}
func (x *SubmitInfo) SetPSignalSemaphores(y []Semaphore) {
	x.pSignalSemaphores = *(func(x *[]Semaphore) **C.VkSemaphore { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSemaphore)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSemaphore)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetSignalSemaphoreCount(uint32(len(y)))
}

// ImageCreateInfo provides a go interface for VkImageCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCreateInfo.html
type ImageCreateInfo C.struct_VkImageCreateInfo

// SizeofImageCreateInfo is the memory size of a ImageCreateInfo
var SizeofImageCreateInfo int = int(unsafe.Sizeof(ImageCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ImageCreateInfo) ArpPtr(arp *AutoReleasePool) *ImageCreateInfo {
	ptr := newCBlock(cULong(SizeofImageCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ImageCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageCreateInfo) AsCPtr() *ImageCreateInfo {
	clone := (*ImageCreateInfo)(newCBlock(cULong(SizeofImageCreateInfo)))
	*clone = x
	return clone
}

// ImageCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ImageCreateInfoCSlice(arp *AutoReleasePool, x ...ImageCreateInfo) []ImageCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ImageCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ImageCreateInfoFreeCSlice releases the memory allocated by ImageCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageCreateInfoFreeCSlice(x []ImageCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageCreateInfoFreeCSlice must be called on the returned slice.
func ImageCreateInfoMakeCSlice(x ...ImageCreateInfo) []ImageCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageCreateInfo * len(x)
	dst := unsafe.Slice((*ImageCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageCreateInfo
func (x ImageCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ImageCreateInfo with the value of
// SType to the value provided in the specification.
func (x ImageCreateInfo) WithDefaultSType() ImageCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ImageCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO)
}

// WithSType clones a new ImageCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithSType(y StructureType) ImageCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ImageCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkImageCreateInfo
func (x ImageCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ImageCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithPNext(y unsafe.Pointer) ImageCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ImageCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkImageCreateInfo
func (x ImageCreateInfo) Flags() ImageCreateFlags {
	ptr := /* typedef */ (*ImageCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new ImageCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithFlags(y ImageCreateFlags) ImageCreateInfo {
	x.flags = *( /* typedef */ (*C.VkImageCreateFlags)(&y))
	return x
}
func (x *ImageCreateInfo) SetFlags(y ImageCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkImageCreateFlags)(&y))
}

// ImageType returns the value of imageType from VkImageCreateInfo
func (x ImageCreateInfo) ImageType() ImageType {
	ptr := /* typedef */ (*ImageType)(&x.imageType)
	return *ptr
}

// WithImageType clones a new ImageCreateInfo with the value of
// ImageType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithImageType(y ImageType) ImageCreateInfo {
	x.imageType = *( /* typedef */ (*C.VkImageType)(&y))
	return x
}
func (x *ImageCreateInfo) SetImageType(y ImageType) {
	x.imageType = *( /* typedef */ (*C.VkImageType)(&y))
}

// Format returns the value of format from VkImageCreateInfo
func (x ImageCreateInfo) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format)
	return *ptr
}

// WithFormat clones a new ImageCreateInfo with the value of
// Format updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithFormat(y Format) ImageCreateInfo {
	x.format = *( /* typedef */ (*C.VkFormat)(&y))
	return x
}
func (x *ImageCreateInfo) SetFormat(y Format) {
	x.format = *( /* typedef */ (*C.VkFormat)(&y))
}

// Extent returns the value of extent from VkImageCreateInfo
func (x ImageCreateInfo) Extent() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.extent)
	return *ptr
}

// WithExtent clones a new ImageCreateInfo with the value of
// Extent updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithExtent(y Extent3D) ImageCreateInfo {
	x.extent = *( /* typedef */ (*C.struct_VkExtent3D)(&y))
	return x
}
func (x *ImageCreateInfo) SetExtent(y Extent3D) {
	x.extent = *( /* typedef */ (*C.struct_VkExtent3D)(&y))
}

// MipLevels returns the value of mipLevels from VkImageCreateInfo
func (x ImageCreateInfo) MipLevels() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.mipLevels)
	return *ptr
}

// WithMipLevels clones a new ImageCreateInfo with the value of
// MipLevels updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithMipLevels(y uint32) ImageCreateInfo {
	x.mipLevels = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *ImageCreateInfo) SetMipLevels(y uint32) {
	x.mipLevels = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// ArrayLayers returns the value of arrayLayers from VkImageCreateInfo
func (x ImageCreateInfo) ArrayLayers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.arrayLayers)
	return *ptr
}

// WithArrayLayers clones a new ImageCreateInfo with the value of
// ArrayLayers updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithArrayLayers(y uint32) ImageCreateInfo {
	x.arrayLayers = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *ImageCreateInfo) SetArrayLayers(y uint32) {
	x.arrayLayers = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// Samples returns the value of samples from VkImageCreateInfo
func (x ImageCreateInfo) Samples() SampleCountFlagBits {
	ptr := /* typedef */ (*SampleCountFlagBits)(&x.samples)
	return *ptr
}

// WithSamples clones a new ImageCreateInfo with the value of
// Samples updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithSamples(y SampleCountFlagBits) ImageCreateInfo {
	x.samples = *( /* typedef */ (*C.VkSampleCountFlagBits)(&y))
	return x
}
func (x *ImageCreateInfo) SetSamples(y SampleCountFlagBits) {
	x.samples = *( /* typedef */ (*C.VkSampleCountFlagBits)(&y))
}

// Tiling returns the value of tiling from VkImageCreateInfo
func (x ImageCreateInfo) Tiling() ImageTiling {
	ptr := /* typedef */ (*ImageTiling)(&x.tiling)
	return *ptr
}

// WithTiling clones a new ImageCreateInfo with the value of
// Tiling updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithTiling(y ImageTiling) ImageCreateInfo {
	x.tiling = *( /* typedef */ (*C.VkImageTiling)(&y))
	return x
}
func (x *ImageCreateInfo) SetTiling(y ImageTiling) {
	x.tiling = *( /* typedef */ (*C.VkImageTiling)(&y))
}

// Usage returns the value of usage from VkImageCreateInfo
func (x ImageCreateInfo) Usage() ImageUsageFlags {
	ptr := /* typedef */ (*ImageUsageFlags)(&x.usage)
	return *ptr
}

// WithUsage clones a new ImageCreateInfo with the value of
// Usage updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithUsage(y ImageUsageFlags) ImageCreateInfo {
	x.usage = *( /* typedef */ (*C.VkImageUsageFlags)(&y))
	return x
}
func (x *ImageCreateInfo) SetUsage(y ImageUsageFlags) {
	x.usage = *( /* typedef */ (*C.VkImageUsageFlags)(&y))
}

// SharingMode returns the value of sharingMode from VkImageCreateInfo
func (x ImageCreateInfo) SharingMode() SharingMode {
	ptr := /* typedef */ (*SharingMode)(&x.sharingMode)
	return *ptr
}

// WithSharingMode clones a new ImageCreateInfo with the value of
// SharingMode updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithSharingMode(y SharingMode) ImageCreateInfo {
	x.sharingMode = *( /* typedef */ (*C.VkSharingMode)(&y))
	return x
}
func (x *ImageCreateInfo) SetSharingMode(y SharingMode) {
	x.sharingMode = *( /* typedef */ (*C.VkSharingMode)(&y))
}

// QueueFamilyIndexCount returns the value of queueFamilyIndexCount from VkImageCreateInfo
func (x ImageCreateInfo) QueueFamilyIndexCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.queueFamilyIndexCount)
	return *ptr
}

// WithQueueFamilyIndexCount clones a new ImageCreateInfo with the value of
// QueueFamilyIndexCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithQueueFamilyIndexCount(y uint32) ImageCreateInfo {
	x.queueFamilyIndexCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *ImageCreateInfo) SetQueueFamilyIndexCount(y uint32) {
	x.queueFamilyIndexCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PQueueFamilyIndices returns the value of pQueueFamilyIndices from VkImageCreateInfo
func (x ImageCreateInfo) PQueueFamilyIndices() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pQueueFamilyIndices)
	return *ptr
}

// WithPQueueFamilyIndices clones a new ImageCreateInfo with the value of
// PQueueFamilyIndices updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines QueueFamilyIndexCount as the length of this field.
// QueueFamilyIndexCount is updated with the length of the new value.
func (x ImageCreateInfo) WithPQueueFamilyIndices(y []uint32) ImageCreateInfo {
	x.pQueueFamilyIndices = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithQueueFamilyIndexCount(uint32(len(y)))
}
func (x *ImageCreateInfo) SetPQueueFamilyIndices(y []uint32) {
	x.pQueueFamilyIndices = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetQueueFamilyIndexCount(uint32(len(y)))
}

// InitialLayout returns the value of initialLayout from VkImageCreateInfo
func (x ImageCreateInfo) InitialLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.initialLayout)
	return *ptr
}

// WithInitialLayout clones a new ImageCreateInfo with the value of
// InitialLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithInitialLayout(y ImageLayout) ImageCreateInfo {
	x.initialLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
	return x
}
func (x *ImageCreateInfo) SetInitialLayout(y ImageLayout) {
	x.initialLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
}

// SubresourceLayout provides a go interface for VkSubresourceLayout.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubresourceLayout.html
type SubresourceLayout C.struct_VkSubresourceLayout

// SizeofSubresourceLayout is the memory size of a SubresourceLayout
var SizeofSubresourceLayout int = int(unsafe.Sizeof(SubresourceLayout{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SubresourceLayout) ArpPtr(arp *AutoReleasePool) *SubresourceLayout {
	ptr := newCBlock(cULong(SizeofSubresourceLayout))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SubresourceLayout)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubresourceLayout) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubresourceLayout) AsCPtr() *SubresourceLayout {
	clone := (*SubresourceLayout)(newCBlock(cULong(SizeofSubresourceLayout)))
	*clone = x
	return clone
}

// SubresourceLayoutCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SubresourceLayoutCSlice(arp *AutoReleasePool, x ...SubresourceLayout) []SubresourceLayout {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubresourceLayout * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SubresourceLayout)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SubresourceLayoutFreeCSlice releases the memory allocated by SubresourceLayoutMakeCSlice.
// It does not free pointers stored inside the slice.
func SubresourceLayoutFreeCSlice(x []SubresourceLayout) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubresourceLayoutMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubresourceLayoutFreeCSlice must be called on the returned slice.
func SubresourceLayoutMakeCSlice(x ...SubresourceLayout) []SubresourceLayout {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubresourceLayout * len(x)
	dst := unsafe.Slice((*SubresourceLayout)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Offset returns the value of offset from VkSubresourceLayout
func (x SubresourceLayout) Offset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.offset)
	return *ptr
}

// WithOffset clones a new SubresourceLayout with the value of
// Offset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubresourceLayout) WithOffset(y DeviceSize) SubresourceLayout {
	x.offset = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *SubresourceLayout) SetOffset(y DeviceSize) {
	x.offset = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// Size returns the value of size from VkSubresourceLayout
func (x SubresourceLayout) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size)
	return *ptr
}

// WithSize clones a new SubresourceLayout with the value of
// Size updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubresourceLayout) WithSize(y DeviceSize) SubresourceLayout {
	x.size = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *SubresourceLayout) SetSize(y DeviceSize) {
	x.size = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// RowPitch returns the value of rowPitch from VkSubresourceLayout
func (x SubresourceLayout) RowPitch() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.rowPitch)
	return *ptr
}

// WithRowPitch clones a new SubresourceLayout with the value of
// RowPitch updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubresourceLayout) WithRowPitch(y DeviceSize) SubresourceLayout {
	x.rowPitch = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *SubresourceLayout) SetRowPitch(y DeviceSize) {
	x.rowPitch = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// ArrayPitch returns the value of arrayPitch from VkSubresourceLayout
func (x SubresourceLayout) ArrayPitch() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.arrayPitch)
	return *ptr
}

// WithArrayPitch clones a new SubresourceLayout with the value of
// ArrayPitch updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubresourceLayout) WithArrayPitch(y DeviceSize) SubresourceLayout {
	x.arrayPitch = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *SubresourceLayout) SetArrayPitch(y DeviceSize) {
	x.arrayPitch = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// DepthPitch returns the value of depthPitch from VkSubresourceLayout
func (x SubresourceLayout) DepthPitch() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.depthPitch)
	return *ptr
}

// WithDepthPitch clones a new SubresourceLayout with the value of
// DepthPitch updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubresourceLayout) WithDepthPitch(y DeviceSize) SubresourceLayout {
	x.depthPitch = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *SubresourceLayout) SetDepthPitch(y DeviceSize) {
	x.depthPitch = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// CommandBufferInheritanceInfo provides a go interface for VkCommandBufferInheritanceInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferInheritanceInfo.html
type CommandBufferInheritanceInfo C.struct_VkCommandBufferInheritanceInfo

// SizeofCommandBufferInheritanceInfo is the memory size of a CommandBufferInheritanceInfo
var SizeofCommandBufferInheritanceInfo int = int(unsafe.Sizeof(CommandBufferInheritanceInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x CommandBufferInheritanceInfo) ArpPtr(arp *AutoReleasePool) *CommandBufferInheritanceInfo {
	ptr := newCBlock(cULong(SizeofCommandBufferInheritanceInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*CommandBufferInheritanceInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *CommandBufferInheritanceInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x CommandBufferInheritanceInfo) AsCPtr() *CommandBufferInheritanceInfo {
	clone := (*CommandBufferInheritanceInfo)(newCBlock(cULong(SizeofCommandBufferInheritanceInfo)))
	*clone = x
	return clone
}

// CommandBufferInheritanceInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func CommandBufferInheritanceInfoCSlice(arp *AutoReleasePool, x ...CommandBufferInheritanceInfo) []CommandBufferInheritanceInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCommandBufferInheritanceInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*CommandBufferInheritanceInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// CommandBufferInheritanceInfoFreeCSlice releases the memory allocated by CommandBufferInheritanceInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func CommandBufferInheritanceInfoFreeCSlice(x []CommandBufferInheritanceInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// CommandBufferInheritanceInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. CommandBufferInheritanceInfoFreeCSlice must be called on the returned slice.
func CommandBufferInheritanceInfoMakeCSlice(x ...CommandBufferInheritanceInfo) []CommandBufferInheritanceInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCommandBufferInheritanceInfo * len(x)
	dst := unsafe.Slice((*CommandBufferInheritanceInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkCommandBufferInheritanceInfo
func (x CommandBufferInheritanceInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new CommandBufferInheritanceInfo with the value of
// SType to the value provided in the specification.
func (x CommandBufferInheritanceInfo) WithDefaultSType() CommandBufferInheritanceInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *CommandBufferInheritanceInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO)
}

// WithSType clones a new CommandBufferInheritanceInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceInfo) WithSType(y StructureType) CommandBufferInheritanceInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *CommandBufferInheritanceInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkCommandBufferInheritanceInfo
func (x CommandBufferInheritanceInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new CommandBufferInheritanceInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceInfo) WithPNext(y unsafe.Pointer) CommandBufferInheritanceInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *CommandBufferInheritanceInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// RenderPass returns the value of renderPass from VkCommandBufferInheritanceInfo
func (x CommandBufferInheritanceInfo) RenderPass() RenderPass {
	ptr := /* handle */ (*RenderPass)(&x.renderPass)
	return *ptr
}

// WithRenderPass clones a new CommandBufferInheritanceInfo with the value of
// RenderPass updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceInfo) WithRenderPass(y RenderPass) CommandBufferInheritanceInfo {
	x.renderPass = *( /* handle */ (*C.VkRenderPass)(&y))
	return x
}
func (x *CommandBufferInheritanceInfo) SetRenderPass(y RenderPass) {
	x.renderPass = *( /* handle */ (*C.VkRenderPass)(&y))
}

// Subpass returns the value of subpass from VkCommandBufferInheritanceInfo
func (x CommandBufferInheritanceInfo) Subpass() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.subpass)
	return *ptr
}

// WithSubpass clones a new CommandBufferInheritanceInfo with the value of
// Subpass updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceInfo) WithSubpass(y uint32) CommandBufferInheritanceInfo {
	x.subpass = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *CommandBufferInheritanceInfo) SetSubpass(y uint32) {
	x.subpass = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// Framebuffer returns the value of framebuffer from VkCommandBufferInheritanceInfo
func (x CommandBufferInheritanceInfo) Framebuffer() Framebuffer {
	ptr := /* handle */ (*Framebuffer)(&x.framebuffer)
	return *ptr
}

// WithFramebuffer clones a new CommandBufferInheritanceInfo with the value of
// Framebuffer updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceInfo) WithFramebuffer(y Framebuffer) CommandBufferInheritanceInfo {
	x.framebuffer = *( /* handle */ (*C.VkFramebuffer)(&y))
	return x
}
func (x *CommandBufferInheritanceInfo) SetFramebuffer(y Framebuffer) {
	x.framebuffer = *( /* handle */ (*C.VkFramebuffer)(&y))
}

// OcclusionQueryEnable returns the value of occlusionQueryEnable from VkCommandBufferInheritanceInfo
func (x CommandBufferInheritanceInfo) OcclusionQueryEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.occlusionQueryEnable)
	return *ptr
}

// WithOcclusionQueryEnable clones a new CommandBufferInheritanceInfo with the value of
// OcclusionQueryEnable updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceInfo) WithOcclusionQueryEnable(y Bool32) CommandBufferInheritanceInfo {
	x.occlusionQueryEnable = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *CommandBufferInheritanceInfo) SetOcclusionQueryEnable(y Bool32) {
	x.occlusionQueryEnable = *( /* typedef */ (*C.VkBool32)(&y))
}

// QueryFlags returns the value of queryFlags from VkCommandBufferInheritanceInfo
func (x CommandBufferInheritanceInfo) QueryFlags() QueryControlFlags {
	ptr := /* typedef */ (*QueryControlFlags)(&x.queryFlags)
	return *ptr
}

// WithQueryFlags clones a new CommandBufferInheritanceInfo with the value of
// QueryFlags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceInfo) WithQueryFlags(y QueryControlFlags) CommandBufferInheritanceInfo {
	x.queryFlags = *( /* typedef */ (*C.VkQueryControlFlags)(&y))
	return x
}
func (x *CommandBufferInheritanceInfo) SetQueryFlags(y QueryControlFlags) {
	x.queryFlags = *( /* typedef */ (*C.VkQueryControlFlags)(&y))
}

// PipelineStatistics returns the value of pipelineStatistics from VkCommandBufferInheritanceInfo
func (x CommandBufferInheritanceInfo) PipelineStatistics() QueryPipelineStatisticFlags {
	ptr := /* typedef */ (*QueryPipelineStatisticFlags)(&x.pipelineStatistics)
	return *ptr
}

// WithPipelineStatistics clones a new CommandBufferInheritanceInfo with the value of
// PipelineStatistics updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceInfo) WithPipelineStatistics(y QueryPipelineStatisticFlags) CommandBufferInheritanceInfo {
	x.pipelineStatistics = *( /* typedef */ (*C.VkQueryPipelineStatisticFlags)(&y))
	return x
}
func (x *CommandBufferInheritanceInfo) SetPipelineStatistics(y QueryPipelineStatisticFlags) {
	x.pipelineStatistics = *( /* typedef */ (*C.VkQueryPipelineStatisticFlags)(&y))
}

// CommandBufferBeginInfo provides a go interface for VkCommandBufferBeginInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferBeginInfo.html
type CommandBufferBeginInfo C.struct_VkCommandBufferBeginInfo

// SizeofCommandBufferBeginInfo is the memory size of a CommandBufferBeginInfo
var SizeofCommandBufferBeginInfo int = int(unsafe.Sizeof(CommandBufferBeginInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x CommandBufferBeginInfo) ArpPtr(arp *AutoReleasePool) *CommandBufferBeginInfo {
	ptr := newCBlock(cULong(SizeofCommandBufferBeginInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*CommandBufferBeginInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *CommandBufferBeginInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x CommandBufferBeginInfo) AsCPtr() *CommandBufferBeginInfo {
	clone := (*CommandBufferBeginInfo)(newCBlock(cULong(SizeofCommandBufferBeginInfo)))
	*clone = x
	return clone
}

// CommandBufferBeginInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func CommandBufferBeginInfoCSlice(arp *AutoReleasePool, x ...CommandBufferBeginInfo) []CommandBufferBeginInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCommandBufferBeginInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*CommandBufferBeginInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// CommandBufferBeginInfoFreeCSlice releases the memory allocated by CommandBufferBeginInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func CommandBufferBeginInfoFreeCSlice(x []CommandBufferBeginInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// CommandBufferBeginInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. CommandBufferBeginInfoFreeCSlice must be called on the returned slice.
func CommandBufferBeginInfoMakeCSlice(x ...CommandBufferBeginInfo) []CommandBufferBeginInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCommandBufferBeginInfo * len(x)
	dst := unsafe.Slice((*CommandBufferBeginInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkCommandBufferBeginInfo
func (x CommandBufferBeginInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new CommandBufferBeginInfo with the value of
// SType to the value provided in the specification.
func (x CommandBufferBeginInfo) WithDefaultSType() CommandBufferBeginInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *CommandBufferBeginInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO)
}

// WithSType clones a new CommandBufferBeginInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferBeginInfo) WithSType(y StructureType) CommandBufferBeginInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *CommandBufferBeginInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkCommandBufferBeginInfo
func (x CommandBufferBeginInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new CommandBufferBeginInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferBeginInfo) WithPNext(y unsafe.Pointer) CommandBufferBeginInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *CommandBufferBeginInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkCommandBufferBeginInfo
func (x CommandBufferBeginInfo) Flags() CommandBufferUsageFlags {
	ptr := /* typedef */ (*CommandBufferUsageFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new CommandBufferBeginInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferBeginInfo) WithFlags(y CommandBufferUsageFlags) CommandBufferBeginInfo {
	x.flags = *( /* typedef */ (*C.VkCommandBufferUsageFlags)(&y))
	return x
}
func (x *CommandBufferBeginInfo) SetFlags(y CommandBufferUsageFlags) {
	x.flags = *( /* typedef */ (*C.VkCommandBufferUsageFlags)(&y))
}

// PInheritanceInfo returns the value of pInheritanceInfo from VkCommandBufferBeginInfo
func (x CommandBufferBeginInfo) PInheritanceInfo() *CommandBufferInheritanceInfo {
	ptr := func(x **C.struct_VkCommandBufferInheritanceInfo) **CommandBufferInheritanceInfo { /* Pointer */
		c2g := (*CommandBufferInheritanceInfo)(*x)
		return &c2g
	}(&x.pInheritanceInfo)
	return *ptr
}

// WithPInheritanceInfo clones a new CommandBufferBeginInfo with the value of
// PInheritanceInfo updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferBeginInfo) WithPInheritanceInfo(y *CommandBufferInheritanceInfo) CommandBufferBeginInfo {
	x.pInheritanceInfo = *(func(x **CommandBufferInheritanceInfo) **C.struct_VkCommandBufferInheritanceInfo { /* Pointer */
		g2c := (*C.struct_VkCommandBufferInheritanceInfo)(*x)
		return &g2c
	}(&y))
	return x
}
func (x *CommandBufferBeginInfo) SetPInheritanceInfo(y *CommandBufferInheritanceInfo) {
	x.pInheritanceInfo = *(func(x **CommandBufferInheritanceInfo) **C.struct_VkCommandBufferInheritanceInfo { /* Pointer */
		g2c := (*C.struct_VkCommandBufferInheritanceInfo)(*x)
		return &g2c
	}(&y))
}

// ComponentMapping provides a go interface for VkComponentMapping.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkComponentMapping.html
type ComponentMapping C.struct_VkComponentMapping

// SizeofComponentMapping is the memory size of a ComponentMapping
var SizeofComponentMapping int = int(unsafe.Sizeof(ComponentMapping{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ComponentMapping) ArpPtr(arp *AutoReleasePool) *ComponentMapping {
	ptr := newCBlock(cULong(SizeofComponentMapping))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ComponentMapping)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ComponentMapping) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ComponentMapping) AsCPtr() *ComponentMapping {
	clone := (*ComponentMapping)(newCBlock(cULong(SizeofComponentMapping)))
	*clone = x
	return clone
}

// ComponentMappingCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ComponentMappingCSlice(arp *AutoReleasePool, x ...ComponentMapping) []ComponentMapping {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofComponentMapping * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ComponentMapping)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ComponentMappingFreeCSlice releases the memory allocated by ComponentMappingMakeCSlice.
// It does not free pointers stored inside the slice.
func ComponentMappingFreeCSlice(x []ComponentMapping) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ComponentMappingMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ComponentMappingFreeCSlice must be called on the returned slice.
func ComponentMappingMakeCSlice(x ...ComponentMapping) []ComponentMapping {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofComponentMapping * len(x)
	dst := unsafe.Slice((*ComponentMapping)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// R returns the value of r from VkComponentMapping
func (x ComponentMapping) R() ComponentSwizzle {
	ptr := /* typedef */ (*ComponentSwizzle)(&x.r)
	return *ptr
}

// WithR clones a new ComponentMapping with the value of
// R updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComponentMapping) WithR(y ComponentSwizzle) ComponentMapping {
	x.r = *( /* typedef */ (*C.VkComponentSwizzle)(&y))
	return x
}
func (x *ComponentMapping) SetR(y ComponentSwizzle) {
	x.r = *( /* typedef */ (*C.VkComponentSwizzle)(&y))
}

// G returns the value of g from VkComponentMapping
func (x ComponentMapping) G() ComponentSwizzle {
	ptr := /* typedef */ (*ComponentSwizzle)(&x.g)
	return *ptr
}

// WithG clones a new ComponentMapping with the value of
// G updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComponentMapping) WithG(y ComponentSwizzle) ComponentMapping {
	x.g = *( /* typedef */ (*C.VkComponentSwizzle)(&y))
	return x
}
func (x *ComponentMapping) SetG(y ComponentSwizzle) {
	x.g = *( /* typedef */ (*C.VkComponentSwizzle)(&y))
}

// B returns the value of b from VkComponentMapping
func (x ComponentMapping) B() ComponentSwizzle {
	ptr := /* typedef */ (*ComponentSwizzle)(&x.b)
	return *ptr
}

// WithB clones a new ComponentMapping with the value of
// B updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComponentMapping) WithB(y ComponentSwizzle) ComponentMapping {
	x.b = *( /* typedef */ (*C.VkComponentSwizzle)(&y))
	return x
}
func (x *ComponentMapping) SetB(y ComponentSwizzle) {
	x.b = *( /* typedef */ (*C.VkComponentSwizzle)(&y))
}

// A returns the value of a from VkComponentMapping
func (x ComponentMapping) A() ComponentSwizzle {
	ptr := /* typedef */ (*ComponentSwizzle)(&x.a)
	return *ptr
}

// WithA clones a new ComponentMapping with the value of
// A updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComponentMapping) WithA(y ComponentSwizzle) ComponentMapping {
	x.a = *( /* typedef */ (*C.VkComponentSwizzle)(&y))
	return x
}
func (x *ComponentMapping) SetA(y ComponentSwizzle) {
	x.a = *( /* typedef */ (*C.VkComponentSwizzle)(&y))
}

// SemaphoreCreateInfo provides a go interface for VkSemaphoreCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreCreateInfo.html
type SemaphoreCreateInfo C.struct_VkSemaphoreCreateInfo

// SizeofSemaphoreCreateInfo is the memory size of a SemaphoreCreateInfo
var SizeofSemaphoreCreateInfo int = int(unsafe.Sizeof(SemaphoreCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SemaphoreCreateInfo) ArpPtr(arp *AutoReleasePool) *SemaphoreCreateInfo {
	ptr := newCBlock(cULong(SizeofSemaphoreCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SemaphoreCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SemaphoreCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SemaphoreCreateInfo) AsCPtr() *SemaphoreCreateInfo {
	clone := (*SemaphoreCreateInfo)(newCBlock(cULong(SizeofSemaphoreCreateInfo)))
	*clone = x
	return clone
}

// SemaphoreCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SemaphoreCreateInfoCSlice(arp *AutoReleasePool, x ...SemaphoreCreateInfo) []SemaphoreCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSemaphoreCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SemaphoreCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SemaphoreCreateInfoFreeCSlice releases the memory allocated by SemaphoreCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SemaphoreCreateInfoFreeCSlice(x []SemaphoreCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SemaphoreCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SemaphoreCreateInfoFreeCSlice must be called on the returned slice.
func SemaphoreCreateInfoMakeCSlice(x ...SemaphoreCreateInfo) []SemaphoreCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSemaphoreCreateInfo * len(x)
	dst := unsafe.Slice((*SemaphoreCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSemaphoreCreateInfo
func (x SemaphoreCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new SemaphoreCreateInfo with the value of
// SType to the value provided in the specification.
func (x SemaphoreCreateInfo) WithDefaultSType() SemaphoreCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *SemaphoreCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO)
}

// WithSType clones a new SemaphoreCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreCreateInfo) WithSType(y StructureType) SemaphoreCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *SemaphoreCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkSemaphoreCreateInfo
func (x SemaphoreCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new SemaphoreCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreCreateInfo) WithPNext(y unsafe.Pointer) SemaphoreCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *SemaphoreCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkSemaphoreCreateInfo
func (x SemaphoreCreateInfo) Flags() SemaphoreCreateFlags {
	ptr := /* typedef */ (*SemaphoreCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new SemaphoreCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreCreateInfo) WithFlags(y SemaphoreCreateFlags) SemaphoreCreateInfo {
	x.flags = *( /* typedef */ (*C.VkSemaphoreCreateFlags)(&y))
	return x
}
func (x *SemaphoreCreateInfo) SetFlags(y SemaphoreCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkSemaphoreCreateFlags)(&y))
}

// ImageSubresourceRange provides a go interface for VkImageSubresourceRange.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSubresourceRange.html
type ImageSubresourceRange C.struct_VkImageSubresourceRange

// SizeofImageSubresourceRange is the memory size of a ImageSubresourceRange
var SizeofImageSubresourceRange int = int(unsafe.Sizeof(ImageSubresourceRange{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ImageSubresourceRange) ArpPtr(arp *AutoReleasePool) *ImageSubresourceRange {
	ptr := newCBlock(cULong(SizeofImageSubresourceRange))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ImageSubresourceRange)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageSubresourceRange) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageSubresourceRange) AsCPtr() *ImageSubresourceRange {
	clone := (*ImageSubresourceRange)(newCBlock(cULong(SizeofImageSubresourceRange)))
	*clone = x
	return clone
}

// ImageSubresourceRangeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ImageSubresourceRangeCSlice(arp *AutoReleasePool, x ...ImageSubresourceRange) []ImageSubresourceRange {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageSubresourceRange * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ImageSubresourceRange)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ImageSubresourceRangeFreeCSlice releases the memory allocated by ImageSubresourceRangeMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageSubresourceRangeFreeCSlice(x []ImageSubresourceRange) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageSubresourceRangeMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageSubresourceRangeFreeCSlice must be called on the returned slice.
func ImageSubresourceRangeMakeCSlice(x ...ImageSubresourceRange) []ImageSubresourceRange {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageSubresourceRange * len(x)
	dst := unsafe.Slice((*ImageSubresourceRange)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// AspectMask returns the value of aspectMask from VkImageSubresourceRange
func (x ImageSubresourceRange) AspectMask() ImageAspectFlags {
	ptr := /* typedef */ (*ImageAspectFlags)(&x.aspectMask)
	return *ptr
}

// WithAspectMask clones a new ImageSubresourceRange with the value of
// AspectMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresourceRange) WithAspectMask(y ImageAspectFlags) ImageSubresourceRange {
	x.aspectMask = *( /* typedef */ (*C.VkImageAspectFlags)(&y))
	return x
}
func (x *ImageSubresourceRange) SetAspectMask(y ImageAspectFlags) {
	x.aspectMask = *( /* typedef */ (*C.VkImageAspectFlags)(&y))
}

// BaseMipLevel returns the value of baseMipLevel from VkImageSubresourceRange
func (x ImageSubresourceRange) BaseMipLevel() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.baseMipLevel)
	return *ptr
}

// WithBaseMipLevel clones a new ImageSubresourceRange with the value of
// BaseMipLevel updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresourceRange) WithBaseMipLevel(y uint32) ImageSubresourceRange {
	x.baseMipLevel = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *ImageSubresourceRange) SetBaseMipLevel(y uint32) {
	x.baseMipLevel = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// LevelCount returns the value of levelCount from VkImageSubresourceRange
func (x ImageSubresourceRange) LevelCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.levelCount)
	return *ptr
}

// WithLevelCount clones a new ImageSubresourceRange with the value of
// LevelCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresourceRange) WithLevelCount(y uint32) ImageSubresourceRange {
	x.levelCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *ImageSubresourceRange) SetLevelCount(y uint32) {
	x.levelCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// BaseArrayLayer returns the value of baseArrayLayer from VkImageSubresourceRange
func (x ImageSubresourceRange) BaseArrayLayer() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.baseArrayLayer)
	return *ptr
}

// WithBaseArrayLayer clones a new ImageSubresourceRange with the value of
// BaseArrayLayer updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresourceRange) WithBaseArrayLayer(y uint32) ImageSubresourceRange {
	x.baseArrayLayer = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *ImageSubresourceRange) SetBaseArrayLayer(y uint32) {
	x.baseArrayLayer = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// LayerCount returns the value of layerCount from VkImageSubresourceRange
func (x ImageSubresourceRange) LayerCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.layerCount)
	return *ptr
}

// WithLayerCount clones a new ImageSubresourceRange with the value of
// LayerCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresourceRange) WithLayerCount(y uint32) ImageSubresourceRange {
	x.layerCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *ImageSubresourceRange) SetLayerCount(y uint32) {
	x.layerCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// CommandBufferAllocateInfo provides a go interface for VkCommandBufferAllocateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferAllocateInfo.html
type CommandBufferAllocateInfo C.struct_VkCommandBufferAllocateInfo

// SizeofCommandBufferAllocateInfo is the memory size of a CommandBufferAllocateInfo
var SizeofCommandBufferAllocateInfo int = int(unsafe.Sizeof(CommandBufferAllocateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x CommandBufferAllocateInfo) ArpPtr(arp *AutoReleasePool) *CommandBufferAllocateInfo {
	ptr := newCBlock(cULong(SizeofCommandBufferAllocateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*CommandBufferAllocateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *CommandBufferAllocateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x CommandBufferAllocateInfo) AsCPtr() *CommandBufferAllocateInfo {
	clone := (*CommandBufferAllocateInfo)(newCBlock(cULong(SizeofCommandBufferAllocateInfo)))
	*clone = x
	return clone
}

// CommandBufferAllocateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func CommandBufferAllocateInfoCSlice(arp *AutoReleasePool, x ...CommandBufferAllocateInfo) []CommandBufferAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCommandBufferAllocateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*CommandBufferAllocateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// CommandBufferAllocateInfoFreeCSlice releases the memory allocated by CommandBufferAllocateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func CommandBufferAllocateInfoFreeCSlice(x []CommandBufferAllocateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// CommandBufferAllocateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. CommandBufferAllocateInfoFreeCSlice must be called on the returned slice.
func CommandBufferAllocateInfoMakeCSlice(x ...CommandBufferAllocateInfo) []CommandBufferAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCommandBufferAllocateInfo * len(x)
	dst := unsafe.Slice((*CommandBufferAllocateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkCommandBufferAllocateInfo
func (x CommandBufferAllocateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new CommandBufferAllocateInfo with the value of
// SType to the value provided in the specification.
func (x CommandBufferAllocateInfo) WithDefaultSType() CommandBufferAllocateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *CommandBufferAllocateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO)
}

// WithSType clones a new CommandBufferAllocateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferAllocateInfo) WithSType(y StructureType) CommandBufferAllocateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *CommandBufferAllocateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkCommandBufferAllocateInfo
func (x CommandBufferAllocateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new CommandBufferAllocateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferAllocateInfo) WithPNext(y unsafe.Pointer) CommandBufferAllocateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *CommandBufferAllocateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// CommandPool returns the value of commandPool from VkCommandBufferAllocateInfo
func (x CommandBufferAllocateInfo) CommandPool() CommandPool {
	ptr := /* handle */ (*CommandPool)(&x.commandPool)
	return *ptr
}

// WithCommandPool clones a new CommandBufferAllocateInfo with the value of
// CommandPool updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferAllocateInfo) WithCommandPool(y CommandPool) CommandBufferAllocateInfo {
	x.commandPool = *( /* handle */ (*C.VkCommandPool)(&y))
	return x
}
func (x *CommandBufferAllocateInfo) SetCommandPool(y CommandPool) {
	x.commandPool = *( /* handle */ (*C.VkCommandPool)(&y))
}

// Level returns the value of level from VkCommandBufferAllocateInfo
func (x CommandBufferAllocateInfo) Level() CommandBufferLevel {
	ptr := /* typedef */ (*CommandBufferLevel)(&x.level)
	return *ptr
}

// WithLevel clones a new CommandBufferAllocateInfo with the value of
// Level updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferAllocateInfo) WithLevel(y CommandBufferLevel) CommandBufferAllocateInfo {
	x.level = *( /* typedef */ (*C.VkCommandBufferLevel)(&y))
	return x
}
func (x *CommandBufferAllocateInfo) SetLevel(y CommandBufferLevel) {
	x.level = *( /* typedef */ (*C.VkCommandBufferLevel)(&y))
}

// CommandBufferCount returns the value of commandBufferCount from VkCommandBufferAllocateInfo
func (x CommandBufferAllocateInfo) CommandBufferCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.commandBufferCount)
	return *ptr
}

// WithCommandBufferCount clones a new CommandBufferAllocateInfo with the value of
// CommandBufferCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferAllocateInfo) WithCommandBufferCount(y uint32) CommandBufferAllocateInfo {
	x.commandBufferCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *CommandBufferAllocateInfo) SetCommandBufferCount(y uint32) {
	x.commandBufferCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// ImageViewCreateInfo provides a go interface for VkImageViewCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateInfo.html
type ImageViewCreateInfo C.struct_VkImageViewCreateInfo

// SizeofImageViewCreateInfo is the memory size of a ImageViewCreateInfo
var SizeofImageViewCreateInfo int = int(unsafe.Sizeof(ImageViewCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ImageViewCreateInfo) ArpPtr(arp *AutoReleasePool) *ImageViewCreateInfo {
	ptr := newCBlock(cULong(SizeofImageViewCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ImageViewCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageViewCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageViewCreateInfo) AsCPtr() *ImageViewCreateInfo {
	clone := (*ImageViewCreateInfo)(newCBlock(cULong(SizeofImageViewCreateInfo)))
	*clone = x
	return clone
}

// ImageViewCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ImageViewCreateInfoCSlice(arp *AutoReleasePool, x ...ImageViewCreateInfo) []ImageViewCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageViewCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ImageViewCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ImageViewCreateInfoFreeCSlice releases the memory allocated by ImageViewCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageViewCreateInfoFreeCSlice(x []ImageViewCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageViewCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageViewCreateInfoFreeCSlice must be called on the returned slice.
func ImageViewCreateInfoMakeCSlice(x ...ImageViewCreateInfo) []ImageViewCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageViewCreateInfo * len(x)
	dst := unsafe.Slice((*ImageViewCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageViewCreateInfo
func (x ImageViewCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ImageViewCreateInfo with the value of
// SType to the value provided in the specification.
func (x ImageViewCreateInfo) WithDefaultSType() ImageViewCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ImageViewCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO)
}

// WithSType clones a new ImageViewCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewCreateInfo) WithSType(y StructureType) ImageViewCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ImageViewCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkImageViewCreateInfo
func (x ImageViewCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ImageViewCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewCreateInfo) WithPNext(y unsafe.Pointer) ImageViewCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ImageViewCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkImageViewCreateInfo
func (x ImageViewCreateInfo) Flags() ImageViewCreateFlags {
	ptr := /* typedef */ (*ImageViewCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new ImageViewCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewCreateInfo) WithFlags(y ImageViewCreateFlags) ImageViewCreateInfo {
	x.flags = *( /* typedef */ (*C.VkImageViewCreateFlags)(&y))
	return x
}
func (x *ImageViewCreateInfo) SetFlags(y ImageViewCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkImageViewCreateFlags)(&y))
}

// Image returns the value of image from VkImageViewCreateInfo
func (x ImageViewCreateInfo) Image() Image {
	ptr := /* handle */ (*Image)(&x.image)
	return *ptr
}

// WithImage clones a new ImageViewCreateInfo with the value of
// Image updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewCreateInfo) WithImage(y Image) ImageViewCreateInfo {
	x.image = *( /* handle */ (*C.VkImage)(&y))
	return x
}
func (x *ImageViewCreateInfo) SetImage(y Image) {
	x.image = *( /* handle */ (*C.VkImage)(&y))
}

// ViewType returns the value of viewType from VkImageViewCreateInfo
func (x ImageViewCreateInfo) ViewType() ImageViewType {
	ptr := /* typedef */ (*ImageViewType)(&x.viewType)
	return *ptr
}

// WithViewType clones a new ImageViewCreateInfo with the value of
// ViewType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewCreateInfo) WithViewType(y ImageViewType) ImageViewCreateInfo {
	x.viewType = *( /* typedef */ (*C.VkImageViewType)(&y))
	return x
}
func (x *ImageViewCreateInfo) SetViewType(y ImageViewType) {
	x.viewType = *( /* typedef */ (*C.VkImageViewType)(&y))
}

// Format returns the value of format from VkImageViewCreateInfo
func (x ImageViewCreateInfo) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format)
	return *ptr
}

// WithFormat clones a new ImageViewCreateInfo with the value of
// Format updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewCreateInfo) WithFormat(y Format) ImageViewCreateInfo {
	x.format = *( /* typedef */ (*C.VkFormat)(&y))
	return x
}
func (x *ImageViewCreateInfo) SetFormat(y Format) {
	x.format = *( /* typedef */ (*C.VkFormat)(&y))
}

// Components returns the value of components from VkImageViewCreateInfo
func (x ImageViewCreateInfo) Components() ComponentMapping {
	ptr := /* typedef */ (*ComponentMapping)(&x.components)
	return *ptr
}

// WithComponents clones a new ImageViewCreateInfo with the value of
// Components updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewCreateInfo) WithComponents(y ComponentMapping) ImageViewCreateInfo {
	x.components = *( /* typedef */ (*C.struct_VkComponentMapping)(&y))
	return x
}
func (x *ImageViewCreateInfo) SetComponents(y ComponentMapping) {
	x.components = *( /* typedef */ (*C.struct_VkComponentMapping)(&y))
}

// SubresourceRange returns the value of subresourceRange from VkImageViewCreateInfo
func (x ImageViewCreateInfo) SubresourceRange() ImageSubresourceRange {
	ptr := /* typedef */ (*ImageSubresourceRange)(&x.subresourceRange)
	return *ptr
}

// WithSubresourceRange clones a new ImageViewCreateInfo with the value of
// SubresourceRange updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewCreateInfo) WithSubresourceRange(y ImageSubresourceRange) ImageViewCreateInfo {
	x.subresourceRange = *( /* typedef */ (*C.struct_VkImageSubresourceRange)(&y))
	return x
}
func (x *ImageViewCreateInfo) SetSubresourceRange(y ImageSubresourceRange) {
	x.subresourceRange = *( /* typedef */ (*C.struct_VkImageSubresourceRange)(&y))
}

// ApplicationInfo provides a go interface for VkApplicationInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkApplicationInfo.html
type ApplicationInfo C.struct_VkApplicationInfo

// SizeofApplicationInfo is the memory size of a ApplicationInfo
var SizeofApplicationInfo int = int(unsafe.Sizeof(ApplicationInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ApplicationInfo) ArpPtr(arp *AutoReleasePool) *ApplicationInfo {
	ptr := newCBlock(cULong(SizeofApplicationInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ApplicationInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ApplicationInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ApplicationInfo) AsCPtr() *ApplicationInfo {
	clone := (*ApplicationInfo)(newCBlock(cULong(SizeofApplicationInfo)))
	*clone = x
	return clone
}

// ApplicationInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ApplicationInfoCSlice(arp *AutoReleasePool, x ...ApplicationInfo) []ApplicationInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofApplicationInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ApplicationInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ApplicationInfoFreeCSlice releases the memory allocated by ApplicationInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ApplicationInfoFreeCSlice(x []ApplicationInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ApplicationInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ApplicationInfoFreeCSlice must be called on the returned slice.
func ApplicationInfoMakeCSlice(x ...ApplicationInfo) []ApplicationInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofApplicationInfo * len(x)
	dst := unsafe.Slice((*ApplicationInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkApplicationInfo
func (x ApplicationInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ApplicationInfo with the value of
// SType to the value provided in the specification.
func (x ApplicationInfo) WithDefaultSType() ApplicationInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_APPLICATION_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ApplicationInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_APPLICATION_INFO)
}

// WithSType clones a new ApplicationInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ApplicationInfo) WithSType(y StructureType) ApplicationInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ApplicationInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkApplicationInfo
func (x ApplicationInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ApplicationInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ApplicationInfo) WithPNext(y unsafe.Pointer) ApplicationInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ApplicationInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// PApplicationName returns the value of pApplicationName from VkApplicationInfo
func (x ApplicationInfo) PApplicationName() *byte {
	ptr := func(x **C.char) **byte { /* Pointer */ return (**byte)(unsafe.Pointer(x)) }(&x.pApplicationName)
	return *ptr
}

// WithPApplicationName clones a new ApplicationInfo with the value of
// PApplicationName updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ApplicationInfo) WithPApplicationName(y *byte) ApplicationInfo {
	x.pApplicationName = *(func(x **byte) **C.char { /* Pointer */ return (**C.char)(unsafe.Pointer(x)) }(&y))
	return x
}
func (x *ApplicationInfo) SetPApplicationName(y *byte) {
	x.pApplicationName = *(func(x **byte) **C.char { /* Pointer */ return (**C.char)(unsafe.Pointer(x)) }(&y))
}

// ApplicationVersion returns the value of applicationVersion from VkApplicationInfo
func (x ApplicationInfo) ApplicationVersion() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.applicationVersion)
	return *ptr
}

// WithApplicationVersion clones a new ApplicationInfo with the value of
// ApplicationVersion updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ApplicationInfo) WithApplicationVersion(y uint32) ApplicationInfo {
	x.applicationVersion = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *ApplicationInfo) SetApplicationVersion(y uint32) {
	x.applicationVersion = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PEngineName returns the value of pEngineName from VkApplicationInfo
func (x ApplicationInfo) PEngineName() *byte {
	ptr := func(x **C.char) **byte { /* Pointer */ return (**byte)(unsafe.Pointer(x)) }(&x.pEngineName)
	return *ptr
}

// WithPEngineName clones a new ApplicationInfo with the value of
// PEngineName updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ApplicationInfo) WithPEngineName(y *byte) ApplicationInfo {
	x.pEngineName = *(func(x **byte) **C.char { /* Pointer */ return (**C.char)(unsafe.Pointer(x)) }(&y))
	return x
}
func (x *ApplicationInfo) SetPEngineName(y *byte) {
	x.pEngineName = *(func(x **byte) **C.char { /* Pointer */ return (**C.char)(unsafe.Pointer(x)) }(&y))
}

// EngineVersion returns the value of engineVersion from VkApplicationInfo
func (x ApplicationInfo) EngineVersion() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.engineVersion)
	return *ptr
}

// WithEngineVersion clones a new ApplicationInfo with the value of
// EngineVersion updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ApplicationInfo) WithEngineVersion(y uint32) ApplicationInfo {
	x.engineVersion = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *ApplicationInfo) SetEngineVersion(y uint32) {
	x.engineVersion = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// ApiVersion returns the value of apiVersion from VkApplicationInfo
func (x ApplicationInfo) ApiVersion() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.apiVersion)
	return *ptr
}

// WithApiVersion clones a new ApplicationInfo with the value of
// ApiVersion updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ApplicationInfo) WithApiVersion(y uint32) ApplicationInfo {
	x.apiVersion = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *ApplicationInfo) SetApiVersion(y uint32) {
	x.apiVersion = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// InstanceCreateInfo provides a go interface for VkInstanceCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateInfo.html
type InstanceCreateInfo C.struct_VkInstanceCreateInfo

// SizeofInstanceCreateInfo is the memory size of a InstanceCreateInfo
var SizeofInstanceCreateInfo int = int(unsafe.Sizeof(InstanceCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x InstanceCreateInfo) ArpPtr(arp *AutoReleasePool) *InstanceCreateInfo {
	ptr := newCBlock(cULong(SizeofInstanceCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*InstanceCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *InstanceCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x InstanceCreateInfo) AsCPtr() *InstanceCreateInfo {
	clone := (*InstanceCreateInfo)(newCBlock(cULong(SizeofInstanceCreateInfo)))
	*clone = x
	return clone
}

// InstanceCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func InstanceCreateInfoCSlice(arp *AutoReleasePool, x ...InstanceCreateInfo) []InstanceCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofInstanceCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*InstanceCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// InstanceCreateInfoFreeCSlice releases the memory allocated by InstanceCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func InstanceCreateInfoFreeCSlice(x []InstanceCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// InstanceCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. InstanceCreateInfoFreeCSlice must be called on the returned slice.
func InstanceCreateInfoMakeCSlice(x ...InstanceCreateInfo) []InstanceCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofInstanceCreateInfo * len(x)
	dst := unsafe.Slice((*InstanceCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkInstanceCreateInfo
func (x InstanceCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new InstanceCreateInfo with the value of
// SType to the value provided in the specification.
func (x InstanceCreateInfo) WithDefaultSType() InstanceCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *InstanceCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO)
}

// WithSType clones a new InstanceCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InstanceCreateInfo) WithSType(y StructureType) InstanceCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *InstanceCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkInstanceCreateInfo
func (x InstanceCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new InstanceCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InstanceCreateInfo) WithPNext(y unsafe.Pointer) InstanceCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *InstanceCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkInstanceCreateInfo
func (x InstanceCreateInfo) Flags() InstanceCreateFlags {
	ptr := /* typedef */ (*InstanceCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new InstanceCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InstanceCreateInfo) WithFlags(y InstanceCreateFlags) InstanceCreateInfo {
	x.flags = *( /* typedef */ (*C.VkInstanceCreateFlags)(&y))
	return x
}
func (x *InstanceCreateInfo) SetFlags(y InstanceCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkInstanceCreateFlags)(&y))
}

// PApplicationInfo returns the value of pApplicationInfo from VkInstanceCreateInfo
func (x InstanceCreateInfo) PApplicationInfo() *ApplicationInfo {
	ptr := func(x **C.struct_VkApplicationInfo) **ApplicationInfo { /* Pointer */
		c2g := (*ApplicationInfo)(*x)
		return &c2g
	}(&x.pApplicationInfo)
	return *ptr
}

// WithPApplicationInfo clones a new InstanceCreateInfo with the value of
// PApplicationInfo updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InstanceCreateInfo) WithPApplicationInfo(y *ApplicationInfo) InstanceCreateInfo {
	x.pApplicationInfo = *(func(x **ApplicationInfo) **C.struct_VkApplicationInfo { /* Pointer */
		g2c := (*C.struct_VkApplicationInfo)(*x)
		return &g2c
	}(&y))
	return x
}
func (x *InstanceCreateInfo) SetPApplicationInfo(y *ApplicationInfo) {
	x.pApplicationInfo = *(func(x **ApplicationInfo) **C.struct_VkApplicationInfo { /* Pointer */
		g2c := (*C.struct_VkApplicationInfo)(*x)
		return &g2c
	}(&y))
}

// EnabledLayerCount returns the value of enabledLayerCount from VkInstanceCreateInfo
func (x InstanceCreateInfo) EnabledLayerCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.enabledLayerCount)
	return *ptr
}

// WithEnabledLayerCount clones a new InstanceCreateInfo with the value of
// EnabledLayerCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InstanceCreateInfo) WithEnabledLayerCount(y uint32) InstanceCreateInfo {
	x.enabledLayerCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *InstanceCreateInfo) SetEnabledLayerCount(y uint32) {
	x.enabledLayerCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PpEnabledLayerNames returns the value of ppEnabledLayerNames from VkInstanceCreateInfo
func (x InstanceCreateInfo) PpEnabledLayerNames() []*byte {
	ptr := func(x ***C.char) *[]*byte { /* Slice */
		slc := unsafe.Slice((**byte)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.ppEnabledLayerNames)
	return *ptr
}

// WithPpEnabledLayerNames clones a new InstanceCreateInfo with the value of
// PpEnabledLayerNames updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InstanceCreateInfo) WithPpEnabledLayerNames(y []*byte) InstanceCreateInfo {
	x.ppEnabledLayerNames = *(func(x *[]*byte) ***C.char { /* Slice */
		if len(*x) > 0 {
			slc := (**C.char)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (***C.char)(unsafe.Pointer((&ptr)))
	}(&y))
	return x
}
func (x *InstanceCreateInfo) SetPpEnabledLayerNames(y []*byte) {
	x.ppEnabledLayerNames = *(func(x *[]*byte) ***C.char { /* Slice */
		if len(*x) > 0 {
			slc := (**C.char)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (***C.char)(unsafe.Pointer((&ptr)))
	}(&y))
}

// EnabledExtensionCount returns the value of enabledExtensionCount from VkInstanceCreateInfo
func (x InstanceCreateInfo) EnabledExtensionCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.enabledExtensionCount)
	return *ptr
}

// WithEnabledExtensionCount clones a new InstanceCreateInfo with the value of
// EnabledExtensionCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InstanceCreateInfo) WithEnabledExtensionCount(y uint32) InstanceCreateInfo {
	x.enabledExtensionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *InstanceCreateInfo) SetEnabledExtensionCount(y uint32) {
	x.enabledExtensionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PpEnabledExtensionNames returns the value of ppEnabledExtensionNames from VkInstanceCreateInfo
func (x InstanceCreateInfo) PpEnabledExtensionNames() []*byte {
	ptr := func(x ***C.char) *[]*byte { /* Slice */
		slc := unsafe.Slice((**byte)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.ppEnabledExtensionNames)
	return *ptr
}

// WithPpEnabledExtensionNames clones a new InstanceCreateInfo with the value of
// PpEnabledExtensionNames updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InstanceCreateInfo) WithPpEnabledExtensionNames(y []*byte) InstanceCreateInfo {
	x.ppEnabledExtensionNames = *(func(x *[]*byte) ***C.char { /* Slice */
		if len(*x) > 0 {
			slc := (**C.char)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (***C.char)(unsafe.Pointer((&ptr)))
	}(&y))
	return x
}
func (x *InstanceCreateInfo) SetPpEnabledExtensionNames(y []*byte) {
	x.ppEnabledExtensionNames = *(func(x *[]*byte) ***C.char { /* Slice */
		if len(*x) > 0 {
			slc := (**C.char)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (***C.char)(unsafe.Pointer((&ptr)))
	}(&y))
}

// CommandPoolCreateInfo provides a go interface for VkCommandPoolCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolCreateInfo.html
type CommandPoolCreateInfo C.struct_VkCommandPoolCreateInfo

// SizeofCommandPoolCreateInfo is the memory size of a CommandPoolCreateInfo
var SizeofCommandPoolCreateInfo int = int(unsafe.Sizeof(CommandPoolCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x CommandPoolCreateInfo) ArpPtr(arp *AutoReleasePool) *CommandPoolCreateInfo {
	ptr := newCBlock(cULong(SizeofCommandPoolCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*CommandPoolCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *CommandPoolCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x CommandPoolCreateInfo) AsCPtr() *CommandPoolCreateInfo {
	clone := (*CommandPoolCreateInfo)(newCBlock(cULong(SizeofCommandPoolCreateInfo)))
	*clone = x
	return clone
}

// CommandPoolCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func CommandPoolCreateInfoCSlice(arp *AutoReleasePool, x ...CommandPoolCreateInfo) []CommandPoolCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCommandPoolCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*CommandPoolCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// CommandPoolCreateInfoFreeCSlice releases the memory allocated by CommandPoolCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func CommandPoolCreateInfoFreeCSlice(x []CommandPoolCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// CommandPoolCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. CommandPoolCreateInfoFreeCSlice must be called on the returned slice.
func CommandPoolCreateInfoMakeCSlice(x ...CommandPoolCreateInfo) []CommandPoolCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCommandPoolCreateInfo * len(x)
	dst := unsafe.Slice((*CommandPoolCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkCommandPoolCreateInfo
func (x CommandPoolCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new CommandPoolCreateInfo with the value of
// SType to the value provided in the specification.
func (x CommandPoolCreateInfo) WithDefaultSType() CommandPoolCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *CommandPoolCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO)
}

// WithSType clones a new CommandPoolCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandPoolCreateInfo) WithSType(y StructureType) CommandPoolCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *CommandPoolCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkCommandPoolCreateInfo
func (x CommandPoolCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new CommandPoolCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandPoolCreateInfo) WithPNext(y unsafe.Pointer) CommandPoolCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *CommandPoolCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkCommandPoolCreateInfo
func (x CommandPoolCreateInfo) Flags() CommandPoolCreateFlags {
	ptr := /* typedef */ (*CommandPoolCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new CommandPoolCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandPoolCreateInfo) WithFlags(y CommandPoolCreateFlags) CommandPoolCreateInfo {
	x.flags = *( /* typedef */ (*C.VkCommandPoolCreateFlags)(&y))
	return x
}
func (x *CommandPoolCreateInfo) SetFlags(y CommandPoolCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkCommandPoolCreateFlags)(&y))
}

// QueueFamilyIndex returns the value of queueFamilyIndex from VkCommandPoolCreateInfo
func (x CommandPoolCreateInfo) QueueFamilyIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.queueFamilyIndex)
	return *ptr
}

// WithQueueFamilyIndex clones a new CommandPoolCreateInfo with the value of
// QueueFamilyIndex updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandPoolCreateInfo) WithQueueFamilyIndex(y uint32) CommandPoolCreateInfo {
	x.queueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *CommandPoolCreateInfo) SetQueueFamilyIndex(y uint32) {
	x.queueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// AttachmentReference provides a go interface for VkAttachmentReference.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentReference.html
type AttachmentReference C.struct_VkAttachmentReference

// SizeofAttachmentReference is the memory size of a AttachmentReference
var SizeofAttachmentReference int = int(unsafe.Sizeof(AttachmentReference{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x AttachmentReference) ArpPtr(arp *AutoReleasePool) *AttachmentReference {
	ptr := newCBlock(cULong(SizeofAttachmentReference))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*AttachmentReference)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *AttachmentReference) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x AttachmentReference) AsCPtr() *AttachmentReference {
	clone := (*AttachmentReference)(newCBlock(cULong(SizeofAttachmentReference)))
	*clone = x
	return clone
}

// AttachmentReferenceCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func AttachmentReferenceCSlice(arp *AutoReleasePool, x ...AttachmentReference) []AttachmentReference {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAttachmentReference * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*AttachmentReference)(ptr), len(x))
	copy(dst, x)
	return dst
}

// AttachmentReferenceFreeCSlice releases the memory allocated by AttachmentReferenceMakeCSlice.
// It does not free pointers stored inside the slice.
func AttachmentReferenceFreeCSlice(x []AttachmentReference) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// AttachmentReferenceMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. AttachmentReferenceFreeCSlice must be called on the returned slice.
func AttachmentReferenceMakeCSlice(x ...AttachmentReference) []AttachmentReference {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAttachmentReference * len(x)
	dst := unsafe.Slice((*AttachmentReference)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Attachment returns the value of attachment from VkAttachmentReference
func (x AttachmentReference) Attachment() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.attachment)
	return *ptr
}

// WithAttachment clones a new AttachmentReference with the value of
// Attachment updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReference) WithAttachment(y uint32) AttachmentReference {
	x.attachment = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *AttachmentReference) SetAttachment(y uint32) {
	x.attachment = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// Layout returns the value of layout from VkAttachmentReference
func (x AttachmentReference) Layout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.layout)
	return *ptr
}

// WithLayout clones a new AttachmentReference with the value of
// Layout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReference) WithLayout(y ImageLayout) AttachmentReference {
	x.layout = *( /* typedef */ (*C.VkImageLayout)(&y))
	return x
}
func (x *AttachmentReference) SetLayout(y ImageLayout) {
	x.layout = *( /* typedef */ (*C.VkImageLayout)(&y))
}

// SubpassDescription provides a go interface for VkSubpassDescription.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDescription.html
type SubpassDescription C.struct_VkSubpassDescription

// SizeofSubpassDescription is the memory size of a SubpassDescription
var SizeofSubpassDescription int = int(unsafe.Sizeof(SubpassDescription{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SubpassDescription) ArpPtr(arp *AutoReleasePool) *SubpassDescription {
	ptr := newCBlock(cULong(SizeofSubpassDescription))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SubpassDescription)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubpassDescription) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubpassDescription) AsCPtr() *SubpassDescription {
	clone := (*SubpassDescription)(newCBlock(cULong(SizeofSubpassDescription)))
	*clone = x
	return clone
}

// SubpassDescriptionCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SubpassDescriptionCSlice(arp *AutoReleasePool, x ...SubpassDescription) []SubpassDescription {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassDescription * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SubpassDescription)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SubpassDescriptionFreeCSlice releases the memory allocated by SubpassDescriptionMakeCSlice.
// It does not free pointers stored inside the slice.
func SubpassDescriptionFreeCSlice(x []SubpassDescription) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubpassDescriptionMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubpassDescriptionFreeCSlice must be called on the returned slice.
func SubpassDescriptionMakeCSlice(x ...SubpassDescription) []SubpassDescription {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassDescription * len(x)
	dst := unsafe.Slice((*SubpassDescription)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Flags returns the value of flags from VkSubpassDescription
func (x SubpassDescription) Flags() SubpassDescriptionFlags {
	ptr := /* typedef */ (*SubpassDescriptionFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new SubpassDescription with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription) WithFlags(y SubpassDescriptionFlags) SubpassDescription {
	x.flags = *( /* typedef */ (*C.VkSubpassDescriptionFlags)(&y))
	return x
}
func (x *SubpassDescription) SetFlags(y SubpassDescriptionFlags) {
	x.flags = *( /* typedef */ (*C.VkSubpassDescriptionFlags)(&y))
}

// PipelineBindPoint returns the value of pipelineBindPoint from VkSubpassDescription
func (x SubpassDescription) PipelineBindPoint() PipelineBindPoint {
	ptr := /* typedef */ (*PipelineBindPoint)(&x.pipelineBindPoint)
	return *ptr
}

// WithPipelineBindPoint clones a new SubpassDescription with the value of
// PipelineBindPoint updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription) WithPipelineBindPoint(y PipelineBindPoint) SubpassDescription {
	x.pipelineBindPoint = *( /* typedef */ (*C.VkPipelineBindPoint)(&y))
	return x
}
func (x *SubpassDescription) SetPipelineBindPoint(y PipelineBindPoint) {
	x.pipelineBindPoint = *( /* typedef */ (*C.VkPipelineBindPoint)(&y))
}

// InputAttachmentCount returns the value of inputAttachmentCount from VkSubpassDescription
func (x SubpassDescription) InputAttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.inputAttachmentCount)
	return *ptr
}

// WithInputAttachmentCount clones a new SubpassDescription with the value of
// InputAttachmentCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription) WithInputAttachmentCount(y uint32) SubpassDescription {
	x.inputAttachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SubpassDescription) SetInputAttachmentCount(y uint32) {
	x.inputAttachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PInputAttachments returns the value of pInputAttachments from VkSubpassDescription
func (x SubpassDescription) PInputAttachments() []AttachmentReference {
	ptr := func(x **C.struct_VkAttachmentReference) *[]AttachmentReference { /* Slice */
		slc := unsafe.Slice((*AttachmentReference)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pInputAttachments)
	return *ptr
}

// WithPInputAttachments clones a new SubpassDescription with the value of
// PInputAttachments updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines InputAttachmentCount as the length of this field.
// InputAttachmentCount is updated with the length of the new value.
func (x SubpassDescription) WithPInputAttachments(y []AttachmentReference) SubpassDescription {
	x.pInputAttachments = *(func(x *[]AttachmentReference) **C.struct_VkAttachmentReference { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkAttachmentReference)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkAttachmentReference)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithInputAttachmentCount(uint32(len(y)))
}
func (x *SubpassDescription) SetPInputAttachments(y []AttachmentReference) {
	x.pInputAttachments = *(func(x *[]AttachmentReference) **C.struct_VkAttachmentReference { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkAttachmentReference)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkAttachmentReference)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetInputAttachmentCount(uint32(len(y)))
}

// ColorAttachmentCount returns the value of colorAttachmentCount from VkSubpassDescription
func (x SubpassDescription) ColorAttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.colorAttachmentCount)
	return *ptr
}

// WithColorAttachmentCount clones a new SubpassDescription with the value of
// ColorAttachmentCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription) WithColorAttachmentCount(y uint32) SubpassDescription {
	x.colorAttachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SubpassDescription) SetColorAttachmentCount(y uint32) {
	x.colorAttachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PColorAttachments returns the value of pColorAttachments from VkSubpassDescription
func (x SubpassDescription) PColorAttachments() []AttachmentReference {
	ptr := func(x **C.struct_VkAttachmentReference) *[]AttachmentReference { /* Slice */
		slc := unsafe.Slice((*AttachmentReference)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pColorAttachments)
	return *ptr
}

// WithPColorAttachments clones a new SubpassDescription with the value of
// PColorAttachments updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines ColorAttachmentCount as the length of this field.
// ColorAttachmentCount is updated with the length of the new value.
func (x SubpassDescription) WithPColorAttachments(y []AttachmentReference) SubpassDescription {
	x.pColorAttachments = *(func(x *[]AttachmentReference) **C.struct_VkAttachmentReference { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkAttachmentReference)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkAttachmentReference)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithColorAttachmentCount(uint32(len(y)))
}
func (x *SubpassDescription) SetPColorAttachments(y []AttachmentReference) {
	x.pColorAttachments = *(func(x *[]AttachmentReference) **C.struct_VkAttachmentReference { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkAttachmentReference)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkAttachmentReference)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetColorAttachmentCount(uint32(len(y)))
}

// PResolveAttachments returns the value of pResolveAttachments from VkSubpassDescription
func (x SubpassDescription) PResolveAttachments() []AttachmentReference {
	ptr := func(x **C.struct_VkAttachmentReference) *[]AttachmentReference { /* Slice */
		slc := unsafe.Slice((*AttachmentReference)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pResolveAttachments)
	return *ptr
}

// WithPResolveAttachments clones a new SubpassDescription with the value of
// PResolveAttachments updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines ColorAttachmentCount as the length of this field.
// ColorAttachmentCount is updated with the length of the new value.
func (x SubpassDescription) WithPResolveAttachments(y []AttachmentReference) SubpassDescription {
	x.pResolveAttachments = *(func(x *[]AttachmentReference) **C.struct_VkAttachmentReference { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkAttachmentReference)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkAttachmentReference)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithColorAttachmentCount(uint32(len(y)))
}
func (x *SubpassDescription) SetPResolveAttachments(y []AttachmentReference) {
	x.pResolveAttachments = *(func(x *[]AttachmentReference) **C.struct_VkAttachmentReference { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkAttachmentReference)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkAttachmentReference)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetColorAttachmentCount(uint32(len(y)))
}

// PDepthStencilAttachment returns the value of pDepthStencilAttachment from VkSubpassDescription
func (x SubpassDescription) PDepthStencilAttachment() *AttachmentReference {
	ptr := func(x **C.struct_VkAttachmentReference) **AttachmentReference { /* Pointer */
		c2g := (*AttachmentReference)(*x)
		return &c2g
	}(&x.pDepthStencilAttachment)
	return *ptr
}

// WithPDepthStencilAttachment clones a new SubpassDescription with the value of
// PDepthStencilAttachment updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription) WithPDepthStencilAttachment(y *AttachmentReference) SubpassDescription {
	x.pDepthStencilAttachment = *(func(x **AttachmentReference) **C.struct_VkAttachmentReference { /* Pointer */
		g2c := (*C.struct_VkAttachmentReference)(*x)
		return &g2c
	}(&y))
	return x
}
func (x *SubpassDescription) SetPDepthStencilAttachment(y *AttachmentReference) {
	x.pDepthStencilAttachment = *(func(x **AttachmentReference) **C.struct_VkAttachmentReference { /* Pointer */
		g2c := (*C.struct_VkAttachmentReference)(*x)
		return &g2c
	}(&y))
}

// PreserveAttachmentCount returns the value of preserveAttachmentCount from VkSubpassDescription
func (x SubpassDescription) PreserveAttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.preserveAttachmentCount)
	return *ptr
}

// WithPreserveAttachmentCount clones a new SubpassDescription with the value of
// PreserveAttachmentCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription) WithPreserveAttachmentCount(y uint32) SubpassDescription {
	x.preserveAttachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SubpassDescription) SetPreserveAttachmentCount(y uint32) {
	x.preserveAttachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PPreserveAttachments returns the value of pPreserveAttachments from VkSubpassDescription
func (x SubpassDescription) PPreserveAttachments() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pPreserveAttachments)
	return *ptr
}

// WithPPreserveAttachments clones a new SubpassDescription with the value of
// PPreserveAttachments updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines PreserveAttachmentCount as the length of this field.
// PreserveAttachmentCount is updated with the length of the new value.
func (x SubpassDescription) WithPPreserveAttachments(y []uint32) SubpassDescription {
	x.pPreserveAttachments = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithPreserveAttachmentCount(uint32(len(y)))
}
func (x *SubpassDescription) SetPPreserveAttachments(y []uint32) {
	x.pPreserveAttachments = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetPreserveAttachmentCount(uint32(len(y)))
}

// SubpassDependency provides a go interface for VkSubpassDependency.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDependency.html
type SubpassDependency C.struct_VkSubpassDependency

// SizeofSubpassDependency is the memory size of a SubpassDependency
var SizeofSubpassDependency int = int(unsafe.Sizeof(SubpassDependency{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SubpassDependency) ArpPtr(arp *AutoReleasePool) *SubpassDependency {
	ptr := newCBlock(cULong(SizeofSubpassDependency))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SubpassDependency)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubpassDependency) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubpassDependency) AsCPtr() *SubpassDependency {
	clone := (*SubpassDependency)(newCBlock(cULong(SizeofSubpassDependency)))
	*clone = x
	return clone
}

// SubpassDependencyCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SubpassDependencyCSlice(arp *AutoReleasePool, x ...SubpassDependency) []SubpassDependency {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassDependency * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SubpassDependency)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SubpassDependencyFreeCSlice releases the memory allocated by SubpassDependencyMakeCSlice.
// It does not free pointers stored inside the slice.
func SubpassDependencyFreeCSlice(x []SubpassDependency) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubpassDependencyMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubpassDependencyFreeCSlice must be called on the returned slice.
func SubpassDependencyMakeCSlice(x ...SubpassDependency) []SubpassDependency {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassDependency * len(x)
	dst := unsafe.Slice((*SubpassDependency)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SrcSubpass returns the value of srcSubpass from VkSubpassDependency
func (x SubpassDependency) SrcSubpass() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.srcSubpass)
	return *ptr
}

// WithSrcSubpass clones a new SubpassDependency with the value of
// SrcSubpass updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency) WithSrcSubpass(y uint32) SubpassDependency {
	x.srcSubpass = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SubpassDependency) SetSrcSubpass(y uint32) {
	x.srcSubpass = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// DstSubpass returns the value of dstSubpass from VkSubpassDependency
func (x SubpassDependency) DstSubpass() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dstSubpass)
	return *ptr
}

// WithDstSubpass clones a new SubpassDependency with the value of
// DstSubpass updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency) WithDstSubpass(y uint32) SubpassDependency {
	x.dstSubpass = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SubpassDependency) SetDstSubpass(y uint32) {
	x.dstSubpass = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// SrcStageMask returns the value of srcStageMask from VkSubpassDependency
func (x SubpassDependency) SrcStageMask() PipelineStageFlags {
	ptr := /* typedef */ (*PipelineStageFlags)(&x.srcStageMask)
	return *ptr
}

// WithSrcStageMask clones a new SubpassDependency with the value of
// SrcStageMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency) WithSrcStageMask(y PipelineStageFlags) SubpassDependency {
	x.srcStageMask = *( /* typedef */ (*C.VkPipelineStageFlags)(&y))
	return x
}
func (x *SubpassDependency) SetSrcStageMask(y PipelineStageFlags) {
	x.srcStageMask = *( /* typedef */ (*C.VkPipelineStageFlags)(&y))
}

// DstStageMask returns the value of dstStageMask from VkSubpassDependency
func (x SubpassDependency) DstStageMask() PipelineStageFlags {
	ptr := /* typedef */ (*PipelineStageFlags)(&x.dstStageMask)
	return *ptr
}

// WithDstStageMask clones a new SubpassDependency with the value of
// DstStageMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency) WithDstStageMask(y PipelineStageFlags) SubpassDependency {
	x.dstStageMask = *( /* typedef */ (*C.VkPipelineStageFlags)(&y))
	return x
}
func (x *SubpassDependency) SetDstStageMask(y PipelineStageFlags) {
	x.dstStageMask = *( /* typedef */ (*C.VkPipelineStageFlags)(&y))
}

// SrcAccessMask returns the value of srcAccessMask from VkSubpassDependency
func (x SubpassDependency) SrcAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.srcAccessMask)
	return *ptr
}

// WithSrcAccessMask clones a new SubpassDependency with the value of
// SrcAccessMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency) WithSrcAccessMask(y AccessFlags) SubpassDependency {
	x.srcAccessMask = *( /* typedef */ (*C.VkAccessFlags)(&y))
	return x
}
func (x *SubpassDependency) SetSrcAccessMask(y AccessFlags) {
	x.srcAccessMask = *( /* typedef */ (*C.VkAccessFlags)(&y))
}

// DstAccessMask returns the value of dstAccessMask from VkSubpassDependency
func (x SubpassDependency) DstAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.dstAccessMask)
	return *ptr
}

// WithDstAccessMask clones a new SubpassDependency with the value of
// DstAccessMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency) WithDstAccessMask(y AccessFlags) SubpassDependency {
	x.dstAccessMask = *( /* typedef */ (*C.VkAccessFlags)(&y))
	return x
}
func (x *SubpassDependency) SetDstAccessMask(y AccessFlags) {
	x.dstAccessMask = *( /* typedef */ (*C.VkAccessFlags)(&y))
}

// DependencyFlags returns the value of dependencyFlags from VkSubpassDependency
func (x SubpassDependency) DependencyFlags() DependencyFlags {
	ptr := /* typedef */ (*DependencyFlags)(&x.dependencyFlags)
	return *ptr
}

// WithDependencyFlags clones a new SubpassDependency with the value of
// DependencyFlags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency) WithDependencyFlags(y DependencyFlags) SubpassDependency {
	x.dependencyFlags = *( /* typedef */ (*C.VkDependencyFlags)(&y))
	return x
}
func (x *SubpassDependency) SetDependencyFlags(y DependencyFlags) {
	x.dependencyFlags = *( /* typedef */ (*C.VkDependencyFlags)(&y))
}

// FenceCreateInfo provides a go interface for VkFenceCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFenceCreateInfo.html
type FenceCreateInfo C.struct_VkFenceCreateInfo

// SizeofFenceCreateInfo is the memory size of a FenceCreateInfo
var SizeofFenceCreateInfo int = int(unsafe.Sizeof(FenceCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x FenceCreateInfo) ArpPtr(arp *AutoReleasePool) *FenceCreateInfo {
	ptr := newCBlock(cULong(SizeofFenceCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*FenceCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *FenceCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x FenceCreateInfo) AsCPtr() *FenceCreateInfo {
	clone := (*FenceCreateInfo)(newCBlock(cULong(SizeofFenceCreateInfo)))
	*clone = x
	return clone
}

// FenceCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func FenceCreateInfoCSlice(arp *AutoReleasePool, x ...FenceCreateInfo) []FenceCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFenceCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*FenceCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// FenceCreateInfoFreeCSlice releases the memory allocated by FenceCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func FenceCreateInfoFreeCSlice(x []FenceCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// FenceCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. FenceCreateInfoFreeCSlice must be called on the returned slice.
func FenceCreateInfoMakeCSlice(x ...FenceCreateInfo) []FenceCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFenceCreateInfo * len(x)
	dst := unsafe.Slice((*FenceCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkFenceCreateInfo
func (x FenceCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new FenceCreateInfo with the value of
// SType to the value provided in the specification.
func (x FenceCreateInfo) WithDefaultSType() FenceCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_FENCE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *FenceCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_FENCE_CREATE_INFO)
}

// WithSType clones a new FenceCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FenceCreateInfo) WithSType(y StructureType) FenceCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *FenceCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkFenceCreateInfo
func (x FenceCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new FenceCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FenceCreateInfo) WithPNext(y unsafe.Pointer) FenceCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *FenceCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkFenceCreateInfo
func (x FenceCreateInfo) Flags() FenceCreateFlags {
	ptr := /* typedef */ (*FenceCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new FenceCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FenceCreateInfo) WithFlags(y FenceCreateFlags) FenceCreateInfo {
	x.flags = *( /* typedef */ (*C.VkFenceCreateFlags)(&y))
	return x
}
func (x *FenceCreateInfo) SetFlags(y FenceCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkFenceCreateFlags)(&y))
}

// ShaderModuleCreateInfo provides a go interface for VkShaderModuleCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderModuleCreateInfo.html
type ShaderModuleCreateInfo C.struct_VkShaderModuleCreateInfo

// SizeofShaderModuleCreateInfo is the memory size of a ShaderModuleCreateInfo
var SizeofShaderModuleCreateInfo int = int(unsafe.Sizeof(ShaderModuleCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ShaderModuleCreateInfo) ArpPtr(arp *AutoReleasePool) *ShaderModuleCreateInfo {
	ptr := newCBlock(cULong(SizeofShaderModuleCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ShaderModuleCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ShaderModuleCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ShaderModuleCreateInfo) AsCPtr() *ShaderModuleCreateInfo {
	clone := (*ShaderModuleCreateInfo)(newCBlock(cULong(SizeofShaderModuleCreateInfo)))
	*clone = x
	return clone
}

// ShaderModuleCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ShaderModuleCreateInfoCSlice(arp *AutoReleasePool, x ...ShaderModuleCreateInfo) []ShaderModuleCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofShaderModuleCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ShaderModuleCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ShaderModuleCreateInfoFreeCSlice releases the memory allocated by ShaderModuleCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ShaderModuleCreateInfoFreeCSlice(x []ShaderModuleCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ShaderModuleCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ShaderModuleCreateInfoFreeCSlice must be called on the returned slice.
func ShaderModuleCreateInfoMakeCSlice(x ...ShaderModuleCreateInfo) []ShaderModuleCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofShaderModuleCreateInfo * len(x)
	dst := unsafe.Slice((*ShaderModuleCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkShaderModuleCreateInfo
func (x ShaderModuleCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ShaderModuleCreateInfo with the value of
// SType to the value provided in the specification.
func (x ShaderModuleCreateInfo) WithDefaultSType() ShaderModuleCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ShaderModuleCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO)
}

// WithSType clones a new ShaderModuleCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ShaderModuleCreateInfo) WithSType(y StructureType) ShaderModuleCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ShaderModuleCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkShaderModuleCreateInfo
func (x ShaderModuleCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ShaderModuleCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ShaderModuleCreateInfo) WithPNext(y unsafe.Pointer) ShaderModuleCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ShaderModuleCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkShaderModuleCreateInfo
func (x ShaderModuleCreateInfo) Flags() ShaderModuleCreateFlags {
	ptr := /* typedef */ (*ShaderModuleCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new ShaderModuleCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ShaderModuleCreateInfo) WithFlags(y ShaderModuleCreateFlags) ShaderModuleCreateInfo {
	x.flags = *( /* typedef */ (*C.VkShaderModuleCreateFlags)(&y))
	return x
}
func (x *ShaderModuleCreateInfo) SetFlags(y ShaderModuleCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkShaderModuleCreateFlags)(&y))
}

// CodeSize returns the value of codeSize from VkShaderModuleCreateInfo
func (x ShaderModuleCreateInfo) CodeSize() uint64 {
	ptr := func(x *C.size_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.codeSize)
	return *ptr
}

// WithCodeSize clones a new ShaderModuleCreateInfo with the value of
// CodeSize updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ShaderModuleCreateInfo) WithCodeSize(y uint64) ShaderModuleCreateInfo {
	x.codeSize = *(func(x *uint64) *C.size_t { /* Scalar */ g2c := C.size_t(*x); return &g2c }(&y))
	return x
}
func (x *ShaderModuleCreateInfo) SetCodeSize(y uint64) {
	x.codeSize = *(func(x *uint64) *C.size_t { /* Scalar */ g2c := C.size_t(*x); return &g2c }(&y))
}

// PCode returns the value of pCode from VkShaderModuleCreateInfo
func (x ShaderModuleCreateInfo) PCode() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pCode)
	return *ptr
}

// WithPCode clones a new ShaderModuleCreateInfo with the value of
// PCode updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ShaderModuleCreateInfo) WithPCode(y []uint32) ShaderModuleCreateInfo {
	x.pCode = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	return x
}
func (x *ShaderModuleCreateInfo) SetPCode(y []uint32) {
	x.pCode = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
}

// AttachmentDescription provides a go interface for VkAttachmentDescription.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentDescription.html
type AttachmentDescription C.struct_VkAttachmentDescription

// SizeofAttachmentDescription is the memory size of a AttachmentDescription
var SizeofAttachmentDescription int = int(unsafe.Sizeof(AttachmentDescription{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x AttachmentDescription) ArpPtr(arp *AutoReleasePool) *AttachmentDescription {
	ptr := newCBlock(cULong(SizeofAttachmentDescription))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*AttachmentDescription)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *AttachmentDescription) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x AttachmentDescription) AsCPtr() *AttachmentDescription {
	clone := (*AttachmentDescription)(newCBlock(cULong(SizeofAttachmentDescription)))
	*clone = x
	return clone
}

// AttachmentDescriptionCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func AttachmentDescriptionCSlice(arp *AutoReleasePool, x ...AttachmentDescription) []AttachmentDescription {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAttachmentDescription * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*AttachmentDescription)(ptr), len(x))
	copy(dst, x)
	return dst
}

// AttachmentDescriptionFreeCSlice releases the memory allocated by AttachmentDescriptionMakeCSlice.
// It does not free pointers stored inside the slice.
func AttachmentDescriptionFreeCSlice(x []AttachmentDescription) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// AttachmentDescriptionMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. AttachmentDescriptionFreeCSlice must be called on the returned slice.
func AttachmentDescriptionMakeCSlice(x ...AttachmentDescription) []AttachmentDescription {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAttachmentDescription * len(x)
	dst := unsafe.Slice((*AttachmentDescription)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Flags returns the value of flags from VkAttachmentDescription
func (x AttachmentDescription) Flags() AttachmentDescriptionFlags {
	ptr := /* typedef */ (*AttachmentDescriptionFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new AttachmentDescription with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription) WithFlags(y AttachmentDescriptionFlags) AttachmentDescription {
	x.flags = *( /* typedef */ (*C.VkAttachmentDescriptionFlags)(&y))
	return x
}
func (x *AttachmentDescription) SetFlags(y AttachmentDescriptionFlags) {
	x.flags = *( /* typedef */ (*C.VkAttachmentDescriptionFlags)(&y))
}

// Format returns the value of format from VkAttachmentDescription
func (x AttachmentDescription) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format)
	return *ptr
}

// WithFormat clones a new AttachmentDescription with the value of
// Format updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription) WithFormat(y Format) AttachmentDescription {
	x.format = *( /* typedef */ (*C.VkFormat)(&y))
	return x
}
func (x *AttachmentDescription) SetFormat(y Format) {
	x.format = *( /* typedef */ (*C.VkFormat)(&y))
}

// Samples returns the value of samples from VkAttachmentDescription
func (x AttachmentDescription) Samples() SampleCountFlagBits {
	ptr := /* typedef */ (*SampleCountFlagBits)(&x.samples)
	return *ptr
}

// WithSamples clones a new AttachmentDescription with the value of
// Samples updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription) WithSamples(y SampleCountFlagBits) AttachmentDescription {
	x.samples = *( /* typedef */ (*C.VkSampleCountFlagBits)(&y))
	return x
}
func (x *AttachmentDescription) SetSamples(y SampleCountFlagBits) {
	x.samples = *( /* typedef */ (*C.VkSampleCountFlagBits)(&y))
}

// LoadOp returns the value of loadOp from VkAttachmentDescription
func (x AttachmentDescription) LoadOp() AttachmentLoadOp {
	ptr := /* typedef */ (*AttachmentLoadOp)(&x.loadOp)
	return *ptr
}

// WithLoadOp clones a new AttachmentDescription with the value of
// LoadOp updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription) WithLoadOp(y AttachmentLoadOp) AttachmentDescription {
	x.loadOp = *( /* typedef */ (*C.VkAttachmentLoadOp)(&y))
	return x
}
func (x *AttachmentDescription) SetLoadOp(y AttachmentLoadOp) {
	x.loadOp = *( /* typedef */ (*C.VkAttachmentLoadOp)(&y))
}

// StoreOp returns the value of storeOp from VkAttachmentDescription
func (x AttachmentDescription) StoreOp() AttachmentStoreOp {
	ptr := /* typedef */ (*AttachmentStoreOp)(&x.storeOp)
	return *ptr
}

// WithStoreOp clones a new AttachmentDescription with the value of
// StoreOp updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription) WithStoreOp(y AttachmentStoreOp) AttachmentDescription {
	x.storeOp = *( /* typedef */ (*C.VkAttachmentStoreOp)(&y))
	return x
}
func (x *AttachmentDescription) SetStoreOp(y AttachmentStoreOp) {
	x.storeOp = *( /* typedef */ (*C.VkAttachmentStoreOp)(&y))
}

// StencilLoadOp returns the value of stencilLoadOp from VkAttachmentDescription
func (x AttachmentDescription) StencilLoadOp() AttachmentLoadOp {
	ptr := /* typedef */ (*AttachmentLoadOp)(&x.stencilLoadOp)
	return *ptr
}

// WithStencilLoadOp clones a new AttachmentDescription with the value of
// StencilLoadOp updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription) WithStencilLoadOp(y AttachmentLoadOp) AttachmentDescription {
	x.stencilLoadOp = *( /* typedef */ (*C.VkAttachmentLoadOp)(&y))
	return x
}
func (x *AttachmentDescription) SetStencilLoadOp(y AttachmentLoadOp) {
	x.stencilLoadOp = *( /* typedef */ (*C.VkAttachmentLoadOp)(&y))
}

// StencilStoreOp returns the value of stencilStoreOp from VkAttachmentDescription
func (x AttachmentDescription) StencilStoreOp() AttachmentStoreOp {
	ptr := /* typedef */ (*AttachmentStoreOp)(&x.stencilStoreOp)
	return *ptr
}

// WithStencilStoreOp clones a new AttachmentDescription with the value of
// StencilStoreOp updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription) WithStencilStoreOp(y AttachmentStoreOp) AttachmentDescription {
	x.stencilStoreOp = *( /* typedef */ (*C.VkAttachmentStoreOp)(&y))
	return x
}
func (x *AttachmentDescription) SetStencilStoreOp(y AttachmentStoreOp) {
	x.stencilStoreOp = *( /* typedef */ (*C.VkAttachmentStoreOp)(&y))
}

// InitialLayout returns the value of initialLayout from VkAttachmentDescription
func (x AttachmentDescription) InitialLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.initialLayout)
	return *ptr
}

// WithInitialLayout clones a new AttachmentDescription with the value of
// InitialLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription) WithInitialLayout(y ImageLayout) AttachmentDescription {
	x.initialLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
	return x
}
func (x *AttachmentDescription) SetInitialLayout(y ImageLayout) {
	x.initialLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
}

// FinalLayout returns the value of finalLayout from VkAttachmentDescription
func (x AttachmentDescription) FinalLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.finalLayout)
	return *ptr
}

// WithFinalLayout clones a new AttachmentDescription with the value of
// FinalLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription) WithFinalLayout(y ImageLayout) AttachmentDescription {
	x.finalLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
	return x
}
func (x *AttachmentDescription) SetFinalLayout(y ImageLayout) {
	x.finalLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
}

// RenderPassCreateInfo provides a go interface for VkRenderPassCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreateInfo.html
type RenderPassCreateInfo C.struct_VkRenderPassCreateInfo

// SizeofRenderPassCreateInfo is the memory size of a RenderPassCreateInfo
var SizeofRenderPassCreateInfo int = int(unsafe.Sizeof(RenderPassCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x RenderPassCreateInfo) ArpPtr(arp *AutoReleasePool) *RenderPassCreateInfo {
	ptr := newCBlock(cULong(SizeofRenderPassCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*RenderPassCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *RenderPassCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x RenderPassCreateInfo) AsCPtr() *RenderPassCreateInfo {
	clone := (*RenderPassCreateInfo)(newCBlock(cULong(SizeofRenderPassCreateInfo)))
	*clone = x
	return clone
}

// RenderPassCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func RenderPassCreateInfoCSlice(arp *AutoReleasePool, x ...RenderPassCreateInfo) []RenderPassCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderPassCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*RenderPassCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// RenderPassCreateInfoFreeCSlice releases the memory allocated by RenderPassCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func RenderPassCreateInfoFreeCSlice(x []RenderPassCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// RenderPassCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. RenderPassCreateInfoFreeCSlice must be called on the returned slice.
func RenderPassCreateInfoMakeCSlice(x ...RenderPassCreateInfo) []RenderPassCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderPassCreateInfo * len(x)
	dst := unsafe.Slice((*RenderPassCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkRenderPassCreateInfo
func (x RenderPassCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new RenderPassCreateInfo with the value of
// SType to the value provided in the specification.
func (x RenderPassCreateInfo) WithDefaultSType() RenderPassCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *RenderPassCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO)
}

// WithSType clones a new RenderPassCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo) WithSType(y StructureType) RenderPassCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *RenderPassCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkRenderPassCreateInfo
func (x RenderPassCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new RenderPassCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo) WithPNext(y unsafe.Pointer) RenderPassCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *RenderPassCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkRenderPassCreateInfo
func (x RenderPassCreateInfo) Flags() RenderPassCreateFlags {
	ptr := /* typedef */ (*RenderPassCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new RenderPassCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo) WithFlags(y RenderPassCreateFlags) RenderPassCreateInfo {
	x.flags = *( /* typedef */ (*C.VkRenderPassCreateFlags)(&y))
	return x
}
func (x *RenderPassCreateInfo) SetFlags(y RenderPassCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkRenderPassCreateFlags)(&y))
}

// AttachmentCount returns the value of attachmentCount from VkRenderPassCreateInfo
func (x RenderPassCreateInfo) AttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.attachmentCount)
	return *ptr
}

// WithAttachmentCount clones a new RenderPassCreateInfo with the value of
// AttachmentCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo) WithAttachmentCount(y uint32) RenderPassCreateInfo {
	x.attachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *RenderPassCreateInfo) SetAttachmentCount(y uint32) {
	x.attachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PAttachments returns the value of pAttachments from VkRenderPassCreateInfo
func (x RenderPassCreateInfo) PAttachments() []AttachmentDescription {
	ptr := func(x **C.struct_VkAttachmentDescription) *[]AttachmentDescription { /* Slice */
		slc := unsafe.Slice((*AttachmentDescription)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pAttachments)
	return *ptr
}

// WithPAttachments clones a new RenderPassCreateInfo with the value of
// PAttachments updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines AttachmentCount as the length of this field.
// AttachmentCount is updated with the length of the new value.
func (x RenderPassCreateInfo) WithPAttachments(y []AttachmentDescription) RenderPassCreateInfo {
	x.pAttachments = *(func(x *[]AttachmentDescription) **C.struct_VkAttachmentDescription { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkAttachmentDescription)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkAttachmentDescription)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithAttachmentCount(uint32(len(y)))
}
func (x *RenderPassCreateInfo) SetPAttachments(y []AttachmentDescription) {
	x.pAttachments = *(func(x *[]AttachmentDescription) **C.struct_VkAttachmentDescription { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkAttachmentDescription)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkAttachmentDescription)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetAttachmentCount(uint32(len(y)))
}

// SubpassCount returns the value of subpassCount from VkRenderPassCreateInfo
func (x RenderPassCreateInfo) SubpassCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.subpassCount)
	return *ptr
}

// WithSubpassCount clones a new RenderPassCreateInfo with the value of
// SubpassCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo) WithSubpassCount(y uint32) RenderPassCreateInfo {
	x.subpassCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *RenderPassCreateInfo) SetSubpassCount(y uint32) {
	x.subpassCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PSubpasses returns the value of pSubpasses from VkRenderPassCreateInfo
func (x RenderPassCreateInfo) PSubpasses() []SubpassDescription {
	ptr := func(x **C.struct_VkSubpassDescription) *[]SubpassDescription { /* Slice */
		slc := unsafe.Slice((*SubpassDescription)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pSubpasses)
	return *ptr
}

// WithPSubpasses clones a new RenderPassCreateInfo with the value of
// PSubpasses updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SubpassCount as the length of this field.
// SubpassCount is updated with the length of the new value.
func (x RenderPassCreateInfo) WithPSubpasses(y []SubpassDescription) RenderPassCreateInfo {
	x.pSubpasses = *(func(x *[]SubpassDescription) **C.struct_VkSubpassDescription { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSubpassDescription)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSubpassDescription)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithSubpassCount(uint32(len(y)))
}
func (x *RenderPassCreateInfo) SetPSubpasses(y []SubpassDescription) {
	x.pSubpasses = *(func(x *[]SubpassDescription) **C.struct_VkSubpassDescription { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSubpassDescription)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSubpassDescription)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetSubpassCount(uint32(len(y)))
}

// DependencyCount returns the value of dependencyCount from VkRenderPassCreateInfo
func (x RenderPassCreateInfo) DependencyCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dependencyCount)
	return *ptr
}

// WithDependencyCount clones a new RenderPassCreateInfo with the value of
// DependencyCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo) WithDependencyCount(y uint32) RenderPassCreateInfo {
	x.dependencyCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *RenderPassCreateInfo) SetDependencyCount(y uint32) {
	x.dependencyCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PDependencies returns the value of pDependencies from VkRenderPassCreateInfo
func (x RenderPassCreateInfo) PDependencies() []SubpassDependency {
	ptr := func(x **C.struct_VkSubpassDependency) *[]SubpassDependency { /* Slice */
		slc := unsafe.Slice((*SubpassDependency)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pDependencies)
	return *ptr
}

// WithPDependencies clones a new RenderPassCreateInfo with the value of
// PDependencies updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DependencyCount as the length of this field.
// DependencyCount is updated with the length of the new value.
func (x RenderPassCreateInfo) WithPDependencies(y []SubpassDependency) RenderPassCreateInfo {
	x.pDependencies = *(func(x *[]SubpassDependency) **C.struct_VkSubpassDependency { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSubpassDependency)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSubpassDependency)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithDependencyCount(uint32(len(y)))
}
func (x *RenderPassCreateInfo) SetPDependencies(y []SubpassDependency) {
	x.pDependencies = *(func(x *[]SubpassDependency) **C.struct_VkSubpassDependency { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSubpassDependency)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSubpassDependency)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetDependencyCount(uint32(len(y)))
}

// FramebufferCreateInfo provides a go interface for VkFramebufferCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebufferCreateInfo.html
type FramebufferCreateInfo C.struct_VkFramebufferCreateInfo

// SizeofFramebufferCreateInfo is the memory size of a FramebufferCreateInfo
var SizeofFramebufferCreateInfo int = int(unsafe.Sizeof(FramebufferCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x FramebufferCreateInfo) ArpPtr(arp *AutoReleasePool) *FramebufferCreateInfo {
	ptr := newCBlock(cULong(SizeofFramebufferCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*FramebufferCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *FramebufferCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x FramebufferCreateInfo) AsCPtr() *FramebufferCreateInfo {
	clone := (*FramebufferCreateInfo)(newCBlock(cULong(SizeofFramebufferCreateInfo)))
	*clone = x
	return clone
}

// FramebufferCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func FramebufferCreateInfoCSlice(arp *AutoReleasePool, x ...FramebufferCreateInfo) []FramebufferCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFramebufferCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*FramebufferCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// FramebufferCreateInfoFreeCSlice releases the memory allocated by FramebufferCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func FramebufferCreateInfoFreeCSlice(x []FramebufferCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// FramebufferCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. FramebufferCreateInfoFreeCSlice must be called on the returned slice.
func FramebufferCreateInfoMakeCSlice(x ...FramebufferCreateInfo) []FramebufferCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFramebufferCreateInfo * len(x)
	dst := unsafe.Slice((*FramebufferCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkFramebufferCreateInfo
func (x FramebufferCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new FramebufferCreateInfo with the value of
// SType to the value provided in the specification.
func (x FramebufferCreateInfo) WithDefaultSType() FramebufferCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *FramebufferCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO)
}

// WithSType clones a new FramebufferCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferCreateInfo) WithSType(y StructureType) FramebufferCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *FramebufferCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkFramebufferCreateInfo
func (x FramebufferCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new FramebufferCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferCreateInfo) WithPNext(y unsafe.Pointer) FramebufferCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *FramebufferCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkFramebufferCreateInfo
func (x FramebufferCreateInfo) Flags() FramebufferCreateFlags {
	ptr := /* typedef */ (*FramebufferCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new FramebufferCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferCreateInfo) WithFlags(y FramebufferCreateFlags) FramebufferCreateInfo {
	x.flags = *( /* typedef */ (*C.VkFramebufferCreateFlags)(&y))
	return x
}
func (x *FramebufferCreateInfo) SetFlags(y FramebufferCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkFramebufferCreateFlags)(&y))
}

// RenderPass returns the value of renderPass from VkFramebufferCreateInfo
func (x FramebufferCreateInfo) RenderPass() RenderPass {
	ptr := /* handle */ (*RenderPass)(&x.renderPass)
	return *ptr
}

// WithRenderPass clones a new FramebufferCreateInfo with the value of
// RenderPass updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferCreateInfo) WithRenderPass(y RenderPass) FramebufferCreateInfo {
	x.renderPass = *( /* handle */ (*C.VkRenderPass)(&y))
	return x
}
func (x *FramebufferCreateInfo) SetRenderPass(y RenderPass) {
	x.renderPass = *( /* handle */ (*C.VkRenderPass)(&y))
}

// AttachmentCount returns the value of attachmentCount from VkFramebufferCreateInfo
func (x FramebufferCreateInfo) AttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.attachmentCount)
	return *ptr
}

// WithAttachmentCount clones a new FramebufferCreateInfo with the value of
// AttachmentCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferCreateInfo) WithAttachmentCount(y uint32) FramebufferCreateInfo {
	x.attachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *FramebufferCreateInfo) SetAttachmentCount(y uint32) {
	x.attachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PAttachments returns the value of pAttachments from VkFramebufferCreateInfo
func (x FramebufferCreateInfo) PAttachments() []ImageView {
	ptr := func(x **C.VkImageView) *[]ImageView { /* Slice */
		slc := unsafe.Slice((*ImageView)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pAttachments)
	return *ptr
}

// WithPAttachments clones a new FramebufferCreateInfo with the value of
// PAttachments updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines AttachmentCount as the length of this field.
// AttachmentCount is updated with the length of the new value.
func (x FramebufferCreateInfo) WithPAttachments(y []ImageView) FramebufferCreateInfo {
	x.pAttachments = *(func(x *[]ImageView) **C.VkImageView { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkImageView)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkImageView)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithAttachmentCount(uint32(len(y)))
}
func (x *FramebufferCreateInfo) SetPAttachments(y []ImageView) {
	x.pAttachments = *(func(x *[]ImageView) **C.VkImageView { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkImageView)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkImageView)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetAttachmentCount(uint32(len(y)))
}

// Width returns the value of width from VkFramebufferCreateInfo
func (x FramebufferCreateInfo) Width() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.width)
	return *ptr
}

// WithWidth clones a new FramebufferCreateInfo with the value of
// Width updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferCreateInfo) WithWidth(y uint32) FramebufferCreateInfo {
	x.width = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *FramebufferCreateInfo) SetWidth(y uint32) {
	x.width = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// Height returns the value of height from VkFramebufferCreateInfo
func (x FramebufferCreateInfo) Height() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.height)
	return *ptr
}

// WithHeight clones a new FramebufferCreateInfo with the value of
// Height updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferCreateInfo) WithHeight(y uint32) FramebufferCreateInfo {
	x.height = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *FramebufferCreateInfo) SetHeight(y uint32) {
	x.height = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// Layers returns the value of layers from VkFramebufferCreateInfo
func (x FramebufferCreateInfo) Layers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.layers)
	return *ptr
}

// WithLayers clones a new FramebufferCreateInfo with the value of
// Layers updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferCreateInfo) WithLayers(y uint32) FramebufferCreateInfo {
	x.layers = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *FramebufferCreateInfo) SetLayers(y uint32) {
	x.layers = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// BaseInStructure provides a go interface for VkBaseInStructure.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBaseInStructure.html
type BaseInStructure C.struct_VkBaseInStructure

// SizeofBaseInStructure is the memory size of a BaseInStructure
var SizeofBaseInStructure int = int(unsafe.Sizeof(BaseInStructure{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x BaseInStructure) ArpPtr(arp *AutoReleasePool) *BaseInStructure {
	ptr := newCBlock(cULong(SizeofBaseInStructure))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*BaseInStructure)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BaseInStructure) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BaseInStructure) AsCPtr() *BaseInStructure {
	clone := (*BaseInStructure)(newCBlock(cULong(SizeofBaseInStructure)))
	*clone = x
	return clone
}

// BaseInStructureCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func BaseInStructureCSlice(arp *AutoReleasePool, x ...BaseInStructure) []BaseInStructure {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBaseInStructure * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*BaseInStructure)(ptr), len(x))
	copy(dst, x)
	return dst
}

// BaseInStructureFreeCSlice releases the memory allocated by BaseInStructureMakeCSlice.
// It does not free pointers stored inside the slice.
func BaseInStructureFreeCSlice(x []BaseInStructure) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BaseInStructureMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BaseInStructureFreeCSlice must be called on the returned slice.
func BaseInStructureMakeCSlice(x ...BaseInStructure) []BaseInStructure {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBaseInStructure * len(x)
	dst := unsafe.Slice((*BaseInStructure)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBaseInStructure
func (x BaseInStructure) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithSType clones a new BaseInStructure with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BaseInStructure) WithSType(y StructureType) BaseInStructure {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *BaseInStructure) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkBaseInStructure
func (x BaseInStructure) PNext() *BaseInStructure {
	ptr := func(x **C.struct_VkBaseInStructure) **BaseInStructure { /* Pointer */
		c2g := (*BaseInStructure)(*x)
		return &c2g
	}(&x.pNext)
	return *ptr
}

// WithPNext clones a new BaseInStructure with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BaseInStructure) WithPNext(y *BaseInStructure) BaseInStructure {
	x.pNext = *(func(x **BaseInStructure) **C.struct_VkBaseInStructure { /* Pointer */
		g2c := (*C.struct_VkBaseInStructure)(*x)
		return &g2c
	}(&y))
	return x
}
func (x *BaseInStructure) SetPNext(y *BaseInStructure) {
	x.pNext = *(func(x **BaseInStructure) **C.struct_VkBaseInStructure { /* Pointer */
		g2c := (*C.struct_VkBaseInStructure)(*x)
		return &g2c
	}(&y))
}

// MappedMemoryRange provides a go interface for VkMappedMemoryRange.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMappedMemoryRange.html
type MappedMemoryRange C.struct_VkMappedMemoryRange

// SizeofMappedMemoryRange is the memory size of a MappedMemoryRange
var SizeofMappedMemoryRange int = int(unsafe.Sizeof(MappedMemoryRange{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x MappedMemoryRange) ArpPtr(arp *AutoReleasePool) *MappedMemoryRange {
	ptr := newCBlock(cULong(SizeofMappedMemoryRange))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*MappedMemoryRange)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MappedMemoryRange) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MappedMemoryRange) AsCPtr() *MappedMemoryRange {
	clone := (*MappedMemoryRange)(newCBlock(cULong(SizeofMappedMemoryRange)))
	*clone = x
	return clone
}

// MappedMemoryRangeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func MappedMemoryRangeCSlice(arp *AutoReleasePool, x ...MappedMemoryRange) []MappedMemoryRange {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMappedMemoryRange * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*MappedMemoryRange)(ptr), len(x))
	copy(dst, x)
	return dst
}

// MappedMemoryRangeFreeCSlice releases the memory allocated by MappedMemoryRangeMakeCSlice.
// It does not free pointers stored inside the slice.
func MappedMemoryRangeFreeCSlice(x []MappedMemoryRange) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MappedMemoryRangeMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MappedMemoryRangeFreeCSlice must be called on the returned slice.
func MappedMemoryRangeMakeCSlice(x ...MappedMemoryRange) []MappedMemoryRange {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMappedMemoryRange * len(x)
	dst := unsafe.Slice((*MappedMemoryRange)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkMappedMemoryRange
func (x MappedMemoryRange) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new MappedMemoryRange with the value of
// SType to the value provided in the specification.
func (x MappedMemoryRange) WithDefaultSType() MappedMemoryRange {
	return x.WithSType(VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *MappedMemoryRange) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE)
}

// WithSType clones a new MappedMemoryRange with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MappedMemoryRange) WithSType(y StructureType) MappedMemoryRange {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *MappedMemoryRange) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkMappedMemoryRange
func (x MappedMemoryRange) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new MappedMemoryRange with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MappedMemoryRange) WithPNext(y unsafe.Pointer) MappedMemoryRange {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *MappedMemoryRange) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Memory returns the value of memory from VkMappedMemoryRange
func (x MappedMemoryRange) Memory() DeviceMemory {
	ptr := /* handle */ (*DeviceMemory)(&x.memory)
	return *ptr
}

// WithMemory clones a new MappedMemoryRange with the value of
// Memory updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MappedMemoryRange) WithMemory(y DeviceMemory) MappedMemoryRange {
	x.memory = *( /* handle */ (*C.VkDeviceMemory)(&y))
	return x
}
func (x *MappedMemoryRange) SetMemory(y DeviceMemory) {
	x.memory = *( /* handle */ (*C.VkDeviceMemory)(&y))
}

// Offset returns the value of offset from VkMappedMemoryRange
func (x MappedMemoryRange) Offset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.offset)
	return *ptr
}

// WithOffset clones a new MappedMemoryRange with the value of
// Offset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MappedMemoryRange) WithOffset(y DeviceSize) MappedMemoryRange {
	x.offset = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *MappedMemoryRange) SetOffset(y DeviceSize) {
	x.offset = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// Size returns the value of size from VkMappedMemoryRange
func (x MappedMemoryRange) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size)
	return *ptr
}

// WithSize clones a new MappedMemoryRange with the value of
// Size updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MappedMemoryRange) WithSize(y DeviceSize) MappedMemoryRange {
	x.size = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *MappedMemoryRange) SetSize(y DeviceSize) {
	x.size = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// PipelineCacheCreateInfo provides a go interface for VkPipelineCacheCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCacheCreateInfo.html
type PipelineCacheCreateInfo C.struct_VkPipelineCacheCreateInfo

// SizeofPipelineCacheCreateInfo is the memory size of a PipelineCacheCreateInfo
var SizeofPipelineCacheCreateInfo int = int(unsafe.Sizeof(PipelineCacheCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PipelineCacheCreateInfo) ArpPtr(arp *AutoReleasePool) *PipelineCacheCreateInfo {
	ptr := newCBlock(cULong(SizeofPipelineCacheCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PipelineCacheCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineCacheCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineCacheCreateInfo) AsCPtr() *PipelineCacheCreateInfo {
	clone := (*PipelineCacheCreateInfo)(newCBlock(cULong(SizeofPipelineCacheCreateInfo)))
	*clone = x
	return clone
}

// PipelineCacheCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PipelineCacheCreateInfoCSlice(arp *AutoReleasePool, x ...PipelineCacheCreateInfo) []PipelineCacheCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineCacheCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PipelineCacheCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PipelineCacheCreateInfoFreeCSlice releases the memory allocated by PipelineCacheCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineCacheCreateInfoFreeCSlice(x []PipelineCacheCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineCacheCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineCacheCreateInfoFreeCSlice must be called on the returned slice.
func PipelineCacheCreateInfoMakeCSlice(x ...PipelineCacheCreateInfo) []PipelineCacheCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineCacheCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineCacheCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineCacheCreateInfo
func (x PipelineCacheCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PipelineCacheCreateInfo with the value of
// SType to the value provided in the specification.
func (x PipelineCacheCreateInfo) WithDefaultSType() PipelineCacheCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PipelineCacheCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO)
}

// WithSType clones a new PipelineCacheCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheCreateInfo) WithSType(y StructureType) PipelineCacheCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PipelineCacheCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPipelineCacheCreateInfo
func (x PipelineCacheCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PipelineCacheCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheCreateInfo) WithPNext(y unsafe.Pointer) PipelineCacheCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PipelineCacheCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkPipelineCacheCreateInfo
func (x PipelineCacheCreateInfo) Flags() PipelineCacheCreateFlags {
	ptr := /* typedef */ (*PipelineCacheCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new PipelineCacheCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheCreateInfo) WithFlags(y PipelineCacheCreateFlags) PipelineCacheCreateInfo {
	x.flags = *( /* typedef */ (*C.VkPipelineCacheCreateFlags)(&y))
	return x
}
func (x *PipelineCacheCreateInfo) SetFlags(y PipelineCacheCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkPipelineCacheCreateFlags)(&y))
}

// InitialDataSize returns the value of initialDataSize from VkPipelineCacheCreateInfo
func (x PipelineCacheCreateInfo) InitialDataSize() uint64 {
	ptr := func(x *C.size_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.initialDataSize)
	return *ptr
}

// WithInitialDataSize clones a new PipelineCacheCreateInfo with the value of
// InitialDataSize updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheCreateInfo) WithInitialDataSize(y uint64) PipelineCacheCreateInfo {
	x.initialDataSize = *(func(x *uint64) *C.size_t { /* Scalar */ g2c := C.size_t(*x); return &g2c }(&y))
	return x
}
func (x *PipelineCacheCreateInfo) SetInitialDataSize(y uint64) {
	x.initialDataSize = *(func(x *uint64) *C.size_t { /* Scalar */ g2c := C.size_t(*x); return &g2c }(&y))
}

// PInitialData returns the value of pInitialData from VkPipelineCacheCreateInfo
func (x PipelineCacheCreateInfo) PInitialData() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pInitialData)
	return *ptr
}

// WithPInitialData clones a new PipelineCacheCreateInfo with the value of
// PInitialData updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheCreateInfo) WithPInitialData(y unsafe.Pointer) PipelineCacheCreateInfo {
	x.pInitialData = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PipelineCacheCreateInfo) SetPInitialData(y unsafe.Pointer) {
	x.pInitialData = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// BaseOutStructure provides a go interface for VkBaseOutStructure.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBaseOutStructure.html
type BaseOutStructure C.struct_VkBaseOutStructure

// SizeofBaseOutStructure is the memory size of a BaseOutStructure
var SizeofBaseOutStructure int = int(unsafe.Sizeof(BaseOutStructure{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x BaseOutStructure) ArpPtr(arp *AutoReleasePool) *BaseOutStructure {
	ptr := newCBlock(cULong(SizeofBaseOutStructure))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*BaseOutStructure)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BaseOutStructure) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BaseOutStructure) AsCPtr() *BaseOutStructure {
	clone := (*BaseOutStructure)(newCBlock(cULong(SizeofBaseOutStructure)))
	*clone = x
	return clone
}

// BaseOutStructureCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func BaseOutStructureCSlice(arp *AutoReleasePool, x ...BaseOutStructure) []BaseOutStructure {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBaseOutStructure * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*BaseOutStructure)(ptr), len(x))
	copy(dst, x)
	return dst
}

// BaseOutStructureFreeCSlice releases the memory allocated by BaseOutStructureMakeCSlice.
// It does not free pointers stored inside the slice.
func BaseOutStructureFreeCSlice(x []BaseOutStructure) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BaseOutStructureMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BaseOutStructureFreeCSlice must be called on the returned slice.
func BaseOutStructureMakeCSlice(x ...BaseOutStructure) []BaseOutStructure {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBaseOutStructure * len(x)
	dst := unsafe.Slice((*BaseOutStructure)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBaseOutStructure
func (x BaseOutStructure) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithSType clones a new BaseOutStructure with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BaseOutStructure) WithSType(y StructureType) BaseOutStructure {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *BaseOutStructure) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkBaseOutStructure
func (x BaseOutStructure) PNext() *BaseOutStructure {
	ptr := func(x **C.struct_VkBaseOutStructure) **BaseOutStructure { /* Pointer */
		c2g := (*BaseOutStructure)(*x)
		return &c2g
	}(&x.pNext)
	return *ptr
}

// WithPNext clones a new BaseOutStructure with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BaseOutStructure) WithPNext(y *BaseOutStructure) BaseOutStructure {
	x.pNext = *(func(x **BaseOutStructure) **C.struct_VkBaseOutStructure { /* Pointer */
		g2c := (*C.struct_VkBaseOutStructure)(*x)
		return &g2c
	}(&y))
	return x
}
func (x *BaseOutStructure) SetPNext(y *BaseOutStructure) {
	x.pNext = *(func(x **BaseOutStructure) **C.struct_VkBaseOutStructure { /* Pointer */
		g2c := (*C.struct_VkBaseOutStructure)(*x)
		return &g2c
	}(&y))
}

// DescriptorImageInfo provides a go interface for VkDescriptorImageInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorImageInfo.html
type DescriptorImageInfo C.struct_VkDescriptorImageInfo

// SizeofDescriptorImageInfo is the memory size of a DescriptorImageInfo
var SizeofDescriptorImageInfo int = int(unsafe.Sizeof(DescriptorImageInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DescriptorImageInfo) ArpPtr(arp *AutoReleasePool) *DescriptorImageInfo {
	ptr := newCBlock(cULong(SizeofDescriptorImageInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DescriptorImageInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorImageInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorImageInfo) AsCPtr() *DescriptorImageInfo {
	clone := (*DescriptorImageInfo)(newCBlock(cULong(SizeofDescriptorImageInfo)))
	*clone = x
	return clone
}

// DescriptorImageInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DescriptorImageInfoCSlice(arp *AutoReleasePool, x ...DescriptorImageInfo) []DescriptorImageInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorImageInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DescriptorImageInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DescriptorImageInfoFreeCSlice releases the memory allocated by DescriptorImageInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorImageInfoFreeCSlice(x []DescriptorImageInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorImageInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorImageInfoFreeCSlice must be called on the returned slice.
func DescriptorImageInfoMakeCSlice(x ...DescriptorImageInfo) []DescriptorImageInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorImageInfo * len(x)
	dst := unsafe.Slice((*DescriptorImageInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Sampler returns the value of sampler from VkDescriptorImageInfo
func (x DescriptorImageInfo) Sampler() Sampler {
	ptr := /* handle */ (*Sampler)(&x.sampler)
	return *ptr
}

// WithSampler clones a new DescriptorImageInfo with the value of
// Sampler updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorImageInfo) WithSampler(y Sampler) DescriptorImageInfo {
	x.sampler = *( /* handle */ (*C.VkSampler)(&y))
	return x
}
func (x *DescriptorImageInfo) SetSampler(y Sampler) {
	x.sampler = *( /* handle */ (*C.VkSampler)(&y))
}

// ImageView returns the value of imageView from VkDescriptorImageInfo
func (x DescriptorImageInfo) ImageView() ImageView {
	ptr := /* handle */ (*ImageView)(&x.imageView)
	return *ptr
}

// WithImageView clones a new DescriptorImageInfo with the value of
// ImageView updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorImageInfo) WithImageView(y ImageView) DescriptorImageInfo {
	x.imageView = *( /* handle */ (*C.VkImageView)(&y))
	return x
}
func (x *DescriptorImageInfo) SetImageView(y ImageView) {
	x.imageView = *( /* handle */ (*C.VkImageView)(&y))
}

// ImageLayout returns the value of imageLayout from VkDescriptorImageInfo
func (x DescriptorImageInfo) ImageLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.imageLayout)
	return *ptr
}

// WithImageLayout clones a new DescriptorImageInfo with the value of
// ImageLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorImageInfo) WithImageLayout(y ImageLayout) DescriptorImageInfo {
	x.imageLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
	return x
}
func (x *DescriptorImageInfo) SetImageLayout(y ImageLayout) {
	x.imageLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
}

// WriteDescriptorSet provides a go interface for VkWriteDescriptorSet.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWriteDescriptorSet.html
type WriteDescriptorSet C.struct_VkWriteDescriptorSet

// SizeofWriteDescriptorSet is the memory size of a WriteDescriptorSet
var SizeofWriteDescriptorSet int = int(unsafe.Sizeof(WriteDescriptorSet{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x WriteDescriptorSet) ArpPtr(arp *AutoReleasePool) *WriteDescriptorSet {
	ptr := newCBlock(cULong(SizeofWriteDescriptorSet))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*WriteDescriptorSet)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *WriteDescriptorSet) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x WriteDescriptorSet) AsCPtr() *WriteDescriptorSet {
	clone := (*WriteDescriptorSet)(newCBlock(cULong(SizeofWriteDescriptorSet)))
	*clone = x
	return clone
}

// WriteDescriptorSetCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func WriteDescriptorSetCSlice(arp *AutoReleasePool, x ...WriteDescriptorSet) []WriteDescriptorSet {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofWriteDescriptorSet * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*WriteDescriptorSet)(ptr), len(x))
	copy(dst, x)
	return dst
}

// WriteDescriptorSetFreeCSlice releases the memory allocated by WriteDescriptorSetMakeCSlice.
// It does not free pointers stored inside the slice.
func WriteDescriptorSetFreeCSlice(x []WriteDescriptorSet) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// WriteDescriptorSetMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. WriteDescriptorSetFreeCSlice must be called on the returned slice.
func WriteDescriptorSetMakeCSlice(x ...WriteDescriptorSet) []WriteDescriptorSet {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofWriteDescriptorSet * len(x)
	dst := unsafe.Slice((*WriteDescriptorSet)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkWriteDescriptorSet
func (x WriteDescriptorSet) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new WriteDescriptorSet with the value of
// SType to the value provided in the specification.
func (x WriteDescriptorSet) WithDefaultSType() WriteDescriptorSet {
	return x.WithSType(VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *WriteDescriptorSet) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET)
}

// WithSType clones a new WriteDescriptorSet with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSet) WithSType(y StructureType) WriteDescriptorSet {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *WriteDescriptorSet) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkWriteDescriptorSet
func (x WriteDescriptorSet) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new WriteDescriptorSet with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSet) WithPNext(y unsafe.Pointer) WriteDescriptorSet {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *WriteDescriptorSet) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// DstSet returns the value of dstSet from VkWriteDescriptorSet
func (x WriteDescriptorSet) DstSet() DescriptorSet {
	ptr := /* handle */ (*DescriptorSet)(&x.dstSet)
	return *ptr
}

// WithDstSet clones a new WriteDescriptorSet with the value of
// DstSet updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSet) WithDstSet(y DescriptorSet) WriteDescriptorSet {
	x.dstSet = *( /* handle */ (*C.VkDescriptorSet)(&y))
	return x
}
func (x *WriteDescriptorSet) SetDstSet(y DescriptorSet) {
	x.dstSet = *( /* handle */ (*C.VkDescriptorSet)(&y))
}

// DstBinding returns the value of dstBinding from VkWriteDescriptorSet
func (x WriteDescriptorSet) DstBinding() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dstBinding)
	return *ptr
}

// WithDstBinding clones a new WriteDescriptorSet with the value of
// DstBinding updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSet) WithDstBinding(y uint32) WriteDescriptorSet {
	x.dstBinding = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *WriteDescriptorSet) SetDstBinding(y uint32) {
	x.dstBinding = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// DstArrayElement returns the value of dstArrayElement from VkWriteDescriptorSet
func (x WriteDescriptorSet) DstArrayElement() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dstArrayElement)
	return *ptr
}

// WithDstArrayElement clones a new WriteDescriptorSet with the value of
// DstArrayElement updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSet) WithDstArrayElement(y uint32) WriteDescriptorSet {
	x.dstArrayElement = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *WriteDescriptorSet) SetDstArrayElement(y uint32) {
	x.dstArrayElement = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// DescriptorCount returns the value of descriptorCount from VkWriteDescriptorSet
func (x WriteDescriptorSet) DescriptorCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.descriptorCount)
	return *ptr
}

// WithDescriptorCount clones a new WriteDescriptorSet with the value of
// DescriptorCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSet) WithDescriptorCount(y uint32) WriteDescriptorSet {
	x.descriptorCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *WriteDescriptorSet) SetDescriptorCount(y uint32) {
	x.descriptorCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// DescriptorType returns the value of descriptorType from VkWriteDescriptorSet
func (x WriteDescriptorSet) DescriptorType() DescriptorType {
	ptr := /* typedef */ (*DescriptorType)(&x.descriptorType)
	return *ptr
}

// WithDescriptorType clones a new WriteDescriptorSet with the value of
// DescriptorType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSet) WithDescriptorType(y DescriptorType) WriteDescriptorSet {
	x.descriptorType = *( /* typedef */ (*C.VkDescriptorType)(&y))
	return x
}
func (x *WriteDescriptorSet) SetDescriptorType(y DescriptorType) {
	x.descriptorType = *( /* typedef */ (*C.VkDescriptorType)(&y))
}

// PImageInfo returns the value of pImageInfo from VkWriteDescriptorSet
func (x WriteDescriptorSet) PImageInfo() []DescriptorImageInfo {
	ptr := func(x **C.struct_VkDescriptorImageInfo) *[]DescriptorImageInfo { /* Slice */
		slc := unsafe.Slice((*DescriptorImageInfo)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pImageInfo)
	return *ptr
}

// WithPImageInfo clones a new WriteDescriptorSet with the value of
// PImageInfo updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DescriptorCount as the length of this field.
// DescriptorCount is updated with the length of the new value.
func (x WriteDescriptorSet) WithPImageInfo(y []DescriptorImageInfo) WriteDescriptorSet {
	x.pImageInfo = *(func(x *[]DescriptorImageInfo) **C.struct_VkDescriptorImageInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDescriptorImageInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDescriptorImageInfo)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithDescriptorCount(uint32(len(y)))
}
func (x *WriteDescriptorSet) SetPImageInfo(y []DescriptorImageInfo) {
	x.pImageInfo = *(func(x *[]DescriptorImageInfo) **C.struct_VkDescriptorImageInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDescriptorImageInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDescriptorImageInfo)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetDescriptorCount(uint32(len(y)))
}

// PBufferInfo returns the value of pBufferInfo from VkWriteDescriptorSet
func (x WriteDescriptorSet) PBufferInfo() []DescriptorBufferInfo {
	ptr := func(x **C.struct_VkDescriptorBufferInfo) *[]DescriptorBufferInfo { /* Slice */
		slc := unsafe.Slice((*DescriptorBufferInfo)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pBufferInfo)
	return *ptr
}

// WithPBufferInfo clones a new WriteDescriptorSet with the value of
// PBufferInfo updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DescriptorCount as the length of this field.
// DescriptorCount is updated with the length of the new value.
func (x WriteDescriptorSet) WithPBufferInfo(y []DescriptorBufferInfo) WriteDescriptorSet {
	x.pBufferInfo = *(func(x *[]DescriptorBufferInfo) **C.struct_VkDescriptorBufferInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDescriptorBufferInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDescriptorBufferInfo)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithDescriptorCount(uint32(len(y)))
}
func (x *WriteDescriptorSet) SetPBufferInfo(y []DescriptorBufferInfo) {
	x.pBufferInfo = *(func(x *[]DescriptorBufferInfo) **C.struct_VkDescriptorBufferInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDescriptorBufferInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDescriptorBufferInfo)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetDescriptorCount(uint32(len(y)))
}

// PTexelBufferView returns the value of pTexelBufferView from VkWriteDescriptorSet
func (x WriteDescriptorSet) PTexelBufferView() []BufferView {
	ptr := func(x **C.VkBufferView) *[]BufferView { /* Slice */
		slc := unsafe.Slice((*BufferView)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pTexelBufferView)
	return *ptr
}

// WithPTexelBufferView clones a new WriteDescriptorSet with the value of
// PTexelBufferView updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DescriptorCount as the length of this field.
// DescriptorCount is updated with the length of the new value.
func (x WriteDescriptorSet) WithPTexelBufferView(y []BufferView) WriteDescriptorSet {
	x.pTexelBufferView = *(func(x *[]BufferView) **C.VkBufferView { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkBufferView)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkBufferView)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithDescriptorCount(uint32(len(y)))
}
func (x *WriteDescriptorSet) SetPTexelBufferView(y []BufferView) {
	x.pTexelBufferView = *(func(x *[]BufferView) **C.VkBufferView { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkBufferView)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkBufferView)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetDescriptorCount(uint32(len(y)))
}

// BufferMemoryBarrier provides a go interface for VkBufferMemoryBarrier.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferMemoryBarrier.html
type BufferMemoryBarrier C.struct_VkBufferMemoryBarrier

// SizeofBufferMemoryBarrier is the memory size of a BufferMemoryBarrier
var SizeofBufferMemoryBarrier int = int(unsafe.Sizeof(BufferMemoryBarrier{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x BufferMemoryBarrier) ArpPtr(arp *AutoReleasePool) *BufferMemoryBarrier {
	ptr := newCBlock(cULong(SizeofBufferMemoryBarrier))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*BufferMemoryBarrier)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferMemoryBarrier) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferMemoryBarrier) AsCPtr() *BufferMemoryBarrier {
	clone := (*BufferMemoryBarrier)(newCBlock(cULong(SizeofBufferMemoryBarrier)))
	*clone = x
	return clone
}

// BufferMemoryBarrierCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func BufferMemoryBarrierCSlice(arp *AutoReleasePool, x ...BufferMemoryBarrier) []BufferMemoryBarrier {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferMemoryBarrier * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*BufferMemoryBarrier)(ptr), len(x))
	copy(dst, x)
	return dst
}

// BufferMemoryBarrierFreeCSlice releases the memory allocated by BufferMemoryBarrierMakeCSlice.
// It does not free pointers stored inside the slice.
func BufferMemoryBarrierFreeCSlice(x []BufferMemoryBarrier) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferMemoryBarrierMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferMemoryBarrierFreeCSlice must be called on the returned slice.
func BufferMemoryBarrierMakeCSlice(x ...BufferMemoryBarrier) []BufferMemoryBarrier {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferMemoryBarrier * len(x)
	dst := unsafe.Slice((*BufferMemoryBarrier)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBufferMemoryBarrier
func (x BufferMemoryBarrier) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new BufferMemoryBarrier with the value of
// SType to the value provided in the specification.
func (x BufferMemoryBarrier) WithDefaultSType() BufferMemoryBarrier {
	return x.WithSType(VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *BufferMemoryBarrier) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER)
}

// WithSType clones a new BufferMemoryBarrier with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier) WithSType(y StructureType) BufferMemoryBarrier {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *BufferMemoryBarrier) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkBufferMemoryBarrier
func (x BufferMemoryBarrier) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new BufferMemoryBarrier with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier) WithPNext(y unsafe.Pointer) BufferMemoryBarrier {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *BufferMemoryBarrier) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SrcAccessMask returns the value of srcAccessMask from VkBufferMemoryBarrier
func (x BufferMemoryBarrier) SrcAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.srcAccessMask)
	return *ptr
}

// WithSrcAccessMask clones a new BufferMemoryBarrier with the value of
// SrcAccessMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier) WithSrcAccessMask(y AccessFlags) BufferMemoryBarrier {
	x.srcAccessMask = *( /* typedef */ (*C.VkAccessFlags)(&y))
	return x
}
func (x *BufferMemoryBarrier) SetSrcAccessMask(y AccessFlags) {
	x.srcAccessMask = *( /* typedef */ (*C.VkAccessFlags)(&y))
}

// DstAccessMask returns the value of dstAccessMask from VkBufferMemoryBarrier
func (x BufferMemoryBarrier) DstAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.dstAccessMask)
	return *ptr
}

// WithDstAccessMask clones a new BufferMemoryBarrier with the value of
// DstAccessMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier) WithDstAccessMask(y AccessFlags) BufferMemoryBarrier {
	x.dstAccessMask = *( /* typedef */ (*C.VkAccessFlags)(&y))
	return x
}
func (x *BufferMemoryBarrier) SetDstAccessMask(y AccessFlags) {
	x.dstAccessMask = *( /* typedef */ (*C.VkAccessFlags)(&y))
}

// SrcQueueFamilyIndex returns the value of srcQueueFamilyIndex from VkBufferMemoryBarrier
func (x BufferMemoryBarrier) SrcQueueFamilyIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.srcQueueFamilyIndex)
	return *ptr
}

// WithSrcQueueFamilyIndex clones a new BufferMemoryBarrier with the value of
// SrcQueueFamilyIndex updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier) WithSrcQueueFamilyIndex(y uint32) BufferMemoryBarrier {
	x.srcQueueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *BufferMemoryBarrier) SetSrcQueueFamilyIndex(y uint32) {
	x.srcQueueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// DstQueueFamilyIndex returns the value of dstQueueFamilyIndex from VkBufferMemoryBarrier
func (x BufferMemoryBarrier) DstQueueFamilyIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dstQueueFamilyIndex)
	return *ptr
}

// WithDstQueueFamilyIndex clones a new BufferMemoryBarrier with the value of
// DstQueueFamilyIndex updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier) WithDstQueueFamilyIndex(y uint32) BufferMemoryBarrier {
	x.dstQueueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *BufferMemoryBarrier) SetDstQueueFamilyIndex(y uint32) {
	x.dstQueueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// Buffer returns the value of buffer from VkBufferMemoryBarrier
func (x BufferMemoryBarrier) Buffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.buffer)
	return *ptr
}

// WithBuffer clones a new BufferMemoryBarrier with the value of
// Buffer updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier) WithBuffer(y Buffer) BufferMemoryBarrier {
	x.buffer = *( /* handle */ (*C.VkBuffer)(&y))
	return x
}
func (x *BufferMemoryBarrier) SetBuffer(y Buffer) {
	x.buffer = *( /* handle */ (*C.VkBuffer)(&y))
}

// Offset returns the value of offset from VkBufferMemoryBarrier
func (x BufferMemoryBarrier) Offset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.offset)
	return *ptr
}

// WithOffset clones a new BufferMemoryBarrier with the value of
// Offset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier) WithOffset(y DeviceSize) BufferMemoryBarrier {
	x.offset = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *BufferMemoryBarrier) SetOffset(y DeviceSize) {
	x.offset = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// Size returns the value of size from VkBufferMemoryBarrier
func (x BufferMemoryBarrier) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size)
	return *ptr
}

// WithSize clones a new BufferMemoryBarrier with the value of
// Size updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier) WithSize(y DeviceSize) BufferMemoryBarrier {
	x.size = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *BufferMemoryBarrier) SetSize(y DeviceSize) {
	x.size = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// ImageFormatProperties provides a go interface for VkImageFormatProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageFormatProperties.html
type ImageFormatProperties C.struct_VkImageFormatProperties

// SizeofImageFormatProperties is the memory size of a ImageFormatProperties
var SizeofImageFormatProperties int = int(unsafe.Sizeof(ImageFormatProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ImageFormatProperties) ArpPtr(arp *AutoReleasePool) *ImageFormatProperties {
	ptr := newCBlock(cULong(SizeofImageFormatProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ImageFormatProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageFormatProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageFormatProperties) AsCPtr() *ImageFormatProperties {
	clone := (*ImageFormatProperties)(newCBlock(cULong(SizeofImageFormatProperties)))
	*clone = x
	return clone
}

// ImageFormatPropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ImageFormatPropertiesCSlice(arp *AutoReleasePool, x ...ImageFormatProperties) []ImageFormatProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageFormatProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ImageFormatProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ImageFormatPropertiesFreeCSlice releases the memory allocated by ImageFormatPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageFormatPropertiesFreeCSlice(x []ImageFormatProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageFormatPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageFormatPropertiesFreeCSlice must be called on the returned slice.
func ImageFormatPropertiesMakeCSlice(x ...ImageFormatProperties) []ImageFormatProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageFormatProperties * len(x)
	dst := unsafe.Slice((*ImageFormatProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// MaxExtent returns the value of maxExtent from VkImageFormatProperties
func (x ImageFormatProperties) MaxExtent() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.maxExtent)
	return *ptr
}

// MaxMipLevels returns the value of maxMipLevels from VkImageFormatProperties
func (x ImageFormatProperties) MaxMipLevels() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxMipLevels)
	return *ptr
}

// MaxArrayLayers returns the value of maxArrayLayers from VkImageFormatProperties
func (x ImageFormatProperties) MaxArrayLayers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxArrayLayers)
	return *ptr
}

// SampleCounts returns the value of sampleCounts from VkImageFormatProperties
func (x ImageFormatProperties) SampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.sampleCounts)
	return *ptr
}

// MaxResourceSize returns the value of maxResourceSize from VkImageFormatProperties
func (x ImageFormatProperties) MaxResourceSize() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.maxResourceSize)
	return *ptr
}

// DescriptorSetLayoutBinding provides a go interface for VkDescriptorSetLayoutBinding.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutBinding.html
type DescriptorSetLayoutBinding C.struct_VkDescriptorSetLayoutBinding

// SizeofDescriptorSetLayoutBinding is the memory size of a DescriptorSetLayoutBinding
var SizeofDescriptorSetLayoutBinding int = int(unsafe.Sizeof(DescriptorSetLayoutBinding{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DescriptorSetLayoutBinding) ArpPtr(arp *AutoReleasePool) *DescriptorSetLayoutBinding {
	ptr := newCBlock(cULong(SizeofDescriptorSetLayoutBinding))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DescriptorSetLayoutBinding)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorSetLayoutBinding) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorSetLayoutBinding) AsCPtr() *DescriptorSetLayoutBinding {
	clone := (*DescriptorSetLayoutBinding)(newCBlock(cULong(SizeofDescriptorSetLayoutBinding)))
	*clone = x
	return clone
}

// DescriptorSetLayoutBindingCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DescriptorSetLayoutBindingCSlice(arp *AutoReleasePool, x ...DescriptorSetLayoutBinding) []DescriptorSetLayoutBinding {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetLayoutBinding * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DescriptorSetLayoutBinding)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DescriptorSetLayoutBindingFreeCSlice releases the memory allocated by DescriptorSetLayoutBindingMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorSetLayoutBindingFreeCSlice(x []DescriptorSetLayoutBinding) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorSetLayoutBindingMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorSetLayoutBindingFreeCSlice must be called on the returned slice.
func DescriptorSetLayoutBindingMakeCSlice(x ...DescriptorSetLayoutBinding) []DescriptorSetLayoutBinding {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetLayoutBinding * len(x)
	dst := unsafe.Slice((*DescriptorSetLayoutBinding)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Binding returns the value of binding from VkDescriptorSetLayoutBinding
func (x DescriptorSetLayoutBinding) Binding() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.binding)
	return *ptr
}

// WithBinding clones a new DescriptorSetLayoutBinding with the value of
// Binding updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutBinding) WithBinding(y uint32) DescriptorSetLayoutBinding {
	x.binding = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DescriptorSetLayoutBinding) SetBinding(y uint32) {
	x.binding = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// DescriptorType returns the value of descriptorType from VkDescriptorSetLayoutBinding
func (x DescriptorSetLayoutBinding) DescriptorType() DescriptorType {
	ptr := /* typedef */ (*DescriptorType)(&x.descriptorType)
	return *ptr
}

// WithDescriptorType clones a new DescriptorSetLayoutBinding with the value of
// DescriptorType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutBinding) WithDescriptorType(y DescriptorType) DescriptorSetLayoutBinding {
	x.descriptorType = *( /* typedef */ (*C.VkDescriptorType)(&y))
	return x
}
func (x *DescriptorSetLayoutBinding) SetDescriptorType(y DescriptorType) {
	x.descriptorType = *( /* typedef */ (*C.VkDescriptorType)(&y))
}

// DescriptorCount returns the value of descriptorCount from VkDescriptorSetLayoutBinding
func (x DescriptorSetLayoutBinding) DescriptorCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.descriptorCount)
	return *ptr
}

// WithDescriptorCount clones a new DescriptorSetLayoutBinding with the value of
// DescriptorCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutBinding) WithDescriptorCount(y uint32) DescriptorSetLayoutBinding {
	x.descriptorCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DescriptorSetLayoutBinding) SetDescriptorCount(y uint32) {
	x.descriptorCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// StageFlags returns the value of stageFlags from VkDescriptorSetLayoutBinding
func (x DescriptorSetLayoutBinding) StageFlags() ShaderStageFlags {
	ptr := /* typedef */ (*ShaderStageFlags)(&x.stageFlags)
	return *ptr
}

// WithStageFlags clones a new DescriptorSetLayoutBinding with the value of
// StageFlags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutBinding) WithStageFlags(y ShaderStageFlags) DescriptorSetLayoutBinding {
	x.stageFlags = *( /* typedef */ (*C.VkShaderStageFlags)(&y))
	return x
}
func (x *DescriptorSetLayoutBinding) SetStageFlags(y ShaderStageFlags) {
	x.stageFlags = *( /* typedef */ (*C.VkShaderStageFlags)(&y))
}

// PImmutableSamplers returns the value of pImmutableSamplers from VkDescriptorSetLayoutBinding
func (x DescriptorSetLayoutBinding) PImmutableSamplers() []Sampler {
	ptr := func(x **C.VkSampler) *[]Sampler { /* Slice */
		slc := unsafe.Slice((*Sampler)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pImmutableSamplers)
	return *ptr
}

// WithPImmutableSamplers clones a new DescriptorSetLayoutBinding with the value of
// PImmutableSamplers updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DescriptorCount as the length of this field.
// DescriptorCount is updated with the length of the new value.
func (x DescriptorSetLayoutBinding) WithPImmutableSamplers(y []Sampler) DescriptorSetLayoutBinding {
	x.pImmutableSamplers = *(func(x *[]Sampler) **C.VkSampler { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSampler)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSampler)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithDescriptorCount(uint32(len(y)))
}
func (x *DescriptorSetLayoutBinding) SetPImmutableSamplers(y []Sampler) {
	x.pImmutableSamplers = *(func(x *[]Sampler) **C.VkSampler { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSampler)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSampler)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetDescriptorCount(uint32(len(y)))
}

// DescriptorSetLayoutCreateInfo provides a go interface for VkDescriptorSetLayoutCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutCreateInfo.html
type DescriptorSetLayoutCreateInfo C.struct_VkDescriptorSetLayoutCreateInfo

// SizeofDescriptorSetLayoutCreateInfo is the memory size of a DescriptorSetLayoutCreateInfo
var SizeofDescriptorSetLayoutCreateInfo int = int(unsafe.Sizeof(DescriptorSetLayoutCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DescriptorSetLayoutCreateInfo) ArpPtr(arp *AutoReleasePool) *DescriptorSetLayoutCreateInfo {
	ptr := newCBlock(cULong(SizeofDescriptorSetLayoutCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DescriptorSetLayoutCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorSetLayoutCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorSetLayoutCreateInfo) AsCPtr() *DescriptorSetLayoutCreateInfo {
	clone := (*DescriptorSetLayoutCreateInfo)(newCBlock(cULong(SizeofDescriptorSetLayoutCreateInfo)))
	*clone = x
	return clone
}

// DescriptorSetLayoutCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DescriptorSetLayoutCreateInfoCSlice(arp *AutoReleasePool, x ...DescriptorSetLayoutCreateInfo) []DescriptorSetLayoutCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetLayoutCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DescriptorSetLayoutCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DescriptorSetLayoutCreateInfoFreeCSlice releases the memory allocated by DescriptorSetLayoutCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorSetLayoutCreateInfoFreeCSlice(x []DescriptorSetLayoutCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorSetLayoutCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorSetLayoutCreateInfoFreeCSlice must be called on the returned slice.
func DescriptorSetLayoutCreateInfoMakeCSlice(x ...DescriptorSetLayoutCreateInfo) []DescriptorSetLayoutCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetLayoutCreateInfo * len(x)
	dst := unsafe.Slice((*DescriptorSetLayoutCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDescriptorSetLayoutCreateInfo
func (x DescriptorSetLayoutCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DescriptorSetLayoutCreateInfo with the value of
// SType to the value provided in the specification.
func (x DescriptorSetLayoutCreateInfo) WithDefaultSType() DescriptorSetLayoutCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DescriptorSetLayoutCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO)
}

// WithSType clones a new DescriptorSetLayoutCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutCreateInfo) WithSType(y StructureType) DescriptorSetLayoutCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DescriptorSetLayoutCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDescriptorSetLayoutCreateInfo
func (x DescriptorSetLayoutCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DescriptorSetLayoutCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutCreateInfo) WithPNext(y unsafe.Pointer) DescriptorSetLayoutCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DescriptorSetLayoutCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkDescriptorSetLayoutCreateInfo
func (x DescriptorSetLayoutCreateInfo) Flags() DescriptorSetLayoutCreateFlags {
	ptr := /* typedef */ (*DescriptorSetLayoutCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new DescriptorSetLayoutCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutCreateInfo) WithFlags(y DescriptorSetLayoutCreateFlags) DescriptorSetLayoutCreateInfo {
	x.flags = *( /* typedef */ (*C.VkDescriptorSetLayoutCreateFlags)(&y))
	return x
}
func (x *DescriptorSetLayoutCreateInfo) SetFlags(y DescriptorSetLayoutCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkDescriptorSetLayoutCreateFlags)(&y))
}

// BindingCount returns the value of bindingCount from VkDescriptorSetLayoutCreateInfo
func (x DescriptorSetLayoutCreateInfo) BindingCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.bindingCount)
	return *ptr
}

// WithBindingCount clones a new DescriptorSetLayoutCreateInfo with the value of
// BindingCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutCreateInfo) WithBindingCount(y uint32) DescriptorSetLayoutCreateInfo {
	x.bindingCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DescriptorSetLayoutCreateInfo) SetBindingCount(y uint32) {
	x.bindingCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PBindings returns the value of pBindings from VkDescriptorSetLayoutCreateInfo
func (x DescriptorSetLayoutCreateInfo) PBindings() []DescriptorSetLayoutBinding {
	ptr := func(x **C.struct_VkDescriptorSetLayoutBinding) *[]DescriptorSetLayoutBinding { /* Slice */
		slc := unsafe.Slice((*DescriptorSetLayoutBinding)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pBindings)
	return *ptr
}

// WithPBindings clones a new DescriptorSetLayoutCreateInfo with the value of
// PBindings updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines BindingCount as the length of this field.
// BindingCount is updated with the length of the new value.
func (x DescriptorSetLayoutCreateInfo) WithPBindings(y []DescriptorSetLayoutBinding) DescriptorSetLayoutCreateInfo {
	x.pBindings = *(func(x *[]DescriptorSetLayoutBinding) **C.struct_VkDescriptorSetLayoutBinding { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDescriptorSetLayoutBinding)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDescriptorSetLayoutBinding)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithBindingCount(uint32(len(y)))
}
func (x *DescriptorSetLayoutCreateInfo) SetPBindings(y []DescriptorSetLayoutBinding) {
	x.pBindings = *(func(x *[]DescriptorSetLayoutBinding) **C.struct_VkDescriptorSetLayoutBinding { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDescriptorSetLayoutBinding)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDescriptorSetLayoutBinding)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetBindingCount(uint32(len(y)))
}

// FormatProperties provides a go interface for VkFormatProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatProperties.html
type FormatProperties C.struct_VkFormatProperties

// SizeofFormatProperties is the memory size of a FormatProperties
var SizeofFormatProperties int = int(unsafe.Sizeof(FormatProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x FormatProperties) ArpPtr(arp *AutoReleasePool) *FormatProperties {
	ptr := newCBlock(cULong(SizeofFormatProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*FormatProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *FormatProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x FormatProperties) AsCPtr() *FormatProperties {
	clone := (*FormatProperties)(newCBlock(cULong(SizeofFormatProperties)))
	*clone = x
	return clone
}

// FormatPropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func FormatPropertiesCSlice(arp *AutoReleasePool, x ...FormatProperties) []FormatProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFormatProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*FormatProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// FormatPropertiesFreeCSlice releases the memory allocated by FormatPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func FormatPropertiesFreeCSlice(x []FormatProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// FormatPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. FormatPropertiesFreeCSlice must be called on the returned slice.
func FormatPropertiesMakeCSlice(x ...FormatProperties) []FormatProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFormatProperties * len(x)
	dst := unsafe.Slice((*FormatProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// LinearTilingFeatures returns the value of linearTilingFeatures from VkFormatProperties
func (x FormatProperties) LinearTilingFeatures() FormatFeatureFlags {
	ptr := /* typedef */ (*FormatFeatureFlags)(&x.linearTilingFeatures)
	return *ptr
}

// OptimalTilingFeatures returns the value of optimalTilingFeatures from VkFormatProperties
func (x FormatProperties) OptimalTilingFeatures() FormatFeatureFlags {
	ptr := /* typedef */ (*FormatFeatureFlags)(&x.optimalTilingFeatures)
	return *ptr
}

// BufferFeatures returns the value of bufferFeatures from VkFormatProperties
func (x FormatProperties) BufferFeatures() FormatFeatureFlags {
	ptr := /* typedef */ (*FormatFeatureFlags)(&x.bufferFeatures)
	return *ptr
}

// MemoryAllocateInfo provides a go interface for VkMemoryAllocateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryAllocateInfo.html
type MemoryAllocateInfo C.struct_VkMemoryAllocateInfo

// SizeofMemoryAllocateInfo is the memory size of a MemoryAllocateInfo
var SizeofMemoryAllocateInfo int = int(unsafe.Sizeof(MemoryAllocateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x MemoryAllocateInfo) ArpPtr(arp *AutoReleasePool) *MemoryAllocateInfo {
	ptr := newCBlock(cULong(SizeofMemoryAllocateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*MemoryAllocateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryAllocateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryAllocateInfo) AsCPtr() *MemoryAllocateInfo {
	clone := (*MemoryAllocateInfo)(newCBlock(cULong(SizeofMemoryAllocateInfo)))
	*clone = x
	return clone
}

// MemoryAllocateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func MemoryAllocateInfoCSlice(arp *AutoReleasePool, x ...MemoryAllocateInfo) []MemoryAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryAllocateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*MemoryAllocateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// MemoryAllocateInfoFreeCSlice releases the memory allocated by MemoryAllocateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryAllocateInfoFreeCSlice(x []MemoryAllocateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryAllocateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryAllocateInfoFreeCSlice must be called on the returned slice.
func MemoryAllocateInfoMakeCSlice(x ...MemoryAllocateInfo) []MemoryAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryAllocateInfo * len(x)
	dst := unsafe.Slice((*MemoryAllocateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkMemoryAllocateInfo
func (x MemoryAllocateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new MemoryAllocateInfo with the value of
// SType to the value provided in the specification.
func (x MemoryAllocateInfo) WithDefaultSType() MemoryAllocateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *MemoryAllocateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO)
}

// WithSType clones a new MemoryAllocateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryAllocateInfo) WithSType(y StructureType) MemoryAllocateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *MemoryAllocateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkMemoryAllocateInfo
func (x MemoryAllocateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new MemoryAllocateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryAllocateInfo) WithPNext(y unsafe.Pointer) MemoryAllocateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *MemoryAllocateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// AllocationSize returns the value of allocationSize from VkMemoryAllocateInfo
func (x MemoryAllocateInfo) AllocationSize() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.allocationSize)
	return *ptr
}

// WithAllocationSize clones a new MemoryAllocateInfo with the value of
// AllocationSize updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryAllocateInfo) WithAllocationSize(y DeviceSize) MemoryAllocateInfo {
	x.allocationSize = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *MemoryAllocateInfo) SetAllocationSize(y DeviceSize) {
	x.allocationSize = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// MemoryTypeIndex returns the value of memoryTypeIndex from VkMemoryAllocateInfo
func (x MemoryAllocateInfo) MemoryTypeIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.memoryTypeIndex)
	return *ptr
}

// WithMemoryTypeIndex clones a new MemoryAllocateInfo with the value of
// MemoryTypeIndex updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryAllocateInfo) WithMemoryTypeIndex(y uint32) MemoryAllocateInfo {
	x.memoryTypeIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *MemoryAllocateInfo) SetMemoryTypeIndex(y uint32) {
	x.memoryTypeIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// DispatchIndirectCommand provides a go interface for VkDispatchIndirectCommand.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDispatchIndirectCommand.html
type DispatchIndirectCommand C.struct_VkDispatchIndirectCommand

// SizeofDispatchIndirectCommand is the memory size of a DispatchIndirectCommand
var SizeofDispatchIndirectCommand int = int(unsafe.Sizeof(DispatchIndirectCommand{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DispatchIndirectCommand) ArpPtr(arp *AutoReleasePool) *DispatchIndirectCommand {
	ptr := newCBlock(cULong(SizeofDispatchIndirectCommand))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DispatchIndirectCommand)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DispatchIndirectCommand) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DispatchIndirectCommand) AsCPtr() *DispatchIndirectCommand {
	clone := (*DispatchIndirectCommand)(newCBlock(cULong(SizeofDispatchIndirectCommand)))
	*clone = x
	return clone
}

// DispatchIndirectCommandCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DispatchIndirectCommandCSlice(arp *AutoReleasePool, x ...DispatchIndirectCommand) []DispatchIndirectCommand {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDispatchIndirectCommand * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DispatchIndirectCommand)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DispatchIndirectCommandFreeCSlice releases the memory allocated by DispatchIndirectCommandMakeCSlice.
// It does not free pointers stored inside the slice.
func DispatchIndirectCommandFreeCSlice(x []DispatchIndirectCommand) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DispatchIndirectCommandMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DispatchIndirectCommandFreeCSlice must be called on the returned slice.
func DispatchIndirectCommandMakeCSlice(x ...DispatchIndirectCommand) []DispatchIndirectCommand {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDispatchIndirectCommand * len(x)
	dst := unsafe.Slice((*DispatchIndirectCommand)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// X returns the value of x from VkDispatchIndirectCommand
func (x DispatchIndirectCommand) X() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.x)
	return *ptr
}

// WithX clones a new DispatchIndirectCommand with the value of
// X updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DispatchIndirectCommand) WithX(y uint32) DispatchIndirectCommand {
	x.x = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DispatchIndirectCommand) SetX(y uint32) {
	x.x = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// Y returns the value of y from VkDispatchIndirectCommand
func (x DispatchIndirectCommand) Y() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.y)
	return *ptr
}

// WithY clones a new DispatchIndirectCommand with the value of
// Y updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DispatchIndirectCommand) WithY(y uint32) DispatchIndirectCommand {
	x.y = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DispatchIndirectCommand) SetY(y uint32) {
	x.y = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// Z returns the value of z from VkDispatchIndirectCommand
func (x DispatchIndirectCommand) Z() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.z)
	return *ptr
}

// WithZ clones a new DispatchIndirectCommand with the value of
// Z updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DispatchIndirectCommand) WithZ(y uint32) DispatchIndirectCommand {
	x.z = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DispatchIndirectCommand) SetZ(y uint32) {
	x.z = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PipelineShaderStageCreateInfo provides a go interface for VkPipelineShaderStageCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageCreateInfo.html
type PipelineShaderStageCreateInfo C.struct_VkPipelineShaderStageCreateInfo

// SizeofPipelineShaderStageCreateInfo is the memory size of a PipelineShaderStageCreateInfo
var SizeofPipelineShaderStageCreateInfo int = int(unsafe.Sizeof(PipelineShaderStageCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PipelineShaderStageCreateInfo) ArpPtr(arp *AutoReleasePool) *PipelineShaderStageCreateInfo {
	ptr := newCBlock(cULong(SizeofPipelineShaderStageCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PipelineShaderStageCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineShaderStageCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineShaderStageCreateInfo) AsCPtr() *PipelineShaderStageCreateInfo {
	clone := (*PipelineShaderStageCreateInfo)(newCBlock(cULong(SizeofPipelineShaderStageCreateInfo)))
	*clone = x
	return clone
}

// PipelineShaderStageCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PipelineShaderStageCreateInfoCSlice(arp *AutoReleasePool, x ...PipelineShaderStageCreateInfo) []PipelineShaderStageCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineShaderStageCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PipelineShaderStageCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PipelineShaderStageCreateInfoFreeCSlice releases the memory allocated by PipelineShaderStageCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineShaderStageCreateInfoFreeCSlice(x []PipelineShaderStageCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineShaderStageCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineShaderStageCreateInfoFreeCSlice must be called on the returned slice.
func PipelineShaderStageCreateInfoMakeCSlice(x ...PipelineShaderStageCreateInfo) []PipelineShaderStageCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineShaderStageCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineShaderStageCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineShaderStageCreateInfo
func (x PipelineShaderStageCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PipelineShaderStageCreateInfo with the value of
// SType to the value provided in the specification.
func (x PipelineShaderStageCreateInfo) WithDefaultSType() PipelineShaderStageCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PipelineShaderStageCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO)
}

// WithSType clones a new PipelineShaderStageCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineShaderStageCreateInfo) WithSType(y StructureType) PipelineShaderStageCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PipelineShaderStageCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPipelineShaderStageCreateInfo
func (x PipelineShaderStageCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PipelineShaderStageCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineShaderStageCreateInfo) WithPNext(y unsafe.Pointer) PipelineShaderStageCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PipelineShaderStageCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkPipelineShaderStageCreateInfo
func (x PipelineShaderStageCreateInfo) Flags() PipelineShaderStageCreateFlags {
	ptr := /* typedef */ (*PipelineShaderStageCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new PipelineShaderStageCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineShaderStageCreateInfo) WithFlags(y PipelineShaderStageCreateFlags) PipelineShaderStageCreateInfo {
	x.flags = *( /* typedef */ (*C.VkPipelineShaderStageCreateFlags)(&y))
	return x
}
func (x *PipelineShaderStageCreateInfo) SetFlags(y PipelineShaderStageCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkPipelineShaderStageCreateFlags)(&y))
}

// Stage returns the value of stage from VkPipelineShaderStageCreateInfo
func (x PipelineShaderStageCreateInfo) Stage() ShaderStageFlagBits {
	ptr := /* typedef */ (*ShaderStageFlagBits)(&x.stage)
	return *ptr
}

// WithStage clones a new PipelineShaderStageCreateInfo with the value of
// Stage updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineShaderStageCreateInfo) WithStage(y ShaderStageFlagBits) PipelineShaderStageCreateInfo {
	x.stage = *( /* typedef */ (*C.VkShaderStageFlagBits)(&y))
	return x
}
func (x *PipelineShaderStageCreateInfo) SetStage(y ShaderStageFlagBits) {
	x.stage = *( /* typedef */ (*C.VkShaderStageFlagBits)(&y))
}

// Module returns the value of module from VkPipelineShaderStageCreateInfo
func (x PipelineShaderStageCreateInfo) Module() ShaderModule {
	ptr := /* handle */ (*ShaderModule)(&x.module)
	return *ptr
}

// WithModule clones a new PipelineShaderStageCreateInfo with the value of
// Module updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineShaderStageCreateInfo) WithModule(y ShaderModule) PipelineShaderStageCreateInfo {
	x.module = *( /* handle */ (*C.VkShaderModule)(&y))
	return x
}
func (x *PipelineShaderStageCreateInfo) SetModule(y ShaderModule) {
	x.module = *( /* handle */ (*C.VkShaderModule)(&y))
}

// PName returns the value of pName from VkPipelineShaderStageCreateInfo
func (x PipelineShaderStageCreateInfo) PName() *byte {
	ptr := func(x **C.char) **byte { /* Pointer */ return (**byte)(unsafe.Pointer(x)) }(&x.pName)
	return *ptr
}

// WithPName clones a new PipelineShaderStageCreateInfo with the value of
// PName updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineShaderStageCreateInfo) WithPName(y *byte) PipelineShaderStageCreateInfo {
	x.pName = *(func(x **byte) **C.char { /* Pointer */ return (**C.char)(unsafe.Pointer(x)) }(&y))
	return x
}
func (x *PipelineShaderStageCreateInfo) SetPName(y *byte) {
	x.pName = *(func(x **byte) **C.char { /* Pointer */ return (**C.char)(unsafe.Pointer(x)) }(&y))
}

// PSpecializationInfo returns the value of pSpecializationInfo from VkPipelineShaderStageCreateInfo
func (x PipelineShaderStageCreateInfo) PSpecializationInfo() *SpecializationInfo {
	ptr := func(x **C.struct_VkSpecializationInfo) **SpecializationInfo { /* Pointer */
		c2g := (*SpecializationInfo)(*x)
		return &c2g
	}(&x.pSpecializationInfo)
	return *ptr
}

// WithPSpecializationInfo clones a new PipelineShaderStageCreateInfo with the value of
// PSpecializationInfo updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineShaderStageCreateInfo) WithPSpecializationInfo(y *SpecializationInfo) PipelineShaderStageCreateInfo {
	x.pSpecializationInfo = *(func(x **SpecializationInfo) **C.struct_VkSpecializationInfo { /* Pointer */
		g2c := (*C.struct_VkSpecializationInfo)(*x)
		return &g2c
	}(&y))
	return x
}
func (x *PipelineShaderStageCreateInfo) SetPSpecializationInfo(y *SpecializationInfo) {
	x.pSpecializationInfo = *(func(x **SpecializationInfo) **C.struct_VkSpecializationInfo { /* Pointer */
		g2c := (*C.struct_VkSpecializationInfo)(*x)
		return &g2c
	}(&y))
}

// ComputePipelineCreateInfo provides a go interface for VkComputePipelineCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkComputePipelineCreateInfo.html
type ComputePipelineCreateInfo C.struct_VkComputePipelineCreateInfo

// SizeofComputePipelineCreateInfo is the memory size of a ComputePipelineCreateInfo
var SizeofComputePipelineCreateInfo int = int(unsafe.Sizeof(ComputePipelineCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ComputePipelineCreateInfo) ArpPtr(arp *AutoReleasePool) *ComputePipelineCreateInfo {
	ptr := newCBlock(cULong(SizeofComputePipelineCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ComputePipelineCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ComputePipelineCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ComputePipelineCreateInfo) AsCPtr() *ComputePipelineCreateInfo {
	clone := (*ComputePipelineCreateInfo)(newCBlock(cULong(SizeofComputePipelineCreateInfo)))
	*clone = x
	return clone
}

// ComputePipelineCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ComputePipelineCreateInfoCSlice(arp *AutoReleasePool, x ...ComputePipelineCreateInfo) []ComputePipelineCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofComputePipelineCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ComputePipelineCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ComputePipelineCreateInfoFreeCSlice releases the memory allocated by ComputePipelineCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ComputePipelineCreateInfoFreeCSlice(x []ComputePipelineCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ComputePipelineCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ComputePipelineCreateInfoFreeCSlice must be called on the returned slice.
func ComputePipelineCreateInfoMakeCSlice(x ...ComputePipelineCreateInfo) []ComputePipelineCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofComputePipelineCreateInfo * len(x)
	dst := unsafe.Slice((*ComputePipelineCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkComputePipelineCreateInfo
func (x ComputePipelineCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ComputePipelineCreateInfo with the value of
// SType to the value provided in the specification.
func (x ComputePipelineCreateInfo) WithDefaultSType() ComputePipelineCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ComputePipelineCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO)
}

// WithSType clones a new ComputePipelineCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComputePipelineCreateInfo) WithSType(y StructureType) ComputePipelineCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ComputePipelineCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkComputePipelineCreateInfo
func (x ComputePipelineCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ComputePipelineCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComputePipelineCreateInfo) WithPNext(y unsafe.Pointer) ComputePipelineCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ComputePipelineCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkComputePipelineCreateInfo
func (x ComputePipelineCreateInfo) Flags() PipelineCreateFlags {
	ptr := /* typedef */ (*PipelineCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new ComputePipelineCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComputePipelineCreateInfo) WithFlags(y PipelineCreateFlags) ComputePipelineCreateInfo {
	x.flags = *( /* typedef */ (*C.VkPipelineCreateFlags)(&y))
	return x
}
func (x *ComputePipelineCreateInfo) SetFlags(y PipelineCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkPipelineCreateFlags)(&y))
}

// Stage returns the value of stage from VkComputePipelineCreateInfo
func (x ComputePipelineCreateInfo) Stage() PipelineShaderStageCreateInfo {
	ptr := /* typedef */ (*PipelineShaderStageCreateInfo)(&x.stage)
	return *ptr
}

// WithStage clones a new ComputePipelineCreateInfo with the value of
// Stage updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComputePipelineCreateInfo) WithStage(y PipelineShaderStageCreateInfo) ComputePipelineCreateInfo {
	x.stage = *( /* typedef */ (*C.struct_VkPipelineShaderStageCreateInfo)(&y))
	return x
}
func (x *ComputePipelineCreateInfo) SetStage(y PipelineShaderStageCreateInfo) {
	x.stage = *( /* typedef */ (*C.struct_VkPipelineShaderStageCreateInfo)(&y))
}

// Layout returns the value of layout from VkComputePipelineCreateInfo
func (x ComputePipelineCreateInfo) Layout() PipelineLayout {
	ptr := /* handle */ (*PipelineLayout)(&x.layout)
	return *ptr
}

// WithLayout clones a new ComputePipelineCreateInfo with the value of
// Layout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComputePipelineCreateInfo) WithLayout(y PipelineLayout) ComputePipelineCreateInfo {
	x.layout = *( /* handle */ (*C.VkPipelineLayout)(&y))
	return x
}
func (x *ComputePipelineCreateInfo) SetLayout(y PipelineLayout) {
	x.layout = *( /* handle */ (*C.VkPipelineLayout)(&y))
}

// BasePipelineHandle returns the value of basePipelineHandle from VkComputePipelineCreateInfo
func (x ComputePipelineCreateInfo) BasePipelineHandle() Pipeline {
	ptr := /* handle */ (*Pipeline)(&x.basePipelineHandle)
	return *ptr
}

// WithBasePipelineHandle clones a new ComputePipelineCreateInfo with the value of
// BasePipelineHandle updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComputePipelineCreateInfo) WithBasePipelineHandle(y Pipeline) ComputePipelineCreateInfo {
	x.basePipelineHandle = *( /* handle */ (*C.VkPipeline)(&y))
	return x
}
func (x *ComputePipelineCreateInfo) SetBasePipelineHandle(y Pipeline) {
	x.basePipelineHandle = *( /* handle */ (*C.VkPipeline)(&y))
}

// BasePipelineIndex returns the value of basePipelineIndex from VkComputePipelineCreateInfo
func (x ComputePipelineCreateInfo) BasePipelineIndex() int32 {
	ptr := func(x *C.int32_t) *int32 { /* Scalar */ c2g := int32(*x); return &c2g }(&x.basePipelineIndex)
	return *ptr
}

// WithBasePipelineIndex clones a new ComputePipelineCreateInfo with the value of
// BasePipelineIndex updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComputePipelineCreateInfo) WithBasePipelineIndex(y int32) ComputePipelineCreateInfo {
	x.basePipelineIndex = *(func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&y))
	return x
}
func (x *ComputePipelineCreateInfo) SetBasePipelineIndex(y int32) {
	x.basePipelineIndex = *(func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&y))
}

// AllocationCallbacks provides a go interface for VkAllocationCallbacks.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAllocationCallbacks.html
type AllocationCallbacks C.struct_VkAllocationCallbacks

// SizeofAllocationCallbacks is the memory size of a AllocationCallbacks
var SizeofAllocationCallbacks int = int(unsafe.Sizeof(AllocationCallbacks{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x AllocationCallbacks) ArpPtr(arp *AutoReleasePool) *AllocationCallbacks {
	ptr := newCBlock(cULong(SizeofAllocationCallbacks))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*AllocationCallbacks)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *AllocationCallbacks) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x AllocationCallbacks) AsCPtr() *AllocationCallbacks {
	clone := (*AllocationCallbacks)(newCBlock(cULong(SizeofAllocationCallbacks)))
	*clone = x
	return clone
}

// AllocationCallbacksCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func AllocationCallbacksCSlice(arp *AutoReleasePool, x ...AllocationCallbacks) []AllocationCallbacks {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAllocationCallbacks * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*AllocationCallbacks)(ptr), len(x))
	copy(dst, x)
	return dst
}

// AllocationCallbacksFreeCSlice releases the memory allocated by AllocationCallbacksMakeCSlice.
// It does not free pointers stored inside the slice.
func AllocationCallbacksFreeCSlice(x []AllocationCallbacks) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// AllocationCallbacksMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. AllocationCallbacksFreeCSlice must be called on the returned slice.
func AllocationCallbacksMakeCSlice(x ...AllocationCallbacks) []AllocationCallbacks {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAllocationCallbacks * len(x)
	dst := unsafe.Slice((*AllocationCallbacks)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// PUserData returns the value of pUserData from VkAllocationCallbacks
func (x AllocationCallbacks) PUserData() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pUserData)
	return *ptr
}

// WithPUserData clones a new AllocationCallbacks with the value of
// PUserData updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AllocationCallbacks) WithPUserData(y unsafe.Pointer) AllocationCallbacks {
	x.pUserData = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *AllocationCallbacks) SetPUserData(y unsafe.Pointer) {
	x.pUserData = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// PfnAllocation returns the value of pfnAllocation from VkAllocationCallbacks
func (x AllocationCallbacks) PfnAllocation() PFN_vkAllocationFunction {
	ptr := /* typedef */ (*PFN_vkAllocationFunction)(&x.pfnAllocation)
	return *ptr
}

// WithPfnAllocation clones a new AllocationCallbacks with the value of
// PfnAllocation updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AllocationCallbacks) WithPfnAllocation(y PFN_vkAllocationFunction) AllocationCallbacks {
	x.pfnAllocation = *( /* typedef */ (*C.PFN_vkAllocationFunction)(&y))
	return x
}
func (x *AllocationCallbacks) SetPfnAllocation(y PFN_vkAllocationFunction) {
	x.pfnAllocation = *( /* typedef */ (*C.PFN_vkAllocationFunction)(&y))
}

// PfnReallocation returns the value of pfnReallocation from VkAllocationCallbacks
func (x AllocationCallbacks) PfnReallocation() PFN_vkReallocationFunction {
	ptr := /* typedef */ (*PFN_vkReallocationFunction)(&x.pfnReallocation)
	return *ptr
}

// WithPfnReallocation clones a new AllocationCallbacks with the value of
// PfnReallocation updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AllocationCallbacks) WithPfnReallocation(y PFN_vkReallocationFunction) AllocationCallbacks {
	x.pfnReallocation = *( /* typedef */ (*C.PFN_vkReallocationFunction)(&y))
	return x
}
func (x *AllocationCallbacks) SetPfnReallocation(y PFN_vkReallocationFunction) {
	x.pfnReallocation = *( /* typedef */ (*C.PFN_vkReallocationFunction)(&y))
}

// PfnFree returns the value of pfnFree from VkAllocationCallbacks
func (x AllocationCallbacks) PfnFree() PFN_vkFreeFunction {
	ptr := /* typedef */ (*PFN_vkFreeFunction)(&x.pfnFree)
	return *ptr
}

// WithPfnFree clones a new AllocationCallbacks with the value of
// PfnFree updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AllocationCallbacks) WithPfnFree(y PFN_vkFreeFunction) AllocationCallbacks {
	x.pfnFree = *( /* typedef */ (*C.PFN_vkFreeFunction)(&y))
	return x
}
func (x *AllocationCallbacks) SetPfnFree(y PFN_vkFreeFunction) {
	x.pfnFree = *( /* typedef */ (*C.PFN_vkFreeFunction)(&y))
}

// PfnInternalAllocation returns the value of pfnInternalAllocation from VkAllocationCallbacks
func (x AllocationCallbacks) PfnInternalAllocation() PFN_vkInternalAllocationNotification {
	ptr := /* typedef */ (*PFN_vkInternalAllocationNotification)(&x.pfnInternalAllocation)
	return *ptr
}

// WithPfnInternalAllocation clones a new AllocationCallbacks with the value of
// PfnInternalAllocation updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AllocationCallbacks) WithPfnInternalAllocation(y PFN_vkInternalAllocationNotification) AllocationCallbacks {
	x.pfnInternalAllocation = *( /* typedef */ (*C.PFN_vkInternalAllocationNotification)(&y))
	return x
}
func (x *AllocationCallbacks) SetPfnInternalAllocation(y PFN_vkInternalAllocationNotification) {
	x.pfnInternalAllocation = *( /* typedef */ (*C.PFN_vkInternalAllocationNotification)(&y))
}

// PfnInternalFree returns the value of pfnInternalFree from VkAllocationCallbacks
func (x AllocationCallbacks) PfnInternalFree() PFN_vkInternalFreeNotification {
	ptr := /* typedef */ (*PFN_vkInternalFreeNotification)(&x.pfnInternalFree)
	return *ptr
}

// WithPfnInternalFree clones a new AllocationCallbacks with the value of
// PfnInternalFree updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AllocationCallbacks) WithPfnInternalFree(y PFN_vkInternalFreeNotification) AllocationCallbacks {
	x.pfnInternalFree = *( /* typedef */ (*C.PFN_vkInternalFreeNotification)(&y))
	return x
}
func (x *AllocationCallbacks) SetPfnInternalFree(y PFN_vkInternalFreeNotification) {
	x.pfnInternalFree = *( /* typedef */ (*C.PFN_vkInternalFreeNotification)(&y))
}

// DrawIndexedIndirectCommand provides a go interface for VkDrawIndexedIndirectCommand.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrawIndexedIndirectCommand.html
type DrawIndexedIndirectCommand C.struct_VkDrawIndexedIndirectCommand

// SizeofDrawIndexedIndirectCommand is the memory size of a DrawIndexedIndirectCommand
var SizeofDrawIndexedIndirectCommand int = int(unsafe.Sizeof(DrawIndexedIndirectCommand{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DrawIndexedIndirectCommand) ArpPtr(arp *AutoReleasePool) *DrawIndexedIndirectCommand {
	ptr := newCBlock(cULong(SizeofDrawIndexedIndirectCommand))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DrawIndexedIndirectCommand)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DrawIndexedIndirectCommand) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DrawIndexedIndirectCommand) AsCPtr() *DrawIndexedIndirectCommand {
	clone := (*DrawIndexedIndirectCommand)(newCBlock(cULong(SizeofDrawIndexedIndirectCommand)))
	*clone = x
	return clone
}

// DrawIndexedIndirectCommandCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DrawIndexedIndirectCommandCSlice(arp *AutoReleasePool, x ...DrawIndexedIndirectCommand) []DrawIndexedIndirectCommand {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDrawIndexedIndirectCommand * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DrawIndexedIndirectCommand)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DrawIndexedIndirectCommandFreeCSlice releases the memory allocated by DrawIndexedIndirectCommandMakeCSlice.
// It does not free pointers stored inside the slice.
func DrawIndexedIndirectCommandFreeCSlice(x []DrawIndexedIndirectCommand) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DrawIndexedIndirectCommandMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DrawIndexedIndirectCommandFreeCSlice must be called on the returned slice.
func DrawIndexedIndirectCommandMakeCSlice(x ...DrawIndexedIndirectCommand) []DrawIndexedIndirectCommand {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDrawIndexedIndirectCommand * len(x)
	dst := unsafe.Slice((*DrawIndexedIndirectCommand)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// IndexCount returns the value of indexCount from VkDrawIndexedIndirectCommand
func (x DrawIndexedIndirectCommand) IndexCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.indexCount)
	return *ptr
}

// WithIndexCount clones a new DrawIndexedIndirectCommand with the value of
// IndexCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DrawIndexedIndirectCommand) WithIndexCount(y uint32) DrawIndexedIndirectCommand {
	x.indexCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DrawIndexedIndirectCommand) SetIndexCount(y uint32) {
	x.indexCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// InstanceCount returns the value of instanceCount from VkDrawIndexedIndirectCommand
func (x DrawIndexedIndirectCommand) InstanceCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.instanceCount)
	return *ptr
}

// WithInstanceCount clones a new DrawIndexedIndirectCommand with the value of
// InstanceCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DrawIndexedIndirectCommand) WithInstanceCount(y uint32) DrawIndexedIndirectCommand {
	x.instanceCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DrawIndexedIndirectCommand) SetInstanceCount(y uint32) {
	x.instanceCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// FirstIndex returns the value of firstIndex from VkDrawIndexedIndirectCommand
func (x DrawIndexedIndirectCommand) FirstIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.firstIndex)
	return *ptr
}

// WithFirstIndex clones a new DrawIndexedIndirectCommand with the value of
// FirstIndex updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DrawIndexedIndirectCommand) WithFirstIndex(y uint32) DrawIndexedIndirectCommand {
	x.firstIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DrawIndexedIndirectCommand) SetFirstIndex(y uint32) {
	x.firstIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// VertexOffset returns the value of vertexOffset from VkDrawIndexedIndirectCommand
func (x DrawIndexedIndirectCommand) VertexOffset() int32 {
	ptr := func(x *C.int32_t) *int32 { /* Scalar */ c2g := int32(*x); return &c2g }(&x.vertexOffset)
	return *ptr
}

// WithVertexOffset clones a new DrawIndexedIndirectCommand with the value of
// VertexOffset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DrawIndexedIndirectCommand) WithVertexOffset(y int32) DrawIndexedIndirectCommand {
	x.vertexOffset = *(func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&y))
	return x
}
func (x *DrawIndexedIndirectCommand) SetVertexOffset(y int32) {
	x.vertexOffset = *(func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&y))
}

// FirstInstance returns the value of firstInstance from VkDrawIndexedIndirectCommand
func (x DrawIndexedIndirectCommand) FirstInstance() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.firstInstance)
	return *ptr
}

// WithFirstInstance clones a new DrawIndexedIndirectCommand with the value of
// FirstInstance updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DrawIndexedIndirectCommand) WithFirstInstance(y uint32) DrawIndexedIndirectCommand {
	x.firstInstance = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DrawIndexedIndirectCommand) SetFirstInstance(y uint32) {
	x.firstInstance = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PipelineDynamicStateCreateInfo provides a go interface for VkPipelineDynamicStateCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineDynamicStateCreateInfo.html
type PipelineDynamicStateCreateInfo C.struct_VkPipelineDynamicStateCreateInfo

// SizeofPipelineDynamicStateCreateInfo is the memory size of a PipelineDynamicStateCreateInfo
var SizeofPipelineDynamicStateCreateInfo int = int(unsafe.Sizeof(PipelineDynamicStateCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PipelineDynamicStateCreateInfo) ArpPtr(arp *AutoReleasePool) *PipelineDynamicStateCreateInfo {
	ptr := newCBlock(cULong(SizeofPipelineDynamicStateCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PipelineDynamicStateCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineDynamicStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineDynamicStateCreateInfo) AsCPtr() *PipelineDynamicStateCreateInfo {
	clone := (*PipelineDynamicStateCreateInfo)(newCBlock(cULong(SizeofPipelineDynamicStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineDynamicStateCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PipelineDynamicStateCreateInfoCSlice(arp *AutoReleasePool, x ...PipelineDynamicStateCreateInfo) []PipelineDynamicStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineDynamicStateCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PipelineDynamicStateCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PipelineDynamicStateCreateInfoFreeCSlice releases the memory allocated by PipelineDynamicStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineDynamicStateCreateInfoFreeCSlice(x []PipelineDynamicStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineDynamicStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineDynamicStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineDynamicStateCreateInfoMakeCSlice(x ...PipelineDynamicStateCreateInfo) []PipelineDynamicStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineDynamicStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineDynamicStateCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineDynamicStateCreateInfo
func (x PipelineDynamicStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PipelineDynamicStateCreateInfo with the value of
// SType to the value provided in the specification.
func (x PipelineDynamicStateCreateInfo) WithDefaultSType() PipelineDynamicStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PipelineDynamicStateCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO)
}

// WithSType clones a new PipelineDynamicStateCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDynamicStateCreateInfo) WithSType(y StructureType) PipelineDynamicStateCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PipelineDynamicStateCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPipelineDynamicStateCreateInfo
func (x PipelineDynamicStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PipelineDynamicStateCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDynamicStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineDynamicStateCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PipelineDynamicStateCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkPipelineDynamicStateCreateInfo
func (x PipelineDynamicStateCreateInfo) Flags() PipelineDynamicStateCreateFlags {
	ptr := /* typedef */ (*PipelineDynamicStateCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new PipelineDynamicStateCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDynamicStateCreateInfo) WithFlags(y PipelineDynamicStateCreateFlags) PipelineDynamicStateCreateInfo {
	x.flags = *( /* typedef */ (*C.VkPipelineDynamicStateCreateFlags)(&y))
	return x
}
func (x *PipelineDynamicStateCreateInfo) SetFlags(y PipelineDynamicStateCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkPipelineDynamicStateCreateFlags)(&y))
}

// DynamicStateCount returns the value of dynamicStateCount from VkPipelineDynamicStateCreateInfo
func (x PipelineDynamicStateCreateInfo) DynamicStateCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dynamicStateCount)
	return *ptr
}

// WithDynamicStateCount clones a new PipelineDynamicStateCreateInfo with the value of
// DynamicStateCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDynamicStateCreateInfo) WithDynamicStateCount(y uint32) PipelineDynamicStateCreateInfo {
	x.dynamicStateCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *PipelineDynamicStateCreateInfo) SetDynamicStateCount(y uint32) {
	x.dynamicStateCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PDynamicStates returns the value of pDynamicStates from VkPipelineDynamicStateCreateInfo
func (x PipelineDynamicStateCreateInfo) PDynamicStates() []DynamicState {
	ptr := func(x **C.VkDynamicState) *[]DynamicState { /* Slice */
		slc := unsafe.Slice((*DynamicState)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pDynamicStates)
	return *ptr
}

// WithPDynamicStates clones a new PipelineDynamicStateCreateInfo with the value of
// PDynamicStates updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DynamicStateCount as the length of this field.
// DynamicStateCount is updated with the length of the new value.
func (x PipelineDynamicStateCreateInfo) WithPDynamicStates(y []DynamicState) PipelineDynamicStateCreateInfo {
	x.pDynamicStates = *(func(x *[]DynamicState) **C.VkDynamicState { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkDynamicState)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkDynamicState)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithDynamicStateCount(uint32(len(y)))
}
func (x *PipelineDynamicStateCreateInfo) SetPDynamicStates(y []DynamicState) {
	x.pDynamicStates = *(func(x *[]DynamicState) **C.VkDynamicState { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkDynamicState)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkDynamicState)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetDynamicStateCount(uint32(len(y)))
}

// PipelineColorBlendAttachmentState provides a go interface for VkPipelineColorBlendAttachmentState.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineColorBlendAttachmentState.html
type PipelineColorBlendAttachmentState C.struct_VkPipelineColorBlendAttachmentState

// SizeofPipelineColorBlendAttachmentState is the memory size of a PipelineColorBlendAttachmentState
var SizeofPipelineColorBlendAttachmentState int = int(unsafe.Sizeof(PipelineColorBlendAttachmentState{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PipelineColorBlendAttachmentState) ArpPtr(arp *AutoReleasePool) *PipelineColorBlendAttachmentState {
	ptr := newCBlock(cULong(SizeofPipelineColorBlendAttachmentState))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PipelineColorBlendAttachmentState)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineColorBlendAttachmentState) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineColorBlendAttachmentState) AsCPtr() *PipelineColorBlendAttachmentState {
	clone := (*PipelineColorBlendAttachmentState)(newCBlock(cULong(SizeofPipelineColorBlendAttachmentState)))
	*clone = x
	return clone
}

// PipelineColorBlendAttachmentStateCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PipelineColorBlendAttachmentStateCSlice(arp *AutoReleasePool, x ...PipelineColorBlendAttachmentState) []PipelineColorBlendAttachmentState {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineColorBlendAttachmentState * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PipelineColorBlendAttachmentState)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PipelineColorBlendAttachmentStateFreeCSlice releases the memory allocated by PipelineColorBlendAttachmentStateMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineColorBlendAttachmentStateFreeCSlice(x []PipelineColorBlendAttachmentState) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineColorBlendAttachmentStateMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineColorBlendAttachmentStateFreeCSlice must be called on the returned slice.
func PipelineColorBlendAttachmentStateMakeCSlice(x ...PipelineColorBlendAttachmentState) []PipelineColorBlendAttachmentState {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineColorBlendAttachmentState * len(x)
	dst := unsafe.Slice((*PipelineColorBlendAttachmentState)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// BlendEnable returns the value of blendEnable from VkPipelineColorBlendAttachmentState
func (x PipelineColorBlendAttachmentState) BlendEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.blendEnable)
	return *ptr
}

// WithBlendEnable clones a new PipelineColorBlendAttachmentState with the value of
// BlendEnable updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendAttachmentState) WithBlendEnable(y Bool32) PipelineColorBlendAttachmentState {
	x.blendEnable = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PipelineColorBlendAttachmentState) SetBlendEnable(y Bool32) {
	x.blendEnable = *( /* typedef */ (*C.VkBool32)(&y))
}

// SrcColorBlendFactor returns the value of srcColorBlendFactor from VkPipelineColorBlendAttachmentState
func (x PipelineColorBlendAttachmentState) SrcColorBlendFactor() BlendFactor {
	ptr := /* typedef */ (*BlendFactor)(&x.srcColorBlendFactor)
	return *ptr
}

// WithSrcColorBlendFactor clones a new PipelineColorBlendAttachmentState with the value of
// SrcColorBlendFactor updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendAttachmentState) WithSrcColorBlendFactor(y BlendFactor) PipelineColorBlendAttachmentState {
	x.srcColorBlendFactor = *( /* typedef */ (*C.VkBlendFactor)(&y))
	return x
}
func (x *PipelineColorBlendAttachmentState) SetSrcColorBlendFactor(y BlendFactor) {
	x.srcColorBlendFactor = *( /* typedef */ (*C.VkBlendFactor)(&y))
}

// DstColorBlendFactor returns the value of dstColorBlendFactor from VkPipelineColorBlendAttachmentState
func (x PipelineColorBlendAttachmentState) DstColorBlendFactor() BlendFactor {
	ptr := /* typedef */ (*BlendFactor)(&x.dstColorBlendFactor)
	return *ptr
}

// WithDstColorBlendFactor clones a new PipelineColorBlendAttachmentState with the value of
// DstColorBlendFactor updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendAttachmentState) WithDstColorBlendFactor(y BlendFactor) PipelineColorBlendAttachmentState {
	x.dstColorBlendFactor = *( /* typedef */ (*C.VkBlendFactor)(&y))
	return x
}
func (x *PipelineColorBlendAttachmentState) SetDstColorBlendFactor(y BlendFactor) {
	x.dstColorBlendFactor = *( /* typedef */ (*C.VkBlendFactor)(&y))
}

// ColorBlendOp returns the value of colorBlendOp from VkPipelineColorBlendAttachmentState
func (x PipelineColorBlendAttachmentState) ColorBlendOp() BlendOp {
	ptr := /* typedef */ (*BlendOp)(&x.colorBlendOp)
	return *ptr
}

// WithColorBlendOp clones a new PipelineColorBlendAttachmentState with the value of
// ColorBlendOp updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendAttachmentState) WithColorBlendOp(y BlendOp) PipelineColorBlendAttachmentState {
	x.colorBlendOp = *( /* typedef */ (*C.VkBlendOp)(&y))
	return x
}
func (x *PipelineColorBlendAttachmentState) SetColorBlendOp(y BlendOp) {
	x.colorBlendOp = *( /* typedef */ (*C.VkBlendOp)(&y))
}

// SrcAlphaBlendFactor returns the value of srcAlphaBlendFactor from VkPipelineColorBlendAttachmentState
func (x PipelineColorBlendAttachmentState) SrcAlphaBlendFactor() BlendFactor {
	ptr := /* typedef */ (*BlendFactor)(&x.srcAlphaBlendFactor)
	return *ptr
}

// WithSrcAlphaBlendFactor clones a new PipelineColorBlendAttachmentState with the value of
// SrcAlphaBlendFactor updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendAttachmentState) WithSrcAlphaBlendFactor(y BlendFactor) PipelineColorBlendAttachmentState {
	x.srcAlphaBlendFactor = *( /* typedef */ (*C.VkBlendFactor)(&y))
	return x
}
func (x *PipelineColorBlendAttachmentState) SetSrcAlphaBlendFactor(y BlendFactor) {
	x.srcAlphaBlendFactor = *( /* typedef */ (*C.VkBlendFactor)(&y))
}

// DstAlphaBlendFactor returns the value of dstAlphaBlendFactor from VkPipelineColorBlendAttachmentState
func (x PipelineColorBlendAttachmentState) DstAlphaBlendFactor() BlendFactor {
	ptr := /* typedef */ (*BlendFactor)(&x.dstAlphaBlendFactor)
	return *ptr
}

// WithDstAlphaBlendFactor clones a new PipelineColorBlendAttachmentState with the value of
// DstAlphaBlendFactor updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendAttachmentState) WithDstAlphaBlendFactor(y BlendFactor) PipelineColorBlendAttachmentState {
	x.dstAlphaBlendFactor = *( /* typedef */ (*C.VkBlendFactor)(&y))
	return x
}
func (x *PipelineColorBlendAttachmentState) SetDstAlphaBlendFactor(y BlendFactor) {
	x.dstAlphaBlendFactor = *( /* typedef */ (*C.VkBlendFactor)(&y))
}

// AlphaBlendOp returns the value of alphaBlendOp from VkPipelineColorBlendAttachmentState
func (x PipelineColorBlendAttachmentState) AlphaBlendOp() BlendOp {
	ptr := /* typedef */ (*BlendOp)(&x.alphaBlendOp)
	return *ptr
}

// WithAlphaBlendOp clones a new PipelineColorBlendAttachmentState with the value of
// AlphaBlendOp updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendAttachmentState) WithAlphaBlendOp(y BlendOp) PipelineColorBlendAttachmentState {
	x.alphaBlendOp = *( /* typedef */ (*C.VkBlendOp)(&y))
	return x
}
func (x *PipelineColorBlendAttachmentState) SetAlphaBlendOp(y BlendOp) {
	x.alphaBlendOp = *( /* typedef */ (*C.VkBlendOp)(&y))
}

// ColorWriteMask returns the value of colorWriteMask from VkPipelineColorBlendAttachmentState
func (x PipelineColorBlendAttachmentState) ColorWriteMask() ColorComponentFlags {
	ptr := /* typedef */ (*ColorComponentFlags)(&x.colorWriteMask)
	return *ptr
}

// WithColorWriteMask clones a new PipelineColorBlendAttachmentState with the value of
// ColorWriteMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendAttachmentState) WithColorWriteMask(y ColorComponentFlags) PipelineColorBlendAttachmentState {
	x.colorWriteMask = *( /* typedef */ (*C.VkColorComponentFlags)(&y))
	return x
}
func (x *PipelineColorBlendAttachmentState) SetColorWriteMask(y ColorComponentFlags) {
	x.colorWriteMask = *( /* typedef */ (*C.VkColorComponentFlags)(&y))
}

// PipelineColorBlendStateCreateInfo provides a go interface for VkPipelineColorBlendStateCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineColorBlendStateCreateInfo.html
type PipelineColorBlendStateCreateInfo C.struct_VkPipelineColorBlendStateCreateInfo

// SizeofPipelineColorBlendStateCreateInfo is the memory size of a PipelineColorBlendStateCreateInfo
var SizeofPipelineColorBlendStateCreateInfo int = int(unsafe.Sizeof(PipelineColorBlendStateCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PipelineColorBlendStateCreateInfo) ArpPtr(arp *AutoReleasePool) *PipelineColorBlendStateCreateInfo {
	ptr := newCBlock(cULong(SizeofPipelineColorBlendStateCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PipelineColorBlendStateCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineColorBlendStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineColorBlendStateCreateInfo) AsCPtr() *PipelineColorBlendStateCreateInfo {
	clone := (*PipelineColorBlendStateCreateInfo)(newCBlock(cULong(SizeofPipelineColorBlendStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineColorBlendStateCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PipelineColorBlendStateCreateInfoCSlice(arp *AutoReleasePool, x ...PipelineColorBlendStateCreateInfo) []PipelineColorBlendStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineColorBlendStateCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PipelineColorBlendStateCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PipelineColorBlendStateCreateInfoFreeCSlice releases the memory allocated by PipelineColorBlendStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineColorBlendStateCreateInfoFreeCSlice(x []PipelineColorBlendStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineColorBlendStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineColorBlendStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineColorBlendStateCreateInfoMakeCSlice(x ...PipelineColorBlendStateCreateInfo) []PipelineColorBlendStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineColorBlendStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineColorBlendStateCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineColorBlendStateCreateInfo
func (x PipelineColorBlendStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PipelineColorBlendStateCreateInfo with the value of
// SType to the value provided in the specification.
func (x PipelineColorBlendStateCreateInfo) WithDefaultSType() PipelineColorBlendStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PipelineColorBlendStateCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO)
}

// WithSType clones a new PipelineColorBlendStateCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendStateCreateInfo) WithSType(y StructureType) PipelineColorBlendStateCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PipelineColorBlendStateCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPipelineColorBlendStateCreateInfo
func (x PipelineColorBlendStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PipelineColorBlendStateCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineColorBlendStateCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PipelineColorBlendStateCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkPipelineColorBlendStateCreateInfo
func (x PipelineColorBlendStateCreateInfo) Flags() PipelineColorBlendStateCreateFlags {
	ptr := /* typedef */ (*PipelineColorBlendStateCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new PipelineColorBlendStateCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendStateCreateInfo) WithFlags(y PipelineColorBlendStateCreateFlags) PipelineColorBlendStateCreateInfo {
	x.flags = *( /* typedef */ (*C.VkPipelineColorBlendStateCreateFlags)(&y))
	return x
}
func (x *PipelineColorBlendStateCreateInfo) SetFlags(y PipelineColorBlendStateCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkPipelineColorBlendStateCreateFlags)(&y))
}

// LogicOpEnable returns the value of logicOpEnable from VkPipelineColorBlendStateCreateInfo
func (x PipelineColorBlendStateCreateInfo) LogicOpEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.logicOpEnable)
	return *ptr
}

// WithLogicOpEnable clones a new PipelineColorBlendStateCreateInfo with the value of
// LogicOpEnable updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendStateCreateInfo) WithLogicOpEnable(y Bool32) PipelineColorBlendStateCreateInfo {
	x.logicOpEnable = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PipelineColorBlendStateCreateInfo) SetLogicOpEnable(y Bool32) {
	x.logicOpEnable = *( /* typedef */ (*C.VkBool32)(&y))
}

// LogicOp returns the value of logicOp from VkPipelineColorBlendStateCreateInfo
func (x PipelineColorBlendStateCreateInfo) LogicOp() LogicOp {
	ptr := /* typedef */ (*LogicOp)(&x.logicOp)
	return *ptr
}

// WithLogicOp clones a new PipelineColorBlendStateCreateInfo with the value of
// LogicOp updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendStateCreateInfo) WithLogicOp(y LogicOp) PipelineColorBlendStateCreateInfo {
	x.logicOp = *( /* typedef */ (*C.VkLogicOp)(&y))
	return x
}
func (x *PipelineColorBlendStateCreateInfo) SetLogicOp(y LogicOp) {
	x.logicOp = *( /* typedef */ (*C.VkLogicOp)(&y))
}

// AttachmentCount returns the value of attachmentCount from VkPipelineColorBlendStateCreateInfo
func (x PipelineColorBlendStateCreateInfo) AttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.attachmentCount)
	return *ptr
}

// WithAttachmentCount clones a new PipelineColorBlendStateCreateInfo with the value of
// AttachmentCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendStateCreateInfo) WithAttachmentCount(y uint32) PipelineColorBlendStateCreateInfo {
	x.attachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *PipelineColorBlendStateCreateInfo) SetAttachmentCount(y uint32) {
	x.attachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PAttachments returns the value of pAttachments from VkPipelineColorBlendStateCreateInfo
func (x PipelineColorBlendStateCreateInfo) PAttachments() []PipelineColorBlendAttachmentState {
	ptr := func(x **C.struct_VkPipelineColorBlendAttachmentState) *[]PipelineColorBlendAttachmentState { /* Slice */
		slc := unsafe.Slice((*PipelineColorBlendAttachmentState)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pAttachments)
	return *ptr
}

// WithPAttachments clones a new PipelineColorBlendStateCreateInfo with the value of
// PAttachments updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines AttachmentCount as the length of this field.
// AttachmentCount is updated with the length of the new value.
func (x PipelineColorBlendStateCreateInfo) WithPAttachments(y []PipelineColorBlendAttachmentState) PipelineColorBlendStateCreateInfo {
	x.pAttachments = *(func(x *[]PipelineColorBlendAttachmentState) **C.struct_VkPipelineColorBlendAttachmentState { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkPipelineColorBlendAttachmentState)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkPipelineColorBlendAttachmentState)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithAttachmentCount(uint32(len(y)))
}
func (x *PipelineColorBlendStateCreateInfo) SetPAttachments(y []PipelineColorBlendAttachmentState) {
	x.pAttachments = *(func(x *[]PipelineColorBlendAttachmentState) **C.struct_VkPipelineColorBlendAttachmentState { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkPipelineColorBlendAttachmentState)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkPipelineColorBlendAttachmentState)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetAttachmentCount(uint32(len(y)))
}

// BlendConstants returns the value of blendConstants from VkPipelineColorBlendStateCreateInfo
func (x PipelineColorBlendStateCreateInfo) BlendConstants() []float32 {
	ptr := func(x *[4]C.float) *[]float32 { /* Array */
		slc := unsafe.Slice((*float32)(unsafe.Pointer(x)), 4)
		return &slc
	}(&x.blendConstants)
	return *ptr
}

// WithBlendConstants clones a new PipelineColorBlendStateCreateInfo with the value of
// BlendConstants updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendStateCreateInfo) WithBlendConstants(y []float32) PipelineColorBlendStateCreateInfo {
	ptr := func(x *[]float32) **C.float { /* Array */
		if len(*x) > 0 {
			slc := (*C.float)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.float)(unsafe.Pointer((&ptr)))
	}(&y)
	copy(x.blendConstants[:], unsafe.Slice(*ptr, len(y)))
	return x
}
func (x *PipelineColorBlendStateCreateInfo) SetBlendConstants(y []float32) {
	ptr := func(x *[]float32) **C.float { /* Array */
		if len(*x) > 0 {
			slc := (*C.float)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.float)(unsafe.Pointer((&ptr)))
	}(&y)
	copy(x.blendConstants[:], unsafe.Slice(*ptr, len(y)))
}

// StencilOpState provides a go interface for VkStencilOpState.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkStencilOpState.html
type StencilOpState C.struct_VkStencilOpState

// SizeofStencilOpState is the memory size of a StencilOpState
var SizeofStencilOpState int = int(unsafe.Sizeof(StencilOpState{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x StencilOpState) ArpPtr(arp *AutoReleasePool) *StencilOpState {
	ptr := newCBlock(cULong(SizeofStencilOpState))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*StencilOpState)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *StencilOpState) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x StencilOpState) AsCPtr() *StencilOpState {
	clone := (*StencilOpState)(newCBlock(cULong(SizeofStencilOpState)))
	*clone = x
	return clone
}

// StencilOpStateCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func StencilOpStateCSlice(arp *AutoReleasePool, x ...StencilOpState) []StencilOpState {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofStencilOpState * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*StencilOpState)(ptr), len(x))
	copy(dst, x)
	return dst
}

// StencilOpStateFreeCSlice releases the memory allocated by StencilOpStateMakeCSlice.
// It does not free pointers stored inside the slice.
func StencilOpStateFreeCSlice(x []StencilOpState) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// StencilOpStateMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. StencilOpStateFreeCSlice must be called on the returned slice.
func StencilOpStateMakeCSlice(x ...StencilOpState) []StencilOpState {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofStencilOpState * len(x)
	dst := unsafe.Slice((*StencilOpState)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// FailOp returns the value of failOp from VkStencilOpState
func (x StencilOpState) FailOp() StencilOp {
	ptr := /* typedef */ (*StencilOp)(&x.failOp)
	return *ptr
}

// WithFailOp clones a new StencilOpState with the value of
// FailOp updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x StencilOpState) WithFailOp(y StencilOp) StencilOpState {
	x.failOp = *( /* typedef */ (*C.VkStencilOp)(&y))
	return x
}
func (x *StencilOpState) SetFailOp(y StencilOp) {
	x.failOp = *( /* typedef */ (*C.VkStencilOp)(&y))
}

// PassOp returns the value of passOp from VkStencilOpState
func (x StencilOpState) PassOp() StencilOp {
	ptr := /* typedef */ (*StencilOp)(&x.passOp)
	return *ptr
}

// WithPassOp clones a new StencilOpState with the value of
// PassOp updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x StencilOpState) WithPassOp(y StencilOp) StencilOpState {
	x.passOp = *( /* typedef */ (*C.VkStencilOp)(&y))
	return x
}
func (x *StencilOpState) SetPassOp(y StencilOp) {
	x.passOp = *( /* typedef */ (*C.VkStencilOp)(&y))
}

// DepthFailOp returns the value of depthFailOp from VkStencilOpState
func (x StencilOpState) DepthFailOp() StencilOp {
	ptr := /* typedef */ (*StencilOp)(&x.depthFailOp)
	return *ptr
}

// WithDepthFailOp clones a new StencilOpState with the value of
// DepthFailOp updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x StencilOpState) WithDepthFailOp(y StencilOp) StencilOpState {
	x.depthFailOp = *( /* typedef */ (*C.VkStencilOp)(&y))
	return x
}
func (x *StencilOpState) SetDepthFailOp(y StencilOp) {
	x.depthFailOp = *( /* typedef */ (*C.VkStencilOp)(&y))
}

// CompareOp returns the value of compareOp from VkStencilOpState
func (x StencilOpState) CompareOp() CompareOp {
	ptr := /* typedef */ (*CompareOp)(&x.compareOp)
	return *ptr
}

// WithCompareOp clones a new StencilOpState with the value of
// CompareOp updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x StencilOpState) WithCompareOp(y CompareOp) StencilOpState {
	x.compareOp = *( /* typedef */ (*C.VkCompareOp)(&y))
	return x
}
func (x *StencilOpState) SetCompareOp(y CompareOp) {
	x.compareOp = *( /* typedef */ (*C.VkCompareOp)(&y))
}

// CompareMask returns the value of compareMask from VkStencilOpState
func (x StencilOpState) CompareMask() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.compareMask)
	return *ptr
}

// WithCompareMask clones a new StencilOpState with the value of
// CompareMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x StencilOpState) WithCompareMask(y uint32) StencilOpState {
	x.compareMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *StencilOpState) SetCompareMask(y uint32) {
	x.compareMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// WriteMask returns the value of writeMask from VkStencilOpState
func (x StencilOpState) WriteMask() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.writeMask)
	return *ptr
}

// WithWriteMask clones a new StencilOpState with the value of
// WriteMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x StencilOpState) WithWriteMask(y uint32) StencilOpState {
	x.writeMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *StencilOpState) SetWriteMask(y uint32) {
	x.writeMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// Reference returns the value of reference from VkStencilOpState
func (x StencilOpState) Reference() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.reference)
	return *ptr
}

// WithReference clones a new StencilOpState with the value of
// Reference updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x StencilOpState) WithReference(y uint32) StencilOpState {
	x.reference = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *StencilOpState) SetReference(y uint32) {
	x.reference = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PipelineDepthStencilStateCreateInfo provides a go interface for VkPipelineDepthStencilStateCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineDepthStencilStateCreateInfo.html
type PipelineDepthStencilStateCreateInfo C.struct_VkPipelineDepthStencilStateCreateInfo

// SizeofPipelineDepthStencilStateCreateInfo is the memory size of a PipelineDepthStencilStateCreateInfo
var SizeofPipelineDepthStencilStateCreateInfo int = int(unsafe.Sizeof(PipelineDepthStencilStateCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PipelineDepthStencilStateCreateInfo) ArpPtr(arp *AutoReleasePool) *PipelineDepthStencilStateCreateInfo {
	ptr := newCBlock(cULong(SizeofPipelineDepthStencilStateCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PipelineDepthStencilStateCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineDepthStencilStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineDepthStencilStateCreateInfo) AsCPtr() *PipelineDepthStencilStateCreateInfo {
	clone := (*PipelineDepthStencilStateCreateInfo)(newCBlock(cULong(SizeofPipelineDepthStencilStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineDepthStencilStateCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PipelineDepthStencilStateCreateInfoCSlice(arp *AutoReleasePool, x ...PipelineDepthStencilStateCreateInfo) []PipelineDepthStencilStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineDepthStencilStateCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PipelineDepthStencilStateCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PipelineDepthStencilStateCreateInfoFreeCSlice releases the memory allocated by PipelineDepthStencilStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineDepthStencilStateCreateInfoFreeCSlice(x []PipelineDepthStencilStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineDepthStencilStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineDepthStencilStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineDepthStencilStateCreateInfoMakeCSlice(x ...PipelineDepthStencilStateCreateInfo) []PipelineDepthStencilStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineDepthStencilStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineDepthStencilStateCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PipelineDepthStencilStateCreateInfo with the value of
// SType to the value provided in the specification.
func (x PipelineDepthStencilStateCreateInfo) WithDefaultSType() PipelineDepthStencilStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PipelineDepthStencilStateCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO)
}

// WithSType clones a new PipelineDepthStencilStateCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithSType(y StructureType) PipelineDepthStencilStateCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PipelineDepthStencilStateCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PipelineDepthStencilStateCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineDepthStencilStateCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PipelineDepthStencilStateCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) Flags() PipelineDepthStencilStateCreateFlags {
	ptr := /* typedef */ (*PipelineDepthStencilStateCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new PipelineDepthStencilStateCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithFlags(y PipelineDepthStencilStateCreateFlags) PipelineDepthStencilStateCreateInfo {
	x.flags = *( /* typedef */ (*C.VkPipelineDepthStencilStateCreateFlags)(&y))
	return x
}
func (x *PipelineDepthStencilStateCreateInfo) SetFlags(y PipelineDepthStencilStateCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkPipelineDepthStencilStateCreateFlags)(&y))
}

// DepthTestEnable returns the value of depthTestEnable from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) DepthTestEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.depthTestEnable)
	return *ptr
}

// WithDepthTestEnable clones a new PipelineDepthStencilStateCreateInfo with the value of
// DepthTestEnable updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithDepthTestEnable(y Bool32) PipelineDepthStencilStateCreateInfo {
	x.depthTestEnable = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PipelineDepthStencilStateCreateInfo) SetDepthTestEnable(y Bool32) {
	x.depthTestEnable = *( /* typedef */ (*C.VkBool32)(&y))
}

// DepthWriteEnable returns the value of depthWriteEnable from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) DepthWriteEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.depthWriteEnable)
	return *ptr
}

// WithDepthWriteEnable clones a new PipelineDepthStencilStateCreateInfo with the value of
// DepthWriteEnable updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithDepthWriteEnable(y Bool32) PipelineDepthStencilStateCreateInfo {
	x.depthWriteEnable = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PipelineDepthStencilStateCreateInfo) SetDepthWriteEnable(y Bool32) {
	x.depthWriteEnable = *( /* typedef */ (*C.VkBool32)(&y))
}

// DepthCompareOp returns the value of depthCompareOp from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) DepthCompareOp() CompareOp {
	ptr := /* typedef */ (*CompareOp)(&x.depthCompareOp)
	return *ptr
}

// WithDepthCompareOp clones a new PipelineDepthStencilStateCreateInfo with the value of
// DepthCompareOp updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithDepthCompareOp(y CompareOp) PipelineDepthStencilStateCreateInfo {
	x.depthCompareOp = *( /* typedef */ (*C.VkCompareOp)(&y))
	return x
}
func (x *PipelineDepthStencilStateCreateInfo) SetDepthCompareOp(y CompareOp) {
	x.depthCompareOp = *( /* typedef */ (*C.VkCompareOp)(&y))
}

// DepthBoundsTestEnable returns the value of depthBoundsTestEnable from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) DepthBoundsTestEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.depthBoundsTestEnable)
	return *ptr
}

// WithDepthBoundsTestEnable clones a new PipelineDepthStencilStateCreateInfo with the value of
// DepthBoundsTestEnable updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithDepthBoundsTestEnable(y Bool32) PipelineDepthStencilStateCreateInfo {
	x.depthBoundsTestEnable = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PipelineDepthStencilStateCreateInfo) SetDepthBoundsTestEnable(y Bool32) {
	x.depthBoundsTestEnable = *( /* typedef */ (*C.VkBool32)(&y))
}

// StencilTestEnable returns the value of stencilTestEnable from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) StencilTestEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.stencilTestEnable)
	return *ptr
}

// WithStencilTestEnable clones a new PipelineDepthStencilStateCreateInfo with the value of
// StencilTestEnable updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithStencilTestEnable(y Bool32) PipelineDepthStencilStateCreateInfo {
	x.stencilTestEnable = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PipelineDepthStencilStateCreateInfo) SetStencilTestEnable(y Bool32) {
	x.stencilTestEnable = *( /* typedef */ (*C.VkBool32)(&y))
}

// Front returns the value of front from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) Front() StencilOpState {
	ptr := /* typedef */ (*StencilOpState)(&x.front)
	return *ptr
}

// WithFront clones a new PipelineDepthStencilStateCreateInfo with the value of
// Front updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithFront(y StencilOpState) PipelineDepthStencilStateCreateInfo {
	x.front = *( /* typedef */ (*C.struct_VkStencilOpState)(&y))
	return x
}
func (x *PipelineDepthStencilStateCreateInfo) SetFront(y StencilOpState) {
	x.front = *( /* typedef */ (*C.struct_VkStencilOpState)(&y))
}

// Back returns the value of back from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) Back() StencilOpState {
	ptr := /* typedef */ (*StencilOpState)(&x.back)
	return *ptr
}

// WithBack clones a new PipelineDepthStencilStateCreateInfo with the value of
// Back updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithBack(y StencilOpState) PipelineDepthStencilStateCreateInfo {
	x.back = *( /* typedef */ (*C.struct_VkStencilOpState)(&y))
	return x
}
func (x *PipelineDepthStencilStateCreateInfo) SetBack(y StencilOpState) {
	x.back = *( /* typedef */ (*C.struct_VkStencilOpState)(&y))
}

// MinDepthBounds returns the value of minDepthBounds from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) MinDepthBounds() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.minDepthBounds)
	return *ptr
}

// WithMinDepthBounds clones a new PipelineDepthStencilStateCreateInfo with the value of
// MinDepthBounds updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithMinDepthBounds(y float32) PipelineDepthStencilStateCreateInfo {
	x.minDepthBounds = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}
func (x *PipelineDepthStencilStateCreateInfo) SetMinDepthBounds(y float32) {
	x.minDepthBounds = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
}

// MaxDepthBounds returns the value of maxDepthBounds from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) MaxDepthBounds() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.maxDepthBounds)
	return *ptr
}

// WithMaxDepthBounds clones a new PipelineDepthStencilStateCreateInfo with the value of
// MaxDepthBounds updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithMaxDepthBounds(y float32) PipelineDepthStencilStateCreateInfo {
	x.maxDepthBounds = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}
func (x *PipelineDepthStencilStateCreateInfo) SetMaxDepthBounds(y float32) {
	x.maxDepthBounds = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
}

// PipelineMultisampleStateCreateInfo provides a go interface for VkPipelineMultisampleStateCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineMultisampleStateCreateInfo.html
type PipelineMultisampleStateCreateInfo C.struct_VkPipelineMultisampleStateCreateInfo

// SizeofPipelineMultisampleStateCreateInfo is the memory size of a PipelineMultisampleStateCreateInfo
var SizeofPipelineMultisampleStateCreateInfo int = int(unsafe.Sizeof(PipelineMultisampleStateCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PipelineMultisampleStateCreateInfo) ArpPtr(arp *AutoReleasePool) *PipelineMultisampleStateCreateInfo {
	ptr := newCBlock(cULong(SizeofPipelineMultisampleStateCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PipelineMultisampleStateCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineMultisampleStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineMultisampleStateCreateInfo) AsCPtr() *PipelineMultisampleStateCreateInfo {
	clone := (*PipelineMultisampleStateCreateInfo)(newCBlock(cULong(SizeofPipelineMultisampleStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineMultisampleStateCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PipelineMultisampleStateCreateInfoCSlice(arp *AutoReleasePool, x ...PipelineMultisampleStateCreateInfo) []PipelineMultisampleStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineMultisampleStateCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PipelineMultisampleStateCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PipelineMultisampleStateCreateInfoFreeCSlice releases the memory allocated by PipelineMultisampleStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineMultisampleStateCreateInfoFreeCSlice(x []PipelineMultisampleStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineMultisampleStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineMultisampleStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineMultisampleStateCreateInfoMakeCSlice(x ...PipelineMultisampleStateCreateInfo) []PipelineMultisampleStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineMultisampleStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineMultisampleStateCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineMultisampleStateCreateInfo
func (x PipelineMultisampleStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PipelineMultisampleStateCreateInfo with the value of
// SType to the value provided in the specification.
func (x PipelineMultisampleStateCreateInfo) WithDefaultSType() PipelineMultisampleStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PipelineMultisampleStateCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO)
}

// WithSType clones a new PipelineMultisampleStateCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineMultisampleStateCreateInfo) WithSType(y StructureType) PipelineMultisampleStateCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PipelineMultisampleStateCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPipelineMultisampleStateCreateInfo
func (x PipelineMultisampleStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PipelineMultisampleStateCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineMultisampleStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineMultisampleStateCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PipelineMultisampleStateCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkPipelineMultisampleStateCreateInfo
func (x PipelineMultisampleStateCreateInfo) Flags() PipelineMultisampleStateCreateFlags {
	ptr := /* typedef */ (*PipelineMultisampleStateCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new PipelineMultisampleStateCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineMultisampleStateCreateInfo) WithFlags(y PipelineMultisampleStateCreateFlags) PipelineMultisampleStateCreateInfo {
	x.flags = *( /* typedef */ (*C.VkPipelineMultisampleStateCreateFlags)(&y))
	return x
}
func (x *PipelineMultisampleStateCreateInfo) SetFlags(y PipelineMultisampleStateCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkPipelineMultisampleStateCreateFlags)(&y))
}

// RasterizationSamples returns the value of rasterizationSamples from VkPipelineMultisampleStateCreateInfo
func (x PipelineMultisampleStateCreateInfo) RasterizationSamples() SampleCountFlagBits {
	ptr := /* typedef */ (*SampleCountFlagBits)(&x.rasterizationSamples)
	return *ptr
}

// WithRasterizationSamples clones a new PipelineMultisampleStateCreateInfo with the value of
// RasterizationSamples updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineMultisampleStateCreateInfo) WithRasterizationSamples(y SampleCountFlagBits) PipelineMultisampleStateCreateInfo {
	x.rasterizationSamples = *( /* typedef */ (*C.VkSampleCountFlagBits)(&y))
	return x
}
func (x *PipelineMultisampleStateCreateInfo) SetRasterizationSamples(y SampleCountFlagBits) {
	x.rasterizationSamples = *( /* typedef */ (*C.VkSampleCountFlagBits)(&y))
}

// SampleShadingEnable returns the value of sampleShadingEnable from VkPipelineMultisampleStateCreateInfo
func (x PipelineMultisampleStateCreateInfo) SampleShadingEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sampleShadingEnable)
	return *ptr
}

// WithSampleShadingEnable clones a new PipelineMultisampleStateCreateInfo with the value of
// SampleShadingEnable updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineMultisampleStateCreateInfo) WithSampleShadingEnable(y Bool32) PipelineMultisampleStateCreateInfo {
	x.sampleShadingEnable = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PipelineMultisampleStateCreateInfo) SetSampleShadingEnable(y Bool32) {
	x.sampleShadingEnable = *( /* typedef */ (*C.VkBool32)(&y))
}

// MinSampleShading returns the value of minSampleShading from VkPipelineMultisampleStateCreateInfo
func (x PipelineMultisampleStateCreateInfo) MinSampleShading() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.minSampleShading)
	return *ptr
}

// WithMinSampleShading clones a new PipelineMultisampleStateCreateInfo with the value of
// MinSampleShading updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineMultisampleStateCreateInfo) WithMinSampleShading(y float32) PipelineMultisampleStateCreateInfo {
	x.minSampleShading = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}
func (x *PipelineMultisampleStateCreateInfo) SetMinSampleShading(y float32) {
	x.minSampleShading = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
}

// PSampleMask returns the value of pSampleMask from VkPipelineMultisampleStateCreateInfo
func (x PipelineMultisampleStateCreateInfo) PSampleMask() []SampleMask {
	ptr := func(x **C.VkSampleMask) *[]SampleMask { /* Slice */
		slc := unsafe.Slice((*SampleMask)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pSampleMask)
	return *ptr
}

// WithPSampleMask clones a new PipelineMultisampleStateCreateInfo with the value of
// PSampleMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineMultisampleStateCreateInfo) WithPSampleMask(y []SampleMask) PipelineMultisampleStateCreateInfo {
	x.pSampleMask = *(func(x *[]SampleMask) **C.VkSampleMask { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSampleMask)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSampleMask)(unsafe.Pointer((&ptr)))
	}(&y))
	return x
}
func (x *PipelineMultisampleStateCreateInfo) SetPSampleMask(y []SampleMask) {
	x.pSampleMask = *(func(x *[]SampleMask) **C.VkSampleMask { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSampleMask)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSampleMask)(unsafe.Pointer((&ptr)))
	}(&y))
}

// AlphaToCoverageEnable returns the value of alphaToCoverageEnable from VkPipelineMultisampleStateCreateInfo
func (x PipelineMultisampleStateCreateInfo) AlphaToCoverageEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.alphaToCoverageEnable)
	return *ptr
}

// WithAlphaToCoverageEnable clones a new PipelineMultisampleStateCreateInfo with the value of
// AlphaToCoverageEnable updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineMultisampleStateCreateInfo) WithAlphaToCoverageEnable(y Bool32) PipelineMultisampleStateCreateInfo {
	x.alphaToCoverageEnable = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PipelineMultisampleStateCreateInfo) SetAlphaToCoverageEnable(y Bool32) {
	x.alphaToCoverageEnable = *( /* typedef */ (*C.VkBool32)(&y))
}

// AlphaToOneEnable returns the value of alphaToOneEnable from VkPipelineMultisampleStateCreateInfo
func (x PipelineMultisampleStateCreateInfo) AlphaToOneEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.alphaToOneEnable)
	return *ptr
}

// WithAlphaToOneEnable clones a new PipelineMultisampleStateCreateInfo with the value of
// AlphaToOneEnable updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineMultisampleStateCreateInfo) WithAlphaToOneEnable(y Bool32) PipelineMultisampleStateCreateInfo {
	x.alphaToOneEnable = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PipelineMultisampleStateCreateInfo) SetAlphaToOneEnable(y Bool32) {
	x.alphaToOneEnable = *( /* typedef */ (*C.VkBool32)(&y))
}

// PipelineRasterizationStateCreateInfo provides a go interface for VkPipelineRasterizationStateCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationStateCreateInfo.html
type PipelineRasterizationStateCreateInfo C.struct_VkPipelineRasterizationStateCreateInfo

// SizeofPipelineRasterizationStateCreateInfo is the memory size of a PipelineRasterizationStateCreateInfo
var SizeofPipelineRasterizationStateCreateInfo int = int(unsafe.Sizeof(PipelineRasterizationStateCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PipelineRasterizationStateCreateInfo) ArpPtr(arp *AutoReleasePool) *PipelineRasterizationStateCreateInfo {
	ptr := newCBlock(cULong(SizeofPipelineRasterizationStateCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PipelineRasterizationStateCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineRasterizationStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineRasterizationStateCreateInfo) AsCPtr() *PipelineRasterizationStateCreateInfo {
	clone := (*PipelineRasterizationStateCreateInfo)(newCBlock(cULong(SizeofPipelineRasterizationStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineRasterizationStateCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PipelineRasterizationStateCreateInfoCSlice(arp *AutoReleasePool, x ...PipelineRasterizationStateCreateInfo) []PipelineRasterizationStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineRasterizationStateCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PipelineRasterizationStateCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PipelineRasterizationStateCreateInfoFreeCSlice releases the memory allocated by PipelineRasterizationStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineRasterizationStateCreateInfoFreeCSlice(x []PipelineRasterizationStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineRasterizationStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineRasterizationStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineRasterizationStateCreateInfoMakeCSlice(x ...PipelineRasterizationStateCreateInfo) []PipelineRasterizationStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineRasterizationStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineRasterizationStateCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PipelineRasterizationStateCreateInfo with the value of
// SType to the value provided in the specification.
func (x PipelineRasterizationStateCreateInfo) WithDefaultSType() PipelineRasterizationStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PipelineRasterizationStateCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO)
}

// WithSType clones a new PipelineRasterizationStateCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithSType(y StructureType) PipelineRasterizationStateCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PipelineRasterizationStateCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PipelineRasterizationStateCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineRasterizationStateCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PipelineRasterizationStateCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) Flags() PipelineRasterizationStateCreateFlags {
	ptr := /* typedef */ (*PipelineRasterizationStateCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new PipelineRasterizationStateCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithFlags(y PipelineRasterizationStateCreateFlags) PipelineRasterizationStateCreateInfo {
	x.flags = *( /* typedef */ (*C.VkPipelineRasterizationStateCreateFlags)(&y))
	return x
}
func (x *PipelineRasterizationStateCreateInfo) SetFlags(y PipelineRasterizationStateCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkPipelineRasterizationStateCreateFlags)(&y))
}

// DepthClampEnable returns the value of depthClampEnable from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) DepthClampEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.depthClampEnable)
	return *ptr
}

// WithDepthClampEnable clones a new PipelineRasterizationStateCreateInfo with the value of
// DepthClampEnable updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithDepthClampEnable(y Bool32) PipelineRasterizationStateCreateInfo {
	x.depthClampEnable = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PipelineRasterizationStateCreateInfo) SetDepthClampEnable(y Bool32) {
	x.depthClampEnable = *( /* typedef */ (*C.VkBool32)(&y))
}

// RasterizerDiscardEnable returns the value of rasterizerDiscardEnable from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) RasterizerDiscardEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.rasterizerDiscardEnable)
	return *ptr
}

// WithRasterizerDiscardEnable clones a new PipelineRasterizationStateCreateInfo with the value of
// RasterizerDiscardEnable updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithRasterizerDiscardEnable(y Bool32) PipelineRasterizationStateCreateInfo {
	x.rasterizerDiscardEnable = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PipelineRasterizationStateCreateInfo) SetRasterizerDiscardEnable(y Bool32) {
	x.rasterizerDiscardEnable = *( /* typedef */ (*C.VkBool32)(&y))
}

// PolygonMode returns the value of polygonMode from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) PolygonMode() PolygonMode {
	ptr := /* typedef */ (*PolygonMode)(&x.polygonMode)
	return *ptr
}

// WithPolygonMode clones a new PipelineRasterizationStateCreateInfo with the value of
// PolygonMode updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithPolygonMode(y PolygonMode) PipelineRasterizationStateCreateInfo {
	x.polygonMode = *( /* typedef */ (*C.VkPolygonMode)(&y))
	return x
}
func (x *PipelineRasterizationStateCreateInfo) SetPolygonMode(y PolygonMode) {
	x.polygonMode = *( /* typedef */ (*C.VkPolygonMode)(&y))
}

// CullMode returns the value of cullMode from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) CullMode() CullModeFlags {
	ptr := /* typedef */ (*CullModeFlags)(&x.cullMode)
	return *ptr
}

// WithCullMode clones a new PipelineRasterizationStateCreateInfo with the value of
// CullMode updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithCullMode(y CullModeFlags) PipelineRasterizationStateCreateInfo {
	x.cullMode = *( /* typedef */ (*C.VkCullModeFlags)(&y))
	return x
}
func (x *PipelineRasterizationStateCreateInfo) SetCullMode(y CullModeFlags) {
	x.cullMode = *( /* typedef */ (*C.VkCullModeFlags)(&y))
}

// FrontFace returns the value of frontFace from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) FrontFace() FrontFace {
	ptr := /* typedef */ (*FrontFace)(&x.frontFace)
	return *ptr
}

// WithFrontFace clones a new PipelineRasterizationStateCreateInfo with the value of
// FrontFace updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithFrontFace(y FrontFace) PipelineRasterizationStateCreateInfo {
	x.frontFace = *( /* typedef */ (*C.VkFrontFace)(&y))
	return x
}
func (x *PipelineRasterizationStateCreateInfo) SetFrontFace(y FrontFace) {
	x.frontFace = *( /* typedef */ (*C.VkFrontFace)(&y))
}

// DepthBiasEnable returns the value of depthBiasEnable from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) DepthBiasEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.depthBiasEnable)
	return *ptr
}

// WithDepthBiasEnable clones a new PipelineRasterizationStateCreateInfo with the value of
// DepthBiasEnable updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithDepthBiasEnable(y Bool32) PipelineRasterizationStateCreateInfo {
	x.depthBiasEnable = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PipelineRasterizationStateCreateInfo) SetDepthBiasEnable(y Bool32) {
	x.depthBiasEnable = *( /* typedef */ (*C.VkBool32)(&y))
}

// DepthBiasConstantFactor returns the value of depthBiasConstantFactor from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) DepthBiasConstantFactor() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.depthBiasConstantFactor)
	return *ptr
}

// WithDepthBiasConstantFactor clones a new PipelineRasterizationStateCreateInfo with the value of
// DepthBiasConstantFactor updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithDepthBiasConstantFactor(y float32) PipelineRasterizationStateCreateInfo {
	x.depthBiasConstantFactor = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}
func (x *PipelineRasterizationStateCreateInfo) SetDepthBiasConstantFactor(y float32) {
	x.depthBiasConstantFactor = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
}

// DepthBiasClamp returns the value of depthBiasClamp from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) DepthBiasClamp() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.depthBiasClamp)
	return *ptr
}

// WithDepthBiasClamp clones a new PipelineRasterizationStateCreateInfo with the value of
// DepthBiasClamp updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithDepthBiasClamp(y float32) PipelineRasterizationStateCreateInfo {
	x.depthBiasClamp = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}
func (x *PipelineRasterizationStateCreateInfo) SetDepthBiasClamp(y float32) {
	x.depthBiasClamp = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
}

// DepthBiasSlopeFactor returns the value of depthBiasSlopeFactor from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) DepthBiasSlopeFactor() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.depthBiasSlopeFactor)
	return *ptr
}

// WithDepthBiasSlopeFactor clones a new PipelineRasterizationStateCreateInfo with the value of
// DepthBiasSlopeFactor updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithDepthBiasSlopeFactor(y float32) PipelineRasterizationStateCreateInfo {
	x.depthBiasSlopeFactor = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}
func (x *PipelineRasterizationStateCreateInfo) SetDepthBiasSlopeFactor(y float32) {
	x.depthBiasSlopeFactor = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
}

// LineWidth returns the value of lineWidth from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) LineWidth() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.lineWidth)
	return *ptr
}

// WithLineWidth clones a new PipelineRasterizationStateCreateInfo with the value of
// LineWidth updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithLineWidth(y float32) PipelineRasterizationStateCreateInfo {
	x.lineWidth = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}
func (x *PipelineRasterizationStateCreateInfo) SetLineWidth(y float32) {
	x.lineWidth = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
}

// Viewport provides a go interface for VkViewport.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkViewport.html
type Viewport C.struct_VkViewport

// SizeofViewport is the memory size of a Viewport
var SizeofViewport int = int(unsafe.Sizeof(Viewport{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x Viewport) ArpPtr(arp *AutoReleasePool) *Viewport {
	ptr := newCBlock(cULong(SizeofViewport))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*Viewport)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *Viewport) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x Viewport) AsCPtr() *Viewport {
	clone := (*Viewport)(newCBlock(cULong(SizeofViewport)))
	*clone = x
	return clone
}

// ViewportCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ViewportCSlice(arp *AutoReleasePool, x ...Viewport) []Viewport {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofViewport * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*Viewport)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ViewportFreeCSlice releases the memory allocated by ViewportMakeCSlice.
// It does not free pointers stored inside the slice.
func ViewportFreeCSlice(x []Viewport) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ViewportMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ViewportFreeCSlice must be called on the returned slice.
func ViewportMakeCSlice(x ...Viewport) []Viewport {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofViewport * len(x)
	dst := unsafe.Slice((*Viewport)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// X returns the value of x from VkViewport
func (x Viewport) X() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.x)
	return *ptr
}

// WithX clones a new Viewport with the value of
// X updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Viewport) WithX(y float32) Viewport {
	x.x = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}
func (x *Viewport) SetX(y float32) {
	x.x = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
}

// Y returns the value of y from VkViewport
func (x Viewport) Y() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.y)
	return *ptr
}

// WithY clones a new Viewport with the value of
// Y updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Viewport) WithY(y float32) Viewport {
	x.y = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}
func (x *Viewport) SetY(y float32) {
	x.y = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
}

// Width returns the value of width from VkViewport
func (x Viewport) Width() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.width)
	return *ptr
}

// WithWidth clones a new Viewport with the value of
// Width updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Viewport) WithWidth(y float32) Viewport {
	x.width = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}
func (x *Viewport) SetWidth(y float32) {
	x.width = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
}

// Height returns the value of height from VkViewport
func (x Viewport) Height() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.height)
	return *ptr
}

// WithHeight clones a new Viewport with the value of
// Height updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Viewport) WithHeight(y float32) Viewport {
	x.height = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}
func (x *Viewport) SetHeight(y float32) {
	x.height = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
}

// MinDepth returns the value of minDepth from VkViewport
func (x Viewport) MinDepth() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.minDepth)
	return *ptr
}

// WithMinDepth clones a new Viewport with the value of
// MinDepth updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Viewport) WithMinDepth(y float32) Viewport {
	x.minDepth = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}
func (x *Viewport) SetMinDepth(y float32) {
	x.minDepth = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
}

// MaxDepth returns the value of maxDepth from VkViewport
func (x Viewport) MaxDepth() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.maxDepth)
	return *ptr
}

// WithMaxDepth clones a new Viewport with the value of
// MaxDepth updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Viewport) WithMaxDepth(y float32) Viewport {
	x.maxDepth = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}
func (x *Viewport) SetMaxDepth(y float32) {
	x.maxDepth = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
}

// PipelineViewportStateCreateInfo provides a go interface for VkPipelineViewportStateCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportStateCreateInfo.html
type PipelineViewportStateCreateInfo C.struct_VkPipelineViewportStateCreateInfo

// SizeofPipelineViewportStateCreateInfo is the memory size of a PipelineViewportStateCreateInfo
var SizeofPipelineViewportStateCreateInfo int = int(unsafe.Sizeof(PipelineViewportStateCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PipelineViewportStateCreateInfo) ArpPtr(arp *AutoReleasePool) *PipelineViewportStateCreateInfo {
	ptr := newCBlock(cULong(SizeofPipelineViewportStateCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PipelineViewportStateCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineViewportStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineViewportStateCreateInfo) AsCPtr() *PipelineViewportStateCreateInfo {
	clone := (*PipelineViewportStateCreateInfo)(newCBlock(cULong(SizeofPipelineViewportStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineViewportStateCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PipelineViewportStateCreateInfoCSlice(arp *AutoReleasePool, x ...PipelineViewportStateCreateInfo) []PipelineViewportStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineViewportStateCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PipelineViewportStateCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PipelineViewportStateCreateInfoFreeCSlice releases the memory allocated by PipelineViewportStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineViewportStateCreateInfoFreeCSlice(x []PipelineViewportStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineViewportStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineViewportStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineViewportStateCreateInfoMakeCSlice(x ...PipelineViewportStateCreateInfo) []PipelineViewportStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineViewportStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineViewportStateCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineViewportStateCreateInfo
func (x PipelineViewportStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PipelineViewportStateCreateInfo with the value of
// SType to the value provided in the specification.
func (x PipelineViewportStateCreateInfo) WithDefaultSType() PipelineViewportStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PipelineViewportStateCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO)
}

// WithSType clones a new PipelineViewportStateCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineViewportStateCreateInfo) WithSType(y StructureType) PipelineViewportStateCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PipelineViewportStateCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPipelineViewportStateCreateInfo
func (x PipelineViewportStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PipelineViewportStateCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineViewportStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineViewportStateCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PipelineViewportStateCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkPipelineViewportStateCreateInfo
func (x PipelineViewportStateCreateInfo) Flags() PipelineViewportStateCreateFlags {
	ptr := /* typedef */ (*PipelineViewportStateCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new PipelineViewportStateCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineViewportStateCreateInfo) WithFlags(y PipelineViewportStateCreateFlags) PipelineViewportStateCreateInfo {
	x.flags = *( /* typedef */ (*C.VkPipelineViewportStateCreateFlags)(&y))
	return x
}
func (x *PipelineViewportStateCreateInfo) SetFlags(y PipelineViewportStateCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkPipelineViewportStateCreateFlags)(&y))
}

// ViewportCount returns the value of viewportCount from VkPipelineViewportStateCreateInfo
func (x PipelineViewportStateCreateInfo) ViewportCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.viewportCount)
	return *ptr
}

// WithViewportCount clones a new PipelineViewportStateCreateInfo with the value of
// ViewportCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineViewportStateCreateInfo) WithViewportCount(y uint32) PipelineViewportStateCreateInfo {
	x.viewportCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *PipelineViewportStateCreateInfo) SetViewportCount(y uint32) {
	x.viewportCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PViewports returns the value of pViewports from VkPipelineViewportStateCreateInfo
func (x PipelineViewportStateCreateInfo) PViewports() []Viewport {
	ptr := func(x **C.struct_VkViewport) *[]Viewport { /* Slice */
		slc := unsafe.Slice((*Viewport)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pViewports)
	return *ptr
}

// WithPViewports clones a new PipelineViewportStateCreateInfo with the value of
// PViewports updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines ViewportCount as the length of this field.
// ViewportCount is updated with the length of the new value.
func (x PipelineViewportStateCreateInfo) WithPViewports(y []Viewport) PipelineViewportStateCreateInfo {
	x.pViewports = *(func(x *[]Viewport) **C.struct_VkViewport { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkViewport)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkViewport)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithViewportCount(uint32(len(y)))
}
func (x *PipelineViewportStateCreateInfo) SetPViewports(y []Viewport) {
	x.pViewports = *(func(x *[]Viewport) **C.struct_VkViewport { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkViewport)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkViewport)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetViewportCount(uint32(len(y)))
}

// ScissorCount returns the value of scissorCount from VkPipelineViewportStateCreateInfo
func (x PipelineViewportStateCreateInfo) ScissorCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.scissorCount)
	return *ptr
}

// WithScissorCount clones a new PipelineViewportStateCreateInfo with the value of
// ScissorCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineViewportStateCreateInfo) WithScissorCount(y uint32) PipelineViewportStateCreateInfo {
	x.scissorCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *PipelineViewportStateCreateInfo) SetScissorCount(y uint32) {
	x.scissorCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PScissors returns the value of pScissors from VkPipelineViewportStateCreateInfo
func (x PipelineViewportStateCreateInfo) PScissors() []Rect2D {
	ptr := func(x **C.struct_VkRect2D) *[]Rect2D { /* Slice */
		slc := unsafe.Slice((*Rect2D)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pScissors)
	return *ptr
}

// WithPScissors clones a new PipelineViewportStateCreateInfo with the value of
// PScissors updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines ScissorCount as the length of this field.
// ScissorCount is updated with the length of the new value.
func (x PipelineViewportStateCreateInfo) WithPScissors(y []Rect2D) PipelineViewportStateCreateInfo {
	x.pScissors = *(func(x *[]Rect2D) **C.struct_VkRect2D { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkRect2D)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkRect2D)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithScissorCount(uint32(len(y)))
}
func (x *PipelineViewportStateCreateInfo) SetPScissors(y []Rect2D) {
	x.pScissors = *(func(x *[]Rect2D) **C.struct_VkRect2D { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkRect2D)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkRect2D)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetScissorCount(uint32(len(y)))
}

// PipelineTessellationStateCreateInfo provides a go interface for VkPipelineTessellationStateCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineTessellationStateCreateInfo.html
type PipelineTessellationStateCreateInfo C.struct_VkPipelineTessellationStateCreateInfo

// SizeofPipelineTessellationStateCreateInfo is the memory size of a PipelineTessellationStateCreateInfo
var SizeofPipelineTessellationStateCreateInfo int = int(unsafe.Sizeof(PipelineTessellationStateCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PipelineTessellationStateCreateInfo) ArpPtr(arp *AutoReleasePool) *PipelineTessellationStateCreateInfo {
	ptr := newCBlock(cULong(SizeofPipelineTessellationStateCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PipelineTessellationStateCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineTessellationStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineTessellationStateCreateInfo) AsCPtr() *PipelineTessellationStateCreateInfo {
	clone := (*PipelineTessellationStateCreateInfo)(newCBlock(cULong(SizeofPipelineTessellationStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineTessellationStateCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PipelineTessellationStateCreateInfoCSlice(arp *AutoReleasePool, x ...PipelineTessellationStateCreateInfo) []PipelineTessellationStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineTessellationStateCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PipelineTessellationStateCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PipelineTessellationStateCreateInfoFreeCSlice releases the memory allocated by PipelineTessellationStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineTessellationStateCreateInfoFreeCSlice(x []PipelineTessellationStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineTessellationStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineTessellationStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineTessellationStateCreateInfoMakeCSlice(x ...PipelineTessellationStateCreateInfo) []PipelineTessellationStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineTessellationStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineTessellationStateCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineTessellationStateCreateInfo
func (x PipelineTessellationStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PipelineTessellationStateCreateInfo with the value of
// SType to the value provided in the specification.
func (x PipelineTessellationStateCreateInfo) WithDefaultSType() PipelineTessellationStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PipelineTessellationStateCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO)
}

// WithSType clones a new PipelineTessellationStateCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineTessellationStateCreateInfo) WithSType(y StructureType) PipelineTessellationStateCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PipelineTessellationStateCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPipelineTessellationStateCreateInfo
func (x PipelineTessellationStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PipelineTessellationStateCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineTessellationStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineTessellationStateCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PipelineTessellationStateCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkPipelineTessellationStateCreateInfo
func (x PipelineTessellationStateCreateInfo) Flags() PipelineTessellationStateCreateFlags {
	ptr := /* typedef */ (*PipelineTessellationStateCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new PipelineTessellationStateCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineTessellationStateCreateInfo) WithFlags(y PipelineTessellationStateCreateFlags) PipelineTessellationStateCreateInfo {
	x.flags = *( /* typedef */ (*C.VkPipelineTessellationStateCreateFlags)(&y))
	return x
}
func (x *PipelineTessellationStateCreateInfo) SetFlags(y PipelineTessellationStateCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkPipelineTessellationStateCreateFlags)(&y))
}

// PatchControlPoints returns the value of patchControlPoints from VkPipelineTessellationStateCreateInfo
func (x PipelineTessellationStateCreateInfo) PatchControlPoints() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.patchControlPoints)
	return *ptr
}

// WithPatchControlPoints clones a new PipelineTessellationStateCreateInfo with the value of
// PatchControlPoints updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineTessellationStateCreateInfo) WithPatchControlPoints(y uint32) PipelineTessellationStateCreateInfo {
	x.patchControlPoints = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *PipelineTessellationStateCreateInfo) SetPatchControlPoints(y uint32) {
	x.patchControlPoints = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PipelineInputAssemblyStateCreateInfo provides a go interface for VkPipelineInputAssemblyStateCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineInputAssemblyStateCreateInfo.html
type PipelineInputAssemblyStateCreateInfo C.struct_VkPipelineInputAssemblyStateCreateInfo

// SizeofPipelineInputAssemblyStateCreateInfo is the memory size of a PipelineInputAssemblyStateCreateInfo
var SizeofPipelineInputAssemblyStateCreateInfo int = int(unsafe.Sizeof(PipelineInputAssemblyStateCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PipelineInputAssemblyStateCreateInfo) ArpPtr(arp *AutoReleasePool) *PipelineInputAssemblyStateCreateInfo {
	ptr := newCBlock(cULong(SizeofPipelineInputAssemblyStateCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PipelineInputAssemblyStateCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineInputAssemblyStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineInputAssemblyStateCreateInfo) AsCPtr() *PipelineInputAssemblyStateCreateInfo {
	clone := (*PipelineInputAssemblyStateCreateInfo)(newCBlock(cULong(SizeofPipelineInputAssemblyStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineInputAssemblyStateCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PipelineInputAssemblyStateCreateInfoCSlice(arp *AutoReleasePool, x ...PipelineInputAssemblyStateCreateInfo) []PipelineInputAssemblyStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineInputAssemblyStateCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PipelineInputAssemblyStateCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PipelineInputAssemblyStateCreateInfoFreeCSlice releases the memory allocated by PipelineInputAssemblyStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineInputAssemblyStateCreateInfoFreeCSlice(x []PipelineInputAssemblyStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineInputAssemblyStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineInputAssemblyStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineInputAssemblyStateCreateInfoMakeCSlice(x ...PipelineInputAssemblyStateCreateInfo) []PipelineInputAssemblyStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineInputAssemblyStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineInputAssemblyStateCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineInputAssemblyStateCreateInfo
func (x PipelineInputAssemblyStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PipelineInputAssemblyStateCreateInfo with the value of
// SType to the value provided in the specification.
func (x PipelineInputAssemblyStateCreateInfo) WithDefaultSType() PipelineInputAssemblyStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PipelineInputAssemblyStateCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO)
}

// WithSType clones a new PipelineInputAssemblyStateCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineInputAssemblyStateCreateInfo) WithSType(y StructureType) PipelineInputAssemblyStateCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PipelineInputAssemblyStateCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPipelineInputAssemblyStateCreateInfo
func (x PipelineInputAssemblyStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PipelineInputAssemblyStateCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineInputAssemblyStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineInputAssemblyStateCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PipelineInputAssemblyStateCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkPipelineInputAssemblyStateCreateInfo
func (x PipelineInputAssemblyStateCreateInfo) Flags() PipelineInputAssemblyStateCreateFlags {
	ptr := /* typedef */ (*PipelineInputAssemblyStateCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new PipelineInputAssemblyStateCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineInputAssemblyStateCreateInfo) WithFlags(y PipelineInputAssemblyStateCreateFlags) PipelineInputAssemblyStateCreateInfo {
	x.flags = *( /* typedef */ (*C.VkPipelineInputAssemblyStateCreateFlags)(&y))
	return x
}
func (x *PipelineInputAssemblyStateCreateInfo) SetFlags(y PipelineInputAssemblyStateCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkPipelineInputAssemblyStateCreateFlags)(&y))
}

// Topology returns the value of topology from VkPipelineInputAssemblyStateCreateInfo
func (x PipelineInputAssemblyStateCreateInfo) Topology() PrimitiveTopology {
	ptr := /* typedef */ (*PrimitiveTopology)(&x.topology)
	return *ptr
}

// WithTopology clones a new PipelineInputAssemblyStateCreateInfo with the value of
// Topology updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineInputAssemblyStateCreateInfo) WithTopology(y PrimitiveTopology) PipelineInputAssemblyStateCreateInfo {
	x.topology = *( /* typedef */ (*C.VkPrimitiveTopology)(&y))
	return x
}
func (x *PipelineInputAssemblyStateCreateInfo) SetTopology(y PrimitiveTopology) {
	x.topology = *( /* typedef */ (*C.VkPrimitiveTopology)(&y))
}

// PrimitiveRestartEnable returns the value of primitiveRestartEnable from VkPipelineInputAssemblyStateCreateInfo
func (x PipelineInputAssemblyStateCreateInfo) PrimitiveRestartEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.primitiveRestartEnable)
	return *ptr
}

// WithPrimitiveRestartEnable clones a new PipelineInputAssemblyStateCreateInfo with the value of
// PrimitiveRestartEnable updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineInputAssemblyStateCreateInfo) WithPrimitiveRestartEnable(y Bool32) PipelineInputAssemblyStateCreateInfo {
	x.primitiveRestartEnable = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PipelineInputAssemblyStateCreateInfo) SetPrimitiveRestartEnable(y Bool32) {
	x.primitiveRestartEnable = *( /* typedef */ (*C.VkBool32)(&y))
}

// VertexInputBindingDescription provides a go interface for VkVertexInputBindingDescription.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVertexInputBindingDescription.html
type VertexInputBindingDescription C.struct_VkVertexInputBindingDescription

// SizeofVertexInputBindingDescription is the memory size of a VertexInputBindingDescription
var SizeofVertexInputBindingDescription int = int(unsafe.Sizeof(VertexInputBindingDescription{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x VertexInputBindingDescription) ArpPtr(arp *AutoReleasePool) *VertexInputBindingDescription {
	ptr := newCBlock(cULong(SizeofVertexInputBindingDescription))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*VertexInputBindingDescription)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *VertexInputBindingDescription) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x VertexInputBindingDescription) AsCPtr() *VertexInputBindingDescription {
	clone := (*VertexInputBindingDescription)(newCBlock(cULong(SizeofVertexInputBindingDescription)))
	*clone = x
	return clone
}

// VertexInputBindingDescriptionCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func VertexInputBindingDescriptionCSlice(arp *AutoReleasePool, x ...VertexInputBindingDescription) []VertexInputBindingDescription {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofVertexInputBindingDescription * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*VertexInputBindingDescription)(ptr), len(x))
	copy(dst, x)
	return dst
}

// VertexInputBindingDescriptionFreeCSlice releases the memory allocated by VertexInputBindingDescriptionMakeCSlice.
// It does not free pointers stored inside the slice.
func VertexInputBindingDescriptionFreeCSlice(x []VertexInputBindingDescription) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// VertexInputBindingDescriptionMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. VertexInputBindingDescriptionFreeCSlice must be called on the returned slice.
func VertexInputBindingDescriptionMakeCSlice(x ...VertexInputBindingDescription) []VertexInputBindingDescription {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofVertexInputBindingDescription * len(x)
	dst := unsafe.Slice((*VertexInputBindingDescription)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Binding returns the value of binding from VkVertexInputBindingDescription
func (x VertexInputBindingDescription) Binding() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.binding)
	return *ptr
}

// WithBinding clones a new VertexInputBindingDescription with the value of
// Binding updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x VertexInputBindingDescription) WithBinding(y uint32) VertexInputBindingDescription {
	x.binding = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *VertexInputBindingDescription) SetBinding(y uint32) {
	x.binding = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// Stride returns the value of stride from VkVertexInputBindingDescription
func (x VertexInputBindingDescription) Stride() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.stride)
	return *ptr
}

// WithStride clones a new VertexInputBindingDescription with the value of
// Stride updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x VertexInputBindingDescription) WithStride(y uint32) VertexInputBindingDescription {
	x.stride = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *VertexInputBindingDescription) SetStride(y uint32) {
	x.stride = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// InputRate returns the value of inputRate from VkVertexInputBindingDescription
func (x VertexInputBindingDescription) InputRate() VertexInputRate {
	ptr := /* typedef */ (*VertexInputRate)(&x.inputRate)
	return *ptr
}

// WithInputRate clones a new VertexInputBindingDescription with the value of
// InputRate updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x VertexInputBindingDescription) WithInputRate(y VertexInputRate) VertexInputBindingDescription {
	x.inputRate = *( /* typedef */ (*C.VkVertexInputRate)(&y))
	return x
}
func (x *VertexInputBindingDescription) SetInputRate(y VertexInputRate) {
	x.inputRate = *( /* typedef */ (*C.VkVertexInputRate)(&y))
}

// VertexInputAttributeDescription provides a go interface for VkVertexInputAttributeDescription.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVertexInputAttributeDescription.html
type VertexInputAttributeDescription C.struct_VkVertexInputAttributeDescription

// SizeofVertexInputAttributeDescription is the memory size of a VertexInputAttributeDescription
var SizeofVertexInputAttributeDescription int = int(unsafe.Sizeof(VertexInputAttributeDescription{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x VertexInputAttributeDescription) ArpPtr(arp *AutoReleasePool) *VertexInputAttributeDescription {
	ptr := newCBlock(cULong(SizeofVertexInputAttributeDescription))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*VertexInputAttributeDescription)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *VertexInputAttributeDescription) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x VertexInputAttributeDescription) AsCPtr() *VertexInputAttributeDescription {
	clone := (*VertexInputAttributeDescription)(newCBlock(cULong(SizeofVertexInputAttributeDescription)))
	*clone = x
	return clone
}

// VertexInputAttributeDescriptionCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func VertexInputAttributeDescriptionCSlice(arp *AutoReleasePool, x ...VertexInputAttributeDescription) []VertexInputAttributeDescription {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofVertexInputAttributeDescription * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*VertexInputAttributeDescription)(ptr), len(x))
	copy(dst, x)
	return dst
}

// VertexInputAttributeDescriptionFreeCSlice releases the memory allocated by VertexInputAttributeDescriptionMakeCSlice.
// It does not free pointers stored inside the slice.
func VertexInputAttributeDescriptionFreeCSlice(x []VertexInputAttributeDescription) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// VertexInputAttributeDescriptionMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. VertexInputAttributeDescriptionFreeCSlice must be called on the returned slice.
func VertexInputAttributeDescriptionMakeCSlice(x ...VertexInputAttributeDescription) []VertexInputAttributeDescription {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofVertexInputAttributeDescription * len(x)
	dst := unsafe.Slice((*VertexInputAttributeDescription)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Location returns the value of location from VkVertexInputAttributeDescription
func (x VertexInputAttributeDescription) Location() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.location)
	return *ptr
}

// WithLocation clones a new VertexInputAttributeDescription with the value of
// Location updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x VertexInputAttributeDescription) WithLocation(y uint32) VertexInputAttributeDescription {
	x.location = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *VertexInputAttributeDescription) SetLocation(y uint32) {
	x.location = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// Binding returns the value of binding from VkVertexInputAttributeDescription
func (x VertexInputAttributeDescription) Binding() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.binding)
	return *ptr
}

// WithBinding clones a new VertexInputAttributeDescription with the value of
// Binding updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x VertexInputAttributeDescription) WithBinding(y uint32) VertexInputAttributeDescription {
	x.binding = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *VertexInputAttributeDescription) SetBinding(y uint32) {
	x.binding = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// Format returns the value of format from VkVertexInputAttributeDescription
func (x VertexInputAttributeDescription) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format)
	return *ptr
}

// WithFormat clones a new VertexInputAttributeDescription with the value of
// Format updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x VertexInputAttributeDescription) WithFormat(y Format) VertexInputAttributeDescription {
	x.format = *( /* typedef */ (*C.VkFormat)(&y))
	return x
}
func (x *VertexInputAttributeDescription) SetFormat(y Format) {
	x.format = *( /* typedef */ (*C.VkFormat)(&y))
}

// Offset returns the value of offset from VkVertexInputAttributeDescription
func (x VertexInputAttributeDescription) Offset() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.offset)
	return *ptr
}

// WithOffset clones a new VertexInputAttributeDescription with the value of
// Offset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x VertexInputAttributeDescription) WithOffset(y uint32) VertexInputAttributeDescription {
	x.offset = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *VertexInputAttributeDescription) SetOffset(y uint32) {
	x.offset = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PipelineVertexInputStateCreateInfo provides a go interface for VkPipelineVertexInputStateCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineVertexInputStateCreateInfo.html
type PipelineVertexInputStateCreateInfo C.struct_VkPipelineVertexInputStateCreateInfo

// SizeofPipelineVertexInputStateCreateInfo is the memory size of a PipelineVertexInputStateCreateInfo
var SizeofPipelineVertexInputStateCreateInfo int = int(unsafe.Sizeof(PipelineVertexInputStateCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PipelineVertexInputStateCreateInfo) ArpPtr(arp *AutoReleasePool) *PipelineVertexInputStateCreateInfo {
	ptr := newCBlock(cULong(SizeofPipelineVertexInputStateCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PipelineVertexInputStateCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineVertexInputStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineVertexInputStateCreateInfo) AsCPtr() *PipelineVertexInputStateCreateInfo {
	clone := (*PipelineVertexInputStateCreateInfo)(newCBlock(cULong(SizeofPipelineVertexInputStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineVertexInputStateCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PipelineVertexInputStateCreateInfoCSlice(arp *AutoReleasePool, x ...PipelineVertexInputStateCreateInfo) []PipelineVertexInputStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineVertexInputStateCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PipelineVertexInputStateCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PipelineVertexInputStateCreateInfoFreeCSlice releases the memory allocated by PipelineVertexInputStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineVertexInputStateCreateInfoFreeCSlice(x []PipelineVertexInputStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineVertexInputStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineVertexInputStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineVertexInputStateCreateInfoMakeCSlice(x ...PipelineVertexInputStateCreateInfo) []PipelineVertexInputStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineVertexInputStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineVertexInputStateCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineVertexInputStateCreateInfo
func (x PipelineVertexInputStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PipelineVertexInputStateCreateInfo with the value of
// SType to the value provided in the specification.
func (x PipelineVertexInputStateCreateInfo) WithDefaultSType() PipelineVertexInputStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PipelineVertexInputStateCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO)
}

// WithSType clones a new PipelineVertexInputStateCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineVertexInputStateCreateInfo) WithSType(y StructureType) PipelineVertexInputStateCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PipelineVertexInputStateCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPipelineVertexInputStateCreateInfo
func (x PipelineVertexInputStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PipelineVertexInputStateCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineVertexInputStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineVertexInputStateCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PipelineVertexInputStateCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkPipelineVertexInputStateCreateInfo
func (x PipelineVertexInputStateCreateInfo) Flags() PipelineVertexInputStateCreateFlags {
	ptr := /* typedef */ (*PipelineVertexInputStateCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new PipelineVertexInputStateCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineVertexInputStateCreateInfo) WithFlags(y PipelineVertexInputStateCreateFlags) PipelineVertexInputStateCreateInfo {
	x.flags = *( /* typedef */ (*C.VkPipelineVertexInputStateCreateFlags)(&y))
	return x
}
func (x *PipelineVertexInputStateCreateInfo) SetFlags(y PipelineVertexInputStateCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkPipelineVertexInputStateCreateFlags)(&y))
}

// VertexBindingDescriptionCount returns the value of vertexBindingDescriptionCount from VkPipelineVertexInputStateCreateInfo
func (x PipelineVertexInputStateCreateInfo) VertexBindingDescriptionCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.vertexBindingDescriptionCount)
	return *ptr
}

// WithVertexBindingDescriptionCount clones a new PipelineVertexInputStateCreateInfo with the value of
// VertexBindingDescriptionCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineVertexInputStateCreateInfo) WithVertexBindingDescriptionCount(y uint32) PipelineVertexInputStateCreateInfo {
	x.vertexBindingDescriptionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *PipelineVertexInputStateCreateInfo) SetVertexBindingDescriptionCount(y uint32) {
	x.vertexBindingDescriptionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PVertexBindingDescriptions returns the value of pVertexBindingDescriptions from VkPipelineVertexInputStateCreateInfo
func (x PipelineVertexInputStateCreateInfo) PVertexBindingDescriptions() []VertexInputBindingDescription {
	ptr := func(x **C.struct_VkVertexInputBindingDescription) *[]VertexInputBindingDescription { /* Slice */
		slc := unsafe.Slice((*VertexInputBindingDescription)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pVertexBindingDescriptions)
	return *ptr
}

// WithPVertexBindingDescriptions clones a new PipelineVertexInputStateCreateInfo with the value of
// PVertexBindingDescriptions updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines VertexBindingDescriptionCount as the length of this field.
// VertexBindingDescriptionCount is updated with the length of the new value.
func (x PipelineVertexInputStateCreateInfo) WithPVertexBindingDescriptions(y []VertexInputBindingDescription) PipelineVertexInputStateCreateInfo {
	x.pVertexBindingDescriptions = *(func(x *[]VertexInputBindingDescription) **C.struct_VkVertexInputBindingDescription { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkVertexInputBindingDescription)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkVertexInputBindingDescription)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithVertexBindingDescriptionCount(uint32(len(y)))
}
func (x *PipelineVertexInputStateCreateInfo) SetPVertexBindingDescriptions(y []VertexInputBindingDescription) {
	x.pVertexBindingDescriptions = *(func(x *[]VertexInputBindingDescription) **C.struct_VkVertexInputBindingDescription { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkVertexInputBindingDescription)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkVertexInputBindingDescription)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetVertexBindingDescriptionCount(uint32(len(y)))
}

// VertexAttributeDescriptionCount returns the value of vertexAttributeDescriptionCount from VkPipelineVertexInputStateCreateInfo
func (x PipelineVertexInputStateCreateInfo) VertexAttributeDescriptionCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.vertexAttributeDescriptionCount)
	return *ptr
}

// WithVertexAttributeDescriptionCount clones a new PipelineVertexInputStateCreateInfo with the value of
// VertexAttributeDescriptionCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineVertexInputStateCreateInfo) WithVertexAttributeDescriptionCount(y uint32) PipelineVertexInputStateCreateInfo {
	x.vertexAttributeDescriptionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *PipelineVertexInputStateCreateInfo) SetVertexAttributeDescriptionCount(y uint32) {
	x.vertexAttributeDescriptionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PVertexAttributeDescriptions returns the value of pVertexAttributeDescriptions from VkPipelineVertexInputStateCreateInfo
func (x PipelineVertexInputStateCreateInfo) PVertexAttributeDescriptions() []VertexInputAttributeDescription {
	ptr := func(x **C.struct_VkVertexInputAttributeDescription) *[]VertexInputAttributeDescription { /* Slice */
		slc := unsafe.Slice((*VertexInputAttributeDescription)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pVertexAttributeDescriptions)
	return *ptr
}

// WithPVertexAttributeDescriptions clones a new PipelineVertexInputStateCreateInfo with the value of
// PVertexAttributeDescriptions updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines VertexAttributeDescriptionCount as the length of this field.
// VertexAttributeDescriptionCount is updated with the length of the new value.
func (x PipelineVertexInputStateCreateInfo) WithPVertexAttributeDescriptions(y []VertexInputAttributeDescription) PipelineVertexInputStateCreateInfo {
	x.pVertexAttributeDescriptions = *(func(x *[]VertexInputAttributeDescription) **C.struct_VkVertexInputAttributeDescription { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkVertexInputAttributeDescription)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkVertexInputAttributeDescription)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithVertexAttributeDescriptionCount(uint32(len(y)))
}
func (x *PipelineVertexInputStateCreateInfo) SetPVertexAttributeDescriptions(y []VertexInputAttributeDescription) {
	x.pVertexAttributeDescriptions = *(func(x *[]VertexInputAttributeDescription) **C.struct_VkVertexInputAttributeDescription { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkVertexInputAttributeDescription)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkVertexInputAttributeDescription)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetVertexAttributeDescriptionCount(uint32(len(y)))
}

// GraphicsPipelineCreateInfo provides a go interface for VkGraphicsPipelineCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGraphicsPipelineCreateInfo.html
type GraphicsPipelineCreateInfo C.struct_VkGraphicsPipelineCreateInfo

// SizeofGraphicsPipelineCreateInfo is the memory size of a GraphicsPipelineCreateInfo
var SizeofGraphicsPipelineCreateInfo int = int(unsafe.Sizeof(GraphicsPipelineCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x GraphicsPipelineCreateInfo) ArpPtr(arp *AutoReleasePool) *GraphicsPipelineCreateInfo {
	ptr := newCBlock(cULong(SizeofGraphicsPipelineCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*GraphicsPipelineCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *GraphicsPipelineCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x GraphicsPipelineCreateInfo) AsCPtr() *GraphicsPipelineCreateInfo {
	clone := (*GraphicsPipelineCreateInfo)(newCBlock(cULong(SizeofGraphicsPipelineCreateInfo)))
	*clone = x
	return clone
}

// GraphicsPipelineCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func GraphicsPipelineCreateInfoCSlice(arp *AutoReleasePool, x ...GraphicsPipelineCreateInfo) []GraphicsPipelineCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofGraphicsPipelineCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*GraphicsPipelineCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// GraphicsPipelineCreateInfoFreeCSlice releases the memory allocated by GraphicsPipelineCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func GraphicsPipelineCreateInfoFreeCSlice(x []GraphicsPipelineCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// GraphicsPipelineCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. GraphicsPipelineCreateInfoFreeCSlice must be called on the returned slice.
func GraphicsPipelineCreateInfoMakeCSlice(x ...GraphicsPipelineCreateInfo) []GraphicsPipelineCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofGraphicsPipelineCreateInfo * len(x)
	dst := unsafe.Slice((*GraphicsPipelineCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new GraphicsPipelineCreateInfo with the value of
// SType to the value provided in the specification.
func (x GraphicsPipelineCreateInfo) WithDefaultSType() GraphicsPipelineCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *GraphicsPipelineCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO)
}

// WithSType clones a new GraphicsPipelineCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithSType(y StructureType) GraphicsPipelineCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *GraphicsPipelineCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new GraphicsPipelineCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPNext(y unsafe.Pointer) GraphicsPipelineCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *GraphicsPipelineCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) Flags() PipelineCreateFlags {
	ptr := /* typedef */ (*PipelineCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new GraphicsPipelineCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithFlags(y PipelineCreateFlags) GraphicsPipelineCreateInfo {
	x.flags = *( /* typedef */ (*C.VkPipelineCreateFlags)(&y))
	return x
}
func (x *GraphicsPipelineCreateInfo) SetFlags(y PipelineCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkPipelineCreateFlags)(&y))
}

// StageCount returns the value of stageCount from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) StageCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.stageCount)
	return *ptr
}

// WithStageCount clones a new GraphicsPipelineCreateInfo with the value of
// StageCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithStageCount(y uint32) GraphicsPipelineCreateInfo {
	x.stageCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *GraphicsPipelineCreateInfo) SetStageCount(y uint32) {
	x.stageCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PStages returns the value of pStages from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PStages() []PipelineShaderStageCreateInfo {
	ptr := func(x **C.struct_VkPipelineShaderStageCreateInfo) *[]PipelineShaderStageCreateInfo { /* Slice */
		slc := unsafe.Slice((*PipelineShaderStageCreateInfo)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pStages)
	return *ptr
}

// WithPStages clones a new GraphicsPipelineCreateInfo with the value of
// PStages updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines StageCount as the length of this field.
// StageCount is updated with the length of the new value.
func (x GraphicsPipelineCreateInfo) WithPStages(y []PipelineShaderStageCreateInfo) GraphicsPipelineCreateInfo {
	x.pStages = *(func(x *[]PipelineShaderStageCreateInfo) **C.struct_VkPipelineShaderStageCreateInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkPipelineShaderStageCreateInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkPipelineShaderStageCreateInfo)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithStageCount(uint32(len(y)))
}
func (x *GraphicsPipelineCreateInfo) SetPStages(y []PipelineShaderStageCreateInfo) {
	x.pStages = *(func(x *[]PipelineShaderStageCreateInfo) **C.struct_VkPipelineShaderStageCreateInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkPipelineShaderStageCreateInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkPipelineShaderStageCreateInfo)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetStageCount(uint32(len(y)))
}

// PVertexInputState returns the value of pVertexInputState from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PVertexInputState() *PipelineVertexInputStateCreateInfo {
	ptr := func(x **C.struct_VkPipelineVertexInputStateCreateInfo) **PipelineVertexInputStateCreateInfo { /* Pointer */
		c2g := (*PipelineVertexInputStateCreateInfo)(*x)
		return &c2g
	}(&x.pVertexInputState)
	return *ptr
}

// WithPVertexInputState clones a new GraphicsPipelineCreateInfo with the value of
// PVertexInputState updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPVertexInputState(y *PipelineVertexInputStateCreateInfo) GraphicsPipelineCreateInfo {
	x.pVertexInputState = *(func(x **PipelineVertexInputStateCreateInfo) **C.struct_VkPipelineVertexInputStateCreateInfo { /* Pointer */
		g2c := (*C.struct_VkPipelineVertexInputStateCreateInfo)(*x)
		return &g2c
	}(&y))
	return x
}
func (x *GraphicsPipelineCreateInfo) SetPVertexInputState(y *PipelineVertexInputStateCreateInfo) {
	x.pVertexInputState = *(func(x **PipelineVertexInputStateCreateInfo) **C.struct_VkPipelineVertexInputStateCreateInfo { /* Pointer */
		g2c := (*C.struct_VkPipelineVertexInputStateCreateInfo)(*x)
		return &g2c
	}(&y))
}

// PInputAssemblyState returns the value of pInputAssemblyState from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PInputAssemblyState() *PipelineInputAssemblyStateCreateInfo {
	ptr := func(x **C.struct_VkPipelineInputAssemblyStateCreateInfo) **PipelineInputAssemblyStateCreateInfo { /* Pointer */
		c2g := (*PipelineInputAssemblyStateCreateInfo)(*x)
		return &c2g
	}(&x.pInputAssemblyState)
	return *ptr
}

// WithPInputAssemblyState clones a new GraphicsPipelineCreateInfo with the value of
// PInputAssemblyState updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPInputAssemblyState(y *PipelineInputAssemblyStateCreateInfo) GraphicsPipelineCreateInfo {
	x.pInputAssemblyState = *(func(x **PipelineInputAssemblyStateCreateInfo) **C.struct_VkPipelineInputAssemblyStateCreateInfo { /* Pointer */
		g2c := (*C.struct_VkPipelineInputAssemblyStateCreateInfo)(*x)
		return &g2c
	}(&y))
	return x
}
func (x *GraphicsPipelineCreateInfo) SetPInputAssemblyState(y *PipelineInputAssemblyStateCreateInfo) {
	x.pInputAssemblyState = *(func(x **PipelineInputAssemblyStateCreateInfo) **C.struct_VkPipelineInputAssemblyStateCreateInfo { /* Pointer */
		g2c := (*C.struct_VkPipelineInputAssemblyStateCreateInfo)(*x)
		return &g2c
	}(&y))
}

// PTessellationState returns the value of pTessellationState from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PTessellationState() *PipelineTessellationStateCreateInfo {
	ptr := func(x **C.struct_VkPipelineTessellationStateCreateInfo) **PipelineTessellationStateCreateInfo { /* Pointer */
		c2g := (*PipelineTessellationStateCreateInfo)(*x)
		return &c2g
	}(&x.pTessellationState)
	return *ptr
}

// WithPTessellationState clones a new GraphicsPipelineCreateInfo with the value of
// PTessellationState updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPTessellationState(y *PipelineTessellationStateCreateInfo) GraphicsPipelineCreateInfo {
	x.pTessellationState = *(func(x **PipelineTessellationStateCreateInfo) **C.struct_VkPipelineTessellationStateCreateInfo { /* Pointer */
		g2c := (*C.struct_VkPipelineTessellationStateCreateInfo)(*x)
		return &g2c
	}(&y))
	return x
}
func (x *GraphicsPipelineCreateInfo) SetPTessellationState(y *PipelineTessellationStateCreateInfo) {
	x.pTessellationState = *(func(x **PipelineTessellationStateCreateInfo) **C.struct_VkPipelineTessellationStateCreateInfo { /* Pointer */
		g2c := (*C.struct_VkPipelineTessellationStateCreateInfo)(*x)
		return &g2c
	}(&y))
}

// PViewportState returns the value of pViewportState from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PViewportState() *PipelineViewportStateCreateInfo {
	ptr := func(x **C.struct_VkPipelineViewportStateCreateInfo) **PipelineViewportStateCreateInfo { /* Pointer */
		c2g := (*PipelineViewportStateCreateInfo)(*x)
		return &c2g
	}(&x.pViewportState)
	return *ptr
}

// WithPViewportState clones a new GraphicsPipelineCreateInfo with the value of
// PViewportState updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPViewportState(y *PipelineViewportStateCreateInfo) GraphicsPipelineCreateInfo {
	x.pViewportState = *(func(x **PipelineViewportStateCreateInfo) **C.struct_VkPipelineViewportStateCreateInfo { /* Pointer */
		g2c := (*C.struct_VkPipelineViewportStateCreateInfo)(*x)
		return &g2c
	}(&y))
	return x
}
func (x *GraphicsPipelineCreateInfo) SetPViewportState(y *PipelineViewportStateCreateInfo) {
	x.pViewportState = *(func(x **PipelineViewportStateCreateInfo) **C.struct_VkPipelineViewportStateCreateInfo { /* Pointer */
		g2c := (*C.struct_VkPipelineViewportStateCreateInfo)(*x)
		return &g2c
	}(&y))
}

// PRasterizationState returns the value of pRasterizationState from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PRasterizationState() *PipelineRasterizationStateCreateInfo {
	ptr := func(x **C.struct_VkPipelineRasterizationStateCreateInfo) **PipelineRasterizationStateCreateInfo { /* Pointer */
		c2g := (*PipelineRasterizationStateCreateInfo)(*x)
		return &c2g
	}(&x.pRasterizationState)
	return *ptr
}

// WithPRasterizationState clones a new GraphicsPipelineCreateInfo with the value of
// PRasterizationState updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPRasterizationState(y *PipelineRasterizationStateCreateInfo) GraphicsPipelineCreateInfo {
	x.pRasterizationState = *(func(x **PipelineRasterizationStateCreateInfo) **C.struct_VkPipelineRasterizationStateCreateInfo { /* Pointer */
		g2c := (*C.struct_VkPipelineRasterizationStateCreateInfo)(*x)
		return &g2c
	}(&y))
	return x
}
func (x *GraphicsPipelineCreateInfo) SetPRasterizationState(y *PipelineRasterizationStateCreateInfo) {
	x.pRasterizationState = *(func(x **PipelineRasterizationStateCreateInfo) **C.struct_VkPipelineRasterizationStateCreateInfo { /* Pointer */
		g2c := (*C.struct_VkPipelineRasterizationStateCreateInfo)(*x)
		return &g2c
	}(&y))
}

// PMultisampleState returns the value of pMultisampleState from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PMultisampleState() *PipelineMultisampleStateCreateInfo {
	ptr := func(x **C.struct_VkPipelineMultisampleStateCreateInfo) **PipelineMultisampleStateCreateInfo { /* Pointer */
		c2g := (*PipelineMultisampleStateCreateInfo)(*x)
		return &c2g
	}(&x.pMultisampleState)
	return *ptr
}

// WithPMultisampleState clones a new GraphicsPipelineCreateInfo with the value of
// PMultisampleState updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPMultisampleState(y *PipelineMultisampleStateCreateInfo) GraphicsPipelineCreateInfo {
	x.pMultisampleState = *(func(x **PipelineMultisampleStateCreateInfo) **C.struct_VkPipelineMultisampleStateCreateInfo { /* Pointer */
		g2c := (*C.struct_VkPipelineMultisampleStateCreateInfo)(*x)
		return &g2c
	}(&y))
	return x
}
func (x *GraphicsPipelineCreateInfo) SetPMultisampleState(y *PipelineMultisampleStateCreateInfo) {
	x.pMultisampleState = *(func(x **PipelineMultisampleStateCreateInfo) **C.struct_VkPipelineMultisampleStateCreateInfo { /* Pointer */
		g2c := (*C.struct_VkPipelineMultisampleStateCreateInfo)(*x)
		return &g2c
	}(&y))
}

// PDepthStencilState returns the value of pDepthStencilState from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PDepthStencilState() *PipelineDepthStencilStateCreateInfo {
	ptr := func(x **C.struct_VkPipelineDepthStencilStateCreateInfo) **PipelineDepthStencilStateCreateInfo { /* Pointer */
		c2g := (*PipelineDepthStencilStateCreateInfo)(*x)
		return &c2g
	}(&x.pDepthStencilState)
	return *ptr
}

// WithPDepthStencilState clones a new GraphicsPipelineCreateInfo with the value of
// PDepthStencilState updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPDepthStencilState(y *PipelineDepthStencilStateCreateInfo) GraphicsPipelineCreateInfo {
	x.pDepthStencilState = *(func(x **PipelineDepthStencilStateCreateInfo) **C.struct_VkPipelineDepthStencilStateCreateInfo { /* Pointer */
		g2c := (*C.struct_VkPipelineDepthStencilStateCreateInfo)(*x)
		return &g2c
	}(&y))
	return x
}
func (x *GraphicsPipelineCreateInfo) SetPDepthStencilState(y *PipelineDepthStencilStateCreateInfo) {
	x.pDepthStencilState = *(func(x **PipelineDepthStencilStateCreateInfo) **C.struct_VkPipelineDepthStencilStateCreateInfo { /* Pointer */
		g2c := (*C.struct_VkPipelineDepthStencilStateCreateInfo)(*x)
		return &g2c
	}(&y))
}

// PColorBlendState returns the value of pColorBlendState from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PColorBlendState() *PipelineColorBlendStateCreateInfo {
	ptr := func(x **C.struct_VkPipelineColorBlendStateCreateInfo) **PipelineColorBlendStateCreateInfo { /* Pointer */
		c2g := (*PipelineColorBlendStateCreateInfo)(*x)
		return &c2g
	}(&x.pColorBlendState)
	return *ptr
}

// WithPColorBlendState clones a new GraphicsPipelineCreateInfo with the value of
// PColorBlendState updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPColorBlendState(y *PipelineColorBlendStateCreateInfo) GraphicsPipelineCreateInfo {
	x.pColorBlendState = *(func(x **PipelineColorBlendStateCreateInfo) **C.struct_VkPipelineColorBlendStateCreateInfo { /* Pointer */
		g2c := (*C.struct_VkPipelineColorBlendStateCreateInfo)(*x)
		return &g2c
	}(&y))
	return x
}
func (x *GraphicsPipelineCreateInfo) SetPColorBlendState(y *PipelineColorBlendStateCreateInfo) {
	x.pColorBlendState = *(func(x **PipelineColorBlendStateCreateInfo) **C.struct_VkPipelineColorBlendStateCreateInfo { /* Pointer */
		g2c := (*C.struct_VkPipelineColorBlendStateCreateInfo)(*x)
		return &g2c
	}(&y))
}

// PDynamicState returns the value of pDynamicState from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PDynamicState() *PipelineDynamicStateCreateInfo {
	ptr := func(x **C.struct_VkPipelineDynamicStateCreateInfo) **PipelineDynamicStateCreateInfo { /* Pointer */
		c2g := (*PipelineDynamicStateCreateInfo)(*x)
		return &c2g
	}(&x.pDynamicState)
	return *ptr
}

// WithPDynamicState clones a new GraphicsPipelineCreateInfo with the value of
// PDynamicState updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPDynamicState(y *PipelineDynamicStateCreateInfo) GraphicsPipelineCreateInfo {
	x.pDynamicState = *(func(x **PipelineDynamicStateCreateInfo) **C.struct_VkPipelineDynamicStateCreateInfo { /* Pointer */
		g2c := (*C.struct_VkPipelineDynamicStateCreateInfo)(*x)
		return &g2c
	}(&y))
	return x
}
func (x *GraphicsPipelineCreateInfo) SetPDynamicState(y *PipelineDynamicStateCreateInfo) {
	x.pDynamicState = *(func(x **PipelineDynamicStateCreateInfo) **C.struct_VkPipelineDynamicStateCreateInfo { /* Pointer */
		g2c := (*C.struct_VkPipelineDynamicStateCreateInfo)(*x)
		return &g2c
	}(&y))
}

// Layout returns the value of layout from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) Layout() PipelineLayout {
	ptr := /* handle */ (*PipelineLayout)(&x.layout)
	return *ptr
}

// WithLayout clones a new GraphicsPipelineCreateInfo with the value of
// Layout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithLayout(y PipelineLayout) GraphicsPipelineCreateInfo {
	x.layout = *( /* handle */ (*C.VkPipelineLayout)(&y))
	return x
}
func (x *GraphicsPipelineCreateInfo) SetLayout(y PipelineLayout) {
	x.layout = *( /* handle */ (*C.VkPipelineLayout)(&y))
}

// RenderPass returns the value of renderPass from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) RenderPass() RenderPass {
	ptr := /* handle */ (*RenderPass)(&x.renderPass)
	return *ptr
}

// WithRenderPass clones a new GraphicsPipelineCreateInfo with the value of
// RenderPass updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithRenderPass(y RenderPass) GraphicsPipelineCreateInfo {
	x.renderPass = *( /* handle */ (*C.VkRenderPass)(&y))
	return x
}
func (x *GraphicsPipelineCreateInfo) SetRenderPass(y RenderPass) {
	x.renderPass = *( /* handle */ (*C.VkRenderPass)(&y))
}

// Subpass returns the value of subpass from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) Subpass() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.subpass)
	return *ptr
}

// WithSubpass clones a new GraphicsPipelineCreateInfo with the value of
// Subpass updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithSubpass(y uint32) GraphicsPipelineCreateInfo {
	x.subpass = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *GraphicsPipelineCreateInfo) SetSubpass(y uint32) {
	x.subpass = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// BasePipelineHandle returns the value of basePipelineHandle from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) BasePipelineHandle() Pipeline {
	ptr := /* handle */ (*Pipeline)(&x.basePipelineHandle)
	return *ptr
}

// WithBasePipelineHandle clones a new GraphicsPipelineCreateInfo with the value of
// BasePipelineHandle updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithBasePipelineHandle(y Pipeline) GraphicsPipelineCreateInfo {
	x.basePipelineHandle = *( /* handle */ (*C.VkPipeline)(&y))
	return x
}
func (x *GraphicsPipelineCreateInfo) SetBasePipelineHandle(y Pipeline) {
	x.basePipelineHandle = *( /* handle */ (*C.VkPipeline)(&y))
}

// BasePipelineIndex returns the value of basePipelineIndex from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) BasePipelineIndex() int32 {
	ptr := func(x *C.int32_t) *int32 { /* Scalar */ c2g := int32(*x); return &c2g }(&x.basePipelineIndex)
	return *ptr
}

// WithBasePipelineIndex clones a new GraphicsPipelineCreateInfo with the value of
// BasePipelineIndex updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithBasePipelineIndex(y int32) GraphicsPipelineCreateInfo {
	x.basePipelineIndex = *(func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&y))
	return x
}
func (x *GraphicsPipelineCreateInfo) SetBasePipelineIndex(y int32) {
	x.basePipelineIndex = *(func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&y))
}

// ExtensionProperties provides a go interface for VkExtensionProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExtensionProperties.html
type ExtensionProperties C.struct_VkExtensionProperties

// SizeofExtensionProperties is the memory size of a ExtensionProperties
var SizeofExtensionProperties int = int(unsafe.Sizeof(ExtensionProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ExtensionProperties) ArpPtr(arp *AutoReleasePool) *ExtensionProperties {
	ptr := newCBlock(cULong(SizeofExtensionProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ExtensionProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExtensionProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExtensionProperties) AsCPtr() *ExtensionProperties {
	clone := (*ExtensionProperties)(newCBlock(cULong(SizeofExtensionProperties)))
	*clone = x
	return clone
}

// ExtensionPropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ExtensionPropertiesCSlice(arp *AutoReleasePool, x ...ExtensionProperties) []ExtensionProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExtensionProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ExtensionProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ExtensionPropertiesFreeCSlice releases the memory allocated by ExtensionPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func ExtensionPropertiesFreeCSlice(x []ExtensionProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExtensionPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExtensionPropertiesFreeCSlice must be called on the returned slice.
func ExtensionPropertiesMakeCSlice(x ...ExtensionProperties) []ExtensionProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExtensionProperties * len(x)
	dst := unsafe.Slice((*ExtensionProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// ExtensionName returns the value of extensionName from VkExtensionProperties
func (x ExtensionProperties) ExtensionName() []byte {
	ptr := func(x *[VK_MAX_EXTENSION_NAME_SIZE]C.char) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_EXTENSION_NAME_SIZE)
		return &slc
	}(&x.extensionName)
	return *ptr
}

// SpecVersion returns the value of specVersion from VkExtensionProperties
func (x ExtensionProperties) SpecVersion() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.specVersion)
	return *ptr
}

// SparseMemoryBind provides a go interface for VkSparseMemoryBind.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseMemoryBind.html
type SparseMemoryBind C.struct_VkSparseMemoryBind

// SizeofSparseMemoryBind is the memory size of a SparseMemoryBind
var SizeofSparseMemoryBind int = int(unsafe.Sizeof(SparseMemoryBind{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SparseMemoryBind) ArpPtr(arp *AutoReleasePool) *SparseMemoryBind {
	ptr := newCBlock(cULong(SizeofSparseMemoryBind))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SparseMemoryBind)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SparseMemoryBind) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SparseMemoryBind) AsCPtr() *SparseMemoryBind {
	clone := (*SparseMemoryBind)(newCBlock(cULong(SizeofSparseMemoryBind)))
	*clone = x
	return clone
}

// SparseMemoryBindCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SparseMemoryBindCSlice(arp *AutoReleasePool, x ...SparseMemoryBind) []SparseMemoryBind {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseMemoryBind * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SparseMemoryBind)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SparseMemoryBindFreeCSlice releases the memory allocated by SparseMemoryBindMakeCSlice.
// It does not free pointers stored inside the slice.
func SparseMemoryBindFreeCSlice(x []SparseMemoryBind) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SparseMemoryBindMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SparseMemoryBindFreeCSlice must be called on the returned slice.
func SparseMemoryBindMakeCSlice(x ...SparseMemoryBind) []SparseMemoryBind {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseMemoryBind * len(x)
	dst := unsafe.Slice((*SparseMemoryBind)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// ResourceOffset returns the value of resourceOffset from VkSparseMemoryBind
func (x SparseMemoryBind) ResourceOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.resourceOffset)
	return *ptr
}

// WithResourceOffset clones a new SparseMemoryBind with the value of
// ResourceOffset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseMemoryBind) WithResourceOffset(y DeviceSize) SparseMemoryBind {
	x.resourceOffset = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *SparseMemoryBind) SetResourceOffset(y DeviceSize) {
	x.resourceOffset = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// Size returns the value of size from VkSparseMemoryBind
func (x SparseMemoryBind) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size)
	return *ptr
}

// WithSize clones a new SparseMemoryBind with the value of
// Size updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseMemoryBind) WithSize(y DeviceSize) SparseMemoryBind {
	x.size = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *SparseMemoryBind) SetSize(y DeviceSize) {
	x.size = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// Memory returns the value of memory from VkSparseMemoryBind
func (x SparseMemoryBind) Memory() DeviceMemory {
	ptr := /* handle */ (*DeviceMemory)(&x.memory)
	return *ptr
}

// WithMemory clones a new SparseMemoryBind with the value of
// Memory updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseMemoryBind) WithMemory(y DeviceMemory) SparseMemoryBind {
	x.memory = *( /* handle */ (*C.VkDeviceMemory)(&y))
	return x
}
func (x *SparseMemoryBind) SetMemory(y DeviceMemory) {
	x.memory = *( /* handle */ (*C.VkDeviceMemory)(&y))
}

// MemoryOffset returns the value of memoryOffset from VkSparseMemoryBind
func (x SparseMemoryBind) MemoryOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.memoryOffset)
	return *ptr
}

// WithMemoryOffset clones a new SparseMemoryBind with the value of
// MemoryOffset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseMemoryBind) WithMemoryOffset(y DeviceSize) SparseMemoryBind {
	x.memoryOffset = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *SparseMemoryBind) SetMemoryOffset(y DeviceSize) {
	x.memoryOffset = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// Flags returns the value of flags from VkSparseMemoryBind
func (x SparseMemoryBind) Flags() SparseMemoryBindFlags {
	ptr := /* typedef */ (*SparseMemoryBindFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new SparseMemoryBind with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseMemoryBind) WithFlags(y SparseMemoryBindFlags) SparseMemoryBind {
	x.flags = *( /* typedef */ (*C.VkSparseMemoryBindFlags)(&y))
	return x
}
func (x *SparseMemoryBind) SetFlags(y SparseMemoryBindFlags) {
	x.flags = *( /* typedef */ (*C.VkSparseMemoryBindFlags)(&y))
}

// SparseImageOpaqueMemoryBindInfo provides a go interface for VkSparseImageOpaqueMemoryBindInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageOpaqueMemoryBindInfo.html
type SparseImageOpaqueMemoryBindInfo C.struct_VkSparseImageOpaqueMemoryBindInfo

// SizeofSparseImageOpaqueMemoryBindInfo is the memory size of a SparseImageOpaqueMemoryBindInfo
var SizeofSparseImageOpaqueMemoryBindInfo int = int(unsafe.Sizeof(SparseImageOpaqueMemoryBindInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SparseImageOpaqueMemoryBindInfo) ArpPtr(arp *AutoReleasePool) *SparseImageOpaqueMemoryBindInfo {
	ptr := newCBlock(cULong(SizeofSparseImageOpaqueMemoryBindInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SparseImageOpaqueMemoryBindInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SparseImageOpaqueMemoryBindInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SparseImageOpaqueMemoryBindInfo) AsCPtr() *SparseImageOpaqueMemoryBindInfo {
	clone := (*SparseImageOpaqueMemoryBindInfo)(newCBlock(cULong(SizeofSparseImageOpaqueMemoryBindInfo)))
	*clone = x
	return clone
}

// SparseImageOpaqueMemoryBindInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SparseImageOpaqueMemoryBindInfoCSlice(arp *AutoReleasePool, x ...SparseImageOpaqueMemoryBindInfo) []SparseImageOpaqueMemoryBindInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageOpaqueMemoryBindInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SparseImageOpaqueMemoryBindInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SparseImageOpaqueMemoryBindInfoFreeCSlice releases the memory allocated by SparseImageOpaqueMemoryBindInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SparseImageOpaqueMemoryBindInfoFreeCSlice(x []SparseImageOpaqueMemoryBindInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SparseImageOpaqueMemoryBindInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SparseImageOpaqueMemoryBindInfoFreeCSlice must be called on the returned slice.
func SparseImageOpaqueMemoryBindInfoMakeCSlice(x ...SparseImageOpaqueMemoryBindInfo) []SparseImageOpaqueMemoryBindInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageOpaqueMemoryBindInfo * len(x)
	dst := unsafe.Slice((*SparseImageOpaqueMemoryBindInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Image returns the value of image from VkSparseImageOpaqueMemoryBindInfo
func (x SparseImageOpaqueMemoryBindInfo) Image() Image {
	ptr := /* handle */ (*Image)(&x.image)
	return *ptr
}

// WithImage clones a new SparseImageOpaqueMemoryBindInfo with the value of
// Image updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageOpaqueMemoryBindInfo) WithImage(y Image) SparseImageOpaqueMemoryBindInfo {
	x.image = *( /* handle */ (*C.VkImage)(&y))
	return x
}
func (x *SparseImageOpaqueMemoryBindInfo) SetImage(y Image) {
	x.image = *( /* handle */ (*C.VkImage)(&y))
}

// BindCount returns the value of bindCount from VkSparseImageOpaqueMemoryBindInfo
func (x SparseImageOpaqueMemoryBindInfo) BindCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.bindCount)
	return *ptr
}

// WithBindCount clones a new SparseImageOpaqueMemoryBindInfo with the value of
// BindCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageOpaqueMemoryBindInfo) WithBindCount(y uint32) SparseImageOpaqueMemoryBindInfo {
	x.bindCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SparseImageOpaqueMemoryBindInfo) SetBindCount(y uint32) {
	x.bindCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PBinds returns the value of pBinds from VkSparseImageOpaqueMemoryBindInfo
func (x SparseImageOpaqueMemoryBindInfo) PBinds() []SparseMemoryBind {
	ptr := func(x **C.struct_VkSparseMemoryBind) *[]SparseMemoryBind { /* Slice */
		slc := unsafe.Slice((*SparseMemoryBind)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pBinds)
	return *ptr
}

// WithPBinds clones a new SparseImageOpaqueMemoryBindInfo with the value of
// PBinds updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines BindCount as the length of this field.
// BindCount is updated with the length of the new value.
func (x SparseImageOpaqueMemoryBindInfo) WithPBinds(y []SparseMemoryBind) SparseImageOpaqueMemoryBindInfo {
	x.pBinds = *(func(x *[]SparseMemoryBind) **C.struct_VkSparseMemoryBind { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSparseMemoryBind)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSparseMemoryBind)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithBindCount(uint32(len(y)))
}
func (x *SparseImageOpaqueMemoryBindInfo) SetPBinds(y []SparseMemoryBind) {
	x.pBinds = *(func(x *[]SparseMemoryBind) **C.struct_VkSparseMemoryBind { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSparseMemoryBind)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSparseMemoryBind)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetBindCount(uint32(len(y)))
}

// SparseImageFormatProperties provides a go interface for VkSparseImageFormatProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageFormatProperties.html
type SparseImageFormatProperties C.struct_VkSparseImageFormatProperties

// SizeofSparseImageFormatProperties is the memory size of a SparseImageFormatProperties
var SizeofSparseImageFormatProperties int = int(unsafe.Sizeof(SparseImageFormatProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SparseImageFormatProperties) ArpPtr(arp *AutoReleasePool) *SparseImageFormatProperties {
	ptr := newCBlock(cULong(SizeofSparseImageFormatProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SparseImageFormatProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SparseImageFormatProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SparseImageFormatProperties) AsCPtr() *SparseImageFormatProperties {
	clone := (*SparseImageFormatProperties)(newCBlock(cULong(SizeofSparseImageFormatProperties)))
	*clone = x
	return clone
}

// SparseImageFormatPropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SparseImageFormatPropertiesCSlice(arp *AutoReleasePool, x ...SparseImageFormatProperties) []SparseImageFormatProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageFormatProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SparseImageFormatProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SparseImageFormatPropertiesFreeCSlice releases the memory allocated by SparseImageFormatPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func SparseImageFormatPropertiesFreeCSlice(x []SparseImageFormatProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SparseImageFormatPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SparseImageFormatPropertiesFreeCSlice must be called on the returned slice.
func SparseImageFormatPropertiesMakeCSlice(x ...SparseImageFormatProperties) []SparseImageFormatProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageFormatProperties * len(x)
	dst := unsafe.Slice((*SparseImageFormatProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// AspectMask returns the value of aspectMask from VkSparseImageFormatProperties
func (x SparseImageFormatProperties) AspectMask() ImageAspectFlags {
	ptr := /* typedef */ (*ImageAspectFlags)(&x.aspectMask)
	return *ptr
}

// ImageGranularity returns the value of imageGranularity from VkSparseImageFormatProperties
func (x SparseImageFormatProperties) ImageGranularity() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.imageGranularity)
	return *ptr
}

// Flags returns the value of flags from VkSparseImageFormatProperties
func (x SparseImageFormatProperties) Flags() SparseImageFormatFlags {
	ptr := /* typedef */ (*SparseImageFormatFlags)(&x.flags)
	return *ptr
}

// SparseImageMemoryRequirements provides a go interface for VkSparseImageMemoryRequirements.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageMemoryRequirements.html
type SparseImageMemoryRequirements C.struct_VkSparseImageMemoryRequirements

// SizeofSparseImageMemoryRequirements is the memory size of a SparseImageMemoryRequirements
var SizeofSparseImageMemoryRequirements int = int(unsafe.Sizeof(SparseImageMemoryRequirements{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SparseImageMemoryRequirements) ArpPtr(arp *AutoReleasePool) *SparseImageMemoryRequirements {
	ptr := newCBlock(cULong(SizeofSparseImageMemoryRequirements))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SparseImageMemoryRequirements)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SparseImageMemoryRequirements) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SparseImageMemoryRequirements) AsCPtr() *SparseImageMemoryRequirements {
	clone := (*SparseImageMemoryRequirements)(newCBlock(cULong(SizeofSparseImageMemoryRequirements)))
	*clone = x
	return clone
}

// SparseImageMemoryRequirementsCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SparseImageMemoryRequirementsCSlice(arp *AutoReleasePool, x ...SparseImageMemoryRequirements) []SparseImageMemoryRequirements {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageMemoryRequirements * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SparseImageMemoryRequirements)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SparseImageMemoryRequirementsFreeCSlice releases the memory allocated by SparseImageMemoryRequirementsMakeCSlice.
// It does not free pointers stored inside the slice.
func SparseImageMemoryRequirementsFreeCSlice(x []SparseImageMemoryRequirements) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SparseImageMemoryRequirementsMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SparseImageMemoryRequirementsFreeCSlice must be called on the returned slice.
func SparseImageMemoryRequirementsMakeCSlice(x ...SparseImageMemoryRequirements) []SparseImageMemoryRequirements {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageMemoryRequirements * len(x)
	dst := unsafe.Slice((*SparseImageMemoryRequirements)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// FormatProperties returns the value of formatProperties from VkSparseImageMemoryRequirements
func (x SparseImageMemoryRequirements) FormatProperties() SparseImageFormatProperties {
	ptr := /* typedef */ (*SparseImageFormatProperties)(&x.formatProperties)
	return *ptr
}

// ImageMipTailFirstLod returns the value of imageMipTailFirstLod from VkSparseImageMemoryRequirements
func (x SparseImageMemoryRequirements) ImageMipTailFirstLod() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.imageMipTailFirstLod)
	return *ptr
}

// ImageMipTailSize returns the value of imageMipTailSize from VkSparseImageMemoryRequirements
func (x SparseImageMemoryRequirements) ImageMipTailSize() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.imageMipTailSize)
	return *ptr
}

// ImageMipTailOffset returns the value of imageMipTailOffset from VkSparseImageMemoryRequirements
func (x SparseImageMemoryRequirements) ImageMipTailOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.imageMipTailOffset)
	return *ptr
}

// ImageMipTailStride returns the value of imageMipTailStride from VkSparseImageMemoryRequirements
func (x SparseImageMemoryRequirements) ImageMipTailStride() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.imageMipTailStride)
	return *ptr
}

// ImageSubresource provides a go interface for VkImageSubresource.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSubresource.html
type ImageSubresource C.struct_VkImageSubresource

// SizeofImageSubresource is the memory size of a ImageSubresource
var SizeofImageSubresource int = int(unsafe.Sizeof(ImageSubresource{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ImageSubresource) ArpPtr(arp *AutoReleasePool) *ImageSubresource {
	ptr := newCBlock(cULong(SizeofImageSubresource))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ImageSubresource)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageSubresource) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageSubresource) AsCPtr() *ImageSubresource {
	clone := (*ImageSubresource)(newCBlock(cULong(SizeofImageSubresource)))
	*clone = x
	return clone
}

// ImageSubresourceCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ImageSubresourceCSlice(arp *AutoReleasePool, x ...ImageSubresource) []ImageSubresource {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageSubresource * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ImageSubresource)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ImageSubresourceFreeCSlice releases the memory allocated by ImageSubresourceMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageSubresourceFreeCSlice(x []ImageSubresource) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageSubresourceMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageSubresourceFreeCSlice must be called on the returned slice.
func ImageSubresourceMakeCSlice(x ...ImageSubresource) []ImageSubresource {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageSubresource * len(x)
	dst := unsafe.Slice((*ImageSubresource)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// AspectMask returns the value of aspectMask from VkImageSubresource
func (x ImageSubresource) AspectMask() ImageAspectFlags {
	ptr := /* typedef */ (*ImageAspectFlags)(&x.aspectMask)
	return *ptr
}

// WithAspectMask clones a new ImageSubresource with the value of
// AspectMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresource) WithAspectMask(y ImageAspectFlags) ImageSubresource {
	x.aspectMask = *( /* typedef */ (*C.VkImageAspectFlags)(&y))
	return x
}
func (x *ImageSubresource) SetAspectMask(y ImageAspectFlags) {
	x.aspectMask = *( /* typedef */ (*C.VkImageAspectFlags)(&y))
}

// MipLevel returns the value of mipLevel from VkImageSubresource
func (x ImageSubresource) MipLevel() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.mipLevel)
	return *ptr
}

// WithMipLevel clones a new ImageSubresource with the value of
// MipLevel updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresource) WithMipLevel(y uint32) ImageSubresource {
	x.mipLevel = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *ImageSubresource) SetMipLevel(y uint32) {
	x.mipLevel = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// ArrayLayer returns the value of arrayLayer from VkImageSubresource
func (x ImageSubresource) ArrayLayer() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.arrayLayer)
	return *ptr
}

// WithArrayLayer clones a new ImageSubresource with the value of
// ArrayLayer updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresource) WithArrayLayer(y uint32) ImageSubresource {
	x.arrayLayer = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *ImageSubresource) SetArrayLayer(y uint32) {
	x.arrayLayer = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// SparseImageMemoryBind provides a go interface for VkSparseImageMemoryBind.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageMemoryBind.html
type SparseImageMemoryBind C.struct_VkSparseImageMemoryBind

// SizeofSparseImageMemoryBind is the memory size of a SparseImageMemoryBind
var SizeofSparseImageMemoryBind int = int(unsafe.Sizeof(SparseImageMemoryBind{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SparseImageMemoryBind) ArpPtr(arp *AutoReleasePool) *SparseImageMemoryBind {
	ptr := newCBlock(cULong(SizeofSparseImageMemoryBind))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SparseImageMemoryBind)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SparseImageMemoryBind) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SparseImageMemoryBind) AsCPtr() *SparseImageMemoryBind {
	clone := (*SparseImageMemoryBind)(newCBlock(cULong(SizeofSparseImageMemoryBind)))
	*clone = x
	return clone
}

// SparseImageMemoryBindCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SparseImageMemoryBindCSlice(arp *AutoReleasePool, x ...SparseImageMemoryBind) []SparseImageMemoryBind {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageMemoryBind * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SparseImageMemoryBind)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SparseImageMemoryBindFreeCSlice releases the memory allocated by SparseImageMemoryBindMakeCSlice.
// It does not free pointers stored inside the slice.
func SparseImageMemoryBindFreeCSlice(x []SparseImageMemoryBind) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SparseImageMemoryBindMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SparseImageMemoryBindFreeCSlice must be called on the returned slice.
func SparseImageMemoryBindMakeCSlice(x ...SparseImageMemoryBind) []SparseImageMemoryBind {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageMemoryBind * len(x)
	dst := unsafe.Slice((*SparseImageMemoryBind)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Subresource returns the value of subresource from VkSparseImageMemoryBind
func (x SparseImageMemoryBind) Subresource() ImageSubresource {
	ptr := /* typedef */ (*ImageSubresource)(&x.subresource)
	return *ptr
}

// WithSubresource clones a new SparseImageMemoryBind with the value of
// Subresource updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryBind) WithSubresource(y ImageSubresource) SparseImageMemoryBind {
	x.subresource = *( /* typedef */ (*C.struct_VkImageSubresource)(&y))
	return x
}
func (x *SparseImageMemoryBind) SetSubresource(y ImageSubresource) {
	x.subresource = *( /* typedef */ (*C.struct_VkImageSubresource)(&y))
}

// Offset returns the value of offset from VkSparseImageMemoryBind
func (x SparseImageMemoryBind) Offset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.offset)
	return *ptr
}

// WithOffset clones a new SparseImageMemoryBind with the value of
// Offset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryBind) WithOffset(y Offset3D) SparseImageMemoryBind {
	x.offset = *( /* typedef */ (*C.struct_VkOffset3D)(&y))
	return x
}
func (x *SparseImageMemoryBind) SetOffset(y Offset3D) {
	x.offset = *( /* typedef */ (*C.struct_VkOffset3D)(&y))
}

// Extent returns the value of extent from VkSparseImageMemoryBind
func (x SparseImageMemoryBind) Extent() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.extent)
	return *ptr
}

// WithExtent clones a new SparseImageMemoryBind with the value of
// Extent updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryBind) WithExtent(y Extent3D) SparseImageMemoryBind {
	x.extent = *( /* typedef */ (*C.struct_VkExtent3D)(&y))
	return x
}
func (x *SparseImageMemoryBind) SetExtent(y Extent3D) {
	x.extent = *( /* typedef */ (*C.struct_VkExtent3D)(&y))
}

// Memory returns the value of memory from VkSparseImageMemoryBind
func (x SparseImageMemoryBind) Memory() DeviceMemory {
	ptr := /* handle */ (*DeviceMemory)(&x.memory)
	return *ptr
}

// WithMemory clones a new SparseImageMemoryBind with the value of
// Memory updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryBind) WithMemory(y DeviceMemory) SparseImageMemoryBind {
	x.memory = *( /* handle */ (*C.VkDeviceMemory)(&y))
	return x
}
func (x *SparseImageMemoryBind) SetMemory(y DeviceMemory) {
	x.memory = *( /* handle */ (*C.VkDeviceMemory)(&y))
}

// MemoryOffset returns the value of memoryOffset from VkSparseImageMemoryBind
func (x SparseImageMemoryBind) MemoryOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.memoryOffset)
	return *ptr
}

// WithMemoryOffset clones a new SparseImageMemoryBind with the value of
// MemoryOffset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryBind) WithMemoryOffset(y DeviceSize) SparseImageMemoryBind {
	x.memoryOffset = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *SparseImageMemoryBind) SetMemoryOffset(y DeviceSize) {
	x.memoryOffset = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// Flags returns the value of flags from VkSparseImageMemoryBind
func (x SparseImageMemoryBind) Flags() SparseMemoryBindFlags {
	ptr := /* typedef */ (*SparseMemoryBindFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new SparseImageMemoryBind with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryBind) WithFlags(y SparseMemoryBindFlags) SparseImageMemoryBind {
	x.flags = *( /* typedef */ (*C.VkSparseMemoryBindFlags)(&y))
	return x
}
func (x *SparseImageMemoryBind) SetFlags(y SparseMemoryBindFlags) {
	x.flags = *( /* typedef */ (*C.VkSparseMemoryBindFlags)(&y))
}

// SparseImageMemoryBindInfo provides a go interface for VkSparseImageMemoryBindInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageMemoryBindInfo.html
type SparseImageMemoryBindInfo C.struct_VkSparseImageMemoryBindInfo

// SizeofSparseImageMemoryBindInfo is the memory size of a SparseImageMemoryBindInfo
var SizeofSparseImageMemoryBindInfo int = int(unsafe.Sizeof(SparseImageMemoryBindInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SparseImageMemoryBindInfo) ArpPtr(arp *AutoReleasePool) *SparseImageMemoryBindInfo {
	ptr := newCBlock(cULong(SizeofSparseImageMemoryBindInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SparseImageMemoryBindInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SparseImageMemoryBindInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SparseImageMemoryBindInfo) AsCPtr() *SparseImageMemoryBindInfo {
	clone := (*SparseImageMemoryBindInfo)(newCBlock(cULong(SizeofSparseImageMemoryBindInfo)))
	*clone = x
	return clone
}

// SparseImageMemoryBindInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SparseImageMemoryBindInfoCSlice(arp *AutoReleasePool, x ...SparseImageMemoryBindInfo) []SparseImageMemoryBindInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageMemoryBindInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SparseImageMemoryBindInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SparseImageMemoryBindInfoFreeCSlice releases the memory allocated by SparseImageMemoryBindInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SparseImageMemoryBindInfoFreeCSlice(x []SparseImageMemoryBindInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SparseImageMemoryBindInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SparseImageMemoryBindInfoFreeCSlice must be called on the returned slice.
func SparseImageMemoryBindInfoMakeCSlice(x ...SparseImageMemoryBindInfo) []SparseImageMemoryBindInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageMemoryBindInfo * len(x)
	dst := unsafe.Slice((*SparseImageMemoryBindInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Image returns the value of image from VkSparseImageMemoryBindInfo
func (x SparseImageMemoryBindInfo) Image() Image {
	ptr := /* handle */ (*Image)(&x.image)
	return *ptr
}

// WithImage clones a new SparseImageMemoryBindInfo with the value of
// Image updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryBindInfo) WithImage(y Image) SparseImageMemoryBindInfo {
	x.image = *( /* handle */ (*C.VkImage)(&y))
	return x
}
func (x *SparseImageMemoryBindInfo) SetImage(y Image) {
	x.image = *( /* handle */ (*C.VkImage)(&y))
}

// BindCount returns the value of bindCount from VkSparseImageMemoryBindInfo
func (x SparseImageMemoryBindInfo) BindCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.bindCount)
	return *ptr
}

// WithBindCount clones a new SparseImageMemoryBindInfo with the value of
// BindCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryBindInfo) WithBindCount(y uint32) SparseImageMemoryBindInfo {
	x.bindCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SparseImageMemoryBindInfo) SetBindCount(y uint32) {
	x.bindCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PBinds returns the value of pBinds from VkSparseImageMemoryBindInfo
func (x SparseImageMemoryBindInfo) PBinds() []SparseImageMemoryBind {
	ptr := func(x **C.struct_VkSparseImageMemoryBind) *[]SparseImageMemoryBind { /* Slice */
		slc := unsafe.Slice((*SparseImageMemoryBind)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pBinds)
	return *ptr
}

// WithPBinds clones a new SparseImageMemoryBindInfo with the value of
// PBinds updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines BindCount as the length of this field.
// BindCount is updated with the length of the new value.
func (x SparseImageMemoryBindInfo) WithPBinds(y []SparseImageMemoryBind) SparseImageMemoryBindInfo {
	x.pBinds = *(func(x *[]SparseImageMemoryBind) **C.struct_VkSparseImageMemoryBind { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSparseImageMemoryBind)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSparseImageMemoryBind)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithBindCount(uint32(len(y)))
}
func (x *SparseImageMemoryBindInfo) SetPBinds(y []SparseImageMemoryBind) {
	x.pBinds = *(func(x *[]SparseImageMemoryBind) **C.struct_VkSparseImageMemoryBind { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSparseImageMemoryBind)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSparseImageMemoryBind)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetBindCount(uint32(len(y)))
}

// DescriptorSetAllocateInfo provides a go interface for VkDescriptorSetAllocateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetAllocateInfo.html
type DescriptorSetAllocateInfo C.struct_VkDescriptorSetAllocateInfo

// SizeofDescriptorSetAllocateInfo is the memory size of a DescriptorSetAllocateInfo
var SizeofDescriptorSetAllocateInfo int = int(unsafe.Sizeof(DescriptorSetAllocateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DescriptorSetAllocateInfo) ArpPtr(arp *AutoReleasePool) *DescriptorSetAllocateInfo {
	ptr := newCBlock(cULong(SizeofDescriptorSetAllocateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DescriptorSetAllocateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorSetAllocateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorSetAllocateInfo) AsCPtr() *DescriptorSetAllocateInfo {
	clone := (*DescriptorSetAllocateInfo)(newCBlock(cULong(SizeofDescriptorSetAllocateInfo)))
	*clone = x
	return clone
}

// DescriptorSetAllocateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DescriptorSetAllocateInfoCSlice(arp *AutoReleasePool, x ...DescriptorSetAllocateInfo) []DescriptorSetAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetAllocateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DescriptorSetAllocateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DescriptorSetAllocateInfoFreeCSlice releases the memory allocated by DescriptorSetAllocateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorSetAllocateInfoFreeCSlice(x []DescriptorSetAllocateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorSetAllocateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorSetAllocateInfoFreeCSlice must be called on the returned slice.
func DescriptorSetAllocateInfoMakeCSlice(x ...DescriptorSetAllocateInfo) []DescriptorSetAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetAllocateInfo * len(x)
	dst := unsafe.Slice((*DescriptorSetAllocateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDescriptorSetAllocateInfo
func (x DescriptorSetAllocateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DescriptorSetAllocateInfo with the value of
// SType to the value provided in the specification.
func (x DescriptorSetAllocateInfo) WithDefaultSType() DescriptorSetAllocateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DescriptorSetAllocateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO)
}

// WithSType clones a new DescriptorSetAllocateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetAllocateInfo) WithSType(y StructureType) DescriptorSetAllocateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DescriptorSetAllocateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDescriptorSetAllocateInfo
func (x DescriptorSetAllocateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DescriptorSetAllocateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetAllocateInfo) WithPNext(y unsafe.Pointer) DescriptorSetAllocateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DescriptorSetAllocateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// DescriptorPool returns the value of descriptorPool from VkDescriptorSetAllocateInfo
func (x DescriptorSetAllocateInfo) DescriptorPool() DescriptorPool {
	ptr := /* handle */ (*DescriptorPool)(&x.descriptorPool)
	return *ptr
}

// WithDescriptorPool clones a new DescriptorSetAllocateInfo with the value of
// DescriptorPool updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetAllocateInfo) WithDescriptorPool(y DescriptorPool) DescriptorSetAllocateInfo {
	x.descriptorPool = *( /* handle */ (*C.VkDescriptorPool)(&y))
	return x
}
func (x *DescriptorSetAllocateInfo) SetDescriptorPool(y DescriptorPool) {
	x.descriptorPool = *( /* handle */ (*C.VkDescriptorPool)(&y))
}

// DescriptorSetCount returns the value of descriptorSetCount from VkDescriptorSetAllocateInfo
func (x DescriptorSetAllocateInfo) DescriptorSetCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.descriptorSetCount)
	return *ptr
}

// WithDescriptorSetCount clones a new DescriptorSetAllocateInfo with the value of
// DescriptorSetCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetAllocateInfo) WithDescriptorSetCount(y uint32) DescriptorSetAllocateInfo {
	x.descriptorSetCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DescriptorSetAllocateInfo) SetDescriptorSetCount(y uint32) {
	x.descriptorSetCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PSetLayouts returns the value of pSetLayouts from VkDescriptorSetAllocateInfo
func (x DescriptorSetAllocateInfo) PSetLayouts() []DescriptorSetLayout {
	ptr := func(x **C.VkDescriptorSetLayout) *[]DescriptorSetLayout { /* Slice */
		slc := unsafe.Slice((*DescriptorSetLayout)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pSetLayouts)
	return *ptr
}

// WithPSetLayouts clones a new DescriptorSetAllocateInfo with the value of
// PSetLayouts updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DescriptorSetCount as the length of this field.
// DescriptorSetCount is updated with the length of the new value.
func (x DescriptorSetAllocateInfo) WithPSetLayouts(y []DescriptorSetLayout) DescriptorSetAllocateInfo {
	x.pSetLayouts = *(func(x *[]DescriptorSetLayout) **C.VkDescriptorSetLayout { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkDescriptorSetLayout)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkDescriptorSetLayout)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithDescriptorSetCount(uint32(len(y)))
}
func (x *DescriptorSetAllocateInfo) SetPSetLayouts(y []DescriptorSetLayout) {
	x.pSetLayouts = *(func(x *[]DescriptorSetLayout) **C.VkDescriptorSetLayout { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkDescriptorSetLayout)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkDescriptorSetLayout)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetDescriptorSetCount(uint32(len(y)))
}

// SparseBufferMemoryBindInfo provides a go interface for VkSparseBufferMemoryBindInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseBufferMemoryBindInfo.html
type SparseBufferMemoryBindInfo C.struct_VkSparseBufferMemoryBindInfo

// SizeofSparseBufferMemoryBindInfo is the memory size of a SparseBufferMemoryBindInfo
var SizeofSparseBufferMemoryBindInfo int = int(unsafe.Sizeof(SparseBufferMemoryBindInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SparseBufferMemoryBindInfo) ArpPtr(arp *AutoReleasePool) *SparseBufferMemoryBindInfo {
	ptr := newCBlock(cULong(SizeofSparseBufferMemoryBindInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SparseBufferMemoryBindInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SparseBufferMemoryBindInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SparseBufferMemoryBindInfo) AsCPtr() *SparseBufferMemoryBindInfo {
	clone := (*SparseBufferMemoryBindInfo)(newCBlock(cULong(SizeofSparseBufferMemoryBindInfo)))
	*clone = x
	return clone
}

// SparseBufferMemoryBindInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SparseBufferMemoryBindInfoCSlice(arp *AutoReleasePool, x ...SparseBufferMemoryBindInfo) []SparseBufferMemoryBindInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseBufferMemoryBindInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SparseBufferMemoryBindInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SparseBufferMemoryBindInfoFreeCSlice releases the memory allocated by SparseBufferMemoryBindInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SparseBufferMemoryBindInfoFreeCSlice(x []SparseBufferMemoryBindInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SparseBufferMemoryBindInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SparseBufferMemoryBindInfoFreeCSlice must be called on the returned slice.
func SparseBufferMemoryBindInfoMakeCSlice(x ...SparseBufferMemoryBindInfo) []SparseBufferMemoryBindInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseBufferMemoryBindInfo * len(x)
	dst := unsafe.Slice((*SparseBufferMemoryBindInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Buffer returns the value of buffer from VkSparseBufferMemoryBindInfo
func (x SparseBufferMemoryBindInfo) Buffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.buffer)
	return *ptr
}

// WithBuffer clones a new SparseBufferMemoryBindInfo with the value of
// Buffer updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseBufferMemoryBindInfo) WithBuffer(y Buffer) SparseBufferMemoryBindInfo {
	x.buffer = *( /* handle */ (*C.VkBuffer)(&y))
	return x
}
func (x *SparseBufferMemoryBindInfo) SetBuffer(y Buffer) {
	x.buffer = *( /* handle */ (*C.VkBuffer)(&y))
}

// BindCount returns the value of bindCount from VkSparseBufferMemoryBindInfo
func (x SparseBufferMemoryBindInfo) BindCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.bindCount)
	return *ptr
}

// WithBindCount clones a new SparseBufferMemoryBindInfo with the value of
// BindCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseBufferMemoryBindInfo) WithBindCount(y uint32) SparseBufferMemoryBindInfo {
	x.bindCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SparseBufferMemoryBindInfo) SetBindCount(y uint32) {
	x.bindCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PBinds returns the value of pBinds from VkSparseBufferMemoryBindInfo
func (x SparseBufferMemoryBindInfo) PBinds() []SparseMemoryBind {
	ptr := func(x **C.struct_VkSparseMemoryBind) *[]SparseMemoryBind { /* Slice */
		slc := unsafe.Slice((*SparseMemoryBind)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pBinds)
	return *ptr
}

// WithPBinds clones a new SparseBufferMemoryBindInfo with the value of
// PBinds updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines BindCount as the length of this field.
// BindCount is updated with the length of the new value.
func (x SparseBufferMemoryBindInfo) WithPBinds(y []SparseMemoryBind) SparseBufferMemoryBindInfo {
	x.pBinds = *(func(x *[]SparseMemoryBind) **C.struct_VkSparseMemoryBind { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSparseMemoryBind)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSparseMemoryBind)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithBindCount(uint32(len(y)))
}
func (x *SparseBufferMemoryBindInfo) SetPBinds(y []SparseMemoryBind) {
	x.pBinds = *(func(x *[]SparseMemoryBind) **C.struct_VkSparseMemoryBind { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSparseMemoryBind)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSparseMemoryBind)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetBindCount(uint32(len(y)))
}

// DrawIndirectCommand provides a go interface for VkDrawIndirectCommand.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrawIndirectCommand.html
type DrawIndirectCommand C.struct_VkDrawIndirectCommand

// SizeofDrawIndirectCommand is the memory size of a DrawIndirectCommand
var SizeofDrawIndirectCommand int = int(unsafe.Sizeof(DrawIndirectCommand{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DrawIndirectCommand) ArpPtr(arp *AutoReleasePool) *DrawIndirectCommand {
	ptr := newCBlock(cULong(SizeofDrawIndirectCommand))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DrawIndirectCommand)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DrawIndirectCommand) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DrawIndirectCommand) AsCPtr() *DrawIndirectCommand {
	clone := (*DrawIndirectCommand)(newCBlock(cULong(SizeofDrawIndirectCommand)))
	*clone = x
	return clone
}

// DrawIndirectCommandCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DrawIndirectCommandCSlice(arp *AutoReleasePool, x ...DrawIndirectCommand) []DrawIndirectCommand {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDrawIndirectCommand * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DrawIndirectCommand)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DrawIndirectCommandFreeCSlice releases the memory allocated by DrawIndirectCommandMakeCSlice.
// It does not free pointers stored inside the slice.
func DrawIndirectCommandFreeCSlice(x []DrawIndirectCommand) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DrawIndirectCommandMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DrawIndirectCommandFreeCSlice must be called on the returned slice.
func DrawIndirectCommandMakeCSlice(x ...DrawIndirectCommand) []DrawIndirectCommand {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDrawIndirectCommand * len(x)
	dst := unsafe.Slice((*DrawIndirectCommand)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// VertexCount returns the value of vertexCount from VkDrawIndirectCommand
func (x DrawIndirectCommand) VertexCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.vertexCount)
	return *ptr
}

// WithVertexCount clones a new DrawIndirectCommand with the value of
// VertexCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DrawIndirectCommand) WithVertexCount(y uint32) DrawIndirectCommand {
	x.vertexCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DrawIndirectCommand) SetVertexCount(y uint32) {
	x.vertexCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// InstanceCount returns the value of instanceCount from VkDrawIndirectCommand
func (x DrawIndirectCommand) InstanceCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.instanceCount)
	return *ptr
}

// WithInstanceCount clones a new DrawIndirectCommand with the value of
// InstanceCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DrawIndirectCommand) WithInstanceCount(y uint32) DrawIndirectCommand {
	x.instanceCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DrawIndirectCommand) SetInstanceCount(y uint32) {
	x.instanceCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// FirstVertex returns the value of firstVertex from VkDrawIndirectCommand
func (x DrawIndirectCommand) FirstVertex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.firstVertex)
	return *ptr
}

// WithFirstVertex clones a new DrawIndirectCommand with the value of
// FirstVertex updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DrawIndirectCommand) WithFirstVertex(y uint32) DrawIndirectCommand {
	x.firstVertex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DrawIndirectCommand) SetFirstVertex(y uint32) {
	x.firstVertex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// FirstInstance returns the value of firstInstance from VkDrawIndirectCommand
func (x DrawIndirectCommand) FirstInstance() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.firstInstance)
	return *ptr
}

// WithFirstInstance clones a new DrawIndirectCommand with the value of
// FirstInstance updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DrawIndirectCommand) WithFirstInstance(y uint32) DrawIndirectCommand {
	x.firstInstance = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DrawIndirectCommand) SetFirstInstance(y uint32) {
	x.firstInstance = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// BindSparseInfo provides a go interface for VkBindSparseInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindSparseInfo.html
type BindSparseInfo C.struct_VkBindSparseInfo

// SizeofBindSparseInfo is the memory size of a BindSparseInfo
var SizeofBindSparseInfo int = int(unsafe.Sizeof(BindSparseInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x BindSparseInfo) ArpPtr(arp *AutoReleasePool) *BindSparseInfo {
	ptr := newCBlock(cULong(SizeofBindSparseInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*BindSparseInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BindSparseInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BindSparseInfo) AsCPtr() *BindSparseInfo {
	clone := (*BindSparseInfo)(newCBlock(cULong(SizeofBindSparseInfo)))
	*clone = x
	return clone
}

// BindSparseInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func BindSparseInfoCSlice(arp *AutoReleasePool, x ...BindSparseInfo) []BindSparseInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindSparseInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*BindSparseInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// BindSparseInfoFreeCSlice releases the memory allocated by BindSparseInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BindSparseInfoFreeCSlice(x []BindSparseInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BindSparseInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BindSparseInfoFreeCSlice must be called on the returned slice.
func BindSparseInfoMakeCSlice(x ...BindSparseInfo) []BindSparseInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindSparseInfo * len(x)
	dst := unsafe.Slice((*BindSparseInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBindSparseInfo
func (x BindSparseInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new BindSparseInfo with the value of
// SType to the value provided in the specification.
func (x BindSparseInfo) WithDefaultSType() BindSparseInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BIND_SPARSE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *BindSparseInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_BIND_SPARSE_INFO)
}

// WithSType clones a new BindSparseInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindSparseInfo) WithSType(y StructureType) BindSparseInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *BindSparseInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkBindSparseInfo
func (x BindSparseInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new BindSparseInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindSparseInfo) WithPNext(y unsafe.Pointer) BindSparseInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *BindSparseInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// WaitSemaphoreCount returns the value of waitSemaphoreCount from VkBindSparseInfo
func (x BindSparseInfo) WaitSemaphoreCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.waitSemaphoreCount)
	return *ptr
}

// WithWaitSemaphoreCount clones a new BindSparseInfo with the value of
// WaitSemaphoreCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindSparseInfo) WithWaitSemaphoreCount(y uint32) BindSparseInfo {
	x.waitSemaphoreCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *BindSparseInfo) SetWaitSemaphoreCount(y uint32) {
	x.waitSemaphoreCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PWaitSemaphores returns the value of pWaitSemaphores from VkBindSparseInfo
func (x BindSparseInfo) PWaitSemaphores() []Semaphore {
	ptr := func(x **C.VkSemaphore) *[]Semaphore { /* Slice */
		slc := unsafe.Slice((*Semaphore)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pWaitSemaphores)
	return *ptr
}

// WithPWaitSemaphores clones a new BindSparseInfo with the value of
// PWaitSemaphores updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines WaitSemaphoreCount as the length of this field.
// WaitSemaphoreCount is updated with the length of the new value.
func (x BindSparseInfo) WithPWaitSemaphores(y []Semaphore) BindSparseInfo {
	x.pWaitSemaphores = *(func(x *[]Semaphore) **C.VkSemaphore { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSemaphore)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSemaphore)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithWaitSemaphoreCount(uint32(len(y)))
}
func (x *BindSparseInfo) SetPWaitSemaphores(y []Semaphore) {
	x.pWaitSemaphores = *(func(x *[]Semaphore) **C.VkSemaphore { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSemaphore)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSemaphore)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetWaitSemaphoreCount(uint32(len(y)))
}

// BufferBindCount returns the value of bufferBindCount from VkBindSparseInfo
func (x BindSparseInfo) BufferBindCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.bufferBindCount)
	return *ptr
}

// WithBufferBindCount clones a new BindSparseInfo with the value of
// BufferBindCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindSparseInfo) WithBufferBindCount(y uint32) BindSparseInfo {
	x.bufferBindCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *BindSparseInfo) SetBufferBindCount(y uint32) {
	x.bufferBindCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PBufferBinds returns the value of pBufferBinds from VkBindSparseInfo
func (x BindSparseInfo) PBufferBinds() []SparseBufferMemoryBindInfo {
	ptr := func(x **C.struct_VkSparseBufferMemoryBindInfo) *[]SparseBufferMemoryBindInfo { /* Slice */
		slc := unsafe.Slice((*SparseBufferMemoryBindInfo)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pBufferBinds)
	return *ptr
}

// WithPBufferBinds clones a new BindSparseInfo with the value of
// PBufferBinds updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines BufferBindCount as the length of this field.
// BufferBindCount is updated with the length of the new value.
func (x BindSparseInfo) WithPBufferBinds(y []SparseBufferMemoryBindInfo) BindSparseInfo {
	x.pBufferBinds = *(func(x *[]SparseBufferMemoryBindInfo) **C.struct_VkSparseBufferMemoryBindInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSparseBufferMemoryBindInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSparseBufferMemoryBindInfo)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithBufferBindCount(uint32(len(y)))
}
func (x *BindSparseInfo) SetPBufferBinds(y []SparseBufferMemoryBindInfo) {
	x.pBufferBinds = *(func(x *[]SparseBufferMemoryBindInfo) **C.struct_VkSparseBufferMemoryBindInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSparseBufferMemoryBindInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSparseBufferMemoryBindInfo)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetBufferBindCount(uint32(len(y)))
}

// ImageOpaqueBindCount returns the value of imageOpaqueBindCount from VkBindSparseInfo
func (x BindSparseInfo) ImageOpaqueBindCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.imageOpaqueBindCount)
	return *ptr
}

// WithImageOpaqueBindCount clones a new BindSparseInfo with the value of
// ImageOpaqueBindCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindSparseInfo) WithImageOpaqueBindCount(y uint32) BindSparseInfo {
	x.imageOpaqueBindCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *BindSparseInfo) SetImageOpaqueBindCount(y uint32) {
	x.imageOpaqueBindCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PImageOpaqueBinds returns the value of pImageOpaqueBinds from VkBindSparseInfo
func (x BindSparseInfo) PImageOpaqueBinds() []SparseImageOpaqueMemoryBindInfo {
	ptr := func(x **C.struct_VkSparseImageOpaqueMemoryBindInfo) *[]SparseImageOpaqueMemoryBindInfo { /* Slice */
		slc := unsafe.Slice((*SparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pImageOpaqueBinds)
	return *ptr
}

// WithPImageOpaqueBinds clones a new BindSparseInfo with the value of
// PImageOpaqueBinds updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines ImageOpaqueBindCount as the length of this field.
// ImageOpaqueBindCount is updated with the length of the new value.
func (x BindSparseInfo) WithPImageOpaqueBinds(y []SparseImageOpaqueMemoryBindInfo) BindSparseInfo {
	x.pImageOpaqueBinds = *(func(x *[]SparseImageOpaqueMemoryBindInfo) **C.struct_VkSparseImageOpaqueMemoryBindInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithImageOpaqueBindCount(uint32(len(y)))
}
func (x *BindSparseInfo) SetPImageOpaqueBinds(y []SparseImageOpaqueMemoryBindInfo) {
	x.pImageOpaqueBinds = *(func(x *[]SparseImageOpaqueMemoryBindInfo) **C.struct_VkSparseImageOpaqueMemoryBindInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetImageOpaqueBindCount(uint32(len(y)))
}

// ImageBindCount returns the value of imageBindCount from VkBindSparseInfo
func (x BindSparseInfo) ImageBindCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.imageBindCount)
	return *ptr
}

// WithImageBindCount clones a new BindSparseInfo with the value of
// ImageBindCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindSparseInfo) WithImageBindCount(y uint32) BindSparseInfo {
	x.imageBindCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *BindSparseInfo) SetImageBindCount(y uint32) {
	x.imageBindCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PImageBinds returns the value of pImageBinds from VkBindSparseInfo
func (x BindSparseInfo) PImageBinds() []SparseImageMemoryBindInfo {
	ptr := func(x **C.struct_VkSparseImageMemoryBindInfo) *[]SparseImageMemoryBindInfo { /* Slice */
		slc := unsafe.Slice((*SparseImageMemoryBindInfo)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pImageBinds)
	return *ptr
}

// WithPImageBinds clones a new BindSparseInfo with the value of
// PImageBinds updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines ImageBindCount as the length of this field.
// ImageBindCount is updated with the length of the new value.
func (x BindSparseInfo) WithPImageBinds(y []SparseImageMemoryBindInfo) BindSparseInfo {
	x.pImageBinds = *(func(x *[]SparseImageMemoryBindInfo) **C.struct_VkSparseImageMemoryBindInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSparseImageMemoryBindInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSparseImageMemoryBindInfo)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithImageBindCount(uint32(len(y)))
}
func (x *BindSparseInfo) SetPImageBinds(y []SparseImageMemoryBindInfo) {
	x.pImageBinds = *(func(x *[]SparseImageMemoryBindInfo) **C.struct_VkSparseImageMemoryBindInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSparseImageMemoryBindInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSparseImageMemoryBindInfo)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetImageBindCount(uint32(len(y)))
}

// SignalSemaphoreCount returns the value of signalSemaphoreCount from VkBindSparseInfo
func (x BindSparseInfo) SignalSemaphoreCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.signalSemaphoreCount)
	return *ptr
}

// WithSignalSemaphoreCount clones a new BindSparseInfo with the value of
// SignalSemaphoreCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindSparseInfo) WithSignalSemaphoreCount(y uint32) BindSparseInfo {
	x.signalSemaphoreCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *BindSparseInfo) SetSignalSemaphoreCount(y uint32) {
	x.signalSemaphoreCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PSignalSemaphores returns the value of pSignalSemaphores from VkBindSparseInfo
func (x BindSparseInfo) PSignalSemaphores() []Semaphore {
	ptr := func(x **C.VkSemaphore) *[]Semaphore { /* Slice */
		slc := unsafe.Slice((*Semaphore)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pSignalSemaphores)
	return *ptr
}

// WithPSignalSemaphores clones a new BindSparseInfo with the value of
// PSignalSemaphores updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SignalSemaphoreCount as the length of this field.
// SignalSemaphoreCount is updated with the length of the new value.
func (x BindSparseInfo) WithPSignalSemaphores(y []Semaphore) BindSparseInfo {
	x.pSignalSemaphores = *(func(x *[]Semaphore) **C.VkSemaphore { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSemaphore)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSemaphore)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithSignalSemaphoreCount(uint32(len(y)))
}
func (x *BindSparseInfo) SetPSignalSemaphores(y []Semaphore) {
	x.pSignalSemaphores = *(func(x *[]Semaphore) **C.VkSemaphore { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSemaphore)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSemaphore)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetSignalSemaphoreCount(uint32(len(y)))
}

// DescriptorPoolSize provides a go interface for VkDescriptorPoolSize.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolSize.html
type DescriptorPoolSize C.struct_VkDescriptorPoolSize

// SizeofDescriptorPoolSize is the memory size of a DescriptorPoolSize
var SizeofDescriptorPoolSize int = int(unsafe.Sizeof(DescriptorPoolSize{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DescriptorPoolSize) ArpPtr(arp *AutoReleasePool) *DescriptorPoolSize {
	ptr := newCBlock(cULong(SizeofDescriptorPoolSize))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DescriptorPoolSize)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorPoolSize) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorPoolSize) AsCPtr() *DescriptorPoolSize {
	clone := (*DescriptorPoolSize)(newCBlock(cULong(SizeofDescriptorPoolSize)))
	*clone = x
	return clone
}

// DescriptorPoolSizeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DescriptorPoolSizeCSlice(arp *AutoReleasePool, x ...DescriptorPoolSize) []DescriptorPoolSize {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorPoolSize * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DescriptorPoolSize)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DescriptorPoolSizeFreeCSlice releases the memory allocated by DescriptorPoolSizeMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorPoolSizeFreeCSlice(x []DescriptorPoolSize) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorPoolSizeMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorPoolSizeFreeCSlice must be called on the returned slice.
func DescriptorPoolSizeMakeCSlice(x ...DescriptorPoolSize) []DescriptorPoolSize {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorPoolSize * len(x)
	dst := unsafe.Slice((*DescriptorPoolSize)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Type_ returns the value of type from VkDescriptorPoolSize
func (x DescriptorPoolSize) Type_() DescriptorType {
	ptr := /* typedef */ (*DescriptorType)(&x._type)
	return *ptr
}

// WithType_ clones a new DescriptorPoolSize with the value of
// Type_ updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorPoolSize) WithType_(y DescriptorType) DescriptorPoolSize {
	x._type = *( /* typedef */ (*C.VkDescriptorType)(&y))
	return x
}
func (x *DescriptorPoolSize) SetType_(y DescriptorType) {
	x._type = *( /* typedef */ (*C.VkDescriptorType)(&y))
}

// DescriptorCount returns the value of descriptorCount from VkDescriptorPoolSize
func (x DescriptorPoolSize) DescriptorCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.descriptorCount)
	return *ptr
}

// WithDescriptorCount clones a new DescriptorPoolSize with the value of
// DescriptorCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorPoolSize) WithDescriptorCount(y uint32) DescriptorPoolSize {
	x.descriptorCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DescriptorPoolSize) SetDescriptorCount(y uint32) {
	x.descriptorCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// DescriptorPoolCreateInfo provides a go interface for VkDescriptorPoolCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolCreateInfo.html
type DescriptorPoolCreateInfo C.struct_VkDescriptorPoolCreateInfo

// SizeofDescriptorPoolCreateInfo is the memory size of a DescriptorPoolCreateInfo
var SizeofDescriptorPoolCreateInfo int = int(unsafe.Sizeof(DescriptorPoolCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DescriptorPoolCreateInfo) ArpPtr(arp *AutoReleasePool) *DescriptorPoolCreateInfo {
	ptr := newCBlock(cULong(SizeofDescriptorPoolCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DescriptorPoolCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorPoolCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorPoolCreateInfo) AsCPtr() *DescriptorPoolCreateInfo {
	clone := (*DescriptorPoolCreateInfo)(newCBlock(cULong(SizeofDescriptorPoolCreateInfo)))
	*clone = x
	return clone
}

// DescriptorPoolCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DescriptorPoolCreateInfoCSlice(arp *AutoReleasePool, x ...DescriptorPoolCreateInfo) []DescriptorPoolCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorPoolCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DescriptorPoolCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DescriptorPoolCreateInfoFreeCSlice releases the memory allocated by DescriptorPoolCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorPoolCreateInfoFreeCSlice(x []DescriptorPoolCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorPoolCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorPoolCreateInfoFreeCSlice must be called on the returned slice.
func DescriptorPoolCreateInfoMakeCSlice(x ...DescriptorPoolCreateInfo) []DescriptorPoolCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorPoolCreateInfo * len(x)
	dst := unsafe.Slice((*DescriptorPoolCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDescriptorPoolCreateInfo
func (x DescriptorPoolCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DescriptorPoolCreateInfo with the value of
// SType to the value provided in the specification.
func (x DescriptorPoolCreateInfo) WithDefaultSType() DescriptorPoolCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DescriptorPoolCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO)
}

// WithSType clones a new DescriptorPoolCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorPoolCreateInfo) WithSType(y StructureType) DescriptorPoolCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DescriptorPoolCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDescriptorPoolCreateInfo
func (x DescriptorPoolCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DescriptorPoolCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorPoolCreateInfo) WithPNext(y unsafe.Pointer) DescriptorPoolCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DescriptorPoolCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkDescriptorPoolCreateInfo
func (x DescriptorPoolCreateInfo) Flags() DescriptorPoolCreateFlags {
	ptr := /* typedef */ (*DescriptorPoolCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new DescriptorPoolCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorPoolCreateInfo) WithFlags(y DescriptorPoolCreateFlags) DescriptorPoolCreateInfo {
	x.flags = *( /* typedef */ (*C.VkDescriptorPoolCreateFlags)(&y))
	return x
}
func (x *DescriptorPoolCreateInfo) SetFlags(y DescriptorPoolCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkDescriptorPoolCreateFlags)(&y))
}

// MaxSets returns the value of maxSets from VkDescriptorPoolCreateInfo
func (x DescriptorPoolCreateInfo) MaxSets() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxSets)
	return *ptr
}

// WithMaxSets clones a new DescriptorPoolCreateInfo with the value of
// MaxSets updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorPoolCreateInfo) WithMaxSets(y uint32) DescriptorPoolCreateInfo {
	x.maxSets = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DescriptorPoolCreateInfo) SetMaxSets(y uint32) {
	x.maxSets = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PoolSizeCount returns the value of poolSizeCount from VkDescriptorPoolCreateInfo
func (x DescriptorPoolCreateInfo) PoolSizeCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.poolSizeCount)
	return *ptr
}

// WithPoolSizeCount clones a new DescriptorPoolCreateInfo with the value of
// PoolSizeCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorPoolCreateInfo) WithPoolSizeCount(y uint32) DescriptorPoolCreateInfo {
	x.poolSizeCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DescriptorPoolCreateInfo) SetPoolSizeCount(y uint32) {
	x.poolSizeCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PPoolSizes returns the value of pPoolSizes from VkDescriptorPoolCreateInfo
func (x DescriptorPoolCreateInfo) PPoolSizes() []DescriptorPoolSize {
	ptr := func(x **C.struct_VkDescriptorPoolSize) *[]DescriptorPoolSize { /* Slice */
		slc := unsafe.Slice((*DescriptorPoolSize)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pPoolSizes)
	return *ptr
}

// WithPPoolSizes clones a new DescriptorPoolCreateInfo with the value of
// PPoolSizes updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines PoolSizeCount as the length of this field.
// PoolSizeCount is updated with the length of the new value.
func (x DescriptorPoolCreateInfo) WithPPoolSizes(y []DescriptorPoolSize) DescriptorPoolCreateInfo {
	x.pPoolSizes = *(func(x *[]DescriptorPoolSize) **C.struct_VkDescriptorPoolSize { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDescriptorPoolSize)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDescriptorPoolSize)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithPoolSizeCount(uint32(len(y)))
}
func (x *DescriptorPoolCreateInfo) SetPPoolSizes(y []DescriptorPoolSize) {
	x.pPoolSizes = *(func(x *[]DescriptorPoolSize) **C.struct_VkDescriptorPoolSize { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDescriptorPoolSize)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDescriptorPoolSize)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetPoolSizeCount(uint32(len(y)))
}

// ImageMemoryBarrier provides a go interface for VkImageMemoryBarrier.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageMemoryBarrier.html
type ImageMemoryBarrier C.struct_VkImageMemoryBarrier

// SizeofImageMemoryBarrier is the memory size of a ImageMemoryBarrier
var SizeofImageMemoryBarrier int = int(unsafe.Sizeof(ImageMemoryBarrier{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ImageMemoryBarrier) ArpPtr(arp *AutoReleasePool) *ImageMemoryBarrier {
	ptr := newCBlock(cULong(SizeofImageMemoryBarrier))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ImageMemoryBarrier)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageMemoryBarrier) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageMemoryBarrier) AsCPtr() *ImageMemoryBarrier {
	clone := (*ImageMemoryBarrier)(newCBlock(cULong(SizeofImageMemoryBarrier)))
	*clone = x
	return clone
}

// ImageMemoryBarrierCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ImageMemoryBarrierCSlice(arp *AutoReleasePool, x ...ImageMemoryBarrier) []ImageMemoryBarrier {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageMemoryBarrier * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ImageMemoryBarrier)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ImageMemoryBarrierFreeCSlice releases the memory allocated by ImageMemoryBarrierMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageMemoryBarrierFreeCSlice(x []ImageMemoryBarrier) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageMemoryBarrierMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageMemoryBarrierFreeCSlice must be called on the returned slice.
func ImageMemoryBarrierMakeCSlice(x ...ImageMemoryBarrier) []ImageMemoryBarrier {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageMemoryBarrier * len(x)
	dst := unsafe.Slice((*ImageMemoryBarrier)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageMemoryBarrier
func (x ImageMemoryBarrier) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ImageMemoryBarrier with the value of
// SType to the value provided in the specification.
func (x ImageMemoryBarrier) WithDefaultSType() ImageMemoryBarrier {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ImageMemoryBarrier) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER)
}

// WithSType clones a new ImageMemoryBarrier with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithSType(y StructureType) ImageMemoryBarrier {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ImageMemoryBarrier) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkImageMemoryBarrier
func (x ImageMemoryBarrier) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ImageMemoryBarrier with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithPNext(y unsafe.Pointer) ImageMemoryBarrier {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ImageMemoryBarrier) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SrcAccessMask returns the value of srcAccessMask from VkImageMemoryBarrier
func (x ImageMemoryBarrier) SrcAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.srcAccessMask)
	return *ptr
}

// WithSrcAccessMask clones a new ImageMemoryBarrier with the value of
// SrcAccessMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithSrcAccessMask(y AccessFlags) ImageMemoryBarrier {
	x.srcAccessMask = *( /* typedef */ (*C.VkAccessFlags)(&y))
	return x
}
func (x *ImageMemoryBarrier) SetSrcAccessMask(y AccessFlags) {
	x.srcAccessMask = *( /* typedef */ (*C.VkAccessFlags)(&y))
}

// DstAccessMask returns the value of dstAccessMask from VkImageMemoryBarrier
func (x ImageMemoryBarrier) DstAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.dstAccessMask)
	return *ptr
}

// WithDstAccessMask clones a new ImageMemoryBarrier with the value of
// DstAccessMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithDstAccessMask(y AccessFlags) ImageMemoryBarrier {
	x.dstAccessMask = *( /* typedef */ (*C.VkAccessFlags)(&y))
	return x
}
func (x *ImageMemoryBarrier) SetDstAccessMask(y AccessFlags) {
	x.dstAccessMask = *( /* typedef */ (*C.VkAccessFlags)(&y))
}

// OldLayout returns the value of oldLayout from VkImageMemoryBarrier
func (x ImageMemoryBarrier) OldLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.oldLayout)
	return *ptr
}

// WithOldLayout clones a new ImageMemoryBarrier with the value of
// OldLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithOldLayout(y ImageLayout) ImageMemoryBarrier {
	x.oldLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
	return x
}
func (x *ImageMemoryBarrier) SetOldLayout(y ImageLayout) {
	x.oldLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
}

// NewLayout returns the value of newLayout from VkImageMemoryBarrier
func (x ImageMemoryBarrier) NewLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.newLayout)
	return *ptr
}

// WithNewLayout clones a new ImageMemoryBarrier with the value of
// NewLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithNewLayout(y ImageLayout) ImageMemoryBarrier {
	x.newLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
	return x
}
func (x *ImageMemoryBarrier) SetNewLayout(y ImageLayout) {
	x.newLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
}

// SrcQueueFamilyIndex returns the value of srcQueueFamilyIndex from VkImageMemoryBarrier
func (x ImageMemoryBarrier) SrcQueueFamilyIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.srcQueueFamilyIndex)
	return *ptr
}

// WithSrcQueueFamilyIndex clones a new ImageMemoryBarrier with the value of
// SrcQueueFamilyIndex updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithSrcQueueFamilyIndex(y uint32) ImageMemoryBarrier {
	x.srcQueueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *ImageMemoryBarrier) SetSrcQueueFamilyIndex(y uint32) {
	x.srcQueueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// DstQueueFamilyIndex returns the value of dstQueueFamilyIndex from VkImageMemoryBarrier
func (x ImageMemoryBarrier) DstQueueFamilyIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dstQueueFamilyIndex)
	return *ptr
}

// WithDstQueueFamilyIndex clones a new ImageMemoryBarrier with the value of
// DstQueueFamilyIndex updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithDstQueueFamilyIndex(y uint32) ImageMemoryBarrier {
	x.dstQueueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *ImageMemoryBarrier) SetDstQueueFamilyIndex(y uint32) {
	x.dstQueueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// Image returns the value of image from VkImageMemoryBarrier
func (x ImageMemoryBarrier) Image() Image {
	ptr := /* handle */ (*Image)(&x.image)
	return *ptr
}

// WithImage clones a new ImageMemoryBarrier with the value of
// Image updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithImage(y Image) ImageMemoryBarrier {
	x.image = *( /* handle */ (*C.VkImage)(&y))
	return x
}
func (x *ImageMemoryBarrier) SetImage(y Image) {
	x.image = *( /* handle */ (*C.VkImage)(&y))
}

// SubresourceRange returns the value of subresourceRange from VkImageMemoryBarrier
func (x ImageMemoryBarrier) SubresourceRange() ImageSubresourceRange {
	ptr := /* typedef */ (*ImageSubresourceRange)(&x.subresourceRange)
	return *ptr
}

// WithSubresourceRange clones a new ImageMemoryBarrier with the value of
// SubresourceRange updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithSubresourceRange(y ImageSubresourceRange) ImageMemoryBarrier {
	x.subresourceRange = *( /* typedef */ (*C.struct_VkImageSubresourceRange)(&y))
	return x
}
func (x *ImageMemoryBarrier) SetSubresourceRange(y ImageSubresourceRange) {
	x.subresourceRange = *( /* typedef */ (*C.struct_VkImageSubresourceRange)(&y))
}

// MemoryRequirements provides a go interface for VkMemoryRequirements.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryRequirements.html
type MemoryRequirements C.struct_VkMemoryRequirements

// SizeofMemoryRequirements is the memory size of a MemoryRequirements
var SizeofMemoryRequirements int = int(unsafe.Sizeof(MemoryRequirements{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x MemoryRequirements) ArpPtr(arp *AutoReleasePool) *MemoryRequirements {
	ptr := newCBlock(cULong(SizeofMemoryRequirements))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*MemoryRequirements)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryRequirements) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryRequirements) AsCPtr() *MemoryRequirements {
	clone := (*MemoryRequirements)(newCBlock(cULong(SizeofMemoryRequirements)))
	*clone = x
	return clone
}

// MemoryRequirementsCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func MemoryRequirementsCSlice(arp *AutoReleasePool, x ...MemoryRequirements) []MemoryRequirements {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryRequirements * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*MemoryRequirements)(ptr), len(x))
	copy(dst, x)
	return dst
}

// MemoryRequirementsFreeCSlice releases the memory allocated by MemoryRequirementsMakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryRequirementsFreeCSlice(x []MemoryRequirements) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryRequirementsMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryRequirementsFreeCSlice must be called on the returned slice.
func MemoryRequirementsMakeCSlice(x ...MemoryRequirements) []MemoryRequirements {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryRequirements * len(x)
	dst := unsafe.Slice((*MemoryRequirements)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Size returns the value of size from VkMemoryRequirements
func (x MemoryRequirements) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size)
	return *ptr
}

// Alignment returns the value of alignment from VkMemoryRequirements
func (x MemoryRequirements) Alignment() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.alignment)
	return *ptr
}

// MemoryTypeBits returns the value of memoryTypeBits from VkMemoryRequirements
func (x MemoryRequirements) MemoryTypeBits() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.memoryTypeBits)
	return *ptr
}

// LayerProperties provides a go interface for VkLayerProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkLayerProperties.html
type LayerProperties C.struct_VkLayerProperties

// SizeofLayerProperties is the memory size of a LayerProperties
var SizeofLayerProperties int = int(unsafe.Sizeof(LayerProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x LayerProperties) ArpPtr(arp *AutoReleasePool) *LayerProperties {
	ptr := newCBlock(cULong(SizeofLayerProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*LayerProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *LayerProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x LayerProperties) AsCPtr() *LayerProperties {
	clone := (*LayerProperties)(newCBlock(cULong(SizeofLayerProperties)))
	*clone = x
	return clone
}

// LayerPropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func LayerPropertiesCSlice(arp *AutoReleasePool, x ...LayerProperties) []LayerProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofLayerProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*LayerProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// LayerPropertiesFreeCSlice releases the memory allocated by LayerPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func LayerPropertiesFreeCSlice(x []LayerProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// LayerPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. LayerPropertiesFreeCSlice must be called on the returned slice.
func LayerPropertiesMakeCSlice(x ...LayerProperties) []LayerProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofLayerProperties * len(x)
	dst := unsafe.Slice((*LayerProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// LayerName returns the value of layerName from VkLayerProperties
func (x LayerProperties) LayerName() []byte {
	ptr := func(x *[VK_MAX_EXTENSION_NAME_SIZE]C.char) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_EXTENSION_NAME_SIZE)
		return &slc
	}(&x.layerName)
	return *ptr
}

// SpecVersion returns the value of specVersion from VkLayerProperties
func (x LayerProperties) SpecVersion() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.specVersion)
	return *ptr
}

// ImplementationVersion returns the value of implementationVersion from VkLayerProperties
func (x LayerProperties) ImplementationVersion() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.implementationVersion)
	return *ptr
}

// Description returns the value of description from VkLayerProperties
func (x LayerProperties) Description() []byte {
	ptr := func(x *[VK_MAX_DESCRIPTION_SIZE]C.char) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_DESCRIPTION_SIZE)
		return &slc
	}(&x.description)
	return *ptr
}

// MemoryBarrier provides a go interface for VkMemoryBarrier.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryBarrier.html
type MemoryBarrier C.struct_VkMemoryBarrier

// SizeofMemoryBarrier is the memory size of a MemoryBarrier
var SizeofMemoryBarrier int = int(unsafe.Sizeof(MemoryBarrier{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x MemoryBarrier) ArpPtr(arp *AutoReleasePool) *MemoryBarrier {
	ptr := newCBlock(cULong(SizeofMemoryBarrier))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*MemoryBarrier)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryBarrier) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryBarrier) AsCPtr() *MemoryBarrier {
	clone := (*MemoryBarrier)(newCBlock(cULong(SizeofMemoryBarrier)))
	*clone = x
	return clone
}

// MemoryBarrierCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func MemoryBarrierCSlice(arp *AutoReleasePool, x ...MemoryBarrier) []MemoryBarrier {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryBarrier * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*MemoryBarrier)(ptr), len(x))
	copy(dst, x)
	return dst
}

// MemoryBarrierFreeCSlice releases the memory allocated by MemoryBarrierMakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryBarrierFreeCSlice(x []MemoryBarrier) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryBarrierMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryBarrierFreeCSlice must be called on the returned slice.
func MemoryBarrierMakeCSlice(x ...MemoryBarrier) []MemoryBarrier {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryBarrier * len(x)
	dst := unsafe.Slice((*MemoryBarrier)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkMemoryBarrier
func (x MemoryBarrier) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new MemoryBarrier with the value of
// SType to the value provided in the specification.
func (x MemoryBarrier) WithDefaultSType() MemoryBarrier {
	return x.WithSType(VK_STRUCTURE_TYPE_MEMORY_BARRIER)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *MemoryBarrier) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_MEMORY_BARRIER)
}

// WithSType clones a new MemoryBarrier with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryBarrier) WithSType(y StructureType) MemoryBarrier {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *MemoryBarrier) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkMemoryBarrier
func (x MemoryBarrier) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new MemoryBarrier with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryBarrier) WithPNext(y unsafe.Pointer) MemoryBarrier {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *MemoryBarrier) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SrcAccessMask returns the value of srcAccessMask from VkMemoryBarrier
func (x MemoryBarrier) SrcAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.srcAccessMask)
	return *ptr
}

// WithSrcAccessMask clones a new MemoryBarrier with the value of
// SrcAccessMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryBarrier) WithSrcAccessMask(y AccessFlags) MemoryBarrier {
	x.srcAccessMask = *( /* typedef */ (*C.VkAccessFlags)(&y))
	return x
}
func (x *MemoryBarrier) SetSrcAccessMask(y AccessFlags) {
	x.srcAccessMask = *( /* typedef */ (*C.VkAccessFlags)(&y))
}

// DstAccessMask returns the value of dstAccessMask from VkMemoryBarrier
func (x MemoryBarrier) DstAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.dstAccessMask)
	return *ptr
}

// WithDstAccessMask clones a new MemoryBarrier with the value of
// DstAccessMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryBarrier) WithDstAccessMask(y AccessFlags) MemoryBarrier {
	x.dstAccessMask = *( /* typedef */ (*C.VkAccessFlags)(&y))
	return x
}
func (x *MemoryBarrier) SetDstAccessMask(y AccessFlags) {
	x.dstAccessMask = *( /* typedef */ (*C.VkAccessFlags)(&y))
}

// CopyDescriptorSet provides a go interface for VkCopyDescriptorSet.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyDescriptorSet.html
type CopyDescriptorSet C.struct_VkCopyDescriptorSet

// SizeofCopyDescriptorSet is the memory size of a CopyDescriptorSet
var SizeofCopyDescriptorSet int = int(unsafe.Sizeof(CopyDescriptorSet{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x CopyDescriptorSet) ArpPtr(arp *AutoReleasePool) *CopyDescriptorSet {
	ptr := newCBlock(cULong(SizeofCopyDescriptorSet))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*CopyDescriptorSet)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *CopyDescriptorSet) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x CopyDescriptorSet) AsCPtr() *CopyDescriptorSet {
	clone := (*CopyDescriptorSet)(newCBlock(cULong(SizeofCopyDescriptorSet)))
	*clone = x
	return clone
}

// CopyDescriptorSetCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func CopyDescriptorSetCSlice(arp *AutoReleasePool, x ...CopyDescriptorSet) []CopyDescriptorSet {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCopyDescriptorSet * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*CopyDescriptorSet)(ptr), len(x))
	copy(dst, x)
	return dst
}

// CopyDescriptorSetFreeCSlice releases the memory allocated by CopyDescriptorSetMakeCSlice.
// It does not free pointers stored inside the slice.
func CopyDescriptorSetFreeCSlice(x []CopyDescriptorSet) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// CopyDescriptorSetMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. CopyDescriptorSetFreeCSlice must be called on the returned slice.
func CopyDescriptorSetMakeCSlice(x ...CopyDescriptorSet) []CopyDescriptorSet {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCopyDescriptorSet * len(x)
	dst := unsafe.Slice((*CopyDescriptorSet)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkCopyDescriptorSet
func (x CopyDescriptorSet) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new CopyDescriptorSet with the value of
// SType to the value provided in the specification.
func (x CopyDescriptorSet) WithDefaultSType() CopyDescriptorSet {
	return x.WithSType(VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *CopyDescriptorSet) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET)
}

// WithSType clones a new CopyDescriptorSet with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyDescriptorSet) WithSType(y StructureType) CopyDescriptorSet {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *CopyDescriptorSet) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkCopyDescriptorSet
func (x CopyDescriptorSet) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new CopyDescriptorSet with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyDescriptorSet) WithPNext(y unsafe.Pointer) CopyDescriptorSet {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *CopyDescriptorSet) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SrcSet returns the value of srcSet from VkCopyDescriptorSet
func (x CopyDescriptorSet) SrcSet() DescriptorSet {
	ptr := /* handle */ (*DescriptorSet)(&x.srcSet)
	return *ptr
}

// WithSrcSet clones a new CopyDescriptorSet with the value of
// SrcSet updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyDescriptorSet) WithSrcSet(y DescriptorSet) CopyDescriptorSet {
	x.srcSet = *( /* handle */ (*C.VkDescriptorSet)(&y))
	return x
}
func (x *CopyDescriptorSet) SetSrcSet(y DescriptorSet) {
	x.srcSet = *( /* handle */ (*C.VkDescriptorSet)(&y))
}

// SrcBinding returns the value of srcBinding from VkCopyDescriptorSet
func (x CopyDescriptorSet) SrcBinding() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.srcBinding)
	return *ptr
}

// WithSrcBinding clones a new CopyDescriptorSet with the value of
// SrcBinding updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyDescriptorSet) WithSrcBinding(y uint32) CopyDescriptorSet {
	x.srcBinding = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *CopyDescriptorSet) SetSrcBinding(y uint32) {
	x.srcBinding = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// SrcArrayElement returns the value of srcArrayElement from VkCopyDescriptorSet
func (x CopyDescriptorSet) SrcArrayElement() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.srcArrayElement)
	return *ptr
}

// WithSrcArrayElement clones a new CopyDescriptorSet with the value of
// SrcArrayElement updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyDescriptorSet) WithSrcArrayElement(y uint32) CopyDescriptorSet {
	x.srcArrayElement = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *CopyDescriptorSet) SetSrcArrayElement(y uint32) {
	x.srcArrayElement = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// DstSet returns the value of dstSet from VkCopyDescriptorSet
func (x CopyDescriptorSet) DstSet() DescriptorSet {
	ptr := /* handle */ (*DescriptorSet)(&x.dstSet)
	return *ptr
}

// WithDstSet clones a new CopyDescriptorSet with the value of
// DstSet updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyDescriptorSet) WithDstSet(y DescriptorSet) CopyDescriptorSet {
	x.dstSet = *( /* handle */ (*C.VkDescriptorSet)(&y))
	return x
}
func (x *CopyDescriptorSet) SetDstSet(y DescriptorSet) {
	x.dstSet = *( /* handle */ (*C.VkDescriptorSet)(&y))
}

// DstBinding returns the value of dstBinding from VkCopyDescriptorSet
func (x CopyDescriptorSet) DstBinding() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dstBinding)
	return *ptr
}

// WithDstBinding clones a new CopyDescriptorSet with the value of
// DstBinding updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyDescriptorSet) WithDstBinding(y uint32) CopyDescriptorSet {
	x.dstBinding = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *CopyDescriptorSet) SetDstBinding(y uint32) {
	x.dstBinding = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// DstArrayElement returns the value of dstArrayElement from VkCopyDescriptorSet
func (x CopyDescriptorSet) DstArrayElement() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dstArrayElement)
	return *ptr
}

// WithDstArrayElement clones a new CopyDescriptorSet with the value of
// DstArrayElement updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyDescriptorSet) WithDstArrayElement(y uint32) CopyDescriptorSet {
	x.dstArrayElement = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *CopyDescriptorSet) SetDstArrayElement(y uint32) {
	x.dstArrayElement = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// DescriptorCount returns the value of descriptorCount from VkCopyDescriptorSet
func (x CopyDescriptorSet) DescriptorCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.descriptorCount)
	return *ptr
}

// WithDescriptorCount clones a new CopyDescriptorSet with the value of
// DescriptorCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyDescriptorSet) WithDescriptorCount(y uint32) CopyDescriptorSet {
	x.descriptorCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *CopyDescriptorSet) SetDescriptorCount(y uint32) {
	x.descriptorCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PipelineCacheHeaderVersionOne provides a go interface for VkPipelineCacheHeaderVersionOne.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCacheHeaderVersionOne.html
type PipelineCacheHeaderVersionOne C.struct_VkPipelineCacheHeaderVersionOne

// SizeofPipelineCacheHeaderVersionOne is the memory size of a PipelineCacheHeaderVersionOne
var SizeofPipelineCacheHeaderVersionOne int = int(unsafe.Sizeof(PipelineCacheHeaderVersionOne{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PipelineCacheHeaderVersionOne) ArpPtr(arp *AutoReleasePool) *PipelineCacheHeaderVersionOne {
	ptr := newCBlock(cULong(SizeofPipelineCacheHeaderVersionOne))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PipelineCacheHeaderVersionOne)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineCacheHeaderVersionOne) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineCacheHeaderVersionOne) AsCPtr() *PipelineCacheHeaderVersionOne {
	clone := (*PipelineCacheHeaderVersionOne)(newCBlock(cULong(SizeofPipelineCacheHeaderVersionOne)))
	*clone = x
	return clone
}

// PipelineCacheHeaderVersionOneCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PipelineCacheHeaderVersionOneCSlice(arp *AutoReleasePool, x ...PipelineCacheHeaderVersionOne) []PipelineCacheHeaderVersionOne {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineCacheHeaderVersionOne * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PipelineCacheHeaderVersionOne)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PipelineCacheHeaderVersionOneFreeCSlice releases the memory allocated by PipelineCacheHeaderVersionOneMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineCacheHeaderVersionOneFreeCSlice(x []PipelineCacheHeaderVersionOne) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineCacheHeaderVersionOneMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineCacheHeaderVersionOneFreeCSlice must be called on the returned slice.
func PipelineCacheHeaderVersionOneMakeCSlice(x ...PipelineCacheHeaderVersionOne) []PipelineCacheHeaderVersionOne {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineCacheHeaderVersionOne * len(x)
	dst := unsafe.Slice((*PipelineCacheHeaderVersionOne)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// HeaderSize returns the value of headerSize from VkPipelineCacheHeaderVersionOne
func (x PipelineCacheHeaderVersionOne) HeaderSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.headerSize)
	return *ptr
}

// WithHeaderSize clones a new PipelineCacheHeaderVersionOne with the value of
// HeaderSize updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheHeaderVersionOne) WithHeaderSize(y uint32) PipelineCacheHeaderVersionOne {
	x.headerSize = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *PipelineCacheHeaderVersionOne) SetHeaderSize(y uint32) {
	x.headerSize = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// HeaderVersion returns the value of headerVersion from VkPipelineCacheHeaderVersionOne
func (x PipelineCacheHeaderVersionOne) HeaderVersion() PipelineCacheHeaderVersion {
	ptr := /* typedef */ (*PipelineCacheHeaderVersion)(&x.headerVersion)
	return *ptr
}

// WithHeaderVersion clones a new PipelineCacheHeaderVersionOne with the value of
// HeaderVersion updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheHeaderVersionOne) WithHeaderVersion(y PipelineCacheHeaderVersion) PipelineCacheHeaderVersionOne {
	x.headerVersion = *( /* typedef */ (*C.VkPipelineCacheHeaderVersion)(&y))
	return x
}
func (x *PipelineCacheHeaderVersionOne) SetHeaderVersion(y PipelineCacheHeaderVersion) {
	x.headerVersion = *( /* typedef */ (*C.VkPipelineCacheHeaderVersion)(&y))
}

// VendorID returns the value of vendorID from VkPipelineCacheHeaderVersionOne
func (x PipelineCacheHeaderVersionOne) VendorID() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.vendorID)
	return *ptr
}

// WithVendorID clones a new PipelineCacheHeaderVersionOne with the value of
// VendorID updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheHeaderVersionOne) WithVendorID(y uint32) PipelineCacheHeaderVersionOne {
	x.vendorID = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *PipelineCacheHeaderVersionOne) SetVendorID(y uint32) {
	x.vendorID = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// DeviceID returns the value of deviceID from VkPipelineCacheHeaderVersionOne
func (x PipelineCacheHeaderVersionOne) DeviceID() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.deviceID)
	return *ptr
}

// WithDeviceID clones a new PipelineCacheHeaderVersionOne with the value of
// DeviceID updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheHeaderVersionOne) WithDeviceID(y uint32) PipelineCacheHeaderVersionOne {
	x.deviceID = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *PipelineCacheHeaderVersionOne) SetDeviceID(y uint32) {
	x.deviceID = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PipelineCacheUUID returns the value of pipelineCacheUUID from VkPipelineCacheHeaderVersionOne
func (x PipelineCacheHeaderVersionOne) PipelineCacheUUID() []byte {
	ptr := func(x *[VK_UUID_SIZE]C.uint8_t) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_UUID_SIZE)
		return &slc
	}(&x.pipelineCacheUUID)
	return *ptr
}

// WithPipelineCacheUUID clones a new PipelineCacheHeaderVersionOne with the value of
// PipelineCacheUUID updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheHeaderVersionOne) WithPipelineCacheUUID(y []byte) PipelineCacheHeaderVersionOne {
	ptr := func(x *[]byte) **C.uint8_t { /* Array */
		if len(*x) > 0 {
			slc := (*C.uint8_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint8_t)(unsafe.Pointer((&ptr)))
	}(&y)
	copy(x.pipelineCacheUUID[:], unsafe.Slice(*ptr, len(y)))
	return x
}
func (x *PipelineCacheHeaderVersionOne) SetPipelineCacheUUID(y []byte) {
	ptr := func(x *[]byte) **C.uint8_t { /* Array */
		if len(*x) > 0 {
			slc := (*C.uint8_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint8_t)(unsafe.Pointer((&ptr)))
	}(&y)
	copy(x.pipelineCacheUUID[:], unsafe.Slice(*ptr, len(y)))
}

// SamplerCreateInfo provides a go interface for VkSamplerCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerCreateInfo.html
type SamplerCreateInfo C.struct_VkSamplerCreateInfo

// SizeofSamplerCreateInfo is the memory size of a SamplerCreateInfo
var SizeofSamplerCreateInfo int = int(unsafe.Sizeof(SamplerCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SamplerCreateInfo) ArpPtr(arp *AutoReleasePool) *SamplerCreateInfo {
	ptr := newCBlock(cULong(SizeofSamplerCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SamplerCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SamplerCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SamplerCreateInfo) AsCPtr() *SamplerCreateInfo {
	clone := (*SamplerCreateInfo)(newCBlock(cULong(SizeofSamplerCreateInfo)))
	*clone = x
	return clone
}

// SamplerCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SamplerCreateInfoCSlice(arp *AutoReleasePool, x ...SamplerCreateInfo) []SamplerCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSamplerCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SamplerCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SamplerCreateInfoFreeCSlice releases the memory allocated by SamplerCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SamplerCreateInfoFreeCSlice(x []SamplerCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SamplerCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SamplerCreateInfoFreeCSlice must be called on the returned slice.
func SamplerCreateInfoMakeCSlice(x ...SamplerCreateInfo) []SamplerCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSamplerCreateInfo * len(x)
	dst := unsafe.Slice((*SamplerCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSamplerCreateInfo
func (x SamplerCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new SamplerCreateInfo with the value of
// SType to the value provided in the specification.
func (x SamplerCreateInfo) WithDefaultSType() SamplerCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *SamplerCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO)
}

// WithSType clones a new SamplerCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithSType(y StructureType) SamplerCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *SamplerCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkSamplerCreateInfo
func (x SamplerCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new SamplerCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithPNext(y unsafe.Pointer) SamplerCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *SamplerCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkSamplerCreateInfo
func (x SamplerCreateInfo) Flags() SamplerCreateFlags {
	ptr := /* typedef */ (*SamplerCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new SamplerCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithFlags(y SamplerCreateFlags) SamplerCreateInfo {
	x.flags = *( /* typedef */ (*C.VkSamplerCreateFlags)(&y))
	return x
}
func (x *SamplerCreateInfo) SetFlags(y SamplerCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkSamplerCreateFlags)(&y))
}

// MagFilter returns the value of magFilter from VkSamplerCreateInfo
func (x SamplerCreateInfo) MagFilter() Filter {
	ptr := /* typedef */ (*Filter)(&x.magFilter)
	return *ptr
}

// WithMagFilter clones a new SamplerCreateInfo with the value of
// MagFilter updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithMagFilter(y Filter) SamplerCreateInfo {
	x.magFilter = *( /* typedef */ (*C.VkFilter)(&y))
	return x
}
func (x *SamplerCreateInfo) SetMagFilter(y Filter) {
	x.magFilter = *( /* typedef */ (*C.VkFilter)(&y))
}

// MinFilter returns the value of minFilter from VkSamplerCreateInfo
func (x SamplerCreateInfo) MinFilter() Filter {
	ptr := /* typedef */ (*Filter)(&x.minFilter)
	return *ptr
}

// WithMinFilter clones a new SamplerCreateInfo with the value of
// MinFilter updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithMinFilter(y Filter) SamplerCreateInfo {
	x.minFilter = *( /* typedef */ (*C.VkFilter)(&y))
	return x
}
func (x *SamplerCreateInfo) SetMinFilter(y Filter) {
	x.minFilter = *( /* typedef */ (*C.VkFilter)(&y))
}

// MipmapMode returns the value of mipmapMode from VkSamplerCreateInfo
func (x SamplerCreateInfo) MipmapMode() SamplerMipmapMode {
	ptr := /* typedef */ (*SamplerMipmapMode)(&x.mipmapMode)
	return *ptr
}

// WithMipmapMode clones a new SamplerCreateInfo with the value of
// MipmapMode updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithMipmapMode(y SamplerMipmapMode) SamplerCreateInfo {
	x.mipmapMode = *( /* typedef */ (*C.VkSamplerMipmapMode)(&y))
	return x
}
func (x *SamplerCreateInfo) SetMipmapMode(y SamplerMipmapMode) {
	x.mipmapMode = *( /* typedef */ (*C.VkSamplerMipmapMode)(&y))
}

// AddressModeU returns the value of addressModeU from VkSamplerCreateInfo
func (x SamplerCreateInfo) AddressModeU() SamplerAddressMode {
	ptr := /* typedef */ (*SamplerAddressMode)(&x.addressModeU)
	return *ptr
}

// WithAddressModeU clones a new SamplerCreateInfo with the value of
// AddressModeU updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithAddressModeU(y SamplerAddressMode) SamplerCreateInfo {
	x.addressModeU = *( /* typedef */ (*C.VkSamplerAddressMode)(&y))
	return x
}
func (x *SamplerCreateInfo) SetAddressModeU(y SamplerAddressMode) {
	x.addressModeU = *( /* typedef */ (*C.VkSamplerAddressMode)(&y))
}

// AddressModeV returns the value of addressModeV from VkSamplerCreateInfo
func (x SamplerCreateInfo) AddressModeV() SamplerAddressMode {
	ptr := /* typedef */ (*SamplerAddressMode)(&x.addressModeV)
	return *ptr
}

// WithAddressModeV clones a new SamplerCreateInfo with the value of
// AddressModeV updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithAddressModeV(y SamplerAddressMode) SamplerCreateInfo {
	x.addressModeV = *( /* typedef */ (*C.VkSamplerAddressMode)(&y))
	return x
}
func (x *SamplerCreateInfo) SetAddressModeV(y SamplerAddressMode) {
	x.addressModeV = *( /* typedef */ (*C.VkSamplerAddressMode)(&y))
}

// AddressModeW returns the value of addressModeW from VkSamplerCreateInfo
func (x SamplerCreateInfo) AddressModeW() SamplerAddressMode {
	ptr := /* typedef */ (*SamplerAddressMode)(&x.addressModeW)
	return *ptr
}

// WithAddressModeW clones a new SamplerCreateInfo with the value of
// AddressModeW updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithAddressModeW(y SamplerAddressMode) SamplerCreateInfo {
	x.addressModeW = *( /* typedef */ (*C.VkSamplerAddressMode)(&y))
	return x
}
func (x *SamplerCreateInfo) SetAddressModeW(y SamplerAddressMode) {
	x.addressModeW = *( /* typedef */ (*C.VkSamplerAddressMode)(&y))
}

// MipLodBias returns the value of mipLodBias from VkSamplerCreateInfo
func (x SamplerCreateInfo) MipLodBias() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.mipLodBias)
	return *ptr
}

// WithMipLodBias clones a new SamplerCreateInfo with the value of
// MipLodBias updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithMipLodBias(y float32) SamplerCreateInfo {
	x.mipLodBias = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}
func (x *SamplerCreateInfo) SetMipLodBias(y float32) {
	x.mipLodBias = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
}

// AnisotropyEnable returns the value of anisotropyEnable from VkSamplerCreateInfo
func (x SamplerCreateInfo) AnisotropyEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.anisotropyEnable)
	return *ptr
}

// WithAnisotropyEnable clones a new SamplerCreateInfo with the value of
// AnisotropyEnable updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithAnisotropyEnable(y Bool32) SamplerCreateInfo {
	x.anisotropyEnable = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *SamplerCreateInfo) SetAnisotropyEnable(y Bool32) {
	x.anisotropyEnable = *( /* typedef */ (*C.VkBool32)(&y))
}

// MaxAnisotropy returns the value of maxAnisotropy from VkSamplerCreateInfo
func (x SamplerCreateInfo) MaxAnisotropy() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.maxAnisotropy)
	return *ptr
}

// WithMaxAnisotropy clones a new SamplerCreateInfo with the value of
// MaxAnisotropy updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithMaxAnisotropy(y float32) SamplerCreateInfo {
	x.maxAnisotropy = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}
func (x *SamplerCreateInfo) SetMaxAnisotropy(y float32) {
	x.maxAnisotropy = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
}

// CompareEnable returns the value of compareEnable from VkSamplerCreateInfo
func (x SamplerCreateInfo) CompareEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.compareEnable)
	return *ptr
}

// WithCompareEnable clones a new SamplerCreateInfo with the value of
// CompareEnable updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithCompareEnable(y Bool32) SamplerCreateInfo {
	x.compareEnable = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *SamplerCreateInfo) SetCompareEnable(y Bool32) {
	x.compareEnable = *( /* typedef */ (*C.VkBool32)(&y))
}

// CompareOp returns the value of compareOp from VkSamplerCreateInfo
func (x SamplerCreateInfo) CompareOp() CompareOp {
	ptr := /* typedef */ (*CompareOp)(&x.compareOp)
	return *ptr
}

// WithCompareOp clones a new SamplerCreateInfo with the value of
// CompareOp updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithCompareOp(y CompareOp) SamplerCreateInfo {
	x.compareOp = *( /* typedef */ (*C.VkCompareOp)(&y))
	return x
}
func (x *SamplerCreateInfo) SetCompareOp(y CompareOp) {
	x.compareOp = *( /* typedef */ (*C.VkCompareOp)(&y))
}

// MinLod returns the value of minLod from VkSamplerCreateInfo
func (x SamplerCreateInfo) MinLod() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.minLod)
	return *ptr
}

// WithMinLod clones a new SamplerCreateInfo with the value of
// MinLod updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithMinLod(y float32) SamplerCreateInfo {
	x.minLod = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}
func (x *SamplerCreateInfo) SetMinLod(y float32) {
	x.minLod = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
}

// MaxLod returns the value of maxLod from VkSamplerCreateInfo
func (x SamplerCreateInfo) MaxLod() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.maxLod)
	return *ptr
}

// WithMaxLod clones a new SamplerCreateInfo with the value of
// MaxLod updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithMaxLod(y float32) SamplerCreateInfo {
	x.maxLod = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}
func (x *SamplerCreateInfo) SetMaxLod(y float32) {
	x.maxLod = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
}

// BorderColor returns the value of borderColor from VkSamplerCreateInfo
func (x SamplerCreateInfo) BorderColor() BorderColor {
	ptr := /* typedef */ (*BorderColor)(&x.borderColor)
	return *ptr
}

// WithBorderColor clones a new SamplerCreateInfo with the value of
// BorderColor updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithBorderColor(y BorderColor) SamplerCreateInfo {
	x.borderColor = *( /* typedef */ (*C.VkBorderColor)(&y))
	return x
}
func (x *SamplerCreateInfo) SetBorderColor(y BorderColor) {
	x.borderColor = *( /* typedef */ (*C.VkBorderColor)(&y))
}

// UnnormalizedCoordinates returns the value of unnormalizedCoordinates from VkSamplerCreateInfo
func (x SamplerCreateInfo) UnnormalizedCoordinates() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.unnormalizedCoordinates)
	return *ptr
}

// WithUnnormalizedCoordinates clones a new SamplerCreateInfo with the value of
// UnnormalizedCoordinates updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithUnnormalizedCoordinates(y Bool32) SamplerCreateInfo {
	x.unnormalizedCoordinates = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *SamplerCreateInfo) SetUnnormalizedCoordinates(y Bool32) {
	x.unnormalizedCoordinates = *( /* typedef */ (*C.VkBool32)(&y))
}

// PushConstantRange provides a go interface for VkPushConstantRange.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPushConstantRange.html
type PushConstantRange C.struct_VkPushConstantRange

// SizeofPushConstantRange is the memory size of a PushConstantRange
var SizeofPushConstantRange int = int(unsafe.Sizeof(PushConstantRange{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PushConstantRange) ArpPtr(arp *AutoReleasePool) *PushConstantRange {
	ptr := newCBlock(cULong(SizeofPushConstantRange))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PushConstantRange)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PushConstantRange) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PushConstantRange) AsCPtr() *PushConstantRange {
	clone := (*PushConstantRange)(newCBlock(cULong(SizeofPushConstantRange)))
	*clone = x
	return clone
}

// PushConstantRangeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PushConstantRangeCSlice(arp *AutoReleasePool, x ...PushConstantRange) []PushConstantRange {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPushConstantRange * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PushConstantRange)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PushConstantRangeFreeCSlice releases the memory allocated by PushConstantRangeMakeCSlice.
// It does not free pointers stored inside the slice.
func PushConstantRangeFreeCSlice(x []PushConstantRange) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PushConstantRangeMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PushConstantRangeFreeCSlice must be called on the returned slice.
func PushConstantRangeMakeCSlice(x ...PushConstantRange) []PushConstantRange {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPushConstantRange * len(x)
	dst := unsafe.Slice((*PushConstantRange)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// StageFlags returns the value of stageFlags from VkPushConstantRange
func (x PushConstantRange) StageFlags() ShaderStageFlags {
	ptr := /* typedef */ (*ShaderStageFlags)(&x.stageFlags)
	return *ptr
}

// WithStageFlags clones a new PushConstantRange with the value of
// StageFlags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PushConstantRange) WithStageFlags(y ShaderStageFlags) PushConstantRange {
	x.stageFlags = *( /* typedef */ (*C.VkShaderStageFlags)(&y))
	return x
}
func (x *PushConstantRange) SetStageFlags(y ShaderStageFlags) {
	x.stageFlags = *( /* typedef */ (*C.VkShaderStageFlags)(&y))
}

// Offset returns the value of offset from VkPushConstantRange
func (x PushConstantRange) Offset() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.offset)
	return *ptr
}

// WithOffset clones a new PushConstantRange with the value of
// Offset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PushConstantRange) WithOffset(y uint32) PushConstantRange {
	x.offset = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *PushConstantRange) SetOffset(y uint32) {
	x.offset = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// Size returns the value of size from VkPushConstantRange
func (x PushConstantRange) Size() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.size)
	return *ptr
}

// WithSize clones a new PushConstantRange with the value of
// Size updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PushConstantRange) WithSize(y uint32) PushConstantRange {
	x.size = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *PushConstantRange) SetSize(y uint32) {
	x.size = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PipelineLayoutCreateInfo provides a go interface for VkPipelineLayoutCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineLayoutCreateInfo.html
type PipelineLayoutCreateInfo C.struct_VkPipelineLayoutCreateInfo

// SizeofPipelineLayoutCreateInfo is the memory size of a PipelineLayoutCreateInfo
var SizeofPipelineLayoutCreateInfo int = int(unsafe.Sizeof(PipelineLayoutCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PipelineLayoutCreateInfo) ArpPtr(arp *AutoReleasePool) *PipelineLayoutCreateInfo {
	ptr := newCBlock(cULong(SizeofPipelineLayoutCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PipelineLayoutCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineLayoutCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineLayoutCreateInfo) AsCPtr() *PipelineLayoutCreateInfo {
	clone := (*PipelineLayoutCreateInfo)(newCBlock(cULong(SizeofPipelineLayoutCreateInfo)))
	*clone = x
	return clone
}

// PipelineLayoutCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PipelineLayoutCreateInfoCSlice(arp *AutoReleasePool, x ...PipelineLayoutCreateInfo) []PipelineLayoutCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineLayoutCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PipelineLayoutCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PipelineLayoutCreateInfoFreeCSlice releases the memory allocated by PipelineLayoutCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineLayoutCreateInfoFreeCSlice(x []PipelineLayoutCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineLayoutCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineLayoutCreateInfoFreeCSlice must be called on the returned slice.
func PipelineLayoutCreateInfoMakeCSlice(x ...PipelineLayoutCreateInfo) []PipelineLayoutCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineLayoutCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineLayoutCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineLayoutCreateInfo
func (x PipelineLayoutCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PipelineLayoutCreateInfo with the value of
// SType to the value provided in the specification.
func (x PipelineLayoutCreateInfo) WithDefaultSType() PipelineLayoutCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PipelineLayoutCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO)
}

// WithSType clones a new PipelineLayoutCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineLayoutCreateInfo) WithSType(y StructureType) PipelineLayoutCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PipelineLayoutCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPipelineLayoutCreateInfo
func (x PipelineLayoutCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PipelineLayoutCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineLayoutCreateInfo) WithPNext(y unsafe.Pointer) PipelineLayoutCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PipelineLayoutCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkPipelineLayoutCreateInfo
func (x PipelineLayoutCreateInfo) Flags() PipelineLayoutCreateFlags {
	ptr := /* typedef */ (*PipelineLayoutCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new PipelineLayoutCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineLayoutCreateInfo) WithFlags(y PipelineLayoutCreateFlags) PipelineLayoutCreateInfo {
	x.flags = *( /* typedef */ (*C.VkPipelineLayoutCreateFlags)(&y))
	return x
}
func (x *PipelineLayoutCreateInfo) SetFlags(y PipelineLayoutCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkPipelineLayoutCreateFlags)(&y))
}

// SetLayoutCount returns the value of setLayoutCount from VkPipelineLayoutCreateInfo
func (x PipelineLayoutCreateInfo) SetLayoutCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.setLayoutCount)
	return *ptr
}

// WithSetLayoutCount clones a new PipelineLayoutCreateInfo with the value of
// SetLayoutCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineLayoutCreateInfo) WithSetLayoutCount(y uint32) PipelineLayoutCreateInfo {
	x.setLayoutCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *PipelineLayoutCreateInfo) SetSetLayoutCount(y uint32) {
	x.setLayoutCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PSetLayouts returns the value of pSetLayouts from VkPipelineLayoutCreateInfo
func (x PipelineLayoutCreateInfo) PSetLayouts() []DescriptorSetLayout {
	ptr := func(x **C.VkDescriptorSetLayout) *[]DescriptorSetLayout { /* Slice */
		slc := unsafe.Slice((*DescriptorSetLayout)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pSetLayouts)
	return *ptr
}

// WithPSetLayouts clones a new PipelineLayoutCreateInfo with the value of
// PSetLayouts updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SetLayoutCount as the length of this field.
// SetLayoutCount is updated with the length of the new value.
func (x PipelineLayoutCreateInfo) WithPSetLayouts(y []DescriptorSetLayout) PipelineLayoutCreateInfo {
	x.pSetLayouts = *(func(x *[]DescriptorSetLayout) **C.VkDescriptorSetLayout { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkDescriptorSetLayout)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkDescriptorSetLayout)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithSetLayoutCount(uint32(len(y)))
}
func (x *PipelineLayoutCreateInfo) SetPSetLayouts(y []DescriptorSetLayout) {
	x.pSetLayouts = *(func(x *[]DescriptorSetLayout) **C.VkDescriptorSetLayout { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkDescriptorSetLayout)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkDescriptorSetLayout)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetSetLayoutCount(uint32(len(y)))
}

// PushConstantRangeCount returns the value of pushConstantRangeCount from VkPipelineLayoutCreateInfo
func (x PipelineLayoutCreateInfo) PushConstantRangeCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.pushConstantRangeCount)
	return *ptr
}

// WithPushConstantRangeCount clones a new PipelineLayoutCreateInfo with the value of
// PushConstantRangeCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineLayoutCreateInfo) WithPushConstantRangeCount(y uint32) PipelineLayoutCreateInfo {
	x.pushConstantRangeCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *PipelineLayoutCreateInfo) SetPushConstantRangeCount(y uint32) {
	x.pushConstantRangeCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PPushConstantRanges returns the value of pPushConstantRanges from VkPipelineLayoutCreateInfo
func (x PipelineLayoutCreateInfo) PPushConstantRanges() []PushConstantRange {
	ptr := func(x **C.struct_VkPushConstantRange) *[]PushConstantRange { /* Slice */
		slc := unsafe.Slice((*PushConstantRange)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pPushConstantRanges)
	return *ptr
}

// WithPPushConstantRanges clones a new PipelineLayoutCreateInfo with the value of
// PPushConstantRanges updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines PushConstantRangeCount as the length of this field.
// PushConstantRangeCount is updated with the length of the new value.
func (x PipelineLayoutCreateInfo) WithPPushConstantRanges(y []PushConstantRange) PipelineLayoutCreateInfo {
	x.pPushConstantRanges = *(func(x *[]PushConstantRange) **C.struct_VkPushConstantRange { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkPushConstantRange)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkPushConstantRange)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithPushConstantRangeCount(uint32(len(y)))
}
func (x *PipelineLayoutCreateInfo) SetPPushConstantRanges(y []PushConstantRange) {
	x.pPushConstantRanges = *(func(x *[]PushConstantRange) **C.struct_VkPushConstantRange { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkPushConstantRange)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkPushConstantRange)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetPushConstantRangeCount(uint32(len(y)))
}

// CreateShaderModule command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateShaderModule.html
func (x DeviceFacade) CreateShaderModule(pCreateInfo *ShaderModuleCreateInfo, pAllocator *AllocationCallbacks, pShaderModule *ShaderModule) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **ShaderModuleCreateInfo) **C.struct_VkShaderModuleCreateInfo { /* Pointer */
		g2c := (*C.struct_VkShaderModuleCreateInfo)(*x)
		return &g2c
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p3 := func(x **ShaderModule) **C.VkShaderModule { /* Pointer */ g2c := (*C.VkShaderModule)(*x); return &g2c }(&pShaderModule)
	ret := C.vkCreateShaderModule(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetDeviceProcAddr command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceProcAddr.html
func (x DeviceFacade) GetDeviceProcAddr(pName *byte) PFN_vkVoidFunction {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **byte) **C.char { /* Pointer */ return (**C.char)(unsafe.Pointer(x)) }(&pName)
	ret := C.vkGetDeviceProcAddr(addrs, *p0, *p1)
	retPtr := /* typedef */ (*PFN_vkVoidFunction)(&ret)
	return *retPtr
}

// ResetDescriptorPool command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetDescriptorPool.html
func (x DeviceFacade) ResetDescriptorPool(descriptorPool DescriptorPool, flags DescriptorPoolResetFlags) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDescriptorPool)(&descriptorPool)
	p2 := /* typedef */ (*C.VkDescriptorPoolResetFlags)(&flags)
	ret := C.vkResetDescriptorPool(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// AllocateDescriptorSets command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAllocateDescriptorSets.html
func (x DeviceFacade) AllocateDescriptorSets(pAllocateInfo *DescriptorSetAllocateInfo, pDescriptorSets []DescriptorSet) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DescriptorSetAllocateInfo) **C.struct_VkDescriptorSetAllocateInfo { /* Pointer */
		g2c := (*C.struct_VkDescriptorSetAllocateInfo)(*x)
		return &g2c
	}(&pAllocateInfo)
	p2 := func(x *[]DescriptorSet) **C.VkDescriptorSet { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkDescriptorSet)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkDescriptorSet)(unsafe.Pointer((&ptr)))
	}(&pDescriptorSets)
	ret := C.vkAllocateDescriptorSets(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// FreeDescriptorSets command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFreeDescriptorSets.html
func (x DeviceFacade) FreeDescriptorSets(descriptorPool DescriptorPool, descriptorSetCount uint32, pDescriptorSets []DescriptorSet) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDescriptorPool)(&descriptorPool)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&descriptorSetCount)
	p3 := func(x *[]DescriptorSet) **C.VkDescriptorSet { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkDescriptorSet)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkDescriptorSet)(unsafe.Pointer((&ptr)))
	}(&pDescriptorSets)
	ret := C.vkFreeDescriptorSets(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// UpdateDescriptorSets command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUpdateDescriptorSets.html
func (x DeviceFacade) UpdateDescriptorSets(descriptorWriteCount uint32, pDescriptorWrites []WriteDescriptorSet, descriptorCopyCount uint32, pDescriptorCopies []CopyDescriptorSet) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&descriptorWriteCount)
	p2 := func(x *[]WriteDescriptorSet) **C.struct_VkWriteDescriptorSet { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkWriteDescriptorSet)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkWriteDescriptorSet)(unsafe.Pointer((&ptr)))
	}(&pDescriptorWrites)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&descriptorCopyCount)
	p4 := func(x *[]CopyDescriptorSet) **C.struct_VkCopyDescriptorSet { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkCopyDescriptorSet)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkCopyDescriptorSet)(unsafe.Pointer((&ptr)))
	}(&pDescriptorCopies)
	C.vkUpdateDescriptorSets(addrs, *p0, *p1, *p2, *p3, *p4)
}

// GetPhysicalDeviceMemoryProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceMemoryProperties.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceMemoryProperties(pMemoryProperties *PhysicalDeviceMemoryProperties) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceMemoryProperties) **C.struct_VkPhysicalDeviceMemoryProperties { /* Pointer */
		g2c := (*C.struct_VkPhysicalDeviceMemoryProperties)(*x)
		return &g2c
	}(&pMemoryProperties)
	C.vkGetPhysicalDeviceMemoryProperties(addrs, *p0, *p1)
}

// DestroyQueryPool command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyQueryPool.html
func (x DeviceFacade) DestroyQueryPool(queryPool QueryPool, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkQueryPool)(&queryPool)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	C.vkDestroyQueryPool(addrs, *p0, *p1, *p2)
}

// GetInstanceProcAddr command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetInstanceProcAddr.html
func GetInstanceProcAddr(instance Instance, pName *byte) PFN_vkVoidFunction {
	addrs := &C.vksProcAddresses
	p0 := /* handle */ (*C.VkInstance)(&instance)
	p1 := func(x **byte) **C.char { /* Pointer */ return (**C.char)(unsafe.Pointer(x)) }(&pName)
	ret := C.vkGetInstanceProcAddr(addrs, *p0, *p1)
	retPtr := /* typedef */ (*PFN_vkVoidFunction)(&ret)
	return *retPtr
}

// CreateImageView command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateImageView.html
func (x DeviceFacade) CreateImageView(pCreateInfo *ImageViewCreateInfo, pAllocator *AllocationCallbacks, pView *ImageView) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **ImageViewCreateInfo) **C.struct_VkImageViewCreateInfo { /* Pointer */
		g2c := (*C.struct_VkImageViewCreateInfo)(*x)
		return &g2c
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p3 := func(x **ImageView) **C.VkImageView { /* Pointer */ g2c := (*C.VkImageView)(*x); return &g2c }(&pView)
	ret := C.vkCreateImageView(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetImageSparseMemoryRequirements command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageSparseMemoryRequirements.html
func (x DeviceFacade) GetImageSparseMemoryRequirements(image Image, pSparseMemoryRequirementCount *uint32, pSparseMemoryRequirements []SparseImageMemoryRequirements) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&image)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pSparseMemoryRequirementCount)
	p3 := func(x *[]SparseImageMemoryRequirements) **C.struct_VkSparseImageMemoryRequirements { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSparseImageMemoryRequirements)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSparseImageMemoryRequirements)(unsafe.Pointer((&ptr)))
	}(&pSparseMemoryRequirements)
	C.vkGetImageSparseMemoryRequirements(addrs, *p0, *p1, *p2, *p3)
}

// BindImageMemory command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindImageMemory.html
func (x DeviceFacade) BindImageMemory(image Image, memory DeviceMemory, memoryOffset DeviceSize) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&image)
	p2 := /* handle */ (*C.VkDeviceMemory)(&memory)
	p3 := /* typedef */ (*C.VkDeviceSize)(&memoryOffset)
	ret := C.vkBindImageMemory(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceSparseImageFormatProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSparseImageFormatProperties.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceSparseImageFormatProperties(format Format, type_ ImageType, samples SampleCountFlagBits, usage ImageUsageFlags, tiling ImageTiling, pPropertyCount *uint32, pProperties []SparseImageFormatProperties) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* typedef */ (*C.VkFormat)(&format)
	p2 := /* typedef */ (*C.VkImageType)(&type_)
	p3 := /* typedef */ (*C.VkSampleCountFlagBits)(&samples)
	p4 := /* typedef */ (*C.VkImageUsageFlags)(&usage)
	p5 := /* typedef */ (*C.VkImageTiling)(&tiling)
	p6 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPropertyCount)
	p7 := func(x *[]SparseImageFormatProperties) **C.struct_VkSparseImageFormatProperties { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSparseImageFormatProperties)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSparseImageFormatProperties)(unsafe.Pointer((&ptr)))
	}(&pProperties)
	C.vkGetPhysicalDeviceSparseImageFormatProperties(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7)
}

// BindBufferMemory command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindBufferMemory.html
func (x DeviceFacade) BindBufferMemory(buffer Buffer, memory DeviceMemory, memoryOffset DeviceSize) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&buffer)
	p2 := /* handle */ (*C.VkDeviceMemory)(&memory)
	p3 := /* typedef */ (*C.VkDeviceSize)(&memoryOffset)
	ret := C.vkBindBufferMemory(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// QueueBindSparse command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueBindSparse.html
func (x QueueFacade) QueueBindSparse(bindInfoCount uint32, pBindInfo []BindSparseInfo, fence Fence) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkQueue)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&bindInfoCount)
	p2 := func(x *[]BindSparseInfo) **C.struct_VkBindSparseInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkBindSparseInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkBindSparseInfo)(unsafe.Pointer((&ptr)))
	}(&pBindInfo)
	p3 := /* handle */ (*C.VkFence)(&fence)
	ret := C.vkQueueBindSparse(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// EnumerateDeviceLayerProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateDeviceLayerProperties.html
func (x PhysicalDeviceFacade) EnumerateDeviceLayerProperties(pPropertyCount *uint32, pProperties []LayerProperties) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPropertyCount)
	p2 := func(x *[]LayerProperties) **C.struct_VkLayerProperties { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkLayerProperties)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkLayerProperties)(unsafe.Pointer((&ptr)))
	}(&pProperties)
	ret := C.vkEnumerateDeviceLayerProperties(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// EnumerateInstanceLayerProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceLayerProperties.html
func EnumerateInstanceLayerProperties(pPropertyCount *uint32, pProperties []LayerProperties) Result {
	addrs := &C.vksProcAddresses
	p0 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPropertyCount)
	p1 := func(x *[]LayerProperties) **C.struct_VkLayerProperties { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkLayerProperties)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkLayerProperties)(unsafe.Pointer((&ptr)))
	}(&pProperties)
	ret := C.vkEnumerateInstanceLayerProperties(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceQueueFamilyProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceQueueFamilyProperties.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceQueueFamilyProperties(pQueueFamilyPropertyCount *uint32, pQueueFamilyProperties []QueueFamilyProperties) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pQueueFamilyPropertyCount)
	p2 := func(x *[]QueueFamilyProperties) **C.struct_VkQueueFamilyProperties { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkQueueFamilyProperties)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkQueueFamilyProperties)(unsafe.Pointer((&ptr)))
	}(&pQueueFamilyProperties)
	C.vkGetPhysicalDeviceQueueFamilyProperties(addrs, *p0, *p1, *p2)
}

// DestroyFence command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyFence.html
func (x DeviceFacade) DestroyFence(fence Fence, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkFence)(&fence)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	C.vkDestroyFence(addrs, *p0, *p1, *p2)
}

// ResetFences command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetFences.html
func (x DeviceFacade) ResetFences(fenceCount uint32, pFences []Fence) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&fenceCount)
	p2 := func(x *[]Fence) **C.VkFence { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkFence)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkFence)(unsafe.Pointer((&ptr)))
	}(&pFences)
	ret := C.vkResetFences(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetFenceStatus command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetFenceStatus.html
func (x DeviceFacade) GetFenceStatus(fence Fence) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkFence)(&fence)
	ret := C.vkGetFenceStatus(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// WaitForFences command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkWaitForFences.html
func (x DeviceFacade) WaitForFences(fenceCount uint32, pFences []Fence, waitAll Bool32, timeout uint64) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&fenceCount)
	p2 := func(x *[]Fence) **C.VkFence { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkFence)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkFence)(unsafe.Pointer((&ptr)))
	}(&pFences)
	p3 := /* typedef */ (*C.VkBool32)(&waitAll)
	p4 := func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&timeout)
	ret := C.vkWaitForFences(addrs, *p0, *p1, *p2, *p3, *p4)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroyPipeline command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPipeline.html
func (x DeviceFacade) DestroyPipeline(pipeline Pipeline, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkPipeline)(&pipeline)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	C.vkDestroyPipeline(addrs, *p0, *p1, *p2)
}

// CreateComputePipelines command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateComputePipelines.html
func (x DeviceFacade) CreateComputePipelines(pipelineCache PipelineCache, createInfoCount uint32, pCreateInfos []ComputePipelineCreateInfo, pAllocator *AllocationCallbacks, pPipelines []Pipeline) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkPipelineCache)(&pipelineCache)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&createInfoCount)
	p3 := func(x *[]ComputePipelineCreateInfo) **C.struct_VkComputePipelineCreateInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkComputePipelineCreateInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkComputePipelineCreateInfo)(unsafe.Pointer((&ptr)))
	}(&pCreateInfos)
	p4 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p5 := func(x *[]Pipeline) **C.VkPipeline { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkPipeline)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkPipeline)(unsafe.Pointer((&ptr)))
	}(&pPipelines)
	ret := C.vkCreateComputePipelines(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CreateFramebuffer command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateFramebuffer.html
func (x DeviceFacade) CreateFramebuffer(pCreateInfo *FramebufferCreateInfo, pAllocator *AllocationCallbacks, pFramebuffer *Framebuffer) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **FramebufferCreateInfo) **C.struct_VkFramebufferCreateInfo { /* Pointer */
		g2c := (*C.struct_VkFramebufferCreateInfo)(*x)
		return &g2c
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p3 := func(x **Framebuffer) **C.VkFramebuffer { /* Pointer */ g2c := (*C.VkFramebuffer)(*x); return &g2c }(&pFramebuffer)
	ret := C.vkCreateFramebuffer(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroyFramebuffer command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyFramebuffer.html
func (x DeviceFacade) DestroyFramebuffer(framebuffer Framebuffer, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkFramebuffer)(&framebuffer)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	C.vkDestroyFramebuffer(addrs, *p0, *p1, *p2)
}

// CreateRenderPass command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateRenderPass.html
func (x DeviceFacade) CreateRenderPass(pCreateInfo *RenderPassCreateInfo, pAllocator *AllocationCallbacks, pRenderPass *RenderPass) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **RenderPassCreateInfo) **C.struct_VkRenderPassCreateInfo { /* Pointer */
		g2c := (*C.struct_VkRenderPassCreateInfo)(*x)
		return &g2c
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p3 := func(x **RenderPass) **C.VkRenderPass { /* Pointer */ g2c := (*C.VkRenderPass)(*x); return &g2c }(&pRenderPass)
	ret := C.vkCreateRenderPass(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroyRenderPass command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyRenderPass.html
func (x DeviceFacade) DestroyRenderPass(renderPass RenderPass, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkRenderPass)(&renderPass)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	C.vkDestroyRenderPass(addrs, *p0, *p1, *p2)
}

// GetRenderAreaGranularity command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetRenderAreaGranularity.html
func (x DeviceFacade) GetRenderAreaGranularity(renderPass RenderPass, pGranularity *Extent2D) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkRenderPass)(&renderPass)
	p2 := func(x **Extent2D) **C.struct_VkExtent2D { /* Pointer */ g2c := (*C.struct_VkExtent2D)(*x); return &g2c }(&pGranularity)
	C.vkGetRenderAreaGranularity(addrs, *p0, *p1, *p2)
}

// CreateGraphicsPipelines command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateGraphicsPipelines.html
func (x DeviceFacade) CreateGraphicsPipelines(pipelineCache PipelineCache, createInfoCount uint32, pCreateInfos []GraphicsPipelineCreateInfo, pAllocator *AllocationCallbacks, pPipelines []Pipeline) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkPipelineCache)(&pipelineCache)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&createInfoCount)
	p3 := func(x *[]GraphicsPipelineCreateInfo) **C.struct_VkGraphicsPipelineCreateInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkGraphicsPipelineCreateInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkGraphicsPipelineCreateInfo)(unsafe.Pointer((&ptr)))
	}(&pCreateInfos)
	p4 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p5 := func(x *[]Pipeline) **C.VkPipeline { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkPipeline)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkPipeline)(unsafe.Pointer((&ptr)))
	}(&pPipelines)
	ret := C.vkCreateGraphicsPipelines(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// EnumerateDeviceExtensionProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateDeviceExtensionProperties.html
func (x PhysicalDeviceFacade) EnumerateDeviceExtensionProperties(pLayerName *byte, pPropertyCount *uint32, pProperties []ExtensionProperties) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **byte) **C.char { /* Pointer */ return (**C.char)(unsafe.Pointer(x)) }(&pLayerName)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPropertyCount)
	p3 := func(x *[]ExtensionProperties) **C.struct_VkExtensionProperties { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkExtensionProperties)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkExtensionProperties)(unsafe.Pointer((&ptr)))
	}(&pProperties)
	ret := C.vkEnumerateDeviceExtensionProperties(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// EnumerateInstanceExtensionProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html
func EnumerateInstanceExtensionProperties(pLayerName *byte, pPropertyCount *uint32, pProperties []ExtensionProperties) Result {
	addrs := &C.vksProcAddresses
	p0 := func(x **byte) **C.char { /* Pointer */ return (**C.char)(unsafe.Pointer(x)) }(&pLayerName)
	p1 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPropertyCount)
	p2 := func(x *[]ExtensionProperties) **C.struct_VkExtensionProperties { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkExtensionProperties)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkExtensionProperties)(unsafe.Pointer((&ptr)))
	}(&pProperties)
	ret := C.vkEnumerateInstanceExtensionProperties(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// MergePipelineCaches command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkMergePipelineCaches.html
func (x DeviceFacade) MergePipelineCaches(dstCache PipelineCache, srcCacheCount uint32, pSrcCaches []PipelineCache) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkPipelineCache)(&dstCache)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&srcCacheCount)
	p3 := func(x *[]PipelineCache) **C.VkPipelineCache { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkPipelineCache)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkPipelineCache)(unsafe.Pointer((&ptr)))
	}(&pSrcCaches)
	ret := C.vkMergePipelineCaches(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetDeviceMemoryCommitment command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceMemoryCommitment.html
func (x DeviceFacade) GetDeviceMemoryCommitment(memory DeviceMemory, pCommittedMemoryInBytes *DeviceSize) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDeviceMemory)(&memory)
	p2 := func(x **DeviceSize) **C.VkDeviceSize { /* Pointer */ g2c := (*C.VkDeviceSize)(*x); return &g2c }(&pCommittedMemoryInBytes)
	C.vkGetDeviceMemoryCommitment(addrs, *p0, *p1, *p2)
}

// CreateDescriptorPool command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDescriptorPool.html
func (x DeviceFacade) CreateDescriptorPool(pCreateInfo *DescriptorPoolCreateInfo, pAllocator *AllocationCallbacks, pDescriptorPool *DescriptorPool) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DescriptorPoolCreateInfo) **C.struct_VkDescriptorPoolCreateInfo { /* Pointer */
		g2c := (*C.struct_VkDescriptorPoolCreateInfo)(*x)
		return &g2c
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p3 := func(x **DescriptorPool) **C.VkDescriptorPool { /* Pointer */
		g2c := (*C.VkDescriptorPool)(*x)
		return &g2c
	}(&pDescriptorPool)
	ret := C.vkCreateDescriptorPool(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPipelineCacheData command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelineCacheData.html
func (x DeviceFacade) GetPipelineCacheData(pipelineCache PipelineCache, pDataSize *uint64, pData unsafe.Pointer) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkPipelineCache)(&pipelineCache)
	p2 := func(x **uint64) **C.size_t { /* Pointer */ g2c := (*C.size_t)(*x); return &g2c }(&pDataSize)
	p3 := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&pData)
	ret := C.vkGetPipelineCacheData(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroyDescriptorSetLayout command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDescriptorSetLayout.html
func (x DeviceFacade) DestroyDescriptorSetLayout(descriptorSetLayout DescriptorSetLayout, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDescriptorSetLayout)(&descriptorSetLayout)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	C.vkDestroyDescriptorSetLayout(addrs, *p0, *p1, *p2)
}

// CreateDescriptorSetLayout command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDescriptorSetLayout.html
func (x DeviceFacade) CreateDescriptorSetLayout(pCreateInfo *DescriptorSetLayoutCreateInfo, pAllocator *AllocationCallbacks, pSetLayout *DescriptorSetLayout) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DescriptorSetLayoutCreateInfo) **C.struct_VkDescriptorSetLayoutCreateInfo { /* Pointer */
		g2c := (*C.struct_VkDescriptorSetLayoutCreateInfo)(*x)
		return &g2c
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p3 := func(x **DescriptorSetLayout) **C.VkDescriptorSetLayout { /* Pointer */
		g2c := (*C.VkDescriptorSetLayout)(*x)
		return &g2c
	}(&pSetLayout)
	ret := C.vkCreateDescriptorSetLayout(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// InvalidateMappedMemoryRanges command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkInvalidateMappedMemoryRanges.html
func (x DeviceFacade) InvalidateMappedMemoryRanges(memoryRangeCount uint32, pMemoryRanges []MappedMemoryRange) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&memoryRangeCount)
	p2 := func(x *[]MappedMemoryRange) **C.struct_VkMappedMemoryRange { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkMappedMemoryRange)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkMappedMemoryRange)(unsafe.Pointer((&ptr)))
	}(&pMemoryRanges)
	ret := C.vkInvalidateMappedMemoryRanges(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetImageMemoryRequirements command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageMemoryRequirements.html
func (x DeviceFacade) GetImageMemoryRequirements(image Image, pMemoryRequirements *MemoryRequirements) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&image)
	p2 := func(x **MemoryRequirements) **C.struct_VkMemoryRequirements { /* Pointer */
		g2c := (*C.struct_VkMemoryRequirements)(*x)
		return &g2c
	}(&pMemoryRequirements)
	C.vkGetImageMemoryRequirements(addrs, *p0, *p1, *p2)
}

// QueueWaitIdle command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueWaitIdle.html
func (x QueueFacade) QueueWaitIdle() Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkQueue)(&x.H)
	ret := C.vkQueueWaitIdle(addrs, *p0)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// FlushMappedMemoryRanges command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFlushMappedMemoryRanges.html
func (x DeviceFacade) FlushMappedMemoryRanges(memoryRangeCount uint32, pMemoryRanges []MappedMemoryRange) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&memoryRangeCount)
	p2 := func(x *[]MappedMemoryRange) **C.struct_VkMappedMemoryRange { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkMappedMemoryRange)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkMappedMemoryRange)(unsafe.Pointer((&ptr)))
	}(&pMemoryRanges)
	ret := C.vkFlushMappedMemoryRanges(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroyPipelineCache command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPipelineCache.html
func (x DeviceFacade) DestroyPipelineCache(pipelineCache PipelineCache, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkPipelineCache)(&pipelineCache)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	C.vkDestroyPipelineCache(addrs, *p0, *p1, *p2)
}

// GetBufferMemoryRequirements command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferMemoryRequirements.html
func (x DeviceFacade) GetBufferMemoryRequirements(buffer Buffer, pMemoryRequirements *MemoryRequirements) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&buffer)
	p2 := func(x **MemoryRequirements) **C.struct_VkMemoryRequirements { /* Pointer */
		g2c := (*C.struct_VkMemoryRequirements)(*x)
		return &g2c
	}(&pMemoryRequirements)
	C.vkGetBufferMemoryRequirements(addrs, *p0, *p1, *p2)
}

// CreateInstance command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateInstance.html
func CreateInstance(pCreateInfo *InstanceCreateInfo, pAllocator *AllocationCallbacks, pInstance *Instance) Result {
	addrs := &C.vksProcAddresses
	p0 := func(x **InstanceCreateInfo) **C.struct_VkInstanceCreateInfo { /* Pointer */
		g2c := (*C.struct_VkInstanceCreateInfo)(*x)
		return &g2c
	}(&pCreateInfo)
	p1 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p2 := func(x **Instance) **C.VkInstance { /* Pointer */ g2c := (*C.VkInstance)(*x); return &g2c }(&pInstance)
	ret := C.vkCreateInstance(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroyInstance command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyInstance.html
func (x InstanceFacade) DestroyInstance(pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkInstance)(&x.H)
	p1 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	C.vkDestroyInstance(addrs, *p0, *p1)
}

// UnmapMemory command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUnmapMemory.html
func (x DeviceFacade) UnmapMemory(memory DeviceMemory) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDeviceMemory)(&memory)
	C.vkUnmapMemory(addrs, *p0, *p1)
}

// CreatePipelineCache command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreatePipelineCache.html
func (x DeviceFacade) CreatePipelineCache(pCreateInfo *PipelineCacheCreateInfo, pAllocator *AllocationCallbacks, pPipelineCache *PipelineCache) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **PipelineCacheCreateInfo) **C.struct_VkPipelineCacheCreateInfo { /* Pointer */
		g2c := (*C.struct_VkPipelineCacheCreateInfo)(*x)
		return &g2c
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p3 := func(x **PipelineCache) **C.VkPipelineCache { /* Pointer */ g2c := (*C.VkPipelineCache)(*x); return &g2c }(&pPipelineCache)
	ret := C.vkCreatePipelineCache(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CreateSemaphore command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSemaphore.html
func (x DeviceFacade) CreateSemaphore(pCreateInfo *SemaphoreCreateInfo, pAllocator *AllocationCallbacks, pSemaphore *Semaphore) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **SemaphoreCreateInfo) **C.struct_VkSemaphoreCreateInfo { /* Pointer */
		g2c := (*C.struct_VkSemaphoreCreateInfo)(*x)
		return &g2c
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p3 := func(x **Semaphore) **C.VkSemaphore { /* Pointer */ g2c := (*C.VkSemaphore)(*x); return &g2c }(&pSemaphore)
	ret := C.vkCreateSemaphore(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroyShaderModule command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyShaderModule.html
func (x DeviceFacade) DestroyShaderModule(shaderModule ShaderModule, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkShaderModule)(&shaderModule)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	C.vkDestroyShaderModule(addrs, *p0, *p1, *p2)
}

// EnumeratePhysicalDevices command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumeratePhysicalDevices.html
func (x InstanceFacade) EnumeratePhysicalDevices(pPhysicalDeviceCount *uint32, pPhysicalDevices []PhysicalDevice) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkInstance)(&x.H)
	p1 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPhysicalDeviceCount)
	p2 := func(x *[]PhysicalDevice) **C.VkPhysicalDevice { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkPhysicalDevice)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkPhysicalDevice)(unsafe.Pointer((&ptr)))
	}(&pPhysicalDevices)
	ret := C.vkEnumeratePhysicalDevices(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// MapMemory command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkMapMemory.html
func (x DeviceFacade) MapMemory(memory DeviceMemory, offset DeviceSize, size DeviceSize, flags MemoryMapFlags, ppData *unsafe.Pointer) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDeviceMemory)(&memory)
	p2 := /* typedef */ (*C.VkDeviceSize)(&offset)
	p3 := /* typedef */ (*C.VkDeviceSize)(&size)
	p4 := /* typedef */ (*C.VkMemoryMapFlags)(&flags)
	p5 := func(x **unsafe.Pointer) **unsafe.Pointer { /* Pointer */ g2c := (*unsafe.Pointer)(*x); return &g2c }(&ppData)
	ret := C.vkMapMemory(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CreateCommandPool command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateCommandPool.html
func (x DeviceFacade) CreateCommandPool(pCreateInfo *CommandPoolCreateInfo, pAllocator *AllocationCallbacks, pCommandPool *CommandPool) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **CommandPoolCreateInfo) **C.struct_VkCommandPoolCreateInfo { /* Pointer */
		g2c := (*C.struct_VkCommandPoolCreateInfo)(*x)
		return &g2c
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p3 := func(x **CommandPool) **C.VkCommandPool { /* Pointer */ g2c := (*C.VkCommandPool)(*x); return &g2c }(&pCommandPool)
	ret := C.vkCreateCommandPool(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroyCommandPool command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyCommandPool.html
func (x DeviceFacade) DestroyCommandPool(commandPool CommandPool, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkCommandPool)(&commandPool)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	C.vkDestroyCommandPool(addrs, *p0, *p1, *p2)
}

// ResetCommandPool command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetCommandPool.html
func (x DeviceFacade) ResetCommandPool(commandPool CommandPool, flags CommandPoolResetFlags) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkCommandPool)(&commandPool)
	p2 := /* typedef */ (*C.VkCommandPoolResetFlags)(&flags)
	ret := C.vkResetCommandPool(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceFeatures command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFeatures.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceFeatures(pFeatures *PhysicalDeviceFeatures) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceFeatures) **C.struct_VkPhysicalDeviceFeatures { /* Pointer */
		g2c := (*C.struct_VkPhysicalDeviceFeatures)(*x)
		return &g2c
	}(&pFeatures)
	C.vkGetPhysicalDeviceFeatures(addrs, *p0, *p1)
}

// GetPhysicalDeviceFormatProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFormatProperties.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceFormatProperties(format Format, pFormatProperties *FormatProperties) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* typedef */ (*C.VkFormat)(&format)
	p2 := func(x **FormatProperties) **C.struct_VkFormatProperties { /* Pointer */
		g2c := (*C.struct_VkFormatProperties)(*x)
		return &g2c
	}(&pFormatProperties)
	C.vkGetPhysicalDeviceFormatProperties(addrs, *p0, *p1, *p2)
}

// FreeMemory command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFreeMemory.html
func (x DeviceFacade) FreeMemory(memory DeviceMemory, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDeviceMemory)(&memory)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	C.vkFreeMemory(addrs, *p0, *p1, *p2)
}

// CreatePipelineLayout command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreatePipelineLayout.html
func (x DeviceFacade) CreatePipelineLayout(pCreateInfo *PipelineLayoutCreateInfo, pAllocator *AllocationCallbacks, pPipelineLayout *PipelineLayout) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **PipelineLayoutCreateInfo) **C.struct_VkPipelineLayoutCreateInfo { /* Pointer */
		g2c := (*C.struct_VkPipelineLayoutCreateInfo)(*x)
		return &g2c
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p3 := func(x **PipelineLayout) **C.VkPipelineLayout { /* Pointer */
		g2c := (*C.VkPipelineLayout)(*x)
		return &g2c
	}(&pPipelineLayout)
	ret := C.vkCreatePipelineLayout(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroySampler command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySampler.html
func (x DeviceFacade) DestroySampler(sampler Sampler, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkSampler)(&sampler)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	C.vkDestroySampler(addrs, *p0, *p1, *p2)
}

// AllocateMemory command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAllocateMemory.html
func (x DeviceFacade) AllocateMemory(pAllocateInfo *MemoryAllocateInfo, pAllocator *AllocationCallbacks, pMemory *DeviceMemory) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **MemoryAllocateInfo) **C.struct_VkMemoryAllocateInfo { /* Pointer */
		g2c := (*C.struct_VkMemoryAllocateInfo)(*x)
		return &g2c
	}(&pAllocateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p3 := func(x **DeviceMemory) **C.VkDeviceMemory { /* Pointer */ g2c := (*C.VkDeviceMemory)(*x); return &g2c }(&pMemory)
	ret := C.vkAllocateMemory(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// AllocateCommandBuffers command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAllocateCommandBuffers.html
func (x DeviceFacade) AllocateCommandBuffers(pAllocateInfo *CommandBufferAllocateInfo, pCommandBuffers []CommandBuffer) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **CommandBufferAllocateInfo) **C.struct_VkCommandBufferAllocateInfo { /* Pointer */
		g2c := (*C.struct_VkCommandBufferAllocateInfo)(*x)
		return &g2c
	}(&pAllocateInfo)
	p2 := func(x *[]CommandBuffer) **C.VkCommandBuffer { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkCommandBuffer)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkCommandBuffer)(unsafe.Pointer((&ptr)))
	}(&pCommandBuffers)
	ret := C.vkAllocateCommandBuffers(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// FreeCommandBuffers command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFreeCommandBuffers.html
func (x DeviceFacade) FreeCommandBuffers(commandPool CommandPool, commandBufferCount uint32, pCommandBuffers []CommandBuffer) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkCommandPool)(&commandPool)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&commandBufferCount)
	p3 := func(x *[]CommandBuffer) **C.VkCommandBuffer { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkCommandBuffer)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkCommandBuffer)(unsafe.Pointer((&ptr)))
	}(&pCommandBuffers)
	C.vkFreeCommandBuffers(addrs, *p0, *p1, *p2, *p3)
}

// BeginCommandBuffer command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBeginCommandBuffer.html
func (x CommandBufferFacade) BeginCommandBuffer(pBeginInfo *CommandBufferBeginInfo) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **CommandBufferBeginInfo) **C.struct_VkCommandBufferBeginInfo { /* Pointer */
		g2c := (*C.struct_VkCommandBufferBeginInfo)(*x)
		return &g2c
	}(&pBeginInfo)
	ret := C.vkBeginCommandBuffer(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// EndCommandBuffer command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEndCommandBuffer.html
func (x CommandBufferFacade) EndCommandBuffer() Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	ret := C.vkEndCommandBuffer(addrs, *p0)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// ResetCommandBuffer command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetCommandBuffer.html
func (x CommandBufferFacade) ResetCommandBuffer(flags CommandBufferResetFlags) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkCommandBufferResetFlags)(&flags)
	ret := C.vkResetCommandBuffer(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CreateSampler command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSampler.html
func (x DeviceFacade) CreateSampler(pCreateInfo *SamplerCreateInfo, pAllocator *AllocationCallbacks, pSampler *Sampler) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **SamplerCreateInfo) **C.struct_VkSamplerCreateInfo { /* Pointer */
		g2c := (*C.struct_VkSamplerCreateInfo)(*x)
		return &g2c
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p3 := func(x **Sampler) **C.VkSampler { /* Pointer */ g2c := (*C.VkSampler)(*x); return &g2c }(&pSampler)
	ret := C.vkCreateSampler(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroySemaphore command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySemaphore.html
func (x DeviceFacade) DestroySemaphore(semaphore Semaphore, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkSemaphore)(&semaphore)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	C.vkDestroySemaphore(addrs, *p0, *p1, *p2)
}

// CreateBuffer command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateBuffer.html
func (x DeviceFacade) CreateBuffer(pCreateInfo *BufferCreateInfo, pAllocator *AllocationCallbacks, pBuffer *Buffer) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **BufferCreateInfo) **C.struct_VkBufferCreateInfo { /* Pointer */
		g2c := (*C.struct_VkBufferCreateInfo)(*x)
		return &g2c
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p3 := func(x **Buffer) **C.VkBuffer { /* Pointer */ g2c := (*C.VkBuffer)(*x); return &g2c }(&pBuffer)
	ret := C.vkCreateBuffer(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroyDescriptorPool command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDescriptorPool.html
func (x DeviceFacade) DestroyDescriptorPool(descriptorPool DescriptorPool, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDescriptorPool)(&descriptorPool)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	C.vkDestroyDescriptorPool(addrs, *p0, *p1, *p2)
}

// CreateFence command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateFence.html
func (x DeviceFacade) CreateFence(pCreateInfo *FenceCreateInfo, pAllocator *AllocationCallbacks, pFence *Fence) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **FenceCreateInfo) **C.struct_VkFenceCreateInfo { /* Pointer */
		g2c := (*C.struct_VkFenceCreateInfo)(*x)
		return &g2c
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p3 := func(x **Fence) **C.VkFence { /* Pointer */ g2c := (*C.VkFence)(*x); return &g2c }(&pFence)
	ret := C.vkCreateFence(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceProperties.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceProperties(pProperties *PhysicalDeviceProperties) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceProperties) **C.struct_VkPhysicalDeviceProperties { /* Pointer */
		g2c := (*C.struct_VkPhysicalDeviceProperties)(*x)
		return &g2c
	}(&pProperties)
	C.vkGetPhysicalDeviceProperties(addrs, *p0, *p1)
}

// GetImageSubresourceLayout command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageSubresourceLayout.html
func (x DeviceFacade) GetImageSubresourceLayout(image Image, pSubresource *ImageSubresource, pLayout *SubresourceLayout) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&image)
	p2 := func(x **ImageSubresource) **C.struct_VkImageSubresource { /* Pointer */
		g2c := (*C.struct_VkImageSubresource)(*x)
		return &g2c
	}(&pSubresource)
	p3 := func(x **SubresourceLayout) **C.struct_VkSubresourceLayout { /* Pointer */
		g2c := (*C.struct_VkSubresourceLayout)(*x)
		return &g2c
	}(&pLayout)
	C.vkGetImageSubresourceLayout(addrs, *p0, *p1, *p2, *p3)
}

// DestroyImage command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyImage.html
func (x DeviceFacade) DestroyImage(image Image, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&image)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	C.vkDestroyImage(addrs, *p0, *p1, *p2)
}

// GetDeviceQueue command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceQueue.html
func (x DeviceFacade) GetDeviceQueue(queueFamilyIndex uint32, queueIndex uint32, pQueue *Queue) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&queueFamilyIndex)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&queueIndex)
	p3 := func(x **Queue) **C.VkQueue { /* Pointer */ g2c := (*C.VkQueue)(*x); return &g2c }(&pQueue)
	C.vkGetDeviceQueue(addrs, *p0, *p1, *p2, *p3)
}

// CreateImage command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateImage.html
func (x DeviceFacade) CreateImage(pCreateInfo *ImageCreateInfo, pAllocator *AllocationCallbacks, pImage *Image) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **ImageCreateInfo) **C.struct_VkImageCreateInfo { /* Pointer */
		g2c := (*C.struct_VkImageCreateInfo)(*x)
		return &g2c
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p3 := func(x **Image) **C.VkImage { /* Pointer */ g2c := (*C.VkImage)(*x); return &g2c }(&pImage)
	ret := C.vkCreateImage(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// QueueSubmit command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueSubmit.html
func (x QueueFacade) QueueSubmit(submitCount uint32, pSubmits []SubmitInfo, fence Fence) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkQueue)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&submitCount)
	p2 := func(x *[]SubmitInfo) **C.struct_VkSubmitInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSubmitInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSubmitInfo)(unsafe.Pointer((&ptr)))
	}(&pSubmits)
	p3 := /* handle */ (*C.VkFence)(&fence)
	ret := C.vkQueueSubmit(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CmdBindPipeline command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindPipeline.html
func (x CommandBufferFacade) CmdBindPipeline(pipelineBindPoint PipelineBindPoint, pipeline Pipeline) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkPipelineBindPoint)(&pipelineBindPoint)
	p2 := /* handle */ (*C.VkPipeline)(&pipeline)
	C.vkCmdBindPipeline(addrs, *p0, *p1, *p2)
}

// CmdSetViewport command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewport.html
func (x CommandBufferFacade) CmdSetViewport(firstViewport uint32, viewportCount uint32, pViewports []Viewport) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&firstViewport)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&viewportCount)
	p3 := func(x *[]Viewport) **C.struct_VkViewport { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkViewport)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkViewport)(unsafe.Pointer((&ptr)))
	}(&pViewports)
	C.vkCmdSetViewport(addrs, *p0, *p1, *p2, *p3)
}

// CmdSetScissor command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetScissor.html
func (x CommandBufferFacade) CmdSetScissor(firstScissor uint32, scissorCount uint32, pScissors []Rect2D) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&firstScissor)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&scissorCount)
	p3 := func(x *[]Rect2D) **C.struct_VkRect2D { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkRect2D)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkRect2D)(unsafe.Pointer((&ptr)))
	}(&pScissors)
	C.vkCmdSetScissor(addrs, *p0, *p1, *p2, *p3)
}

// CmdSetLineWidth command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetLineWidth.html
func (x CommandBufferFacade) CmdSetLineWidth(lineWidth float32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&lineWidth)
	C.vkCmdSetLineWidth(addrs, *p0, *p1)
}

// CmdSetDepthBias command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBias.html
func (x CommandBufferFacade) CmdSetDepthBias(depthBiasConstantFactor float32, depthBiasClamp float32, depthBiasSlopeFactor float32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&depthBiasConstantFactor)
	p2 := func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&depthBiasClamp)
	p3 := func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&depthBiasSlopeFactor)
	C.vkCmdSetDepthBias(addrs, *p0, *p1, *p2, *p3)
}

// CmdSetBlendConstants command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetBlendConstants.html
func (x CommandBufferFacade) CmdSetBlendConstants(blendConstants []float32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *[]float32) **C.float { /* Array */
		if len(*x) > 0 {
			slc := (*C.float)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.float)(unsafe.Pointer((&ptr)))
	}(&blendConstants)
	C.vkCmdSetBlendConstants(addrs, *p0, *p1)
}

// CmdSetDepthBounds command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBounds.html
func (x CommandBufferFacade) CmdSetDepthBounds(minDepthBounds float32, maxDepthBounds float32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&minDepthBounds)
	p2 := func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&maxDepthBounds)
	C.vkCmdSetDepthBounds(addrs, *p0, *p1, *p2)
}

// CmdSetStencilCompareMask command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilCompareMask.html
func (x CommandBufferFacade) CmdSetStencilCompareMask(faceMask StencilFaceFlags, compareMask uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkStencilFaceFlags)(&faceMask)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&compareMask)
	C.vkCmdSetStencilCompareMask(addrs, *p0, *p1, *p2)
}

// CmdSetStencilWriteMask command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilWriteMask.html
func (x CommandBufferFacade) CmdSetStencilWriteMask(faceMask StencilFaceFlags, writeMask uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkStencilFaceFlags)(&faceMask)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&writeMask)
	C.vkCmdSetStencilWriteMask(addrs, *p0, *p1, *p2)
}

// CmdSetStencilReference command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilReference.html
func (x CommandBufferFacade) CmdSetStencilReference(faceMask StencilFaceFlags, reference uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkStencilFaceFlags)(&faceMask)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&reference)
	C.vkCmdSetStencilReference(addrs, *p0, *p1, *p2)
}

// CmdBindDescriptorSets command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindDescriptorSets.html
func (x CommandBufferFacade) CmdBindDescriptorSets(pipelineBindPoint PipelineBindPoint, layout PipelineLayout, firstSet uint32, descriptorSetCount uint32, pDescriptorSets []DescriptorSet, dynamicOffsetCount uint32, pDynamicOffsets []uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkPipelineBindPoint)(&pipelineBindPoint)
	p2 := /* handle */ (*C.VkPipelineLayout)(&layout)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&firstSet)
	p4 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&descriptorSetCount)
	p5 := func(x *[]DescriptorSet) **C.VkDescriptorSet { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkDescriptorSet)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkDescriptorSet)(unsafe.Pointer((&ptr)))
	}(&pDescriptorSets)
	p6 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&dynamicOffsetCount)
	p7 := func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&pDynamicOffsets)
	C.vkCmdBindDescriptorSets(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7)
}

// CmdBindIndexBuffer command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindIndexBuffer.html
func (x CommandBufferFacade) CmdBindIndexBuffer(buffer Buffer, offset DeviceSize, indexType IndexType) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&buffer)
	p2 := /* typedef */ (*C.VkDeviceSize)(&offset)
	p3 := /* typedef */ (*C.VkIndexType)(&indexType)
	C.vkCmdBindIndexBuffer(addrs, *p0, *p1, *p2, *p3)
}

// CmdBindVertexBuffers command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindVertexBuffers.html
func (x CommandBufferFacade) CmdBindVertexBuffers(firstBinding uint32, bindingCount uint32, pBuffers []Buffer, pOffsets []DeviceSize) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&firstBinding)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&bindingCount)
	p3 := func(x *[]Buffer) **C.VkBuffer { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkBuffer)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkBuffer)(unsafe.Pointer((&ptr)))
	}(&pBuffers)
	p4 := func(x *[]DeviceSize) **C.VkDeviceSize { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkDeviceSize)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkDeviceSize)(unsafe.Pointer((&ptr)))
	}(&pOffsets)
	C.vkCmdBindVertexBuffers(addrs, *p0, *p1, *p2, *p3, *p4)
}

// CmdDraw command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDraw.html
func (x CommandBufferFacade) CmdDraw(vertexCount uint32, instanceCount uint32, firstVertex uint32, firstInstance uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&vertexCount)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&instanceCount)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&firstVertex)
	p4 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&firstInstance)
	C.vkCmdDraw(addrs, *p0, *p1, *p2, *p3, *p4)
}

// CmdDrawIndexed command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndexed.html
func (x CommandBufferFacade) CmdDrawIndexed(indexCount uint32, instanceCount uint32, firstIndex uint32, vertexOffset int32, firstInstance uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&indexCount)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&instanceCount)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&firstIndex)
	p4 := func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&vertexOffset)
	p5 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&firstInstance)
	C.vkCmdDrawIndexed(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
}

// CmdDrawIndirect command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndirect.html
func (x CommandBufferFacade) CmdDrawIndirect(buffer Buffer, offset DeviceSize, drawCount uint32, stride uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&buffer)
	p2 := /* typedef */ (*C.VkDeviceSize)(&offset)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&drawCount)
	p4 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&stride)
	C.vkCmdDrawIndirect(addrs, *p0, *p1, *p2, *p3, *p4)
}

// CmdDrawIndexedIndirect command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndexedIndirect.html
func (x CommandBufferFacade) CmdDrawIndexedIndirect(buffer Buffer, offset DeviceSize, drawCount uint32, stride uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&buffer)
	p2 := /* typedef */ (*C.VkDeviceSize)(&offset)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&drawCount)
	p4 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&stride)
	C.vkCmdDrawIndexedIndirect(addrs, *p0, *p1, *p2, *p3, *p4)
}

// CmdDispatch command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDispatch.html
func (x CommandBufferFacade) CmdDispatch(groupCountX uint32, groupCountY uint32, groupCountZ uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&groupCountX)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&groupCountY)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&groupCountZ)
	C.vkCmdDispatch(addrs, *p0, *p1, *p2, *p3)
}

// CmdDispatchIndirect command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDispatchIndirect.html
func (x CommandBufferFacade) CmdDispatchIndirect(buffer Buffer, offset DeviceSize) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&buffer)
	p2 := /* typedef */ (*C.VkDeviceSize)(&offset)
	C.vkCmdDispatchIndirect(addrs, *p0, *p1, *p2)
}

// CmdCopyBuffer command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBuffer.html
func (x CommandBufferFacade) CmdCopyBuffer(srcBuffer Buffer, dstBuffer Buffer, regionCount uint32, pRegions []BufferCopy) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&srcBuffer)
	p2 := /* handle */ (*C.VkBuffer)(&dstBuffer)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&regionCount)
	p4 := func(x *[]BufferCopy) **C.struct_VkBufferCopy { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkBufferCopy)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkBufferCopy)(unsafe.Pointer((&ptr)))
	}(&pRegions)
	C.vkCmdCopyBuffer(addrs, *p0, *p1, *p2, *p3, *p4)
}

// CmdCopyImage command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImage.html
func (x CommandBufferFacade) CmdCopyImage(srcImage Image, srcImageLayout ImageLayout, dstImage Image, dstImageLayout ImageLayout, regionCount uint32, pRegions []ImageCopy) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&srcImage)
	p2 := /* typedef */ (*C.VkImageLayout)(&srcImageLayout)
	p3 := /* handle */ (*C.VkImage)(&dstImage)
	p4 := /* typedef */ (*C.VkImageLayout)(&dstImageLayout)
	p5 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&regionCount)
	p6 := func(x *[]ImageCopy) **C.struct_VkImageCopy { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkImageCopy)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkImageCopy)(unsafe.Pointer((&ptr)))
	}(&pRegions)
	C.vkCmdCopyImage(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6)
}

// CmdBlitImage command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBlitImage.html
func (x CommandBufferFacade) CmdBlitImage(srcImage Image, srcImageLayout ImageLayout, dstImage Image, dstImageLayout ImageLayout, regionCount uint32, pRegions []ImageBlit, filter Filter) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&srcImage)
	p2 := /* typedef */ (*C.VkImageLayout)(&srcImageLayout)
	p3 := /* handle */ (*C.VkImage)(&dstImage)
	p4 := /* typedef */ (*C.VkImageLayout)(&dstImageLayout)
	p5 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&regionCount)
	p6 := func(x *[]ImageBlit) **C.struct_VkImageBlit { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkImageBlit)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkImageBlit)(unsafe.Pointer((&ptr)))
	}(&pRegions)
	p7 := /* typedef */ (*C.VkFilter)(&filter)
	C.vkCmdBlitImage(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7)
}

// CmdCopyBufferToImage command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBufferToImage.html
func (x CommandBufferFacade) CmdCopyBufferToImage(srcBuffer Buffer, dstImage Image, dstImageLayout ImageLayout, regionCount uint32, pRegions []BufferImageCopy) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&srcBuffer)
	p2 := /* handle */ (*C.VkImage)(&dstImage)
	p3 := /* typedef */ (*C.VkImageLayout)(&dstImageLayout)
	p4 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&regionCount)
	p5 := func(x *[]BufferImageCopy) **C.struct_VkBufferImageCopy { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkBufferImageCopy)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkBufferImageCopy)(unsafe.Pointer((&ptr)))
	}(&pRegions)
	C.vkCmdCopyBufferToImage(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
}

// CmdCopyImageToBuffer command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImageToBuffer.html
func (x CommandBufferFacade) CmdCopyImageToBuffer(srcImage Image, srcImageLayout ImageLayout, dstBuffer Buffer, regionCount uint32, pRegions []BufferImageCopy) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&srcImage)
	p2 := /* typedef */ (*C.VkImageLayout)(&srcImageLayout)
	p3 := /* handle */ (*C.VkBuffer)(&dstBuffer)
	p4 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&regionCount)
	p5 := func(x *[]BufferImageCopy) **C.struct_VkBufferImageCopy { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkBufferImageCopy)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkBufferImageCopy)(unsafe.Pointer((&ptr)))
	}(&pRegions)
	C.vkCmdCopyImageToBuffer(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
}

// CmdUpdateBuffer command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdUpdateBuffer.html
func (x CommandBufferFacade) CmdUpdateBuffer(dstBuffer Buffer, dstOffset DeviceSize, dataSize DeviceSize, pData unsafe.Pointer) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&dstBuffer)
	p2 := /* typedef */ (*C.VkDeviceSize)(&dstOffset)
	p3 := /* typedef */ (*C.VkDeviceSize)(&dataSize)
	p4 := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&pData)
	C.vkCmdUpdateBuffer(addrs, *p0, *p1, *p2, *p3, *p4)
}

// CmdFillBuffer command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdFillBuffer.html
func (x CommandBufferFacade) CmdFillBuffer(dstBuffer Buffer, dstOffset DeviceSize, size DeviceSize, data uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&dstBuffer)
	p2 := /* typedef */ (*C.VkDeviceSize)(&dstOffset)
	p3 := /* typedef */ (*C.VkDeviceSize)(&size)
	p4 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&data)
	C.vkCmdFillBuffer(addrs, *p0, *p1, *p2, *p3, *p4)
}

// CmdClearColorImage command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdClearColorImage.html
func (x CommandBufferFacade) CmdClearColorImage(image Image, imageLayout ImageLayout, pColor *ClearColorValue, rangeCount uint32, pRanges []ImageSubresourceRange) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&image)
	p2 := /* typedef */ (*C.VkImageLayout)(&imageLayout)
	p3 := func(x **ClearColorValue) **C.VkClearColorValue { /* Pointer */
		g2c := (*C.VkClearColorValue)(*x)
		return &g2c
	}(&pColor)
	p4 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&rangeCount)
	p5 := func(x *[]ImageSubresourceRange) **C.struct_VkImageSubresourceRange { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkImageSubresourceRange)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkImageSubresourceRange)(unsafe.Pointer((&ptr)))
	}(&pRanges)
	C.vkCmdClearColorImage(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
}

// CmdClearDepthStencilImage command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdClearDepthStencilImage.html
func (x CommandBufferFacade) CmdClearDepthStencilImage(image Image, imageLayout ImageLayout, pDepthStencil *ClearDepthStencilValue, rangeCount uint32, pRanges []ImageSubresourceRange) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&image)
	p2 := /* typedef */ (*C.VkImageLayout)(&imageLayout)
	p3 := func(x **ClearDepthStencilValue) **C.struct_VkClearDepthStencilValue { /* Pointer */
		g2c := (*C.struct_VkClearDepthStencilValue)(*x)
		return &g2c
	}(&pDepthStencil)
	p4 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&rangeCount)
	p5 := func(x *[]ImageSubresourceRange) **C.struct_VkImageSubresourceRange { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkImageSubresourceRange)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkImageSubresourceRange)(unsafe.Pointer((&ptr)))
	}(&pRanges)
	C.vkCmdClearDepthStencilImage(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
}

// CmdClearAttachments command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdClearAttachments.html
func (x CommandBufferFacade) CmdClearAttachments(attachmentCount uint32, pAttachments []ClearAttachment, rectCount uint32, pRects []ClearRect) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&attachmentCount)
	p2 := func(x *[]ClearAttachment) **C.struct_VkClearAttachment { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkClearAttachment)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkClearAttachment)(unsafe.Pointer((&ptr)))
	}(&pAttachments)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&rectCount)
	p4 := func(x *[]ClearRect) **C.struct_VkClearRect { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkClearRect)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkClearRect)(unsafe.Pointer((&ptr)))
	}(&pRects)
	C.vkCmdClearAttachments(addrs, *p0, *p1, *p2, *p3, *p4)
}

// CmdResolveImage command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResolveImage.html
func (x CommandBufferFacade) CmdResolveImage(srcImage Image, srcImageLayout ImageLayout, dstImage Image, dstImageLayout ImageLayout, regionCount uint32, pRegions []ImageResolve) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&srcImage)
	p2 := /* typedef */ (*C.VkImageLayout)(&srcImageLayout)
	p3 := /* handle */ (*C.VkImage)(&dstImage)
	p4 := /* typedef */ (*C.VkImageLayout)(&dstImageLayout)
	p5 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&regionCount)
	p6 := func(x *[]ImageResolve) **C.struct_VkImageResolve { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkImageResolve)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkImageResolve)(unsafe.Pointer((&ptr)))
	}(&pRegions)
	C.vkCmdResolveImage(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6)
}

// CmdSetEvent command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetEvent.html
func (x CommandBufferFacade) CmdSetEvent(event Event, stageMask PipelineStageFlags) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkEvent)(&event)
	p2 := /* typedef */ (*C.VkPipelineStageFlags)(&stageMask)
	C.vkCmdSetEvent(addrs, *p0, *p1, *p2)
}

// CmdResetEvent command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResetEvent.html
func (x CommandBufferFacade) CmdResetEvent(event Event, stageMask PipelineStageFlags) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkEvent)(&event)
	p2 := /* typedef */ (*C.VkPipelineStageFlags)(&stageMask)
	C.vkCmdResetEvent(addrs, *p0, *p1, *p2)
}

// CmdWaitEvents command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWaitEvents.html
func (x CommandBufferFacade) CmdWaitEvents(eventCount uint32, pEvents []Event, srcStageMask PipelineStageFlags, dstStageMask PipelineStageFlags, memoryBarrierCount uint32, pMemoryBarriers []MemoryBarrier, bufferMemoryBarrierCount uint32, pBufferMemoryBarriers []BufferMemoryBarrier, imageMemoryBarrierCount uint32, pImageMemoryBarriers []ImageMemoryBarrier) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&eventCount)
	p2 := func(x *[]Event) **C.VkEvent { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkEvent)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkEvent)(unsafe.Pointer((&ptr)))
	}(&pEvents)
	p3 := /* typedef */ (*C.VkPipelineStageFlags)(&srcStageMask)
	p4 := /* typedef */ (*C.VkPipelineStageFlags)(&dstStageMask)
	p5 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&memoryBarrierCount)
	p6 := func(x *[]MemoryBarrier) **C.struct_VkMemoryBarrier { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkMemoryBarrier)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkMemoryBarrier)(unsafe.Pointer((&ptr)))
	}(&pMemoryBarriers)
	p7 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&bufferMemoryBarrierCount)
	p8 := func(x *[]BufferMemoryBarrier) **C.struct_VkBufferMemoryBarrier { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkBufferMemoryBarrier)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkBufferMemoryBarrier)(unsafe.Pointer((&ptr)))
	}(&pBufferMemoryBarriers)
	p9 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&imageMemoryBarrierCount)
	p10 := func(x *[]ImageMemoryBarrier) **C.struct_VkImageMemoryBarrier { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkImageMemoryBarrier)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkImageMemoryBarrier)(unsafe.Pointer((&ptr)))
	}(&pImageMemoryBarriers)
	C.vkCmdWaitEvents(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7, *p8, *p9, *p10)
}

// CmdPipelineBarrier command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPipelineBarrier.html
func (x CommandBufferFacade) CmdPipelineBarrier(srcStageMask PipelineStageFlags, dstStageMask PipelineStageFlags, dependencyFlags DependencyFlags, memoryBarrierCount uint32, pMemoryBarriers []MemoryBarrier, bufferMemoryBarrierCount uint32, pBufferMemoryBarriers []BufferMemoryBarrier, imageMemoryBarrierCount uint32, pImageMemoryBarriers []ImageMemoryBarrier) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkPipelineStageFlags)(&srcStageMask)
	p2 := /* typedef */ (*C.VkPipelineStageFlags)(&dstStageMask)
	p3 := /* typedef */ (*C.VkDependencyFlags)(&dependencyFlags)
	p4 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&memoryBarrierCount)
	p5 := func(x *[]MemoryBarrier) **C.struct_VkMemoryBarrier { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkMemoryBarrier)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkMemoryBarrier)(unsafe.Pointer((&ptr)))
	}(&pMemoryBarriers)
	p6 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&bufferMemoryBarrierCount)
	p7 := func(x *[]BufferMemoryBarrier) **C.struct_VkBufferMemoryBarrier { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkBufferMemoryBarrier)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkBufferMemoryBarrier)(unsafe.Pointer((&ptr)))
	}(&pBufferMemoryBarriers)
	p8 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&imageMemoryBarrierCount)
	p9 := func(x *[]ImageMemoryBarrier) **C.struct_VkImageMemoryBarrier { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkImageMemoryBarrier)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkImageMemoryBarrier)(unsafe.Pointer((&ptr)))
	}(&pImageMemoryBarriers)
	C.vkCmdPipelineBarrier(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7, *p8, *p9)
}

// CmdBeginQuery command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginQuery.html
func (x CommandBufferFacade) CmdBeginQuery(queryPool QueryPool, query uint32, flags QueryControlFlags) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkQueryPool)(&queryPool)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&query)
	p3 := /* typedef */ (*C.VkQueryControlFlags)(&flags)
	C.vkCmdBeginQuery(addrs, *p0, *p1, *p2, *p3)
}

// CmdEndQuery command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndQuery.html
func (x CommandBufferFacade) CmdEndQuery(queryPool QueryPool, query uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkQueryPool)(&queryPool)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&query)
	C.vkCmdEndQuery(addrs, *p0, *p1, *p2)
}

// CmdResetQueryPool command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResetQueryPool.html
func (x CommandBufferFacade) CmdResetQueryPool(queryPool QueryPool, firstQuery uint32, queryCount uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkQueryPool)(&queryPool)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&firstQuery)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&queryCount)
	C.vkCmdResetQueryPool(addrs, *p0, *p1, *p2, *p3)
}

// CmdWriteTimestamp command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteTimestamp.html
func (x CommandBufferFacade) CmdWriteTimestamp(pipelineStage PipelineStageFlagBits, queryPool QueryPool, query uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkPipelineStageFlagBits)(&pipelineStage)
	p2 := /* handle */ (*C.VkQueryPool)(&queryPool)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&query)
	C.vkCmdWriteTimestamp(addrs, *p0, *p1, *p2, *p3)
}

// CmdCopyQueryPoolResults command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyQueryPoolResults.html
func (x CommandBufferFacade) CmdCopyQueryPoolResults(queryPool QueryPool, firstQuery uint32, queryCount uint32, dstBuffer Buffer, dstOffset DeviceSize, stride DeviceSize, flags QueryResultFlags) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkQueryPool)(&queryPool)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&firstQuery)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&queryCount)
	p4 := /* handle */ (*C.VkBuffer)(&dstBuffer)
	p5 := /* typedef */ (*C.VkDeviceSize)(&dstOffset)
	p6 := /* typedef */ (*C.VkDeviceSize)(&stride)
	p7 := /* typedef */ (*C.VkQueryResultFlags)(&flags)
	C.vkCmdCopyQueryPoolResults(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7)
}

// CmdPushConstants command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPushConstants.html
func (x CommandBufferFacade) CmdPushConstants(layout PipelineLayout, stageFlags ShaderStageFlags, offset uint32, size uint32, pValues unsafe.Pointer) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkPipelineLayout)(&layout)
	p2 := /* typedef */ (*C.VkShaderStageFlags)(&stageFlags)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&offset)
	p4 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&size)
	p5 := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&pValues)
	C.vkCmdPushConstants(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
}

// CmdBeginRenderPass command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass.html
func (x CommandBufferFacade) CmdBeginRenderPass(pRenderPassBegin *RenderPassBeginInfo, contents SubpassContents) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **RenderPassBeginInfo) **C.struct_VkRenderPassBeginInfo { /* Pointer */
		g2c := (*C.struct_VkRenderPassBeginInfo)(*x)
		return &g2c
	}(&pRenderPassBegin)
	p2 := /* typedef */ (*C.VkSubpassContents)(&contents)
	C.vkCmdBeginRenderPass(addrs, *p0, *p1, *p2)
}

// CmdNextSubpass command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdNextSubpass.html
func (x CommandBufferFacade) CmdNextSubpass(contents SubpassContents) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkSubpassContents)(&contents)
	C.vkCmdNextSubpass(addrs, *p0, *p1)
}

// CmdEndRenderPass command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndRenderPass.html
func (x CommandBufferFacade) CmdEndRenderPass() {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	C.vkCmdEndRenderPass(addrs, *p0)
}

// CmdExecuteCommands command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdExecuteCommands.html
func (x CommandBufferFacade) CmdExecuteCommands(commandBufferCount uint32, pCommandBuffers []CommandBuffer) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&commandBufferCount)
	p2 := func(x *[]CommandBuffer) **C.VkCommandBuffer { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkCommandBuffer)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkCommandBuffer)(unsafe.Pointer((&ptr)))
	}(&pCommandBuffers)
	C.vkCmdExecuteCommands(addrs, *p0, *p1, *p2)
}

// CreateEvent command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateEvent.html
func (x DeviceFacade) CreateEvent(pCreateInfo *EventCreateInfo, pAllocator *AllocationCallbacks, pEvent *Event) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **EventCreateInfo) **C.struct_VkEventCreateInfo { /* Pointer */
		g2c := (*C.struct_VkEventCreateInfo)(*x)
		return &g2c
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p3 := func(x **Event) **C.VkEvent { /* Pointer */ g2c := (*C.VkEvent)(*x); return &g2c }(&pEvent)
	ret := C.vkCreateEvent(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroyBufferView command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyBufferView.html
func (x DeviceFacade) DestroyBufferView(bufferView BufferView, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkBufferView)(&bufferView)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	C.vkDestroyBufferView(addrs, *p0, *p1, *p2)
}

// CreateBufferView command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateBufferView.html
func (x DeviceFacade) CreateBufferView(pCreateInfo *BufferViewCreateInfo, pAllocator *AllocationCallbacks, pView *BufferView) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **BufferViewCreateInfo) **C.struct_VkBufferViewCreateInfo { /* Pointer */
		g2c := (*C.struct_VkBufferViewCreateInfo)(*x)
		return &g2c
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p3 := func(x **BufferView) **C.VkBufferView { /* Pointer */ g2c := (*C.VkBufferView)(*x); return &g2c }(&pView)
	ret := C.vkCreateBufferView(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceImageFormatProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceImageFormatProperties.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceImageFormatProperties(format Format, type_ ImageType, tiling ImageTiling, usage ImageUsageFlags, flags ImageCreateFlags, pImageFormatProperties *ImageFormatProperties) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* typedef */ (*C.VkFormat)(&format)
	p2 := /* typedef */ (*C.VkImageType)(&type_)
	p3 := /* typedef */ (*C.VkImageTiling)(&tiling)
	p4 := /* typedef */ (*C.VkImageUsageFlags)(&usage)
	p5 := /* typedef */ (*C.VkImageCreateFlags)(&flags)
	p6 := func(x **ImageFormatProperties) **C.struct_VkImageFormatProperties { /* Pointer */
		g2c := (*C.struct_VkImageFormatProperties)(*x)
		return &g2c
	}(&pImageFormatProperties)
	ret := C.vkGetPhysicalDeviceImageFormatProperties(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroyEvent command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyEvent.html
func (x DeviceFacade) DestroyEvent(event Event, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkEvent)(&event)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	C.vkDestroyEvent(addrs, *p0, *p1, *p2)
}

// GetEventStatus command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetEventStatus.html
func (x DeviceFacade) GetEventStatus(event Event) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkEvent)(&event)
	ret := C.vkGetEventStatus(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroyPipelineLayout command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPipelineLayout.html
func (x DeviceFacade) DestroyPipelineLayout(pipelineLayout PipelineLayout, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkPipelineLayout)(&pipelineLayout)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	C.vkDestroyPipelineLayout(addrs, *p0, *p1, *p2)
}

// DestroyBuffer command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyBuffer.html
func (x DeviceFacade) DestroyBuffer(buffer Buffer, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&buffer)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	C.vkDestroyBuffer(addrs, *p0, *p1, *p2)
}

// DestroyImageView command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyImageView.html
func (x DeviceFacade) DestroyImageView(imageView ImageView, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkImageView)(&imageView)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	C.vkDestroyImageView(addrs, *p0, *p1, *p2)
}

// SetEvent command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetEvent.html
func (x DeviceFacade) SetEvent(event Event) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkEvent)(&event)
	ret := C.vkSetEvent(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// ResetEvent command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetEvent.html
func (x DeviceFacade) ResetEvent(event Event) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkEvent)(&event)
	ret := C.vkResetEvent(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CreateDevice command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDevice.html
func (x PhysicalDeviceFacade) CreateDevice(pCreateInfo *DeviceCreateInfo, pAllocator *AllocationCallbacks, pDevice *Device) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **DeviceCreateInfo) **C.struct_VkDeviceCreateInfo { /* Pointer */
		g2c := (*C.struct_VkDeviceCreateInfo)(*x)
		return &g2c
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p3 := func(x **Device) **C.VkDevice { /* Pointer */ g2c := (*C.VkDevice)(*x); return &g2c }(&pDevice)
	ret := C.vkCreateDevice(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CreateQueryPool command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateQueryPool.html
func (x DeviceFacade) CreateQueryPool(pCreateInfo *QueryPoolCreateInfo, pAllocator *AllocationCallbacks, pQueryPool *QueryPool) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **QueryPoolCreateInfo) **C.struct_VkQueryPoolCreateInfo { /* Pointer */
		g2c := (*C.struct_VkQueryPoolCreateInfo)(*x)
		return &g2c
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p3 := func(x **QueryPool) **C.VkQueryPool { /* Pointer */ g2c := (*C.VkQueryPool)(*x); return &g2c }(&pQueryPool)
	ret := C.vkCreateQueryPool(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroyDevice command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDevice.html
func (x DeviceFacade) DestroyDevice(pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	C.vkDestroyDevice(addrs, *p0, *p1)
}

// DeviceWaitIdle command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDeviceWaitIdle.html
func (x DeviceFacade) DeviceWaitIdle() Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	ret := C.vkDeviceWaitIdle(addrs, *p0)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetQueryPoolResults command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetQueryPoolResults.html
func (x DeviceFacade) GetQueryPoolResults(queryPool QueryPool, firstQuery uint32, queryCount uint32, dataSize uint64, pData unsafe.Pointer, stride DeviceSize, flags QueryResultFlags) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkQueryPool)(&queryPool)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&firstQuery)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&queryCount)
	p4 := func(x *uint64) *C.size_t { /* Scalar */ g2c := C.size_t(*x); return &g2c }(&dataSize)
	p5 := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&pData)
	p6 := /* typedef */ (*C.VkDeviceSize)(&stride)
	p7 := /* typedef */ (*C.VkQueryResultFlags)(&flags)
	ret := C.vkGetQueryPoolResults(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DescriptorUpdateTemplate is a Handle to a vulkan resource.
// DescriptorUpdateTemplate is a child of Device.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorUpdateTemplate.html
type DescriptorUpdateTemplate C.VkDescriptorUpdateTemplate

// NullDescriptorUpdateTemplate is a typed Null value for the DescriptorUpdateTemplate type.
var NullDescriptorUpdateTemplate DescriptorUpdateTemplate

// SamplerYcbcrConversion is a Handle to a vulkan resource.
// SamplerYcbcrConversion is a child of Device.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerYcbcrConversion.html
type SamplerYcbcrConversion C.VkSamplerYcbcrConversion

// NullSamplerYcbcrConversion is a typed Null value for the SamplerYcbcrConversion type.
var NullSamplerYcbcrConversion SamplerYcbcrConversion

// ExternalSemaphoreHandleTypeFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalSemaphoreHandleTypeFlagBits.html
type ExternalSemaphoreHandleTypeFlagBits uint32

const (
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT        ExternalSemaphoreHandleTypeFlagBits = (1 << 0)
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT     ExternalSemaphoreHandleTypeFlagBits = (1 << 1)
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT ExternalSemaphoreHandleTypeFlagBits = (1 << 2)
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT      ExternalSemaphoreHandleTypeFlagBits = (1 << 3)
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT      ExternalSemaphoreHandleTypeFlagBits = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT          ExternalSemaphoreHandleTypeFlagBits = (1 << 4)
)

var (
	reverseExternalSemaphoreHandleTypeFlagBits map[ExternalSemaphoreHandleTypeFlagBits]string = map[ExternalSemaphoreHandleTypeFlagBits]string{
		VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT:        "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT",
		VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT:     "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT",
		VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT",
		VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT:      "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT",
		VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT:          "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT",
	}
)

func (x ExternalSemaphoreHandleTypeFlagBits) String() string {
	if s, ok := reverseExternalSemaphoreHandleTypeFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ExternalSemaphoreHandleTypeFlagBits=%d", x)
}

// SamplerYcbcrRange enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerYcbcrRange.html
type SamplerYcbcrRange uint32

const (
	VK_SAMPLER_YCBCR_RANGE_ITU_FULL   SamplerYcbcrRange = 0
	VK_SAMPLER_YCBCR_RANGE_ITU_NARROW SamplerYcbcrRange = 1
)

var (
	reverseSamplerYcbcrRange map[SamplerYcbcrRange]string = map[SamplerYcbcrRange]string{
		VK_SAMPLER_YCBCR_RANGE_ITU_FULL:   "VK_SAMPLER_YCBCR_RANGE_ITU_FULL",
		VK_SAMPLER_YCBCR_RANGE_ITU_NARROW: "VK_SAMPLER_YCBCR_RANGE_ITU_NARROW",
	}
)

func (x SamplerYcbcrRange) String() string {
	if s, ok := reverseSamplerYcbcrRange[x]; ok {
		return s
	}
	return fmt.Sprintf("SamplerYcbcrRange=%d", x)
}

// PeerMemoryFeatureFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPeerMemoryFeatureFlagBits.html
type PeerMemoryFeatureFlagBits uint32

const (
	VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT    PeerMemoryFeatureFlagBits = (1 << 0)
	VK_PEER_MEMORY_FEATURE_COPY_DST_BIT    PeerMemoryFeatureFlagBits = (1 << 1)
	VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT PeerMemoryFeatureFlagBits = (1 << 2)
	VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT PeerMemoryFeatureFlagBits = (1 << 3)
)

var (
	reversePeerMemoryFeatureFlagBits map[PeerMemoryFeatureFlagBits]string = map[PeerMemoryFeatureFlagBits]string{
		VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT:    "VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT",
		VK_PEER_MEMORY_FEATURE_COPY_DST_BIT:    "VK_PEER_MEMORY_FEATURE_COPY_DST_BIT",
		VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT: "VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT",
		VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT: "VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT",
	}
)

func (x PeerMemoryFeatureFlagBits) String() string {
	if s, ok := reversePeerMemoryFeatureFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("PeerMemoryFeatureFlagBits=%d", x)
}

// ExternalFenceFeatureFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalFenceFeatureFlagBits.html
type ExternalFenceFeatureFlagBits uint32

const (
	VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT ExternalFenceFeatureFlagBits = (1 << 0)
	VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT ExternalFenceFeatureFlagBits = (1 << 1)
)

var (
	reverseExternalFenceFeatureFlagBits map[ExternalFenceFeatureFlagBits]string = map[ExternalFenceFeatureFlagBits]string{
		VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT: "VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT",
		VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT: "VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT",
	}
)

func (x ExternalFenceFeatureFlagBits) String() string {
	if s, ok := reverseExternalFenceFeatureFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ExternalFenceFeatureFlagBits=%d", x)
}

// ExternalSemaphoreFeatureFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalSemaphoreFeatureFlagBits.html
type ExternalSemaphoreFeatureFlagBits uint32

const (
	VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT ExternalSemaphoreFeatureFlagBits = (1 << 0)
	VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT ExternalSemaphoreFeatureFlagBits = (1 << 1)
)

var (
	reverseExternalSemaphoreFeatureFlagBits map[ExternalSemaphoreFeatureFlagBits]string = map[ExternalSemaphoreFeatureFlagBits]string{
		VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT: "VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT",
		VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT: "VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT",
	}
)

func (x ExternalSemaphoreFeatureFlagBits) String() string {
	if s, ok := reverseExternalSemaphoreFeatureFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ExternalSemaphoreFeatureFlagBits=%d", x)
}

// SemaphoreImportFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreImportFlagBits.html
type SemaphoreImportFlagBits uint32

const (
	VK_SEMAPHORE_IMPORT_TEMPORARY_BIT SemaphoreImportFlagBits = (1 << 0)
)

var (
	reverseSemaphoreImportFlagBits map[SemaphoreImportFlagBits]string = map[SemaphoreImportFlagBits]string{
		VK_SEMAPHORE_IMPORT_TEMPORARY_BIT: "VK_SEMAPHORE_IMPORT_TEMPORARY_BIT",
	}
)

func (x SemaphoreImportFlagBits) String() string {
	if s, ok := reverseSemaphoreImportFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("SemaphoreImportFlagBits=%d", x)
}

// PointClippingBehavior enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPointClippingBehavior.html
type PointClippingBehavior uint32

const (
	VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES       PointClippingBehavior = 0
	VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY PointClippingBehavior = 1
)

var (
	reversePointClippingBehavior map[PointClippingBehavior]string = map[PointClippingBehavior]string{
		VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES:       "VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES",
		VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY: "VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY",
	}
)

func (x PointClippingBehavior) String() string {
	if s, ok := reversePointClippingBehavior[x]; ok {
		return s
	}
	return fmt.Sprintf("PointClippingBehavior=%d", x)
}

// SamplerYcbcrModelConversion enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerYcbcrModelConversion.html
type SamplerYcbcrModelConversion uint32

const (
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY   SamplerYcbcrModelConversion = 0
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY SamplerYcbcrModelConversion = 1
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709      SamplerYcbcrModelConversion = 2
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601      SamplerYcbcrModelConversion = 3
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020     SamplerYcbcrModelConversion = 4
)

var (
	reverseSamplerYcbcrModelConversion map[SamplerYcbcrModelConversion]string = map[SamplerYcbcrModelConversion]string{
		VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY:   "VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY",
		VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY: "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY",
		VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709:      "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709",
		VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601:      "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601",
		VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020:     "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020",
	}
)

func (x SamplerYcbcrModelConversion) String() string {
	if s, ok := reverseSamplerYcbcrModelConversion[x]; ok {
		return s
	}
	return fmt.Sprintf("SamplerYcbcrModelConversion=%d", x)
}

// ExternalFenceHandleTypeFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalFenceHandleTypeFlagBits.html
type ExternalFenceHandleTypeFlagBits uint32

const (
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT        ExternalFenceHandleTypeFlagBits = (1 << 0)
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT     ExternalFenceHandleTypeFlagBits = (1 << 1)
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT ExternalFenceHandleTypeFlagBits = (1 << 2)
	VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT          ExternalFenceHandleTypeFlagBits = (1 << 3)
)

var (
	reverseExternalFenceHandleTypeFlagBits map[ExternalFenceHandleTypeFlagBits]string = map[ExternalFenceHandleTypeFlagBits]string{
		VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT:        "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT",
		VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT:     "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT",
		VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT",
		VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT:          "VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT",
	}
)

func (x ExternalFenceHandleTypeFlagBits) String() string {
	if s, ok := reverseExternalFenceHandleTypeFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ExternalFenceHandleTypeFlagBits=%d", x)
}

// SubgroupFeatureFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubgroupFeatureFlagBits.html
type SubgroupFeatureFlagBits uint32

const (
	VK_SUBGROUP_FEATURE_BASIC_BIT            SubgroupFeatureFlagBits = (1 << 0)
	VK_SUBGROUP_FEATURE_VOTE_BIT             SubgroupFeatureFlagBits = (1 << 1)
	VK_SUBGROUP_FEATURE_ARITHMETIC_BIT       SubgroupFeatureFlagBits = (1 << 2)
	VK_SUBGROUP_FEATURE_BALLOT_BIT           SubgroupFeatureFlagBits = (1 << 3)
	VK_SUBGROUP_FEATURE_SHUFFLE_BIT          SubgroupFeatureFlagBits = (1 << 4)
	VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT SubgroupFeatureFlagBits = (1 << 5)
	VK_SUBGROUP_FEATURE_CLUSTERED_BIT        SubgroupFeatureFlagBits = (1 << 6)
	VK_SUBGROUP_FEATURE_QUAD_BIT             SubgroupFeatureFlagBits = (1 << 7)
)

var (
	reverseSubgroupFeatureFlagBits map[SubgroupFeatureFlagBits]string = map[SubgroupFeatureFlagBits]string{
		VK_SUBGROUP_FEATURE_BASIC_BIT:            "VK_SUBGROUP_FEATURE_BASIC_BIT",
		VK_SUBGROUP_FEATURE_VOTE_BIT:             "VK_SUBGROUP_FEATURE_VOTE_BIT",
		VK_SUBGROUP_FEATURE_ARITHMETIC_BIT:       "VK_SUBGROUP_FEATURE_ARITHMETIC_BIT",
		VK_SUBGROUP_FEATURE_BALLOT_BIT:           "VK_SUBGROUP_FEATURE_BALLOT_BIT",
		VK_SUBGROUP_FEATURE_SHUFFLE_BIT:          "VK_SUBGROUP_FEATURE_SHUFFLE_BIT",
		VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT: "VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT",
		VK_SUBGROUP_FEATURE_CLUSTERED_BIT:        "VK_SUBGROUP_FEATURE_CLUSTERED_BIT",
		VK_SUBGROUP_FEATURE_QUAD_BIT:             "VK_SUBGROUP_FEATURE_QUAD_BIT",
	}
)

func (x SubgroupFeatureFlagBits) String() string {
	if s, ok := reverseSubgroupFeatureFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("SubgroupFeatureFlagBits=%d", x)
}

// ChromaLocation enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkChromaLocation.html
type ChromaLocation uint32

const (
	VK_CHROMA_LOCATION_COSITED_EVEN ChromaLocation = 0
	VK_CHROMA_LOCATION_MIDPOINT     ChromaLocation = 1
)

var (
	reverseChromaLocation map[ChromaLocation]string = map[ChromaLocation]string{
		VK_CHROMA_LOCATION_COSITED_EVEN: "VK_CHROMA_LOCATION_COSITED_EVEN",
		VK_CHROMA_LOCATION_MIDPOINT:     "VK_CHROMA_LOCATION_MIDPOINT",
	}
)

func (x ChromaLocation) String() string {
	if s, ok := reverseChromaLocation[x]; ok {
		return s
	}
	return fmt.Sprintf("ChromaLocation=%d", x)
}

// FenceImportFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFenceImportFlagBits.html
type FenceImportFlagBits uint32

const (
	VK_FENCE_IMPORT_TEMPORARY_BIT FenceImportFlagBits = (1 << 0)
)

var (
	reverseFenceImportFlagBits map[FenceImportFlagBits]string = map[FenceImportFlagBits]string{
		VK_FENCE_IMPORT_TEMPORARY_BIT: "VK_FENCE_IMPORT_TEMPORARY_BIT",
	}
)

func (x FenceImportFlagBits) String() string {
	if s, ok := reverseFenceImportFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("FenceImportFlagBits=%d", x)
}

// TessellationDomainOrigin enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkTessellationDomainOrigin.html
type TessellationDomainOrigin uint32

const (
	VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT TessellationDomainOrigin = 0
	VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT TessellationDomainOrigin = 1
)

var (
	reverseTessellationDomainOrigin map[TessellationDomainOrigin]string = map[TessellationDomainOrigin]string{
		VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT: "VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT",
		VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT: "VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT",
	}
)

func (x TessellationDomainOrigin) String() string {
	if s, ok := reverseTessellationDomainOrigin[x]; ok {
		return s
	}
	return fmt.Sprintf("TessellationDomainOrigin=%d", x)
}

// DescriptorUpdateTemplateType enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorUpdateTemplateType.html
type DescriptorUpdateTemplateType uint32

const (
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET DescriptorUpdateTemplateType = 0
)

var (
	reverseDescriptorUpdateTemplateType map[DescriptorUpdateTemplateType]string = map[DescriptorUpdateTemplateType]string{
		VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET: "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET",
	}
)

func (x DescriptorUpdateTemplateType) String() string {
	if s, ok := reverseDescriptorUpdateTemplateType[x]; ok {
		return s
	}
	return fmt.Sprintf("DescriptorUpdateTemplateType=%d", x)
}

// ExternalMemoryHandleTypeFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalMemoryHandleTypeFlagBits.html
type ExternalMemoryHandleTypeFlagBits uint32

const (
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT         ExternalMemoryHandleTypeFlagBits = (1 << 0)
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT      ExternalMemoryHandleTypeFlagBits = (1 << 1)
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT  ExternalMemoryHandleTypeFlagBits = (1 << 2)
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT     ExternalMemoryHandleTypeFlagBits = (1 << 3)
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT ExternalMemoryHandleTypeFlagBits = (1 << 4)
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT        ExternalMemoryHandleTypeFlagBits = (1 << 5)
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT    ExternalMemoryHandleTypeFlagBits = (1 << 6)
)

var (
	reverseExternalMemoryHandleTypeFlagBits map[ExternalMemoryHandleTypeFlagBits]string = map[ExternalMemoryHandleTypeFlagBits]string{
		VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT:         "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT",
		VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:      "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT",
		VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:  "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT",
		VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT:     "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT",
		VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT: "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT",
		VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT:        "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT",
		VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT:    "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT",
	}
)

func (x ExternalMemoryHandleTypeFlagBits) String() string {
	if s, ok := reverseExternalMemoryHandleTypeFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ExternalMemoryHandleTypeFlagBits=%d", x)
}

// ExternalMemoryFeatureFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalMemoryFeatureFlagBits.html
type ExternalMemoryFeatureFlagBits uint32

const (
	VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT ExternalMemoryFeatureFlagBits = (1 << 0)
	VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT     ExternalMemoryFeatureFlagBits = (1 << 1)
	VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT     ExternalMemoryFeatureFlagBits = (1 << 2)
)

var (
	reverseExternalMemoryFeatureFlagBits map[ExternalMemoryFeatureFlagBits]string = map[ExternalMemoryFeatureFlagBits]string{
		VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT: "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT",
		VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT:     "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT",
		VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT:     "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT",
	}
)

func (x ExternalMemoryFeatureFlagBits) String() string {
	if s, ok := reverseExternalMemoryFeatureFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ExternalMemoryFeatureFlagBits=%d", x)
}

// MemoryAllocateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryAllocateFlagBits.html
type MemoryAllocateFlagBits uint32

const (
	VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT                   MemoryAllocateFlagBits = (1 << 0)
	VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT                MemoryAllocateFlagBits = (1 << 1)
	VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT MemoryAllocateFlagBits = (1 << 2)
)

var (
	reverseMemoryAllocateFlagBits map[MemoryAllocateFlagBits]string = map[MemoryAllocateFlagBits]string{
		VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT:                   "VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT",
		VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT:                "VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT",
		VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT: "VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT",
	}
)

func (x MemoryAllocateFlagBits) String() string {
	if s, ok := reverseMemoryAllocateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("MemoryAllocateFlagBits=%d", x)
}

// MemoryAllocateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryAllocateFlags.html
type MemoryAllocateFlags Flags

// ExternalMemoryFeatureFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalMemoryFeatureFlags.html
type ExternalMemoryFeatureFlags Flags

// PeerMemoryFeatureFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPeerMemoryFeatureFlags.html
type PeerMemoryFeatureFlags Flags

// CommandPoolTrimFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolTrimFlags.html
type CommandPoolTrimFlags Flags

// SubgroupFeatureFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubgroupFeatureFlags.html
type SubgroupFeatureFlags Flags

// SemaphoreImportFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreImportFlags.html
type SemaphoreImportFlags Flags

// ExternalSemaphoreHandleTypeFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalSemaphoreHandleTypeFlags.html
type ExternalSemaphoreHandleTypeFlags Flags

// ExternalSemaphoreFeatureFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalSemaphoreFeatureFlags.html
type ExternalSemaphoreFeatureFlags Flags

// ExternalFenceFeatureFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalFenceFeatureFlags.html
type ExternalFenceFeatureFlags Flags

// ExternalFenceHandleTypeFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalFenceHandleTypeFlags.html
type ExternalFenceHandleTypeFlags Flags

// DescriptorUpdateTemplateCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorUpdateTemplateCreateFlags.html
type DescriptorUpdateTemplateCreateFlags Flags

// FenceImportFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFenceImportFlags.html
type FenceImportFlags Flags

// ExternalMemoryHandleTypeFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalMemoryHandleTypeFlags.html
type ExternalMemoryHandleTypeFlags Flags

// SamplerYcbcrConversionImageFormatProperties provides a go interface for VkSamplerYcbcrConversionImageFormatProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerYcbcrConversionImageFormatProperties.html
type SamplerYcbcrConversionImageFormatProperties C.struct_VkSamplerYcbcrConversionImageFormatProperties

// SizeofSamplerYcbcrConversionImageFormatProperties is the memory size of a SamplerYcbcrConversionImageFormatProperties
var SizeofSamplerYcbcrConversionImageFormatProperties int = int(unsafe.Sizeof(SamplerYcbcrConversionImageFormatProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SamplerYcbcrConversionImageFormatProperties) ArpPtr(arp *AutoReleasePool) *SamplerYcbcrConversionImageFormatProperties {
	ptr := newCBlock(cULong(SizeofSamplerYcbcrConversionImageFormatProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SamplerYcbcrConversionImageFormatProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SamplerYcbcrConversionImageFormatProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SamplerYcbcrConversionImageFormatProperties) AsCPtr() *SamplerYcbcrConversionImageFormatProperties {
	clone := (*SamplerYcbcrConversionImageFormatProperties)(newCBlock(cULong(SizeofSamplerYcbcrConversionImageFormatProperties)))
	*clone = x
	return clone
}

// SamplerYcbcrConversionImageFormatPropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SamplerYcbcrConversionImageFormatPropertiesCSlice(arp *AutoReleasePool, x ...SamplerYcbcrConversionImageFormatProperties) []SamplerYcbcrConversionImageFormatProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSamplerYcbcrConversionImageFormatProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SamplerYcbcrConversionImageFormatProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SamplerYcbcrConversionImageFormatPropertiesFreeCSlice releases the memory allocated by SamplerYcbcrConversionImageFormatPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func SamplerYcbcrConversionImageFormatPropertiesFreeCSlice(x []SamplerYcbcrConversionImageFormatProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SamplerYcbcrConversionImageFormatPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SamplerYcbcrConversionImageFormatPropertiesFreeCSlice must be called on the returned slice.
func SamplerYcbcrConversionImageFormatPropertiesMakeCSlice(x ...SamplerYcbcrConversionImageFormatProperties) []SamplerYcbcrConversionImageFormatProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSamplerYcbcrConversionImageFormatProperties * len(x)
	dst := unsafe.Slice((*SamplerYcbcrConversionImageFormatProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSamplerYcbcrConversionImageFormatProperties
func (x SamplerYcbcrConversionImageFormatProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new SamplerYcbcrConversionImageFormatProperties with the value of
// SType to the value provided in the specification.
func (x SamplerYcbcrConversionImageFormatProperties) WithDefaultSType() SamplerYcbcrConversionImageFormatProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *SamplerYcbcrConversionImageFormatProperties) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES)
}

// WithSType clones a new SamplerYcbcrConversionImageFormatProperties with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionImageFormatProperties) WithSType(y StructureType) SamplerYcbcrConversionImageFormatProperties {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *SamplerYcbcrConversionImageFormatProperties) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkSamplerYcbcrConversionImageFormatProperties
func (x SamplerYcbcrConversionImageFormatProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new SamplerYcbcrConversionImageFormatProperties with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionImageFormatProperties) WithPNext(y unsafe.Pointer) SamplerYcbcrConversionImageFormatProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *SamplerYcbcrConversionImageFormatProperties) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// CombinedImageSamplerDescriptorCount returns the value of combinedImageSamplerDescriptorCount from VkSamplerYcbcrConversionImageFormatProperties
func (x SamplerYcbcrConversionImageFormatProperties) CombinedImageSamplerDescriptorCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.combinedImageSamplerDescriptorCount)
	return *ptr
}

// PhysicalDeviceShaderDrawParametersFeatures provides a go interface for VkPhysicalDeviceShaderDrawParametersFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderDrawParametersFeatures.html
type PhysicalDeviceShaderDrawParametersFeatures C.struct_VkPhysicalDeviceShaderDrawParametersFeatures

// SizeofPhysicalDeviceShaderDrawParametersFeatures is the memory size of a PhysicalDeviceShaderDrawParametersFeatures
var SizeofPhysicalDeviceShaderDrawParametersFeatures int = int(unsafe.Sizeof(PhysicalDeviceShaderDrawParametersFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceShaderDrawParametersFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceShaderDrawParametersFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceShaderDrawParametersFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceShaderDrawParametersFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceShaderDrawParametersFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceShaderDrawParametersFeatures) AsCPtr() *PhysicalDeviceShaderDrawParametersFeatures {
	clone := (*PhysicalDeviceShaderDrawParametersFeatures)(newCBlock(cULong(SizeofPhysicalDeviceShaderDrawParametersFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceShaderDrawParametersFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceShaderDrawParametersFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceShaderDrawParametersFeatures) []PhysicalDeviceShaderDrawParametersFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderDrawParametersFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceShaderDrawParametersFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceShaderDrawParametersFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceShaderDrawParametersFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceShaderDrawParametersFeaturesFreeCSlice(x []PhysicalDeviceShaderDrawParametersFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceShaderDrawParametersFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceShaderDrawParametersFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceShaderDrawParametersFeaturesMakeCSlice(x ...PhysicalDeviceShaderDrawParametersFeatures) []PhysicalDeviceShaderDrawParametersFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderDrawParametersFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceShaderDrawParametersFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceShaderDrawParametersFeatures
func (x PhysicalDeviceShaderDrawParametersFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceShaderDrawParametersFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceShaderDrawParametersFeatures) WithDefaultSType() PhysicalDeviceShaderDrawParametersFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceShaderDrawParametersFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES)
}

// WithSType clones a new PhysicalDeviceShaderDrawParametersFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderDrawParametersFeatures) WithSType(y StructureType) PhysicalDeviceShaderDrawParametersFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceShaderDrawParametersFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceShaderDrawParametersFeatures
func (x PhysicalDeviceShaderDrawParametersFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceShaderDrawParametersFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderDrawParametersFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceShaderDrawParametersFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceShaderDrawParametersFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// ShaderDrawParameters returns the value of shaderDrawParameters from VkPhysicalDeviceShaderDrawParametersFeatures
func (x PhysicalDeviceShaderDrawParametersFeatures) ShaderDrawParameters() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDrawParameters)
	return *ptr
}

// WithShaderDrawParameters clones a new PhysicalDeviceShaderDrawParametersFeatures with the value of
// ShaderDrawParameters updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderDrawParametersFeatures) WithShaderDrawParameters(y Bool32) PhysicalDeviceShaderDrawParametersFeatures {
	x.shaderDrawParameters = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceShaderDrawParametersFeatures) SetShaderDrawParameters(y Bool32) {
	x.shaderDrawParameters = *( /* typedef */ (*C.VkBool32)(&y))
}

// ExternalMemoryProperties provides a go interface for VkExternalMemoryProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalMemoryProperties.html
type ExternalMemoryProperties C.struct_VkExternalMemoryProperties

// SizeofExternalMemoryProperties is the memory size of a ExternalMemoryProperties
var SizeofExternalMemoryProperties int = int(unsafe.Sizeof(ExternalMemoryProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ExternalMemoryProperties) ArpPtr(arp *AutoReleasePool) *ExternalMemoryProperties {
	ptr := newCBlock(cULong(SizeofExternalMemoryProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ExternalMemoryProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExternalMemoryProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExternalMemoryProperties) AsCPtr() *ExternalMemoryProperties {
	clone := (*ExternalMemoryProperties)(newCBlock(cULong(SizeofExternalMemoryProperties)))
	*clone = x
	return clone
}

// ExternalMemoryPropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ExternalMemoryPropertiesCSlice(arp *AutoReleasePool, x ...ExternalMemoryProperties) []ExternalMemoryProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalMemoryProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ExternalMemoryProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ExternalMemoryPropertiesFreeCSlice releases the memory allocated by ExternalMemoryPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func ExternalMemoryPropertiesFreeCSlice(x []ExternalMemoryProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExternalMemoryPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExternalMemoryPropertiesFreeCSlice must be called on the returned slice.
func ExternalMemoryPropertiesMakeCSlice(x ...ExternalMemoryProperties) []ExternalMemoryProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalMemoryProperties * len(x)
	dst := unsafe.Slice((*ExternalMemoryProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// ExternalMemoryFeatures returns the value of externalMemoryFeatures from VkExternalMemoryProperties
func (x ExternalMemoryProperties) ExternalMemoryFeatures() ExternalMemoryFeatureFlags {
	ptr := /* typedef */ (*ExternalMemoryFeatureFlags)(&x.externalMemoryFeatures)
	return *ptr
}

// ExportFromImportedHandleTypes returns the value of exportFromImportedHandleTypes from VkExternalMemoryProperties
func (x ExternalMemoryProperties) ExportFromImportedHandleTypes() ExternalMemoryHandleTypeFlags {
	ptr := /* typedef */ (*ExternalMemoryHandleTypeFlags)(&x.exportFromImportedHandleTypes)
	return *ptr
}

// CompatibleHandleTypes returns the value of compatibleHandleTypes from VkExternalMemoryProperties
func (x ExternalMemoryProperties) CompatibleHandleTypes() ExternalMemoryHandleTypeFlags {
	ptr := /* typedef */ (*ExternalMemoryHandleTypeFlags)(&x.compatibleHandleTypes)
	return *ptr
}

// ExternalMemoryBufferCreateInfo provides a go interface for VkExternalMemoryBufferCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalMemoryBufferCreateInfo.html
type ExternalMemoryBufferCreateInfo C.struct_VkExternalMemoryBufferCreateInfo

// SizeofExternalMemoryBufferCreateInfo is the memory size of a ExternalMemoryBufferCreateInfo
var SizeofExternalMemoryBufferCreateInfo int = int(unsafe.Sizeof(ExternalMemoryBufferCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ExternalMemoryBufferCreateInfo) ArpPtr(arp *AutoReleasePool) *ExternalMemoryBufferCreateInfo {
	ptr := newCBlock(cULong(SizeofExternalMemoryBufferCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ExternalMemoryBufferCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExternalMemoryBufferCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExternalMemoryBufferCreateInfo) AsCPtr() *ExternalMemoryBufferCreateInfo {
	clone := (*ExternalMemoryBufferCreateInfo)(newCBlock(cULong(SizeofExternalMemoryBufferCreateInfo)))
	*clone = x
	return clone
}

// ExternalMemoryBufferCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ExternalMemoryBufferCreateInfoCSlice(arp *AutoReleasePool, x ...ExternalMemoryBufferCreateInfo) []ExternalMemoryBufferCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalMemoryBufferCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ExternalMemoryBufferCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ExternalMemoryBufferCreateInfoFreeCSlice releases the memory allocated by ExternalMemoryBufferCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ExternalMemoryBufferCreateInfoFreeCSlice(x []ExternalMemoryBufferCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExternalMemoryBufferCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExternalMemoryBufferCreateInfoFreeCSlice must be called on the returned slice.
func ExternalMemoryBufferCreateInfoMakeCSlice(x ...ExternalMemoryBufferCreateInfo) []ExternalMemoryBufferCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalMemoryBufferCreateInfo * len(x)
	dst := unsafe.Slice((*ExternalMemoryBufferCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkExternalMemoryBufferCreateInfo
func (x ExternalMemoryBufferCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ExternalMemoryBufferCreateInfo with the value of
// SType to the value provided in the specification.
func (x ExternalMemoryBufferCreateInfo) WithDefaultSType() ExternalMemoryBufferCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ExternalMemoryBufferCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO)
}

// WithSType clones a new ExternalMemoryBufferCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalMemoryBufferCreateInfo) WithSType(y StructureType) ExternalMemoryBufferCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ExternalMemoryBufferCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkExternalMemoryBufferCreateInfo
func (x ExternalMemoryBufferCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ExternalMemoryBufferCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalMemoryBufferCreateInfo) WithPNext(y unsafe.Pointer) ExternalMemoryBufferCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ExternalMemoryBufferCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// HandleTypes returns the value of handleTypes from VkExternalMemoryBufferCreateInfo
func (x ExternalMemoryBufferCreateInfo) HandleTypes() ExternalMemoryHandleTypeFlags {
	ptr := /* typedef */ (*ExternalMemoryHandleTypeFlags)(&x.handleTypes)
	return *ptr
}

// WithHandleTypes clones a new ExternalMemoryBufferCreateInfo with the value of
// HandleTypes updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalMemoryBufferCreateInfo) WithHandleTypes(y ExternalMemoryHandleTypeFlags) ExternalMemoryBufferCreateInfo {
	x.handleTypes = *( /* typedef */ (*C.VkExternalMemoryHandleTypeFlags)(&y))
	return x
}
func (x *ExternalMemoryBufferCreateInfo) SetHandleTypes(y ExternalMemoryHandleTypeFlags) {
	x.handleTypes = *( /* typedef */ (*C.VkExternalMemoryHandleTypeFlags)(&y))
}

// PhysicalDeviceExternalImageFormatInfo provides a go interface for VkPhysicalDeviceExternalImageFormatInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalImageFormatInfo.html
type PhysicalDeviceExternalImageFormatInfo C.struct_VkPhysicalDeviceExternalImageFormatInfo

// SizeofPhysicalDeviceExternalImageFormatInfo is the memory size of a PhysicalDeviceExternalImageFormatInfo
var SizeofPhysicalDeviceExternalImageFormatInfo int = int(unsafe.Sizeof(PhysicalDeviceExternalImageFormatInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceExternalImageFormatInfo) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceExternalImageFormatInfo {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceExternalImageFormatInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceExternalImageFormatInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceExternalImageFormatInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceExternalImageFormatInfo) AsCPtr() *PhysicalDeviceExternalImageFormatInfo {
	clone := (*PhysicalDeviceExternalImageFormatInfo)(newCBlock(cULong(SizeofPhysicalDeviceExternalImageFormatInfo)))
	*clone = x
	return clone
}

// PhysicalDeviceExternalImageFormatInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceExternalImageFormatInfoCSlice(arp *AutoReleasePool, x ...PhysicalDeviceExternalImageFormatInfo) []PhysicalDeviceExternalImageFormatInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceExternalImageFormatInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceExternalImageFormatInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceExternalImageFormatInfoFreeCSlice releases the memory allocated by PhysicalDeviceExternalImageFormatInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceExternalImageFormatInfoFreeCSlice(x []PhysicalDeviceExternalImageFormatInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceExternalImageFormatInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceExternalImageFormatInfoFreeCSlice must be called on the returned slice.
func PhysicalDeviceExternalImageFormatInfoMakeCSlice(x ...PhysicalDeviceExternalImageFormatInfo) []PhysicalDeviceExternalImageFormatInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceExternalImageFormatInfo * len(x)
	dst := unsafe.Slice((*PhysicalDeviceExternalImageFormatInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceExternalImageFormatInfo
func (x PhysicalDeviceExternalImageFormatInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceExternalImageFormatInfo with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceExternalImageFormatInfo) WithDefaultSType() PhysicalDeviceExternalImageFormatInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceExternalImageFormatInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO)
}

// WithSType clones a new PhysicalDeviceExternalImageFormatInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalImageFormatInfo) WithSType(y StructureType) PhysicalDeviceExternalImageFormatInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceExternalImageFormatInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceExternalImageFormatInfo
func (x PhysicalDeviceExternalImageFormatInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceExternalImageFormatInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalImageFormatInfo) WithPNext(y unsafe.Pointer) PhysicalDeviceExternalImageFormatInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceExternalImageFormatInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// HandleType returns the value of handleType from VkPhysicalDeviceExternalImageFormatInfo
func (x PhysicalDeviceExternalImageFormatInfo) HandleType() ExternalMemoryHandleTypeFlagBits {
	ptr := /* typedef */ (*ExternalMemoryHandleTypeFlagBits)(&x.handleType)
	return *ptr
}

// WithHandleType clones a new PhysicalDeviceExternalImageFormatInfo with the value of
// HandleType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalImageFormatInfo) WithHandleType(y ExternalMemoryHandleTypeFlagBits) PhysicalDeviceExternalImageFormatInfo {
	x.handleType = *( /* typedef */ (*C.VkExternalMemoryHandleTypeFlagBits)(&y))
	return x
}
func (x *PhysicalDeviceExternalImageFormatInfo) SetHandleType(y ExternalMemoryHandleTypeFlagBits) {
	x.handleType = *( /* typedef */ (*C.VkExternalMemoryHandleTypeFlagBits)(&y))
}

// ExternalImageFormatProperties provides a go interface for VkExternalImageFormatProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalImageFormatProperties.html
type ExternalImageFormatProperties C.struct_VkExternalImageFormatProperties

// SizeofExternalImageFormatProperties is the memory size of a ExternalImageFormatProperties
var SizeofExternalImageFormatProperties int = int(unsafe.Sizeof(ExternalImageFormatProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ExternalImageFormatProperties) ArpPtr(arp *AutoReleasePool) *ExternalImageFormatProperties {
	ptr := newCBlock(cULong(SizeofExternalImageFormatProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ExternalImageFormatProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExternalImageFormatProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExternalImageFormatProperties) AsCPtr() *ExternalImageFormatProperties {
	clone := (*ExternalImageFormatProperties)(newCBlock(cULong(SizeofExternalImageFormatProperties)))
	*clone = x
	return clone
}

// ExternalImageFormatPropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ExternalImageFormatPropertiesCSlice(arp *AutoReleasePool, x ...ExternalImageFormatProperties) []ExternalImageFormatProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalImageFormatProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ExternalImageFormatProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ExternalImageFormatPropertiesFreeCSlice releases the memory allocated by ExternalImageFormatPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func ExternalImageFormatPropertiesFreeCSlice(x []ExternalImageFormatProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExternalImageFormatPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExternalImageFormatPropertiesFreeCSlice must be called on the returned slice.
func ExternalImageFormatPropertiesMakeCSlice(x ...ExternalImageFormatProperties) []ExternalImageFormatProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalImageFormatProperties * len(x)
	dst := unsafe.Slice((*ExternalImageFormatProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkExternalImageFormatProperties
func (x ExternalImageFormatProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ExternalImageFormatProperties with the value of
// SType to the value provided in the specification.
func (x ExternalImageFormatProperties) WithDefaultSType() ExternalImageFormatProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ExternalImageFormatProperties) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES)
}

// WithSType clones a new ExternalImageFormatProperties with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalImageFormatProperties) WithSType(y StructureType) ExternalImageFormatProperties {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ExternalImageFormatProperties) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkExternalImageFormatProperties
func (x ExternalImageFormatProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ExternalImageFormatProperties with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalImageFormatProperties) WithPNext(y unsafe.Pointer) ExternalImageFormatProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ExternalImageFormatProperties) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// ExternalMemoryProperties returns the value of externalMemoryProperties from VkExternalImageFormatProperties
func (x ExternalImageFormatProperties) ExternalMemoryProperties() ExternalMemoryProperties {
	ptr := /* typedef */ (*ExternalMemoryProperties)(&x.externalMemoryProperties)
	return *ptr
}

// DescriptorUpdateTemplateEntry provides a go interface for VkDescriptorUpdateTemplateEntry.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorUpdateTemplateEntry.html
type DescriptorUpdateTemplateEntry C.struct_VkDescriptorUpdateTemplateEntry

// SizeofDescriptorUpdateTemplateEntry is the memory size of a DescriptorUpdateTemplateEntry
var SizeofDescriptorUpdateTemplateEntry int = int(unsafe.Sizeof(DescriptorUpdateTemplateEntry{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DescriptorUpdateTemplateEntry) ArpPtr(arp *AutoReleasePool) *DescriptorUpdateTemplateEntry {
	ptr := newCBlock(cULong(SizeofDescriptorUpdateTemplateEntry))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DescriptorUpdateTemplateEntry)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorUpdateTemplateEntry) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorUpdateTemplateEntry) AsCPtr() *DescriptorUpdateTemplateEntry {
	clone := (*DescriptorUpdateTemplateEntry)(newCBlock(cULong(SizeofDescriptorUpdateTemplateEntry)))
	*clone = x
	return clone
}

// DescriptorUpdateTemplateEntryCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DescriptorUpdateTemplateEntryCSlice(arp *AutoReleasePool, x ...DescriptorUpdateTemplateEntry) []DescriptorUpdateTemplateEntry {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorUpdateTemplateEntry * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DescriptorUpdateTemplateEntry)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DescriptorUpdateTemplateEntryFreeCSlice releases the memory allocated by DescriptorUpdateTemplateEntryMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorUpdateTemplateEntryFreeCSlice(x []DescriptorUpdateTemplateEntry) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorUpdateTemplateEntryMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorUpdateTemplateEntryFreeCSlice must be called on the returned slice.
func DescriptorUpdateTemplateEntryMakeCSlice(x ...DescriptorUpdateTemplateEntry) []DescriptorUpdateTemplateEntry {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorUpdateTemplateEntry * len(x)
	dst := unsafe.Slice((*DescriptorUpdateTemplateEntry)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// DstBinding returns the value of dstBinding from VkDescriptorUpdateTemplateEntry
func (x DescriptorUpdateTemplateEntry) DstBinding() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dstBinding)
	return *ptr
}

// WithDstBinding clones a new DescriptorUpdateTemplateEntry with the value of
// DstBinding updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateEntry) WithDstBinding(y uint32) DescriptorUpdateTemplateEntry {
	x.dstBinding = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DescriptorUpdateTemplateEntry) SetDstBinding(y uint32) {
	x.dstBinding = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// DstArrayElement returns the value of dstArrayElement from VkDescriptorUpdateTemplateEntry
func (x DescriptorUpdateTemplateEntry) DstArrayElement() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dstArrayElement)
	return *ptr
}

// WithDstArrayElement clones a new DescriptorUpdateTemplateEntry with the value of
// DstArrayElement updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateEntry) WithDstArrayElement(y uint32) DescriptorUpdateTemplateEntry {
	x.dstArrayElement = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DescriptorUpdateTemplateEntry) SetDstArrayElement(y uint32) {
	x.dstArrayElement = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// DescriptorCount returns the value of descriptorCount from VkDescriptorUpdateTemplateEntry
func (x DescriptorUpdateTemplateEntry) DescriptorCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.descriptorCount)
	return *ptr
}

// WithDescriptorCount clones a new DescriptorUpdateTemplateEntry with the value of
// DescriptorCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateEntry) WithDescriptorCount(y uint32) DescriptorUpdateTemplateEntry {
	x.descriptorCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DescriptorUpdateTemplateEntry) SetDescriptorCount(y uint32) {
	x.descriptorCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// DescriptorType returns the value of descriptorType from VkDescriptorUpdateTemplateEntry
func (x DescriptorUpdateTemplateEntry) DescriptorType() DescriptorType {
	ptr := /* typedef */ (*DescriptorType)(&x.descriptorType)
	return *ptr
}

// WithDescriptorType clones a new DescriptorUpdateTemplateEntry with the value of
// DescriptorType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateEntry) WithDescriptorType(y DescriptorType) DescriptorUpdateTemplateEntry {
	x.descriptorType = *( /* typedef */ (*C.VkDescriptorType)(&y))
	return x
}
func (x *DescriptorUpdateTemplateEntry) SetDescriptorType(y DescriptorType) {
	x.descriptorType = *( /* typedef */ (*C.VkDescriptorType)(&y))
}

// Offset returns the value of offset from VkDescriptorUpdateTemplateEntry
func (x DescriptorUpdateTemplateEntry) Offset() uint64 {
	ptr := func(x *C.size_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.offset)
	return *ptr
}

// WithOffset clones a new DescriptorUpdateTemplateEntry with the value of
// Offset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateEntry) WithOffset(y uint64) DescriptorUpdateTemplateEntry {
	x.offset = *(func(x *uint64) *C.size_t { /* Scalar */ g2c := C.size_t(*x); return &g2c }(&y))
	return x
}
func (x *DescriptorUpdateTemplateEntry) SetOffset(y uint64) {
	x.offset = *(func(x *uint64) *C.size_t { /* Scalar */ g2c := C.size_t(*x); return &g2c }(&y))
}

// Stride returns the value of stride from VkDescriptorUpdateTemplateEntry
func (x DescriptorUpdateTemplateEntry) Stride() uint64 {
	ptr := func(x *C.size_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.stride)
	return *ptr
}

// WithStride clones a new DescriptorUpdateTemplateEntry with the value of
// Stride updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateEntry) WithStride(y uint64) DescriptorUpdateTemplateEntry {
	x.stride = *(func(x *uint64) *C.size_t { /* Scalar */ g2c := C.size_t(*x); return &g2c }(&y))
	return x
}
func (x *DescriptorUpdateTemplateEntry) SetStride(y uint64) {
	x.stride = *(func(x *uint64) *C.size_t { /* Scalar */ g2c := C.size_t(*x); return &g2c }(&y))
}

// DescriptorUpdateTemplateCreateInfo provides a go interface for VkDescriptorUpdateTemplateCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorUpdateTemplateCreateInfo.html
type DescriptorUpdateTemplateCreateInfo C.struct_VkDescriptorUpdateTemplateCreateInfo

// SizeofDescriptorUpdateTemplateCreateInfo is the memory size of a DescriptorUpdateTemplateCreateInfo
var SizeofDescriptorUpdateTemplateCreateInfo int = int(unsafe.Sizeof(DescriptorUpdateTemplateCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DescriptorUpdateTemplateCreateInfo) ArpPtr(arp *AutoReleasePool) *DescriptorUpdateTemplateCreateInfo {
	ptr := newCBlock(cULong(SizeofDescriptorUpdateTemplateCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DescriptorUpdateTemplateCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorUpdateTemplateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorUpdateTemplateCreateInfo) AsCPtr() *DescriptorUpdateTemplateCreateInfo {
	clone := (*DescriptorUpdateTemplateCreateInfo)(newCBlock(cULong(SizeofDescriptorUpdateTemplateCreateInfo)))
	*clone = x
	return clone
}

// DescriptorUpdateTemplateCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DescriptorUpdateTemplateCreateInfoCSlice(arp *AutoReleasePool, x ...DescriptorUpdateTemplateCreateInfo) []DescriptorUpdateTemplateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorUpdateTemplateCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DescriptorUpdateTemplateCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DescriptorUpdateTemplateCreateInfoFreeCSlice releases the memory allocated by DescriptorUpdateTemplateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorUpdateTemplateCreateInfoFreeCSlice(x []DescriptorUpdateTemplateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorUpdateTemplateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorUpdateTemplateCreateInfoFreeCSlice must be called on the returned slice.
func DescriptorUpdateTemplateCreateInfoMakeCSlice(x ...DescriptorUpdateTemplateCreateInfo) []DescriptorUpdateTemplateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorUpdateTemplateCreateInfo * len(x)
	dst := unsafe.Slice((*DescriptorUpdateTemplateCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DescriptorUpdateTemplateCreateInfo with the value of
// SType to the value provided in the specification.
func (x DescriptorUpdateTemplateCreateInfo) WithDefaultSType() DescriptorUpdateTemplateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DescriptorUpdateTemplateCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO)
}

// WithSType clones a new DescriptorUpdateTemplateCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateCreateInfo) WithSType(y StructureType) DescriptorUpdateTemplateCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DescriptorUpdateTemplateCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DescriptorUpdateTemplateCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateCreateInfo) WithPNext(y unsafe.Pointer) DescriptorUpdateTemplateCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DescriptorUpdateTemplateCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) Flags() DescriptorUpdateTemplateCreateFlags {
	ptr := /* typedef */ (*DescriptorUpdateTemplateCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new DescriptorUpdateTemplateCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateCreateInfo) WithFlags(y DescriptorUpdateTemplateCreateFlags) DescriptorUpdateTemplateCreateInfo {
	x.flags = *( /* typedef */ (*C.VkDescriptorUpdateTemplateCreateFlags)(&y))
	return x
}
func (x *DescriptorUpdateTemplateCreateInfo) SetFlags(y DescriptorUpdateTemplateCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkDescriptorUpdateTemplateCreateFlags)(&y))
}

// DescriptorUpdateEntryCount returns the value of descriptorUpdateEntryCount from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) DescriptorUpdateEntryCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.descriptorUpdateEntryCount)
	return *ptr
}

// WithDescriptorUpdateEntryCount clones a new DescriptorUpdateTemplateCreateInfo with the value of
// DescriptorUpdateEntryCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateCreateInfo) WithDescriptorUpdateEntryCount(y uint32) DescriptorUpdateTemplateCreateInfo {
	x.descriptorUpdateEntryCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DescriptorUpdateTemplateCreateInfo) SetDescriptorUpdateEntryCount(y uint32) {
	x.descriptorUpdateEntryCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PDescriptorUpdateEntries returns the value of pDescriptorUpdateEntries from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) PDescriptorUpdateEntries() []DescriptorUpdateTemplateEntry {
	ptr := func(x **C.struct_VkDescriptorUpdateTemplateEntry) *[]DescriptorUpdateTemplateEntry { /* Slice */
		slc := unsafe.Slice((*DescriptorUpdateTemplateEntry)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pDescriptorUpdateEntries)
	return *ptr
}

// WithPDescriptorUpdateEntries clones a new DescriptorUpdateTemplateCreateInfo with the value of
// PDescriptorUpdateEntries updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DescriptorUpdateEntryCount as the length of this field.
// DescriptorUpdateEntryCount is updated with the length of the new value.
func (x DescriptorUpdateTemplateCreateInfo) WithPDescriptorUpdateEntries(y []DescriptorUpdateTemplateEntry) DescriptorUpdateTemplateCreateInfo {
	x.pDescriptorUpdateEntries = *(func(x *[]DescriptorUpdateTemplateEntry) **C.struct_VkDescriptorUpdateTemplateEntry { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDescriptorUpdateTemplateEntry)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDescriptorUpdateTemplateEntry)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithDescriptorUpdateEntryCount(uint32(len(y)))
}
func (x *DescriptorUpdateTemplateCreateInfo) SetPDescriptorUpdateEntries(y []DescriptorUpdateTemplateEntry) {
	x.pDescriptorUpdateEntries = *(func(x *[]DescriptorUpdateTemplateEntry) **C.struct_VkDescriptorUpdateTemplateEntry { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDescriptorUpdateTemplateEntry)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDescriptorUpdateTemplateEntry)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetDescriptorUpdateEntryCount(uint32(len(y)))
}

// TemplateType returns the value of templateType from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) TemplateType() DescriptorUpdateTemplateType {
	ptr := /* typedef */ (*DescriptorUpdateTemplateType)(&x.templateType)
	return *ptr
}

// WithTemplateType clones a new DescriptorUpdateTemplateCreateInfo with the value of
// TemplateType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateCreateInfo) WithTemplateType(y DescriptorUpdateTemplateType) DescriptorUpdateTemplateCreateInfo {
	x.templateType = *( /* typedef */ (*C.VkDescriptorUpdateTemplateType)(&y))
	return x
}
func (x *DescriptorUpdateTemplateCreateInfo) SetTemplateType(y DescriptorUpdateTemplateType) {
	x.templateType = *( /* typedef */ (*C.VkDescriptorUpdateTemplateType)(&y))
}

// DescriptorSetLayout returns the value of descriptorSetLayout from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) DescriptorSetLayout() DescriptorSetLayout {
	ptr := /* handle */ (*DescriptorSetLayout)(&x.descriptorSetLayout)
	return *ptr
}

// WithDescriptorSetLayout clones a new DescriptorUpdateTemplateCreateInfo with the value of
// DescriptorSetLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateCreateInfo) WithDescriptorSetLayout(y DescriptorSetLayout) DescriptorUpdateTemplateCreateInfo {
	x.descriptorSetLayout = *( /* handle */ (*C.VkDescriptorSetLayout)(&y))
	return x
}
func (x *DescriptorUpdateTemplateCreateInfo) SetDescriptorSetLayout(y DescriptorSetLayout) {
	x.descriptorSetLayout = *( /* handle */ (*C.VkDescriptorSetLayout)(&y))
}

// PipelineBindPoint returns the value of pipelineBindPoint from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) PipelineBindPoint() PipelineBindPoint {
	ptr := /* typedef */ (*PipelineBindPoint)(&x.pipelineBindPoint)
	return *ptr
}

// WithPipelineBindPoint clones a new DescriptorUpdateTemplateCreateInfo with the value of
// PipelineBindPoint updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateCreateInfo) WithPipelineBindPoint(y PipelineBindPoint) DescriptorUpdateTemplateCreateInfo {
	x.pipelineBindPoint = *( /* typedef */ (*C.VkPipelineBindPoint)(&y))
	return x
}
func (x *DescriptorUpdateTemplateCreateInfo) SetPipelineBindPoint(y PipelineBindPoint) {
	x.pipelineBindPoint = *( /* typedef */ (*C.VkPipelineBindPoint)(&y))
}

// PipelineLayout returns the value of pipelineLayout from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) PipelineLayout() PipelineLayout {
	ptr := /* handle */ (*PipelineLayout)(&x.pipelineLayout)
	return *ptr
}

// WithPipelineLayout clones a new DescriptorUpdateTemplateCreateInfo with the value of
// PipelineLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateCreateInfo) WithPipelineLayout(y PipelineLayout) DescriptorUpdateTemplateCreateInfo {
	x.pipelineLayout = *( /* handle */ (*C.VkPipelineLayout)(&y))
	return x
}
func (x *DescriptorUpdateTemplateCreateInfo) SetPipelineLayout(y PipelineLayout) {
	x.pipelineLayout = *( /* handle */ (*C.VkPipelineLayout)(&y))
}

// Set returns the value of set from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) Set() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.set)
	return *ptr
}

// WithSet clones a new DescriptorUpdateTemplateCreateInfo with the value of
// Set updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateCreateInfo) WithSet(y uint32) DescriptorUpdateTemplateCreateInfo {
	x.set = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DescriptorUpdateTemplateCreateInfo) SetSet(y uint32) {
	x.set = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// BindBufferMemoryDeviceGroupInfo provides a go interface for VkBindBufferMemoryDeviceGroupInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindBufferMemoryDeviceGroupInfo.html
type BindBufferMemoryDeviceGroupInfo C.struct_VkBindBufferMemoryDeviceGroupInfo

// SizeofBindBufferMemoryDeviceGroupInfo is the memory size of a BindBufferMemoryDeviceGroupInfo
var SizeofBindBufferMemoryDeviceGroupInfo int = int(unsafe.Sizeof(BindBufferMemoryDeviceGroupInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x BindBufferMemoryDeviceGroupInfo) ArpPtr(arp *AutoReleasePool) *BindBufferMemoryDeviceGroupInfo {
	ptr := newCBlock(cULong(SizeofBindBufferMemoryDeviceGroupInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*BindBufferMemoryDeviceGroupInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BindBufferMemoryDeviceGroupInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BindBufferMemoryDeviceGroupInfo) AsCPtr() *BindBufferMemoryDeviceGroupInfo {
	clone := (*BindBufferMemoryDeviceGroupInfo)(newCBlock(cULong(SizeofBindBufferMemoryDeviceGroupInfo)))
	*clone = x
	return clone
}

// BindBufferMemoryDeviceGroupInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func BindBufferMemoryDeviceGroupInfoCSlice(arp *AutoReleasePool, x ...BindBufferMemoryDeviceGroupInfo) []BindBufferMemoryDeviceGroupInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindBufferMemoryDeviceGroupInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*BindBufferMemoryDeviceGroupInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// BindBufferMemoryDeviceGroupInfoFreeCSlice releases the memory allocated by BindBufferMemoryDeviceGroupInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BindBufferMemoryDeviceGroupInfoFreeCSlice(x []BindBufferMemoryDeviceGroupInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BindBufferMemoryDeviceGroupInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BindBufferMemoryDeviceGroupInfoFreeCSlice must be called on the returned slice.
func BindBufferMemoryDeviceGroupInfoMakeCSlice(x ...BindBufferMemoryDeviceGroupInfo) []BindBufferMemoryDeviceGroupInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindBufferMemoryDeviceGroupInfo * len(x)
	dst := unsafe.Slice((*BindBufferMemoryDeviceGroupInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBindBufferMemoryDeviceGroupInfo
func (x BindBufferMemoryDeviceGroupInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new BindBufferMemoryDeviceGroupInfo with the value of
// SType to the value provided in the specification.
func (x BindBufferMemoryDeviceGroupInfo) WithDefaultSType() BindBufferMemoryDeviceGroupInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *BindBufferMemoryDeviceGroupInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO)
}

// WithSType clones a new BindBufferMemoryDeviceGroupInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindBufferMemoryDeviceGroupInfo) WithSType(y StructureType) BindBufferMemoryDeviceGroupInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *BindBufferMemoryDeviceGroupInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkBindBufferMemoryDeviceGroupInfo
func (x BindBufferMemoryDeviceGroupInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new BindBufferMemoryDeviceGroupInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindBufferMemoryDeviceGroupInfo) WithPNext(y unsafe.Pointer) BindBufferMemoryDeviceGroupInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *BindBufferMemoryDeviceGroupInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// DeviceIndexCount returns the value of deviceIndexCount from VkBindBufferMemoryDeviceGroupInfo
func (x BindBufferMemoryDeviceGroupInfo) DeviceIndexCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.deviceIndexCount)
	return *ptr
}

// WithDeviceIndexCount clones a new BindBufferMemoryDeviceGroupInfo with the value of
// DeviceIndexCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindBufferMemoryDeviceGroupInfo) WithDeviceIndexCount(y uint32) BindBufferMemoryDeviceGroupInfo {
	x.deviceIndexCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *BindBufferMemoryDeviceGroupInfo) SetDeviceIndexCount(y uint32) {
	x.deviceIndexCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PDeviceIndices returns the value of pDeviceIndices from VkBindBufferMemoryDeviceGroupInfo
func (x BindBufferMemoryDeviceGroupInfo) PDeviceIndices() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pDeviceIndices)
	return *ptr
}

// WithPDeviceIndices clones a new BindBufferMemoryDeviceGroupInfo with the value of
// PDeviceIndices updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DeviceIndexCount as the length of this field.
// DeviceIndexCount is updated with the length of the new value.
func (x BindBufferMemoryDeviceGroupInfo) WithPDeviceIndices(y []uint32) BindBufferMemoryDeviceGroupInfo {
	x.pDeviceIndices = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithDeviceIndexCount(uint32(len(y)))
}
func (x *BindBufferMemoryDeviceGroupInfo) SetPDeviceIndices(y []uint32) {
	x.pDeviceIndices = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetDeviceIndexCount(uint32(len(y)))
}

// BindImageMemoryDeviceGroupInfo provides a go interface for VkBindImageMemoryDeviceGroupInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindImageMemoryDeviceGroupInfo.html
type BindImageMemoryDeviceGroupInfo C.struct_VkBindImageMemoryDeviceGroupInfo

// SizeofBindImageMemoryDeviceGroupInfo is the memory size of a BindImageMemoryDeviceGroupInfo
var SizeofBindImageMemoryDeviceGroupInfo int = int(unsafe.Sizeof(BindImageMemoryDeviceGroupInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x BindImageMemoryDeviceGroupInfo) ArpPtr(arp *AutoReleasePool) *BindImageMemoryDeviceGroupInfo {
	ptr := newCBlock(cULong(SizeofBindImageMemoryDeviceGroupInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*BindImageMemoryDeviceGroupInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BindImageMemoryDeviceGroupInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BindImageMemoryDeviceGroupInfo) AsCPtr() *BindImageMemoryDeviceGroupInfo {
	clone := (*BindImageMemoryDeviceGroupInfo)(newCBlock(cULong(SizeofBindImageMemoryDeviceGroupInfo)))
	*clone = x
	return clone
}

// BindImageMemoryDeviceGroupInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func BindImageMemoryDeviceGroupInfoCSlice(arp *AutoReleasePool, x ...BindImageMemoryDeviceGroupInfo) []BindImageMemoryDeviceGroupInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindImageMemoryDeviceGroupInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*BindImageMemoryDeviceGroupInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// BindImageMemoryDeviceGroupInfoFreeCSlice releases the memory allocated by BindImageMemoryDeviceGroupInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BindImageMemoryDeviceGroupInfoFreeCSlice(x []BindImageMemoryDeviceGroupInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BindImageMemoryDeviceGroupInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BindImageMemoryDeviceGroupInfoFreeCSlice must be called on the returned slice.
func BindImageMemoryDeviceGroupInfoMakeCSlice(x ...BindImageMemoryDeviceGroupInfo) []BindImageMemoryDeviceGroupInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindImageMemoryDeviceGroupInfo * len(x)
	dst := unsafe.Slice((*BindImageMemoryDeviceGroupInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBindImageMemoryDeviceGroupInfo
func (x BindImageMemoryDeviceGroupInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new BindImageMemoryDeviceGroupInfo with the value of
// SType to the value provided in the specification.
func (x BindImageMemoryDeviceGroupInfo) WithDefaultSType() BindImageMemoryDeviceGroupInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *BindImageMemoryDeviceGroupInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO)
}

// WithSType clones a new BindImageMemoryDeviceGroupInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemoryDeviceGroupInfo) WithSType(y StructureType) BindImageMemoryDeviceGroupInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *BindImageMemoryDeviceGroupInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkBindImageMemoryDeviceGroupInfo
func (x BindImageMemoryDeviceGroupInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new BindImageMemoryDeviceGroupInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemoryDeviceGroupInfo) WithPNext(y unsafe.Pointer) BindImageMemoryDeviceGroupInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *BindImageMemoryDeviceGroupInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// DeviceIndexCount returns the value of deviceIndexCount from VkBindImageMemoryDeviceGroupInfo
func (x BindImageMemoryDeviceGroupInfo) DeviceIndexCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.deviceIndexCount)
	return *ptr
}

// WithDeviceIndexCount clones a new BindImageMemoryDeviceGroupInfo with the value of
// DeviceIndexCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemoryDeviceGroupInfo) WithDeviceIndexCount(y uint32) BindImageMemoryDeviceGroupInfo {
	x.deviceIndexCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *BindImageMemoryDeviceGroupInfo) SetDeviceIndexCount(y uint32) {
	x.deviceIndexCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PDeviceIndices returns the value of pDeviceIndices from VkBindImageMemoryDeviceGroupInfo
func (x BindImageMemoryDeviceGroupInfo) PDeviceIndices() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pDeviceIndices)
	return *ptr
}

// WithPDeviceIndices clones a new BindImageMemoryDeviceGroupInfo with the value of
// PDeviceIndices updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DeviceIndexCount as the length of this field.
// DeviceIndexCount is updated with the length of the new value.
func (x BindImageMemoryDeviceGroupInfo) WithPDeviceIndices(y []uint32) BindImageMemoryDeviceGroupInfo {
	x.pDeviceIndices = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithDeviceIndexCount(uint32(len(y)))
}
func (x *BindImageMemoryDeviceGroupInfo) SetPDeviceIndices(y []uint32) {
	x.pDeviceIndices = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetDeviceIndexCount(uint32(len(y)))
}

// SplitInstanceBindRegionCount returns the value of splitInstanceBindRegionCount from VkBindImageMemoryDeviceGroupInfo
func (x BindImageMemoryDeviceGroupInfo) SplitInstanceBindRegionCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.splitInstanceBindRegionCount)
	return *ptr
}

// WithSplitInstanceBindRegionCount clones a new BindImageMemoryDeviceGroupInfo with the value of
// SplitInstanceBindRegionCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemoryDeviceGroupInfo) WithSplitInstanceBindRegionCount(y uint32) BindImageMemoryDeviceGroupInfo {
	x.splitInstanceBindRegionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *BindImageMemoryDeviceGroupInfo) SetSplitInstanceBindRegionCount(y uint32) {
	x.splitInstanceBindRegionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PSplitInstanceBindRegions returns the value of pSplitInstanceBindRegions from VkBindImageMemoryDeviceGroupInfo
func (x BindImageMemoryDeviceGroupInfo) PSplitInstanceBindRegions() []Rect2D {
	ptr := func(x **C.struct_VkRect2D) *[]Rect2D { /* Slice */
		slc := unsafe.Slice((*Rect2D)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pSplitInstanceBindRegions)
	return *ptr
}

// WithPSplitInstanceBindRegions clones a new BindImageMemoryDeviceGroupInfo with the value of
// PSplitInstanceBindRegions updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SplitInstanceBindRegionCount as the length of this field.
// SplitInstanceBindRegionCount is updated with the length of the new value.
func (x BindImageMemoryDeviceGroupInfo) WithPSplitInstanceBindRegions(y []Rect2D) BindImageMemoryDeviceGroupInfo {
	x.pSplitInstanceBindRegions = *(func(x *[]Rect2D) **C.struct_VkRect2D { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkRect2D)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkRect2D)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithSplitInstanceBindRegionCount(uint32(len(y)))
}
func (x *BindImageMemoryDeviceGroupInfo) SetPSplitInstanceBindRegions(y []Rect2D) {
	x.pSplitInstanceBindRegions = *(func(x *[]Rect2D) **C.struct_VkRect2D { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkRect2D)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkRect2D)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetSplitInstanceBindRegionCount(uint32(len(y)))
}

// MemoryDedicatedAllocateInfo provides a go interface for VkMemoryDedicatedAllocateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryDedicatedAllocateInfo.html
type MemoryDedicatedAllocateInfo C.struct_VkMemoryDedicatedAllocateInfo

// SizeofMemoryDedicatedAllocateInfo is the memory size of a MemoryDedicatedAllocateInfo
var SizeofMemoryDedicatedAllocateInfo int = int(unsafe.Sizeof(MemoryDedicatedAllocateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x MemoryDedicatedAllocateInfo) ArpPtr(arp *AutoReleasePool) *MemoryDedicatedAllocateInfo {
	ptr := newCBlock(cULong(SizeofMemoryDedicatedAllocateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*MemoryDedicatedAllocateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryDedicatedAllocateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryDedicatedAllocateInfo) AsCPtr() *MemoryDedicatedAllocateInfo {
	clone := (*MemoryDedicatedAllocateInfo)(newCBlock(cULong(SizeofMemoryDedicatedAllocateInfo)))
	*clone = x
	return clone
}

// MemoryDedicatedAllocateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func MemoryDedicatedAllocateInfoCSlice(arp *AutoReleasePool, x ...MemoryDedicatedAllocateInfo) []MemoryDedicatedAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryDedicatedAllocateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*MemoryDedicatedAllocateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// MemoryDedicatedAllocateInfoFreeCSlice releases the memory allocated by MemoryDedicatedAllocateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryDedicatedAllocateInfoFreeCSlice(x []MemoryDedicatedAllocateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryDedicatedAllocateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryDedicatedAllocateInfoFreeCSlice must be called on the returned slice.
func MemoryDedicatedAllocateInfoMakeCSlice(x ...MemoryDedicatedAllocateInfo) []MemoryDedicatedAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryDedicatedAllocateInfo * len(x)
	dst := unsafe.Slice((*MemoryDedicatedAllocateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkMemoryDedicatedAllocateInfo
func (x MemoryDedicatedAllocateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new MemoryDedicatedAllocateInfo with the value of
// SType to the value provided in the specification.
func (x MemoryDedicatedAllocateInfo) WithDefaultSType() MemoryDedicatedAllocateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *MemoryDedicatedAllocateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO)
}

// WithSType clones a new MemoryDedicatedAllocateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryDedicatedAllocateInfo) WithSType(y StructureType) MemoryDedicatedAllocateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *MemoryDedicatedAllocateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkMemoryDedicatedAllocateInfo
func (x MemoryDedicatedAllocateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new MemoryDedicatedAllocateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryDedicatedAllocateInfo) WithPNext(y unsafe.Pointer) MemoryDedicatedAllocateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *MemoryDedicatedAllocateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Image returns the value of image from VkMemoryDedicatedAllocateInfo
func (x MemoryDedicatedAllocateInfo) Image() Image {
	ptr := /* handle */ (*Image)(&x.image)
	return *ptr
}

// WithImage clones a new MemoryDedicatedAllocateInfo with the value of
// Image updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryDedicatedAllocateInfo) WithImage(y Image) MemoryDedicatedAllocateInfo {
	x.image = *( /* handle */ (*C.VkImage)(&y))
	return x
}
func (x *MemoryDedicatedAllocateInfo) SetImage(y Image) {
	x.image = *( /* handle */ (*C.VkImage)(&y))
}

// Buffer returns the value of buffer from VkMemoryDedicatedAllocateInfo
func (x MemoryDedicatedAllocateInfo) Buffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.buffer)
	return *ptr
}

// WithBuffer clones a new MemoryDedicatedAllocateInfo with the value of
// Buffer updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryDedicatedAllocateInfo) WithBuffer(y Buffer) MemoryDedicatedAllocateInfo {
	x.buffer = *( /* handle */ (*C.VkBuffer)(&y))
	return x
}
func (x *MemoryDedicatedAllocateInfo) SetBuffer(y Buffer) {
	x.buffer = *( /* handle */ (*C.VkBuffer)(&y))
}

// DeviceGroupBindSparseInfo provides a go interface for VkDeviceGroupBindSparseInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupBindSparseInfo.html
type DeviceGroupBindSparseInfo C.struct_VkDeviceGroupBindSparseInfo

// SizeofDeviceGroupBindSparseInfo is the memory size of a DeviceGroupBindSparseInfo
var SizeofDeviceGroupBindSparseInfo int = int(unsafe.Sizeof(DeviceGroupBindSparseInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DeviceGroupBindSparseInfo) ArpPtr(arp *AutoReleasePool) *DeviceGroupBindSparseInfo {
	ptr := newCBlock(cULong(SizeofDeviceGroupBindSparseInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DeviceGroupBindSparseInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceGroupBindSparseInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceGroupBindSparseInfo) AsCPtr() *DeviceGroupBindSparseInfo {
	clone := (*DeviceGroupBindSparseInfo)(newCBlock(cULong(SizeofDeviceGroupBindSparseInfo)))
	*clone = x
	return clone
}

// DeviceGroupBindSparseInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DeviceGroupBindSparseInfoCSlice(arp *AutoReleasePool, x ...DeviceGroupBindSparseInfo) []DeviceGroupBindSparseInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupBindSparseInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DeviceGroupBindSparseInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DeviceGroupBindSparseInfoFreeCSlice releases the memory allocated by DeviceGroupBindSparseInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceGroupBindSparseInfoFreeCSlice(x []DeviceGroupBindSparseInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceGroupBindSparseInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceGroupBindSparseInfoFreeCSlice must be called on the returned slice.
func DeviceGroupBindSparseInfoMakeCSlice(x ...DeviceGroupBindSparseInfo) []DeviceGroupBindSparseInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupBindSparseInfo * len(x)
	dst := unsafe.Slice((*DeviceGroupBindSparseInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceGroupBindSparseInfo
func (x DeviceGroupBindSparseInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DeviceGroupBindSparseInfo with the value of
// SType to the value provided in the specification.
func (x DeviceGroupBindSparseInfo) WithDefaultSType() DeviceGroupBindSparseInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DeviceGroupBindSparseInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO)
}

// WithSType clones a new DeviceGroupBindSparseInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupBindSparseInfo) WithSType(y StructureType) DeviceGroupBindSparseInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DeviceGroupBindSparseInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDeviceGroupBindSparseInfo
func (x DeviceGroupBindSparseInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DeviceGroupBindSparseInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupBindSparseInfo) WithPNext(y unsafe.Pointer) DeviceGroupBindSparseInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DeviceGroupBindSparseInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// ResourceDeviceIndex returns the value of resourceDeviceIndex from VkDeviceGroupBindSparseInfo
func (x DeviceGroupBindSparseInfo) ResourceDeviceIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.resourceDeviceIndex)
	return *ptr
}

// WithResourceDeviceIndex clones a new DeviceGroupBindSparseInfo with the value of
// ResourceDeviceIndex updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupBindSparseInfo) WithResourceDeviceIndex(y uint32) DeviceGroupBindSparseInfo {
	x.resourceDeviceIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DeviceGroupBindSparseInfo) SetResourceDeviceIndex(y uint32) {
	x.resourceDeviceIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// MemoryDeviceIndex returns the value of memoryDeviceIndex from VkDeviceGroupBindSparseInfo
func (x DeviceGroupBindSparseInfo) MemoryDeviceIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.memoryDeviceIndex)
	return *ptr
}

// WithMemoryDeviceIndex clones a new DeviceGroupBindSparseInfo with the value of
// MemoryDeviceIndex updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupBindSparseInfo) WithMemoryDeviceIndex(y uint32) DeviceGroupBindSparseInfo {
	x.memoryDeviceIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DeviceGroupBindSparseInfo) SetMemoryDeviceIndex(y uint32) {
	x.memoryDeviceIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// DescriptorSetLayoutSupport provides a go interface for VkDescriptorSetLayoutSupport.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutSupport.html
type DescriptorSetLayoutSupport C.struct_VkDescriptorSetLayoutSupport

// SizeofDescriptorSetLayoutSupport is the memory size of a DescriptorSetLayoutSupport
var SizeofDescriptorSetLayoutSupport int = int(unsafe.Sizeof(DescriptorSetLayoutSupport{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DescriptorSetLayoutSupport) ArpPtr(arp *AutoReleasePool) *DescriptorSetLayoutSupport {
	ptr := newCBlock(cULong(SizeofDescriptorSetLayoutSupport))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DescriptorSetLayoutSupport)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorSetLayoutSupport) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorSetLayoutSupport) AsCPtr() *DescriptorSetLayoutSupport {
	clone := (*DescriptorSetLayoutSupport)(newCBlock(cULong(SizeofDescriptorSetLayoutSupport)))
	*clone = x
	return clone
}

// DescriptorSetLayoutSupportCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DescriptorSetLayoutSupportCSlice(arp *AutoReleasePool, x ...DescriptorSetLayoutSupport) []DescriptorSetLayoutSupport {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetLayoutSupport * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DescriptorSetLayoutSupport)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DescriptorSetLayoutSupportFreeCSlice releases the memory allocated by DescriptorSetLayoutSupportMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorSetLayoutSupportFreeCSlice(x []DescriptorSetLayoutSupport) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorSetLayoutSupportMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorSetLayoutSupportFreeCSlice must be called on the returned slice.
func DescriptorSetLayoutSupportMakeCSlice(x ...DescriptorSetLayoutSupport) []DescriptorSetLayoutSupport {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetLayoutSupport * len(x)
	dst := unsafe.Slice((*DescriptorSetLayoutSupport)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDescriptorSetLayoutSupport
func (x DescriptorSetLayoutSupport) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DescriptorSetLayoutSupport with the value of
// SType to the value provided in the specification.
func (x DescriptorSetLayoutSupport) WithDefaultSType() DescriptorSetLayoutSupport {
	return x.WithSType(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DescriptorSetLayoutSupport) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT)
}

// WithSType clones a new DescriptorSetLayoutSupport with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutSupport) WithSType(y StructureType) DescriptorSetLayoutSupport {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DescriptorSetLayoutSupport) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDescriptorSetLayoutSupport
func (x DescriptorSetLayoutSupport) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DescriptorSetLayoutSupport with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutSupport) WithPNext(y unsafe.Pointer) DescriptorSetLayoutSupport {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DescriptorSetLayoutSupport) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Supported returns the value of supported from VkDescriptorSetLayoutSupport
func (x DescriptorSetLayoutSupport) Supported() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.supported)
	return *ptr
}

// PhysicalDeviceGroupProperties provides a go interface for VkPhysicalDeviceGroupProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceGroupProperties.html
type PhysicalDeviceGroupProperties C.struct_VkPhysicalDeviceGroupProperties

// SizeofPhysicalDeviceGroupProperties is the memory size of a PhysicalDeviceGroupProperties
var SizeofPhysicalDeviceGroupProperties int = int(unsafe.Sizeof(PhysicalDeviceGroupProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceGroupProperties) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceGroupProperties {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceGroupProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceGroupProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceGroupProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceGroupProperties) AsCPtr() *PhysicalDeviceGroupProperties {
	clone := (*PhysicalDeviceGroupProperties)(newCBlock(cULong(SizeofPhysicalDeviceGroupProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceGroupPropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceGroupPropertiesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceGroupProperties) []PhysicalDeviceGroupProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceGroupProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceGroupProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceGroupPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceGroupPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceGroupPropertiesFreeCSlice(x []PhysicalDeviceGroupProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceGroupPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceGroupPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceGroupPropertiesMakeCSlice(x ...PhysicalDeviceGroupProperties) []PhysicalDeviceGroupProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceGroupProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceGroupProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceGroupProperties
func (x PhysicalDeviceGroupProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceGroupProperties with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceGroupProperties) WithDefaultSType() PhysicalDeviceGroupProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceGroupProperties) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES)
}

// WithSType clones a new PhysicalDeviceGroupProperties with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceGroupProperties) WithSType(y StructureType) PhysicalDeviceGroupProperties {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceGroupProperties) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceGroupProperties
func (x PhysicalDeviceGroupProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceGroupProperties with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceGroupProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceGroupProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceGroupProperties) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// PhysicalDeviceCount returns the value of physicalDeviceCount from VkPhysicalDeviceGroupProperties
func (x PhysicalDeviceGroupProperties) PhysicalDeviceCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.physicalDeviceCount)
	return *ptr
}

// PhysicalDevices returns the value of physicalDevices from VkPhysicalDeviceGroupProperties
func (x PhysicalDeviceGroupProperties) PhysicalDevices() []PhysicalDevice {
	ptr := func(x *[VK_MAX_DEVICE_GROUP_SIZE]C.VkPhysicalDevice) *[]PhysicalDevice { /* Array */
		slc := unsafe.Slice((*PhysicalDevice)(unsafe.Pointer(x)), VK_MAX_DEVICE_GROUP_SIZE)
		return &slc
	}(&x.physicalDevices)
	return *ptr
}

// SubsetAllocation returns the value of subsetAllocation from VkPhysicalDeviceGroupProperties
func (x PhysicalDeviceGroupProperties) SubsetAllocation() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.subsetAllocation)
	return *ptr
}

// DeviceGroupDeviceCreateInfo provides a go interface for VkDeviceGroupDeviceCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupDeviceCreateInfo.html
type DeviceGroupDeviceCreateInfo C.struct_VkDeviceGroupDeviceCreateInfo

// SizeofDeviceGroupDeviceCreateInfo is the memory size of a DeviceGroupDeviceCreateInfo
var SizeofDeviceGroupDeviceCreateInfo int = int(unsafe.Sizeof(DeviceGroupDeviceCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DeviceGroupDeviceCreateInfo) ArpPtr(arp *AutoReleasePool) *DeviceGroupDeviceCreateInfo {
	ptr := newCBlock(cULong(SizeofDeviceGroupDeviceCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DeviceGroupDeviceCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceGroupDeviceCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceGroupDeviceCreateInfo) AsCPtr() *DeviceGroupDeviceCreateInfo {
	clone := (*DeviceGroupDeviceCreateInfo)(newCBlock(cULong(SizeofDeviceGroupDeviceCreateInfo)))
	*clone = x
	return clone
}

// DeviceGroupDeviceCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DeviceGroupDeviceCreateInfoCSlice(arp *AutoReleasePool, x ...DeviceGroupDeviceCreateInfo) []DeviceGroupDeviceCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupDeviceCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DeviceGroupDeviceCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DeviceGroupDeviceCreateInfoFreeCSlice releases the memory allocated by DeviceGroupDeviceCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceGroupDeviceCreateInfoFreeCSlice(x []DeviceGroupDeviceCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceGroupDeviceCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceGroupDeviceCreateInfoFreeCSlice must be called on the returned slice.
func DeviceGroupDeviceCreateInfoMakeCSlice(x ...DeviceGroupDeviceCreateInfo) []DeviceGroupDeviceCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupDeviceCreateInfo * len(x)
	dst := unsafe.Slice((*DeviceGroupDeviceCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceGroupDeviceCreateInfo
func (x DeviceGroupDeviceCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DeviceGroupDeviceCreateInfo with the value of
// SType to the value provided in the specification.
func (x DeviceGroupDeviceCreateInfo) WithDefaultSType() DeviceGroupDeviceCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DeviceGroupDeviceCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO)
}

// WithSType clones a new DeviceGroupDeviceCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupDeviceCreateInfo) WithSType(y StructureType) DeviceGroupDeviceCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DeviceGroupDeviceCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDeviceGroupDeviceCreateInfo
func (x DeviceGroupDeviceCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DeviceGroupDeviceCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupDeviceCreateInfo) WithPNext(y unsafe.Pointer) DeviceGroupDeviceCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DeviceGroupDeviceCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// PhysicalDeviceCount returns the value of physicalDeviceCount from VkDeviceGroupDeviceCreateInfo
func (x DeviceGroupDeviceCreateInfo) PhysicalDeviceCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.physicalDeviceCount)
	return *ptr
}

// WithPhysicalDeviceCount clones a new DeviceGroupDeviceCreateInfo with the value of
// PhysicalDeviceCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupDeviceCreateInfo) WithPhysicalDeviceCount(y uint32) DeviceGroupDeviceCreateInfo {
	x.physicalDeviceCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DeviceGroupDeviceCreateInfo) SetPhysicalDeviceCount(y uint32) {
	x.physicalDeviceCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PPhysicalDevices returns the value of pPhysicalDevices from VkDeviceGroupDeviceCreateInfo
func (x DeviceGroupDeviceCreateInfo) PPhysicalDevices() []PhysicalDevice {
	ptr := func(x **C.VkPhysicalDevice) *[]PhysicalDevice { /* Slice */
		slc := unsafe.Slice((*PhysicalDevice)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pPhysicalDevices)
	return *ptr
}

// WithPPhysicalDevices clones a new DeviceGroupDeviceCreateInfo with the value of
// PPhysicalDevices updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines PhysicalDeviceCount as the length of this field.
// PhysicalDeviceCount is updated with the length of the new value.
func (x DeviceGroupDeviceCreateInfo) WithPPhysicalDevices(y []PhysicalDevice) DeviceGroupDeviceCreateInfo {
	x.pPhysicalDevices = *(func(x *[]PhysicalDevice) **C.VkPhysicalDevice { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkPhysicalDevice)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkPhysicalDevice)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithPhysicalDeviceCount(uint32(len(y)))
}
func (x *DeviceGroupDeviceCreateInfo) SetPPhysicalDevices(y []PhysicalDevice) {
	x.pPhysicalDevices = *(func(x *[]PhysicalDevice) **C.VkPhysicalDevice { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkPhysicalDevice)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkPhysicalDevice)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetPhysicalDeviceCount(uint32(len(y)))
}

// MemoryDedicatedRequirements provides a go interface for VkMemoryDedicatedRequirements.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryDedicatedRequirements.html
type MemoryDedicatedRequirements C.struct_VkMemoryDedicatedRequirements

// SizeofMemoryDedicatedRequirements is the memory size of a MemoryDedicatedRequirements
var SizeofMemoryDedicatedRequirements int = int(unsafe.Sizeof(MemoryDedicatedRequirements{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x MemoryDedicatedRequirements) ArpPtr(arp *AutoReleasePool) *MemoryDedicatedRequirements {
	ptr := newCBlock(cULong(SizeofMemoryDedicatedRequirements))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*MemoryDedicatedRequirements)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryDedicatedRequirements) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryDedicatedRequirements) AsCPtr() *MemoryDedicatedRequirements {
	clone := (*MemoryDedicatedRequirements)(newCBlock(cULong(SizeofMemoryDedicatedRequirements)))
	*clone = x
	return clone
}

// MemoryDedicatedRequirementsCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func MemoryDedicatedRequirementsCSlice(arp *AutoReleasePool, x ...MemoryDedicatedRequirements) []MemoryDedicatedRequirements {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryDedicatedRequirements * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*MemoryDedicatedRequirements)(ptr), len(x))
	copy(dst, x)
	return dst
}

// MemoryDedicatedRequirementsFreeCSlice releases the memory allocated by MemoryDedicatedRequirementsMakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryDedicatedRequirementsFreeCSlice(x []MemoryDedicatedRequirements) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryDedicatedRequirementsMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryDedicatedRequirementsFreeCSlice must be called on the returned slice.
func MemoryDedicatedRequirementsMakeCSlice(x ...MemoryDedicatedRequirements) []MemoryDedicatedRequirements {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryDedicatedRequirements * len(x)
	dst := unsafe.Slice((*MemoryDedicatedRequirements)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkMemoryDedicatedRequirements
func (x MemoryDedicatedRequirements) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new MemoryDedicatedRequirements with the value of
// SType to the value provided in the specification.
func (x MemoryDedicatedRequirements) WithDefaultSType() MemoryDedicatedRequirements {
	return x.WithSType(VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *MemoryDedicatedRequirements) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS)
}

// WithSType clones a new MemoryDedicatedRequirements with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryDedicatedRequirements) WithSType(y StructureType) MemoryDedicatedRequirements {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *MemoryDedicatedRequirements) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkMemoryDedicatedRequirements
func (x MemoryDedicatedRequirements) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new MemoryDedicatedRequirements with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryDedicatedRequirements) WithPNext(y unsafe.Pointer) MemoryDedicatedRequirements {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *MemoryDedicatedRequirements) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// PrefersDedicatedAllocation returns the value of prefersDedicatedAllocation from VkMemoryDedicatedRequirements
func (x MemoryDedicatedRequirements) PrefersDedicatedAllocation() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.prefersDedicatedAllocation)
	return *ptr
}

// RequiresDedicatedAllocation returns the value of requiresDedicatedAllocation from VkMemoryDedicatedRequirements
func (x MemoryDedicatedRequirements) RequiresDedicatedAllocation() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.requiresDedicatedAllocation)
	return *ptr
}

// ExportMemoryAllocateInfo provides a go interface for VkExportMemoryAllocateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMemoryAllocateInfo.html
type ExportMemoryAllocateInfo C.struct_VkExportMemoryAllocateInfo

// SizeofExportMemoryAllocateInfo is the memory size of a ExportMemoryAllocateInfo
var SizeofExportMemoryAllocateInfo int = int(unsafe.Sizeof(ExportMemoryAllocateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ExportMemoryAllocateInfo) ArpPtr(arp *AutoReleasePool) *ExportMemoryAllocateInfo {
	ptr := newCBlock(cULong(SizeofExportMemoryAllocateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ExportMemoryAllocateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExportMemoryAllocateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExportMemoryAllocateInfo) AsCPtr() *ExportMemoryAllocateInfo {
	clone := (*ExportMemoryAllocateInfo)(newCBlock(cULong(SizeofExportMemoryAllocateInfo)))
	*clone = x
	return clone
}

// ExportMemoryAllocateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ExportMemoryAllocateInfoCSlice(arp *AutoReleasePool, x ...ExportMemoryAllocateInfo) []ExportMemoryAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExportMemoryAllocateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ExportMemoryAllocateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ExportMemoryAllocateInfoFreeCSlice releases the memory allocated by ExportMemoryAllocateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ExportMemoryAllocateInfoFreeCSlice(x []ExportMemoryAllocateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExportMemoryAllocateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExportMemoryAllocateInfoFreeCSlice must be called on the returned slice.
func ExportMemoryAllocateInfoMakeCSlice(x ...ExportMemoryAllocateInfo) []ExportMemoryAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExportMemoryAllocateInfo * len(x)
	dst := unsafe.Slice((*ExportMemoryAllocateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkExportMemoryAllocateInfo
func (x ExportMemoryAllocateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ExportMemoryAllocateInfo with the value of
// SType to the value provided in the specification.
func (x ExportMemoryAllocateInfo) WithDefaultSType() ExportMemoryAllocateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ExportMemoryAllocateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO)
}

// WithSType clones a new ExportMemoryAllocateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExportMemoryAllocateInfo) WithSType(y StructureType) ExportMemoryAllocateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ExportMemoryAllocateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkExportMemoryAllocateInfo
func (x ExportMemoryAllocateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ExportMemoryAllocateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExportMemoryAllocateInfo) WithPNext(y unsafe.Pointer) ExportMemoryAllocateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ExportMemoryAllocateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// HandleTypes returns the value of handleTypes from VkExportMemoryAllocateInfo
func (x ExportMemoryAllocateInfo) HandleTypes() ExternalMemoryHandleTypeFlags {
	ptr := /* typedef */ (*ExternalMemoryHandleTypeFlags)(&x.handleTypes)
	return *ptr
}

// WithHandleTypes clones a new ExportMemoryAllocateInfo with the value of
// HandleTypes updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExportMemoryAllocateInfo) WithHandleTypes(y ExternalMemoryHandleTypeFlags) ExportMemoryAllocateInfo {
	x.handleTypes = *( /* typedef */ (*C.VkExternalMemoryHandleTypeFlags)(&y))
	return x
}
func (x *ExportMemoryAllocateInfo) SetHandleTypes(y ExternalMemoryHandleTypeFlags) {
	x.handleTypes = *( /* typedef */ (*C.VkExternalMemoryHandleTypeFlags)(&y))
}

// ExportFenceCreateInfo provides a go interface for VkExportFenceCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportFenceCreateInfo.html
type ExportFenceCreateInfo C.struct_VkExportFenceCreateInfo

// SizeofExportFenceCreateInfo is the memory size of a ExportFenceCreateInfo
var SizeofExportFenceCreateInfo int = int(unsafe.Sizeof(ExportFenceCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ExportFenceCreateInfo) ArpPtr(arp *AutoReleasePool) *ExportFenceCreateInfo {
	ptr := newCBlock(cULong(SizeofExportFenceCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ExportFenceCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExportFenceCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExportFenceCreateInfo) AsCPtr() *ExportFenceCreateInfo {
	clone := (*ExportFenceCreateInfo)(newCBlock(cULong(SizeofExportFenceCreateInfo)))
	*clone = x
	return clone
}

// ExportFenceCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ExportFenceCreateInfoCSlice(arp *AutoReleasePool, x ...ExportFenceCreateInfo) []ExportFenceCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExportFenceCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ExportFenceCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ExportFenceCreateInfoFreeCSlice releases the memory allocated by ExportFenceCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ExportFenceCreateInfoFreeCSlice(x []ExportFenceCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExportFenceCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExportFenceCreateInfoFreeCSlice must be called on the returned slice.
func ExportFenceCreateInfoMakeCSlice(x ...ExportFenceCreateInfo) []ExportFenceCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExportFenceCreateInfo * len(x)
	dst := unsafe.Slice((*ExportFenceCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkExportFenceCreateInfo
func (x ExportFenceCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ExportFenceCreateInfo with the value of
// SType to the value provided in the specification.
func (x ExportFenceCreateInfo) WithDefaultSType() ExportFenceCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ExportFenceCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO)
}

// WithSType clones a new ExportFenceCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExportFenceCreateInfo) WithSType(y StructureType) ExportFenceCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ExportFenceCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkExportFenceCreateInfo
func (x ExportFenceCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ExportFenceCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExportFenceCreateInfo) WithPNext(y unsafe.Pointer) ExportFenceCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ExportFenceCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// HandleTypes returns the value of handleTypes from VkExportFenceCreateInfo
func (x ExportFenceCreateInfo) HandleTypes() ExternalFenceHandleTypeFlags {
	ptr := /* typedef */ (*ExternalFenceHandleTypeFlags)(&x.handleTypes)
	return *ptr
}

// WithHandleTypes clones a new ExportFenceCreateInfo with the value of
// HandleTypes updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExportFenceCreateInfo) WithHandleTypes(y ExternalFenceHandleTypeFlags) ExportFenceCreateInfo {
	x.handleTypes = *( /* typedef */ (*C.VkExternalFenceHandleTypeFlags)(&y))
	return x
}
func (x *ExportFenceCreateInfo) SetHandleTypes(y ExternalFenceHandleTypeFlags) {
	x.handleTypes = *( /* typedef */ (*C.VkExternalFenceHandleTypeFlags)(&y))
}

// PhysicalDevice16BitStorageFeatures provides a go interface for VkPhysicalDevice16BitStorageFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice16BitStorageFeatures.html
type PhysicalDevice16BitStorageFeatures C.struct_VkPhysicalDevice16BitStorageFeatures

// SizeofPhysicalDevice16BitStorageFeatures is the memory size of a PhysicalDevice16BitStorageFeatures
var SizeofPhysicalDevice16BitStorageFeatures int = int(unsafe.Sizeof(PhysicalDevice16BitStorageFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDevice16BitStorageFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDevice16BitStorageFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDevice16BitStorageFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDevice16BitStorageFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDevice16BitStorageFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDevice16BitStorageFeatures) AsCPtr() *PhysicalDevice16BitStorageFeatures {
	clone := (*PhysicalDevice16BitStorageFeatures)(newCBlock(cULong(SizeofPhysicalDevice16BitStorageFeatures)))
	*clone = x
	return clone
}

// PhysicalDevice16BitStorageFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDevice16BitStorageFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDevice16BitStorageFeatures) []PhysicalDevice16BitStorageFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDevice16BitStorageFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDevice16BitStorageFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDevice16BitStorageFeaturesFreeCSlice releases the memory allocated by PhysicalDevice16BitStorageFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDevice16BitStorageFeaturesFreeCSlice(x []PhysicalDevice16BitStorageFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDevice16BitStorageFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDevice16BitStorageFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDevice16BitStorageFeaturesMakeCSlice(x ...PhysicalDevice16BitStorageFeatures) []PhysicalDevice16BitStorageFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDevice16BitStorageFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDevice16BitStorageFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDevice16BitStorageFeatures
func (x PhysicalDevice16BitStorageFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDevice16BitStorageFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDevice16BitStorageFeatures) WithDefaultSType() PhysicalDevice16BitStorageFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDevice16BitStorageFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES)
}

// WithSType clones a new PhysicalDevice16BitStorageFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice16BitStorageFeatures) WithSType(y StructureType) PhysicalDevice16BitStorageFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDevice16BitStorageFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDevice16BitStorageFeatures
func (x PhysicalDevice16BitStorageFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDevice16BitStorageFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice16BitStorageFeatures) WithPNext(y unsafe.Pointer) PhysicalDevice16BitStorageFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDevice16BitStorageFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// StorageBuffer16BitAccess returns the value of storageBuffer16BitAccess from VkPhysicalDevice16BitStorageFeatures
func (x PhysicalDevice16BitStorageFeatures) StorageBuffer16BitAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storageBuffer16BitAccess)
	return *ptr
}

// WithStorageBuffer16BitAccess clones a new PhysicalDevice16BitStorageFeatures with the value of
// StorageBuffer16BitAccess updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice16BitStorageFeatures) WithStorageBuffer16BitAccess(y Bool32) PhysicalDevice16BitStorageFeatures {
	x.storageBuffer16BitAccess = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDevice16BitStorageFeatures) SetStorageBuffer16BitAccess(y Bool32) {
	x.storageBuffer16BitAccess = *( /* typedef */ (*C.VkBool32)(&y))
}

// UniformAndStorageBuffer16BitAccess returns the value of uniformAndStorageBuffer16BitAccess from VkPhysicalDevice16BitStorageFeatures
func (x PhysicalDevice16BitStorageFeatures) UniformAndStorageBuffer16BitAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.uniformAndStorageBuffer16BitAccess)
	return *ptr
}

// WithUniformAndStorageBuffer16BitAccess clones a new PhysicalDevice16BitStorageFeatures with the value of
// UniformAndStorageBuffer16BitAccess updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice16BitStorageFeatures) WithUniformAndStorageBuffer16BitAccess(y Bool32) PhysicalDevice16BitStorageFeatures {
	x.uniformAndStorageBuffer16BitAccess = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDevice16BitStorageFeatures) SetUniformAndStorageBuffer16BitAccess(y Bool32) {
	x.uniformAndStorageBuffer16BitAccess = *( /* typedef */ (*C.VkBool32)(&y))
}

// StoragePushConstant16 returns the value of storagePushConstant16 from VkPhysicalDevice16BitStorageFeatures
func (x PhysicalDevice16BitStorageFeatures) StoragePushConstant16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storagePushConstant16)
	return *ptr
}

// WithStoragePushConstant16 clones a new PhysicalDevice16BitStorageFeatures with the value of
// StoragePushConstant16 updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice16BitStorageFeatures) WithStoragePushConstant16(y Bool32) PhysicalDevice16BitStorageFeatures {
	x.storagePushConstant16 = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDevice16BitStorageFeatures) SetStoragePushConstant16(y Bool32) {
	x.storagePushConstant16 = *( /* typedef */ (*C.VkBool32)(&y))
}

// StorageInputOutput16 returns the value of storageInputOutput16 from VkPhysicalDevice16BitStorageFeatures
func (x PhysicalDevice16BitStorageFeatures) StorageInputOutput16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storageInputOutput16)
	return *ptr
}

// WithStorageInputOutput16 clones a new PhysicalDevice16BitStorageFeatures with the value of
// StorageInputOutput16 updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice16BitStorageFeatures) WithStorageInputOutput16(y Bool32) PhysicalDevice16BitStorageFeatures {
	x.storageInputOutput16 = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDevice16BitStorageFeatures) SetStorageInputOutput16(y Bool32) {
	x.storageInputOutput16 = *( /* typedef */ (*C.VkBool32)(&y))
}

// PhysicalDeviceMaintenance3Properties provides a go interface for VkPhysicalDeviceMaintenance3Properties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance3Properties.html
type PhysicalDeviceMaintenance3Properties C.struct_VkPhysicalDeviceMaintenance3Properties

// SizeofPhysicalDeviceMaintenance3Properties is the memory size of a PhysicalDeviceMaintenance3Properties
var SizeofPhysicalDeviceMaintenance3Properties int = int(unsafe.Sizeof(PhysicalDeviceMaintenance3Properties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceMaintenance3Properties) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceMaintenance3Properties {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceMaintenance3Properties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceMaintenance3Properties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceMaintenance3Properties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceMaintenance3Properties) AsCPtr() *PhysicalDeviceMaintenance3Properties {
	clone := (*PhysicalDeviceMaintenance3Properties)(newCBlock(cULong(SizeofPhysicalDeviceMaintenance3Properties)))
	*clone = x
	return clone
}

// PhysicalDeviceMaintenance3PropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceMaintenance3PropertiesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceMaintenance3Properties) []PhysicalDeviceMaintenance3Properties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceMaintenance3Properties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceMaintenance3Properties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceMaintenance3PropertiesFreeCSlice releases the memory allocated by PhysicalDeviceMaintenance3PropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceMaintenance3PropertiesFreeCSlice(x []PhysicalDeviceMaintenance3Properties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceMaintenance3PropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceMaintenance3PropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceMaintenance3PropertiesMakeCSlice(x ...PhysicalDeviceMaintenance3Properties) []PhysicalDeviceMaintenance3Properties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceMaintenance3Properties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceMaintenance3Properties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceMaintenance3Properties
func (x PhysicalDeviceMaintenance3Properties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceMaintenance3Properties with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceMaintenance3Properties) WithDefaultSType() PhysicalDeviceMaintenance3Properties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceMaintenance3Properties) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES)
}

// WithSType clones a new PhysicalDeviceMaintenance3Properties with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMaintenance3Properties) WithSType(y StructureType) PhysicalDeviceMaintenance3Properties {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceMaintenance3Properties) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceMaintenance3Properties
func (x PhysicalDeviceMaintenance3Properties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceMaintenance3Properties with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMaintenance3Properties) WithPNext(y unsafe.Pointer) PhysicalDeviceMaintenance3Properties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceMaintenance3Properties) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// MaxPerSetDescriptors returns the value of maxPerSetDescriptors from VkPhysicalDeviceMaintenance3Properties
func (x PhysicalDeviceMaintenance3Properties) MaxPerSetDescriptors() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerSetDescriptors)
	return *ptr
}

// MaxMemoryAllocationSize returns the value of maxMemoryAllocationSize from VkPhysicalDeviceMaintenance3Properties
func (x PhysicalDeviceMaintenance3Properties) MaxMemoryAllocationSize() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.maxMemoryAllocationSize)
	return *ptr
}

// DeviceGroupSubmitInfo provides a go interface for VkDeviceGroupSubmitInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupSubmitInfo.html
type DeviceGroupSubmitInfo C.struct_VkDeviceGroupSubmitInfo

// SizeofDeviceGroupSubmitInfo is the memory size of a DeviceGroupSubmitInfo
var SizeofDeviceGroupSubmitInfo int = int(unsafe.Sizeof(DeviceGroupSubmitInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DeviceGroupSubmitInfo) ArpPtr(arp *AutoReleasePool) *DeviceGroupSubmitInfo {
	ptr := newCBlock(cULong(SizeofDeviceGroupSubmitInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DeviceGroupSubmitInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceGroupSubmitInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceGroupSubmitInfo) AsCPtr() *DeviceGroupSubmitInfo {
	clone := (*DeviceGroupSubmitInfo)(newCBlock(cULong(SizeofDeviceGroupSubmitInfo)))
	*clone = x
	return clone
}

// DeviceGroupSubmitInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DeviceGroupSubmitInfoCSlice(arp *AutoReleasePool, x ...DeviceGroupSubmitInfo) []DeviceGroupSubmitInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupSubmitInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DeviceGroupSubmitInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DeviceGroupSubmitInfoFreeCSlice releases the memory allocated by DeviceGroupSubmitInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceGroupSubmitInfoFreeCSlice(x []DeviceGroupSubmitInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceGroupSubmitInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceGroupSubmitInfoFreeCSlice must be called on the returned slice.
func DeviceGroupSubmitInfoMakeCSlice(x ...DeviceGroupSubmitInfo) []DeviceGroupSubmitInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupSubmitInfo * len(x)
	dst := unsafe.Slice((*DeviceGroupSubmitInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceGroupSubmitInfo
func (x DeviceGroupSubmitInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DeviceGroupSubmitInfo with the value of
// SType to the value provided in the specification.
func (x DeviceGroupSubmitInfo) WithDefaultSType() DeviceGroupSubmitInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DeviceGroupSubmitInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO)
}

// WithSType clones a new DeviceGroupSubmitInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupSubmitInfo) WithSType(y StructureType) DeviceGroupSubmitInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DeviceGroupSubmitInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDeviceGroupSubmitInfo
func (x DeviceGroupSubmitInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DeviceGroupSubmitInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupSubmitInfo) WithPNext(y unsafe.Pointer) DeviceGroupSubmitInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DeviceGroupSubmitInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// WaitSemaphoreCount returns the value of waitSemaphoreCount from VkDeviceGroupSubmitInfo
func (x DeviceGroupSubmitInfo) WaitSemaphoreCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.waitSemaphoreCount)
	return *ptr
}

// WithWaitSemaphoreCount clones a new DeviceGroupSubmitInfo with the value of
// WaitSemaphoreCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupSubmitInfo) WithWaitSemaphoreCount(y uint32) DeviceGroupSubmitInfo {
	x.waitSemaphoreCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DeviceGroupSubmitInfo) SetWaitSemaphoreCount(y uint32) {
	x.waitSemaphoreCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PWaitSemaphoreDeviceIndices returns the value of pWaitSemaphoreDeviceIndices from VkDeviceGroupSubmitInfo
func (x DeviceGroupSubmitInfo) PWaitSemaphoreDeviceIndices() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pWaitSemaphoreDeviceIndices)
	return *ptr
}

// WithPWaitSemaphoreDeviceIndices clones a new DeviceGroupSubmitInfo with the value of
// PWaitSemaphoreDeviceIndices updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines WaitSemaphoreCount as the length of this field.
// WaitSemaphoreCount is updated with the length of the new value.
func (x DeviceGroupSubmitInfo) WithPWaitSemaphoreDeviceIndices(y []uint32) DeviceGroupSubmitInfo {
	x.pWaitSemaphoreDeviceIndices = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithWaitSemaphoreCount(uint32(len(y)))
}
func (x *DeviceGroupSubmitInfo) SetPWaitSemaphoreDeviceIndices(y []uint32) {
	x.pWaitSemaphoreDeviceIndices = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetWaitSemaphoreCount(uint32(len(y)))
}

// CommandBufferCount returns the value of commandBufferCount from VkDeviceGroupSubmitInfo
func (x DeviceGroupSubmitInfo) CommandBufferCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.commandBufferCount)
	return *ptr
}

// WithCommandBufferCount clones a new DeviceGroupSubmitInfo with the value of
// CommandBufferCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupSubmitInfo) WithCommandBufferCount(y uint32) DeviceGroupSubmitInfo {
	x.commandBufferCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DeviceGroupSubmitInfo) SetCommandBufferCount(y uint32) {
	x.commandBufferCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PCommandBufferDeviceMasks returns the value of pCommandBufferDeviceMasks from VkDeviceGroupSubmitInfo
func (x DeviceGroupSubmitInfo) PCommandBufferDeviceMasks() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pCommandBufferDeviceMasks)
	return *ptr
}

// WithPCommandBufferDeviceMasks clones a new DeviceGroupSubmitInfo with the value of
// PCommandBufferDeviceMasks updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines CommandBufferCount as the length of this field.
// CommandBufferCount is updated with the length of the new value.
func (x DeviceGroupSubmitInfo) WithPCommandBufferDeviceMasks(y []uint32) DeviceGroupSubmitInfo {
	x.pCommandBufferDeviceMasks = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithCommandBufferCount(uint32(len(y)))
}
func (x *DeviceGroupSubmitInfo) SetPCommandBufferDeviceMasks(y []uint32) {
	x.pCommandBufferDeviceMasks = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetCommandBufferCount(uint32(len(y)))
}

// SignalSemaphoreCount returns the value of signalSemaphoreCount from VkDeviceGroupSubmitInfo
func (x DeviceGroupSubmitInfo) SignalSemaphoreCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.signalSemaphoreCount)
	return *ptr
}

// WithSignalSemaphoreCount clones a new DeviceGroupSubmitInfo with the value of
// SignalSemaphoreCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupSubmitInfo) WithSignalSemaphoreCount(y uint32) DeviceGroupSubmitInfo {
	x.signalSemaphoreCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DeviceGroupSubmitInfo) SetSignalSemaphoreCount(y uint32) {
	x.signalSemaphoreCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PSignalSemaphoreDeviceIndices returns the value of pSignalSemaphoreDeviceIndices from VkDeviceGroupSubmitInfo
func (x DeviceGroupSubmitInfo) PSignalSemaphoreDeviceIndices() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pSignalSemaphoreDeviceIndices)
	return *ptr
}

// WithPSignalSemaphoreDeviceIndices clones a new DeviceGroupSubmitInfo with the value of
// PSignalSemaphoreDeviceIndices updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SignalSemaphoreCount as the length of this field.
// SignalSemaphoreCount is updated with the length of the new value.
func (x DeviceGroupSubmitInfo) WithPSignalSemaphoreDeviceIndices(y []uint32) DeviceGroupSubmitInfo {
	x.pSignalSemaphoreDeviceIndices = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithSignalSemaphoreCount(uint32(len(y)))
}
func (x *DeviceGroupSubmitInfo) SetPSignalSemaphoreDeviceIndices(y []uint32) {
	x.pSignalSemaphoreDeviceIndices = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetSignalSemaphoreCount(uint32(len(y)))
}

// DeviceGroupCommandBufferBeginInfo provides a go interface for VkDeviceGroupCommandBufferBeginInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupCommandBufferBeginInfo.html
type DeviceGroupCommandBufferBeginInfo C.struct_VkDeviceGroupCommandBufferBeginInfo

// SizeofDeviceGroupCommandBufferBeginInfo is the memory size of a DeviceGroupCommandBufferBeginInfo
var SizeofDeviceGroupCommandBufferBeginInfo int = int(unsafe.Sizeof(DeviceGroupCommandBufferBeginInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DeviceGroupCommandBufferBeginInfo) ArpPtr(arp *AutoReleasePool) *DeviceGroupCommandBufferBeginInfo {
	ptr := newCBlock(cULong(SizeofDeviceGroupCommandBufferBeginInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DeviceGroupCommandBufferBeginInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceGroupCommandBufferBeginInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceGroupCommandBufferBeginInfo) AsCPtr() *DeviceGroupCommandBufferBeginInfo {
	clone := (*DeviceGroupCommandBufferBeginInfo)(newCBlock(cULong(SizeofDeviceGroupCommandBufferBeginInfo)))
	*clone = x
	return clone
}

// DeviceGroupCommandBufferBeginInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DeviceGroupCommandBufferBeginInfoCSlice(arp *AutoReleasePool, x ...DeviceGroupCommandBufferBeginInfo) []DeviceGroupCommandBufferBeginInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupCommandBufferBeginInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DeviceGroupCommandBufferBeginInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DeviceGroupCommandBufferBeginInfoFreeCSlice releases the memory allocated by DeviceGroupCommandBufferBeginInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceGroupCommandBufferBeginInfoFreeCSlice(x []DeviceGroupCommandBufferBeginInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceGroupCommandBufferBeginInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceGroupCommandBufferBeginInfoFreeCSlice must be called on the returned slice.
func DeviceGroupCommandBufferBeginInfoMakeCSlice(x ...DeviceGroupCommandBufferBeginInfo) []DeviceGroupCommandBufferBeginInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupCommandBufferBeginInfo * len(x)
	dst := unsafe.Slice((*DeviceGroupCommandBufferBeginInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceGroupCommandBufferBeginInfo
func (x DeviceGroupCommandBufferBeginInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DeviceGroupCommandBufferBeginInfo with the value of
// SType to the value provided in the specification.
func (x DeviceGroupCommandBufferBeginInfo) WithDefaultSType() DeviceGroupCommandBufferBeginInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DeviceGroupCommandBufferBeginInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO)
}

// WithSType clones a new DeviceGroupCommandBufferBeginInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupCommandBufferBeginInfo) WithSType(y StructureType) DeviceGroupCommandBufferBeginInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DeviceGroupCommandBufferBeginInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDeviceGroupCommandBufferBeginInfo
func (x DeviceGroupCommandBufferBeginInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DeviceGroupCommandBufferBeginInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupCommandBufferBeginInfo) WithPNext(y unsafe.Pointer) DeviceGroupCommandBufferBeginInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DeviceGroupCommandBufferBeginInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// DeviceMask returns the value of deviceMask from VkDeviceGroupCommandBufferBeginInfo
func (x DeviceGroupCommandBufferBeginInfo) DeviceMask() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.deviceMask)
	return *ptr
}

// WithDeviceMask clones a new DeviceGroupCommandBufferBeginInfo with the value of
// DeviceMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupCommandBufferBeginInfo) WithDeviceMask(y uint32) DeviceGroupCommandBufferBeginInfo {
	x.deviceMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DeviceGroupCommandBufferBeginInfo) SetDeviceMask(y uint32) {
	x.deviceMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// BufferMemoryRequirementsInfo2 provides a go interface for VkBufferMemoryRequirementsInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferMemoryRequirementsInfo2.html
type BufferMemoryRequirementsInfo2 C.struct_VkBufferMemoryRequirementsInfo2

// SizeofBufferMemoryRequirementsInfo2 is the memory size of a BufferMemoryRequirementsInfo2
var SizeofBufferMemoryRequirementsInfo2 int = int(unsafe.Sizeof(BufferMemoryRequirementsInfo2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x BufferMemoryRequirementsInfo2) ArpPtr(arp *AutoReleasePool) *BufferMemoryRequirementsInfo2 {
	ptr := newCBlock(cULong(SizeofBufferMemoryRequirementsInfo2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*BufferMemoryRequirementsInfo2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferMemoryRequirementsInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferMemoryRequirementsInfo2) AsCPtr() *BufferMemoryRequirementsInfo2 {
	clone := (*BufferMemoryRequirementsInfo2)(newCBlock(cULong(SizeofBufferMemoryRequirementsInfo2)))
	*clone = x
	return clone
}

// BufferMemoryRequirementsInfo2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func BufferMemoryRequirementsInfo2CSlice(arp *AutoReleasePool, x ...BufferMemoryRequirementsInfo2) []BufferMemoryRequirementsInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferMemoryRequirementsInfo2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*BufferMemoryRequirementsInfo2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// BufferMemoryRequirementsInfo2FreeCSlice releases the memory allocated by BufferMemoryRequirementsInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func BufferMemoryRequirementsInfo2FreeCSlice(x []BufferMemoryRequirementsInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferMemoryRequirementsInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferMemoryRequirementsInfo2FreeCSlice must be called on the returned slice.
func BufferMemoryRequirementsInfo2MakeCSlice(x ...BufferMemoryRequirementsInfo2) []BufferMemoryRequirementsInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferMemoryRequirementsInfo2 * len(x)
	dst := unsafe.Slice((*BufferMemoryRequirementsInfo2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBufferMemoryRequirementsInfo2
func (x BufferMemoryRequirementsInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new BufferMemoryRequirementsInfo2 with the value of
// SType to the value provided in the specification.
func (x BufferMemoryRequirementsInfo2) WithDefaultSType() BufferMemoryRequirementsInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *BufferMemoryRequirementsInfo2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2)
}

// WithSType clones a new BufferMemoryRequirementsInfo2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryRequirementsInfo2) WithSType(y StructureType) BufferMemoryRequirementsInfo2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *BufferMemoryRequirementsInfo2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkBufferMemoryRequirementsInfo2
func (x BufferMemoryRequirementsInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new BufferMemoryRequirementsInfo2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryRequirementsInfo2) WithPNext(y unsafe.Pointer) BufferMemoryRequirementsInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *BufferMemoryRequirementsInfo2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Buffer returns the value of buffer from VkBufferMemoryRequirementsInfo2
func (x BufferMemoryRequirementsInfo2) Buffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.buffer)
	return *ptr
}

// WithBuffer clones a new BufferMemoryRequirementsInfo2 with the value of
// Buffer updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryRequirementsInfo2) WithBuffer(y Buffer) BufferMemoryRequirementsInfo2 {
	x.buffer = *( /* handle */ (*C.VkBuffer)(&y))
	return x
}
func (x *BufferMemoryRequirementsInfo2) SetBuffer(y Buffer) {
	x.buffer = *( /* handle */ (*C.VkBuffer)(&y))
}

// ImageMemoryRequirementsInfo2 provides a go interface for VkImageMemoryRequirementsInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageMemoryRequirementsInfo2.html
type ImageMemoryRequirementsInfo2 C.struct_VkImageMemoryRequirementsInfo2

// SizeofImageMemoryRequirementsInfo2 is the memory size of a ImageMemoryRequirementsInfo2
var SizeofImageMemoryRequirementsInfo2 int = int(unsafe.Sizeof(ImageMemoryRequirementsInfo2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ImageMemoryRequirementsInfo2) ArpPtr(arp *AutoReleasePool) *ImageMemoryRequirementsInfo2 {
	ptr := newCBlock(cULong(SizeofImageMemoryRequirementsInfo2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ImageMemoryRequirementsInfo2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageMemoryRequirementsInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageMemoryRequirementsInfo2) AsCPtr() *ImageMemoryRequirementsInfo2 {
	clone := (*ImageMemoryRequirementsInfo2)(newCBlock(cULong(SizeofImageMemoryRequirementsInfo2)))
	*clone = x
	return clone
}

// ImageMemoryRequirementsInfo2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ImageMemoryRequirementsInfo2CSlice(arp *AutoReleasePool, x ...ImageMemoryRequirementsInfo2) []ImageMemoryRequirementsInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageMemoryRequirementsInfo2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ImageMemoryRequirementsInfo2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ImageMemoryRequirementsInfo2FreeCSlice releases the memory allocated by ImageMemoryRequirementsInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func ImageMemoryRequirementsInfo2FreeCSlice(x []ImageMemoryRequirementsInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageMemoryRequirementsInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageMemoryRequirementsInfo2FreeCSlice must be called on the returned slice.
func ImageMemoryRequirementsInfo2MakeCSlice(x ...ImageMemoryRequirementsInfo2) []ImageMemoryRequirementsInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageMemoryRequirementsInfo2 * len(x)
	dst := unsafe.Slice((*ImageMemoryRequirementsInfo2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageMemoryRequirementsInfo2
func (x ImageMemoryRequirementsInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ImageMemoryRequirementsInfo2 with the value of
// SType to the value provided in the specification.
func (x ImageMemoryRequirementsInfo2) WithDefaultSType() ImageMemoryRequirementsInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ImageMemoryRequirementsInfo2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2)
}

// WithSType clones a new ImageMemoryRequirementsInfo2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryRequirementsInfo2) WithSType(y StructureType) ImageMemoryRequirementsInfo2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ImageMemoryRequirementsInfo2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkImageMemoryRequirementsInfo2
func (x ImageMemoryRequirementsInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ImageMemoryRequirementsInfo2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryRequirementsInfo2) WithPNext(y unsafe.Pointer) ImageMemoryRequirementsInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ImageMemoryRequirementsInfo2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Image returns the value of image from VkImageMemoryRequirementsInfo2
func (x ImageMemoryRequirementsInfo2) Image() Image {
	ptr := /* handle */ (*Image)(&x.image)
	return *ptr
}

// WithImage clones a new ImageMemoryRequirementsInfo2 with the value of
// Image updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryRequirementsInfo2) WithImage(y Image) ImageMemoryRequirementsInfo2 {
	x.image = *( /* handle */ (*C.VkImage)(&y))
	return x
}
func (x *ImageMemoryRequirementsInfo2) SetImage(y Image) {
	x.image = *( /* handle */ (*C.VkImage)(&y))
}

// ImageSparseMemoryRequirementsInfo2 provides a go interface for VkImageSparseMemoryRequirementsInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSparseMemoryRequirementsInfo2.html
type ImageSparseMemoryRequirementsInfo2 C.struct_VkImageSparseMemoryRequirementsInfo2

// SizeofImageSparseMemoryRequirementsInfo2 is the memory size of a ImageSparseMemoryRequirementsInfo2
var SizeofImageSparseMemoryRequirementsInfo2 int = int(unsafe.Sizeof(ImageSparseMemoryRequirementsInfo2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ImageSparseMemoryRequirementsInfo2) ArpPtr(arp *AutoReleasePool) *ImageSparseMemoryRequirementsInfo2 {
	ptr := newCBlock(cULong(SizeofImageSparseMemoryRequirementsInfo2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ImageSparseMemoryRequirementsInfo2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageSparseMemoryRequirementsInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageSparseMemoryRequirementsInfo2) AsCPtr() *ImageSparseMemoryRequirementsInfo2 {
	clone := (*ImageSparseMemoryRequirementsInfo2)(newCBlock(cULong(SizeofImageSparseMemoryRequirementsInfo2)))
	*clone = x
	return clone
}

// ImageSparseMemoryRequirementsInfo2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ImageSparseMemoryRequirementsInfo2CSlice(arp *AutoReleasePool, x ...ImageSparseMemoryRequirementsInfo2) []ImageSparseMemoryRequirementsInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageSparseMemoryRequirementsInfo2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ImageSparseMemoryRequirementsInfo2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ImageSparseMemoryRequirementsInfo2FreeCSlice releases the memory allocated by ImageSparseMemoryRequirementsInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func ImageSparseMemoryRequirementsInfo2FreeCSlice(x []ImageSparseMemoryRequirementsInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageSparseMemoryRequirementsInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageSparseMemoryRequirementsInfo2FreeCSlice must be called on the returned slice.
func ImageSparseMemoryRequirementsInfo2MakeCSlice(x ...ImageSparseMemoryRequirementsInfo2) []ImageSparseMemoryRequirementsInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageSparseMemoryRequirementsInfo2 * len(x)
	dst := unsafe.Slice((*ImageSparseMemoryRequirementsInfo2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageSparseMemoryRequirementsInfo2
func (x ImageSparseMemoryRequirementsInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ImageSparseMemoryRequirementsInfo2 with the value of
// SType to the value provided in the specification.
func (x ImageSparseMemoryRequirementsInfo2) WithDefaultSType() ImageSparseMemoryRequirementsInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ImageSparseMemoryRequirementsInfo2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2)
}

// WithSType clones a new ImageSparseMemoryRequirementsInfo2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSparseMemoryRequirementsInfo2) WithSType(y StructureType) ImageSparseMemoryRequirementsInfo2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ImageSparseMemoryRequirementsInfo2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkImageSparseMemoryRequirementsInfo2
func (x ImageSparseMemoryRequirementsInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ImageSparseMemoryRequirementsInfo2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSparseMemoryRequirementsInfo2) WithPNext(y unsafe.Pointer) ImageSparseMemoryRequirementsInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ImageSparseMemoryRequirementsInfo2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Image returns the value of image from VkImageSparseMemoryRequirementsInfo2
func (x ImageSparseMemoryRequirementsInfo2) Image() Image {
	ptr := /* handle */ (*Image)(&x.image)
	return *ptr
}

// WithImage clones a new ImageSparseMemoryRequirementsInfo2 with the value of
// Image updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSparseMemoryRequirementsInfo2) WithImage(y Image) ImageSparseMemoryRequirementsInfo2 {
	x.image = *( /* handle */ (*C.VkImage)(&y))
	return x
}
func (x *ImageSparseMemoryRequirementsInfo2) SetImage(y Image) {
	x.image = *( /* handle */ (*C.VkImage)(&y))
}

// MemoryRequirements2 provides a go interface for VkMemoryRequirements2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryRequirements2.html
type MemoryRequirements2 C.struct_VkMemoryRequirements2

// SizeofMemoryRequirements2 is the memory size of a MemoryRequirements2
var SizeofMemoryRequirements2 int = int(unsafe.Sizeof(MemoryRequirements2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x MemoryRequirements2) ArpPtr(arp *AutoReleasePool) *MemoryRequirements2 {
	ptr := newCBlock(cULong(SizeofMemoryRequirements2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*MemoryRequirements2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryRequirements2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryRequirements2) AsCPtr() *MemoryRequirements2 {
	clone := (*MemoryRequirements2)(newCBlock(cULong(SizeofMemoryRequirements2)))
	*clone = x
	return clone
}

// MemoryRequirements2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func MemoryRequirements2CSlice(arp *AutoReleasePool, x ...MemoryRequirements2) []MemoryRequirements2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryRequirements2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*MemoryRequirements2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// MemoryRequirements2FreeCSlice releases the memory allocated by MemoryRequirements2MakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryRequirements2FreeCSlice(x []MemoryRequirements2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryRequirements2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryRequirements2FreeCSlice must be called on the returned slice.
func MemoryRequirements2MakeCSlice(x ...MemoryRequirements2) []MemoryRequirements2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryRequirements2 * len(x)
	dst := unsafe.Slice((*MemoryRequirements2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkMemoryRequirements2
func (x MemoryRequirements2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new MemoryRequirements2 with the value of
// SType to the value provided in the specification.
func (x MemoryRequirements2) WithDefaultSType() MemoryRequirements2 {
	return x.WithSType(VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *MemoryRequirements2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2)
}

// WithSType clones a new MemoryRequirements2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryRequirements2) WithSType(y StructureType) MemoryRequirements2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *MemoryRequirements2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkMemoryRequirements2
func (x MemoryRequirements2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new MemoryRequirements2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryRequirements2) WithPNext(y unsafe.Pointer) MemoryRequirements2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *MemoryRequirements2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// MemoryRequirements returns the value of memoryRequirements from VkMemoryRequirements2
func (x MemoryRequirements2) MemoryRequirements() MemoryRequirements {
	ptr := /* typedef */ (*MemoryRequirements)(&x.memoryRequirements)
	return *ptr
}

// SparseImageMemoryRequirements2 provides a go interface for VkSparseImageMemoryRequirements2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageMemoryRequirements2.html
type SparseImageMemoryRequirements2 C.struct_VkSparseImageMemoryRequirements2

// SizeofSparseImageMemoryRequirements2 is the memory size of a SparseImageMemoryRequirements2
var SizeofSparseImageMemoryRequirements2 int = int(unsafe.Sizeof(SparseImageMemoryRequirements2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SparseImageMemoryRequirements2) ArpPtr(arp *AutoReleasePool) *SparseImageMemoryRequirements2 {
	ptr := newCBlock(cULong(SizeofSparseImageMemoryRequirements2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SparseImageMemoryRequirements2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SparseImageMemoryRequirements2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SparseImageMemoryRequirements2) AsCPtr() *SparseImageMemoryRequirements2 {
	clone := (*SparseImageMemoryRequirements2)(newCBlock(cULong(SizeofSparseImageMemoryRequirements2)))
	*clone = x
	return clone
}

// SparseImageMemoryRequirements2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SparseImageMemoryRequirements2CSlice(arp *AutoReleasePool, x ...SparseImageMemoryRequirements2) []SparseImageMemoryRequirements2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageMemoryRequirements2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SparseImageMemoryRequirements2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SparseImageMemoryRequirements2FreeCSlice releases the memory allocated by SparseImageMemoryRequirements2MakeCSlice.
// It does not free pointers stored inside the slice.
func SparseImageMemoryRequirements2FreeCSlice(x []SparseImageMemoryRequirements2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SparseImageMemoryRequirements2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SparseImageMemoryRequirements2FreeCSlice must be called on the returned slice.
func SparseImageMemoryRequirements2MakeCSlice(x ...SparseImageMemoryRequirements2) []SparseImageMemoryRequirements2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageMemoryRequirements2 * len(x)
	dst := unsafe.Slice((*SparseImageMemoryRequirements2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSparseImageMemoryRequirements2
func (x SparseImageMemoryRequirements2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new SparseImageMemoryRequirements2 with the value of
// SType to the value provided in the specification.
func (x SparseImageMemoryRequirements2) WithDefaultSType() SparseImageMemoryRequirements2 {
	return x.WithSType(VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *SparseImageMemoryRequirements2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2)
}

// WithSType clones a new SparseImageMemoryRequirements2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryRequirements2) WithSType(y StructureType) SparseImageMemoryRequirements2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *SparseImageMemoryRequirements2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkSparseImageMemoryRequirements2
func (x SparseImageMemoryRequirements2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new SparseImageMemoryRequirements2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryRequirements2) WithPNext(y unsafe.Pointer) SparseImageMemoryRequirements2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *SparseImageMemoryRequirements2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// MemoryRequirements returns the value of memoryRequirements from VkSparseImageMemoryRequirements2
func (x SparseImageMemoryRequirements2) MemoryRequirements() SparseImageMemoryRequirements {
	ptr := /* typedef */ (*SparseImageMemoryRequirements)(&x.memoryRequirements)
	return *ptr
}

// BindImageMemoryInfo provides a go interface for VkBindImageMemoryInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindImageMemoryInfo.html
type BindImageMemoryInfo C.struct_VkBindImageMemoryInfo

// SizeofBindImageMemoryInfo is the memory size of a BindImageMemoryInfo
var SizeofBindImageMemoryInfo int = int(unsafe.Sizeof(BindImageMemoryInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x BindImageMemoryInfo) ArpPtr(arp *AutoReleasePool) *BindImageMemoryInfo {
	ptr := newCBlock(cULong(SizeofBindImageMemoryInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*BindImageMemoryInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BindImageMemoryInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BindImageMemoryInfo) AsCPtr() *BindImageMemoryInfo {
	clone := (*BindImageMemoryInfo)(newCBlock(cULong(SizeofBindImageMemoryInfo)))
	*clone = x
	return clone
}

// BindImageMemoryInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func BindImageMemoryInfoCSlice(arp *AutoReleasePool, x ...BindImageMemoryInfo) []BindImageMemoryInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindImageMemoryInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*BindImageMemoryInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// BindImageMemoryInfoFreeCSlice releases the memory allocated by BindImageMemoryInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BindImageMemoryInfoFreeCSlice(x []BindImageMemoryInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BindImageMemoryInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BindImageMemoryInfoFreeCSlice must be called on the returned slice.
func BindImageMemoryInfoMakeCSlice(x ...BindImageMemoryInfo) []BindImageMemoryInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindImageMemoryInfo * len(x)
	dst := unsafe.Slice((*BindImageMemoryInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBindImageMemoryInfo
func (x BindImageMemoryInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new BindImageMemoryInfo with the value of
// SType to the value provided in the specification.
func (x BindImageMemoryInfo) WithDefaultSType() BindImageMemoryInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *BindImageMemoryInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO)
}

// WithSType clones a new BindImageMemoryInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemoryInfo) WithSType(y StructureType) BindImageMemoryInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *BindImageMemoryInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkBindImageMemoryInfo
func (x BindImageMemoryInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new BindImageMemoryInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemoryInfo) WithPNext(y unsafe.Pointer) BindImageMemoryInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *BindImageMemoryInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Image returns the value of image from VkBindImageMemoryInfo
func (x BindImageMemoryInfo) Image() Image {
	ptr := /* handle */ (*Image)(&x.image)
	return *ptr
}

// WithImage clones a new BindImageMemoryInfo with the value of
// Image updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemoryInfo) WithImage(y Image) BindImageMemoryInfo {
	x.image = *( /* handle */ (*C.VkImage)(&y))
	return x
}
func (x *BindImageMemoryInfo) SetImage(y Image) {
	x.image = *( /* handle */ (*C.VkImage)(&y))
}

// Memory returns the value of memory from VkBindImageMemoryInfo
func (x BindImageMemoryInfo) Memory() DeviceMemory {
	ptr := /* handle */ (*DeviceMemory)(&x.memory)
	return *ptr
}

// WithMemory clones a new BindImageMemoryInfo with the value of
// Memory updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemoryInfo) WithMemory(y DeviceMemory) BindImageMemoryInfo {
	x.memory = *( /* handle */ (*C.VkDeviceMemory)(&y))
	return x
}
func (x *BindImageMemoryInfo) SetMemory(y DeviceMemory) {
	x.memory = *( /* handle */ (*C.VkDeviceMemory)(&y))
}

// MemoryOffset returns the value of memoryOffset from VkBindImageMemoryInfo
func (x BindImageMemoryInfo) MemoryOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.memoryOffset)
	return *ptr
}

// WithMemoryOffset clones a new BindImageMemoryInfo with the value of
// MemoryOffset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemoryInfo) WithMemoryOffset(y DeviceSize) BindImageMemoryInfo {
	x.memoryOffset = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *BindImageMemoryInfo) SetMemoryOffset(y DeviceSize) {
	x.memoryOffset = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// PhysicalDeviceExternalBufferInfo provides a go interface for VkPhysicalDeviceExternalBufferInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalBufferInfo.html
type PhysicalDeviceExternalBufferInfo C.struct_VkPhysicalDeviceExternalBufferInfo

// SizeofPhysicalDeviceExternalBufferInfo is the memory size of a PhysicalDeviceExternalBufferInfo
var SizeofPhysicalDeviceExternalBufferInfo int = int(unsafe.Sizeof(PhysicalDeviceExternalBufferInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceExternalBufferInfo) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceExternalBufferInfo {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceExternalBufferInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceExternalBufferInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceExternalBufferInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceExternalBufferInfo) AsCPtr() *PhysicalDeviceExternalBufferInfo {
	clone := (*PhysicalDeviceExternalBufferInfo)(newCBlock(cULong(SizeofPhysicalDeviceExternalBufferInfo)))
	*clone = x
	return clone
}

// PhysicalDeviceExternalBufferInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceExternalBufferInfoCSlice(arp *AutoReleasePool, x ...PhysicalDeviceExternalBufferInfo) []PhysicalDeviceExternalBufferInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceExternalBufferInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceExternalBufferInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceExternalBufferInfoFreeCSlice releases the memory allocated by PhysicalDeviceExternalBufferInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceExternalBufferInfoFreeCSlice(x []PhysicalDeviceExternalBufferInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceExternalBufferInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceExternalBufferInfoFreeCSlice must be called on the returned slice.
func PhysicalDeviceExternalBufferInfoMakeCSlice(x ...PhysicalDeviceExternalBufferInfo) []PhysicalDeviceExternalBufferInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceExternalBufferInfo * len(x)
	dst := unsafe.Slice((*PhysicalDeviceExternalBufferInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceExternalBufferInfo
func (x PhysicalDeviceExternalBufferInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceExternalBufferInfo with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceExternalBufferInfo) WithDefaultSType() PhysicalDeviceExternalBufferInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceExternalBufferInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO)
}

// WithSType clones a new PhysicalDeviceExternalBufferInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalBufferInfo) WithSType(y StructureType) PhysicalDeviceExternalBufferInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceExternalBufferInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceExternalBufferInfo
func (x PhysicalDeviceExternalBufferInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceExternalBufferInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalBufferInfo) WithPNext(y unsafe.Pointer) PhysicalDeviceExternalBufferInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceExternalBufferInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkPhysicalDeviceExternalBufferInfo
func (x PhysicalDeviceExternalBufferInfo) Flags() BufferCreateFlags {
	ptr := /* typedef */ (*BufferCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new PhysicalDeviceExternalBufferInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalBufferInfo) WithFlags(y BufferCreateFlags) PhysicalDeviceExternalBufferInfo {
	x.flags = *( /* typedef */ (*C.VkBufferCreateFlags)(&y))
	return x
}
func (x *PhysicalDeviceExternalBufferInfo) SetFlags(y BufferCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkBufferCreateFlags)(&y))
}

// Usage returns the value of usage from VkPhysicalDeviceExternalBufferInfo
func (x PhysicalDeviceExternalBufferInfo) Usage() BufferUsageFlags {
	ptr := /* typedef */ (*BufferUsageFlags)(&x.usage)
	return *ptr
}

// WithUsage clones a new PhysicalDeviceExternalBufferInfo with the value of
// Usage updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalBufferInfo) WithUsage(y BufferUsageFlags) PhysicalDeviceExternalBufferInfo {
	x.usage = *( /* typedef */ (*C.VkBufferUsageFlags)(&y))
	return x
}
func (x *PhysicalDeviceExternalBufferInfo) SetUsage(y BufferUsageFlags) {
	x.usage = *( /* typedef */ (*C.VkBufferUsageFlags)(&y))
}

// HandleType returns the value of handleType from VkPhysicalDeviceExternalBufferInfo
func (x PhysicalDeviceExternalBufferInfo) HandleType() ExternalMemoryHandleTypeFlagBits {
	ptr := /* typedef */ (*ExternalMemoryHandleTypeFlagBits)(&x.handleType)
	return *ptr
}

// WithHandleType clones a new PhysicalDeviceExternalBufferInfo with the value of
// HandleType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalBufferInfo) WithHandleType(y ExternalMemoryHandleTypeFlagBits) PhysicalDeviceExternalBufferInfo {
	x.handleType = *( /* typedef */ (*C.VkExternalMemoryHandleTypeFlagBits)(&y))
	return x
}
func (x *PhysicalDeviceExternalBufferInfo) SetHandleType(y ExternalMemoryHandleTypeFlagBits) {
	x.handleType = *( /* typedef */ (*C.VkExternalMemoryHandleTypeFlagBits)(&y))
}

// PhysicalDeviceSamplerYcbcrConversionFeatures provides a go interface for VkPhysicalDeviceSamplerYcbcrConversionFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSamplerYcbcrConversionFeatures.html
type PhysicalDeviceSamplerYcbcrConversionFeatures C.struct_VkPhysicalDeviceSamplerYcbcrConversionFeatures

// SizeofPhysicalDeviceSamplerYcbcrConversionFeatures is the memory size of a PhysicalDeviceSamplerYcbcrConversionFeatures
var SizeofPhysicalDeviceSamplerYcbcrConversionFeatures int = int(unsafe.Sizeof(PhysicalDeviceSamplerYcbcrConversionFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceSamplerYcbcrConversionFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceSamplerYcbcrConversionFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceSamplerYcbcrConversionFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceSamplerYcbcrConversionFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) AsCPtr() *PhysicalDeviceSamplerYcbcrConversionFeatures {
	clone := (*PhysicalDeviceSamplerYcbcrConversionFeatures)(newCBlock(cULong(SizeofPhysicalDeviceSamplerYcbcrConversionFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceSamplerYcbcrConversionFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceSamplerYcbcrConversionFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceSamplerYcbcrConversionFeatures) []PhysicalDeviceSamplerYcbcrConversionFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSamplerYcbcrConversionFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceSamplerYcbcrConversionFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceSamplerYcbcrConversionFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceSamplerYcbcrConversionFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceSamplerYcbcrConversionFeaturesFreeCSlice(x []PhysicalDeviceSamplerYcbcrConversionFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceSamplerYcbcrConversionFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceSamplerYcbcrConversionFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceSamplerYcbcrConversionFeaturesMakeCSlice(x ...PhysicalDeviceSamplerYcbcrConversionFeatures) []PhysicalDeviceSamplerYcbcrConversionFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSamplerYcbcrConversionFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceSamplerYcbcrConversionFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceSamplerYcbcrConversionFeatures
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceSamplerYcbcrConversionFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) WithDefaultSType() PhysicalDeviceSamplerYcbcrConversionFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceSamplerYcbcrConversionFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES)
}

// WithSType clones a new PhysicalDeviceSamplerYcbcrConversionFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) WithSType(y StructureType) PhysicalDeviceSamplerYcbcrConversionFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceSamplerYcbcrConversionFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceSamplerYcbcrConversionFeatures
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceSamplerYcbcrConversionFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceSamplerYcbcrConversionFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceSamplerYcbcrConversionFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SamplerYcbcrConversion returns the value of samplerYcbcrConversion from VkPhysicalDeviceSamplerYcbcrConversionFeatures
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) SamplerYcbcrConversion() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.samplerYcbcrConversion)
	return *ptr
}

// WithSamplerYcbcrConversion clones a new PhysicalDeviceSamplerYcbcrConversionFeatures with the value of
// SamplerYcbcrConversion updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) WithSamplerYcbcrConversion(y Bool32) PhysicalDeviceSamplerYcbcrConversionFeatures {
	x.samplerYcbcrConversion = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceSamplerYcbcrConversionFeatures) SetSamplerYcbcrConversion(y Bool32) {
	x.samplerYcbcrConversion = *( /* typedef */ (*C.VkBool32)(&y))
}

// ImagePlaneMemoryRequirementsInfo provides a go interface for VkImagePlaneMemoryRequirementsInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImagePlaneMemoryRequirementsInfo.html
type ImagePlaneMemoryRequirementsInfo C.struct_VkImagePlaneMemoryRequirementsInfo

// SizeofImagePlaneMemoryRequirementsInfo is the memory size of a ImagePlaneMemoryRequirementsInfo
var SizeofImagePlaneMemoryRequirementsInfo int = int(unsafe.Sizeof(ImagePlaneMemoryRequirementsInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ImagePlaneMemoryRequirementsInfo) ArpPtr(arp *AutoReleasePool) *ImagePlaneMemoryRequirementsInfo {
	ptr := newCBlock(cULong(SizeofImagePlaneMemoryRequirementsInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ImagePlaneMemoryRequirementsInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImagePlaneMemoryRequirementsInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImagePlaneMemoryRequirementsInfo) AsCPtr() *ImagePlaneMemoryRequirementsInfo {
	clone := (*ImagePlaneMemoryRequirementsInfo)(newCBlock(cULong(SizeofImagePlaneMemoryRequirementsInfo)))
	*clone = x
	return clone
}

// ImagePlaneMemoryRequirementsInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ImagePlaneMemoryRequirementsInfoCSlice(arp *AutoReleasePool, x ...ImagePlaneMemoryRequirementsInfo) []ImagePlaneMemoryRequirementsInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImagePlaneMemoryRequirementsInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ImagePlaneMemoryRequirementsInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ImagePlaneMemoryRequirementsInfoFreeCSlice releases the memory allocated by ImagePlaneMemoryRequirementsInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ImagePlaneMemoryRequirementsInfoFreeCSlice(x []ImagePlaneMemoryRequirementsInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImagePlaneMemoryRequirementsInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImagePlaneMemoryRequirementsInfoFreeCSlice must be called on the returned slice.
func ImagePlaneMemoryRequirementsInfoMakeCSlice(x ...ImagePlaneMemoryRequirementsInfo) []ImagePlaneMemoryRequirementsInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImagePlaneMemoryRequirementsInfo * len(x)
	dst := unsafe.Slice((*ImagePlaneMemoryRequirementsInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImagePlaneMemoryRequirementsInfo
func (x ImagePlaneMemoryRequirementsInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ImagePlaneMemoryRequirementsInfo with the value of
// SType to the value provided in the specification.
func (x ImagePlaneMemoryRequirementsInfo) WithDefaultSType() ImagePlaneMemoryRequirementsInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ImagePlaneMemoryRequirementsInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO)
}

// WithSType clones a new ImagePlaneMemoryRequirementsInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImagePlaneMemoryRequirementsInfo) WithSType(y StructureType) ImagePlaneMemoryRequirementsInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ImagePlaneMemoryRequirementsInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkImagePlaneMemoryRequirementsInfo
func (x ImagePlaneMemoryRequirementsInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ImagePlaneMemoryRequirementsInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImagePlaneMemoryRequirementsInfo) WithPNext(y unsafe.Pointer) ImagePlaneMemoryRequirementsInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ImagePlaneMemoryRequirementsInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// PlaneAspect returns the value of planeAspect from VkImagePlaneMemoryRequirementsInfo
func (x ImagePlaneMemoryRequirementsInfo) PlaneAspect() ImageAspectFlagBits {
	ptr := /* typedef */ (*ImageAspectFlagBits)(&x.planeAspect)
	return *ptr
}

// WithPlaneAspect clones a new ImagePlaneMemoryRequirementsInfo with the value of
// PlaneAspect updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImagePlaneMemoryRequirementsInfo) WithPlaneAspect(y ImageAspectFlagBits) ImagePlaneMemoryRequirementsInfo {
	x.planeAspect = *( /* typedef */ (*C.VkImageAspectFlagBits)(&y))
	return x
}
func (x *ImagePlaneMemoryRequirementsInfo) SetPlaneAspect(y ImageAspectFlagBits) {
	x.planeAspect = *( /* typedef */ (*C.VkImageAspectFlagBits)(&y))
}

// BindImagePlaneMemoryInfo provides a go interface for VkBindImagePlaneMemoryInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindImagePlaneMemoryInfo.html
type BindImagePlaneMemoryInfo C.struct_VkBindImagePlaneMemoryInfo

// SizeofBindImagePlaneMemoryInfo is the memory size of a BindImagePlaneMemoryInfo
var SizeofBindImagePlaneMemoryInfo int = int(unsafe.Sizeof(BindImagePlaneMemoryInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x BindImagePlaneMemoryInfo) ArpPtr(arp *AutoReleasePool) *BindImagePlaneMemoryInfo {
	ptr := newCBlock(cULong(SizeofBindImagePlaneMemoryInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*BindImagePlaneMemoryInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BindImagePlaneMemoryInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BindImagePlaneMemoryInfo) AsCPtr() *BindImagePlaneMemoryInfo {
	clone := (*BindImagePlaneMemoryInfo)(newCBlock(cULong(SizeofBindImagePlaneMemoryInfo)))
	*clone = x
	return clone
}

// BindImagePlaneMemoryInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func BindImagePlaneMemoryInfoCSlice(arp *AutoReleasePool, x ...BindImagePlaneMemoryInfo) []BindImagePlaneMemoryInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindImagePlaneMemoryInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*BindImagePlaneMemoryInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// BindImagePlaneMemoryInfoFreeCSlice releases the memory allocated by BindImagePlaneMemoryInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BindImagePlaneMemoryInfoFreeCSlice(x []BindImagePlaneMemoryInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BindImagePlaneMemoryInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BindImagePlaneMemoryInfoFreeCSlice must be called on the returned slice.
func BindImagePlaneMemoryInfoMakeCSlice(x ...BindImagePlaneMemoryInfo) []BindImagePlaneMemoryInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindImagePlaneMemoryInfo * len(x)
	dst := unsafe.Slice((*BindImagePlaneMemoryInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBindImagePlaneMemoryInfo
func (x BindImagePlaneMemoryInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new BindImagePlaneMemoryInfo with the value of
// SType to the value provided in the specification.
func (x BindImagePlaneMemoryInfo) WithDefaultSType() BindImagePlaneMemoryInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *BindImagePlaneMemoryInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO)
}

// WithSType clones a new BindImagePlaneMemoryInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImagePlaneMemoryInfo) WithSType(y StructureType) BindImagePlaneMemoryInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *BindImagePlaneMemoryInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkBindImagePlaneMemoryInfo
func (x BindImagePlaneMemoryInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new BindImagePlaneMemoryInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImagePlaneMemoryInfo) WithPNext(y unsafe.Pointer) BindImagePlaneMemoryInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *BindImagePlaneMemoryInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// PlaneAspect returns the value of planeAspect from VkBindImagePlaneMemoryInfo
func (x BindImagePlaneMemoryInfo) PlaneAspect() ImageAspectFlagBits {
	ptr := /* typedef */ (*ImageAspectFlagBits)(&x.planeAspect)
	return *ptr
}

// WithPlaneAspect clones a new BindImagePlaneMemoryInfo with the value of
// PlaneAspect updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImagePlaneMemoryInfo) WithPlaneAspect(y ImageAspectFlagBits) BindImagePlaneMemoryInfo {
	x.planeAspect = *( /* typedef */ (*C.VkImageAspectFlagBits)(&y))
	return x
}
func (x *BindImagePlaneMemoryInfo) SetPlaneAspect(y ImageAspectFlagBits) {
	x.planeAspect = *( /* typedef */ (*C.VkImageAspectFlagBits)(&y))
}

// ExternalSemaphoreProperties provides a go interface for VkExternalSemaphoreProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalSemaphoreProperties.html
type ExternalSemaphoreProperties C.struct_VkExternalSemaphoreProperties

// SizeofExternalSemaphoreProperties is the memory size of a ExternalSemaphoreProperties
var SizeofExternalSemaphoreProperties int = int(unsafe.Sizeof(ExternalSemaphoreProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ExternalSemaphoreProperties) ArpPtr(arp *AutoReleasePool) *ExternalSemaphoreProperties {
	ptr := newCBlock(cULong(SizeofExternalSemaphoreProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ExternalSemaphoreProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExternalSemaphoreProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExternalSemaphoreProperties) AsCPtr() *ExternalSemaphoreProperties {
	clone := (*ExternalSemaphoreProperties)(newCBlock(cULong(SizeofExternalSemaphoreProperties)))
	*clone = x
	return clone
}

// ExternalSemaphorePropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ExternalSemaphorePropertiesCSlice(arp *AutoReleasePool, x ...ExternalSemaphoreProperties) []ExternalSemaphoreProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalSemaphoreProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ExternalSemaphoreProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ExternalSemaphorePropertiesFreeCSlice releases the memory allocated by ExternalSemaphorePropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func ExternalSemaphorePropertiesFreeCSlice(x []ExternalSemaphoreProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExternalSemaphorePropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExternalSemaphorePropertiesFreeCSlice must be called on the returned slice.
func ExternalSemaphorePropertiesMakeCSlice(x ...ExternalSemaphoreProperties) []ExternalSemaphoreProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalSemaphoreProperties * len(x)
	dst := unsafe.Slice((*ExternalSemaphoreProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkExternalSemaphoreProperties
func (x ExternalSemaphoreProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ExternalSemaphoreProperties with the value of
// SType to the value provided in the specification.
func (x ExternalSemaphoreProperties) WithDefaultSType() ExternalSemaphoreProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ExternalSemaphoreProperties) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES)
}

// WithSType clones a new ExternalSemaphoreProperties with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalSemaphoreProperties) WithSType(y StructureType) ExternalSemaphoreProperties {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ExternalSemaphoreProperties) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkExternalSemaphoreProperties
func (x ExternalSemaphoreProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ExternalSemaphoreProperties with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalSemaphoreProperties) WithPNext(y unsafe.Pointer) ExternalSemaphoreProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ExternalSemaphoreProperties) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// ExportFromImportedHandleTypes returns the value of exportFromImportedHandleTypes from VkExternalSemaphoreProperties
func (x ExternalSemaphoreProperties) ExportFromImportedHandleTypes() ExternalSemaphoreHandleTypeFlags {
	ptr := /* typedef */ (*ExternalSemaphoreHandleTypeFlags)(&x.exportFromImportedHandleTypes)
	return *ptr
}

// CompatibleHandleTypes returns the value of compatibleHandleTypes from VkExternalSemaphoreProperties
func (x ExternalSemaphoreProperties) CompatibleHandleTypes() ExternalSemaphoreHandleTypeFlags {
	ptr := /* typedef */ (*ExternalSemaphoreHandleTypeFlags)(&x.compatibleHandleTypes)
	return *ptr
}

// ExternalSemaphoreFeatures returns the value of externalSemaphoreFeatures from VkExternalSemaphoreProperties
func (x ExternalSemaphoreProperties) ExternalSemaphoreFeatures() ExternalSemaphoreFeatureFlags {
	ptr := /* typedef */ (*ExternalSemaphoreFeatureFlags)(&x.externalSemaphoreFeatures)
	return *ptr
}

// PhysicalDeviceExternalSemaphoreInfo provides a go interface for VkPhysicalDeviceExternalSemaphoreInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalSemaphoreInfo.html
type PhysicalDeviceExternalSemaphoreInfo C.struct_VkPhysicalDeviceExternalSemaphoreInfo

// SizeofPhysicalDeviceExternalSemaphoreInfo is the memory size of a PhysicalDeviceExternalSemaphoreInfo
var SizeofPhysicalDeviceExternalSemaphoreInfo int = int(unsafe.Sizeof(PhysicalDeviceExternalSemaphoreInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceExternalSemaphoreInfo) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceExternalSemaphoreInfo {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceExternalSemaphoreInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceExternalSemaphoreInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceExternalSemaphoreInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceExternalSemaphoreInfo) AsCPtr() *PhysicalDeviceExternalSemaphoreInfo {
	clone := (*PhysicalDeviceExternalSemaphoreInfo)(newCBlock(cULong(SizeofPhysicalDeviceExternalSemaphoreInfo)))
	*clone = x
	return clone
}

// PhysicalDeviceExternalSemaphoreInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceExternalSemaphoreInfoCSlice(arp *AutoReleasePool, x ...PhysicalDeviceExternalSemaphoreInfo) []PhysicalDeviceExternalSemaphoreInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceExternalSemaphoreInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceExternalSemaphoreInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceExternalSemaphoreInfoFreeCSlice releases the memory allocated by PhysicalDeviceExternalSemaphoreInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceExternalSemaphoreInfoFreeCSlice(x []PhysicalDeviceExternalSemaphoreInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceExternalSemaphoreInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceExternalSemaphoreInfoFreeCSlice must be called on the returned slice.
func PhysicalDeviceExternalSemaphoreInfoMakeCSlice(x ...PhysicalDeviceExternalSemaphoreInfo) []PhysicalDeviceExternalSemaphoreInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceExternalSemaphoreInfo * len(x)
	dst := unsafe.Slice((*PhysicalDeviceExternalSemaphoreInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceExternalSemaphoreInfo
func (x PhysicalDeviceExternalSemaphoreInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceExternalSemaphoreInfo with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceExternalSemaphoreInfo) WithDefaultSType() PhysicalDeviceExternalSemaphoreInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceExternalSemaphoreInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO)
}

// WithSType clones a new PhysicalDeviceExternalSemaphoreInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalSemaphoreInfo) WithSType(y StructureType) PhysicalDeviceExternalSemaphoreInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceExternalSemaphoreInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceExternalSemaphoreInfo
func (x PhysicalDeviceExternalSemaphoreInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceExternalSemaphoreInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalSemaphoreInfo) WithPNext(y unsafe.Pointer) PhysicalDeviceExternalSemaphoreInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceExternalSemaphoreInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// HandleType returns the value of handleType from VkPhysicalDeviceExternalSemaphoreInfo
func (x PhysicalDeviceExternalSemaphoreInfo) HandleType() ExternalSemaphoreHandleTypeFlagBits {
	ptr := /* typedef */ (*ExternalSemaphoreHandleTypeFlagBits)(&x.handleType)
	return *ptr
}

// WithHandleType clones a new PhysicalDeviceExternalSemaphoreInfo with the value of
// HandleType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalSemaphoreInfo) WithHandleType(y ExternalSemaphoreHandleTypeFlagBits) PhysicalDeviceExternalSemaphoreInfo {
	x.handleType = *( /* typedef */ (*C.VkExternalSemaphoreHandleTypeFlagBits)(&y))
	return x
}
func (x *PhysicalDeviceExternalSemaphoreInfo) SetHandleType(y ExternalSemaphoreHandleTypeFlagBits) {
	x.handleType = *( /* typedef */ (*C.VkExternalSemaphoreHandleTypeFlagBits)(&y))
}

// BindBufferMemoryInfo provides a go interface for VkBindBufferMemoryInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindBufferMemoryInfo.html
type BindBufferMemoryInfo C.struct_VkBindBufferMemoryInfo

// SizeofBindBufferMemoryInfo is the memory size of a BindBufferMemoryInfo
var SizeofBindBufferMemoryInfo int = int(unsafe.Sizeof(BindBufferMemoryInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x BindBufferMemoryInfo) ArpPtr(arp *AutoReleasePool) *BindBufferMemoryInfo {
	ptr := newCBlock(cULong(SizeofBindBufferMemoryInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*BindBufferMemoryInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BindBufferMemoryInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BindBufferMemoryInfo) AsCPtr() *BindBufferMemoryInfo {
	clone := (*BindBufferMemoryInfo)(newCBlock(cULong(SizeofBindBufferMemoryInfo)))
	*clone = x
	return clone
}

// BindBufferMemoryInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func BindBufferMemoryInfoCSlice(arp *AutoReleasePool, x ...BindBufferMemoryInfo) []BindBufferMemoryInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindBufferMemoryInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*BindBufferMemoryInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// BindBufferMemoryInfoFreeCSlice releases the memory allocated by BindBufferMemoryInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BindBufferMemoryInfoFreeCSlice(x []BindBufferMemoryInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BindBufferMemoryInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BindBufferMemoryInfoFreeCSlice must be called on the returned slice.
func BindBufferMemoryInfoMakeCSlice(x ...BindBufferMemoryInfo) []BindBufferMemoryInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindBufferMemoryInfo * len(x)
	dst := unsafe.Slice((*BindBufferMemoryInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBindBufferMemoryInfo
func (x BindBufferMemoryInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new BindBufferMemoryInfo with the value of
// SType to the value provided in the specification.
func (x BindBufferMemoryInfo) WithDefaultSType() BindBufferMemoryInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *BindBufferMemoryInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO)
}

// WithSType clones a new BindBufferMemoryInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindBufferMemoryInfo) WithSType(y StructureType) BindBufferMemoryInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *BindBufferMemoryInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkBindBufferMemoryInfo
func (x BindBufferMemoryInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new BindBufferMemoryInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindBufferMemoryInfo) WithPNext(y unsafe.Pointer) BindBufferMemoryInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *BindBufferMemoryInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Buffer returns the value of buffer from VkBindBufferMemoryInfo
func (x BindBufferMemoryInfo) Buffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.buffer)
	return *ptr
}

// WithBuffer clones a new BindBufferMemoryInfo with the value of
// Buffer updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindBufferMemoryInfo) WithBuffer(y Buffer) BindBufferMemoryInfo {
	x.buffer = *( /* handle */ (*C.VkBuffer)(&y))
	return x
}
func (x *BindBufferMemoryInfo) SetBuffer(y Buffer) {
	x.buffer = *( /* handle */ (*C.VkBuffer)(&y))
}

// Memory returns the value of memory from VkBindBufferMemoryInfo
func (x BindBufferMemoryInfo) Memory() DeviceMemory {
	ptr := /* handle */ (*DeviceMemory)(&x.memory)
	return *ptr
}

// WithMemory clones a new BindBufferMemoryInfo with the value of
// Memory updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindBufferMemoryInfo) WithMemory(y DeviceMemory) BindBufferMemoryInfo {
	x.memory = *( /* handle */ (*C.VkDeviceMemory)(&y))
	return x
}
func (x *BindBufferMemoryInfo) SetMemory(y DeviceMemory) {
	x.memory = *( /* handle */ (*C.VkDeviceMemory)(&y))
}

// MemoryOffset returns the value of memoryOffset from VkBindBufferMemoryInfo
func (x BindBufferMemoryInfo) MemoryOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.memoryOffset)
	return *ptr
}

// WithMemoryOffset clones a new BindBufferMemoryInfo with the value of
// MemoryOffset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindBufferMemoryInfo) WithMemoryOffset(y DeviceSize) BindBufferMemoryInfo {
	x.memoryOffset = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *BindBufferMemoryInfo) SetMemoryOffset(y DeviceSize) {
	x.memoryOffset = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// ExternalMemoryImageCreateInfo provides a go interface for VkExternalMemoryImageCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalMemoryImageCreateInfo.html
type ExternalMemoryImageCreateInfo C.struct_VkExternalMemoryImageCreateInfo

// SizeofExternalMemoryImageCreateInfo is the memory size of a ExternalMemoryImageCreateInfo
var SizeofExternalMemoryImageCreateInfo int = int(unsafe.Sizeof(ExternalMemoryImageCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ExternalMemoryImageCreateInfo) ArpPtr(arp *AutoReleasePool) *ExternalMemoryImageCreateInfo {
	ptr := newCBlock(cULong(SizeofExternalMemoryImageCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ExternalMemoryImageCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExternalMemoryImageCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExternalMemoryImageCreateInfo) AsCPtr() *ExternalMemoryImageCreateInfo {
	clone := (*ExternalMemoryImageCreateInfo)(newCBlock(cULong(SizeofExternalMemoryImageCreateInfo)))
	*clone = x
	return clone
}

// ExternalMemoryImageCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ExternalMemoryImageCreateInfoCSlice(arp *AutoReleasePool, x ...ExternalMemoryImageCreateInfo) []ExternalMemoryImageCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalMemoryImageCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ExternalMemoryImageCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ExternalMemoryImageCreateInfoFreeCSlice releases the memory allocated by ExternalMemoryImageCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ExternalMemoryImageCreateInfoFreeCSlice(x []ExternalMemoryImageCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExternalMemoryImageCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExternalMemoryImageCreateInfoFreeCSlice must be called on the returned slice.
func ExternalMemoryImageCreateInfoMakeCSlice(x ...ExternalMemoryImageCreateInfo) []ExternalMemoryImageCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalMemoryImageCreateInfo * len(x)
	dst := unsafe.Slice((*ExternalMemoryImageCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkExternalMemoryImageCreateInfo
func (x ExternalMemoryImageCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ExternalMemoryImageCreateInfo with the value of
// SType to the value provided in the specification.
func (x ExternalMemoryImageCreateInfo) WithDefaultSType() ExternalMemoryImageCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ExternalMemoryImageCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO)
}

// WithSType clones a new ExternalMemoryImageCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalMemoryImageCreateInfo) WithSType(y StructureType) ExternalMemoryImageCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ExternalMemoryImageCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkExternalMemoryImageCreateInfo
func (x ExternalMemoryImageCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ExternalMemoryImageCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalMemoryImageCreateInfo) WithPNext(y unsafe.Pointer) ExternalMemoryImageCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ExternalMemoryImageCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// HandleTypes returns the value of handleTypes from VkExternalMemoryImageCreateInfo
func (x ExternalMemoryImageCreateInfo) HandleTypes() ExternalMemoryHandleTypeFlags {
	ptr := /* typedef */ (*ExternalMemoryHandleTypeFlags)(&x.handleTypes)
	return *ptr
}

// WithHandleTypes clones a new ExternalMemoryImageCreateInfo with the value of
// HandleTypes updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalMemoryImageCreateInfo) WithHandleTypes(y ExternalMemoryHandleTypeFlags) ExternalMemoryImageCreateInfo {
	x.handleTypes = *( /* typedef */ (*C.VkExternalMemoryHandleTypeFlags)(&y))
	return x
}
func (x *ExternalMemoryImageCreateInfo) SetHandleTypes(y ExternalMemoryHandleTypeFlags) {
	x.handleTypes = *( /* typedef */ (*C.VkExternalMemoryHandleTypeFlags)(&y))
}

// DeviceGroupRenderPassBeginInfo provides a go interface for VkDeviceGroupRenderPassBeginInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupRenderPassBeginInfo.html
type DeviceGroupRenderPassBeginInfo C.struct_VkDeviceGroupRenderPassBeginInfo

// SizeofDeviceGroupRenderPassBeginInfo is the memory size of a DeviceGroupRenderPassBeginInfo
var SizeofDeviceGroupRenderPassBeginInfo int = int(unsafe.Sizeof(DeviceGroupRenderPassBeginInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DeviceGroupRenderPassBeginInfo) ArpPtr(arp *AutoReleasePool) *DeviceGroupRenderPassBeginInfo {
	ptr := newCBlock(cULong(SizeofDeviceGroupRenderPassBeginInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DeviceGroupRenderPassBeginInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceGroupRenderPassBeginInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceGroupRenderPassBeginInfo) AsCPtr() *DeviceGroupRenderPassBeginInfo {
	clone := (*DeviceGroupRenderPassBeginInfo)(newCBlock(cULong(SizeofDeviceGroupRenderPassBeginInfo)))
	*clone = x
	return clone
}

// DeviceGroupRenderPassBeginInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DeviceGroupRenderPassBeginInfoCSlice(arp *AutoReleasePool, x ...DeviceGroupRenderPassBeginInfo) []DeviceGroupRenderPassBeginInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupRenderPassBeginInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DeviceGroupRenderPassBeginInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DeviceGroupRenderPassBeginInfoFreeCSlice releases the memory allocated by DeviceGroupRenderPassBeginInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceGroupRenderPassBeginInfoFreeCSlice(x []DeviceGroupRenderPassBeginInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceGroupRenderPassBeginInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceGroupRenderPassBeginInfoFreeCSlice must be called on the returned slice.
func DeviceGroupRenderPassBeginInfoMakeCSlice(x ...DeviceGroupRenderPassBeginInfo) []DeviceGroupRenderPassBeginInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupRenderPassBeginInfo * len(x)
	dst := unsafe.Slice((*DeviceGroupRenderPassBeginInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceGroupRenderPassBeginInfo
func (x DeviceGroupRenderPassBeginInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DeviceGroupRenderPassBeginInfo with the value of
// SType to the value provided in the specification.
func (x DeviceGroupRenderPassBeginInfo) WithDefaultSType() DeviceGroupRenderPassBeginInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DeviceGroupRenderPassBeginInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO)
}

// WithSType clones a new DeviceGroupRenderPassBeginInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupRenderPassBeginInfo) WithSType(y StructureType) DeviceGroupRenderPassBeginInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DeviceGroupRenderPassBeginInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDeviceGroupRenderPassBeginInfo
func (x DeviceGroupRenderPassBeginInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DeviceGroupRenderPassBeginInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupRenderPassBeginInfo) WithPNext(y unsafe.Pointer) DeviceGroupRenderPassBeginInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DeviceGroupRenderPassBeginInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// DeviceMask returns the value of deviceMask from VkDeviceGroupRenderPassBeginInfo
func (x DeviceGroupRenderPassBeginInfo) DeviceMask() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.deviceMask)
	return *ptr
}

// WithDeviceMask clones a new DeviceGroupRenderPassBeginInfo with the value of
// DeviceMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupRenderPassBeginInfo) WithDeviceMask(y uint32) DeviceGroupRenderPassBeginInfo {
	x.deviceMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DeviceGroupRenderPassBeginInfo) SetDeviceMask(y uint32) {
	x.deviceMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// DeviceRenderAreaCount returns the value of deviceRenderAreaCount from VkDeviceGroupRenderPassBeginInfo
func (x DeviceGroupRenderPassBeginInfo) DeviceRenderAreaCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.deviceRenderAreaCount)
	return *ptr
}

// WithDeviceRenderAreaCount clones a new DeviceGroupRenderPassBeginInfo with the value of
// DeviceRenderAreaCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupRenderPassBeginInfo) WithDeviceRenderAreaCount(y uint32) DeviceGroupRenderPassBeginInfo {
	x.deviceRenderAreaCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DeviceGroupRenderPassBeginInfo) SetDeviceRenderAreaCount(y uint32) {
	x.deviceRenderAreaCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PDeviceRenderAreas returns the value of pDeviceRenderAreas from VkDeviceGroupRenderPassBeginInfo
func (x DeviceGroupRenderPassBeginInfo) PDeviceRenderAreas() []Rect2D {
	ptr := func(x **C.struct_VkRect2D) *[]Rect2D { /* Slice */
		slc := unsafe.Slice((*Rect2D)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pDeviceRenderAreas)
	return *ptr
}

// WithPDeviceRenderAreas clones a new DeviceGroupRenderPassBeginInfo with the value of
// PDeviceRenderAreas updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DeviceRenderAreaCount as the length of this field.
// DeviceRenderAreaCount is updated with the length of the new value.
func (x DeviceGroupRenderPassBeginInfo) WithPDeviceRenderAreas(y []Rect2D) DeviceGroupRenderPassBeginInfo {
	x.pDeviceRenderAreas = *(func(x *[]Rect2D) **C.struct_VkRect2D { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkRect2D)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkRect2D)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithDeviceRenderAreaCount(uint32(len(y)))
}
func (x *DeviceGroupRenderPassBeginInfo) SetPDeviceRenderAreas(y []Rect2D) {
	x.pDeviceRenderAreas = *(func(x *[]Rect2D) **C.struct_VkRect2D { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkRect2D)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkRect2D)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetDeviceRenderAreaCount(uint32(len(y)))
}

// PhysicalDeviceExternalFenceInfo provides a go interface for VkPhysicalDeviceExternalFenceInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalFenceInfo.html
type PhysicalDeviceExternalFenceInfo C.struct_VkPhysicalDeviceExternalFenceInfo

// SizeofPhysicalDeviceExternalFenceInfo is the memory size of a PhysicalDeviceExternalFenceInfo
var SizeofPhysicalDeviceExternalFenceInfo int = int(unsafe.Sizeof(PhysicalDeviceExternalFenceInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceExternalFenceInfo) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceExternalFenceInfo {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceExternalFenceInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceExternalFenceInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceExternalFenceInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceExternalFenceInfo) AsCPtr() *PhysicalDeviceExternalFenceInfo {
	clone := (*PhysicalDeviceExternalFenceInfo)(newCBlock(cULong(SizeofPhysicalDeviceExternalFenceInfo)))
	*clone = x
	return clone
}

// PhysicalDeviceExternalFenceInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceExternalFenceInfoCSlice(arp *AutoReleasePool, x ...PhysicalDeviceExternalFenceInfo) []PhysicalDeviceExternalFenceInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceExternalFenceInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceExternalFenceInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceExternalFenceInfoFreeCSlice releases the memory allocated by PhysicalDeviceExternalFenceInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceExternalFenceInfoFreeCSlice(x []PhysicalDeviceExternalFenceInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceExternalFenceInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceExternalFenceInfoFreeCSlice must be called on the returned slice.
func PhysicalDeviceExternalFenceInfoMakeCSlice(x ...PhysicalDeviceExternalFenceInfo) []PhysicalDeviceExternalFenceInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceExternalFenceInfo * len(x)
	dst := unsafe.Slice((*PhysicalDeviceExternalFenceInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceExternalFenceInfo
func (x PhysicalDeviceExternalFenceInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceExternalFenceInfo with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceExternalFenceInfo) WithDefaultSType() PhysicalDeviceExternalFenceInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceExternalFenceInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO)
}

// WithSType clones a new PhysicalDeviceExternalFenceInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalFenceInfo) WithSType(y StructureType) PhysicalDeviceExternalFenceInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceExternalFenceInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceExternalFenceInfo
func (x PhysicalDeviceExternalFenceInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceExternalFenceInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalFenceInfo) WithPNext(y unsafe.Pointer) PhysicalDeviceExternalFenceInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceExternalFenceInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// HandleType returns the value of handleType from VkPhysicalDeviceExternalFenceInfo
func (x PhysicalDeviceExternalFenceInfo) HandleType() ExternalFenceHandleTypeFlagBits {
	ptr := /* typedef */ (*ExternalFenceHandleTypeFlagBits)(&x.handleType)
	return *ptr
}

// WithHandleType clones a new PhysicalDeviceExternalFenceInfo with the value of
// HandleType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalFenceInfo) WithHandleType(y ExternalFenceHandleTypeFlagBits) PhysicalDeviceExternalFenceInfo {
	x.handleType = *( /* typedef */ (*C.VkExternalFenceHandleTypeFlagBits)(&y))
	return x
}
func (x *PhysicalDeviceExternalFenceInfo) SetHandleType(y ExternalFenceHandleTypeFlagBits) {
	x.handleType = *( /* typedef */ (*C.VkExternalFenceHandleTypeFlagBits)(&y))
}

// MemoryAllocateFlagsInfo provides a go interface for VkMemoryAllocateFlagsInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryAllocateFlagsInfo.html
type MemoryAllocateFlagsInfo C.struct_VkMemoryAllocateFlagsInfo

// SizeofMemoryAllocateFlagsInfo is the memory size of a MemoryAllocateFlagsInfo
var SizeofMemoryAllocateFlagsInfo int = int(unsafe.Sizeof(MemoryAllocateFlagsInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x MemoryAllocateFlagsInfo) ArpPtr(arp *AutoReleasePool) *MemoryAllocateFlagsInfo {
	ptr := newCBlock(cULong(SizeofMemoryAllocateFlagsInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*MemoryAllocateFlagsInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryAllocateFlagsInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryAllocateFlagsInfo) AsCPtr() *MemoryAllocateFlagsInfo {
	clone := (*MemoryAllocateFlagsInfo)(newCBlock(cULong(SizeofMemoryAllocateFlagsInfo)))
	*clone = x
	return clone
}

// MemoryAllocateFlagsInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func MemoryAllocateFlagsInfoCSlice(arp *AutoReleasePool, x ...MemoryAllocateFlagsInfo) []MemoryAllocateFlagsInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryAllocateFlagsInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*MemoryAllocateFlagsInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// MemoryAllocateFlagsInfoFreeCSlice releases the memory allocated by MemoryAllocateFlagsInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryAllocateFlagsInfoFreeCSlice(x []MemoryAllocateFlagsInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryAllocateFlagsInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryAllocateFlagsInfoFreeCSlice must be called on the returned slice.
func MemoryAllocateFlagsInfoMakeCSlice(x ...MemoryAllocateFlagsInfo) []MemoryAllocateFlagsInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryAllocateFlagsInfo * len(x)
	dst := unsafe.Slice((*MemoryAllocateFlagsInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkMemoryAllocateFlagsInfo
func (x MemoryAllocateFlagsInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new MemoryAllocateFlagsInfo with the value of
// SType to the value provided in the specification.
func (x MemoryAllocateFlagsInfo) WithDefaultSType() MemoryAllocateFlagsInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *MemoryAllocateFlagsInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO)
}

// WithSType clones a new MemoryAllocateFlagsInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryAllocateFlagsInfo) WithSType(y StructureType) MemoryAllocateFlagsInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *MemoryAllocateFlagsInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkMemoryAllocateFlagsInfo
func (x MemoryAllocateFlagsInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new MemoryAllocateFlagsInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryAllocateFlagsInfo) WithPNext(y unsafe.Pointer) MemoryAllocateFlagsInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *MemoryAllocateFlagsInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkMemoryAllocateFlagsInfo
func (x MemoryAllocateFlagsInfo) Flags() MemoryAllocateFlags {
	ptr := /* typedef */ (*MemoryAllocateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new MemoryAllocateFlagsInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryAllocateFlagsInfo) WithFlags(y MemoryAllocateFlags) MemoryAllocateFlagsInfo {
	x.flags = *( /* typedef */ (*C.VkMemoryAllocateFlags)(&y))
	return x
}
func (x *MemoryAllocateFlagsInfo) SetFlags(y MemoryAllocateFlags) {
	x.flags = *( /* typedef */ (*C.VkMemoryAllocateFlags)(&y))
}

// DeviceMask returns the value of deviceMask from VkMemoryAllocateFlagsInfo
func (x MemoryAllocateFlagsInfo) DeviceMask() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.deviceMask)
	return *ptr
}

// WithDeviceMask clones a new MemoryAllocateFlagsInfo with the value of
// DeviceMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryAllocateFlagsInfo) WithDeviceMask(y uint32) MemoryAllocateFlagsInfo {
	x.deviceMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *MemoryAllocateFlagsInfo) SetDeviceMask(y uint32) {
	x.deviceMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PhysicalDeviceFeatures2 provides a go interface for VkPhysicalDeviceFeatures2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures2.html
type PhysicalDeviceFeatures2 C.struct_VkPhysicalDeviceFeatures2

// SizeofPhysicalDeviceFeatures2 is the memory size of a PhysicalDeviceFeatures2
var SizeofPhysicalDeviceFeatures2 int = int(unsafe.Sizeof(PhysicalDeviceFeatures2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceFeatures2) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceFeatures2 {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceFeatures2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceFeatures2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceFeatures2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceFeatures2) AsCPtr() *PhysicalDeviceFeatures2 {
	clone := (*PhysicalDeviceFeatures2)(newCBlock(cULong(SizeofPhysicalDeviceFeatures2)))
	*clone = x
	return clone
}

// PhysicalDeviceFeatures2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceFeatures2CSlice(arp *AutoReleasePool, x ...PhysicalDeviceFeatures2) []PhysicalDeviceFeatures2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceFeatures2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceFeatures2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceFeatures2FreeCSlice releases the memory allocated by PhysicalDeviceFeatures2MakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceFeatures2FreeCSlice(x []PhysicalDeviceFeatures2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceFeatures2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceFeatures2FreeCSlice must be called on the returned slice.
func PhysicalDeviceFeatures2MakeCSlice(x ...PhysicalDeviceFeatures2) []PhysicalDeviceFeatures2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceFeatures2 * len(x)
	dst := unsafe.Slice((*PhysicalDeviceFeatures2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceFeatures2
func (x PhysicalDeviceFeatures2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceFeatures2 with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceFeatures2) WithDefaultSType() PhysicalDeviceFeatures2 {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceFeatures2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2)
}

// WithSType clones a new PhysicalDeviceFeatures2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures2) WithSType(y StructureType) PhysicalDeviceFeatures2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceFeatures2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceFeatures2
func (x PhysicalDeviceFeatures2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceFeatures2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures2) WithPNext(y unsafe.Pointer) PhysicalDeviceFeatures2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceFeatures2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Features returns the value of features from VkPhysicalDeviceFeatures2
func (x PhysicalDeviceFeatures2) Features() PhysicalDeviceFeatures {
	ptr := /* typedef */ (*PhysicalDeviceFeatures)(&x.features)
	return *ptr
}

// WithFeatures clones a new PhysicalDeviceFeatures2 with the value of
// Features updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures2) WithFeatures(y PhysicalDeviceFeatures) PhysicalDeviceFeatures2 {
	x.features = *( /* typedef */ (*C.struct_VkPhysicalDeviceFeatures)(&y))
	return x
}
func (x *PhysicalDeviceFeatures2) SetFeatures(y PhysicalDeviceFeatures) {
	x.features = *( /* typedef */ (*C.struct_VkPhysicalDeviceFeatures)(&y))
}

// PhysicalDeviceProperties2 provides a go interface for VkPhysicalDeviceProperties2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProperties2.html
type PhysicalDeviceProperties2 C.struct_VkPhysicalDeviceProperties2

// SizeofPhysicalDeviceProperties2 is the memory size of a PhysicalDeviceProperties2
var SizeofPhysicalDeviceProperties2 int = int(unsafe.Sizeof(PhysicalDeviceProperties2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceProperties2) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceProperties2 {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceProperties2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceProperties2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceProperties2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceProperties2) AsCPtr() *PhysicalDeviceProperties2 {
	clone := (*PhysicalDeviceProperties2)(newCBlock(cULong(SizeofPhysicalDeviceProperties2)))
	*clone = x
	return clone
}

// PhysicalDeviceProperties2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceProperties2CSlice(arp *AutoReleasePool, x ...PhysicalDeviceProperties2) []PhysicalDeviceProperties2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceProperties2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceProperties2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceProperties2FreeCSlice releases the memory allocated by PhysicalDeviceProperties2MakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceProperties2FreeCSlice(x []PhysicalDeviceProperties2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceProperties2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceProperties2FreeCSlice must be called on the returned slice.
func PhysicalDeviceProperties2MakeCSlice(x ...PhysicalDeviceProperties2) []PhysicalDeviceProperties2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceProperties2 * len(x)
	dst := unsafe.Slice((*PhysicalDeviceProperties2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceProperties2
func (x PhysicalDeviceProperties2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceProperties2 with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceProperties2) WithDefaultSType() PhysicalDeviceProperties2 {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceProperties2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2)
}

// WithSType clones a new PhysicalDeviceProperties2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceProperties2) WithSType(y StructureType) PhysicalDeviceProperties2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceProperties2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceProperties2
func (x PhysicalDeviceProperties2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceProperties2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceProperties2) WithPNext(y unsafe.Pointer) PhysicalDeviceProperties2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceProperties2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Properties returns the value of properties from VkPhysicalDeviceProperties2
func (x PhysicalDeviceProperties2) Properties() PhysicalDeviceProperties {
	ptr := /* typedef */ (*PhysicalDeviceProperties)(&x.properties)
	return *ptr
}

// FormatProperties2 provides a go interface for VkFormatProperties2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatProperties2.html
type FormatProperties2 C.struct_VkFormatProperties2

// SizeofFormatProperties2 is the memory size of a FormatProperties2
var SizeofFormatProperties2 int = int(unsafe.Sizeof(FormatProperties2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x FormatProperties2) ArpPtr(arp *AutoReleasePool) *FormatProperties2 {
	ptr := newCBlock(cULong(SizeofFormatProperties2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*FormatProperties2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *FormatProperties2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x FormatProperties2) AsCPtr() *FormatProperties2 {
	clone := (*FormatProperties2)(newCBlock(cULong(SizeofFormatProperties2)))
	*clone = x
	return clone
}

// FormatProperties2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func FormatProperties2CSlice(arp *AutoReleasePool, x ...FormatProperties2) []FormatProperties2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFormatProperties2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*FormatProperties2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// FormatProperties2FreeCSlice releases the memory allocated by FormatProperties2MakeCSlice.
// It does not free pointers stored inside the slice.
func FormatProperties2FreeCSlice(x []FormatProperties2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// FormatProperties2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. FormatProperties2FreeCSlice must be called on the returned slice.
func FormatProperties2MakeCSlice(x ...FormatProperties2) []FormatProperties2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFormatProperties2 * len(x)
	dst := unsafe.Slice((*FormatProperties2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkFormatProperties2
func (x FormatProperties2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new FormatProperties2 with the value of
// SType to the value provided in the specification.
func (x FormatProperties2) WithDefaultSType() FormatProperties2 {
	return x.WithSType(VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *FormatProperties2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2)
}

// WithSType clones a new FormatProperties2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FormatProperties2) WithSType(y StructureType) FormatProperties2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *FormatProperties2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkFormatProperties2
func (x FormatProperties2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new FormatProperties2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FormatProperties2) WithPNext(y unsafe.Pointer) FormatProperties2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *FormatProperties2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// FormatProperties returns the value of formatProperties from VkFormatProperties2
func (x FormatProperties2) FormatProperties() FormatProperties {
	ptr := /* typedef */ (*FormatProperties)(&x.formatProperties)
	return *ptr
}

// ImageFormatProperties2 provides a go interface for VkImageFormatProperties2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageFormatProperties2.html
type ImageFormatProperties2 C.struct_VkImageFormatProperties2

// SizeofImageFormatProperties2 is the memory size of a ImageFormatProperties2
var SizeofImageFormatProperties2 int = int(unsafe.Sizeof(ImageFormatProperties2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ImageFormatProperties2) ArpPtr(arp *AutoReleasePool) *ImageFormatProperties2 {
	ptr := newCBlock(cULong(SizeofImageFormatProperties2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ImageFormatProperties2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageFormatProperties2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageFormatProperties2) AsCPtr() *ImageFormatProperties2 {
	clone := (*ImageFormatProperties2)(newCBlock(cULong(SizeofImageFormatProperties2)))
	*clone = x
	return clone
}

// ImageFormatProperties2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ImageFormatProperties2CSlice(arp *AutoReleasePool, x ...ImageFormatProperties2) []ImageFormatProperties2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageFormatProperties2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ImageFormatProperties2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ImageFormatProperties2FreeCSlice releases the memory allocated by ImageFormatProperties2MakeCSlice.
// It does not free pointers stored inside the slice.
func ImageFormatProperties2FreeCSlice(x []ImageFormatProperties2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageFormatProperties2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageFormatProperties2FreeCSlice must be called on the returned slice.
func ImageFormatProperties2MakeCSlice(x ...ImageFormatProperties2) []ImageFormatProperties2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageFormatProperties2 * len(x)
	dst := unsafe.Slice((*ImageFormatProperties2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageFormatProperties2
func (x ImageFormatProperties2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ImageFormatProperties2 with the value of
// SType to the value provided in the specification.
func (x ImageFormatProperties2) WithDefaultSType() ImageFormatProperties2 {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ImageFormatProperties2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2)
}

// WithSType clones a new ImageFormatProperties2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageFormatProperties2) WithSType(y StructureType) ImageFormatProperties2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ImageFormatProperties2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkImageFormatProperties2
func (x ImageFormatProperties2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ImageFormatProperties2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageFormatProperties2) WithPNext(y unsafe.Pointer) ImageFormatProperties2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ImageFormatProperties2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// ImageFormatProperties returns the value of imageFormatProperties from VkImageFormatProperties2
func (x ImageFormatProperties2) ImageFormatProperties() ImageFormatProperties {
	ptr := /* typedef */ (*ImageFormatProperties)(&x.imageFormatProperties)
	return *ptr
}

// PhysicalDeviceImageFormatInfo2 provides a go interface for VkPhysicalDeviceImageFormatInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageFormatInfo2.html
type PhysicalDeviceImageFormatInfo2 C.struct_VkPhysicalDeviceImageFormatInfo2

// SizeofPhysicalDeviceImageFormatInfo2 is the memory size of a PhysicalDeviceImageFormatInfo2
var SizeofPhysicalDeviceImageFormatInfo2 int = int(unsafe.Sizeof(PhysicalDeviceImageFormatInfo2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceImageFormatInfo2) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceImageFormatInfo2 {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceImageFormatInfo2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceImageFormatInfo2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceImageFormatInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceImageFormatInfo2) AsCPtr() *PhysicalDeviceImageFormatInfo2 {
	clone := (*PhysicalDeviceImageFormatInfo2)(newCBlock(cULong(SizeofPhysicalDeviceImageFormatInfo2)))
	*clone = x
	return clone
}

// PhysicalDeviceImageFormatInfo2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceImageFormatInfo2CSlice(arp *AutoReleasePool, x ...PhysicalDeviceImageFormatInfo2) []PhysicalDeviceImageFormatInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceImageFormatInfo2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceImageFormatInfo2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceImageFormatInfo2FreeCSlice releases the memory allocated by PhysicalDeviceImageFormatInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceImageFormatInfo2FreeCSlice(x []PhysicalDeviceImageFormatInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceImageFormatInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceImageFormatInfo2FreeCSlice must be called on the returned slice.
func PhysicalDeviceImageFormatInfo2MakeCSlice(x ...PhysicalDeviceImageFormatInfo2) []PhysicalDeviceImageFormatInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceImageFormatInfo2 * len(x)
	dst := unsafe.Slice((*PhysicalDeviceImageFormatInfo2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceImageFormatInfo2
func (x PhysicalDeviceImageFormatInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceImageFormatInfo2 with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceImageFormatInfo2) WithDefaultSType() PhysicalDeviceImageFormatInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceImageFormatInfo2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2)
}

// WithSType clones a new PhysicalDeviceImageFormatInfo2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImageFormatInfo2) WithSType(y StructureType) PhysicalDeviceImageFormatInfo2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceImageFormatInfo2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceImageFormatInfo2
func (x PhysicalDeviceImageFormatInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceImageFormatInfo2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImageFormatInfo2) WithPNext(y unsafe.Pointer) PhysicalDeviceImageFormatInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceImageFormatInfo2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Format returns the value of format from VkPhysicalDeviceImageFormatInfo2
func (x PhysicalDeviceImageFormatInfo2) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format)
	return *ptr
}

// WithFormat clones a new PhysicalDeviceImageFormatInfo2 with the value of
// Format updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImageFormatInfo2) WithFormat(y Format) PhysicalDeviceImageFormatInfo2 {
	x.format = *( /* typedef */ (*C.VkFormat)(&y))
	return x
}
func (x *PhysicalDeviceImageFormatInfo2) SetFormat(y Format) {
	x.format = *( /* typedef */ (*C.VkFormat)(&y))
}

// Type_ returns the value of type from VkPhysicalDeviceImageFormatInfo2
func (x PhysicalDeviceImageFormatInfo2) Type_() ImageType {
	ptr := /* typedef */ (*ImageType)(&x._type)
	return *ptr
}

// WithType_ clones a new PhysicalDeviceImageFormatInfo2 with the value of
// Type_ updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImageFormatInfo2) WithType_(y ImageType) PhysicalDeviceImageFormatInfo2 {
	x._type = *( /* typedef */ (*C.VkImageType)(&y))
	return x
}
func (x *PhysicalDeviceImageFormatInfo2) SetType_(y ImageType) {
	x._type = *( /* typedef */ (*C.VkImageType)(&y))
}

// Tiling returns the value of tiling from VkPhysicalDeviceImageFormatInfo2
func (x PhysicalDeviceImageFormatInfo2) Tiling() ImageTiling {
	ptr := /* typedef */ (*ImageTiling)(&x.tiling)
	return *ptr
}

// WithTiling clones a new PhysicalDeviceImageFormatInfo2 with the value of
// Tiling updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImageFormatInfo2) WithTiling(y ImageTiling) PhysicalDeviceImageFormatInfo2 {
	x.tiling = *( /* typedef */ (*C.VkImageTiling)(&y))
	return x
}
func (x *PhysicalDeviceImageFormatInfo2) SetTiling(y ImageTiling) {
	x.tiling = *( /* typedef */ (*C.VkImageTiling)(&y))
}

// Usage returns the value of usage from VkPhysicalDeviceImageFormatInfo2
func (x PhysicalDeviceImageFormatInfo2) Usage() ImageUsageFlags {
	ptr := /* typedef */ (*ImageUsageFlags)(&x.usage)
	return *ptr
}

// WithUsage clones a new PhysicalDeviceImageFormatInfo2 with the value of
// Usage updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImageFormatInfo2) WithUsage(y ImageUsageFlags) PhysicalDeviceImageFormatInfo2 {
	x.usage = *( /* typedef */ (*C.VkImageUsageFlags)(&y))
	return x
}
func (x *PhysicalDeviceImageFormatInfo2) SetUsage(y ImageUsageFlags) {
	x.usage = *( /* typedef */ (*C.VkImageUsageFlags)(&y))
}

// Flags returns the value of flags from VkPhysicalDeviceImageFormatInfo2
func (x PhysicalDeviceImageFormatInfo2) Flags() ImageCreateFlags {
	ptr := /* typedef */ (*ImageCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new PhysicalDeviceImageFormatInfo2 with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImageFormatInfo2) WithFlags(y ImageCreateFlags) PhysicalDeviceImageFormatInfo2 {
	x.flags = *( /* typedef */ (*C.VkImageCreateFlags)(&y))
	return x
}
func (x *PhysicalDeviceImageFormatInfo2) SetFlags(y ImageCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkImageCreateFlags)(&y))
}

// QueueFamilyProperties2 provides a go interface for VkQueueFamilyProperties2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFamilyProperties2.html
type QueueFamilyProperties2 C.struct_VkQueueFamilyProperties2

// SizeofQueueFamilyProperties2 is the memory size of a QueueFamilyProperties2
var SizeofQueueFamilyProperties2 int = int(unsafe.Sizeof(QueueFamilyProperties2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x QueueFamilyProperties2) ArpPtr(arp *AutoReleasePool) *QueueFamilyProperties2 {
	ptr := newCBlock(cULong(SizeofQueueFamilyProperties2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*QueueFamilyProperties2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *QueueFamilyProperties2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x QueueFamilyProperties2) AsCPtr() *QueueFamilyProperties2 {
	clone := (*QueueFamilyProperties2)(newCBlock(cULong(SizeofQueueFamilyProperties2)))
	*clone = x
	return clone
}

// QueueFamilyProperties2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func QueueFamilyProperties2CSlice(arp *AutoReleasePool, x ...QueueFamilyProperties2) []QueueFamilyProperties2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofQueueFamilyProperties2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*QueueFamilyProperties2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// QueueFamilyProperties2FreeCSlice releases the memory allocated by QueueFamilyProperties2MakeCSlice.
// It does not free pointers stored inside the slice.
func QueueFamilyProperties2FreeCSlice(x []QueueFamilyProperties2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// QueueFamilyProperties2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. QueueFamilyProperties2FreeCSlice must be called on the returned slice.
func QueueFamilyProperties2MakeCSlice(x ...QueueFamilyProperties2) []QueueFamilyProperties2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofQueueFamilyProperties2 * len(x)
	dst := unsafe.Slice((*QueueFamilyProperties2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkQueueFamilyProperties2
func (x QueueFamilyProperties2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new QueueFamilyProperties2 with the value of
// SType to the value provided in the specification.
func (x QueueFamilyProperties2) WithDefaultSType() QueueFamilyProperties2 {
	return x.WithSType(VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *QueueFamilyProperties2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2)
}

// WithSType clones a new QueueFamilyProperties2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x QueueFamilyProperties2) WithSType(y StructureType) QueueFamilyProperties2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *QueueFamilyProperties2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkQueueFamilyProperties2
func (x QueueFamilyProperties2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new QueueFamilyProperties2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x QueueFamilyProperties2) WithPNext(y unsafe.Pointer) QueueFamilyProperties2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *QueueFamilyProperties2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// QueueFamilyProperties returns the value of queueFamilyProperties from VkQueueFamilyProperties2
func (x QueueFamilyProperties2) QueueFamilyProperties() QueueFamilyProperties {
	ptr := /* typedef */ (*QueueFamilyProperties)(&x.queueFamilyProperties)
	return *ptr
}

// PhysicalDeviceMemoryProperties2 provides a go interface for VkPhysicalDeviceMemoryProperties2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryProperties2.html
type PhysicalDeviceMemoryProperties2 C.struct_VkPhysicalDeviceMemoryProperties2

// SizeofPhysicalDeviceMemoryProperties2 is the memory size of a PhysicalDeviceMemoryProperties2
var SizeofPhysicalDeviceMemoryProperties2 int = int(unsafe.Sizeof(PhysicalDeviceMemoryProperties2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceMemoryProperties2) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceMemoryProperties2 {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceMemoryProperties2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceMemoryProperties2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceMemoryProperties2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceMemoryProperties2) AsCPtr() *PhysicalDeviceMemoryProperties2 {
	clone := (*PhysicalDeviceMemoryProperties2)(newCBlock(cULong(SizeofPhysicalDeviceMemoryProperties2)))
	*clone = x
	return clone
}

// PhysicalDeviceMemoryProperties2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceMemoryProperties2CSlice(arp *AutoReleasePool, x ...PhysicalDeviceMemoryProperties2) []PhysicalDeviceMemoryProperties2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceMemoryProperties2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceMemoryProperties2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceMemoryProperties2FreeCSlice releases the memory allocated by PhysicalDeviceMemoryProperties2MakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceMemoryProperties2FreeCSlice(x []PhysicalDeviceMemoryProperties2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceMemoryProperties2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceMemoryProperties2FreeCSlice must be called on the returned slice.
func PhysicalDeviceMemoryProperties2MakeCSlice(x ...PhysicalDeviceMemoryProperties2) []PhysicalDeviceMemoryProperties2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceMemoryProperties2 * len(x)
	dst := unsafe.Slice((*PhysicalDeviceMemoryProperties2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceMemoryProperties2
func (x PhysicalDeviceMemoryProperties2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceMemoryProperties2 with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceMemoryProperties2) WithDefaultSType() PhysicalDeviceMemoryProperties2 {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceMemoryProperties2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2)
}

// WithSType clones a new PhysicalDeviceMemoryProperties2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMemoryProperties2) WithSType(y StructureType) PhysicalDeviceMemoryProperties2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceMemoryProperties2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceMemoryProperties2
func (x PhysicalDeviceMemoryProperties2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceMemoryProperties2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMemoryProperties2) WithPNext(y unsafe.Pointer) PhysicalDeviceMemoryProperties2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceMemoryProperties2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// MemoryProperties returns the value of memoryProperties from VkPhysicalDeviceMemoryProperties2
func (x PhysicalDeviceMemoryProperties2) MemoryProperties() PhysicalDeviceMemoryProperties {
	ptr := /* typedef */ (*PhysicalDeviceMemoryProperties)(&x.memoryProperties)
	return *ptr
}

// SparseImageFormatProperties2 provides a go interface for VkSparseImageFormatProperties2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageFormatProperties2.html
type SparseImageFormatProperties2 C.struct_VkSparseImageFormatProperties2

// SizeofSparseImageFormatProperties2 is the memory size of a SparseImageFormatProperties2
var SizeofSparseImageFormatProperties2 int = int(unsafe.Sizeof(SparseImageFormatProperties2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SparseImageFormatProperties2) ArpPtr(arp *AutoReleasePool) *SparseImageFormatProperties2 {
	ptr := newCBlock(cULong(SizeofSparseImageFormatProperties2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SparseImageFormatProperties2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SparseImageFormatProperties2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SparseImageFormatProperties2) AsCPtr() *SparseImageFormatProperties2 {
	clone := (*SparseImageFormatProperties2)(newCBlock(cULong(SizeofSparseImageFormatProperties2)))
	*clone = x
	return clone
}

// SparseImageFormatProperties2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SparseImageFormatProperties2CSlice(arp *AutoReleasePool, x ...SparseImageFormatProperties2) []SparseImageFormatProperties2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageFormatProperties2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SparseImageFormatProperties2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SparseImageFormatProperties2FreeCSlice releases the memory allocated by SparseImageFormatProperties2MakeCSlice.
// It does not free pointers stored inside the slice.
func SparseImageFormatProperties2FreeCSlice(x []SparseImageFormatProperties2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SparseImageFormatProperties2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SparseImageFormatProperties2FreeCSlice must be called on the returned slice.
func SparseImageFormatProperties2MakeCSlice(x ...SparseImageFormatProperties2) []SparseImageFormatProperties2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageFormatProperties2 * len(x)
	dst := unsafe.Slice((*SparseImageFormatProperties2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSparseImageFormatProperties2
func (x SparseImageFormatProperties2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new SparseImageFormatProperties2 with the value of
// SType to the value provided in the specification.
func (x SparseImageFormatProperties2) WithDefaultSType() SparseImageFormatProperties2 {
	return x.WithSType(VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *SparseImageFormatProperties2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2)
}

// WithSType clones a new SparseImageFormatProperties2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageFormatProperties2) WithSType(y StructureType) SparseImageFormatProperties2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *SparseImageFormatProperties2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkSparseImageFormatProperties2
func (x SparseImageFormatProperties2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new SparseImageFormatProperties2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageFormatProperties2) WithPNext(y unsafe.Pointer) SparseImageFormatProperties2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *SparseImageFormatProperties2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Properties returns the value of properties from VkSparseImageFormatProperties2
func (x SparseImageFormatProperties2) Properties() SparseImageFormatProperties {
	ptr := /* typedef */ (*SparseImageFormatProperties)(&x.properties)
	return *ptr
}

// PhysicalDeviceSparseImageFormatInfo2 provides a go interface for VkPhysicalDeviceSparseImageFormatInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSparseImageFormatInfo2.html
type PhysicalDeviceSparseImageFormatInfo2 C.struct_VkPhysicalDeviceSparseImageFormatInfo2

// SizeofPhysicalDeviceSparseImageFormatInfo2 is the memory size of a PhysicalDeviceSparseImageFormatInfo2
var SizeofPhysicalDeviceSparseImageFormatInfo2 int = int(unsafe.Sizeof(PhysicalDeviceSparseImageFormatInfo2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceSparseImageFormatInfo2) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceSparseImageFormatInfo2 {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceSparseImageFormatInfo2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceSparseImageFormatInfo2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceSparseImageFormatInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceSparseImageFormatInfo2) AsCPtr() *PhysicalDeviceSparseImageFormatInfo2 {
	clone := (*PhysicalDeviceSparseImageFormatInfo2)(newCBlock(cULong(SizeofPhysicalDeviceSparseImageFormatInfo2)))
	*clone = x
	return clone
}

// PhysicalDeviceSparseImageFormatInfo2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceSparseImageFormatInfo2CSlice(arp *AutoReleasePool, x ...PhysicalDeviceSparseImageFormatInfo2) []PhysicalDeviceSparseImageFormatInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSparseImageFormatInfo2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceSparseImageFormatInfo2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceSparseImageFormatInfo2FreeCSlice releases the memory allocated by PhysicalDeviceSparseImageFormatInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceSparseImageFormatInfo2FreeCSlice(x []PhysicalDeviceSparseImageFormatInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceSparseImageFormatInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceSparseImageFormatInfo2FreeCSlice must be called on the returned slice.
func PhysicalDeviceSparseImageFormatInfo2MakeCSlice(x ...PhysicalDeviceSparseImageFormatInfo2) []PhysicalDeviceSparseImageFormatInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSparseImageFormatInfo2 * len(x)
	dst := unsafe.Slice((*PhysicalDeviceSparseImageFormatInfo2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceSparseImageFormatInfo2
func (x PhysicalDeviceSparseImageFormatInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceSparseImageFormatInfo2 with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceSparseImageFormatInfo2) WithDefaultSType() PhysicalDeviceSparseImageFormatInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceSparseImageFormatInfo2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2)
}

// WithSType clones a new PhysicalDeviceSparseImageFormatInfo2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSparseImageFormatInfo2) WithSType(y StructureType) PhysicalDeviceSparseImageFormatInfo2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceSparseImageFormatInfo2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceSparseImageFormatInfo2
func (x PhysicalDeviceSparseImageFormatInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceSparseImageFormatInfo2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSparseImageFormatInfo2) WithPNext(y unsafe.Pointer) PhysicalDeviceSparseImageFormatInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceSparseImageFormatInfo2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Format returns the value of format from VkPhysicalDeviceSparseImageFormatInfo2
func (x PhysicalDeviceSparseImageFormatInfo2) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format)
	return *ptr
}

// WithFormat clones a new PhysicalDeviceSparseImageFormatInfo2 with the value of
// Format updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSparseImageFormatInfo2) WithFormat(y Format) PhysicalDeviceSparseImageFormatInfo2 {
	x.format = *( /* typedef */ (*C.VkFormat)(&y))
	return x
}
func (x *PhysicalDeviceSparseImageFormatInfo2) SetFormat(y Format) {
	x.format = *( /* typedef */ (*C.VkFormat)(&y))
}

// Type_ returns the value of type from VkPhysicalDeviceSparseImageFormatInfo2
func (x PhysicalDeviceSparseImageFormatInfo2) Type_() ImageType {
	ptr := /* typedef */ (*ImageType)(&x._type)
	return *ptr
}

// WithType_ clones a new PhysicalDeviceSparseImageFormatInfo2 with the value of
// Type_ updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSparseImageFormatInfo2) WithType_(y ImageType) PhysicalDeviceSparseImageFormatInfo2 {
	x._type = *( /* typedef */ (*C.VkImageType)(&y))
	return x
}
func (x *PhysicalDeviceSparseImageFormatInfo2) SetType_(y ImageType) {
	x._type = *( /* typedef */ (*C.VkImageType)(&y))
}

// Samples returns the value of samples from VkPhysicalDeviceSparseImageFormatInfo2
func (x PhysicalDeviceSparseImageFormatInfo2) Samples() SampleCountFlagBits {
	ptr := /* typedef */ (*SampleCountFlagBits)(&x.samples)
	return *ptr
}

// WithSamples clones a new PhysicalDeviceSparseImageFormatInfo2 with the value of
// Samples updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSparseImageFormatInfo2) WithSamples(y SampleCountFlagBits) PhysicalDeviceSparseImageFormatInfo2 {
	x.samples = *( /* typedef */ (*C.VkSampleCountFlagBits)(&y))
	return x
}
func (x *PhysicalDeviceSparseImageFormatInfo2) SetSamples(y SampleCountFlagBits) {
	x.samples = *( /* typedef */ (*C.VkSampleCountFlagBits)(&y))
}

// Usage returns the value of usage from VkPhysicalDeviceSparseImageFormatInfo2
func (x PhysicalDeviceSparseImageFormatInfo2) Usage() ImageUsageFlags {
	ptr := /* typedef */ (*ImageUsageFlags)(&x.usage)
	return *ptr
}

// WithUsage clones a new PhysicalDeviceSparseImageFormatInfo2 with the value of
// Usage updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSparseImageFormatInfo2) WithUsage(y ImageUsageFlags) PhysicalDeviceSparseImageFormatInfo2 {
	x.usage = *( /* typedef */ (*C.VkImageUsageFlags)(&y))
	return x
}
func (x *PhysicalDeviceSparseImageFormatInfo2) SetUsage(y ImageUsageFlags) {
	x.usage = *( /* typedef */ (*C.VkImageUsageFlags)(&y))
}

// Tiling returns the value of tiling from VkPhysicalDeviceSparseImageFormatInfo2
func (x PhysicalDeviceSparseImageFormatInfo2) Tiling() ImageTiling {
	ptr := /* typedef */ (*ImageTiling)(&x.tiling)
	return *ptr
}

// WithTiling clones a new PhysicalDeviceSparseImageFormatInfo2 with the value of
// Tiling updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSparseImageFormatInfo2) WithTiling(y ImageTiling) PhysicalDeviceSparseImageFormatInfo2 {
	x.tiling = *( /* typedef */ (*C.VkImageTiling)(&y))
	return x
}
func (x *PhysicalDeviceSparseImageFormatInfo2) SetTiling(y ImageTiling) {
	x.tiling = *( /* typedef */ (*C.VkImageTiling)(&y))
}

// SamplerYcbcrConversionInfo provides a go interface for VkSamplerYcbcrConversionInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerYcbcrConversionInfo.html
type SamplerYcbcrConversionInfo C.struct_VkSamplerYcbcrConversionInfo

// SizeofSamplerYcbcrConversionInfo is the memory size of a SamplerYcbcrConversionInfo
var SizeofSamplerYcbcrConversionInfo int = int(unsafe.Sizeof(SamplerYcbcrConversionInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SamplerYcbcrConversionInfo) ArpPtr(arp *AutoReleasePool) *SamplerYcbcrConversionInfo {
	ptr := newCBlock(cULong(SizeofSamplerYcbcrConversionInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SamplerYcbcrConversionInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SamplerYcbcrConversionInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SamplerYcbcrConversionInfo) AsCPtr() *SamplerYcbcrConversionInfo {
	clone := (*SamplerYcbcrConversionInfo)(newCBlock(cULong(SizeofSamplerYcbcrConversionInfo)))
	*clone = x
	return clone
}

// SamplerYcbcrConversionInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SamplerYcbcrConversionInfoCSlice(arp *AutoReleasePool, x ...SamplerYcbcrConversionInfo) []SamplerYcbcrConversionInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSamplerYcbcrConversionInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SamplerYcbcrConversionInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SamplerYcbcrConversionInfoFreeCSlice releases the memory allocated by SamplerYcbcrConversionInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SamplerYcbcrConversionInfoFreeCSlice(x []SamplerYcbcrConversionInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SamplerYcbcrConversionInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SamplerYcbcrConversionInfoFreeCSlice must be called on the returned slice.
func SamplerYcbcrConversionInfoMakeCSlice(x ...SamplerYcbcrConversionInfo) []SamplerYcbcrConversionInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSamplerYcbcrConversionInfo * len(x)
	dst := unsafe.Slice((*SamplerYcbcrConversionInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSamplerYcbcrConversionInfo
func (x SamplerYcbcrConversionInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new SamplerYcbcrConversionInfo with the value of
// SType to the value provided in the specification.
func (x SamplerYcbcrConversionInfo) WithDefaultSType() SamplerYcbcrConversionInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *SamplerYcbcrConversionInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO)
}

// WithSType clones a new SamplerYcbcrConversionInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionInfo) WithSType(y StructureType) SamplerYcbcrConversionInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *SamplerYcbcrConversionInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkSamplerYcbcrConversionInfo
func (x SamplerYcbcrConversionInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new SamplerYcbcrConversionInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionInfo) WithPNext(y unsafe.Pointer) SamplerYcbcrConversionInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *SamplerYcbcrConversionInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Conversion returns the value of conversion from VkSamplerYcbcrConversionInfo
func (x SamplerYcbcrConversionInfo) Conversion() SamplerYcbcrConversion {
	ptr := /* handle */ (*SamplerYcbcrConversion)(&x.conversion)
	return *ptr
}

// WithConversion clones a new SamplerYcbcrConversionInfo with the value of
// Conversion updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionInfo) WithConversion(y SamplerYcbcrConversion) SamplerYcbcrConversionInfo {
	x.conversion = *( /* handle */ (*C.VkSamplerYcbcrConversion)(&y))
	return x
}
func (x *SamplerYcbcrConversionInfo) SetConversion(y SamplerYcbcrConversion) {
	x.conversion = *( /* handle */ (*C.VkSamplerYcbcrConversion)(&y))
}

// SamplerYcbcrConversionCreateInfo provides a go interface for VkSamplerYcbcrConversionCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerYcbcrConversionCreateInfo.html
type SamplerYcbcrConversionCreateInfo C.struct_VkSamplerYcbcrConversionCreateInfo

// SizeofSamplerYcbcrConversionCreateInfo is the memory size of a SamplerYcbcrConversionCreateInfo
var SizeofSamplerYcbcrConversionCreateInfo int = int(unsafe.Sizeof(SamplerYcbcrConversionCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SamplerYcbcrConversionCreateInfo) ArpPtr(arp *AutoReleasePool) *SamplerYcbcrConversionCreateInfo {
	ptr := newCBlock(cULong(SizeofSamplerYcbcrConversionCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SamplerYcbcrConversionCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SamplerYcbcrConversionCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SamplerYcbcrConversionCreateInfo) AsCPtr() *SamplerYcbcrConversionCreateInfo {
	clone := (*SamplerYcbcrConversionCreateInfo)(newCBlock(cULong(SizeofSamplerYcbcrConversionCreateInfo)))
	*clone = x
	return clone
}

// SamplerYcbcrConversionCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SamplerYcbcrConversionCreateInfoCSlice(arp *AutoReleasePool, x ...SamplerYcbcrConversionCreateInfo) []SamplerYcbcrConversionCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSamplerYcbcrConversionCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SamplerYcbcrConversionCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SamplerYcbcrConversionCreateInfoFreeCSlice releases the memory allocated by SamplerYcbcrConversionCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SamplerYcbcrConversionCreateInfoFreeCSlice(x []SamplerYcbcrConversionCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SamplerYcbcrConversionCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SamplerYcbcrConversionCreateInfoFreeCSlice must be called on the returned slice.
func SamplerYcbcrConversionCreateInfoMakeCSlice(x ...SamplerYcbcrConversionCreateInfo) []SamplerYcbcrConversionCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSamplerYcbcrConversionCreateInfo * len(x)
	dst := unsafe.Slice((*SamplerYcbcrConversionCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new SamplerYcbcrConversionCreateInfo with the value of
// SType to the value provided in the specification.
func (x SamplerYcbcrConversionCreateInfo) WithDefaultSType() SamplerYcbcrConversionCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *SamplerYcbcrConversionCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO)
}

// WithSType clones a new SamplerYcbcrConversionCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithSType(y StructureType) SamplerYcbcrConversionCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *SamplerYcbcrConversionCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new SamplerYcbcrConversionCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithPNext(y unsafe.Pointer) SamplerYcbcrConversionCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *SamplerYcbcrConversionCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Format returns the value of format from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format)
	return *ptr
}

// WithFormat clones a new SamplerYcbcrConversionCreateInfo with the value of
// Format updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithFormat(y Format) SamplerYcbcrConversionCreateInfo {
	x.format = *( /* typedef */ (*C.VkFormat)(&y))
	return x
}
func (x *SamplerYcbcrConversionCreateInfo) SetFormat(y Format) {
	x.format = *( /* typedef */ (*C.VkFormat)(&y))
}

// YcbcrModel returns the value of ycbcrModel from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) YcbcrModel() SamplerYcbcrModelConversion {
	ptr := /* typedef */ (*SamplerYcbcrModelConversion)(&x.ycbcrModel)
	return *ptr
}

// WithYcbcrModel clones a new SamplerYcbcrConversionCreateInfo with the value of
// YcbcrModel updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithYcbcrModel(y SamplerYcbcrModelConversion) SamplerYcbcrConversionCreateInfo {
	x.ycbcrModel = *( /* typedef */ (*C.VkSamplerYcbcrModelConversion)(&y))
	return x
}
func (x *SamplerYcbcrConversionCreateInfo) SetYcbcrModel(y SamplerYcbcrModelConversion) {
	x.ycbcrModel = *( /* typedef */ (*C.VkSamplerYcbcrModelConversion)(&y))
}

// YcbcrRange returns the value of ycbcrRange from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) YcbcrRange() SamplerYcbcrRange {
	ptr := /* typedef */ (*SamplerYcbcrRange)(&x.ycbcrRange)
	return *ptr
}

// WithYcbcrRange clones a new SamplerYcbcrConversionCreateInfo with the value of
// YcbcrRange updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithYcbcrRange(y SamplerYcbcrRange) SamplerYcbcrConversionCreateInfo {
	x.ycbcrRange = *( /* typedef */ (*C.VkSamplerYcbcrRange)(&y))
	return x
}
func (x *SamplerYcbcrConversionCreateInfo) SetYcbcrRange(y SamplerYcbcrRange) {
	x.ycbcrRange = *( /* typedef */ (*C.VkSamplerYcbcrRange)(&y))
}

// Components returns the value of components from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) Components() ComponentMapping {
	ptr := /* typedef */ (*ComponentMapping)(&x.components)
	return *ptr
}

// WithComponents clones a new SamplerYcbcrConversionCreateInfo with the value of
// Components updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithComponents(y ComponentMapping) SamplerYcbcrConversionCreateInfo {
	x.components = *( /* typedef */ (*C.struct_VkComponentMapping)(&y))
	return x
}
func (x *SamplerYcbcrConversionCreateInfo) SetComponents(y ComponentMapping) {
	x.components = *( /* typedef */ (*C.struct_VkComponentMapping)(&y))
}

// XChromaOffset returns the value of xChromaOffset from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) XChromaOffset() ChromaLocation {
	ptr := /* typedef */ (*ChromaLocation)(&x.xChromaOffset)
	return *ptr
}

// WithXChromaOffset clones a new SamplerYcbcrConversionCreateInfo with the value of
// XChromaOffset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithXChromaOffset(y ChromaLocation) SamplerYcbcrConversionCreateInfo {
	x.xChromaOffset = *( /* typedef */ (*C.VkChromaLocation)(&y))
	return x
}
func (x *SamplerYcbcrConversionCreateInfo) SetXChromaOffset(y ChromaLocation) {
	x.xChromaOffset = *( /* typedef */ (*C.VkChromaLocation)(&y))
}

// YChromaOffset returns the value of yChromaOffset from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) YChromaOffset() ChromaLocation {
	ptr := /* typedef */ (*ChromaLocation)(&x.yChromaOffset)
	return *ptr
}

// WithYChromaOffset clones a new SamplerYcbcrConversionCreateInfo with the value of
// YChromaOffset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithYChromaOffset(y ChromaLocation) SamplerYcbcrConversionCreateInfo {
	x.yChromaOffset = *( /* typedef */ (*C.VkChromaLocation)(&y))
	return x
}
func (x *SamplerYcbcrConversionCreateInfo) SetYChromaOffset(y ChromaLocation) {
	x.yChromaOffset = *( /* typedef */ (*C.VkChromaLocation)(&y))
}

// ChromaFilter returns the value of chromaFilter from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) ChromaFilter() Filter {
	ptr := /* typedef */ (*Filter)(&x.chromaFilter)
	return *ptr
}

// WithChromaFilter clones a new SamplerYcbcrConversionCreateInfo with the value of
// ChromaFilter updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithChromaFilter(y Filter) SamplerYcbcrConversionCreateInfo {
	x.chromaFilter = *( /* typedef */ (*C.VkFilter)(&y))
	return x
}
func (x *SamplerYcbcrConversionCreateInfo) SetChromaFilter(y Filter) {
	x.chromaFilter = *( /* typedef */ (*C.VkFilter)(&y))
}

// ForceExplicitReconstruction returns the value of forceExplicitReconstruction from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) ForceExplicitReconstruction() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.forceExplicitReconstruction)
	return *ptr
}

// WithForceExplicitReconstruction clones a new SamplerYcbcrConversionCreateInfo with the value of
// ForceExplicitReconstruction updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithForceExplicitReconstruction(y Bool32) SamplerYcbcrConversionCreateInfo {
	x.forceExplicitReconstruction = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *SamplerYcbcrConversionCreateInfo) SetForceExplicitReconstruction(y Bool32) {
	x.forceExplicitReconstruction = *( /* typedef */ (*C.VkBool32)(&y))
}

// PhysicalDeviceShaderDrawParameterFeatures is an alias to PhysicalDeviceShaderDrawParametersFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderDrawParameterFeatures.html
//
// Deprecated: Most Aliases in the Vulkan spec are for compatibility purposes as extensions get
// promoted to features. If possible, update code to use the promoted name: PhysicalDeviceShaderDrawParametersFeatures.
type PhysicalDeviceShaderDrawParameterFeatures = PhysicalDeviceShaderDrawParametersFeatures

// RenderPassMultiviewCreateInfo provides a go interface for VkRenderPassMultiviewCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassMultiviewCreateInfo.html
type RenderPassMultiviewCreateInfo C.struct_VkRenderPassMultiviewCreateInfo

// SizeofRenderPassMultiviewCreateInfo is the memory size of a RenderPassMultiviewCreateInfo
var SizeofRenderPassMultiviewCreateInfo int = int(unsafe.Sizeof(RenderPassMultiviewCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x RenderPassMultiviewCreateInfo) ArpPtr(arp *AutoReleasePool) *RenderPassMultiviewCreateInfo {
	ptr := newCBlock(cULong(SizeofRenderPassMultiviewCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*RenderPassMultiviewCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *RenderPassMultiviewCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x RenderPassMultiviewCreateInfo) AsCPtr() *RenderPassMultiviewCreateInfo {
	clone := (*RenderPassMultiviewCreateInfo)(newCBlock(cULong(SizeofRenderPassMultiviewCreateInfo)))
	*clone = x
	return clone
}

// RenderPassMultiviewCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func RenderPassMultiviewCreateInfoCSlice(arp *AutoReleasePool, x ...RenderPassMultiviewCreateInfo) []RenderPassMultiviewCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderPassMultiviewCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*RenderPassMultiviewCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// RenderPassMultiviewCreateInfoFreeCSlice releases the memory allocated by RenderPassMultiviewCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func RenderPassMultiviewCreateInfoFreeCSlice(x []RenderPassMultiviewCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// RenderPassMultiviewCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. RenderPassMultiviewCreateInfoFreeCSlice must be called on the returned slice.
func RenderPassMultiviewCreateInfoMakeCSlice(x ...RenderPassMultiviewCreateInfo) []RenderPassMultiviewCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderPassMultiviewCreateInfo * len(x)
	dst := unsafe.Slice((*RenderPassMultiviewCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkRenderPassMultiviewCreateInfo
func (x RenderPassMultiviewCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new RenderPassMultiviewCreateInfo with the value of
// SType to the value provided in the specification.
func (x RenderPassMultiviewCreateInfo) WithDefaultSType() RenderPassMultiviewCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *RenderPassMultiviewCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO)
}

// WithSType clones a new RenderPassMultiviewCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassMultiviewCreateInfo) WithSType(y StructureType) RenderPassMultiviewCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *RenderPassMultiviewCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkRenderPassMultiviewCreateInfo
func (x RenderPassMultiviewCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new RenderPassMultiviewCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassMultiviewCreateInfo) WithPNext(y unsafe.Pointer) RenderPassMultiviewCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *RenderPassMultiviewCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SubpassCount returns the value of subpassCount from VkRenderPassMultiviewCreateInfo
func (x RenderPassMultiviewCreateInfo) SubpassCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.subpassCount)
	return *ptr
}

// WithSubpassCount clones a new RenderPassMultiviewCreateInfo with the value of
// SubpassCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassMultiviewCreateInfo) WithSubpassCount(y uint32) RenderPassMultiviewCreateInfo {
	x.subpassCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *RenderPassMultiviewCreateInfo) SetSubpassCount(y uint32) {
	x.subpassCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PViewMasks returns the value of pViewMasks from VkRenderPassMultiviewCreateInfo
func (x RenderPassMultiviewCreateInfo) PViewMasks() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pViewMasks)
	return *ptr
}

// WithPViewMasks clones a new RenderPassMultiviewCreateInfo with the value of
// PViewMasks updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SubpassCount as the length of this field.
// SubpassCount is updated with the length of the new value.
func (x RenderPassMultiviewCreateInfo) WithPViewMasks(y []uint32) RenderPassMultiviewCreateInfo {
	x.pViewMasks = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithSubpassCount(uint32(len(y)))
}
func (x *RenderPassMultiviewCreateInfo) SetPViewMasks(y []uint32) {
	x.pViewMasks = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetSubpassCount(uint32(len(y)))
}

// DependencyCount returns the value of dependencyCount from VkRenderPassMultiviewCreateInfo
func (x RenderPassMultiviewCreateInfo) DependencyCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dependencyCount)
	return *ptr
}

// WithDependencyCount clones a new RenderPassMultiviewCreateInfo with the value of
// DependencyCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassMultiviewCreateInfo) WithDependencyCount(y uint32) RenderPassMultiviewCreateInfo {
	x.dependencyCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *RenderPassMultiviewCreateInfo) SetDependencyCount(y uint32) {
	x.dependencyCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PViewOffsets returns the value of pViewOffsets from VkRenderPassMultiviewCreateInfo
func (x RenderPassMultiviewCreateInfo) PViewOffsets() []int32 {
	ptr := func(x **C.int32_t) *[]int32 { /* Slice */
		slc := unsafe.Slice((*int32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pViewOffsets)
	return *ptr
}

// WithPViewOffsets clones a new RenderPassMultiviewCreateInfo with the value of
// PViewOffsets updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DependencyCount as the length of this field.
// DependencyCount is updated with the length of the new value.
func (x RenderPassMultiviewCreateInfo) WithPViewOffsets(y []int32) RenderPassMultiviewCreateInfo {
	x.pViewOffsets = *(func(x *[]int32) **C.int32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.int32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.int32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithDependencyCount(uint32(len(y)))
}
func (x *RenderPassMultiviewCreateInfo) SetPViewOffsets(y []int32) {
	x.pViewOffsets = *(func(x *[]int32) **C.int32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.int32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.int32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetDependencyCount(uint32(len(y)))
}

// CorrelationMaskCount returns the value of correlationMaskCount from VkRenderPassMultiviewCreateInfo
func (x RenderPassMultiviewCreateInfo) CorrelationMaskCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.correlationMaskCount)
	return *ptr
}

// WithCorrelationMaskCount clones a new RenderPassMultiviewCreateInfo with the value of
// CorrelationMaskCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassMultiviewCreateInfo) WithCorrelationMaskCount(y uint32) RenderPassMultiviewCreateInfo {
	x.correlationMaskCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *RenderPassMultiviewCreateInfo) SetCorrelationMaskCount(y uint32) {
	x.correlationMaskCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PCorrelationMasks returns the value of pCorrelationMasks from VkRenderPassMultiviewCreateInfo
func (x RenderPassMultiviewCreateInfo) PCorrelationMasks() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pCorrelationMasks)
	return *ptr
}

// WithPCorrelationMasks clones a new RenderPassMultiviewCreateInfo with the value of
// PCorrelationMasks updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines CorrelationMaskCount as the length of this field.
// CorrelationMaskCount is updated with the length of the new value.
func (x RenderPassMultiviewCreateInfo) WithPCorrelationMasks(y []uint32) RenderPassMultiviewCreateInfo {
	x.pCorrelationMasks = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithCorrelationMaskCount(uint32(len(y)))
}
func (x *RenderPassMultiviewCreateInfo) SetPCorrelationMasks(y []uint32) {
	x.pCorrelationMasks = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetCorrelationMaskCount(uint32(len(y)))
}

// ProtectedSubmitInfo provides a go interface for VkProtectedSubmitInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkProtectedSubmitInfo.html
type ProtectedSubmitInfo C.struct_VkProtectedSubmitInfo

// SizeofProtectedSubmitInfo is the memory size of a ProtectedSubmitInfo
var SizeofProtectedSubmitInfo int = int(unsafe.Sizeof(ProtectedSubmitInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ProtectedSubmitInfo) ArpPtr(arp *AutoReleasePool) *ProtectedSubmitInfo {
	ptr := newCBlock(cULong(SizeofProtectedSubmitInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ProtectedSubmitInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ProtectedSubmitInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ProtectedSubmitInfo) AsCPtr() *ProtectedSubmitInfo {
	clone := (*ProtectedSubmitInfo)(newCBlock(cULong(SizeofProtectedSubmitInfo)))
	*clone = x
	return clone
}

// ProtectedSubmitInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ProtectedSubmitInfoCSlice(arp *AutoReleasePool, x ...ProtectedSubmitInfo) []ProtectedSubmitInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofProtectedSubmitInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ProtectedSubmitInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ProtectedSubmitInfoFreeCSlice releases the memory allocated by ProtectedSubmitInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ProtectedSubmitInfoFreeCSlice(x []ProtectedSubmitInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ProtectedSubmitInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ProtectedSubmitInfoFreeCSlice must be called on the returned slice.
func ProtectedSubmitInfoMakeCSlice(x ...ProtectedSubmitInfo) []ProtectedSubmitInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofProtectedSubmitInfo * len(x)
	dst := unsafe.Slice((*ProtectedSubmitInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkProtectedSubmitInfo
func (x ProtectedSubmitInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ProtectedSubmitInfo with the value of
// SType to the value provided in the specification.
func (x ProtectedSubmitInfo) WithDefaultSType() ProtectedSubmitInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ProtectedSubmitInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO)
}

// WithSType clones a new ProtectedSubmitInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ProtectedSubmitInfo) WithSType(y StructureType) ProtectedSubmitInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ProtectedSubmitInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkProtectedSubmitInfo
func (x ProtectedSubmitInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ProtectedSubmitInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ProtectedSubmitInfo) WithPNext(y unsafe.Pointer) ProtectedSubmitInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ProtectedSubmitInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// ProtectedSubmit returns the value of protectedSubmit from VkProtectedSubmitInfo
func (x ProtectedSubmitInfo) ProtectedSubmit() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.protectedSubmit)
	return *ptr
}

// WithProtectedSubmit clones a new ProtectedSubmitInfo with the value of
// ProtectedSubmit updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ProtectedSubmitInfo) WithProtectedSubmit(y Bool32) ProtectedSubmitInfo {
	x.protectedSubmit = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *ProtectedSubmitInfo) SetProtectedSubmit(y Bool32) {
	x.protectedSubmit = *( /* typedef */ (*C.VkBool32)(&y))
}

// DeviceQueueInfo2 provides a go interface for VkDeviceQueueInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueInfo2.html
type DeviceQueueInfo2 C.struct_VkDeviceQueueInfo2

// SizeofDeviceQueueInfo2 is the memory size of a DeviceQueueInfo2
var SizeofDeviceQueueInfo2 int = int(unsafe.Sizeof(DeviceQueueInfo2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DeviceQueueInfo2) ArpPtr(arp *AutoReleasePool) *DeviceQueueInfo2 {
	ptr := newCBlock(cULong(SizeofDeviceQueueInfo2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DeviceQueueInfo2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceQueueInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceQueueInfo2) AsCPtr() *DeviceQueueInfo2 {
	clone := (*DeviceQueueInfo2)(newCBlock(cULong(SizeofDeviceQueueInfo2)))
	*clone = x
	return clone
}

// DeviceQueueInfo2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DeviceQueueInfo2CSlice(arp *AutoReleasePool, x ...DeviceQueueInfo2) []DeviceQueueInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceQueueInfo2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DeviceQueueInfo2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DeviceQueueInfo2FreeCSlice releases the memory allocated by DeviceQueueInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceQueueInfo2FreeCSlice(x []DeviceQueueInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceQueueInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceQueueInfo2FreeCSlice must be called on the returned slice.
func DeviceQueueInfo2MakeCSlice(x ...DeviceQueueInfo2) []DeviceQueueInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceQueueInfo2 * len(x)
	dst := unsafe.Slice((*DeviceQueueInfo2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceQueueInfo2
func (x DeviceQueueInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DeviceQueueInfo2 with the value of
// SType to the value provided in the specification.
func (x DeviceQueueInfo2) WithDefaultSType() DeviceQueueInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DeviceQueueInfo2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2)
}

// WithSType clones a new DeviceQueueInfo2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueInfo2) WithSType(y StructureType) DeviceQueueInfo2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DeviceQueueInfo2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDeviceQueueInfo2
func (x DeviceQueueInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DeviceQueueInfo2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueInfo2) WithPNext(y unsafe.Pointer) DeviceQueueInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DeviceQueueInfo2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkDeviceQueueInfo2
func (x DeviceQueueInfo2) Flags() DeviceQueueCreateFlags {
	ptr := /* typedef */ (*DeviceQueueCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new DeviceQueueInfo2 with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueInfo2) WithFlags(y DeviceQueueCreateFlags) DeviceQueueInfo2 {
	x.flags = *( /* typedef */ (*C.VkDeviceQueueCreateFlags)(&y))
	return x
}
func (x *DeviceQueueInfo2) SetFlags(y DeviceQueueCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkDeviceQueueCreateFlags)(&y))
}

// QueueFamilyIndex returns the value of queueFamilyIndex from VkDeviceQueueInfo2
func (x DeviceQueueInfo2) QueueFamilyIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.queueFamilyIndex)
	return *ptr
}

// WithQueueFamilyIndex clones a new DeviceQueueInfo2 with the value of
// QueueFamilyIndex updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueInfo2) WithQueueFamilyIndex(y uint32) DeviceQueueInfo2 {
	x.queueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DeviceQueueInfo2) SetQueueFamilyIndex(y uint32) {
	x.queueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// QueueIndex returns the value of queueIndex from VkDeviceQueueInfo2
func (x DeviceQueueInfo2) QueueIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.queueIndex)
	return *ptr
}

// WithQueueIndex clones a new DeviceQueueInfo2 with the value of
// QueueIndex updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueInfo2) WithQueueIndex(y uint32) DeviceQueueInfo2 {
	x.queueIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DeviceQueueInfo2) SetQueueIndex(y uint32) {
	x.queueIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PhysicalDeviceVariablePointersFeatures provides a go interface for VkPhysicalDeviceVariablePointersFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVariablePointersFeatures.html
type PhysicalDeviceVariablePointersFeatures C.struct_VkPhysicalDeviceVariablePointersFeatures

// SizeofPhysicalDeviceVariablePointersFeatures is the memory size of a PhysicalDeviceVariablePointersFeatures
var SizeofPhysicalDeviceVariablePointersFeatures int = int(unsafe.Sizeof(PhysicalDeviceVariablePointersFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceVariablePointersFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceVariablePointersFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceVariablePointersFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceVariablePointersFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceVariablePointersFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceVariablePointersFeatures) AsCPtr() *PhysicalDeviceVariablePointersFeatures {
	clone := (*PhysicalDeviceVariablePointersFeatures)(newCBlock(cULong(SizeofPhysicalDeviceVariablePointersFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceVariablePointersFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceVariablePointersFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceVariablePointersFeatures) []PhysicalDeviceVariablePointersFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVariablePointersFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceVariablePointersFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceVariablePointersFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceVariablePointersFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceVariablePointersFeaturesFreeCSlice(x []PhysicalDeviceVariablePointersFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceVariablePointersFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceVariablePointersFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceVariablePointersFeaturesMakeCSlice(x ...PhysicalDeviceVariablePointersFeatures) []PhysicalDeviceVariablePointersFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVariablePointersFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceVariablePointersFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceVariablePointersFeatures
func (x PhysicalDeviceVariablePointersFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceVariablePointersFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceVariablePointersFeatures) WithDefaultSType() PhysicalDeviceVariablePointersFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceVariablePointersFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES)
}

// WithSType clones a new PhysicalDeviceVariablePointersFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVariablePointersFeatures) WithSType(y StructureType) PhysicalDeviceVariablePointersFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceVariablePointersFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceVariablePointersFeatures
func (x PhysicalDeviceVariablePointersFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceVariablePointersFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVariablePointersFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceVariablePointersFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceVariablePointersFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// VariablePointersStorageBuffer returns the value of variablePointersStorageBuffer from VkPhysicalDeviceVariablePointersFeatures
func (x PhysicalDeviceVariablePointersFeatures) VariablePointersStorageBuffer() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.variablePointersStorageBuffer)
	return *ptr
}

// WithVariablePointersStorageBuffer clones a new PhysicalDeviceVariablePointersFeatures with the value of
// VariablePointersStorageBuffer updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVariablePointersFeatures) WithVariablePointersStorageBuffer(y Bool32) PhysicalDeviceVariablePointersFeatures {
	x.variablePointersStorageBuffer = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVariablePointersFeatures) SetVariablePointersStorageBuffer(y Bool32) {
	x.variablePointersStorageBuffer = *( /* typedef */ (*C.VkBool32)(&y))
}

// VariablePointers returns the value of variablePointers from VkPhysicalDeviceVariablePointersFeatures
func (x PhysicalDeviceVariablePointersFeatures) VariablePointers() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.variablePointers)
	return *ptr
}

// WithVariablePointers clones a new PhysicalDeviceVariablePointersFeatures with the value of
// VariablePointers updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVariablePointersFeatures) WithVariablePointers(y Bool32) PhysicalDeviceVariablePointersFeatures {
	x.variablePointers = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVariablePointersFeatures) SetVariablePointers(y Bool32) {
	x.variablePointers = *( /* typedef */ (*C.VkBool32)(&y))
}

// PhysicalDeviceProtectedMemoryFeatures provides a go interface for VkPhysicalDeviceProtectedMemoryFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProtectedMemoryFeatures.html
type PhysicalDeviceProtectedMemoryFeatures C.struct_VkPhysicalDeviceProtectedMemoryFeatures

// SizeofPhysicalDeviceProtectedMemoryFeatures is the memory size of a PhysicalDeviceProtectedMemoryFeatures
var SizeofPhysicalDeviceProtectedMemoryFeatures int = int(unsafe.Sizeof(PhysicalDeviceProtectedMemoryFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceProtectedMemoryFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceProtectedMemoryFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceProtectedMemoryFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceProtectedMemoryFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceProtectedMemoryFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceProtectedMemoryFeatures) AsCPtr() *PhysicalDeviceProtectedMemoryFeatures {
	clone := (*PhysicalDeviceProtectedMemoryFeatures)(newCBlock(cULong(SizeofPhysicalDeviceProtectedMemoryFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceProtectedMemoryFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceProtectedMemoryFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceProtectedMemoryFeatures) []PhysicalDeviceProtectedMemoryFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceProtectedMemoryFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceProtectedMemoryFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceProtectedMemoryFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceProtectedMemoryFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceProtectedMemoryFeaturesFreeCSlice(x []PhysicalDeviceProtectedMemoryFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceProtectedMemoryFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceProtectedMemoryFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceProtectedMemoryFeaturesMakeCSlice(x ...PhysicalDeviceProtectedMemoryFeatures) []PhysicalDeviceProtectedMemoryFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceProtectedMemoryFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceProtectedMemoryFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceProtectedMemoryFeatures
func (x PhysicalDeviceProtectedMemoryFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceProtectedMemoryFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceProtectedMemoryFeatures) WithDefaultSType() PhysicalDeviceProtectedMemoryFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceProtectedMemoryFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES)
}

// WithSType clones a new PhysicalDeviceProtectedMemoryFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceProtectedMemoryFeatures) WithSType(y StructureType) PhysicalDeviceProtectedMemoryFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceProtectedMemoryFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceProtectedMemoryFeatures
func (x PhysicalDeviceProtectedMemoryFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceProtectedMemoryFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceProtectedMemoryFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceProtectedMemoryFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceProtectedMemoryFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// ProtectedMemory returns the value of protectedMemory from VkPhysicalDeviceProtectedMemoryFeatures
func (x PhysicalDeviceProtectedMemoryFeatures) ProtectedMemory() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.protectedMemory)
	return *ptr
}

// WithProtectedMemory clones a new PhysicalDeviceProtectedMemoryFeatures with the value of
// ProtectedMemory updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceProtectedMemoryFeatures) WithProtectedMemory(y Bool32) PhysicalDeviceProtectedMemoryFeatures {
	x.protectedMemory = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceProtectedMemoryFeatures) SetProtectedMemory(y Bool32) {
	x.protectedMemory = *( /* typedef */ (*C.VkBool32)(&y))
}

// ExportSemaphoreCreateInfo provides a go interface for VkExportSemaphoreCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportSemaphoreCreateInfo.html
type ExportSemaphoreCreateInfo C.struct_VkExportSemaphoreCreateInfo

// SizeofExportSemaphoreCreateInfo is the memory size of a ExportSemaphoreCreateInfo
var SizeofExportSemaphoreCreateInfo int = int(unsafe.Sizeof(ExportSemaphoreCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ExportSemaphoreCreateInfo) ArpPtr(arp *AutoReleasePool) *ExportSemaphoreCreateInfo {
	ptr := newCBlock(cULong(SizeofExportSemaphoreCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ExportSemaphoreCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExportSemaphoreCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExportSemaphoreCreateInfo) AsCPtr() *ExportSemaphoreCreateInfo {
	clone := (*ExportSemaphoreCreateInfo)(newCBlock(cULong(SizeofExportSemaphoreCreateInfo)))
	*clone = x
	return clone
}

// ExportSemaphoreCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ExportSemaphoreCreateInfoCSlice(arp *AutoReleasePool, x ...ExportSemaphoreCreateInfo) []ExportSemaphoreCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExportSemaphoreCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ExportSemaphoreCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ExportSemaphoreCreateInfoFreeCSlice releases the memory allocated by ExportSemaphoreCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ExportSemaphoreCreateInfoFreeCSlice(x []ExportSemaphoreCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExportSemaphoreCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExportSemaphoreCreateInfoFreeCSlice must be called on the returned slice.
func ExportSemaphoreCreateInfoMakeCSlice(x ...ExportSemaphoreCreateInfo) []ExportSemaphoreCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExportSemaphoreCreateInfo * len(x)
	dst := unsafe.Slice((*ExportSemaphoreCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkExportSemaphoreCreateInfo
func (x ExportSemaphoreCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ExportSemaphoreCreateInfo with the value of
// SType to the value provided in the specification.
func (x ExportSemaphoreCreateInfo) WithDefaultSType() ExportSemaphoreCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ExportSemaphoreCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO)
}

// WithSType clones a new ExportSemaphoreCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExportSemaphoreCreateInfo) WithSType(y StructureType) ExportSemaphoreCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ExportSemaphoreCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkExportSemaphoreCreateInfo
func (x ExportSemaphoreCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ExportSemaphoreCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExportSemaphoreCreateInfo) WithPNext(y unsafe.Pointer) ExportSemaphoreCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ExportSemaphoreCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// HandleTypes returns the value of handleTypes from VkExportSemaphoreCreateInfo
func (x ExportSemaphoreCreateInfo) HandleTypes() ExternalSemaphoreHandleTypeFlags {
	ptr := /* typedef */ (*ExternalSemaphoreHandleTypeFlags)(&x.handleTypes)
	return *ptr
}

// WithHandleTypes clones a new ExportSemaphoreCreateInfo with the value of
// HandleTypes updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExportSemaphoreCreateInfo) WithHandleTypes(y ExternalSemaphoreHandleTypeFlags) ExportSemaphoreCreateInfo {
	x.handleTypes = *( /* typedef */ (*C.VkExternalSemaphoreHandleTypeFlags)(&y))
	return x
}
func (x *ExportSemaphoreCreateInfo) SetHandleTypes(y ExternalSemaphoreHandleTypeFlags) {
	x.handleTypes = *( /* typedef */ (*C.VkExternalSemaphoreHandleTypeFlags)(&y))
}

// PhysicalDeviceIDProperties provides a go interface for VkPhysicalDeviceIDProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceIDProperties.html
type PhysicalDeviceIDProperties C.struct_VkPhysicalDeviceIDProperties

// SizeofPhysicalDeviceIDProperties is the memory size of a PhysicalDeviceIDProperties
var SizeofPhysicalDeviceIDProperties int = int(unsafe.Sizeof(PhysicalDeviceIDProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceIDProperties) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceIDProperties {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceIDProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceIDProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceIDProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceIDProperties) AsCPtr() *PhysicalDeviceIDProperties {
	clone := (*PhysicalDeviceIDProperties)(newCBlock(cULong(SizeofPhysicalDeviceIDProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceIDPropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceIDPropertiesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceIDProperties) []PhysicalDeviceIDProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceIDProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceIDProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceIDPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceIDPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceIDPropertiesFreeCSlice(x []PhysicalDeviceIDProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceIDPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceIDPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceIDPropertiesMakeCSlice(x ...PhysicalDeviceIDProperties) []PhysicalDeviceIDProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceIDProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceIDProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceIDProperties
func (x PhysicalDeviceIDProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceIDProperties with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceIDProperties) WithDefaultSType() PhysicalDeviceIDProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceIDProperties) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES)
}

// WithSType clones a new PhysicalDeviceIDProperties with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceIDProperties) WithSType(y StructureType) PhysicalDeviceIDProperties {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceIDProperties) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceIDProperties
func (x PhysicalDeviceIDProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceIDProperties with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceIDProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceIDProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceIDProperties) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// DeviceUUID returns the value of deviceUUID from VkPhysicalDeviceIDProperties
func (x PhysicalDeviceIDProperties) DeviceUUID() []byte {
	ptr := func(x *[VK_UUID_SIZE]C.uint8_t) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_UUID_SIZE)
		return &slc
	}(&x.deviceUUID)
	return *ptr
}

// DriverUUID returns the value of driverUUID from VkPhysicalDeviceIDProperties
func (x PhysicalDeviceIDProperties) DriverUUID() []byte {
	ptr := func(x *[VK_UUID_SIZE]C.uint8_t) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_UUID_SIZE)
		return &slc
	}(&x.driverUUID)
	return *ptr
}

// DeviceLUID returns the value of deviceLUID from VkPhysicalDeviceIDProperties
func (x PhysicalDeviceIDProperties) DeviceLUID() []byte {
	ptr := func(x *[VK_LUID_SIZE]C.uint8_t) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_LUID_SIZE)
		return &slc
	}(&x.deviceLUID)
	return *ptr
}

// DeviceNodeMask returns the value of deviceNodeMask from VkPhysicalDeviceIDProperties
func (x PhysicalDeviceIDProperties) DeviceNodeMask() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.deviceNodeMask)
	return *ptr
}

// DeviceLUIDValid returns the value of deviceLUIDValid from VkPhysicalDeviceIDProperties
func (x PhysicalDeviceIDProperties) DeviceLUIDValid() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.deviceLUIDValid)
	return *ptr
}

// ExternalBufferProperties provides a go interface for VkExternalBufferProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalBufferProperties.html
type ExternalBufferProperties C.struct_VkExternalBufferProperties

// SizeofExternalBufferProperties is the memory size of a ExternalBufferProperties
var SizeofExternalBufferProperties int = int(unsafe.Sizeof(ExternalBufferProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ExternalBufferProperties) ArpPtr(arp *AutoReleasePool) *ExternalBufferProperties {
	ptr := newCBlock(cULong(SizeofExternalBufferProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ExternalBufferProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExternalBufferProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExternalBufferProperties) AsCPtr() *ExternalBufferProperties {
	clone := (*ExternalBufferProperties)(newCBlock(cULong(SizeofExternalBufferProperties)))
	*clone = x
	return clone
}

// ExternalBufferPropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ExternalBufferPropertiesCSlice(arp *AutoReleasePool, x ...ExternalBufferProperties) []ExternalBufferProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalBufferProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ExternalBufferProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ExternalBufferPropertiesFreeCSlice releases the memory allocated by ExternalBufferPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func ExternalBufferPropertiesFreeCSlice(x []ExternalBufferProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExternalBufferPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExternalBufferPropertiesFreeCSlice must be called on the returned slice.
func ExternalBufferPropertiesMakeCSlice(x ...ExternalBufferProperties) []ExternalBufferProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalBufferProperties * len(x)
	dst := unsafe.Slice((*ExternalBufferProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkExternalBufferProperties
func (x ExternalBufferProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ExternalBufferProperties with the value of
// SType to the value provided in the specification.
func (x ExternalBufferProperties) WithDefaultSType() ExternalBufferProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ExternalBufferProperties) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES)
}

// WithSType clones a new ExternalBufferProperties with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalBufferProperties) WithSType(y StructureType) ExternalBufferProperties {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ExternalBufferProperties) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkExternalBufferProperties
func (x ExternalBufferProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ExternalBufferProperties with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalBufferProperties) WithPNext(y unsafe.Pointer) ExternalBufferProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ExternalBufferProperties) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// ExternalMemoryProperties returns the value of externalMemoryProperties from VkExternalBufferProperties
func (x ExternalBufferProperties) ExternalMemoryProperties() ExternalMemoryProperties {
	ptr := /* typedef */ (*ExternalMemoryProperties)(&x.externalMemoryProperties)
	return *ptr
}

// PhysicalDeviceProtectedMemoryProperties provides a go interface for VkPhysicalDeviceProtectedMemoryProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProtectedMemoryProperties.html
type PhysicalDeviceProtectedMemoryProperties C.struct_VkPhysicalDeviceProtectedMemoryProperties

// SizeofPhysicalDeviceProtectedMemoryProperties is the memory size of a PhysicalDeviceProtectedMemoryProperties
var SizeofPhysicalDeviceProtectedMemoryProperties int = int(unsafe.Sizeof(PhysicalDeviceProtectedMemoryProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceProtectedMemoryProperties) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceProtectedMemoryProperties {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceProtectedMemoryProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceProtectedMemoryProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceProtectedMemoryProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceProtectedMemoryProperties) AsCPtr() *PhysicalDeviceProtectedMemoryProperties {
	clone := (*PhysicalDeviceProtectedMemoryProperties)(newCBlock(cULong(SizeofPhysicalDeviceProtectedMemoryProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceProtectedMemoryPropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceProtectedMemoryPropertiesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceProtectedMemoryProperties) []PhysicalDeviceProtectedMemoryProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceProtectedMemoryProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceProtectedMemoryProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceProtectedMemoryPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceProtectedMemoryPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceProtectedMemoryPropertiesFreeCSlice(x []PhysicalDeviceProtectedMemoryProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceProtectedMemoryPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceProtectedMemoryPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceProtectedMemoryPropertiesMakeCSlice(x ...PhysicalDeviceProtectedMemoryProperties) []PhysicalDeviceProtectedMemoryProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceProtectedMemoryProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceProtectedMemoryProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceProtectedMemoryProperties
func (x PhysicalDeviceProtectedMemoryProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceProtectedMemoryProperties with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceProtectedMemoryProperties) WithDefaultSType() PhysicalDeviceProtectedMemoryProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceProtectedMemoryProperties) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES)
}

// WithSType clones a new PhysicalDeviceProtectedMemoryProperties with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceProtectedMemoryProperties) WithSType(y StructureType) PhysicalDeviceProtectedMemoryProperties {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceProtectedMemoryProperties) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceProtectedMemoryProperties
func (x PhysicalDeviceProtectedMemoryProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceProtectedMemoryProperties with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceProtectedMemoryProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceProtectedMemoryProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceProtectedMemoryProperties) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// ProtectedNoFault returns the value of protectedNoFault from VkPhysicalDeviceProtectedMemoryProperties
func (x PhysicalDeviceProtectedMemoryProperties) ProtectedNoFault() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.protectedNoFault)
	return *ptr
}

// PhysicalDeviceVariablePointerFeatures is an alias to PhysicalDeviceVariablePointersFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVariablePointerFeatures.html
//
// Deprecated: Most Aliases in the Vulkan spec are for compatibility purposes as extensions get
// promoted to features. If possible, update code to use the promoted name: PhysicalDeviceVariablePointersFeatures.
type PhysicalDeviceVariablePointerFeatures = PhysicalDeviceVariablePointersFeatures

// PhysicalDeviceMultiviewProperties provides a go interface for VkPhysicalDeviceMultiviewProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultiviewProperties.html
type PhysicalDeviceMultiviewProperties C.struct_VkPhysicalDeviceMultiviewProperties

// SizeofPhysicalDeviceMultiviewProperties is the memory size of a PhysicalDeviceMultiviewProperties
var SizeofPhysicalDeviceMultiviewProperties int = int(unsafe.Sizeof(PhysicalDeviceMultiviewProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceMultiviewProperties) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceMultiviewProperties {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceMultiviewProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceMultiviewProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceMultiviewProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceMultiviewProperties) AsCPtr() *PhysicalDeviceMultiviewProperties {
	clone := (*PhysicalDeviceMultiviewProperties)(newCBlock(cULong(SizeofPhysicalDeviceMultiviewProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceMultiviewPropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceMultiviewPropertiesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceMultiviewProperties) []PhysicalDeviceMultiviewProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceMultiviewProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceMultiviewProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceMultiviewPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceMultiviewPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceMultiviewPropertiesFreeCSlice(x []PhysicalDeviceMultiviewProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceMultiviewPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceMultiviewPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceMultiviewPropertiesMakeCSlice(x ...PhysicalDeviceMultiviewProperties) []PhysicalDeviceMultiviewProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceMultiviewProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceMultiviewProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceMultiviewProperties
func (x PhysicalDeviceMultiviewProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceMultiviewProperties with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceMultiviewProperties) WithDefaultSType() PhysicalDeviceMultiviewProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceMultiviewProperties) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES)
}

// WithSType clones a new PhysicalDeviceMultiviewProperties with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMultiviewProperties) WithSType(y StructureType) PhysicalDeviceMultiviewProperties {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceMultiviewProperties) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceMultiviewProperties
func (x PhysicalDeviceMultiviewProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceMultiviewProperties with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMultiviewProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceMultiviewProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceMultiviewProperties) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// MaxMultiviewViewCount returns the value of maxMultiviewViewCount from VkPhysicalDeviceMultiviewProperties
func (x PhysicalDeviceMultiviewProperties) MaxMultiviewViewCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxMultiviewViewCount)
	return *ptr
}

// MaxMultiviewInstanceIndex returns the value of maxMultiviewInstanceIndex from VkPhysicalDeviceMultiviewProperties
func (x PhysicalDeviceMultiviewProperties) MaxMultiviewInstanceIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxMultiviewInstanceIndex)
	return *ptr
}

// PhysicalDeviceMultiviewFeatures provides a go interface for VkPhysicalDeviceMultiviewFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultiviewFeatures.html
type PhysicalDeviceMultiviewFeatures C.struct_VkPhysicalDeviceMultiviewFeatures

// SizeofPhysicalDeviceMultiviewFeatures is the memory size of a PhysicalDeviceMultiviewFeatures
var SizeofPhysicalDeviceMultiviewFeatures int = int(unsafe.Sizeof(PhysicalDeviceMultiviewFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceMultiviewFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceMultiviewFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceMultiviewFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceMultiviewFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceMultiviewFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceMultiviewFeatures) AsCPtr() *PhysicalDeviceMultiviewFeatures {
	clone := (*PhysicalDeviceMultiviewFeatures)(newCBlock(cULong(SizeofPhysicalDeviceMultiviewFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceMultiviewFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceMultiviewFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceMultiviewFeatures) []PhysicalDeviceMultiviewFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceMultiviewFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceMultiviewFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceMultiviewFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceMultiviewFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceMultiviewFeaturesFreeCSlice(x []PhysicalDeviceMultiviewFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceMultiviewFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceMultiviewFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceMultiviewFeaturesMakeCSlice(x ...PhysicalDeviceMultiviewFeatures) []PhysicalDeviceMultiviewFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceMultiviewFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceMultiviewFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceMultiviewFeatures
func (x PhysicalDeviceMultiviewFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceMultiviewFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceMultiviewFeatures) WithDefaultSType() PhysicalDeviceMultiviewFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceMultiviewFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES)
}

// WithSType clones a new PhysicalDeviceMultiviewFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMultiviewFeatures) WithSType(y StructureType) PhysicalDeviceMultiviewFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceMultiviewFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceMultiviewFeatures
func (x PhysicalDeviceMultiviewFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceMultiviewFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMultiviewFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceMultiviewFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceMultiviewFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Multiview returns the value of multiview from VkPhysicalDeviceMultiviewFeatures
func (x PhysicalDeviceMultiviewFeatures) Multiview() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.multiview)
	return *ptr
}

// WithMultiview clones a new PhysicalDeviceMultiviewFeatures with the value of
// Multiview updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMultiviewFeatures) WithMultiview(y Bool32) PhysicalDeviceMultiviewFeatures {
	x.multiview = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceMultiviewFeatures) SetMultiview(y Bool32) {
	x.multiview = *( /* typedef */ (*C.VkBool32)(&y))
}

// MultiviewGeometryShader returns the value of multiviewGeometryShader from VkPhysicalDeviceMultiviewFeatures
func (x PhysicalDeviceMultiviewFeatures) MultiviewGeometryShader() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.multiviewGeometryShader)
	return *ptr
}

// WithMultiviewGeometryShader clones a new PhysicalDeviceMultiviewFeatures with the value of
// MultiviewGeometryShader updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMultiviewFeatures) WithMultiviewGeometryShader(y Bool32) PhysicalDeviceMultiviewFeatures {
	x.multiviewGeometryShader = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceMultiviewFeatures) SetMultiviewGeometryShader(y Bool32) {
	x.multiviewGeometryShader = *( /* typedef */ (*C.VkBool32)(&y))
}

// MultiviewTessellationShader returns the value of multiviewTessellationShader from VkPhysicalDeviceMultiviewFeatures
func (x PhysicalDeviceMultiviewFeatures) MultiviewTessellationShader() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.multiviewTessellationShader)
	return *ptr
}

// WithMultiviewTessellationShader clones a new PhysicalDeviceMultiviewFeatures with the value of
// MultiviewTessellationShader updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMultiviewFeatures) WithMultiviewTessellationShader(y Bool32) PhysicalDeviceMultiviewFeatures {
	x.multiviewTessellationShader = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceMultiviewFeatures) SetMultiviewTessellationShader(y Bool32) {
	x.multiviewTessellationShader = *( /* typedef */ (*C.VkBool32)(&y))
}

// PhysicalDevicePointClippingProperties provides a go interface for VkPhysicalDevicePointClippingProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePointClippingProperties.html
type PhysicalDevicePointClippingProperties C.struct_VkPhysicalDevicePointClippingProperties

// SizeofPhysicalDevicePointClippingProperties is the memory size of a PhysicalDevicePointClippingProperties
var SizeofPhysicalDevicePointClippingProperties int = int(unsafe.Sizeof(PhysicalDevicePointClippingProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDevicePointClippingProperties) ArpPtr(arp *AutoReleasePool) *PhysicalDevicePointClippingProperties {
	ptr := newCBlock(cULong(SizeofPhysicalDevicePointClippingProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDevicePointClippingProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDevicePointClippingProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDevicePointClippingProperties) AsCPtr() *PhysicalDevicePointClippingProperties {
	clone := (*PhysicalDevicePointClippingProperties)(newCBlock(cULong(SizeofPhysicalDevicePointClippingProperties)))
	*clone = x
	return clone
}

// PhysicalDevicePointClippingPropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDevicePointClippingPropertiesCSlice(arp *AutoReleasePool, x ...PhysicalDevicePointClippingProperties) []PhysicalDevicePointClippingProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDevicePointClippingProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDevicePointClippingProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDevicePointClippingPropertiesFreeCSlice releases the memory allocated by PhysicalDevicePointClippingPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDevicePointClippingPropertiesFreeCSlice(x []PhysicalDevicePointClippingProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDevicePointClippingPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDevicePointClippingPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDevicePointClippingPropertiesMakeCSlice(x ...PhysicalDevicePointClippingProperties) []PhysicalDevicePointClippingProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDevicePointClippingProperties * len(x)
	dst := unsafe.Slice((*PhysicalDevicePointClippingProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDevicePointClippingProperties
func (x PhysicalDevicePointClippingProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDevicePointClippingProperties with the value of
// SType to the value provided in the specification.
func (x PhysicalDevicePointClippingProperties) WithDefaultSType() PhysicalDevicePointClippingProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDevicePointClippingProperties) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES)
}

// WithSType clones a new PhysicalDevicePointClippingProperties with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePointClippingProperties) WithSType(y StructureType) PhysicalDevicePointClippingProperties {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDevicePointClippingProperties) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDevicePointClippingProperties
func (x PhysicalDevicePointClippingProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDevicePointClippingProperties with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePointClippingProperties) WithPNext(y unsafe.Pointer) PhysicalDevicePointClippingProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDevicePointClippingProperties) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// PointClippingBehavior returns the value of pointClippingBehavior from VkPhysicalDevicePointClippingProperties
func (x PhysicalDevicePointClippingProperties) PointClippingBehavior() PointClippingBehavior {
	ptr := /* typedef */ (*PointClippingBehavior)(&x.pointClippingBehavior)
	return *ptr
}

// PhysicalDeviceSubgroupProperties provides a go interface for VkPhysicalDeviceSubgroupProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubgroupProperties.html
type PhysicalDeviceSubgroupProperties C.struct_VkPhysicalDeviceSubgroupProperties

// SizeofPhysicalDeviceSubgroupProperties is the memory size of a PhysicalDeviceSubgroupProperties
var SizeofPhysicalDeviceSubgroupProperties int = int(unsafe.Sizeof(PhysicalDeviceSubgroupProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceSubgroupProperties) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceSubgroupProperties {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceSubgroupProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceSubgroupProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceSubgroupProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceSubgroupProperties) AsCPtr() *PhysicalDeviceSubgroupProperties {
	clone := (*PhysicalDeviceSubgroupProperties)(newCBlock(cULong(SizeofPhysicalDeviceSubgroupProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceSubgroupPropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceSubgroupPropertiesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceSubgroupProperties) []PhysicalDeviceSubgroupProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSubgroupProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceSubgroupProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceSubgroupPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceSubgroupPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceSubgroupPropertiesFreeCSlice(x []PhysicalDeviceSubgroupProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceSubgroupPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceSubgroupPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceSubgroupPropertiesMakeCSlice(x ...PhysicalDeviceSubgroupProperties) []PhysicalDeviceSubgroupProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSubgroupProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceSubgroupProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceSubgroupProperties
func (x PhysicalDeviceSubgroupProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceSubgroupProperties with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceSubgroupProperties) WithDefaultSType() PhysicalDeviceSubgroupProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceSubgroupProperties) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES)
}

// WithSType clones a new PhysicalDeviceSubgroupProperties with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSubgroupProperties) WithSType(y StructureType) PhysicalDeviceSubgroupProperties {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceSubgroupProperties) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceSubgroupProperties
func (x PhysicalDeviceSubgroupProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceSubgroupProperties with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSubgroupProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceSubgroupProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceSubgroupProperties) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SubgroupSize returns the value of subgroupSize from VkPhysicalDeviceSubgroupProperties
func (x PhysicalDeviceSubgroupProperties) SubgroupSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.subgroupSize)
	return *ptr
}

// SupportedStages returns the value of supportedStages from VkPhysicalDeviceSubgroupProperties
func (x PhysicalDeviceSubgroupProperties) SupportedStages() ShaderStageFlags {
	ptr := /* typedef */ (*ShaderStageFlags)(&x.supportedStages)
	return *ptr
}

// SupportedOperations returns the value of supportedOperations from VkPhysicalDeviceSubgroupProperties
func (x PhysicalDeviceSubgroupProperties) SupportedOperations() SubgroupFeatureFlags {
	ptr := /* typedef */ (*SubgroupFeatureFlags)(&x.supportedOperations)
	return *ptr
}

// QuadOperationsInAllStages returns the value of quadOperationsInAllStages from VkPhysicalDeviceSubgroupProperties
func (x PhysicalDeviceSubgroupProperties) QuadOperationsInAllStages() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.quadOperationsInAllStages)
	return *ptr
}

// InputAttachmentAspectReference provides a go interface for VkInputAttachmentAspectReference.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInputAttachmentAspectReference.html
type InputAttachmentAspectReference C.struct_VkInputAttachmentAspectReference

// SizeofInputAttachmentAspectReference is the memory size of a InputAttachmentAspectReference
var SizeofInputAttachmentAspectReference int = int(unsafe.Sizeof(InputAttachmentAspectReference{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x InputAttachmentAspectReference) ArpPtr(arp *AutoReleasePool) *InputAttachmentAspectReference {
	ptr := newCBlock(cULong(SizeofInputAttachmentAspectReference))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*InputAttachmentAspectReference)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *InputAttachmentAspectReference) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x InputAttachmentAspectReference) AsCPtr() *InputAttachmentAspectReference {
	clone := (*InputAttachmentAspectReference)(newCBlock(cULong(SizeofInputAttachmentAspectReference)))
	*clone = x
	return clone
}

// InputAttachmentAspectReferenceCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func InputAttachmentAspectReferenceCSlice(arp *AutoReleasePool, x ...InputAttachmentAspectReference) []InputAttachmentAspectReference {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofInputAttachmentAspectReference * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*InputAttachmentAspectReference)(ptr), len(x))
	copy(dst, x)
	return dst
}

// InputAttachmentAspectReferenceFreeCSlice releases the memory allocated by InputAttachmentAspectReferenceMakeCSlice.
// It does not free pointers stored inside the slice.
func InputAttachmentAspectReferenceFreeCSlice(x []InputAttachmentAspectReference) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// InputAttachmentAspectReferenceMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. InputAttachmentAspectReferenceFreeCSlice must be called on the returned slice.
func InputAttachmentAspectReferenceMakeCSlice(x ...InputAttachmentAspectReference) []InputAttachmentAspectReference {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofInputAttachmentAspectReference * len(x)
	dst := unsafe.Slice((*InputAttachmentAspectReference)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Subpass returns the value of subpass from VkInputAttachmentAspectReference
func (x InputAttachmentAspectReference) Subpass() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.subpass)
	return *ptr
}

// WithSubpass clones a new InputAttachmentAspectReference with the value of
// Subpass updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InputAttachmentAspectReference) WithSubpass(y uint32) InputAttachmentAspectReference {
	x.subpass = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *InputAttachmentAspectReference) SetSubpass(y uint32) {
	x.subpass = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// InputAttachmentIndex returns the value of inputAttachmentIndex from VkInputAttachmentAspectReference
func (x InputAttachmentAspectReference) InputAttachmentIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.inputAttachmentIndex)
	return *ptr
}

// WithInputAttachmentIndex clones a new InputAttachmentAspectReference with the value of
// InputAttachmentIndex updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InputAttachmentAspectReference) WithInputAttachmentIndex(y uint32) InputAttachmentAspectReference {
	x.inputAttachmentIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *InputAttachmentAspectReference) SetInputAttachmentIndex(y uint32) {
	x.inputAttachmentIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// AspectMask returns the value of aspectMask from VkInputAttachmentAspectReference
func (x InputAttachmentAspectReference) AspectMask() ImageAspectFlags {
	ptr := /* typedef */ (*ImageAspectFlags)(&x.aspectMask)
	return *ptr
}

// WithAspectMask clones a new InputAttachmentAspectReference with the value of
// AspectMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InputAttachmentAspectReference) WithAspectMask(y ImageAspectFlags) InputAttachmentAspectReference {
	x.aspectMask = *( /* typedef */ (*C.VkImageAspectFlags)(&y))
	return x
}
func (x *InputAttachmentAspectReference) SetAspectMask(y ImageAspectFlags) {
	x.aspectMask = *( /* typedef */ (*C.VkImageAspectFlags)(&y))
}

// RenderPassInputAttachmentAspectCreateInfo provides a go interface for VkRenderPassInputAttachmentAspectCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassInputAttachmentAspectCreateInfo.html
type RenderPassInputAttachmentAspectCreateInfo C.struct_VkRenderPassInputAttachmentAspectCreateInfo

// SizeofRenderPassInputAttachmentAspectCreateInfo is the memory size of a RenderPassInputAttachmentAspectCreateInfo
var SizeofRenderPassInputAttachmentAspectCreateInfo int = int(unsafe.Sizeof(RenderPassInputAttachmentAspectCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x RenderPassInputAttachmentAspectCreateInfo) ArpPtr(arp *AutoReleasePool) *RenderPassInputAttachmentAspectCreateInfo {
	ptr := newCBlock(cULong(SizeofRenderPassInputAttachmentAspectCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*RenderPassInputAttachmentAspectCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *RenderPassInputAttachmentAspectCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x RenderPassInputAttachmentAspectCreateInfo) AsCPtr() *RenderPassInputAttachmentAspectCreateInfo {
	clone := (*RenderPassInputAttachmentAspectCreateInfo)(newCBlock(cULong(SizeofRenderPassInputAttachmentAspectCreateInfo)))
	*clone = x
	return clone
}

// RenderPassInputAttachmentAspectCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func RenderPassInputAttachmentAspectCreateInfoCSlice(arp *AutoReleasePool, x ...RenderPassInputAttachmentAspectCreateInfo) []RenderPassInputAttachmentAspectCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderPassInputAttachmentAspectCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*RenderPassInputAttachmentAspectCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// RenderPassInputAttachmentAspectCreateInfoFreeCSlice releases the memory allocated by RenderPassInputAttachmentAspectCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func RenderPassInputAttachmentAspectCreateInfoFreeCSlice(x []RenderPassInputAttachmentAspectCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// RenderPassInputAttachmentAspectCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. RenderPassInputAttachmentAspectCreateInfoFreeCSlice must be called on the returned slice.
func RenderPassInputAttachmentAspectCreateInfoMakeCSlice(x ...RenderPassInputAttachmentAspectCreateInfo) []RenderPassInputAttachmentAspectCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderPassInputAttachmentAspectCreateInfo * len(x)
	dst := unsafe.Slice((*RenderPassInputAttachmentAspectCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkRenderPassInputAttachmentAspectCreateInfo
func (x RenderPassInputAttachmentAspectCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new RenderPassInputAttachmentAspectCreateInfo with the value of
// SType to the value provided in the specification.
func (x RenderPassInputAttachmentAspectCreateInfo) WithDefaultSType() RenderPassInputAttachmentAspectCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *RenderPassInputAttachmentAspectCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO)
}

// WithSType clones a new RenderPassInputAttachmentAspectCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassInputAttachmentAspectCreateInfo) WithSType(y StructureType) RenderPassInputAttachmentAspectCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *RenderPassInputAttachmentAspectCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkRenderPassInputAttachmentAspectCreateInfo
func (x RenderPassInputAttachmentAspectCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new RenderPassInputAttachmentAspectCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassInputAttachmentAspectCreateInfo) WithPNext(y unsafe.Pointer) RenderPassInputAttachmentAspectCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *RenderPassInputAttachmentAspectCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// AspectReferenceCount returns the value of aspectReferenceCount from VkRenderPassInputAttachmentAspectCreateInfo
func (x RenderPassInputAttachmentAspectCreateInfo) AspectReferenceCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.aspectReferenceCount)
	return *ptr
}

// WithAspectReferenceCount clones a new RenderPassInputAttachmentAspectCreateInfo with the value of
// AspectReferenceCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassInputAttachmentAspectCreateInfo) WithAspectReferenceCount(y uint32) RenderPassInputAttachmentAspectCreateInfo {
	x.aspectReferenceCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *RenderPassInputAttachmentAspectCreateInfo) SetAspectReferenceCount(y uint32) {
	x.aspectReferenceCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PAspectReferences returns the value of pAspectReferences from VkRenderPassInputAttachmentAspectCreateInfo
func (x RenderPassInputAttachmentAspectCreateInfo) PAspectReferences() []InputAttachmentAspectReference {
	ptr := func(x **C.struct_VkInputAttachmentAspectReference) *[]InputAttachmentAspectReference { /* Slice */
		slc := unsafe.Slice((*InputAttachmentAspectReference)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pAspectReferences)
	return *ptr
}

// WithPAspectReferences clones a new RenderPassInputAttachmentAspectCreateInfo with the value of
// PAspectReferences updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines AspectReferenceCount as the length of this field.
// AspectReferenceCount is updated with the length of the new value.
func (x RenderPassInputAttachmentAspectCreateInfo) WithPAspectReferences(y []InputAttachmentAspectReference) RenderPassInputAttachmentAspectCreateInfo {
	x.pAspectReferences = *(func(x *[]InputAttachmentAspectReference) **C.struct_VkInputAttachmentAspectReference { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkInputAttachmentAspectReference)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkInputAttachmentAspectReference)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithAspectReferenceCount(uint32(len(y)))
}
func (x *RenderPassInputAttachmentAspectCreateInfo) SetPAspectReferences(y []InputAttachmentAspectReference) {
	x.pAspectReferences = *(func(x *[]InputAttachmentAspectReference) **C.struct_VkInputAttachmentAspectReference { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkInputAttachmentAspectReference)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkInputAttachmentAspectReference)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetAspectReferenceCount(uint32(len(y)))
}

// ImageViewUsageCreateInfo provides a go interface for VkImageViewUsageCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewUsageCreateInfo.html
type ImageViewUsageCreateInfo C.struct_VkImageViewUsageCreateInfo

// SizeofImageViewUsageCreateInfo is the memory size of a ImageViewUsageCreateInfo
var SizeofImageViewUsageCreateInfo int = int(unsafe.Sizeof(ImageViewUsageCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ImageViewUsageCreateInfo) ArpPtr(arp *AutoReleasePool) *ImageViewUsageCreateInfo {
	ptr := newCBlock(cULong(SizeofImageViewUsageCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ImageViewUsageCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageViewUsageCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageViewUsageCreateInfo) AsCPtr() *ImageViewUsageCreateInfo {
	clone := (*ImageViewUsageCreateInfo)(newCBlock(cULong(SizeofImageViewUsageCreateInfo)))
	*clone = x
	return clone
}

// ImageViewUsageCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ImageViewUsageCreateInfoCSlice(arp *AutoReleasePool, x ...ImageViewUsageCreateInfo) []ImageViewUsageCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageViewUsageCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ImageViewUsageCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ImageViewUsageCreateInfoFreeCSlice releases the memory allocated by ImageViewUsageCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageViewUsageCreateInfoFreeCSlice(x []ImageViewUsageCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageViewUsageCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageViewUsageCreateInfoFreeCSlice must be called on the returned slice.
func ImageViewUsageCreateInfoMakeCSlice(x ...ImageViewUsageCreateInfo) []ImageViewUsageCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageViewUsageCreateInfo * len(x)
	dst := unsafe.Slice((*ImageViewUsageCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageViewUsageCreateInfo
func (x ImageViewUsageCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ImageViewUsageCreateInfo with the value of
// SType to the value provided in the specification.
func (x ImageViewUsageCreateInfo) WithDefaultSType() ImageViewUsageCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ImageViewUsageCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO)
}

// WithSType clones a new ImageViewUsageCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewUsageCreateInfo) WithSType(y StructureType) ImageViewUsageCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ImageViewUsageCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkImageViewUsageCreateInfo
func (x ImageViewUsageCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ImageViewUsageCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewUsageCreateInfo) WithPNext(y unsafe.Pointer) ImageViewUsageCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ImageViewUsageCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Usage returns the value of usage from VkImageViewUsageCreateInfo
func (x ImageViewUsageCreateInfo) Usage() ImageUsageFlags {
	ptr := /* typedef */ (*ImageUsageFlags)(&x.usage)
	return *ptr
}

// WithUsage clones a new ImageViewUsageCreateInfo with the value of
// Usage updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewUsageCreateInfo) WithUsage(y ImageUsageFlags) ImageViewUsageCreateInfo {
	x.usage = *( /* typedef */ (*C.VkImageUsageFlags)(&y))
	return x
}
func (x *ImageViewUsageCreateInfo) SetUsage(y ImageUsageFlags) {
	x.usage = *( /* typedef */ (*C.VkImageUsageFlags)(&y))
}

// ExternalFenceProperties provides a go interface for VkExternalFenceProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalFenceProperties.html
type ExternalFenceProperties C.struct_VkExternalFenceProperties

// SizeofExternalFenceProperties is the memory size of a ExternalFenceProperties
var SizeofExternalFenceProperties int = int(unsafe.Sizeof(ExternalFenceProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ExternalFenceProperties) ArpPtr(arp *AutoReleasePool) *ExternalFenceProperties {
	ptr := newCBlock(cULong(SizeofExternalFenceProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ExternalFenceProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExternalFenceProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExternalFenceProperties) AsCPtr() *ExternalFenceProperties {
	clone := (*ExternalFenceProperties)(newCBlock(cULong(SizeofExternalFenceProperties)))
	*clone = x
	return clone
}

// ExternalFencePropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ExternalFencePropertiesCSlice(arp *AutoReleasePool, x ...ExternalFenceProperties) []ExternalFenceProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalFenceProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ExternalFenceProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ExternalFencePropertiesFreeCSlice releases the memory allocated by ExternalFencePropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func ExternalFencePropertiesFreeCSlice(x []ExternalFenceProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExternalFencePropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExternalFencePropertiesFreeCSlice must be called on the returned slice.
func ExternalFencePropertiesMakeCSlice(x ...ExternalFenceProperties) []ExternalFenceProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalFenceProperties * len(x)
	dst := unsafe.Slice((*ExternalFenceProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkExternalFenceProperties
func (x ExternalFenceProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ExternalFenceProperties with the value of
// SType to the value provided in the specification.
func (x ExternalFenceProperties) WithDefaultSType() ExternalFenceProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ExternalFenceProperties) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES)
}

// WithSType clones a new ExternalFenceProperties with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalFenceProperties) WithSType(y StructureType) ExternalFenceProperties {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ExternalFenceProperties) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkExternalFenceProperties
func (x ExternalFenceProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ExternalFenceProperties with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalFenceProperties) WithPNext(y unsafe.Pointer) ExternalFenceProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ExternalFenceProperties) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// ExportFromImportedHandleTypes returns the value of exportFromImportedHandleTypes from VkExternalFenceProperties
func (x ExternalFenceProperties) ExportFromImportedHandleTypes() ExternalFenceHandleTypeFlags {
	ptr := /* typedef */ (*ExternalFenceHandleTypeFlags)(&x.exportFromImportedHandleTypes)
	return *ptr
}

// CompatibleHandleTypes returns the value of compatibleHandleTypes from VkExternalFenceProperties
func (x ExternalFenceProperties) CompatibleHandleTypes() ExternalFenceHandleTypeFlags {
	ptr := /* typedef */ (*ExternalFenceHandleTypeFlags)(&x.compatibleHandleTypes)
	return *ptr
}

// ExternalFenceFeatures returns the value of externalFenceFeatures from VkExternalFenceProperties
func (x ExternalFenceProperties) ExternalFenceFeatures() ExternalFenceFeatureFlags {
	ptr := /* typedef */ (*ExternalFenceFeatureFlags)(&x.externalFenceFeatures)
	return *ptr
}

// PipelineTessellationDomainOriginStateCreateInfo provides a go interface for VkPipelineTessellationDomainOriginStateCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineTessellationDomainOriginStateCreateInfo.html
type PipelineTessellationDomainOriginStateCreateInfo C.struct_VkPipelineTessellationDomainOriginStateCreateInfo

// SizeofPipelineTessellationDomainOriginStateCreateInfo is the memory size of a PipelineTessellationDomainOriginStateCreateInfo
var SizeofPipelineTessellationDomainOriginStateCreateInfo int = int(unsafe.Sizeof(PipelineTessellationDomainOriginStateCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PipelineTessellationDomainOriginStateCreateInfo) ArpPtr(arp *AutoReleasePool) *PipelineTessellationDomainOriginStateCreateInfo {
	ptr := newCBlock(cULong(SizeofPipelineTessellationDomainOriginStateCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PipelineTessellationDomainOriginStateCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineTessellationDomainOriginStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineTessellationDomainOriginStateCreateInfo) AsCPtr() *PipelineTessellationDomainOriginStateCreateInfo {
	clone := (*PipelineTessellationDomainOriginStateCreateInfo)(newCBlock(cULong(SizeofPipelineTessellationDomainOriginStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineTessellationDomainOriginStateCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PipelineTessellationDomainOriginStateCreateInfoCSlice(arp *AutoReleasePool, x ...PipelineTessellationDomainOriginStateCreateInfo) []PipelineTessellationDomainOriginStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineTessellationDomainOriginStateCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PipelineTessellationDomainOriginStateCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PipelineTessellationDomainOriginStateCreateInfoFreeCSlice releases the memory allocated by PipelineTessellationDomainOriginStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineTessellationDomainOriginStateCreateInfoFreeCSlice(x []PipelineTessellationDomainOriginStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineTessellationDomainOriginStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineTessellationDomainOriginStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineTessellationDomainOriginStateCreateInfoMakeCSlice(x ...PipelineTessellationDomainOriginStateCreateInfo) []PipelineTessellationDomainOriginStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineTessellationDomainOriginStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineTessellationDomainOriginStateCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineTessellationDomainOriginStateCreateInfo
func (x PipelineTessellationDomainOriginStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PipelineTessellationDomainOriginStateCreateInfo with the value of
// SType to the value provided in the specification.
func (x PipelineTessellationDomainOriginStateCreateInfo) WithDefaultSType() PipelineTessellationDomainOriginStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PipelineTessellationDomainOriginStateCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO)
}

// WithSType clones a new PipelineTessellationDomainOriginStateCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineTessellationDomainOriginStateCreateInfo) WithSType(y StructureType) PipelineTessellationDomainOriginStateCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PipelineTessellationDomainOriginStateCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPipelineTessellationDomainOriginStateCreateInfo
func (x PipelineTessellationDomainOriginStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PipelineTessellationDomainOriginStateCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineTessellationDomainOriginStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineTessellationDomainOriginStateCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PipelineTessellationDomainOriginStateCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// DomainOrigin returns the value of domainOrigin from VkPipelineTessellationDomainOriginStateCreateInfo
func (x PipelineTessellationDomainOriginStateCreateInfo) DomainOrigin() TessellationDomainOrigin {
	ptr := /* typedef */ (*TessellationDomainOrigin)(&x.domainOrigin)
	return *ptr
}

// WithDomainOrigin clones a new PipelineTessellationDomainOriginStateCreateInfo with the value of
// DomainOrigin updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineTessellationDomainOriginStateCreateInfo) WithDomainOrigin(y TessellationDomainOrigin) PipelineTessellationDomainOriginStateCreateInfo {
	x.domainOrigin = *( /* typedef */ (*C.VkTessellationDomainOrigin)(&y))
	return x
}
func (x *PipelineTessellationDomainOriginStateCreateInfo) SetDomainOrigin(y TessellationDomainOrigin) {
	x.domainOrigin = *( /* typedef */ (*C.VkTessellationDomainOrigin)(&y))
}

// GetPhysicalDeviceFormatProperties2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFormatProperties2.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceFormatProperties2(format Format, pFormatProperties *FormatProperties2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* typedef */ (*C.VkFormat)(&format)
	p2 := func(x **FormatProperties2) **C.struct_VkFormatProperties2 { /* Pointer */
		g2c := (*C.struct_VkFormatProperties2)(*x)
		return &g2c
	}(&pFormatProperties)
	C.vkGetPhysicalDeviceFormatProperties2(addrs, *p0, *p1, *p2)
}

// GetPhysicalDeviceExternalFenceProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalFenceProperties.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceExternalFenceProperties(pExternalFenceInfo *PhysicalDeviceExternalFenceInfo, pExternalFenceProperties *ExternalFenceProperties) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceExternalFenceInfo) **C.struct_VkPhysicalDeviceExternalFenceInfo { /* Pointer */
		g2c := (*C.struct_VkPhysicalDeviceExternalFenceInfo)(*x)
		return &g2c
	}(&pExternalFenceInfo)
	p2 := func(x **ExternalFenceProperties) **C.struct_VkExternalFenceProperties { /* Pointer */
		g2c := (*C.struct_VkExternalFenceProperties)(*x)
		return &g2c
	}(&pExternalFenceProperties)
	C.vkGetPhysicalDeviceExternalFenceProperties(addrs, *p0, *p1, *p2)
}

// GetPhysicalDeviceExternalBufferProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalBufferProperties.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceExternalBufferProperties(pExternalBufferInfo *PhysicalDeviceExternalBufferInfo, pExternalBufferProperties *ExternalBufferProperties) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceExternalBufferInfo) **C.struct_VkPhysicalDeviceExternalBufferInfo { /* Pointer */
		g2c := (*C.struct_VkPhysicalDeviceExternalBufferInfo)(*x)
		return &g2c
	}(&pExternalBufferInfo)
	p2 := func(x **ExternalBufferProperties) **C.struct_VkExternalBufferProperties { /* Pointer */
		g2c := (*C.struct_VkExternalBufferProperties)(*x)
		return &g2c
	}(&pExternalBufferProperties)
	C.vkGetPhysicalDeviceExternalBufferProperties(addrs, *p0, *p1, *p2)
}

// UpdateDescriptorSetWithTemplate command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUpdateDescriptorSetWithTemplate.html
func (x DeviceFacade) UpdateDescriptorSetWithTemplate(descriptorSet DescriptorSet, descriptorUpdateTemplate DescriptorUpdateTemplate, pData unsafe.Pointer) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDescriptorSet)(&descriptorSet)
	p2 := /* handle */ (*C.VkDescriptorUpdateTemplate)(&descriptorUpdateTemplate)
	p3 := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&pData)
	C.vkUpdateDescriptorSetWithTemplate(addrs, *p0, *p1, *p2, *p3)
}

// DestroyDescriptorUpdateTemplate command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDescriptorUpdateTemplate.html
func (x DeviceFacade) DestroyDescriptorUpdateTemplate(descriptorUpdateTemplate DescriptorUpdateTemplate, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDescriptorUpdateTemplate)(&descriptorUpdateTemplate)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	C.vkDestroyDescriptorUpdateTemplate(addrs, *p0, *p1, *p2)
}

// CreateDescriptorUpdateTemplate command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDescriptorUpdateTemplate.html
func (x DeviceFacade) CreateDescriptorUpdateTemplate(pCreateInfo *DescriptorUpdateTemplateCreateInfo, pAllocator *AllocationCallbacks, pDescriptorUpdateTemplate *DescriptorUpdateTemplate) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DescriptorUpdateTemplateCreateInfo) **C.struct_VkDescriptorUpdateTemplateCreateInfo { /* Pointer */
		g2c := (*C.struct_VkDescriptorUpdateTemplateCreateInfo)(*x)
		return &g2c
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p3 := func(x **DescriptorUpdateTemplate) **C.VkDescriptorUpdateTemplate { /* Pointer */
		g2c := (*C.VkDescriptorUpdateTemplate)(*x)
		return &g2c
	}(&pDescriptorUpdateTemplate)
	ret := C.vkCreateDescriptorUpdateTemplate(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroySamplerYcbcrConversion command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySamplerYcbcrConversion.html
func (x DeviceFacade) DestroySamplerYcbcrConversion(ycbcrConversion SamplerYcbcrConversion, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkSamplerYcbcrConversion)(&ycbcrConversion)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	C.vkDestroySamplerYcbcrConversion(addrs, *p0, *p1, *p2)
}

// CreateSamplerYcbcrConversion command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSamplerYcbcrConversion.html
func (x DeviceFacade) CreateSamplerYcbcrConversion(pCreateInfo *SamplerYcbcrConversionCreateInfo, pAllocator *AllocationCallbacks, pYcbcrConversion *SamplerYcbcrConversion) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **SamplerYcbcrConversionCreateInfo) **C.struct_VkSamplerYcbcrConversionCreateInfo { /* Pointer */
		g2c := (*C.struct_VkSamplerYcbcrConversionCreateInfo)(*x)
		return &g2c
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p3 := func(x **SamplerYcbcrConversion) **C.VkSamplerYcbcrConversion { /* Pointer */
		g2c := (*C.VkSamplerYcbcrConversion)(*x)
		return &g2c
	}(&pYcbcrConversion)
	ret := C.vkCreateSamplerYcbcrConversion(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetDeviceQueue2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceQueue2.html
func (x DeviceFacade) GetDeviceQueue2(pQueueInfo *DeviceQueueInfo2, pQueue *Queue) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DeviceQueueInfo2) **C.struct_VkDeviceQueueInfo2 { /* Pointer */
		g2c := (*C.struct_VkDeviceQueueInfo2)(*x)
		return &g2c
	}(&pQueueInfo)
	p2 := func(x **Queue) **C.VkQueue { /* Pointer */ g2c := (*C.VkQueue)(*x); return &g2c }(&pQueue)
	C.vkGetDeviceQueue2(addrs, *p0, *p1, *p2)
}

// TrimCommandPool command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkTrimCommandPool.html
func (x DeviceFacade) TrimCommandPool(commandPool CommandPool, flags CommandPoolTrimFlags) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkCommandPool)(&commandPool)
	p2 := /* typedef */ (*C.VkCommandPoolTrimFlags)(&flags)
	C.vkTrimCommandPool(addrs, *p0, *p1, *p2)
}

// GetPhysicalDeviceExternalSemaphoreProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalSemaphoreProperties.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceExternalSemaphoreProperties(pExternalSemaphoreInfo *PhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties *ExternalSemaphoreProperties) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceExternalSemaphoreInfo) **C.struct_VkPhysicalDeviceExternalSemaphoreInfo { /* Pointer */
		g2c := (*C.struct_VkPhysicalDeviceExternalSemaphoreInfo)(*x)
		return &g2c
	}(&pExternalSemaphoreInfo)
	p2 := func(x **ExternalSemaphoreProperties) **C.struct_VkExternalSemaphoreProperties { /* Pointer */
		g2c := (*C.struct_VkExternalSemaphoreProperties)(*x)
		return &g2c
	}(&pExternalSemaphoreProperties)
	C.vkGetPhysicalDeviceExternalSemaphoreProperties(addrs, *p0, *p1, *p2)
}

// GetPhysicalDeviceSparseImageFormatProperties2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSparseImageFormatProperties2.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceSparseImageFormatProperties2(pFormatInfo *PhysicalDeviceSparseImageFormatInfo2, pPropertyCount *uint32, pProperties []SparseImageFormatProperties2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceSparseImageFormatInfo2) **C.struct_VkPhysicalDeviceSparseImageFormatInfo2 { /* Pointer */
		g2c := (*C.struct_VkPhysicalDeviceSparseImageFormatInfo2)(*x)
		return &g2c
	}(&pFormatInfo)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPropertyCount)
	p3 := func(x *[]SparseImageFormatProperties2) **C.struct_VkSparseImageFormatProperties2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSparseImageFormatProperties2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSparseImageFormatProperties2)(unsafe.Pointer((&ptr)))
	}(&pProperties)
	C.vkGetPhysicalDeviceSparseImageFormatProperties2(addrs, *p0, *p1, *p2, *p3)
}

// GetPhysicalDeviceMemoryProperties2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceMemoryProperties2.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceMemoryProperties2(pMemoryProperties *PhysicalDeviceMemoryProperties2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceMemoryProperties2) **C.struct_VkPhysicalDeviceMemoryProperties2 { /* Pointer */
		g2c := (*C.struct_VkPhysicalDeviceMemoryProperties2)(*x)
		return &g2c
	}(&pMemoryProperties)
	C.vkGetPhysicalDeviceMemoryProperties2(addrs, *p0, *p1)
}

// GetPhysicalDeviceQueueFamilyProperties2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceQueueFamilyProperties2.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceQueueFamilyProperties2(pQueueFamilyPropertyCount *uint32, pQueueFamilyProperties []QueueFamilyProperties2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pQueueFamilyPropertyCount)
	p2 := func(x *[]QueueFamilyProperties2) **C.struct_VkQueueFamilyProperties2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkQueueFamilyProperties2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkQueueFamilyProperties2)(unsafe.Pointer((&ptr)))
	}(&pQueueFamilyProperties)
	C.vkGetPhysicalDeviceQueueFamilyProperties2(addrs, *p0, *p1, *p2)
}

// GetPhysicalDeviceImageFormatProperties2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceImageFormatProperties2.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceImageFormatProperties2(pImageFormatInfo *PhysicalDeviceImageFormatInfo2, pImageFormatProperties *ImageFormatProperties2) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceImageFormatInfo2) **C.struct_VkPhysicalDeviceImageFormatInfo2 { /* Pointer */
		g2c := (*C.struct_VkPhysicalDeviceImageFormatInfo2)(*x)
		return &g2c
	}(&pImageFormatInfo)
	p2 := func(x **ImageFormatProperties2) **C.struct_VkImageFormatProperties2 { /* Pointer */
		g2c := (*C.struct_VkImageFormatProperties2)(*x)
		return &g2c
	}(&pImageFormatProperties)
	ret := C.vkGetPhysicalDeviceImageFormatProperties2(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceProperties2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceProperties2.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceProperties2(pProperties *PhysicalDeviceProperties2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceProperties2) **C.struct_VkPhysicalDeviceProperties2 { /* Pointer */
		g2c := (*C.struct_VkPhysicalDeviceProperties2)(*x)
		return &g2c
	}(&pProperties)
	C.vkGetPhysicalDeviceProperties2(addrs, *p0, *p1)
}

// GetPhysicalDeviceFeatures2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFeatures2.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceFeatures2(pFeatures *PhysicalDeviceFeatures2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceFeatures2) **C.struct_VkPhysicalDeviceFeatures2 { /* Pointer */
		g2c := (*C.struct_VkPhysicalDeviceFeatures2)(*x)
		return &g2c
	}(&pFeatures)
	C.vkGetPhysicalDeviceFeatures2(addrs, *p0, *p1)
}

// GetImageSparseMemoryRequirements2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageSparseMemoryRequirements2.html
func (x DeviceFacade) GetImageSparseMemoryRequirements2(pInfo *ImageSparseMemoryRequirementsInfo2, pSparseMemoryRequirementCount *uint32, pSparseMemoryRequirements []SparseImageMemoryRequirements2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **ImageSparseMemoryRequirementsInfo2) **C.struct_VkImageSparseMemoryRequirementsInfo2 { /* Pointer */
		g2c := (*C.struct_VkImageSparseMemoryRequirementsInfo2)(*x)
		return &g2c
	}(&pInfo)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pSparseMemoryRequirementCount)
	p3 := func(x *[]SparseImageMemoryRequirements2) **C.struct_VkSparseImageMemoryRequirements2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSparseImageMemoryRequirements2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSparseImageMemoryRequirements2)(unsafe.Pointer((&ptr)))
	}(&pSparseMemoryRequirements)
	C.vkGetImageSparseMemoryRequirements2(addrs, *p0, *p1, *p2, *p3)
}

// GetBufferMemoryRequirements2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferMemoryRequirements2.html
func (x DeviceFacade) GetBufferMemoryRequirements2(pInfo *BufferMemoryRequirementsInfo2, pMemoryRequirements *MemoryRequirements2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **BufferMemoryRequirementsInfo2) **C.struct_VkBufferMemoryRequirementsInfo2 { /* Pointer */
		g2c := (*C.struct_VkBufferMemoryRequirementsInfo2)(*x)
		return &g2c
	}(&pInfo)
	p2 := func(x **MemoryRequirements2) **C.struct_VkMemoryRequirements2 { /* Pointer */
		g2c := (*C.struct_VkMemoryRequirements2)(*x)
		return &g2c
	}(&pMemoryRequirements)
	C.vkGetBufferMemoryRequirements2(addrs, *p0, *p1, *p2)
}

// GetDescriptorSetLayoutSupport command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorSetLayoutSupport.html
func (x DeviceFacade) GetDescriptorSetLayoutSupport(pCreateInfo *DescriptorSetLayoutCreateInfo, pSupport *DescriptorSetLayoutSupport) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DescriptorSetLayoutCreateInfo) **C.struct_VkDescriptorSetLayoutCreateInfo { /* Pointer */
		g2c := (*C.struct_VkDescriptorSetLayoutCreateInfo)(*x)
		return &g2c
	}(&pCreateInfo)
	p2 := func(x **DescriptorSetLayoutSupport) **C.struct_VkDescriptorSetLayoutSupport { /* Pointer */
		g2c := (*C.struct_VkDescriptorSetLayoutSupport)(*x)
		return &g2c
	}(&pSupport)
	C.vkGetDescriptorSetLayoutSupport(addrs, *p0, *p1, *p2)
}

// GetImageMemoryRequirements2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageMemoryRequirements2.html
func (x DeviceFacade) GetImageMemoryRequirements2(pInfo *ImageMemoryRequirementsInfo2, pMemoryRequirements *MemoryRequirements2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **ImageMemoryRequirementsInfo2) **C.struct_VkImageMemoryRequirementsInfo2 { /* Pointer */
		g2c := (*C.struct_VkImageMemoryRequirementsInfo2)(*x)
		return &g2c
	}(&pInfo)
	p2 := func(x **MemoryRequirements2) **C.struct_VkMemoryRequirements2 { /* Pointer */
		g2c := (*C.struct_VkMemoryRequirements2)(*x)
		return &g2c
	}(&pMemoryRequirements)
	C.vkGetImageMemoryRequirements2(addrs, *p0, *p1, *p2)
}

// EnumeratePhysicalDeviceGroups command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumeratePhysicalDeviceGroups.html
func (x InstanceFacade) EnumeratePhysicalDeviceGroups(pPhysicalDeviceGroupCount *uint32, pPhysicalDeviceGroupProperties []PhysicalDeviceGroupProperties) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkInstance)(&x.H)
	p1 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPhysicalDeviceGroupCount)
	p2 := func(x *[]PhysicalDeviceGroupProperties) **C.struct_VkPhysicalDeviceGroupProperties { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkPhysicalDeviceGroupProperties)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkPhysicalDeviceGroupProperties)(unsafe.Pointer((&ptr)))
	}(&pPhysicalDeviceGroupProperties)
	ret := C.vkEnumeratePhysicalDeviceGroups(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CmdDispatchBase command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDispatchBase.html
func (x CommandBufferFacade) CmdDispatchBase(baseGroupX uint32, baseGroupY uint32, baseGroupZ uint32, groupCountX uint32, groupCountY uint32, groupCountZ uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&baseGroupX)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&baseGroupY)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&baseGroupZ)
	p4 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&groupCountX)
	p5 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&groupCountY)
	p6 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&groupCountZ)
	C.vkCmdDispatchBase(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6)
}

// CmdSetDeviceMask command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDeviceMask.html
func (x CommandBufferFacade) CmdSetDeviceMask(deviceMask uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&deviceMask)
	C.vkCmdSetDeviceMask(addrs, *p0, *p1)
}

// GetDeviceGroupPeerMemoryFeatures command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceGroupPeerMemoryFeatures.html
func (x DeviceFacade) GetDeviceGroupPeerMemoryFeatures(heapIndex uint32, localDeviceIndex uint32, remoteDeviceIndex uint32, pPeerMemoryFeatures *PeerMemoryFeatureFlags) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&heapIndex)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&localDeviceIndex)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&remoteDeviceIndex)
	p4 := func(x **PeerMemoryFeatureFlags) **C.VkPeerMemoryFeatureFlags { /* Pointer */
		g2c := (*C.VkPeerMemoryFeatureFlags)(*x)
		return &g2c
	}(&pPeerMemoryFeatures)
	C.vkGetDeviceGroupPeerMemoryFeatures(addrs, *p0, *p1, *p2, *p3, *p4)
}

// BindImageMemory2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindImageMemory2.html
func (x DeviceFacade) BindImageMemory2(bindInfoCount uint32, pBindInfos []BindImageMemoryInfo) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&bindInfoCount)
	p2 := func(x *[]BindImageMemoryInfo) **C.struct_VkBindImageMemoryInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkBindImageMemoryInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkBindImageMemoryInfo)(unsafe.Pointer((&ptr)))
	}(&pBindInfos)
	ret := C.vkBindImageMemory2(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// BindBufferMemory2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindBufferMemory2.html
func (x DeviceFacade) BindBufferMemory2(bindInfoCount uint32, pBindInfos []BindBufferMemoryInfo) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&bindInfoCount)
	p2 := func(x *[]BindBufferMemoryInfo) **C.struct_VkBindBufferMemoryInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkBindBufferMemoryInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkBindBufferMemoryInfo)(unsafe.Pointer((&ptr)))
	}(&pBindInfos)
	ret := C.vkBindBufferMemory2(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// EnumerateInstanceVersion command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceVersion.html
func EnumerateInstanceVersion(pApiVersion *uint32) Result {
	addrs := &C.vksProcAddresses
	p0 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pApiVersion)
	ret := C.vkEnumerateInstanceVersion(addrs, *p0)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// ResolveModeFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkResolveModeFlagBits.html
type ResolveModeFlagBits uint32

const (
	VK_RESOLVE_MODE_NONE            ResolveModeFlagBits = 0
	VK_RESOLVE_MODE_SAMPLE_ZERO_BIT ResolveModeFlagBits = (1 << 0)
	VK_RESOLVE_MODE_AVERAGE_BIT     ResolveModeFlagBits = (1 << 1)
	VK_RESOLVE_MODE_MIN_BIT         ResolveModeFlagBits = (1 << 2)
	VK_RESOLVE_MODE_MAX_BIT         ResolveModeFlagBits = (1 << 3)
)

var (
	reverseResolveModeFlagBits map[ResolveModeFlagBits]string = map[ResolveModeFlagBits]string{
		VK_RESOLVE_MODE_NONE:            "VK_RESOLVE_MODE_NONE",
		VK_RESOLVE_MODE_SAMPLE_ZERO_BIT: "VK_RESOLVE_MODE_SAMPLE_ZERO_BIT",
		VK_RESOLVE_MODE_AVERAGE_BIT:     "VK_RESOLVE_MODE_AVERAGE_BIT",
		VK_RESOLVE_MODE_MIN_BIT:         "VK_RESOLVE_MODE_MIN_BIT",
		VK_RESOLVE_MODE_MAX_BIT:         "VK_RESOLVE_MODE_MAX_BIT",
	}
)

func (x ResolveModeFlagBits) String() string {
	if s, ok := reverseResolveModeFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ResolveModeFlagBits=%d", x)
}

// SamplerReductionMode enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerReductionMode.html
type SamplerReductionMode uint32

const (
	VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE SamplerReductionMode = 0
	VK_SAMPLER_REDUCTION_MODE_MIN              SamplerReductionMode = 1
	VK_SAMPLER_REDUCTION_MODE_MAX              SamplerReductionMode = 2
)

var (
	reverseSamplerReductionMode map[SamplerReductionMode]string = map[SamplerReductionMode]string{
		VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE: "VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE",
		VK_SAMPLER_REDUCTION_MODE_MIN:              "VK_SAMPLER_REDUCTION_MODE_MIN",
		VK_SAMPLER_REDUCTION_MODE_MAX:              "VK_SAMPLER_REDUCTION_MODE_MAX",
	}
)

func (x SamplerReductionMode) String() string {
	if s, ok := reverseSamplerReductionMode[x]; ok {
		return s
	}
	return fmt.Sprintf("SamplerReductionMode=%d", x)
}

// DescriptorBindingFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorBindingFlagBits.html
type DescriptorBindingFlagBits uint32

const (
	VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT           DescriptorBindingFlagBits = (1 << 0)
	VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT DescriptorBindingFlagBits = (1 << 1)
	VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT             DescriptorBindingFlagBits = (1 << 2)
	VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT   DescriptorBindingFlagBits = (1 << 3)
)

var (
	reverseDescriptorBindingFlagBits map[DescriptorBindingFlagBits]string = map[DescriptorBindingFlagBits]string{
		VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT:           "VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT",
		VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT: "VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT",
		VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT:             "VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT",
		VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT:   "VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT",
	}
)

func (x DescriptorBindingFlagBits) String() string {
	if s, ok := reverseDescriptorBindingFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("DescriptorBindingFlagBits=%d", x)
}

// ShaderFloatControlsIndependence enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderFloatControlsIndependence.html
type ShaderFloatControlsIndependence uint32

const (
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY ShaderFloatControlsIndependence = 0
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL         ShaderFloatControlsIndependence = 1
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE        ShaderFloatControlsIndependence = 2
)

var (
	reverseShaderFloatControlsIndependence map[ShaderFloatControlsIndependence]string = map[ShaderFloatControlsIndependence]string{
		VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY: "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY",
		VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL:         "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL",
		VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE:        "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE",
	}
)

func (x ShaderFloatControlsIndependence) String() string {
	if s, ok := reverseShaderFloatControlsIndependence[x]; ok {
		return s
	}
	return fmt.Sprintf("ShaderFloatControlsIndependence=%d", x)
}

// DriverId enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDriverId.html
type DriverId uint32

const (
	VK_DRIVER_ID_AMD_PROPRIETARY              DriverId = 1
	VK_DRIVER_ID_AMD_OPEN_SOURCE              DriverId = 2
	VK_DRIVER_ID_MESA_RADV                    DriverId = 3
	VK_DRIVER_ID_NVIDIA_PROPRIETARY           DriverId = 4
	VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS    DriverId = 5
	VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA       DriverId = 6
	VK_DRIVER_ID_IMAGINATION_PROPRIETARY      DriverId = 7
	VK_DRIVER_ID_QUALCOMM_PROPRIETARY         DriverId = 8
	VK_DRIVER_ID_ARM_PROPRIETARY              DriverId = 9
	VK_DRIVER_ID_GOOGLE_SWIFTSHADER           DriverId = 10
	VK_DRIVER_ID_GGP_PROPRIETARY              DriverId = 11
	VK_DRIVER_ID_BROADCOM_PROPRIETARY         DriverId = 12
	VK_DRIVER_ID_MESA_LLVMPIPE                DriverId = 13
	VK_DRIVER_ID_MOLTENVK                     DriverId = 14
	VK_DRIVER_ID_COREAVI_PROPRIETARY          DriverId = 15
	VK_DRIVER_ID_JUICE_PROPRIETARY            DriverId = 16
	VK_DRIVER_ID_VERISILICON_PROPRIETARY      DriverId = 17
	VK_DRIVER_ID_MESA_TURNIP                  DriverId = 18
	VK_DRIVER_ID_MESA_V3DV                    DriverId = 19
	VK_DRIVER_ID_MESA_PANVK                   DriverId = 20
	VK_DRIVER_ID_SAMSUNG_PROPRIETARY          DriverId = 21
	VK_DRIVER_ID_MESA_VENUS                   DriverId = 22
	VK_DRIVER_ID_MESA_DOZEN                   DriverId = 23
	VK_DRIVER_ID_MESA_NVK                     DriverId = 24
	VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA DriverId = 25
	VK_DRIVER_ID_MESA_AGXV                    DriverId = 26
)

var (
	reverseDriverId map[DriverId]string = map[DriverId]string{
		VK_DRIVER_ID_AMD_PROPRIETARY:              "VK_DRIVER_ID_AMD_PROPRIETARY",
		VK_DRIVER_ID_AMD_OPEN_SOURCE:              "VK_DRIVER_ID_AMD_OPEN_SOURCE",
		VK_DRIVER_ID_MESA_RADV:                    "VK_DRIVER_ID_MESA_RADV",
		VK_DRIVER_ID_NVIDIA_PROPRIETARY:           "VK_DRIVER_ID_NVIDIA_PROPRIETARY",
		VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS:    "VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS",
		VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA:       "VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA",
		VK_DRIVER_ID_IMAGINATION_PROPRIETARY:      "VK_DRIVER_ID_IMAGINATION_PROPRIETARY",
		VK_DRIVER_ID_QUALCOMM_PROPRIETARY:         "VK_DRIVER_ID_QUALCOMM_PROPRIETARY",
		VK_DRIVER_ID_ARM_PROPRIETARY:              "VK_DRIVER_ID_ARM_PROPRIETARY",
		VK_DRIVER_ID_GOOGLE_SWIFTSHADER:           "VK_DRIVER_ID_GOOGLE_SWIFTSHADER",
		VK_DRIVER_ID_GGP_PROPRIETARY:              "VK_DRIVER_ID_GGP_PROPRIETARY",
		VK_DRIVER_ID_BROADCOM_PROPRIETARY:         "VK_DRIVER_ID_BROADCOM_PROPRIETARY",
		VK_DRIVER_ID_MESA_LLVMPIPE:                "VK_DRIVER_ID_MESA_LLVMPIPE",
		VK_DRIVER_ID_MOLTENVK:                     "VK_DRIVER_ID_MOLTENVK",
		VK_DRIVER_ID_COREAVI_PROPRIETARY:          "VK_DRIVER_ID_COREAVI_PROPRIETARY",
		VK_DRIVER_ID_JUICE_PROPRIETARY:            "VK_DRIVER_ID_JUICE_PROPRIETARY",
		VK_DRIVER_ID_VERISILICON_PROPRIETARY:      "VK_DRIVER_ID_VERISILICON_PROPRIETARY",
		VK_DRIVER_ID_MESA_TURNIP:                  "VK_DRIVER_ID_MESA_TURNIP",
		VK_DRIVER_ID_MESA_V3DV:                    "VK_DRIVER_ID_MESA_V3DV",
		VK_DRIVER_ID_MESA_PANVK:                   "VK_DRIVER_ID_MESA_PANVK",
		VK_DRIVER_ID_SAMSUNG_PROPRIETARY:          "VK_DRIVER_ID_SAMSUNG_PROPRIETARY",
		VK_DRIVER_ID_MESA_VENUS:                   "VK_DRIVER_ID_MESA_VENUS",
		VK_DRIVER_ID_MESA_DOZEN:                   "VK_DRIVER_ID_MESA_DOZEN",
		VK_DRIVER_ID_MESA_NVK:                     "VK_DRIVER_ID_MESA_NVK",
		VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA: "VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA",
		VK_DRIVER_ID_MESA_AGXV:                    "VK_DRIVER_ID_MESA_AGXV",
	}
)

func (x DriverId) String() string {
	if s, ok := reverseDriverId[x]; ok {
		return s
	}
	return fmt.Sprintf("DriverId=%d", x)
}

// SemaphoreType enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreType.html
type SemaphoreType uint32

const (
	VK_SEMAPHORE_TYPE_BINARY   SemaphoreType = 0
	VK_SEMAPHORE_TYPE_TIMELINE SemaphoreType = 1
)

var (
	reverseSemaphoreType map[SemaphoreType]string = map[SemaphoreType]string{
		VK_SEMAPHORE_TYPE_BINARY:   "VK_SEMAPHORE_TYPE_BINARY",
		VK_SEMAPHORE_TYPE_TIMELINE: "VK_SEMAPHORE_TYPE_TIMELINE",
	}
)

func (x SemaphoreType) String() string {
	if s, ok := reverseSemaphoreType[x]; ok {
		return s
	}
	return fmt.Sprintf("SemaphoreType=%d", x)
}

// SemaphoreWaitFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreWaitFlagBits.html
type SemaphoreWaitFlagBits uint32

const (
	VK_SEMAPHORE_WAIT_ANY_BIT SemaphoreWaitFlagBits = (1 << 0)
)

var (
	reverseSemaphoreWaitFlagBits map[SemaphoreWaitFlagBits]string = map[SemaphoreWaitFlagBits]string{
		VK_SEMAPHORE_WAIT_ANY_BIT: "VK_SEMAPHORE_WAIT_ANY_BIT",
	}
)

func (x SemaphoreWaitFlagBits) String() string {
	if s, ok := reverseSemaphoreWaitFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("SemaphoreWaitFlagBits=%d", x)
}

// SemaphoreWaitFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreWaitFlags.html
type SemaphoreWaitFlags Flags

// ResolveModeFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkResolveModeFlags.html
type ResolveModeFlags Flags

// DescriptorBindingFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorBindingFlags.html
type DescriptorBindingFlags Flags

// PhysicalDeviceSeparateDepthStencilLayoutsFeatures provides a go interface for VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.html
type PhysicalDeviceSeparateDepthStencilLayoutsFeatures C.struct_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures

// SizeofPhysicalDeviceSeparateDepthStencilLayoutsFeatures is the memory size of a PhysicalDeviceSeparateDepthStencilLayoutsFeatures
var SizeofPhysicalDeviceSeparateDepthStencilLayoutsFeatures int = int(unsafe.Sizeof(PhysicalDeviceSeparateDepthStencilLayoutsFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceSeparateDepthStencilLayoutsFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceSeparateDepthStencilLayoutsFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceSeparateDepthStencilLayoutsFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceSeparateDepthStencilLayoutsFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceSeparateDepthStencilLayoutsFeatures) AsCPtr() *PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
	clone := (*PhysicalDeviceSeparateDepthStencilLayoutsFeatures)(newCBlock(cULong(SizeofPhysicalDeviceSeparateDepthStencilLayoutsFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceSeparateDepthStencilLayoutsFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceSeparateDepthStencilLayoutsFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceSeparateDepthStencilLayoutsFeatures) []PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSeparateDepthStencilLayoutsFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceSeparateDepthStencilLayoutsFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceSeparateDepthStencilLayoutsFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceSeparateDepthStencilLayoutsFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceSeparateDepthStencilLayoutsFeaturesFreeCSlice(x []PhysicalDeviceSeparateDepthStencilLayoutsFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceSeparateDepthStencilLayoutsFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceSeparateDepthStencilLayoutsFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceSeparateDepthStencilLayoutsFeaturesMakeCSlice(x ...PhysicalDeviceSeparateDepthStencilLayoutsFeatures) []PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSeparateDepthStencilLayoutsFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceSeparateDepthStencilLayoutsFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures
func (x PhysicalDeviceSeparateDepthStencilLayoutsFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceSeparateDepthStencilLayoutsFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceSeparateDepthStencilLayoutsFeatures) WithDefaultSType() PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceSeparateDepthStencilLayoutsFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES)
}

// WithSType clones a new PhysicalDeviceSeparateDepthStencilLayoutsFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSeparateDepthStencilLayoutsFeatures) WithSType(y StructureType) PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceSeparateDepthStencilLayoutsFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures
func (x PhysicalDeviceSeparateDepthStencilLayoutsFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceSeparateDepthStencilLayoutsFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSeparateDepthStencilLayoutsFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceSeparateDepthStencilLayoutsFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SeparateDepthStencilLayouts returns the value of separateDepthStencilLayouts from VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures
func (x PhysicalDeviceSeparateDepthStencilLayoutsFeatures) SeparateDepthStencilLayouts() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.separateDepthStencilLayouts)
	return *ptr
}

// WithSeparateDepthStencilLayouts clones a new PhysicalDeviceSeparateDepthStencilLayoutsFeatures with the value of
// SeparateDepthStencilLayouts updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSeparateDepthStencilLayoutsFeatures) WithSeparateDepthStencilLayouts(y Bool32) PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
	x.separateDepthStencilLayouts = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceSeparateDepthStencilLayoutsFeatures) SetSeparateDepthStencilLayouts(y Bool32) {
	x.separateDepthStencilLayouts = *( /* typedef */ (*C.VkBool32)(&y))
}

// ConformanceVersion provides a go interface for VkConformanceVersion.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkConformanceVersion.html
type ConformanceVersion C.struct_VkConformanceVersion

// SizeofConformanceVersion is the memory size of a ConformanceVersion
var SizeofConformanceVersion int = int(unsafe.Sizeof(ConformanceVersion{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ConformanceVersion) ArpPtr(arp *AutoReleasePool) *ConformanceVersion {
	ptr := newCBlock(cULong(SizeofConformanceVersion))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ConformanceVersion)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ConformanceVersion) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ConformanceVersion) AsCPtr() *ConformanceVersion {
	clone := (*ConformanceVersion)(newCBlock(cULong(SizeofConformanceVersion)))
	*clone = x
	return clone
}

// ConformanceVersionCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ConformanceVersionCSlice(arp *AutoReleasePool, x ...ConformanceVersion) []ConformanceVersion {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofConformanceVersion * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ConformanceVersion)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ConformanceVersionFreeCSlice releases the memory allocated by ConformanceVersionMakeCSlice.
// It does not free pointers stored inside the slice.
func ConformanceVersionFreeCSlice(x []ConformanceVersion) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ConformanceVersionMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ConformanceVersionFreeCSlice must be called on the returned slice.
func ConformanceVersionMakeCSlice(x ...ConformanceVersion) []ConformanceVersion {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofConformanceVersion * len(x)
	dst := unsafe.Slice((*ConformanceVersion)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Major returns the value of major from VkConformanceVersion
func (x ConformanceVersion) Major() byte {
	ptr := func(x *C.uint8_t) *byte { /* Scalar */ c2g := byte(*x); return &c2g }(&x.major)
	return *ptr
}

// WithMajor clones a new ConformanceVersion with the value of
// Major updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ConformanceVersion) WithMajor(y byte) ConformanceVersion {
	x.major = *(func(x *byte) *C.uint8_t { /* Scalar */ g2c := C.uint8_t(*x); return &g2c }(&y))
	return x
}
func (x *ConformanceVersion) SetMajor(y byte) {
	x.major = *(func(x *byte) *C.uint8_t { /* Scalar */ g2c := C.uint8_t(*x); return &g2c }(&y))
}

// Minor returns the value of minor from VkConformanceVersion
func (x ConformanceVersion) Minor() byte {
	ptr := func(x *C.uint8_t) *byte { /* Scalar */ c2g := byte(*x); return &c2g }(&x.minor)
	return *ptr
}

// WithMinor clones a new ConformanceVersion with the value of
// Minor updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ConformanceVersion) WithMinor(y byte) ConformanceVersion {
	x.minor = *(func(x *byte) *C.uint8_t { /* Scalar */ g2c := C.uint8_t(*x); return &g2c }(&y))
	return x
}
func (x *ConformanceVersion) SetMinor(y byte) {
	x.minor = *(func(x *byte) *C.uint8_t { /* Scalar */ g2c := C.uint8_t(*x); return &g2c }(&y))
}

// Subminor returns the value of subminor from VkConformanceVersion
func (x ConformanceVersion) Subminor() byte {
	ptr := func(x *C.uint8_t) *byte { /* Scalar */ c2g := byte(*x); return &c2g }(&x.subminor)
	return *ptr
}

// WithSubminor clones a new ConformanceVersion with the value of
// Subminor updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ConformanceVersion) WithSubminor(y byte) ConformanceVersion {
	x.subminor = *(func(x *byte) *C.uint8_t { /* Scalar */ g2c := C.uint8_t(*x); return &g2c }(&y))
	return x
}
func (x *ConformanceVersion) SetSubminor(y byte) {
	x.subminor = *(func(x *byte) *C.uint8_t { /* Scalar */ g2c := C.uint8_t(*x); return &g2c }(&y))
}

// Patch returns the value of patch from VkConformanceVersion
func (x ConformanceVersion) Patch() byte {
	ptr := func(x *C.uint8_t) *byte { /* Scalar */ c2g := byte(*x); return &c2g }(&x.patch)
	return *ptr
}

// WithPatch clones a new ConformanceVersion with the value of
// Patch updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ConformanceVersion) WithPatch(y byte) ConformanceVersion {
	x.patch = *(func(x *byte) *C.uint8_t { /* Scalar */ g2c := C.uint8_t(*x); return &g2c }(&y))
	return x
}
func (x *ConformanceVersion) SetPatch(y byte) {
	x.patch = *(func(x *byte) *C.uint8_t { /* Scalar */ g2c := C.uint8_t(*x); return &g2c }(&y))
}

// PhysicalDeviceDriverProperties provides a go interface for VkPhysicalDeviceDriverProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDriverProperties.html
type PhysicalDeviceDriverProperties C.struct_VkPhysicalDeviceDriverProperties

// SizeofPhysicalDeviceDriverProperties is the memory size of a PhysicalDeviceDriverProperties
var SizeofPhysicalDeviceDriverProperties int = int(unsafe.Sizeof(PhysicalDeviceDriverProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceDriverProperties) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceDriverProperties {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceDriverProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceDriverProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceDriverProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceDriverProperties) AsCPtr() *PhysicalDeviceDriverProperties {
	clone := (*PhysicalDeviceDriverProperties)(newCBlock(cULong(SizeofPhysicalDeviceDriverProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceDriverPropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceDriverPropertiesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceDriverProperties) []PhysicalDeviceDriverProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceDriverProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceDriverProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceDriverPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceDriverPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceDriverPropertiesFreeCSlice(x []PhysicalDeviceDriverProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceDriverPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceDriverPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceDriverPropertiesMakeCSlice(x ...PhysicalDeviceDriverProperties) []PhysicalDeviceDriverProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceDriverProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceDriverProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceDriverProperties
func (x PhysicalDeviceDriverProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceDriverProperties with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceDriverProperties) WithDefaultSType() PhysicalDeviceDriverProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceDriverProperties) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES)
}

// WithSType clones a new PhysicalDeviceDriverProperties with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDriverProperties) WithSType(y StructureType) PhysicalDeviceDriverProperties {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceDriverProperties) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceDriverProperties
func (x PhysicalDeviceDriverProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceDriverProperties with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDriverProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceDriverProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceDriverProperties) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// DriverID returns the value of driverID from VkPhysicalDeviceDriverProperties
func (x PhysicalDeviceDriverProperties) DriverID() DriverId {
	ptr := /* typedef */ (*DriverId)(&x.driverID)
	return *ptr
}

// DriverName returns the value of driverName from VkPhysicalDeviceDriverProperties
func (x PhysicalDeviceDriverProperties) DriverName() []byte {
	ptr := func(x *[VK_MAX_DRIVER_NAME_SIZE]C.char) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_DRIVER_NAME_SIZE)
		return &slc
	}(&x.driverName)
	return *ptr
}

// DriverInfo returns the value of driverInfo from VkPhysicalDeviceDriverProperties
func (x PhysicalDeviceDriverProperties) DriverInfo() []byte {
	ptr := func(x *[VK_MAX_DRIVER_INFO_SIZE]C.char) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_DRIVER_INFO_SIZE)
		return &slc
	}(&x.driverInfo)
	return *ptr
}

// ConformanceVersion returns the value of conformanceVersion from VkPhysicalDeviceDriverProperties
func (x PhysicalDeviceDriverProperties) ConformanceVersion() ConformanceVersion {
	ptr := /* typedef */ (*ConformanceVersion)(&x.conformanceVersion)
	return *ptr
}

// SemaphoreSignalInfo provides a go interface for VkSemaphoreSignalInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreSignalInfo.html
type SemaphoreSignalInfo C.struct_VkSemaphoreSignalInfo

// SizeofSemaphoreSignalInfo is the memory size of a SemaphoreSignalInfo
var SizeofSemaphoreSignalInfo int = int(unsafe.Sizeof(SemaphoreSignalInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SemaphoreSignalInfo) ArpPtr(arp *AutoReleasePool) *SemaphoreSignalInfo {
	ptr := newCBlock(cULong(SizeofSemaphoreSignalInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SemaphoreSignalInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SemaphoreSignalInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SemaphoreSignalInfo) AsCPtr() *SemaphoreSignalInfo {
	clone := (*SemaphoreSignalInfo)(newCBlock(cULong(SizeofSemaphoreSignalInfo)))
	*clone = x
	return clone
}

// SemaphoreSignalInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SemaphoreSignalInfoCSlice(arp *AutoReleasePool, x ...SemaphoreSignalInfo) []SemaphoreSignalInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSemaphoreSignalInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SemaphoreSignalInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SemaphoreSignalInfoFreeCSlice releases the memory allocated by SemaphoreSignalInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SemaphoreSignalInfoFreeCSlice(x []SemaphoreSignalInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SemaphoreSignalInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SemaphoreSignalInfoFreeCSlice must be called on the returned slice.
func SemaphoreSignalInfoMakeCSlice(x ...SemaphoreSignalInfo) []SemaphoreSignalInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSemaphoreSignalInfo * len(x)
	dst := unsafe.Slice((*SemaphoreSignalInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSemaphoreSignalInfo
func (x SemaphoreSignalInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new SemaphoreSignalInfo with the value of
// SType to the value provided in the specification.
func (x SemaphoreSignalInfo) WithDefaultSType() SemaphoreSignalInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *SemaphoreSignalInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO)
}

// WithSType clones a new SemaphoreSignalInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreSignalInfo) WithSType(y StructureType) SemaphoreSignalInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *SemaphoreSignalInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkSemaphoreSignalInfo
func (x SemaphoreSignalInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new SemaphoreSignalInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreSignalInfo) WithPNext(y unsafe.Pointer) SemaphoreSignalInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *SemaphoreSignalInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Semaphore returns the value of semaphore from VkSemaphoreSignalInfo
func (x SemaphoreSignalInfo) Semaphore() Semaphore {
	ptr := /* handle */ (*Semaphore)(&x.semaphore)
	return *ptr
}

// WithSemaphore clones a new SemaphoreSignalInfo with the value of
// Semaphore updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreSignalInfo) WithSemaphore(y Semaphore) SemaphoreSignalInfo {
	x.semaphore = *( /* handle */ (*C.VkSemaphore)(&y))
	return x
}
func (x *SemaphoreSignalInfo) SetSemaphore(y Semaphore) {
	x.semaphore = *( /* handle */ (*C.VkSemaphore)(&y))
}

// Value returns the value of value from VkSemaphoreSignalInfo
func (x SemaphoreSignalInfo) Value() uint64 {
	ptr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.value)
	return *ptr
}

// WithValue clones a new SemaphoreSignalInfo with the value of
// Value updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreSignalInfo) WithValue(y uint64) SemaphoreSignalInfo {
	x.value = *(func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&y))
	return x
}
func (x *SemaphoreSignalInfo) SetValue(y uint64) {
	x.value = *(func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&y))
}

// PhysicalDeviceBufferDeviceAddressFeatures provides a go interface for VkPhysicalDeviceBufferDeviceAddressFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceBufferDeviceAddressFeatures.html
type PhysicalDeviceBufferDeviceAddressFeatures C.struct_VkPhysicalDeviceBufferDeviceAddressFeatures

// SizeofPhysicalDeviceBufferDeviceAddressFeatures is the memory size of a PhysicalDeviceBufferDeviceAddressFeatures
var SizeofPhysicalDeviceBufferDeviceAddressFeatures int = int(unsafe.Sizeof(PhysicalDeviceBufferDeviceAddressFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceBufferDeviceAddressFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceBufferDeviceAddressFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceBufferDeviceAddressFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceBufferDeviceAddressFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceBufferDeviceAddressFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceBufferDeviceAddressFeatures) AsCPtr() *PhysicalDeviceBufferDeviceAddressFeatures {
	clone := (*PhysicalDeviceBufferDeviceAddressFeatures)(newCBlock(cULong(SizeofPhysicalDeviceBufferDeviceAddressFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceBufferDeviceAddressFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceBufferDeviceAddressFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceBufferDeviceAddressFeatures) []PhysicalDeviceBufferDeviceAddressFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceBufferDeviceAddressFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceBufferDeviceAddressFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceBufferDeviceAddressFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceBufferDeviceAddressFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceBufferDeviceAddressFeaturesFreeCSlice(x []PhysicalDeviceBufferDeviceAddressFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceBufferDeviceAddressFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceBufferDeviceAddressFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceBufferDeviceAddressFeaturesMakeCSlice(x ...PhysicalDeviceBufferDeviceAddressFeatures) []PhysicalDeviceBufferDeviceAddressFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceBufferDeviceAddressFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceBufferDeviceAddressFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceBufferDeviceAddressFeatures
func (x PhysicalDeviceBufferDeviceAddressFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceBufferDeviceAddressFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceBufferDeviceAddressFeatures) WithDefaultSType() PhysicalDeviceBufferDeviceAddressFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceBufferDeviceAddressFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES)
}

// WithSType clones a new PhysicalDeviceBufferDeviceAddressFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceBufferDeviceAddressFeatures) WithSType(y StructureType) PhysicalDeviceBufferDeviceAddressFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceBufferDeviceAddressFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceBufferDeviceAddressFeatures
func (x PhysicalDeviceBufferDeviceAddressFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceBufferDeviceAddressFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceBufferDeviceAddressFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceBufferDeviceAddressFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceBufferDeviceAddressFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// BufferDeviceAddress returns the value of bufferDeviceAddress from VkPhysicalDeviceBufferDeviceAddressFeatures
func (x PhysicalDeviceBufferDeviceAddressFeatures) BufferDeviceAddress() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.bufferDeviceAddress)
	return *ptr
}

// WithBufferDeviceAddress clones a new PhysicalDeviceBufferDeviceAddressFeatures with the value of
// BufferDeviceAddress updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceBufferDeviceAddressFeatures) WithBufferDeviceAddress(y Bool32) PhysicalDeviceBufferDeviceAddressFeatures {
	x.bufferDeviceAddress = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceBufferDeviceAddressFeatures) SetBufferDeviceAddress(y Bool32) {
	x.bufferDeviceAddress = *( /* typedef */ (*C.VkBool32)(&y))
}

// BufferDeviceAddressCaptureReplay returns the value of bufferDeviceAddressCaptureReplay from VkPhysicalDeviceBufferDeviceAddressFeatures
func (x PhysicalDeviceBufferDeviceAddressFeatures) BufferDeviceAddressCaptureReplay() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.bufferDeviceAddressCaptureReplay)
	return *ptr
}

// WithBufferDeviceAddressCaptureReplay clones a new PhysicalDeviceBufferDeviceAddressFeatures with the value of
// BufferDeviceAddressCaptureReplay updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceBufferDeviceAddressFeatures) WithBufferDeviceAddressCaptureReplay(y Bool32) PhysicalDeviceBufferDeviceAddressFeatures {
	x.bufferDeviceAddressCaptureReplay = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceBufferDeviceAddressFeatures) SetBufferDeviceAddressCaptureReplay(y Bool32) {
	x.bufferDeviceAddressCaptureReplay = *( /* typedef */ (*C.VkBool32)(&y))
}

// BufferDeviceAddressMultiDevice returns the value of bufferDeviceAddressMultiDevice from VkPhysicalDeviceBufferDeviceAddressFeatures
func (x PhysicalDeviceBufferDeviceAddressFeatures) BufferDeviceAddressMultiDevice() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.bufferDeviceAddressMultiDevice)
	return *ptr
}

// WithBufferDeviceAddressMultiDevice clones a new PhysicalDeviceBufferDeviceAddressFeatures with the value of
// BufferDeviceAddressMultiDevice updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceBufferDeviceAddressFeatures) WithBufferDeviceAddressMultiDevice(y Bool32) PhysicalDeviceBufferDeviceAddressFeatures {
	x.bufferDeviceAddressMultiDevice = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceBufferDeviceAddressFeatures) SetBufferDeviceAddressMultiDevice(y Bool32) {
	x.bufferDeviceAddressMultiDevice = *( /* typedef */ (*C.VkBool32)(&y))
}

// TimelineSemaphoreSubmitInfo provides a go interface for VkTimelineSemaphoreSubmitInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkTimelineSemaphoreSubmitInfo.html
type TimelineSemaphoreSubmitInfo C.struct_VkTimelineSemaphoreSubmitInfo

// SizeofTimelineSemaphoreSubmitInfo is the memory size of a TimelineSemaphoreSubmitInfo
var SizeofTimelineSemaphoreSubmitInfo int = int(unsafe.Sizeof(TimelineSemaphoreSubmitInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x TimelineSemaphoreSubmitInfo) ArpPtr(arp *AutoReleasePool) *TimelineSemaphoreSubmitInfo {
	ptr := newCBlock(cULong(SizeofTimelineSemaphoreSubmitInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*TimelineSemaphoreSubmitInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *TimelineSemaphoreSubmitInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x TimelineSemaphoreSubmitInfo) AsCPtr() *TimelineSemaphoreSubmitInfo {
	clone := (*TimelineSemaphoreSubmitInfo)(newCBlock(cULong(SizeofTimelineSemaphoreSubmitInfo)))
	*clone = x
	return clone
}

// TimelineSemaphoreSubmitInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func TimelineSemaphoreSubmitInfoCSlice(arp *AutoReleasePool, x ...TimelineSemaphoreSubmitInfo) []TimelineSemaphoreSubmitInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofTimelineSemaphoreSubmitInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*TimelineSemaphoreSubmitInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// TimelineSemaphoreSubmitInfoFreeCSlice releases the memory allocated by TimelineSemaphoreSubmitInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func TimelineSemaphoreSubmitInfoFreeCSlice(x []TimelineSemaphoreSubmitInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// TimelineSemaphoreSubmitInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. TimelineSemaphoreSubmitInfoFreeCSlice must be called on the returned slice.
func TimelineSemaphoreSubmitInfoMakeCSlice(x ...TimelineSemaphoreSubmitInfo) []TimelineSemaphoreSubmitInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofTimelineSemaphoreSubmitInfo * len(x)
	dst := unsafe.Slice((*TimelineSemaphoreSubmitInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkTimelineSemaphoreSubmitInfo
func (x TimelineSemaphoreSubmitInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new TimelineSemaphoreSubmitInfo with the value of
// SType to the value provided in the specification.
func (x TimelineSemaphoreSubmitInfo) WithDefaultSType() TimelineSemaphoreSubmitInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *TimelineSemaphoreSubmitInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO)
}

// WithSType clones a new TimelineSemaphoreSubmitInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x TimelineSemaphoreSubmitInfo) WithSType(y StructureType) TimelineSemaphoreSubmitInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *TimelineSemaphoreSubmitInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkTimelineSemaphoreSubmitInfo
func (x TimelineSemaphoreSubmitInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new TimelineSemaphoreSubmitInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x TimelineSemaphoreSubmitInfo) WithPNext(y unsafe.Pointer) TimelineSemaphoreSubmitInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *TimelineSemaphoreSubmitInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// WaitSemaphoreValueCount returns the value of waitSemaphoreValueCount from VkTimelineSemaphoreSubmitInfo
func (x TimelineSemaphoreSubmitInfo) WaitSemaphoreValueCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.waitSemaphoreValueCount)
	return *ptr
}

// WithWaitSemaphoreValueCount clones a new TimelineSemaphoreSubmitInfo with the value of
// WaitSemaphoreValueCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x TimelineSemaphoreSubmitInfo) WithWaitSemaphoreValueCount(y uint32) TimelineSemaphoreSubmitInfo {
	x.waitSemaphoreValueCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *TimelineSemaphoreSubmitInfo) SetWaitSemaphoreValueCount(y uint32) {
	x.waitSemaphoreValueCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PWaitSemaphoreValues returns the value of pWaitSemaphoreValues from VkTimelineSemaphoreSubmitInfo
func (x TimelineSemaphoreSubmitInfo) PWaitSemaphoreValues() []uint64 {
	ptr := func(x **C.uint64_t) *[]uint64 { /* Slice */
		slc := unsafe.Slice((*uint64)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pWaitSemaphoreValues)
	return *ptr
}

// WithPWaitSemaphoreValues clones a new TimelineSemaphoreSubmitInfo with the value of
// PWaitSemaphoreValues updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines WaitSemaphoreValueCount as the length of this field.
// WaitSemaphoreValueCount is updated with the length of the new value.
func (x TimelineSemaphoreSubmitInfo) WithPWaitSemaphoreValues(y []uint64) TimelineSemaphoreSubmitInfo {
	x.pWaitSemaphoreValues = *(func(x *[]uint64) **C.uint64_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint64_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint64_t)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithWaitSemaphoreValueCount(uint32(len(y)))
}
func (x *TimelineSemaphoreSubmitInfo) SetPWaitSemaphoreValues(y []uint64) {
	x.pWaitSemaphoreValues = *(func(x *[]uint64) **C.uint64_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint64_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint64_t)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetWaitSemaphoreValueCount(uint32(len(y)))
}

// SignalSemaphoreValueCount returns the value of signalSemaphoreValueCount from VkTimelineSemaphoreSubmitInfo
func (x TimelineSemaphoreSubmitInfo) SignalSemaphoreValueCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.signalSemaphoreValueCount)
	return *ptr
}

// WithSignalSemaphoreValueCount clones a new TimelineSemaphoreSubmitInfo with the value of
// SignalSemaphoreValueCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x TimelineSemaphoreSubmitInfo) WithSignalSemaphoreValueCount(y uint32) TimelineSemaphoreSubmitInfo {
	x.signalSemaphoreValueCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *TimelineSemaphoreSubmitInfo) SetSignalSemaphoreValueCount(y uint32) {
	x.signalSemaphoreValueCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PSignalSemaphoreValues returns the value of pSignalSemaphoreValues from VkTimelineSemaphoreSubmitInfo
func (x TimelineSemaphoreSubmitInfo) PSignalSemaphoreValues() []uint64 {
	ptr := func(x **C.uint64_t) *[]uint64 { /* Slice */
		slc := unsafe.Slice((*uint64)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pSignalSemaphoreValues)
	return *ptr
}

// WithPSignalSemaphoreValues clones a new TimelineSemaphoreSubmitInfo with the value of
// PSignalSemaphoreValues updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SignalSemaphoreValueCount as the length of this field.
// SignalSemaphoreValueCount is updated with the length of the new value.
func (x TimelineSemaphoreSubmitInfo) WithPSignalSemaphoreValues(y []uint64) TimelineSemaphoreSubmitInfo {
	x.pSignalSemaphoreValues = *(func(x *[]uint64) **C.uint64_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint64_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint64_t)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithSignalSemaphoreValueCount(uint32(len(y)))
}
func (x *TimelineSemaphoreSubmitInfo) SetPSignalSemaphoreValues(y []uint64) {
	x.pSignalSemaphoreValues = *(func(x *[]uint64) **C.uint64_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint64_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint64_t)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetSignalSemaphoreValueCount(uint32(len(y)))
}

// SemaphoreTypeCreateInfo provides a go interface for VkSemaphoreTypeCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreTypeCreateInfo.html
type SemaphoreTypeCreateInfo C.struct_VkSemaphoreTypeCreateInfo

// SizeofSemaphoreTypeCreateInfo is the memory size of a SemaphoreTypeCreateInfo
var SizeofSemaphoreTypeCreateInfo int = int(unsafe.Sizeof(SemaphoreTypeCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SemaphoreTypeCreateInfo) ArpPtr(arp *AutoReleasePool) *SemaphoreTypeCreateInfo {
	ptr := newCBlock(cULong(SizeofSemaphoreTypeCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SemaphoreTypeCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SemaphoreTypeCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SemaphoreTypeCreateInfo) AsCPtr() *SemaphoreTypeCreateInfo {
	clone := (*SemaphoreTypeCreateInfo)(newCBlock(cULong(SizeofSemaphoreTypeCreateInfo)))
	*clone = x
	return clone
}

// SemaphoreTypeCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SemaphoreTypeCreateInfoCSlice(arp *AutoReleasePool, x ...SemaphoreTypeCreateInfo) []SemaphoreTypeCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSemaphoreTypeCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SemaphoreTypeCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SemaphoreTypeCreateInfoFreeCSlice releases the memory allocated by SemaphoreTypeCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SemaphoreTypeCreateInfoFreeCSlice(x []SemaphoreTypeCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SemaphoreTypeCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SemaphoreTypeCreateInfoFreeCSlice must be called on the returned slice.
func SemaphoreTypeCreateInfoMakeCSlice(x ...SemaphoreTypeCreateInfo) []SemaphoreTypeCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSemaphoreTypeCreateInfo * len(x)
	dst := unsafe.Slice((*SemaphoreTypeCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSemaphoreTypeCreateInfo
func (x SemaphoreTypeCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new SemaphoreTypeCreateInfo with the value of
// SType to the value provided in the specification.
func (x SemaphoreTypeCreateInfo) WithDefaultSType() SemaphoreTypeCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *SemaphoreTypeCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO)
}

// WithSType clones a new SemaphoreTypeCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreTypeCreateInfo) WithSType(y StructureType) SemaphoreTypeCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *SemaphoreTypeCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkSemaphoreTypeCreateInfo
func (x SemaphoreTypeCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new SemaphoreTypeCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreTypeCreateInfo) WithPNext(y unsafe.Pointer) SemaphoreTypeCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *SemaphoreTypeCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SemaphoreType returns the value of semaphoreType from VkSemaphoreTypeCreateInfo
func (x SemaphoreTypeCreateInfo) SemaphoreType() SemaphoreType {
	ptr := /* typedef */ (*SemaphoreType)(&x.semaphoreType)
	return *ptr
}

// WithSemaphoreType clones a new SemaphoreTypeCreateInfo with the value of
// SemaphoreType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreTypeCreateInfo) WithSemaphoreType(y SemaphoreType) SemaphoreTypeCreateInfo {
	x.semaphoreType = *( /* typedef */ (*C.VkSemaphoreType)(&y))
	return x
}
func (x *SemaphoreTypeCreateInfo) SetSemaphoreType(y SemaphoreType) {
	x.semaphoreType = *( /* typedef */ (*C.VkSemaphoreType)(&y))
}

// InitialValue returns the value of initialValue from VkSemaphoreTypeCreateInfo
func (x SemaphoreTypeCreateInfo) InitialValue() uint64 {
	ptr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.initialValue)
	return *ptr
}

// WithInitialValue clones a new SemaphoreTypeCreateInfo with the value of
// InitialValue updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreTypeCreateInfo) WithInitialValue(y uint64) SemaphoreTypeCreateInfo {
	x.initialValue = *(func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&y))
	return x
}
func (x *SemaphoreTypeCreateInfo) SetInitialValue(y uint64) {
	x.initialValue = *(func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&y))
}

// PhysicalDeviceTimelineSemaphoreProperties provides a go interface for VkPhysicalDeviceTimelineSemaphoreProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTimelineSemaphoreProperties.html
type PhysicalDeviceTimelineSemaphoreProperties C.struct_VkPhysicalDeviceTimelineSemaphoreProperties

// SizeofPhysicalDeviceTimelineSemaphoreProperties is the memory size of a PhysicalDeviceTimelineSemaphoreProperties
var SizeofPhysicalDeviceTimelineSemaphoreProperties int = int(unsafe.Sizeof(PhysicalDeviceTimelineSemaphoreProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceTimelineSemaphoreProperties) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceTimelineSemaphoreProperties {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceTimelineSemaphoreProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceTimelineSemaphoreProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceTimelineSemaphoreProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceTimelineSemaphoreProperties) AsCPtr() *PhysicalDeviceTimelineSemaphoreProperties {
	clone := (*PhysicalDeviceTimelineSemaphoreProperties)(newCBlock(cULong(SizeofPhysicalDeviceTimelineSemaphoreProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceTimelineSemaphorePropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceTimelineSemaphorePropertiesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceTimelineSemaphoreProperties) []PhysicalDeviceTimelineSemaphoreProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceTimelineSemaphoreProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceTimelineSemaphoreProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceTimelineSemaphorePropertiesFreeCSlice releases the memory allocated by PhysicalDeviceTimelineSemaphorePropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceTimelineSemaphorePropertiesFreeCSlice(x []PhysicalDeviceTimelineSemaphoreProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceTimelineSemaphorePropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceTimelineSemaphorePropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceTimelineSemaphorePropertiesMakeCSlice(x ...PhysicalDeviceTimelineSemaphoreProperties) []PhysicalDeviceTimelineSemaphoreProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceTimelineSemaphoreProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceTimelineSemaphoreProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceTimelineSemaphoreProperties
func (x PhysicalDeviceTimelineSemaphoreProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceTimelineSemaphoreProperties with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceTimelineSemaphoreProperties) WithDefaultSType() PhysicalDeviceTimelineSemaphoreProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceTimelineSemaphoreProperties) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES)
}

// WithSType clones a new PhysicalDeviceTimelineSemaphoreProperties with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceTimelineSemaphoreProperties) WithSType(y StructureType) PhysicalDeviceTimelineSemaphoreProperties {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceTimelineSemaphoreProperties) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceTimelineSemaphoreProperties
func (x PhysicalDeviceTimelineSemaphoreProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceTimelineSemaphoreProperties with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceTimelineSemaphoreProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceTimelineSemaphoreProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceTimelineSemaphoreProperties) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// MaxTimelineSemaphoreValueDifference returns the value of maxTimelineSemaphoreValueDifference from VkPhysicalDeviceTimelineSemaphoreProperties
func (x PhysicalDeviceTimelineSemaphoreProperties) MaxTimelineSemaphoreValueDifference() uint64 {
	ptr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.maxTimelineSemaphoreValueDifference)
	return *ptr
}

// SubpassDependency2 provides a go interface for VkSubpassDependency2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDependency2.html
type SubpassDependency2 C.struct_VkSubpassDependency2

// SizeofSubpassDependency2 is the memory size of a SubpassDependency2
var SizeofSubpassDependency2 int = int(unsafe.Sizeof(SubpassDependency2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SubpassDependency2) ArpPtr(arp *AutoReleasePool) *SubpassDependency2 {
	ptr := newCBlock(cULong(SizeofSubpassDependency2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SubpassDependency2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubpassDependency2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubpassDependency2) AsCPtr() *SubpassDependency2 {
	clone := (*SubpassDependency2)(newCBlock(cULong(SizeofSubpassDependency2)))
	*clone = x
	return clone
}

// SubpassDependency2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SubpassDependency2CSlice(arp *AutoReleasePool, x ...SubpassDependency2) []SubpassDependency2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassDependency2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SubpassDependency2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SubpassDependency2FreeCSlice releases the memory allocated by SubpassDependency2MakeCSlice.
// It does not free pointers stored inside the slice.
func SubpassDependency2FreeCSlice(x []SubpassDependency2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubpassDependency2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubpassDependency2FreeCSlice must be called on the returned slice.
func SubpassDependency2MakeCSlice(x ...SubpassDependency2) []SubpassDependency2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassDependency2 * len(x)
	dst := unsafe.Slice((*SubpassDependency2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSubpassDependency2
func (x SubpassDependency2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new SubpassDependency2 with the value of
// SType to the value provided in the specification.
func (x SubpassDependency2) WithDefaultSType() SubpassDependency2 {
	return x.WithSType(VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *SubpassDependency2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2)
}

// WithSType clones a new SubpassDependency2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithSType(y StructureType) SubpassDependency2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *SubpassDependency2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkSubpassDependency2
func (x SubpassDependency2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new SubpassDependency2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithPNext(y unsafe.Pointer) SubpassDependency2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *SubpassDependency2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SrcSubpass returns the value of srcSubpass from VkSubpassDependency2
func (x SubpassDependency2) SrcSubpass() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.srcSubpass)
	return *ptr
}

// WithSrcSubpass clones a new SubpassDependency2 with the value of
// SrcSubpass updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithSrcSubpass(y uint32) SubpassDependency2 {
	x.srcSubpass = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SubpassDependency2) SetSrcSubpass(y uint32) {
	x.srcSubpass = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// DstSubpass returns the value of dstSubpass from VkSubpassDependency2
func (x SubpassDependency2) DstSubpass() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dstSubpass)
	return *ptr
}

// WithDstSubpass clones a new SubpassDependency2 with the value of
// DstSubpass updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithDstSubpass(y uint32) SubpassDependency2 {
	x.dstSubpass = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SubpassDependency2) SetDstSubpass(y uint32) {
	x.dstSubpass = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// SrcStageMask returns the value of srcStageMask from VkSubpassDependency2
func (x SubpassDependency2) SrcStageMask() PipelineStageFlags {
	ptr := /* typedef */ (*PipelineStageFlags)(&x.srcStageMask)
	return *ptr
}

// WithSrcStageMask clones a new SubpassDependency2 with the value of
// SrcStageMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithSrcStageMask(y PipelineStageFlags) SubpassDependency2 {
	x.srcStageMask = *( /* typedef */ (*C.VkPipelineStageFlags)(&y))
	return x
}
func (x *SubpassDependency2) SetSrcStageMask(y PipelineStageFlags) {
	x.srcStageMask = *( /* typedef */ (*C.VkPipelineStageFlags)(&y))
}

// DstStageMask returns the value of dstStageMask from VkSubpassDependency2
func (x SubpassDependency2) DstStageMask() PipelineStageFlags {
	ptr := /* typedef */ (*PipelineStageFlags)(&x.dstStageMask)
	return *ptr
}

// WithDstStageMask clones a new SubpassDependency2 with the value of
// DstStageMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithDstStageMask(y PipelineStageFlags) SubpassDependency2 {
	x.dstStageMask = *( /* typedef */ (*C.VkPipelineStageFlags)(&y))
	return x
}
func (x *SubpassDependency2) SetDstStageMask(y PipelineStageFlags) {
	x.dstStageMask = *( /* typedef */ (*C.VkPipelineStageFlags)(&y))
}

// SrcAccessMask returns the value of srcAccessMask from VkSubpassDependency2
func (x SubpassDependency2) SrcAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.srcAccessMask)
	return *ptr
}

// WithSrcAccessMask clones a new SubpassDependency2 with the value of
// SrcAccessMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithSrcAccessMask(y AccessFlags) SubpassDependency2 {
	x.srcAccessMask = *( /* typedef */ (*C.VkAccessFlags)(&y))
	return x
}
func (x *SubpassDependency2) SetSrcAccessMask(y AccessFlags) {
	x.srcAccessMask = *( /* typedef */ (*C.VkAccessFlags)(&y))
}

// DstAccessMask returns the value of dstAccessMask from VkSubpassDependency2
func (x SubpassDependency2) DstAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.dstAccessMask)
	return *ptr
}

// WithDstAccessMask clones a new SubpassDependency2 with the value of
// DstAccessMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithDstAccessMask(y AccessFlags) SubpassDependency2 {
	x.dstAccessMask = *( /* typedef */ (*C.VkAccessFlags)(&y))
	return x
}
func (x *SubpassDependency2) SetDstAccessMask(y AccessFlags) {
	x.dstAccessMask = *( /* typedef */ (*C.VkAccessFlags)(&y))
}

// DependencyFlags returns the value of dependencyFlags from VkSubpassDependency2
func (x SubpassDependency2) DependencyFlags() DependencyFlags {
	ptr := /* typedef */ (*DependencyFlags)(&x.dependencyFlags)
	return *ptr
}

// WithDependencyFlags clones a new SubpassDependency2 with the value of
// DependencyFlags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithDependencyFlags(y DependencyFlags) SubpassDependency2 {
	x.dependencyFlags = *( /* typedef */ (*C.VkDependencyFlags)(&y))
	return x
}
func (x *SubpassDependency2) SetDependencyFlags(y DependencyFlags) {
	x.dependencyFlags = *( /* typedef */ (*C.VkDependencyFlags)(&y))
}

// ViewOffset returns the value of viewOffset from VkSubpassDependency2
func (x SubpassDependency2) ViewOffset() int32 {
	ptr := func(x *C.int32_t) *int32 { /* Scalar */ c2g := int32(*x); return &c2g }(&x.viewOffset)
	return *ptr
}

// WithViewOffset clones a new SubpassDependency2 with the value of
// ViewOffset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithViewOffset(y int32) SubpassDependency2 {
	x.viewOffset = *(func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&y))
	return x
}
func (x *SubpassDependency2) SetViewOffset(y int32) {
	x.viewOffset = *(func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&y))
}

// AttachmentReference2 provides a go interface for VkAttachmentReference2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentReference2.html
type AttachmentReference2 C.struct_VkAttachmentReference2

// SizeofAttachmentReference2 is the memory size of a AttachmentReference2
var SizeofAttachmentReference2 int = int(unsafe.Sizeof(AttachmentReference2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x AttachmentReference2) ArpPtr(arp *AutoReleasePool) *AttachmentReference2 {
	ptr := newCBlock(cULong(SizeofAttachmentReference2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*AttachmentReference2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *AttachmentReference2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x AttachmentReference2) AsCPtr() *AttachmentReference2 {
	clone := (*AttachmentReference2)(newCBlock(cULong(SizeofAttachmentReference2)))
	*clone = x
	return clone
}

// AttachmentReference2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func AttachmentReference2CSlice(arp *AutoReleasePool, x ...AttachmentReference2) []AttachmentReference2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAttachmentReference2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*AttachmentReference2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// AttachmentReference2FreeCSlice releases the memory allocated by AttachmentReference2MakeCSlice.
// It does not free pointers stored inside the slice.
func AttachmentReference2FreeCSlice(x []AttachmentReference2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// AttachmentReference2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. AttachmentReference2FreeCSlice must be called on the returned slice.
func AttachmentReference2MakeCSlice(x ...AttachmentReference2) []AttachmentReference2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAttachmentReference2 * len(x)
	dst := unsafe.Slice((*AttachmentReference2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkAttachmentReference2
func (x AttachmentReference2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new AttachmentReference2 with the value of
// SType to the value provided in the specification.
func (x AttachmentReference2) WithDefaultSType() AttachmentReference2 {
	return x.WithSType(VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *AttachmentReference2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2)
}

// WithSType clones a new AttachmentReference2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReference2) WithSType(y StructureType) AttachmentReference2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *AttachmentReference2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkAttachmentReference2
func (x AttachmentReference2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new AttachmentReference2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReference2) WithPNext(y unsafe.Pointer) AttachmentReference2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *AttachmentReference2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Attachment returns the value of attachment from VkAttachmentReference2
func (x AttachmentReference2) Attachment() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.attachment)
	return *ptr
}

// WithAttachment clones a new AttachmentReference2 with the value of
// Attachment updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReference2) WithAttachment(y uint32) AttachmentReference2 {
	x.attachment = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *AttachmentReference2) SetAttachment(y uint32) {
	x.attachment = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// Layout returns the value of layout from VkAttachmentReference2
func (x AttachmentReference2) Layout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.layout)
	return *ptr
}

// WithLayout clones a new AttachmentReference2 with the value of
// Layout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReference2) WithLayout(y ImageLayout) AttachmentReference2 {
	x.layout = *( /* typedef */ (*C.VkImageLayout)(&y))
	return x
}
func (x *AttachmentReference2) SetLayout(y ImageLayout) {
	x.layout = *( /* typedef */ (*C.VkImageLayout)(&y))
}

// AspectMask returns the value of aspectMask from VkAttachmentReference2
func (x AttachmentReference2) AspectMask() ImageAspectFlags {
	ptr := /* typedef */ (*ImageAspectFlags)(&x.aspectMask)
	return *ptr
}

// WithAspectMask clones a new AttachmentReference2 with the value of
// AspectMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReference2) WithAspectMask(y ImageAspectFlags) AttachmentReference2 {
	x.aspectMask = *( /* typedef */ (*C.VkImageAspectFlags)(&y))
	return x
}
func (x *AttachmentReference2) SetAspectMask(y ImageAspectFlags) {
	x.aspectMask = *( /* typedef */ (*C.VkImageAspectFlags)(&y))
}

// SubpassDescription2 provides a go interface for VkSubpassDescription2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDescription2.html
type SubpassDescription2 C.struct_VkSubpassDescription2

// SizeofSubpassDescription2 is the memory size of a SubpassDescription2
var SizeofSubpassDescription2 int = int(unsafe.Sizeof(SubpassDescription2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SubpassDescription2) ArpPtr(arp *AutoReleasePool) *SubpassDescription2 {
	ptr := newCBlock(cULong(SizeofSubpassDescription2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SubpassDescription2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubpassDescription2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubpassDescription2) AsCPtr() *SubpassDescription2 {
	clone := (*SubpassDescription2)(newCBlock(cULong(SizeofSubpassDescription2)))
	*clone = x
	return clone
}

// SubpassDescription2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SubpassDescription2CSlice(arp *AutoReleasePool, x ...SubpassDescription2) []SubpassDescription2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassDescription2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SubpassDescription2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SubpassDescription2FreeCSlice releases the memory allocated by SubpassDescription2MakeCSlice.
// It does not free pointers stored inside the slice.
func SubpassDescription2FreeCSlice(x []SubpassDescription2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubpassDescription2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubpassDescription2FreeCSlice must be called on the returned slice.
func SubpassDescription2MakeCSlice(x ...SubpassDescription2) []SubpassDescription2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassDescription2 * len(x)
	dst := unsafe.Slice((*SubpassDescription2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSubpassDescription2
func (x SubpassDescription2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new SubpassDescription2 with the value of
// SType to the value provided in the specification.
func (x SubpassDescription2) WithDefaultSType() SubpassDescription2 {
	return x.WithSType(VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *SubpassDescription2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2)
}

// WithSType clones a new SubpassDescription2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription2) WithSType(y StructureType) SubpassDescription2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *SubpassDescription2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkSubpassDescription2
func (x SubpassDescription2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new SubpassDescription2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription2) WithPNext(y unsafe.Pointer) SubpassDescription2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *SubpassDescription2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkSubpassDescription2
func (x SubpassDescription2) Flags() SubpassDescriptionFlags {
	ptr := /* typedef */ (*SubpassDescriptionFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new SubpassDescription2 with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription2) WithFlags(y SubpassDescriptionFlags) SubpassDescription2 {
	x.flags = *( /* typedef */ (*C.VkSubpassDescriptionFlags)(&y))
	return x
}
func (x *SubpassDescription2) SetFlags(y SubpassDescriptionFlags) {
	x.flags = *( /* typedef */ (*C.VkSubpassDescriptionFlags)(&y))
}

// PipelineBindPoint returns the value of pipelineBindPoint from VkSubpassDescription2
func (x SubpassDescription2) PipelineBindPoint() PipelineBindPoint {
	ptr := /* typedef */ (*PipelineBindPoint)(&x.pipelineBindPoint)
	return *ptr
}

// WithPipelineBindPoint clones a new SubpassDescription2 with the value of
// PipelineBindPoint updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription2) WithPipelineBindPoint(y PipelineBindPoint) SubpassDescription2 {
	x.pipelineBindPoint = *( /* typedef */ (*C.VkPipelineBindPoint)(&y))
	return x
}
func (x *SubpassDescription2) SetPipelineBindPoint(y PipelineBindPoint) {
	x.pipelineBindPoint = *( /* typedef */ (*C.VkPipelineBindPoint)(&y))
}

// ViewMask returns the value of viewMask from VkSubpassDescription2
func (x SubpassDescription2) ViewMask() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.viewMask)
	return *ptr
}

// WithViewMask clones a new SubpassDescription2 with the value of
// ViewMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription2) WithViewMask(y uint32) SubpassDescription2 {
	x.viewMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SubpassDescription2) SetViewMask(y uint32) {
	x.viewMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// InputAttachmentCount returns the value of inputAttachmentCount from VkSubpassDescription2
func (x SubpassDescription2) InputAttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.inputAttachmentCount)
	return *ptr
}

// WithInputAttachmentCount clones a new SubpassDescription2 with the value of
// InputAttachmentCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription2) WithInputAttachmentCount(y uint32) SubpassDescription2 {
	x.inputAttachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SubpassDescription2) SetInputAttachmentCount(y uint32) {
	x.inputAttachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PInputAttachments returns the value of pInputAttachments from VkSubpassDescription2
func (x SubpassDescription2) PInputAttachments() []AttachmentReference2 {
	ptr := func(x **C.struct_VkAttachmentReference2) *[]AttachmentReference2 { /* Slice */
		slc := unsafe.Slice((*AttachmentReference2)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pInputAttachments)
	return *ptr
}

// WithPInputAttachments clones a new SubpassDescription2 with the value of
// PInputAttachments updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines InputAttachmentCount as the length of this field.
// InputAttachmentCount is updated with the length of the new value.
func (x SubpassDescription2) WithPInputAttachments(y []AttachmentReference2) SubpassDescription2 {
	x.pInputAttachments = *(func(x *[]AttachmentReference2) **C.struct_VkAttachmentReference2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkAttachmentReference2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkAttachmentReference2)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithInputAttachmentCount(uint32(len(y)))
}
func (x *SubpassDescription2) SetPInputAttachments(y []AttachmentReference2) {
	x.pInputAttachments = *(func(x *[]AttachmentReference2) **C.struct_VkAttachmentReference2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkAttachmentReference2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkAttachmentReference2)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetInputAttachmentCount(uint32(len(y)))
}

// ColorAttachmentCount returns the value of colorAttachmentCount from VkSubpassDescription2
func (x SubpassDescription2) ColorAttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.colorAttachmentCount)
	return *ptr
}

// WithColorAttachmentCount clones a new SubpassDescription2 with the value of
// ColorAttachmentCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription2) WithColorAttachmentCount(y uint32) SubpassDescription2 {
	x.colorAttachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SubpassDescription2) SetColorAttachmentCount(y uint32) {
	x.colorAttachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PColorAttachments returns the value of pColorAttachments from VkSubpassDescription2
func (x SubpassDescription2) PColorAttachments() []AttachmentReference2 {
	ptr := func(x **C.struct_VkAttachmentReference2) *[]AttachmentReference2 { /* Slice */
		slc := unsafe.Slice((*AttachmentReference2)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pColorAttachments)
	return *ptr
}

// WithPColorAttachments clones a new SubpassDescription2 with the value of
// PColorAttachments updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines ColorAttachmentCount as the length of this field.
// ColorAttachmentCount is updated with the length of the new value.
func (x SubpassDescription2) WithPColorAttachments(y []AttachmentReference2) SubpassDescription2 {
	x.pColorAttachments = *(func(x *[]AttachmentReference2) **C.struct_VkAttachmentReference2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkAttachmentReference2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkAttachmentReference2)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithColorAttachmentCount(uint32(len(y)))
}
func (x *SubpassDescription2) SetPColorAttachments(y []AttachmentReference2) {
	x.pColorAttachments = *(func(x *[]AttachmentReference2) **C.struct_VkAttachmentReference2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkAttachmentReference2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkAttachmentReference2)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetColorAttachmentCount(uint32(len(y)))
}

// PResolveAttachments returns the value of pResolveAttachments from VkSubpassDescription2
func (x SubpassDescription2) PResolveAttachments() []AttachmentReference2 {
	ptr := func(x **C.struct_VkAttachmentReference2) *[]AttachmentReference2 { /* Slice */
		slc := unsafe.Slice((*AttachmentReference2)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pResolveAttachments)
	return *ptr
}

// WithPResolveAttachments clones a new SubpassDescription2 with the value of
// PResolveAttachments updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines ColorAttachmentCount as the length of this field.
// ColorAttachmentCount is updated with the length of the new value.
func (x SubpassDescription2) WithPResolveAttachments(y []AttachmentReference2) SubpassDescription2 {
	x.pResolveAttachments = *(func(x *[]AttachmentReference2) **C.struct_VkAttachmentReference2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkAttachmentReference2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkAttachmentReference2)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithColorAttachmentCount(uint32(len(y)))
}
func (x *SubpassDescription2) SetPResolveAttachments(y []AttachmentReference2) {
	x.pResolveAttachments = *(func(x *[]AttachmentReference2) **C.struct_VkAttachmentReference2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkAttachmentReference2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkAttachmentReference2)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetColorAttachmentCount(uint32(len(y)))
}

// PDepthStencilAttachment returns the value of pDepthStencilAttachment from VkSubpassDescription2
func (x SubpassDescription2) PDepthStencilAttachment() *AttachmentReference2 {
	ptr := func(x **C.struct_VkAttachmentReference2) **AttachmentReference2 { /* Pointer */
		c2g := (*AttachmentReference2)(*x)
		return &c2g
	}(&x.pDepthStencilAttachment)
	return *ptr
}

// WithPDepthStencilAttachment clones a new SubpassDescription2 with the value of
// PDepthStencilAttachment updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription2) WithPDepthStencilAttachment(y *AttachmentReference2) SubpassDescription2 {
	x.pDepthStencilAttachment = *(func(x **AttachmentReference2) **C.struct_VkAttachmentReference2 { /* Pointer */
		g2c := (*C.struct_VkAttachmentReference2)(*x)
		return &g2c
	}(&y))
	return x
}
func (x *SubpassDescription2) SetPDepthStencilAttachment(y *AttachmentReference2) {
	x.pDepthStencilAttachment = *(func(x **AttachmentReference2) **C.struct_VkAttachmentReference2 { /* Pointer */
		g2c := (*C.struct_VkAttachmentReference2)(*x)
		return &g2c
	}(&y))
}

// PreserveAttachmentCount returns the value of preserveAttachmentCount from VkSubpassDescription2
func (x SubpassDescription2) PreserveAttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.preserveAttachmentCount)
	return *ptr
}

// WithPreserveAttachmentCount clones a new SubpassDescription2 with the value of
// PreserveAttachmentCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription2) WithPreserveAttachmentCount(y uint32) SubpassDescription2 {
	x.preserveAttachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SubpassDescription2) SetPreserveAttachmentCount(y uint32) {
	x.preserveAttachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PPreserveAttachments returns the value of pPreserveAttachments from VkSubpassDescription2
func (x SubpassDescription2) PPreserveAttachments() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pPreserveAttachments)
	return *ptr
}

// WithPPreserveAttachments clones a new SubpassDescription2 with the value of
// PPreserveAttachments updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines PreserveAttachmentCount as the length of this field.
// PreserveAttachmentCount is updated with the length of the new value.
func (x SubpassDescription2) WithPPreserveAttachments(y []uint32) SubpassDescription2 {
	x.pPreserveAttachments = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithPreserveAttachmentCount(uint32(len(y)))
}
func (x *SubpassDescription2) SetPPreserveAttachments(y []uint32) {
	x.pPreserveAttachments = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetPreserveAttachmentCount(uint32(len(y)))
}

// AttachmentDescription2 provides a go interface for VkAttachmentDescription2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentDescription2.html
type AttachmentDescription2 C.struct_VkAttachmentDescription2

// SizeofAttachmentDescription2 is the memory size of a AttachmentDescription2
var SizeofAttachmentDescription2 int = int(unsafe.Sizeof(AttachmentDescription2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x AttachmentDescription2) ArpPtr(arp *AutoReleasePool) *AttachmentDescription2 {
	ptr := newCBlock(cULong(SizeofAttachmentDescription2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*AttachmentDescription2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *AttachmentDescription2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x AttachmentDescription2) AsCPtr() *AttachmentDescription2 {
	clone := (*AttachmentDescription2)(newCBlock(cULong(SizeofAttachmentDescription2)))
	*clone = x
	return clone
}

// AttachmentDescription2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func AttachmentDescription2CSlice(arp *AutoReleasePool, x ...AttachmentDescription2) []AttachmentDescription2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAttachmentDescription2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*AttachmentDescription2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// AttachmentDescription2FreeCSlice releases the memory allocated by AttachmentDescription2MakeCSlice.
// It does not free pointers stored inside the slice.
func AttachmentDescription2FreeCSlice(x []AttachmentDescription2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// AttachmentDescription2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. AttachmentDescription2FreeCSlice must be called on the returned slice.
func AttachmentDescription2MakeCSlice(x ...AttachmentDescription2) []AttachmentDescription2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAttachmentDescription2 * len(x)
	dst := unsafe.Slice((*AttachmentDescription2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkAttachmentDescription2
func (x AttachmentDescription2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new AttachmentDescription2 with the value of
// SType to the value provided in the specification.
func (x AttachmentDescription2) WithDefaultSType() AttachmentDescription2 {
	return x.WithSType(VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *AttachmentDescription2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2)
}

// WithSType clones a new AttachmentDescription2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithSType(y StructureType) AttachmentDescription2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *AttachmentDescription2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkAttachmentDescription2
func (x AttachmentDescription2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new AttachmentDescription2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithPNext(y unsafe.Pointer) AttachmentDescription2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *AttachmentDescription2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkAttachmentDescription2
func (x AttachmentDescription2) Flags() AttachmentDescriptionFlags {
	ptr := /* typedef */ (*AttachmentDescriptionFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new AttachmentDescription2 with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithFlags(y AttachmentDescriptionFlags) AttachmentDescription2 {
	x.flags = *( /* typedef */ (*C.VkAttachmentDescriptionFlags)(&y))
	return x
}
func (x *AttachmentDescription2) SetFlags(y AttachmentDescriptionFlags) {
	x.flags = *( /* typedef */ (*C.VkAttachmentDescriptionFlags)(&y))
}

// Format returns the value of format from VkAttachmentDescription2
func (x AttachmentDescription2) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format)
	return *ptr
}

// WithFormat clones a new AttachmentDescription2 with the value of
// Format updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithFormat(y Format) AttachmentDescription2 {
	x.format = *( /* typedef */ (*C.VkFormat)(&y))
	return x
}
func (x *AttachmentDescription2) SetFormat(y Format) {
	x.format = *( /* typedef */ (*C.VkFormat)(&y))
}

// Samples returns the value of samples from VkAttachmentDescription2
func (x AttachmentDescription2) Samples() SampleCountFlagBits {
	ptr := /* typedef */ (*SampleCountFlagBits)(&x.samples)
	return *ptr
}

// WithSamples clones a new AttachmentDescription2 with the value of
// Samples updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithSamples(y SampleCountFlagBits) AttachmentDescription2 {
	x.samples = *( /* typedef */ (*C.VkSampleCountFlagBits)(&y))
	return x
}
func (x *AttachmentDescription2) SetSamples(y SampleCountFlagBits) {
	x.samples = *( /* typedef */ (*C.VkSampleCountFlagBits)(&y))
}

// LoadOp returns the value of loadOp from VkAttachmentDescription2
func (x AttachmentDescription2) LoadOp() AttachmentLoadOp {
	ptr := /* typedef */ (*AttachmentLoadOp)(&x.loadOp)
	return *ptr
}

// WithLoadOp clones a new AttachmentDescription2 with the value of
// LoadOp updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithLoadOp(y AttachmentLoadOp) AttachmentDescription2 {
	x.loadOp = *( /* typedef */ (*C.VkAttachmentLoadOp)(&y))
	return x
}
func (x *AttachmentDescription2) SetLoadOp(y AttachmentLoadOp) {
	x.loadOp = *( /* typedef */ (*C.VkAttachmentLoadOp)(&y))
}

// StoreOp returns the value of storeOp from VkAttachmentDescription2
func (x AttachmentDescription2) StoreOp() AttachmentStoreOp {
	ptr := /* typedef */ (*AttachmentStoreOp)(&x.storeOp)
	return *ptr
}

// WithStoreOp clones a new AttachmentDescription2 with the value of
// StoreOp updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithStoreOp(y AttachmentStoreOp) AttachmentDescription2 {
	x.storeOp = *( /* typedef */ (*C.VkAttachmentStoreOp)(&y))
	return x
}
func (x *AttachmentDescription2) SetStoreOp(y AttachmentStoreOp) {
	x.storeOp = *( /* typedef */ (*C.VkAttachmentStoreOp)(&y))
}

// StencilLoadOp returns the value of stencilLoadOp from VkAttachmentDescription2
func (x AttachmentDescription2) StencilLoadOp() AttachmentLoadOp {
	ptr := /* typedef */ (*AttachmentLoadOp)(&x.stencilLoadOp)
	return *ptr
}

// WithStencilLoadOp clones a new AttachmentDescription2 with the value of
// StencilLoadOp updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithStencilLoadOp(y AttachmentLoadOp) AttachmentDescription2 {
	x.stencilLoadOp = *( /* typedef */ (*C.VkAttachmentLoadOp)(&y))
	return x
}
func (x *AttachmentDescription2) SetStencilLoadOp(y AttachmentLoadOp) {
	x.stencilLoadOp = *( /* typedef */ (*C.VkAttachmentLoadOp)(&y))
}

// StencilStoreOp returns the value of stencilStoreOp from VkAttachmentDescription2
func (x AttachmentDescription2) StencilStoreOp() AttachmentStoreOp {
	ptr := /* typedef */ (*AttachmentStoreOp)(&x.stencilStoreOp)
	return *ptr
}

// WithStencilStoreOp clones a new AttachmentDescription2 with the value of
// StencilStoreOp updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithStencilStoreOp(y AttachmentStoreOp) AttachmentDescription2 {
	x.stencilStoreOp = *( /* typedef */ (*C.VkAttachmentStoreOp)(&y))
	return x
}
func (x *AttachmentDescription2) SetStencilStoreOp(y AttachmentStoreOp) {
	x.stencilStoreOp = *( /* typedef */ (*C.VkAttachmentStoreOp)(&y))
}

// InitialLayout returns the value of initialLayout from VkAttachmentDescription2
func (x AttachmentDescription2) InitialLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.initialLayout)
	return *ptr
}

// WithInitialLayout clones a new AttachmentDescription2 with the value of
// InitialLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithInitialLayout(y ImageLayout) AttachmentDescription2 {
	x.initialLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
	return x
}
func (x *AttachmentDescription2) SetInitialLayout(y ImageLayout) {
	x.initialLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
}

// FinalLayout returns the value of finalLayout from VkAttachmentDescription2
func (x AttachmentDescription2) FinalLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.finalLayout)
	return *ptr
}

// WithFinalLayout clones a new AttachmentDescription2 with the value of
// FinalLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithFinalLayout(y ImageLayout) AttachmentDescription2 {
	x.finalLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
	return x
}
func (x *AttachmentDescription2) SetFinalLayout(y ImageLayout) {
	x.finalLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
}

// RenderPassCreateInfo2 provides a go interface for VkRenderPassCreateInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreateInfo2.html
type RenderPassCreateInfo2 C.struct_VkRenderPassCreateInfo2

// SizeofRenderPassCreateInfo2 is the memory size of a RenderPassCreateInfo2
var SizeofRenderPassCreateInfo2 int = int(unsafe.Sizeof(RenderPassCreateInfo2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x RenderPassCreateInfo2) ArpPtr(arp *AutoReleasePool) *RenderPassCreateInfo2 {
	ptr := newCBlock(cULong(SizeofRenderPassCreateInfo2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*RenderPassCreateInfo2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *RenderPassCreateInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x RenderPassCreateInfo2) AsCPtr() *RenderPassCreateInfo2 {
	clone := (*RenderPassCreateInfo2)(newCBlock(cULong(SizeofRenderPassCreateInfo2)))
	*clone = x
	return clone
}

// RenderPassCreateInfo2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func RenderPassCreateInfo2CSlice(arp *AutoReleasePool, x ...RenderPassCreateInfo2) []RenderPassCreateInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderPassCreateInfo2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*RenderPassCreateInfo2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// RenderPassCreateInfo2FreeCSlice releases the memory allocated by RenderPassCreateInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func RenderPassCreateInfo2FreeCSlice(x []RenderPassCreateInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// RenderPassCreateInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. RenderPassCreateInfo2FreeCSlice must be called on the returned slice.
func RenderPassCreateInfo2MakeCSlice(x ...RenderPassCreateInfo2) []RenderPassCreateInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderPassCreateInfo2 * len(x)
	dst := unsafe.Slice((*RenderPassCreateInfo2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new RenderPassCreateInfo2 with the value of
// SType to the value provided in the specification.
func (x RenderPassCreateInfo2) WithDefaultSType() RenderPassCreateInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *RenderPassCreateInfo2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2)
}

// WithSType clones a new RenderPassCreateInfo2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo2) WithSType(y StructureType) RenderPassCreateInfo2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *RenderPassCreateInfo2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new RenderPassCreateInfo2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo2) WithPNext(y unsafe.Pointer) RenderPassCreateInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *RenderPassCreateInfo2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) Flags() RenderPassCreateFlags {
	ptr := /* typedef */ (*RenderPassCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new RenderPassCreateInfo2 with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo2) WithFlags(y RenderPassCreateFlags) RenderPassCreateInfo2 {
	x.flags = *( /* typedef */ (*C.VkRenderPassCreateFlags)(&y))
	return x
}
func (x *RenderPassCreateInfo2) SetFlags(y RenderPassCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkRenderPassCreateFlags)(&y))
}

// AttachmentCount returns the value of attachmentCount from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) AttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.attachmentCount)
	return *ptr
}

// WithAttachmentCount clones a new RenderPassCreateInfo2 with the value of
// AttachmentCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo2) WithAttachmentCount(y uint32) RenderPassCreateInfo2 {
	x.attachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *RenderPassCreateInfo2) SetAttachmentCount(y uint32) {
	x.attachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PAttachments returns the value of pAttachments from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) PAttachments() []AttachmentDescription2 {
	ptr := func(x **C.struct_VkAttachmentDescription2) *[]AttachmentDescription2 { /* Slice */
		slc := unsafe.Slice((*AttachmentDescription2)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pAttachments)
	return *ptr
}

// WithPAttachments clones a new RenderPassCreateInfo2 with the value of
// PAttachments updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines AttachmentCount as the length of this field.
// AttachmentCount is updated with the length of the new value.
func (x RenderPassCreateInfo2) WithPAttachments(y []AttachmentDescription2) RenderPassCreateInfo2 {
	x.pAttachments = *(func(x *[]AttachmentDescription2) **C.struct_VkAttachmentDescription2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkAttachmentDescription2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkAttachmentDescription2)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithAttachmentCount(uint32(len(y)))
}
func (x *RenderPassCreateInfo2) SetPAttachments(y []AttachmentDescription2) {
	x.pAttachments = *(func(x *[]AttachmentDescription2) **C.struct_VkAttachmentDescription2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkAttachmentDescription2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkAttachmentDescription2)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetAttachmentCount(uint32(len(y)))
}

// SubpassCount returns the value of subpassCount from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) SubpassCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.subpassCount)
	return *ptr
}

// WithSubpassCount clones a new RenderPassCreateInfo2 with the value of
// SubpassCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo2) WithSubpassCount(y uint32) RenderPassCreateInfo2 {
	x.subpassCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *RenderPassCreateInfo2) SetSubpassCount(y uint32) {
	x.subpassCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PSubpasses returns the value of pSubpasses from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) PSubpasses() []SubpassDescription2 {
	ptr := func(x **C.struct_VkSubpassDescription2) *[]SubpassDescription2 { /* Slice */
		slc := unsafe.Slice((*SubpassDescription2)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pSubpasses)
	return *ptr
}

// WithPSubpasses clones a new RenderPassCreateInfo2 with the value of
// PSubpasses updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SubpassCount as the length of this field.
// SubpassCount is updated with the length of the new value.
func (x RenderPassCreateInfo2) WithPSubpasses(y []SubpassDescription2) RenderPassCreateInfo2 {
	x.pSubpasses = *(func(x *[]SubpassDescription2) **C.struct_VkSubpassDescription2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSubpassDescription2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSubpassDescription2)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithSubpassCount(uint32(len(y)))
}
func (x *RenderPassCreateInfo2) SetPSubpasses(y []SubpassDescription2) {
	x.pSubpasses = *(func(x *[]SubpassDescription2) **C.struct_VkSubpassDescription2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSubpassDescription2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSubpassDescription2)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetSubpassCount(uint32(len(y)))
}

// DependencyCount returns the value of dependencyCount from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) DependencyCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dependencyCount)
	return *ptr
}

// WithDependencyCount clones a new RenderPassCreateInfo2 with the value of
// DependencyCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo2) WithDependencyCount(y uint32) RenderPassCreateInfo2 {
	x.dependencyCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *RenderPassCreateInfo2) SetDependencyCount(y uint32) {
	x.dependencyCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PDependencies returns the value of pDependencies from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) PDependencies() []SubpassDependency2 {
	ptr := func(x **C.struct_VkSubpassDependency2) *[]SubpassDependency2 { /* Slice */
		slc := unsafe.Slice((*SubpassDependency2)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pDependencies)
	return *ptr
}

// WithPDependencies clones a new RenderPassCreateInfo2 with the value of
// PDependencies updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DependencyCount as the length of this field.
// DependencyCount is updated with the length of the new value.
func (x RenderPassCreateInfo2) WithPDependencies(y []SubpassDependency2) RenderPassCreateInfo2 {
	x.pDependencies = *(func(x *[]SubpassDependency2) **C.struct_VkSubpassDependency2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSubpassDependency2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSubpassDependency2)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithDependencyCount(uint32(len(y)))
}
func (x *RenderPassCreateInfo2) SetPDependencies(y []SubpassDependency2) {
	x.pDependencies = *(func(x *[]SubpassDependency2) **C.struct_VkSubpassDependency2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSubpassDependency2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSubpassDependency2)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetDependencyCount(uint32(len(y)))
}

// CorrelatedViewMaskCount returns the value of correlatedViewMaskCount from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) CorrelatedViewMaskCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.correlatedViewMaskCount)
	return *ptr
}

// WithCorrelatedViewMaskCount clones a new RenderPassCreateInfo2 with the value of
// CorrelatedViewMaskCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo2) WithCorrelatedViewMaskCount(y uint32) RenderPassCreateInfo2 {
	x.correlatedViewMaskCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *RenderPassCreateInfo2) SetCorrelatedViewMaskCount(y uint32) {
	x.correlatedViewMaskCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PCorrelatedViewMasks returns the value of pCorrelatedViewMasks from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) PCorrelatedViewMasks() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pCorrelatedViewMasks)
	return *ptr
}

// WithPCorrelatedViewMasks clones a new RenderPassCreateInfo2 with the value of
// PCorrelatedViewMasks updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines CorrelatedViewMaskCount as the length of this field.
// CorrelatedViewMaskCount is updated with the length of the new value.
func (x RenderPassCreateInfo2) WithPCorrelatedViewMasks(y []uint32) RenderPassCreateInfo2 {
	x.pCorrelatedViewMasks = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithCorrelatedViewMaskCount(uint32(len(y)))
}
func (x *RenderPassCreateInfo2) SetPCorrelatedViewMasks(y []uint32) {
	x.pCorrelatedViewMasks = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetCorrelatedViewMaskCount(uint32(len(y)))
}

// SubpassBeginInfo provides a go interface for VkSubpassBeginInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassBeginInfo.html
type SubpassBeginInfo C.struct_VkSubpassBeginInfo

// SizeofSubpassBeginInfo is the memory size of a SubpassBeginInfo
var SizeofSubpassBeginInfo int = int(unsafe.Sizeof(SubpassBeginInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SubpassBeginInfo) ArpPtr(arp *AutoReleasePool) *SubpassBeginInfo {
	ptr := newCBlock(cULong(SizeofSubpassBeginInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SubpassBeginInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubpassBeginInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubpassBeginInfo) AsCPtr() *SubpassBeginInfo {
	clone := (*SubpassBeginInfo)(newCBlock(cULong(SizeofSubpassBeginInfo)))
	*clone = x
	return clone
}

// SubpassBeginInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SubpassBeginInfoCSlice(arp *AutoReleasePool, x ...SubpassBeginInfo) []SubpassBeginInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassBeginInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SubpassBeginInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SubpassBeginInfoFreeCSlice releases the memory allocated by SubpassBeginInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SubpassBeginInfoFreeCSlice(x []SubpassBeginInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubpassBeginInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubpassBeginInfoFreeCSlice must be called on the returned slice.
func SubpassBeginInfoMakeCSlice(x ...SubpassBeginInfo) []SubpassBeginInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassBeginInfo * len(x)
	dst := unsafe.Slice((*SubpassBeginInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSubpassBeginInfo
func (x SubpassBeginInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new SubpassBeginInfo with the value of
// SType to the value provided in the specification.
func (x SubpassBeginInfo) WithDefaultSType() SubpassBeginInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *SubpassBeginInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO)
}

// WithSType clones a new SubpassBeginInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassBeginInfo) WithSType(y StructureType) SubpassBeginInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *SubpassBeginInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkSubpassBeginInfo
func (x SubpassBeginInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new SubpassBeginInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassBeginInfo) WithPNext(y unsafe.Pointer) SubpassBeginInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *SubpassBeginInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Contents returns the value of contents from VkSubpassBeginInfo
func (x SubpassBeginInfo) Contents() SubpassContents {
	ptr := /* typedef */ (*SubpassContents)(&x.contents)
	return *ptr
}

// WithContents clones a new SubpassBeginInfo with the value of
// Contents updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassBeginInfo) WithContents(y SubpassContents) SubpassBeginInfo {
	x.contents = *( /* typedef */ (*C.VkSubpassContents)(&y))
	return x
}
func (x *SubpassBeginInfo) SetContents(y SubpassContents) {
	x.contents = *( /* typedef */ (*C.VkSubpassContents)(&y))
}

// SubpassEndInfo provides a go interface for VkSubpassEndInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassEndInfo.html
type SubpassEndInfo C.struct_VkSubpassEndInfo

// SizeofSubpassEndInfo is the memory size of a SubpassEndInfo
var SizeofSubpassEndInfo int = int(unsafe.Sizeof(SubpassEndInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SubpassEndInfo) ArpPtr(arp *AutoReleasePool) *SubpassEndInfo {
	ptr := newCBlock(cULong(SizeofSubpassEndInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SubpassEndInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubpassEndInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubpassEndInfo) AsCPtr() *SubpassEndInfo {
	clone := (*SubpassEndInfo)(newCBlock(cULong(SizeofSubpassEndInfo)))
	*clone = x
	return clone
}

// SubpassEndInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SubpassEndInfoCSlice(arp *AutoReleasePool, x ...SubpassEndInfo) []SubpassEndInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassEndInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SubpassEndInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SubpassEndInfoFreeCSlice releases the memory allocated by SubpassEndInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SubpassEndInfoFreeCSlice(x []SubpassEndInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubpassEndInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubpassEndInfoFreeCSlice must be called on the returned slice.
func SubpassEndInfoMakeCSlice(x ...SubpassEndInfo) []SubpassEndInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassEndInfo * len(x)
	dst := unsafe.Slice((*SubpassEndInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSubpassEndInfo
func (x SubpassEndInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new SubpassEndInfo with the value of
// SType to the value provided in the specification.
func (x SubpassEndInfo) WithDefaultSType() SubpassEndInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SUBPASS_END_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *SubpassEndInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_SUBPASS_END_INFO)
}

// WithSType clones a new SubpassEndInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassEndInfo) WithSType(y StructureType) SubpassEndInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *SubpassEndInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkSubpassEndInfo
func (x SubpassEndInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new SubpassEndInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassEndInfo) WithPNext(y unsafe.Pointer) SubpassEndInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *SubpassEndInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// PhysicalDeviceTimelineSemaphoreFeatures provides a go interface for VkPhysicalDeviceTimelineSemaphoreFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTimelineSemaphoreFeatures.html
type PhysicalDeviceTimelineSemaphoreFeatures C.struct_VkPhysicalDeviceTimelineSemaphoreFeatures

// SizeofPhysicalDeviceTimelineSemaphoreFeatures is the memory size of a PhysicalDeviceTimelineSemaphoreFeatures
var SizeofPhysicalDeviceTimelineSemaphoreFeatures int = int(unsafe.Sizeof(PhysicalDeviceTimelineSemaphoreFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceTimelineSemaphoreFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceTimelineSemaphoreFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceTimelineSemaphoreFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceTimelineSemaphoreFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceTimelineSemaphoreFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceTimelineSemaphoreFeatures) AsCPtr() *PhysicalDeviceTimelineSemaphoreFeatures {
	clone := (*PhysicalDeviceTimelineSemaphoreFeatures)(newCBlock(cULong(SizeofPhysicalDeviceTimelineSemaphoreFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceTimelineSemaphoreFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceTimelineSemaphoreFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceTimelineSemaphoreFeatures) []PhysicalDeviceTimelineSemaphoreFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceTimelineSemaphoreFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceTimelineSemaphoreFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceTimelineSemaphoreFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceTimelineSemaphoreFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceTimelineSemaphoreFeaturesFreeCSlice(x []PhysicalDeviceTimelineSemaphoreFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceTimelineSemaphoreFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceTimelineSemaphoreFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceTimelineSemaphoreFeaturesMakeCSlice(x ...PhysicalDeviceTimelineSemaphoreFeatures) []PhysicalDeviceTimelineSemaphoreFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceTimelineSemaphoreFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceTimelineSemaphoreFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceTimelineSemaphoreFeatures
func (x PhysicalDeviceTimelineSemaphoreFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceTimelineSemaphoreFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceTimelineSemaphoreFeatures) WithDefaultSType() PhysicalDeviceTimelineSemaphoreFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceTimelineSemaphoreFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES)
}

// WithSType clones a new PhysicalDeviceTimelineSemaphoreFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceTimelineSemaphoreFeatures) WithSType(y StructureType) PhysicalDeviceTimelineSemaphoreFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceTimelineSemaphoreFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceTimelineSemaphoreFeatures
func (x PhysicalDeviceTimelineSemaphoreFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceTimelineSemaphoreFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceTimelineSemaphoreFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceTimelineSemaphoreFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceTimelineSemaphoreFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// TimelineSemaphore returns the value of timelineSemaphore from VkPhysicalDeviceTimelineSemaphoreFeatures
func (x PhysicalDeviceTimelineSemaphoreFeatures) TimelineSemaphore() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.timelineSemaphore)
	return *ptr
}

// WithTimelineSemaphore clones a new PhysicalDeviceTimelineSemaphoreFeatures with the value of
// TimelineSemaphore updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceTimelineSemaphoreFeatures) WithTimelineSemaphore(y Bool32) PhysicalDeviceTimelineSemaphoreFeatures {
	x.timelineSemaphore = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceTimelineSemaphoreFeatures) SetTimelineSemaphore(y Bool32) {
	x.timelineSemaphore = *( /* typedef */ (*C.VkBool32)(&y))
}

// ImageFormatListCreateInfo provides a go interface for VkImageFormatListCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageFormatListCreateInfo.html
type ImageFormatListCreateInfo C.struct_VkImageFormatListCreateInfo

// SizeofImageFormatListCreateInfo is the memory size of a ImageFormatListCreateInfo
var SizeofImageFormatListCreateInfo int = int(unsafe.Sizeof(ImageFormatListCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ImageFormatListCreateInfo) ArpPtr(arp *AutoReleasePool) *ImageFormatListCreateInfo {
	ptr := newCBlock(cULong(SizeofImageFormatListCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ImageFormatListCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageFormatListCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageFormatListCreateInfo) AsCPtr() *ImageFormatListCreateInfo {
	clone := (*ImageFormatListCreateInfo)(newCBlock(cULong(SizeofImageFormatListCreateInfo)))
	*clone = x
	return clone
}

// ImageFormatListCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ImageFormatListCreateInfoCSlice(arp *AutoReleasePool, x ...ImageFormatListCreateInfo) []ImageFormatListCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageFormatListCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ImageFormatListCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ImageFormatListCreateInfoFreeCSlice releases the memory allocated by ImageFormatListCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageFormatListCreateInfoFreeCSlice(x []ImageFormatListCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageFormatListCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageFormatListCreateInfoFreeCSlice must be called on the returned slice.
func ImageFormatListCreateInfoMakeCSlice(x ...ImageFormatListCreateInfo) []ImageFormatListCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageFormatListCreateInfo * len(x)
	dst := unsafe.Slice((*ImageFormatListCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageFormatListCreateInfo
func (x ImageFormatListCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ImageFormatListCreateInfo with the value of
// SType to the value provided in the specification.
func (x ImageFormatListCreateInfo) WithDefaultSType() ImageFormatListCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ImageFormatListCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO)
}

// WithSType clones a new ImageFormatListCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageFormatListCreateInfo) WithSType(y StructureType) ImageFormatListCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ImageFormatListCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkImageFormatListCreateInfo
func (x ImageFormatListCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ImageFormatListCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageFormatListCreateInfo) WithPNext(y unsafe.Pointer) ImageFormatListCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ImageFormatListCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// ViewFormatCount returns the value of viewFormatCount from VkImageFormatListCreateInfo
func (x ImageFormatListCreateInfo) ViewFormatCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.viewFormatCount)
	return *ptr
}

// WithViewFormatCount clones a new ImageFormatListCreateInfo with the value of
// ViewFormatCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageFormatListCreateInfo) WithViewFormatCount(y uint32) ImageFormatListCreateInfo {
	x.viewFormatCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *ImageFormatListCreateInfo) SetViewFormatCount(y uint32) {
	x.viewFormatCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PViewFormats returns the value of pViewFormats from VkImageFormatListCreateInfo
func (x ImageFormatListCreateInfo) PViewFormats() []Format {
	ptr := func(x **C.VkFormat) *[]Format { /* Slice */
		slc := unsafe.Slice((*Format)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pViewFormats)
	return *ptr
}

// WithPViewFormats clones a new ImageFormatListCreateInfo with the value of
// PViewFormats updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines ViewFormatCount as the length of this field.
// ViewFormatCount is updated with the length of the new value.
func (x ImageFormatListCreateInfo) WithPViewFormats(y []Format) ImageFormatListCreateInfo {
	x.pViewFormats = *(func(x *[]Format) **C.VkFormat { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkFormat)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkFormat)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithViewFormatCount(uint32(len(y)))
}
func (x *ImageFormatListCreateInfo) SetPViewFormats(y []Format) {
	x.pViewFormats = *(func(x *[]Format) **C.VkFormat { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkFormat)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkFormat)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetViewFormatCount(uint32(len(y)))
}

// PhysicalDeviceHostQueryResetFeatures provides a go interface for VkPhysicalDeviceHostQueryResetFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceHostQueryResetFeatures.html
type PhysicalDeviceHostQueryResetFeatures C.struct_VkPhysicalDeviceHostQueryResetFeatures

// SizeofPhysicalDeviceHostQueryResetFeatures is the memory size of a PhysicalDeviceHostQueryResetFeatures
var SizeofPhysicalDeviceHostQueryResetFeatures int = int(unsafe.Sizeof(PhysicalDeviceHostQueryResetFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceHostQueryResetFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceHostQueryResetFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceHostQueryResetFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceHostQueryResetFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceHostQueryResetFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceHostQueryResetFeatures) AsCPtr() *PhysicalDeviceHostQueryResetFeatures {
	clone := (*PhysicalDeviceHostQueryResetFeatures)(newCBlock(cULong(SizeofPhysicalDeviceHostQueryResetFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceHostQueryResetFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceHostQueryResetFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceHostQueryResetFeatures) []PhysicalDeviceHostQueryResetFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceHostQueryResetFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceHostQueryResetFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceHostQueryResetFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceHostQueryResetFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceHostQueryResetFeaturesFreeCSlice(x []PhysicalDeviceHostQueryResetFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceHostQueryResetFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceHostQueryResetFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceHostQueryResetFeaturesMakeCSlice(x ...PhysicalDeviceHostQueryResetFeatures) []PhysicalDeviceHostQueryResetFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceHostQueryResetFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceHostQueryResetFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceHostQueryResetFeatures
func (x PhysicalDeviceHostQueryResetFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceHostQueryResetFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceHostQueryResetFeatures) WithDefaultSType() PhysicalDeviceHostQueryResetFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceHostQueryResetFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES)
}

// WithSType clones a new PhysicalDeviceHostQueryResetFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceHostQueryResetFeatures) WithSType(y StructureType) PhysicalDeviceHostQueryResetFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceHostQueryResetFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceHostQueryResetFeatures
func (x PhysicalDeviceHostQueryResetFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceHostQueryResetFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceHostQueryResetFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceHostQueryResetFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceHostQueryResetFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// HostQueryReset returns the value of hostQueryReset from VkPhysicalDeviceHostQueryResetFeatures
func (x PhysicalDeviceHostQueryResetFeatures) HostQueryReset() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.hostQueryReset)
	return *ptr
}

// WithHostQueryReset clones a new PhysicalDeviceHostQueryResetFeatures with the value of
// HostQueryReset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceHostQueryResetFeatures) WithHostQueryReset(y Bool32) PhysicalDeviceHostQueryResetFeatures {
	x.hostQueryReset = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceHostQueryResetFeatures) SetHostQueryReset(y Bool32) {
	x.hostQueryReset = *( /* typedef */ (*C.VkBool32)(&y))
}

// AttachmentDescriptionStencilLayout provides a go interface for VkAttachmentDescriptionStencilLayout.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentDescriptionStencilLayout.html
type AttachmentDescriptionStencilLayout C.struct_VkAttachmentDescriptionStencilLayout

// SizeofAttachmentDescriptionStencilLayout is the memory size of a AttachmentDescriptionStencilLayout
var SizeofAttachmentDescriptionStencilLayout int = int(unsafe.Sizeof(AttachmentDescriptionStencilLayout{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x AttachmentDescriptionStencilLayout) ArpPtr(arp *AutoReleasePool) *AttachmentDescriptionStencilLayout {
	ptr := newCBlock(cULong(SizeofAttachmentDescriptionStencilLayout))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*AttachmentDescriptionStencilLayout)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *AttachmentDescriptionStencilLayout) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x AttachmentDescriptionStencilLayout) AsCPtr() *AttachmentDescriptionStencilLayout {
	clone := (*AttachmentDescriptionStencilLayout)(newCBlock(cULong(SizeofAttachmentDescriptionStencilLayout)))
	*clone = x
	return clone
}

// AttachmentDescriptionStencilLayoutCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func AttachmentDescriptionStencilLayoutCSlice(arp *AutoReleasePool, x ...AttachmentDescriptionStencilLayout) []AttachmentDescriptionStencilLayout {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAttachmentDescriptionStencilLayout * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*AttachmentDescriptionStencilLayout)(ptr), len(x))
	copy(dst, x)
	return dst
}

// AttachmentDescriptionStencilLayoutFreeCSlice releases the memory allocated by AttachmentDescriptionStencilLayoutMakeCSlice.
// It does not free pointers stored inside the slice.
func AttachmentDescriptionStencilLayoutFreeCSlice(x []AttachmentDescriptionStencilLayout) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// AttachmentDescriptionStencilLayoutMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. AttachmentDescriptionStencilLayoutFreeCSlice must be called on the returned slice.
func AttachmentDescriptionStencilLayoutMakeCSlice(x ...AttachmentDescriptionStencilLayout) []AttachmentDescriptionStencilLayout {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAttachmentDescriptionStencilLayout * len(x)
	dst := unsafe.Slice((*AttachmentDescriptionStencilLayout)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkAttachmentDescriptionStencilLayout
func (x AttachmentDescriptionStencilLayout) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new AttachmentDescriptionStencilLayout with the value of
// SType to the value provided in the specification.
func (x AttachmentDescriptionStencilLayout) WithDefaultSType() AttachmentDescriptionStencilLayout {
	return x.WithSType(VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *AttachmentDescriptionStencilLayout) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT)
}

// WithSType clones a new AttachmentDescriptionStencilLayout with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescriptionStencilLayout) WithSType(y StructureType) AttachmentDescriptionStencilLayout {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *AttachmentDescriptionStencilLayout) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkAttachmentDescriptionStencilLayout
func (x AttachmentDescriptionStencilLayout) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new AttachmentDescriptionStencilLayout with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescriptionStencilLayout) WithPNext(y unsafe.Pointer) AttachmentDescriptionStencilLayout {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *AttachmentDescriptionStencilLayout) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// StencilInitialLayout returns the value of stencilInitialLayout from VkAttachmentDescriptionStencilLayout
func (x AttachmentDescriptionStencilLayout) StencilInitialLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.stencilInitialLayout)
	return *ptr
}

// WithStencilInitialLayout clones a new AttachmentDescriptionStencilLayout with the value of
// StencilInitialLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescriptionStencilLayout) WithStencilInitialLayout(y ImageLayout) AttachmentDescriptionStencilLayout {
	x.stencilInitialLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
	return x
}
func (x *AttachmentDescriptionStencilLayout) SetStencilInitialLayout(y ImageLayout) {
	x.stencilInitialLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
}

// StencilFinalLayout returns the value of stencilFinalLayout from VkAttachmentDescriptionStencilLayout
func (x AttachmentDescriptionStencilLayout) StencilFinalLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.stencilFinalLayout)
	return *ptr
}

// WithStencilFinalLayout clones a new AttachmentDescriptionStencilLayout with the value of
// StencilFinalLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescriptionStencilLayout) WithStencilFinalLayout(y ImageLayout) AttachmentDescriptionStencilLayout {
	x.stencilFinalLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
	return x
}
func (x *AttachmentDescriptionStencilLayout) SetStencilFinalLayout(y ImageLayout) {
	x.stencilFinalLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
}

// AttachmentReferenceStencilLayout provides a go interface for VkAttachmentReferenceStencilLayout.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentReferenceStencilLayout.html
type AttachmentReferenceStencilLayout C.struct_VkAttachmentReferenceStencilLayout

// SizeofAttachmentReferenceStencilLayout is the memory size of a AttachmentReferenceStencilLayout
var SizeofAttachmentReferenceStencilLayout int = int(unsafe.Sizeof(AttachmentReferenceStencilLayout{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x AttachmentReferenceStencilLayout) ArpPtr(arp *AutoReleasePool) *AttachmentReferenceStencilLayout {
	ptr := newCBlock(cULong(SizeofAttachmentReferenceStencilLayout))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*AttachmentReferenceStencilLayout)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *AttachmentReferenceStencilLayout) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x AttachmentReferenceStencilLayout) AsCPtr() *AttachmentReferenceStencilLayout {
	clone := (*AttachmentReferenceStencilLayout)(newCBlock(cULong(SizeofAttachmentReferenceStencilLayout)))
	*clone = x
	return clone
}

// AttachmentReferenceStencilLayoutCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func AttachmentReferenceStencilLayoutCSlice(arp *AutoReleasePool, x ...AttachmentReferenceStencilLayout) []AttachmentReferenceStencilLayout {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAttachmentReferenceStencilLayout * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*AttachmentReferenceStencilLayout)(ptr), len(x))
	copy(dst, x)
	return dst
}

// AttachmentReferenceStencilLayoutFreeCSlice releases the memory allocated by AttachmentReferenceStencilLayoutMakeCSlice.
// It does not free pointers stored inside the slice.
func AttachmentReferenceStencilLayoutFreeCSlice(x []AttachmentReferenceStencilLayout) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// AttachmentReferenceStencilLayoutMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. AttachmentReferenceStencilLayoutFreeCSlice must be called on the returned slice.
func AttachmentReferenceStencilLayoutMakeCSlice(x ...AttachmentReferenceStencilLayout) []AttachmentReferenceStencilLayout {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAttachmentReferenceStencilLayout * len(x)
	dst := unsafe.Slice((*AttachmentReferenceStencilLayout)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkAttachmentReferenceStencilLayout
func (x AttachmentReferenceStencilLayout) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new AttachmentReferenceStencilLayout with the value of
// SType to the value provided in the specification.
func (x AttachmentReferenceStencilLayout) WithDefaultSType() AttachmentReferenceStencilLayout {
	return x.WithSType(VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *AttachmentReferenceStencilLayout) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT)
}

// WithSType clones a new AttachmentReferenceStencilLayout with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReferenceStencilLayout) WithSType(y StructureType) AttachmentReferenceStencilLayout {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *AttachmentReferenceStencilLayout) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkAttachmentReferenceStencilLayout
func (x AttachmentReferenceStencilLayout) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new AttachmentReferenceStencilLayout with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReferenceStencilLayout) WithPNext(y unsafe.Pointer) AttachmentReferenceStencilLayout {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *AttachmentReferenceStencilLayout) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// StencilLayout returns the value of stencilLayout from VkAttachmentReferenceStencilLayout
func (x AttachmentReferenceStencilLayout) StencilLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.stencilLayout)
	return *ptr
}

// WithStencilLayout clones a new AttachmentReferenceStencilLayout with the value of
// StencilLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReferenceStencilLayout) WithStencilLayout(y ImageLayout) AttachmentReferenceStencilLayout {
	x.stencilLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
	return x
}
func (x *AttachmentReferenceStencilLayout) SetStencilLayout(y ImageLayout) {
	x.stencilLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
}

// SubpassDescriptionDepthStencilResolve provides a go interface for VkSubpassDescriptionDepthStencilResolve.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDescriptionDepthStencilResolve.html
type SubpassDescriptionDepthStencilResolve C.struct_VkSubpassDescriptionDepthStencilResolve

// SizeofSubpassDescriptionDepthStencilResolve is the memory size of a SubpassDescriptionDepthStencilResolve
var SizeofSubpassDescriptionDepthStencilResolve int = int(unsafe.Sizeof(SubpassDescriptionDepthStencilResolve{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SubpassDescriptionDepthStencilResolve) ArpPtr(arp *AutoReleasePool) *SubpassDescriptionDepthStencilResolve {
	ptr := newCBlock(cULong(SizeofSubpassDescriptionDepthStencilResolve))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SubpassDescriptionDepthStencilResolve)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubpassDescriptionDepthStencilResolve) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubpassDescriptionDepthStencilResolve) AsCPtr() *SubpassDescriptionDepthStencilResolve {
	clone := (*SubpassDescriptionDepthStencilResolve)(newCBlock(cULong(SizeofSubpassDescriptionDepthStencilResolve)))
	*clone = x
	return clone
}

// SubpassDescriptionDepthStencilResolveCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SubpassDescriptionDepthStencilResolveCSlice(arp *AutoReleasePool, x ...SubpassDescriptionDepthStencilResolve) []SubpassDescriptionDepthStencilResolve {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassDescriptionDepthStencilResolve * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SubpassDescriptionDepthStencilResolve)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SubpassDescriptionDepthStencilResolveFreeCSlice releases the memory allocated by SubpassDescriptionDepthStencilResolveMakeCSlice.
// It does not free pointers stored inside the slice.
func SubpassDescriptionDepthStencilResolveFreeCSlice(x []SubpassDescriptionDepthStencilResolve) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubpassDescriptionDepthStencilResolveMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubpassDescriptionDepthStencilResolveFreeCSlice must be called on the returned slice.
func SubpassDescriptionDepthStencilResolveMakeCSlice(x ...SubpassDescriptionDepthStencilResolve) []SubpassDescriptionDepthStencilResolve {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassDescriptionDepthStencilResolve * len(x)
	dst := unsafe.Slice((*SubpassDescriptionDepthStencilResolve)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSubpassDescriptionDepthStencilResolve
func (x SubpassDescriptionDepthStencilResolve) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new SubpassDescriptionDepthStencilResolve with the value of
// SType to the value provided in the specification.
func (x SubpassDescriptionDepthStencilResolve) WithDefaultSType() SubpassDescriptionDepthStencilResolve {
	return x.WithSType(VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *SubpassDescriptionDepthStencilResolve) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE)
}

// WithSType clones a new SubpassDescriptionDepthStencilResolve with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescriptionDepthStencilResolve) WithSType(y StructureType) SubpassDescriptionDepthStencilResolve {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *SubpassDescriptionDepthStencilResolve) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkSubpassDescriptionDepthStencilResolve
func (x SubpassDescriptionDepthStencilResolve) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new SubpassDescriptionDepthStencilResolve with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescriptionDepthStencilResolve) WithPNext(y unsafe.Pointer) SubpassDescriptionDepthStencilResolve {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *SubpassDescriptionDepthStencilResolve) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// DepthResolveMode returns the value of depthResolveMode from VkSubpassDescriptionDepthStencilResolve
func (x SubpassDescriptionDepthStencilResolve) DepthResolveMode() ResolveModeFlagBits {
	ptr := /* typedef */ (*ResolveModeFlagBits)(&x.depthResolveMode)
	return *ptr
}

// WithDepthResolveMode clones a new SubpassDescriptionDepthStencilResolve with the value of
// DepthResolveMode updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescriptionDepthStencilResolve) WithDepthResolveMode(y ResolveModeFlagBits) SubpassDescriptionDepthStencilResolve {
	x.depthResolveMode = *( /* typedef */ (*C.VkResolveModeFlagBits)(&y))
	return x
}
func (x *SubpassDescriptionDepthStencilResolve) SetDepthResolveMode(y ResolveModeFlagBits) {
	x.depthResolveMode = *( /* typedef */ (*C.VkResolveModeFlagBits)(&y))
}

// StencilResolveMode returns the value of stencilResolveMode from VkSubpassDescriptionDepthStencilResolve
func (x SubpassDescriptionDepthStencilResolve) StencilResolveMode() ResolveModeFlagBits {
	ptr := /* typedef */ (*ResolveModeFlagBits)(&x.stencilResolveMode)
	return *ptr
}

// WithStencilResolveMode clones a new SubpassDescriptionDepthStencilResolve with the value of
// StencilResolveMode updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescriptionDepthStencilResolve) WithStencilResolveMode(y ResolveModeFlagBits) SubpassDescriptionDepthStencilResolve {
	x.stencilResolveMode = *( /* typedef */ (*C.VkResolveModeFlagBits)(&y))
	return x
}
func (x *SubpassDescriptionDepthStencilResolve) SetStencilResolveMode(y ResolveModeFlagBits) {
	x.stencilResolveMode = *( /* typedef */ (*C.VkResolveModeFlagBits)(&y))
}

// PDepthStencilResolveAttachment returns the value of pDepthStencilResolveAttachment from VkSubpassDescriptionDepthStencilResolve
func (x SubpassDescriptionDepthStencilResolve) PDepthStencilResolveAttachment() *AttachmentReference2 {
	ptr := func(x **C.struct_VkAttachmentReference2) **AttachmentReference2 { /* Pointer */
		c2g := (*AttachmentReference2)(*x)
		return &c2g
	}(&x.pDepthStencilResolveAttachment)
	return *ptr
}

// WithPDepthStencilResolveAttachment clones a new SubpassDescriptionDepthStencilResolve with the value of
// PDepthStencilResolveAttachment updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescriptionDepthStencilResolve) WithPDepthStencilResolveAttachment(y *AttachmentReference2) SubpassDescriptionDepthStencilResolve {
	x.pDepthStencilResolveAttachment = *(func(x **AttachmentReference2) **C.struct_VkAttachmentReference2 { /* Pointer */
		g2c := (*C.struct_VkAttachmentReference2)(*x)
		return &g2c
	}(&y))
	return x
}
func (x *SubpassDescriptionDepthStencilResolve) SetPDepthStencilResolveAttachment(y *AttachmentReference2) {
	x.pDepthStencilResolveAttachment = *(func(x **AttachmentReference2) **C.struct_VkAttachmentReference2 { /* Pointer */
		g2c := (*C.struct_VkAttachmentReference2)(*x)
		return &g2c
	}(&y))
}

// PhysicalDeviceShaderSubgroupExtendedTypesFeatures provides a go interface for VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.html
type PhysicalDeviceShaderSubgroupExtendedTypesFeatures C.struct_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures

// SizeofPhysicalDeviceShaderSubgroupExtendedTypesFeatures is the memory size of a PhysicalDeviceShaderSubgroupExtendedTypesFeatures
var SizeofPhysicalDeviceShaderSubgroupExtendedTypesFeatures int = int(unsafe.Sizeof(PhysicalDeviceShaderSubgroupExtendedTypesFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceShaderSubgroupExtendedTypesFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceShaderSubgroupExtendedTypesFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceShaderSubgroupExtendedTypesFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceShaderSubgroupExtendedTypesFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceShaderSubgroupExtendedTypesFeatures) AsCPtr() *PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
	clone := (*PhysicalDeviceShaderSubgroupExtendedTypesFeatures)(newCBlock(cULong(SizeofPhysicalDeviceShaderSubgroupExtendedTypesFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceShaderSubgroupExtendedTypesFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceShaderSubgroupExtendedTypesFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceShaderSubgroupExtendedTypesFeatures) []PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderSubgroupExtendedTypesFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceShaderSubgroupExtendedTypesFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceShaderSubgroupExtendedTypesFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceShaderSubgroupExtendedTypesFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceShaderSubgroupExtendedTypesFeaturesFreeCSlice(x []PhysicalDeviceShaderSubgroupExtendedTypesFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceShaderSubgroupExtendedTypesFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceShaderSubgroupExtendedTypesFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceShaderSubgroupExtendedTypesFeaturesMakeCSlice(x ...PhysicalDeviceShaderSubgroupExtendedTypesFeatures) []PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderSubgroupExtendedTypesFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceShaderSubgroupExtendedTypesFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures
func (x PhysicalDeviceShaderSubgroupExtendedTypesFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceShaderSubgroupExtendedTypesFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceShaderSubgroupExtendedTypesFeatures) WithDefaultSType() PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceShaderSubgroupExtendedTypesFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES)
}

// WithSType clones a new PhysicalDeviceShaderSubgroupExtendedTypesFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderSubgroupExtendedTypesFeatures) WithSType(y StructureType) PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceShaderSubgroupExtendedTypesFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures
func (x PhysicalDeviceShaderSubgroupExtendedTypesFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceShaderSubgroupExtendedTypesFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderSubgroupExtendedTypesFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceShaderSubgroupExtendedTypesFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// ShaderSubgroupExtendedTypes returns the value of shaderSubgroupExtendedTypes from VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures
func (x PhysicalDeviceShaderSubgroupExtendedTypesFeatures) ShaderSubgroupExtendedTypes() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSubgroupExtendedTypes)
	return *ptr
}

// WithShaderSubgroupExtendedTypes clones a new PhysicalDeviceShaderSubgroupExtendedTypesFeatures with the value of
// ShaderSubgroupExtendedTypes updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderSubgroupExtendedTypesFeatures) WithShaderSubgroupExtendedTypes(y Bool32) PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
	x.shaderSubgroupExtendedTypes = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceShaderSubgroupExtendedTypesFeatures) SetShaderSubgroupExtendedTypes(y Bool32) {
	x.shaderSubgroupExtendedTypes = *( /* typedef */ (*C.VkBool32)(&y))
}

// PhysicalDevice8BitStorageFeatures provides a go interface for VkPhysicalDevice8BitStorageFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice8BitStorageFeatures.html
type PhysicalDevice8BitStorageFeatures C.struct_VkPhysicalDevice8BitStorageFeatures

// SizeofPhysicalDevice8BitStorageFeatures is the memory size of a PhysicalDevice8BitStorageFeatures
var SizeofPhysicalDevice8BitStorageFeatures int = int(unsafe.Sizeof(PhysicalDevice8BitStorageFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDevice8BitStorageFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDevice8BitStorageFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDevice8BitStorageFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDevice8BitStorageFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDevice8BitStorageFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDevice8BitStorageFeatures) AsCPtr() *PhysicalDevice8BitStorageFeatures {
	clone := (*PhysicalDevice8BitStorageFeatures)(newCBlock(cULong(SizeofPhysicalDevice8BitStorageFeatures)))
	*clone = x
	return clone
}

// PhysicalDevice8BitStorageFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDevice8BitStorageFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDevice8BitStorageFeatures) []PhysicalDevice8BitStorageFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDevice8BitStorageFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDevice8BitStorageFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDevice8BitStorageFeaturesFreeCSlice releases the memory allocated by PhysicalDevice8BitStorageFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDevice8BitStorageFeaturesFreeCSlice(x []PhysicalDevice8BitStorageFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDevice8BitStorageFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDevice8BitStorageFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDevice8BitStorageFeaturesMakeCSlice(x ...PhysicalDevice8BitStorageFeatures) []PhysicalDevice8BitStorageFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDevice8BitStorageFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDevice8BitStorageFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDevice8BitStorageFeatures
func (x PhysicalDevice8BitStorageFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDevice8BitStorageFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDevice8BitStorageFeatures) WithDefaultSType() PhysicalDevice8BitStorageFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDevice8BitStorageFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES)
}

// WithSType clones a new PhysicalDevice8BitStorageFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice8BitStorageFeatures) WithSType(y StructureType) PhysicalDevice8BitStorageFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDevice8BitStorageFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDevice8BitStorageFeatures
func (x PhysicalDevice8BitStorageFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDevice8BitStorageFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice8BitStorageFeatures) WithPNext(y unsafe.Pointer) PhysicalDevice8BitStorageFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDevice8BitStorageFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// StorageBuffer8BitAccess returns the value of storageBuffer8BitAccess from VkPhysicalDevice8BitStorageFeatures
func (x PhysicalDevice8BitStorageFeatures) StorageBuffer8BitAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storageBuffer8BitAccess)
	return *ptr
}

// WithStorageBuffer8BitAccess clones a new PhysicalDevice8BitStorageFeatures with the value of
// StorageBuffer8BitAccess updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice8BitStorageFeatures) WithStorageBuffer8BitAccess(y Bool32) PhysicalDevice8BitStorageFeatures {
	x.storageBuffer8BitAccess = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDevice8BitStorageFeatures) SetStorageBuffer8BitAccess(y Bool32) {
	x.storageBuffer8BitAccess = *( /* typedef */ (*C.VkBool32)(&y))
}

// UniformAndStorageBuffer8BitAccess returns the value of uniformAndStorageBuffer8BitAccess from VkPhysicalDevice8BitStorageFeatures
func (x PhysicalDevice8BitStorageFeatures) UniformAndStorageBuffer8BitAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.uniformAndStorageBuffer8BitAccess)
	return *ptr
}

// WithUniformAndStorageBuffer8BitAccess clones a new PhysicalDevice8BitStorageFeatures with the value of
// UniformAndStorageBuffer8BitAccess updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice8BitStorageFeatures) WithUniformAndStorageBuffer8BitAccess(y Bool32) PhysicalDevice8BitStorageFeatures {
	x.uniformAndStorageBuffer8BitAccess = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDevice8BitStorageFeatures) SetUniformAndStorageBuffer8BitAccess(y Bool32) {
	x.uniformAndStorageBuffer8BitAccess = *( /* typedef */ (*C.VkBool32)(&y))
}

// StoragePushConstant8 returns the value of storagePushConstant8 from VkPhysicalDevice8BitStorageFeatures
func (x PhysicalDevice8BitStorageFeatures) StoragePushConstant8() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storagePushConstant8)
	return *ptr
}

// WithStoragePushConstant8 clones a new PhysicalDevice8BitStorageFeatures with the value of
// StoragePushConstant8 updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice8BitStorageFeatures) WithStoragePushConstant8(y Bool32) PhysicalDevice8BitStorageFeatures {
	x.storagePushConstant8 = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDevice8BitStorageFeatures) SetStoragePushConstant8(y Bool32) {
	x.storagePushConstant8 = *( /* typedef */ (*C.VkBool32)(&y))
}

// PhysicalDeviceUniformBufferStandardLayoutFeatures provides a go interface for VkPhysicalDeviceUniformBufferStandardLayoutFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceUniformBufferStandardLayoutFeatures.html
type PhysicalDeviceUniformBufferStandardLayoutFeatures C.struct_VkPhysicalDeviceUniformBufferStandardLayoutFeatures

// SizeofPhysicalDeviceUniformBufferStandardLayoutFeatures is the memory size of a PhysicalDeviceUniformBufferStandardLayoutFeatures
var SizeofPhysicalDeviceUniformBufferStandardLayoutFeatures int = int(unsafe.Sizeof(PhysicalDeviceUniformBufferStandardLayoutFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceUniformBufferStandardLayoutFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceUniformBufferStandardLayoutFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceUniformBufferStandardLayoutFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceUniformBufferStandardLayoutFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceUniformBufferStandardLayoutFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceUniformBufferStandardLayoutFeatures) AsCPtr() *PhysicalDeviceUniformBufferStandardLayoutFeatures {
	clone := (*PhysicalDeviceUniformBufferStandardLayoutFeatures)(newCBlock(cULong(SizeofPhysicalDeviceUniformBufferStandardLayoutFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceUniformBufferStandardLayoutFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceUniformBufferStandardLayoutFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceUniformBufferStandardLayoutFeatures) []PhysicalDeviceUniformBufferStandardLayoutFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceUniformBufferStandardLayoutFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceUniformBufferStandardLayoutFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceUniformBufferStandardLayoutFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceUniformBufferStandardLayoutFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceUniformBufferStandardLayoutFeaturesFreeCSlice(x []PhysicalDeviceUniformBufferStandardLayoutFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceUniformBufferStandardLayoutFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceUniformBufferStandardLayoutFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceUniformBufferStandardLayoutFeaturesMakeCSlice(x ...PhysicalDeviceUniformBufferStandardLayoutFeatures) []PhysicalDeviceUniformBufferStandardLayoutFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceUniformBufferStandardLayoutFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceUniformBufferStandardLayoutFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceUniformBufferStandardLayoutFeatures
func (x PhysicalDeviceUniformBufferStandardLayoutFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceUniformBufferStandardLayoutFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceUniformBufferStandardLayoutFeatures) WithDefaultSType() PhysicalDeviceUniformBufferStandardLayoutFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceUniformBufferStandardLayoutFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES)
}

// WithSType clones a new PhysicalDeviceUniformBufferStandardLayoutFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceUniformBufferStandardLayoutFeatures) WithSType(y StructureType) PhysicalDeviceUniformBufferStandardLayoutFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceUniformBufferStandardLayoutFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceUniformBufferStandardLayoutFeatures
func (x PhysicalDeviceUniformBufferStandardLayoutFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceUniformBufferStandardLayoutFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceUniformBufferStandardLayoutFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceUniformBufferStandardLayoutFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceUniformBufferStandardLayoutFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// UniformBufferStandardLayout returns the value of uniformBufferStandardLayout from VkPhysicalDeviceUniformBufferStandardLayoutFeatures
func (x PhysicalDeviceUniformBufferStandardLayoutFeatures) UniformBufferStandardLayout() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.uniformBufferStandardLayout)
	return *ptr
}

// WithUniformBufferStandardLayout clones a new PhysicalDeviceUniformBufferStandardLayoutFeatures with the value of
// UniformBufferStandardLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceUniformBufferStandardLayoutFeatures) WithUniformBufferStandardLayout(y Bool32) PhysicalDeviceUniformBufferStandardLayoutFeatures {
	x.uniformBufferStandardLayout = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceUniformBufferStandardLayoutFeatures) SetUniformBufferStandardLayout(y Bool32) {
	x.uniformBufferStandardLayout = *( /* typedef */ (*C.VkBool32)(&y))
}

// BufferDeviceAddressInfo provides a go interface for VkBufferDeviceAddressInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferDeviceAddressInfo.html
type BufferDeviceAddressInfo C.struct_VkBufferDeviceAddressInfo

// SizeofBufferDeviceAddressInfo is the memory size of a BufferDeviceAddressInfo
var SizeofBufferDeviceAddressInfo int = int(unsafe.Sizeof(BufferDeviceAddressInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x BufferDeviceAddressInfo) ArpPtr(arp *AutoReleasePool) *BufferDeviceAddressInfo {
	ptr := newCBlock(cULong(SizeofBufferDeviceAddressInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*BufferDeviceAddressInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferDeviceAddressInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferDeviceAddressInfo) AsCPtr() *BufferDeviceAddressInfo {
	clone := (*BufferDeviceAddressInfo)(newCBlock(cULong(SizeofBufferDeviceAddressInfo)))
	*clone = x
	return clone
}

// BufferDeviceAddressInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func BufferDeviceAddressInfoCSlice(arp *AutoReleasePool, x ...BufferDeviceAddressInfo) []BufferDeviceAddressInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferDeviceAddressInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*BufferDeviceAddressInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// BufferDeviceAddressInfoFreeCSlice releases the memory allocated by BufferDeviceAddressInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BufferDeviceAddressInfoFreeCSlice(x []BufferDeviceAddressInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferDeviceAddressInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferDeviceAddressInfoFreeCSlice must be called on the returned slice.
func BufferDeviceAddressInfoMakeCSlice(x ...BufferDeviceAddressInfo) []BufferDeviceAddressInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferDeviceAddressInfo * len(x)
	dst := unsafe.Slice((*BufferDeviceAddressInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBufferDeviceAddressInfo
func (x BufferDeviceAddressInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new BufferDeviceAddressInfo with the value of
// SType to the value provided in the specification.
func (x BufferDeviceAddressInfo) WithDefaultSType() BufferDeviceAddressInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *BufferDeviceAddressInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO)
}

// WithSType clones a new BufferDeviceAddressInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferDeviceAddressInfo) WithSType(y StructureType) BufferDeviceAddressInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *BufferDeviceAddressInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkBufferDeviceAddressInfo
func (x BufferDeviceAddressInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new BufferDeviceAddressInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferDeviceAddressInfo) WithPNext(y unsafe.Pointer) BufferDeviceAddressInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *BufferDeviceAddressInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Buffer returns the value of buffer from VkBufferDeviceAddressInfo
func (x BufferDeviceAddressInfo) Buffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.buffer)
	return *ptr
}

// WithBuffer clones a new BufferDeviceAddressInfo with the value of
// Buffer updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferDeviceAddressInfo) WithBuffer(y Buffer) BufferDeviceAddressInfo {
	x.buffer = *( /* handle */ (*C.VkBuffer)(&y))
	return x
}
func (x *BufferDeviceAddressInfo) SetBuffer(y Buffer) {
	x.buffer = *( /* handle */ (*C.VkBuffer)(&y))
}

// SemaphoreWaitInfo provides a go interface for VkSemaphoreWaitInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreWaitInfo.html
type SemaphoreWaitInfo C.struct_VkSemaphoreWaitInfo

// SizeofSemaphoreWaitInfo is the memory size of a SemaphoreWaitInfo
var SizeofSemaphoreWaitInfo int = int(unsafe.Sizeof(SemaphoreWaitInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SemaphoreWaitInfo) ArpPtr(arp *AutoReleasePool) *SemaphoreWaitInfo {
	ptr := newCBlock(cULong(SizeofSemaphoreWaitInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SemaphoreWaitInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SemaphoreWaitInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SemaphoreWaitInfo) AsCPtr() *SemaphoreWaitInfo {
	clone := (*SemaphoreWaitInfo)(newCBlock(cULong(SizeofSemaphoreWaitInfo)))
	*clone = x
	return clone
}

// SemaphoreWaitInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SemaphoreWaitInfoCSlice(arp *AutoReleasePool, x ...SemaphoreWaitInfo) []SemaphoreWaitInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSemaphoreWaitInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SemaphoreWaitInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SemaphoreWaitInfoFreeCSlice releases the memory allocated by SemaphoreWaitInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SemaphoreWaitInfoFreeCSlice(x []SemaphoreWaitInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SemaphoreWaitInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SemaphoreWaitInfoFreeCSlice must be called on the returned slice.
func SemaphoreWaitInfoMakeCSlice(x ...SemaphoreWaitInfo) []SemaphoreWaitInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSemaphoreWaitInfo * len(x)
	dst := unsafe.Slice((*SemaphoreWaitInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSemaphoreWaitInfo
func (x SemaphoreWaitInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new SemaphoreWaitInfo with the value of
// SType to the value provided in the specification.
func (x SemaphoreWaitInfo) WithDefaultSType() SemaphoreWaitInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *SemaphoreWaitInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO)
}

// WithSType clones a new SemaphoreWaitInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreWaitInfo) WithSType(y StructureType) SemaphoreWaitInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *SemaphoreWaitInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkSemaphoreWaitInfo
func (x SemaphoreWaitInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new SemaphoreWaitInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreWaitInfo) WithPNext(y unsafe.Pointer) SemaphoreWaitInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *SemaphoreWaitInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkSemaphoreWaitInfo
func (x SemaphoreWaitInfo) Flags() SemaphoreWaitFlags {
	ptr := /* typedef */ (*SemaphoreWaitFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new SemaphoreWaitInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreWaitInfo) WithFlags(y SemaphoreWaitFlags) SemaphoreWaitInfo {
	x.flags = *( /* typedef */ (*C.VkSemaphoreWaitFlags)(&y))
	return x
}
func (x *SemaphoreWaitInfo) SetFlags(y SemaphoreWaitFlags) {
	x.flags = *( /* typedef */ (*C.VkSemaphoreWaitFlags)(&y))
}

// SemaphoreCount returns the value of semaphoreCount from VkSemaphoreWaitInfo
func (x SemaphoreWaitInfo) SemaphoreCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.semaphoreCount)
	return *ptr
}

// WithSemaphoreCount clones a new SemaphoreWaitInfo with the value of
// SemaphoreCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreWaitInfo) WithSemaphoreCount(y uint32) SemaphoreWaitInfo {
	x.semaphoreCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SemaphoreWaitInfo) SetSemaphoreCount(y uint32) {
	x.semaphoreCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PSemaphores returns the value of pSemaphores from VkSemaphoreWaitInfo
func (x SemaphoreWaitInfo) PSemaphores() []Semaphore {
	ptr := func(x **C.VkSemaphore) *[]Semaphore { /* Slice */
		slc := unsafe.Slice((*Semaphore)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pSemaphores)
	return *ptr
}

// WithPSemaphores clones a new SemaphoreWaitInfo with the value of
// PSemaphores updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SemaphoreCount as the length of this field.
// SemaphoreCount is updated with the length of the new value.
func (x SemaphoreWaitInfo) WithPSemaphores(y []Semaphore) SemaphoreWaitInfo {
	x.pSemaphores = *(func(x *[]Semaphore) **C.VkSemaphore { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSemaphore)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSemaphore)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithSemaphoreCount(uint32(len(y)))
}
func (x *SemaphoreWaitInfo) SetPSemaphores(y []Semaphore) {
	x.pSemaphores = *(func(x *[]Semaphore) **C.VkSemaphore { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSemaphore)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSemaphore)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetSemaphoreCount(uint32(len(y)))
}

// PValues returns the value of pValues from VkSemaphoreWaitInfo
func (x SemaphoreWaitInfo) PValues() []uint64 {
	ptr := func(x **C.uint64_t) *[]uint64 { /* Slice */
		slc := unsafe.Slice((*uint64)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pValues)
	return *ptr
}

// WithPValues clones a new SemaphoreWaitInfo with the value of
// PValues updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SemaphoreCount as the length of this field.
// SemaphoreCount is updated with the length of the new value.
func (x SemaphoreWaitInfo) WithPValues(y []uint64) SemaphoreWaitInfo {
	x.pValues = *(func(x *[]uint64) **C.uint64_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint64_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint64_t)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithSemaphoreCount(uint32(len(y)))
}
func (x *SemaphoreWaitInfo) SetPValues(y []uint64) {
	x.pValues = *(func(x *[]uint64) **C.uint64_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint64_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint64_t)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetSemaphoreCount(uint32(len(y)))
}

// RenderPassAttachmentBeginInfo provides a go interface for VkRenderPassAttachmentBeginInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassAttachmentBeginInfo.html
type RenderPassAttachmentBeginInfo C.struct_VkRenderPassAttachmentBeginInfo

// SizeofRenderPassAttachmentBeginInfo is the memory size of a RenderPassAttachmentBeginInfo
var SizeofRenderPassAttachmentBeginInfo int = int(unsafe.Sizeof(RenderPassAttachmentBeginInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x RenderPassAttachmentBeginInfo) ArpPtr(arp *AutoReleasePool) *RenderPassAttachmentBeginInfo {
	ptr := newCBlock(cULong(SizeofRenderPassAttachmentBeginInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*RenderPassAttachmentBeginInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *RenderPassAttachmentBeginInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x RenderPassAttachmentBeginInfo) AsCPtr() *RenderPassAttachmentBeginInfo {
	clone := (*RenderPassAttachmentBeginInfo)(newCBlock(cULong(SizeofRenderPassAttachmentBeginInfo)))
	*clone = x
	return clone
}

// RenderPassAttachmentBeginInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func RenderPassAttachmentBeginInfoCSlice(arp *AutoReleasePool, x ...RenderPassAttachmentBeginInfo) []RenderPassAttachmentBeginInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderPassAttachmentBeginInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*RenderPassAttachmentBeginInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// RenderPassAttachmentBeginInfoFreeCSlice releases the memory allocated by RenderPassAttachmentBeginInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func RenderPassAttachmentBeginInfoFreeCSlice(x []RenderPassAttachmentBeginInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// RenderPassAttachmentBeginInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. RenderPassAttachmentBeginInfoFreeCSlice must be called on the returned slice.
func RenderPassAttachmentBeginInfoMakeCSlice(x ...RenderPassAttachmentBeginInfo) []RenderPassAttachmentBeginInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderPassAttachmentBeginInfo * len(x)
	dst := unsafe.Slice((*RenderPassAttachmentBeginInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkRenderPassAttachmentBeginInfo
func (x RenderPassAttachmentBeginInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new RenderPassAttachmentBeginInfo with the value of
// SType to the value provided in the specification.
func (x RenderPassAttachmentBeginInfo) WithDefaultSType() RenderPassAttachmentBeginInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *RenderPassAttachmentBeginInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO)
}

// WithSType clones a new RenderPassAttachmentBeginInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassAttachmentBeginInfo) WithSType(y StructureType) RenderPassAttachmentBeginInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *RenderPassAttachmentBeginInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkRenderPassAttachmentBeginInfo
func (x RenderPassAttachmentBeginInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new RenderPassAttachmentBeginInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassAttachmentBeginInfo) WithPNext(y unsafe.Pointer) RenderPassAttachmentBeginInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *RenderPassAttachmentBeginInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// AttachmentCount returns the value of attachmentCount from VkRenderPassAttachmentBeginInfo
func (x RenderPassAttachmentBeginInfo) AttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.attachmentCount)
	return *ptr
}

// WithAttachmentCount clones a new RenderPassAttachmentBeginInfo with the value of
// AttachmentCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassAttachmentBeginInfo) WithAttachmentCount(y uint32) RenderPassAttachmentBeginInfo {
	x.attachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *RenderPassAttachmentBeginInfo) SetAttachmentCount(y uint32) {
	x.attachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PAttachments returns the value of pAttachments from VkRenderPassAttachmentBeginInfo
func (x RenderPassAttachmentBeginInfo) PAttachments() []ImageView {
	ptr := func(x **C.VkImageView) *[]ImageView { /* Slice */
		slc := unsafe.Slice((*ImageView)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pAttachments)
	return *ptr
}

// WithPAttachments clones a new RenderPassAttachmentBeginInfo with the value of
// PAttachments updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines AttachmentCount as the length of this field.
// AttachmentCount is updated with the length of the new value.
func (x RenderPassAttachmentBeginInfo) WithPAttachments(y []ImageView) RenderPassAttachmentBeginInfo {
	x.pAttachments = *(func(x *[]ImageView) **C.VkImageView { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkImageView)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkImageView)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithAttachmentCount(uint32(len(y)))
}
func (x *RenderPassAttachmentBeginInfo) SetPAttachments(y []ImageView) {
	x.pAttachments = *(func(x *[]ImageView) **C.VkImageView { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkImageView)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkImageView)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetAttachmentCount(uint32(len(y)))
}

// FramebufferAttachmentImageInfo provides a go interface for VkFramebufferAttachmentImageInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebufferAttachmentImageInfo.html
type FramebufferAttachmentImageInfo C.struct_VkFramebufferAttachmentImageInfo

// SizeofFramebufferAttachmentImageInfo is the memory size of a FramebufferAttachmentImageInfo
var SizeofFramebufferAttachmentImageInfo int = int(unsafe.Sizeof(FramebufferAttachmentImageInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x FramebufferAttachmentImageInfo) ArpPtr(arp *AutoReleasePool) *FramebufferAttachmentImageInfo {
	ptr := newCBlock(cULong(SizeofFramebufferAttachmentImageInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*FramebufferAttachmentImageInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *FramebufferAttachmentImageInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x FramebufferAttachmentImageInfo) AsCPtr() *FramebufferAttachmentImageInfo {
	clone := (*FramebufferAttachmentImageInfo)(newCBlock(cULong(SizeofFramebufferAttachmentImageInfo)))
	*clone = x
	return clone
}

// FramebufferAttachmentImageInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func FramebufferAttachmentImageInfoCSlice(arp *AutoReleasePool, x ...FramebufferAttachmentImageInfo) []FramebufferAttachmentImageInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFramebufferAttachmentImageInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*FramebufferAttachmentImageInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// FramebufferAttachmentImageInfoFreeCSlice releases the memory allocated by FramebufferAttachmentImageInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func FramebufferAttachmentImageInfoFreeCSlice(x []FramebufferAttachmentImageInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// FramebufferAttachmentImageInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. FramebufferAttachmentImageInfoFreeCSlice must be called on the returned slice.
func FramebufferAttachmentImageInfoMakeCSlice(x ...FramebufferAttachmentImageInfo) []FramebufferAttachmentImageInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFramebufferAttachmentImageInfo * len(x)
	dst := unsafe.Slice((*FramebufferAttachmentImageInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkFramebufferAttachmentImageInfo
func (x FramebufferAttachmentImageInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new FramebufferAttachmentImageInfo with the value of
// SType to the value provided in the specification.
func (x FramebufferAttachmentImageInfo) WithDefaultSType() FramebufferAttachmentImageInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *FramebufferAttachmentImageInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO)
}

// WithSType clones a new FramebufferAttachmentImageInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentImageInfo) WithSType(y StructureType) FramebufferAttachmentImageInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *FramebufferAttachmentImageInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkFramebufferAttachmentImageInfo
func (x FramebufferAttachmentImageInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new FramebufferAttachmentImageInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentImageInfo) WithPNext(y unsafe.Pointer) FramebufferAttachmentImageInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *FramebufferAttachmentImageInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkFramebufferAttachmentImageInfo
func (x FramebufferAttachmentImageInfo) Flags() ImageCreateFlags {
	ptr := /* typedef */ (*ImageCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new FramebufferAttachmentImageInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentImageInfo) WithFlags(y ImageCreateFlags) FramebufferAttachmentImageInfo {
	x.flags = *( /* typedef */ (*C.VkImageCreateFlags)(&y))
	return x
}
func (x *FramebufferAttachmentImageInfo) SetFlags(y ImageCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkImageCreateFlags)(&y))
}

// Usage returns the value of usage from VkFramebufferAttachmentImageInfo
func (x FramebufferAttachmentImageInfo) Usage() ImageUsageFlags {
	ptr := /* typedef */ (*ImageUsageFlags)(&x.usage)
	return *ptr
}

// WithUsage clones a new FramebufferAttachmentImageInfo with the value of
// Usage updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentImageInfo) WithUsage(y ImageUsageFlags) FramebufferAttachmentImageInfo {
	x.usage = *( /* typedef */ (*C.VkImageUsageFlags)(&y))
	return x
}
func (x *FramebufferAttachmentImageInfo) SetUsage(y ImageUsageFlags) {
	x.usage = *( /* typedef */ (*C.VkImageUsageFlags)(&y))
}

// Width returns the value of width from VkFramebufferAttachmentImageInfo
func (x FramebufferAttachmentImageInfo) Width() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.width)
	return *ptr
}

// WithWidth clones a new FramebufferAttachmentImageInfo with the value of
// Width updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentImageInfo) WithWidth(y uint32) FramebufferAttachmentImageInfo {
	x.width = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *FramebufferAttachmentImageInfo) SetWidth(y uint32) {
	x.width = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// Height returns the value of height from VkFramebufferAttachmentImageInfo
func (x FramebufferAttachmentImageInfo) Height() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.height)
	return *ptr
}

// WithHeight clones a new FramebufferAttachmentImageInfo with the value of
// Height updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentImageInfo) WithHeight(y uint32) FramebufferAttachmentImageInfo {
	x.height = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *FramebufferAttachmentImageInfo) SetHeight(y uint32) {
	x.height = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// LayerCount returns the value of layerCount from VkFramebufferAttachmentImageInfo
func (x FramebufferAttachmentImageInfo) LayerCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.layerCount)
	return *ptr
}

// WithLayerCount clones a new FramebufferAttachmentImageInfo with the value of
// LayerCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentImageInfo) WithLayerCount(y uint32) FramebufferAttachmentImageInfo {
	x.layerCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *FramebufferAttachmentImageInfo) SetLayerCount(y uint32) {
	x.layerCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// ViewFormatCount returns the value of viewFormatCount from VkFramebufferAttachmentImageInfo
func (x FramebufferAttachmentImageInfo) ViewFormatCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.viewFormatCount)
	return *ptr
}

// WithViewFormatCount clones a new FramebufferAttachmentImageInfo with the value of
// ViewFormatCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentImageInfo) WithViewFormatCount(y uint32) FramebufferAttachmentImageInfo {
	x.viewFormatCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *FramebufferAttachmentImageInfo) SetViewFormatCount(y uint32) {
	x.viewFormatCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PViewFormats returns the value of pViewFormats from VkFramebufferAttachmentImageInfo
func (x FramebufferAttachmentImageInfo) PViewFormats() []Format {
	ptr := func(x **C.VkFormat) *[]Format { /* Slice */
		slc := unsafe.Slice((*Format)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pViewFormats)
	return *ptr
}

// WithPViewFormats clones a new FramebufferAttachmentImageInfo with the value of
// PViewFormats updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines ViewFormatCount as the length of this field.
// ViewFormatCount is updated with the length of the new value.
func (x FramebufferAttachmentImageInfo) WithPViewFormats(y []Format) FramebufferAttachmentImageInfo {
	x.pViewFormats = *(func(x *[]Format) **C.VkFormat { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkFormat)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkFormat)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithViewFormatCount(uint32(len(y)))
}
func (x *FramebufferAttachmentImageInfo) SetPViewFormats(y []Format) {
	x.pViewFormats = *(func(x *[]Format) **C.VkFormat { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkFormat)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkFormat)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetViewFormatCount(uint32(len(y)))
}

// FramebufferAttachmentsCreateInfo provides a go interface for VkFramebufferAttachmentsCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebufferAttachmentsCreateInfo.html
type FramebufferAttachmentsCreateInfo C.struct_VkFramebufferAttachmentsCreateInfo

// SizeofFramebufferAttachmentsCreateInfo is the memory size of a FramebufferAttachmentsCreateInfo
var SizeofFramebufferAttachmentsCreateInfo int = int(unsafe.Sizeof(FramebufferAttachmentsCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x FramebufferAttachmentsCreateInfo) ArpPtr(arp *AutoReleasePool) *FramebufferAttachmentsCreateInfo {
	ptr := newCBlock(cULong(SizeofFramebufferAttachmentsCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*FramebufferAttachmentsCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *FramebufferAttachmentsCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x FramebufferAttachmentsCreateInfo) AsCPtr() *FramebufferAttachmentsCreateInfo {
	clone := (*FramebufferAttachmentsCreateInfo)(newCBlock(cULong(SizeofFramebufferAttachmentsCreateInfo)))
	*clone = x
	return clone
}

// FramebufferAttachmentsCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func FramebufferAttachmentsCreateInfoCSlice(arp *AutoReleasePool, x ...FramebufferAttachmentsCreateInfo) []FramebufferAttachmentsCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFramebufferAttachmentsCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*FramebufferAttachmentsCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// FramebufferAttachmentsCreateInfoFreeCSlice releases the memory allocated by FramebufferAttachmentsCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func FramebufferAttachmentsCreateInfoFreeCSlice(x []FramebufferAttachmentsCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// FramebufferAttachmentsCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. FramebufferAttachmentsCreateInfoFreeCSlice must be called on the returned slice.
func FramebufferAttachmentsCreateInfoMakeCSlice(x ...FramebufferAttachmentsCreateInfo) []FramebufferAttachmentsCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFramebufferAttachmentsCreateInfo * len(x)
	dst := unsafe.Slice((*FramebufferAttachmentsCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkFramebufferAttachmentsCreateInfo
func (x FramebufferAttachmentsCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new FramebufferAttachmentsCreateInfo with the value of
// SType to the value provided in the specification.
func (x FramebufferAttachmentsCreateInfo) WithDefaultSType() FramebufferAttachmentsCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *FramebufferAttachmentsCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO)
}

// WithSType clones a new FramebufferAttachmentsCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentsCreateInfo) WithSType(y StructureType) FramebufferAttachmentsCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *FramebufferAttachmentsCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkFramebufferAttachmentsCreateInfo
func (x FramebufferAttachmentsCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new FramebufferAttachmentsCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentsCreateInfo) WithPNext(y unsafe.Pointer) FramebufferAttachmentsCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *FramebufferAttachmentsCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// AttachmentImageInfoCount returns the value of attachmentImageInfoCount from VkFramebufferAttachmentsCreateInfo
func (x FramebufferAttachmentsCreateInfo) AttachmentImageInfoCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.attachmentImageInfoCount)
	return *ptr
}

// WithAttachmentImageInfoCount clones a new FramebufferAttachmentsCreateInfo with the value of
// AttachmentImageInfoCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentsCreateInfo) WithAttachmentImageInfoCount(y uint32) FramebufferAttachmentsCreateInfo {
	x.attachmentImageInfoCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *FramebufferAttachmentsCreateInfo) SetAttachmentImageInfoCount(y uint32) {
	x.attachmentImageInfoCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PAttachmentImageInfos returns the value of pAttachmentImageInfos from VkFramebufferAttachmentsCreateInfo
func (x FramebufferAttachmentsCreateInfo) PAttachmentImageInfos() []FramebufferAttachmentImageInfo {
	ptr := func(x **C.struct_VkFramebufferAttachmentImageInfo) *[]FramebufferAttachmentImageInfo { /* Slice */
		slc := unsafe.Slice((*FramebufferAttachmentImageInfo)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pAttachmentImageInfos)
	return *ptr
}

// WithPAttachmentImageInfos clones a new FramebufferAttachmentsCreateInfo with the value of
// PAttachmentImageInfos updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines AttachmentImageInfoCount as the length of this field.
// AttachmentImageInfoCount is updated with the length of the new value.
func (x FramebufferAttachmentsCreateInfo) WithPAttachmentImageInfos(y []FramebufferAttachmentImageInfo) FramebufferAttachmentsCreateInfo {
	x.pAttachmentImageInfos = *(func(x *[]FramebufferAttachmentImageInfo) **C.struct_VkFramebufferAttachmentImageInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkFramebufferAttachmentImageInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkFramebufferAttachmentImageInfo)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithAttachmentImageInfoCount(uint32(len(y)))
}
func (x *FramebufferAttachmentsCreateInfo) SetPAttachmentImageInfos(y []FramebufferAttachmentImageInfo) {
	x.pAttachmentImageInfos = *(func(x *[]FramebufferAttachmentImageInfo) **C.struct_VkFramebufferAttachmentImageInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkFramebufferAttachmentImageInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkFramebufferAttachmentImageInfo)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetAttachmentImageInfoCount(uint32(len(y)))
}

// PhysicalDeviceShaderAtomicInt64Features provides a go interface for VkPhysicalDeviceShaderAtomicInt64Features.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicInt64Features.html
type PhysicalDeviceShaderAtomicInt64Features C.struct_VkPhysicalDeviceShaderAtomicInt64Features

// SizeofPhysicalDeviceShaderAtomicInt64Features is the memory size of a PhysicalDeviceShaderAtomicInt64Features
var SizeofPhysicalDeviceShaderAtomicInt64Features int = int(unsafe.Sizeof(PhysicalDeviceShaderAtomicInt64Features{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceShaderAtomicInt64Features) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceShaderAtomicInt64Features {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceShaderAtomicInt64Features))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceShaderAtomicInt64Features)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceShaderAtomicInt64Features) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceShaderAtomicInt64Features) AsCPtr() *PhysicalDeviceShaderAtomicInt64Features {
	clone := (*PhysicalDeviceShaderAtomicInt64Features)(newCBlock(cULong(SizeofPhysicalDeviceShaderAtomicInt64Features)))
	*clone = x
	return clone
}

// PhysicalDeviceShaderAtomicInt64FeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceShaderAtomicInt64FeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceShaderAtomicInt64Features) []PhysicalDeviceShaderAtomicInt64Features {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderAtomicInt64Features * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceShaderAtomicInt64Features)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceShaderAtomicInt64FeaturesFreeCSlice releases the memory allocated by PhysicalDeviceShaderAtomicInt64FeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceShaderAtomicInt64FeaturesFreeCSlice(x []PhysicalDeviceShaderAtomicInt64Features) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceShaderAtomicInt64FeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceShaderAtomicInt64FeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceShaderAtomicInt64FeaturesMakeCSlice(x ...PhysicalDeviceShaderAtomicInt64Features) []PhysicalDeviceShaderAtomicInt64Features {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderAtomicInt64Features * len(x)
	dst := unsafe.Slice((*PhysicalDeviceShaderAtomicInt64Features)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceShaderAtomicInt64Features
func (x PhysicalDeviceShaderAtomicInt64Features) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceShaderAtomicInt64Features with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceShaderAtomicInt64Features) WithDefaultSType() PhysicalDeviceShaderAtomicInt64Features {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceShaderAtomicInt64Features) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES)
}

// WithSType clones a new PhysicalDeviceShaderAtomicInt64Features with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderAtomicInt64Features) WithSType(y StructureType) PhysicalDeviceShaderAtomicInt64Features {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceShaderAtomicInt64Features) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceShaderAtomicInt64Features
func (x PhysicalDeviceShaderAtomicInt64Features) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceShaderAtomicInt64Features with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderAtomicInt64Features) WithPNext(y unsafe.Pointer) PhysicalDeviceShaderAtomicInt64Features {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceShaderAtomicInt64Features) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// ShaderBufferInt64Atomics returns the value of shaderBufferInt64Atomics from VkPhysicalDeviceShaderAtomicInt64Features
func (x PhysicalDeviceShaderAtomicInt64Features) ShaderBufferInt64Atomics() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderBufferInt64Atomics)
	return *ptr
}

// WithShaderBufferInt64Atomics clones a new PhysicalDeviceShaderAtomicInt64Features with the value of
// ShaderBufferInt64Atomics updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderAtomicInt64Features) WithShaderBufferInt64Atomics(y Bool32) PhysicalDeviceShaderAtomicInt64Features {
	x.shaderBufferInt64Atomics = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceShaderAtomicInt64Features) SetShaderBufferInt64Atomics(y Bool32) {
	x.shaderBufferInt64Atomics = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderSharedInt64Atomics returns the value of shaderSharedInt64Atomics from VkPhysicalDeviceShaderAtomicInt64Features
func (x PhysicalDeviceShaderAtomicInt64Features) ShaderSharedInt64Atomics() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSharedInt64Atomics)
	return *ptr
}

// WithShaderSharedInt64Atomics clones a new PhysicalDeviceShaderAtomicInt64Features with the value of
// ShaderSharedInt64Atomics updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderAtomicInt64Features) WithShaderSharedInt64Atomics(y Bool32) PhysicalDeviceShaderAtomicInt64Features {
	x.shaderSharedInt64Atomics = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceShaderAtomicInt64Features) SetShaderSharedInt64Atomics(y Bool32) {
	x.shaderSharedInt64Atomics = *( /* typedef */ (*C.VkBool32)(&y))
}

// PhysicalDeviceImagelessFramebufferFeatures provides a go interface for VkPhysicalDeviceImagelessFramebufferFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImagelessFramebufferFeatures.html
type PhysicalDeviceImagelessFramebufferFeatures C.struct_VkPhysicalDeviceImagelessFramebufferFeatures

// SizeofPhysicalDeviceImagelessFramebufferFeatures is the memory size of a PhysicalDeviceImagelessFramebufferFeatures
var SizeofPhysicalDeviceImagelessFramebufferFeatures int = int(unsafe.Sizeof(PhysicalDeviceImagelessFramebufferFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceImagelessFramebufferFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceImagelessFramebufferFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceImagelessFramebufferFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceImagelessFramebufferFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceImagelessFramebufferFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceImagelessFramebufferFeatures) AsCPtr() *PhysicalDeviceImagelessFramebufferFeatures {
	clone := (*PhysicalDeviceImagelessFramebufferFeatures)(newCBlock(cULong(SizeofPhysicalDeviceImagelessFramebufferFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceImagelessFramebufferFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceImagelessFramebufferFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceImagelessFramebufferFeatures) []PhysicalDeviceImagelessFramebufferFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceImagelessFramebufferFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceImagelessFramebufferFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceImagelessFramebufferFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceImagelessFramebufferFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceImagelessFramebufferFeaturesFreeCSlice(x []PhysicalDeviceImagelessFramebufferFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceImagelessFramebufferFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceImagelessFramebufferFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceImagelessFramebufferFeaturesMakeCSlice(x ...PhysicalDeviceImagelessFramebufferFeatures) []PhysicalDeviceImagelessFramebufferFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceImagelessFramebufferFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceImagelessFramebufferFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceImagelessFramebufferFeatures
func (x PhysicalDeviceImagelessFramebufferFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceImagelessFramebufferFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceImagelessFramebufferFeatures) WithDefaultSType() PhysicalDeviceImagelessFramebufferFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceImagelessFramebufferFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES)
}

// WithSType clones a new PhysicalDeviceImagelessFramebufferFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImagelessFramebufferFeatures) WithSType(y StructureType) PhysicalDeviceImagelessFramebufferFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceImagelessFramebufferFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceImagelessFramebufferFeatures
func (x PhysicalDeviceImagelessFramebufferFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceImagelessFramebufferFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImagelessFramebufferFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceImagelessFramebufferFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceImagelessFramebufferFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// ImagelessFramebuffer returns the value of imagelessFramebuffer from VkPhysicalDeviceImagelessFramebufferFeatures
func (x PhysicalDeviceImagelessFramebufferFeatures) ImagelessFramebuffer() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.imagelessFramebuffer)
	return *ptr
}

// WithImagelessFramebuffer clones a new PhysicalDeviceImagelessFramebufferFeatures with the value of
// ImagelessFramebuffer updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImagelessFramebufferFeatures) WithImagelessFramebuffer(y Bool32) PhysicalDeviceImagelessFramebufferFeatures {
	x.imagelessFramebuffer = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceImagelessFramebufferFeatures) SetImagelessFramebuffer(y Bool32) {
	x.imagelessFramebuffer = *( /* typedef */ (*C.VkBool32)(&y))
}

// PhysicalDeviceShaderFloat16Int8Features provides a go interface for VkPhysicalDeviceShaderFloat16Int8Features.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderFloat16Int8Features.html
type PhysicalDeviceShaderFloat16Int8Features C.struct_VkPhysicalDeviceShaderFloat16Int8Features

// SizeofPhysicalDeviceShaderFloat16Int8Features is the memory size of a PhysicalDeviceShaderFloat16Int8Features
var SizeofPhysicalDeviceShaderFloat16Int8Features int = int(unsafe.Sizeof(PhysicalDeviceShaderFloat16Int8Features{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceShaderFloat16Int8Features) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceShaderFloat16Int8Features {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceShaderFloat16Int8Features))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceShaderFloat16Int8Features)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceShaderFloat16Int8Features) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceShaderFloat16Int8Features) AsCPtr() *PhysicalDeviceShaderFloat16Int8Features {
	clone := (*PhysicalDeviceShaderFloat16Int8Features)(newCBlock(cULong(SizeofPhysicalDeviceShaderFloat16Int8Features)))
	*clone = x
	return clone
}

// PhysicalDeviceShaderFloat16Int8FeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceShaderFloat16Int8FeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceShaderFloat16Int8Features) []PhysicalDeviceShaderFloat16Int8Features {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderFloat16Int8Features * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceShaderFloat16Int8Features)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceShaderFloat16Int8FeaturesFreeCSlice releases the memory allocated by PhysicalDeviceShaderFloat16Int8FeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceShaderFloat16Int8FeaturesFreeCSlice(x []PhysicalDeviceShaderFloat16Int8Features) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceShaderFloat16Int8FeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceShaderFloat16Int8FeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceShaderFloat16Int8FeaturesMakeCSlice(x ...PhysicalDeviceShaderFloat16Int8Features) []PhysicalDeviceShaderFloat16Int8Features {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderFloat16Int8Features * len(x)
	dst := unsafe.Slice((*PhysicalDeviceShaderFloat16Int8Features)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceShaderFloat16Int8Features
func (x PhysicalDeviceShaderFloat16Int8Features) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceShaderFloat16Int8Features with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceShaderFloat16Int8Features) WithDefaultSType() PhysicalDeviceShaderFloat16Int8Features {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceShaderFloat16Int8Features) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES)
}

// WithSType clones a new PhysicalDeviceShaderFloat16Int8Features with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderFloat16Int8Features) WithSType(y StructureType) PhysicalDeviceShaderFloat16Int8Features {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceShaderFloat16Int8Features) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceShaderFloat16Int8Features
func (x PhysicalDeviceShaderFloat16Int8Features) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceShaderFloat16Int8Features with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderFloat16Int8Features) WithPNext(y unsafe.Pointer) PhysicalDeviceShaderFloat16Int8Features {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceShaderFloat16Int8Features) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// ShaderFloat16 returns the value of shaderFloat16 from VkPhysicalDeviceShaderFloat16Int8Features
func (x PhysicalDeviceShaderFloat16Int8Features) ShaderFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderFloat16)
	return *ptr
}

// WithShaderFloat16 clones a new PhysicalDeviceShaderFloat16Int8Features with the value of
// ShaderFloat16 updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderFloat16Int8Features) WithShaderFloat16(y Bool32) PhysicalDeviceShaderFloat16Int8Features {
	x.shaderFloat16 = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceShaderFloat16Int8Features) SetShaderFloat16(y Bool32) {
	x.shaderFloat16 = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderInt8 returns the value of shaderInt8 from VkPhysicalDeviceShaderFloat16Int8Features
func (x PhysicalDeviceShaderFloat16Int8Features) ShaderInt8() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInt8)
	return *ptr
}

// WithShaderInt8 clones a new PhysicalDeviceShaderFloat16Int8Features with the value of
// ShaderInt8 updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderFloat16Int8Features) WithShaderInt8(y Bool32) PhysicalDeviceShaderFloat16Int8Features {
	x.shaderInt8 = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceShaderFloat16Int8Features) SetShaderInt8(y Bool32) {
	x.shaderInt8 = *( /* typedef */ (*C.VkBool32)(&y))
}

// PhysicalDeviceVulkanMemoryModelFeatures provides a go interface for VkPhysicalDeviceVulkanMemoryModelFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkanMemoryModelFeatures.html
type PhysicalDeviceVulkanMemoryModelFeatures C.struct_VkPhysicalDeviceVulkanMemoryModelFeatures

// SizeofPhysicalDeviceVulkanMemoryModelFeatures is the memory size of a PhysicalDeviceVulkanMemoryModelFeatures
var SizeofPhysicalDeviceVulkanMemoryModelFeatures int = int(unsafe.Sizeof(PhysicalDeviceVulkanMemoryModelFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceVulkanMemoryModelFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceVulkanMemoryModelFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceVulkanMemoryModelFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceVulkanMemoryModelFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceVulkanMemoryModelFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceVulkanMemoryModelFeatures) AsCPtr() *PhysicalDeviceVulkanMemoryModelFeatures {
	clone := (*PhysicalDeviceVulkanMemoryModelFeatures)(newCBlock(cULong(SizeofPhysicalDeviceVulkanMemoryModelFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceVulkanMemoryModelFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceVulkanMemoryModelFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceVulkanMemoryModelFeatures) []PhysicalDeviceVulkanMemoryModelFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVulkanMemoryModelFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceVulkanMemoryModelFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceVulkanMemoryModelFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceVulkanMemoryModelFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceVulkanMemoryModelFeaturesFreeCSlice(x []PhysicalDeviceVulkanMemoryModelFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceVulkanMemoryModelFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceVulkanMemoryModelFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceVulkanMemoryModelFeaturesMakeCSlice(x ...PhysicalDeviceVulkanMemoryModelFeatures) []PhysicalDeviceVulkanMemoryModelFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVulkanMemoryModelFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceVulkanMemoryModelFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceVulkanMemoryModelFeatures
func (x PhysicalDeviceVulkanMemoryModelFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceVulkanMemoryModelFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceVulkanMemoryModelFeatures) WithDefaultSType() PhysicalDeviceVulkanMemoryModelFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceVulkanMemoryModelFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES)
}

// WithSType clones a new PhysicalDeviceVulkanMemoryModelFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkanMemoryModelFeatures) WithSType(y StructureType) PhysicalDeviceVulkanMemoryModelFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceVulkanMemoryModelFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceVulkanMemoryModelFeatures
func (x PhysicalDeviceVulkanMemoryModelFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceVulkanMemoryModelFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkanMemoryModelFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceVulkanMemoryModelFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceVulkanMemoryModelFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// VulkanMemoryModel returns the value of vulkanMemoryModel from VkPhysicalDeviceVulkanMemoryModelFeatures
func (x PhysicalDeviceVulkanMemoryModelFeatures) VulkanMemoryModel() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.vulkanMemoryModel)
	return *ptr
}

// WithVulkanMemoryModel clones a new PhysicalDeviceVulkanMemoryModelFeatures with the value of
// VulkanMemoryModel updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkanMemoryModelFeatures) WithVulkanMemoryModel(y Bool32) PhysicalDeviceVulkanMemoryModelFeatures {
	x.vulkanMemoryModel = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkanMemoryModelFeatures) SetVulkanMemoryModel(y Bool32) {
	x.vulkanMemoryModel = *( /* typedef */ (*C.VkBool32)(&y))
}

// VulkanMemoryModelDeviceScope returns the value of vulkanMemoryModelDeviceScope from VkPhysicalDeviceVulkanMemoryModelFeatures
func (x PhysicalDeviceVulkanMemoryModelFeatures) VulkanMemoryModelDeviceScope() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.vulkanMemoryModelDeviceScope)
	return *ptr
}

// WithVulkanMemoryModelDeviceScope clones a new PhysicalDeviceVulkanMemoryModelFeatures with the value of
// VulkanMemoryModelDeviceScope updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkanMemoryModelFeatures) WithVulkanMemoryModelDeviceScope(y Bool32) PhysicalDeviceVulkanMemoryModelFeatures {
	x.vulkanMemoryModelDeviceScope = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkanMemoryModelFeatures) SetVulkanMemoryModelDeviceScope(y Bool32) {
	x.vulkanMemoryModelDeviceScope = *( /* typedef */ (*C.VkBool32)(&y))
}

// VulkanMemoryModelAvailabilityVisibilityChains returns the value of vulkanMemoryModelAvailabilityVisibilityChains from VkPhysicalDeviceVulkanMemoryModelFeatures
func (x PhysicalDeviceVulkanMemoryModelFeatures) VulkanMemoryModelAvailabilityVisibilityChains() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.vulkanMemoryModelAvailabilityVisibilityChains)
	return *ptr
}

// WithVulkanMemoryModelAvailabilityVisibilityChains clones a new PhysicalDeviceVulkanMemoryModelFeatures with the value of
// VulkanMemoryModelAvailabilityVisibilityChains updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkanMemoryModelFeatures) WithVulkanMemoryModelAvailabilityVisibilityChains(y Bool32) PhysicalDeviceVulkanMemoryModelFeatures {
	x.vulkanMemoryModelAvailabilityVisibilityChains = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkanMemoryModelFeatures) SetVulkanMemoryModelAvailabilityVisibilityChains(y Bool32) {
	x.vulkanMemoryModelAvailabilityVisibilityChains = *( /* typedef */ (*C.VkBool32)(&y))
}

// PhysicalDeviceFloatControlsProperties provides a go interface for VkPhysicalDeviceFloatControlsProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFloatControlsProperties.html
type PhysicalDeviceFloatControlsProperties C.struct_VkPhysicalDeviceFloatControlsProperties

// SizeofPhysicalDeviceFloatControlsProperties is the memory size of a PhysicalDeviceFloatControlsProperties
var SizeofPhysicalDeviceFloatControlsProperties int = int(unsafe.Sizeof(PhysicalDeviceFloatControlsProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceFloatControlsProperties) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceFloatControlsProperties {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceFloatControlsProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceFloatControlsProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceFloatControlsProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceFloatControlsProperties) AsCPtr() *PhysicalDeviceFloatControlsProperties {
	clone := (*PhysicalDeviceFloatControlsProperties)(newCBlock(cULong(SizeofPhysicalDeviceFloatControlsProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceFloatControlsPropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceFloatControlsPropertiesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceFloatControlsProperties) []PhysicalDeviceFloatControlsProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceFloatControlsProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceFloatControlsProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceFloatControlsPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceFloatControlsPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceFloatControlsPropertiesFreeCSlice(x []PhysicalDeviceFloatControlsProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceFloatControlsPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceFloatControlsPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceFloatControlsPropertiesMakeCSlice(x ...PhysicalDeviceFloatControlsProperties) []PhysicalDeviceFloatControlsProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceFloatControlsProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceFloatControlsProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceFloatControlsProperties with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceFloatControlsProperties) WithDefaultSType() PhysicalDeviceFloatControlsProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceFloatControlsProperties) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES)
}

// WithSType clones a new PhysicalDeviceFloatControlsProperties with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFloatControlsProperties) WithSType(y StructureType) PhysicalDeviceFloatControlsProperties {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceFloatControlsProperties) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceFloatControlsProperties with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFloatControlsProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceFloatControlsProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceFloatControlsProperties) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// DenormBehaviorIndependence returns the value of denormBehaviorIndependence from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) DenormBehaviorIndependence() ShaderFloatControlsIndependence {
	ptr := /* typedef */ (*ShaderFloatControlsIndependence)(&x.denormBehaviorIndependence)
	return *ptr
}

// RoundingModeIndependence returns the value of roundingModeIndependence from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) RoundingModeIndependence() ShaderFloatControlsIndependence {
	ptr := /* typedef */ (*ShaderFloatControlsIndependence)(&x.roundingModeIndependence)
	return *ptr
}

// ShaderSignedZeroInfNanPreserveFloat16 returns the value of shaderSignedZeroInfNanPreserveFloat16 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderSignedZeroInfNanPreserveFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSignedZeroInfNanPreserveFloat16)
	return *ptr
}

// ShaderSignedZeroInfNanPreserveFloat32 returns the value of shaderSignedZeroInfNanPreserveFloat32 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderSignedZeroInfNanPreserveFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSignedZeroInfNanPreserveFloat32)
	return *ptr
}

// ShaderSignedZeroInfNanPreserveFloat64 returns the value of shaderSignedZeroInfNanPreserveFloat64 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderSignedZeroInfNanPreserveFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSignedZeroInfNanPreserveFloat64)
	return *ptr
}

// ShaderDenormPreserveFloat16 returns the value of shaderDenormPreserveFloat16 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderDenormPreserveFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormPreserveFloat16)
	return *ptr
}

// ShaderDenormPreserveFloat32 returns the value of shaderDenormPreserveFloat32 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderDenormPreserveFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormPreserveFloat32)
	return *ptr
}

// ShaderDenormPreserveFloat64 returns the value of shaderDenormPreserveFloat64 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderDenormPreserveFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormPreserveFloat64)
	return *ptr
}

// ShaderDenormFlushToZeroFloat16 returns the value of shaderDenormFlushToZeroFloat16 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderDenormFlushToZeroFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormFlushToZeroFloat16)
	return *ptr
}

// ShaderDenormFlushToZeroFloat32 returns the value of shaderDenormFlushToZeroFloat32 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderDenormFlushToZeroFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormFlushToZeroFloat32)
	return *ptr
}

// ShaderDenormFlushToZeroFloat64 returns the value of shaderDenormFlushToZeroFloat64 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderDenormFlushToZeroFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormFlushToZeroFloat64)
	return *ptr
}

// ShaderRoundingModeRTEFloat16 returns the value of shaderRoundingModeRTEFloat16 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderRoundingModeRTEFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTEFloat16)
	return *ptr
}

// ShaderRoundingModeRTEFloat32 returns the value of shaderRoundingModeRTEFloat32 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderRoundingModeRTEFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTEFloat32)
	return *ptr
}

// ShaderRoundingModeRTEFloat64 returns the value of shaderRoundingModeRTEFloat64 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderRoundingModeRTEFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTEFloat64)
	return *ptr
}

// ShaderRoundingModeRTZFloat16 returns the value of shaderRoundingModeRTZFloat16 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderRoundingModeRTZFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTZFloat16)
	return *ptr
}

// ShaderRoundingModeRTZFloat32 returns the value of shaderRoundingModeRTZFloat32 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderRoundingModeRTZFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTZFloat32)
	return *ptr
}

// ShaderRoundingModeRTZFloat64 returns the value of shaderRoundingModeRTZFloat64 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderRoundingModeRTZFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTZFloat64)
	return *ptr
}

// BufferOpaqueCaptureAddressCreateInfo provides a go interface for VkBufferOpaqueCaptureAddressCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferOpaqueCaptureAddressCreateInfo.html
type BufferOpaqueCaptureAddressCreateInfo C.struct_VkBufferOpaqueCaptureAddressCreateInfo

// SizeofBufferOpaqueCaptureAddressCreateInfo is the memory size of a BufferOpaqueCaptureAddressCreateInfo
var SizeofBufferOpaqueCaptureAddressCreateInfo int = int(unsafe.Sizeof(BufferOpaqueCaptureAddressCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x BufferOpaqueCaptureAddressCreateInfo) ArpPtr(arp *AutoReleasePool) *BufferOpaqueCaptureAddressCreateInfo {
	ptr := newCBlock(cULong(SizeofBufferOpaqueCaptureAddressCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*BufferOpaqueCaptureAddressCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferOpaqueCaptureAddressCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferOpaqueCaptureAddressCreateInfo) AsCPtr() *BufferOpaqueCaptureAddressCreateInfo {
	clone := (*BufferOpaqueCaptureAddressCreateInfo)(newCBlock(cULong(SizeofBufferOpaqueCaptureAddressCreateInfo)))
	*clone = x
	return clone
}

// BufferOpaqueCaptureAddressCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func BufferOpaqueCaptureAddressCreateInfoCSlice(arp *AutoReleasePool, x ...BufferOpaqueCaptureAddressCreateInfo) []BufferOpaqueCaptureAddressCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferOpaqueCaptureAddressCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*BufferOpaqueCaptureAddressCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// BufferOpaqueCaptureAddressCreateInfoFreeCSlice releases the memory allocated by BufferOpaqueCaptureAddressCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BufferOpaqueCaptureAddressCreateInfoFreeCSlice(x []BufferOpaqueCaptureAddressCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferOpaqueCaptureAddressCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferOpaqueCaptureAddressCreateInfoFreeCSlice must be called on the returned slice.
func BufferOpaqueCaptureAddressCreateInfoMakeCSlice(x ...BufferOpaqueCaptureAddressCreateInfo) []BufferOpaqueCaptureAddressCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferOpaqueCaptureAddressCreateInfo * len(x)
	dst := unsafe.Slice((*BufferOpaqueCaptureAddressCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBufferOpaqueCaptureAddressCreateInfo
func (x BufferOpaqueCaptureAddressCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new BufferOpaqueCaptureAddressCreateInfo with the value of
// SType to the value provided in the specification.
func (x BufferOpaqueCaptureAddressCreateInfo) WithDefaultSType() BufferOpaqueCaptureAddressCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *BufferOpaqueCaptureAddressCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO)
}

// WithSType clones a new BufferOpaqueCaptureAddressCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferOpaqueCaptureAddressCreateInfo) WithSType(y StructureType) BufferOpaqueCaptureAddressCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *BufferOpaqueCaptureAddressCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkBufferOpaqueCaptureAddressCreateInfo
func (x BufferOpaqueCaptureAddressCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new BufferOpaqueCaptureAddressCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferOpaqueCaptureAddressCreateInfo) WithPNext(y unsafe.Pointer) BufferOpaqueCaptureAddressCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *BufferOpaqueCaptureAddressCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// OpaqueCaptureAddress returns the value of opaqueCaptureAddress from VkBufferOpaqueCaptureAddressCreateInfo
func (x BufferOpaqueCaptureAddressCreateInfo) OpaqueCaptureAddress() uint64 {
	ptr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.opaqueCaptureAddress)
	return *ptr
}

// WithOpaqueCaptureAddress clones a new BufferOpaqueCaptureAddressCreateInfo with the value of
// OpaqueCaptureAddress updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferOpaqueCaptureAddressCreateInfo) WithOpaqueCaptureAddress(y uint64) BufferOpaqueCaptureAddressCreateInfo {
	x.opaqueCaptureAddress = *(func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&y))
	return x
}
func (x *BufferOpaqueCaptureAddressCreateInfo) SetOpaqueCaptureAddress(y uint64) {
	x.opaqueCaptureAddress = *(func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&y))
}

// PhysicalDeviceSamplerFilterMinmaxProperties provides a go interface for VkPhysicalDeviceSamplerFilterMinmaxProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSamplerFilterMinmaxProperties.html
type PhysicalDeviceSamplerFilterMinmaxProperties C.struct_VkPhysicalDeviceSamplerFilterMinmaxProperties

// SizeofPhysicalDeviceSamplerFilterMinmaxProperties is the memory size of a PhysicalDeviceSamplerFilterMinmaxProperties
var SizeofPhysicalDeviceSamplerFilterMinmaxProperties int = int(unsafe.Sizeof(PhysicalDeviceSamplerFilterMinmaxProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceSamplerFilterMinmaxProperties) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceSamplerFilterMinmaxProperties {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceSamplerFilterMinmaxProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceSamplerFilterMinmaxProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceSamplerFilterMinmaxProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceSamplerFilterMinmaxProperties) AsCPtr() *PhysicalDeviceSamplerFilterMinmaxProperties {
	clone := (*PhysicalDeviceSamplerFilterMinmaxProperties)(newCBlock(cULong(SizeofPhysicalDeviceSamplerFilterMinmaxProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceSamplerFilterMinmaxPropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceSamplerFilterMinmaxPropertiesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceSamplerFilterMinmaxProperties) []PhysicalDeviceSamplerFilterMinmaxProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSamplerFilterMinmaxProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceSamplerFilterMinmaxProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceSamplerFilterMinmaxPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceSamplerFilterMinmaxPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceSamplerFilterMinmaxPropertiesFreeCSlice(x []PhysicalDeviceSamplerFilterMinmaxProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceSamplerFilterMinmaxPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceSamplerFilterMinmaxPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceSamplerFilterMinmaxPropertiesMakeCSlice(x ...PhysicalDeviceSamplerFilterMinmaxProperties) []PhysicalDeviceSamplerFilterMinmaxProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSamplerFilterMinmaxProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceSamplerFilterMinmaxProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceSamplerFilterMinmaxProperties
func (x PhysicalDeviceSamplerFilterMinmaxProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceSamplerFilterMinmaxProperties with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceSamplerFilterMinmaxProperties) WithDefaultSType() PhysicalDeviceSamplerFilterMinmaxProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceSamplerFilterMinmaxProperties) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES)
}

// WithSType clones a new PhysicalDeviceSamplerFilterMinmaxProperties with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSamplerFilterMinmaxProperties) WithSType(y StructureType) PhysicalDeviceSamplerFilterMinmaxProperties {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceSamplerFilterMinmaxProperties) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceSamplerFilterMinmaxProperties
func (x PhysicalDeviceSamplerFilterMinmaxProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceSamplerFilterMinmaxProperties with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSamplerFilterMinmaxProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceSamplerFilterMinmaxProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceSamplerFilterMinmaxProperties) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// FilterMinmaxSingleComponentFormats returns the value of filterMinmaxSingleComponentFormats from VkPhysicalDeviceSamplerFilterMinmaxProperties
func (x PhysicalDeviceSamplerFilterMinmaxProperties) FilterMinmaxSingleComponentFormats() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.filterMinmaxSingleComponentFormats)
	return *ptr
}

// FilterMinmaxImageComponentMapping returns the value of filterMinmaxImageComponentMapping from VkPhysicalDeviceSamplerFilterMinmaxProperties
func (x PhysicalDeviceSamplerFilterMinmaxProperties) FilterMinmaxImageComponentMapping() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.filterMinmaxImageComponentMapping)
	return *ptr
}

// DescriptorSetLayoutBindingFlagsCreateInfo provides a go interface for VkDescriptorSetLayoutBindingFlagsCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutBindingFlagsCreateInfo.html
type DescriptorSetLayoutBindingFlagsCreateInfo C.struct_VkDescriptorSetLayoutBindingFlagsCreateInfo

// SizeofDescriptorSetLayoutBindingFlagsCreateInfo is the memory size of a DescriptorSetLayoutBindingFlagsCreateInfo
var SizeofDescriptorSetLayoutBindingFlagsCreateInfo int = int(unsafe.Sizeof(DescriptorSetLayoutBindingFlagsCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DescriptorSetLayoutBindingFlagsCreateInfo) ArpPtr(arp *AutoReleasePool) *DescriptorSetLayoutBindingFlagsCreateInfo {
	ptr := newCBlock(cULong(SizeofDescriptorSetLayoutBindingFlagsCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DescriptorSetLayoutBindingFlagsCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorSetLayoutBindingFlagsCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorSetLayoutBindingFlagsCreateInfo) AsCPtr() *DescriptorSetLayoutBindingFlagsCreateInfo {
	clone := (*DescriptorSetLayoutBindingFlagsCreateInfo)(newCBlock(cULong(SizeofDescriptorSetLayoutBindingFlagsCreateInfo)))
	*clone = x
	return clone
}

// DescriptorSetLayoutBindingFlagsCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DescriptorSetLayoutBindingFlagsCreateInfoCSlice(arp *AutoReleasePool, x ...DescriptorSetLayoutBindingFlagsCreateInfo) []DescriptorSetLayoutBindingFlagsCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetLayoutBindingFlagsCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DescriptorSetLayoutBindingFlagsCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DescriptorSetLayoutBindingFlagsCreateInfoFreeCSlice releases the memory allocated by DescriptorSetLayoutBindingFlagsCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorSetLayoutBindingFlagsCreateInfoFreeCSlice(x []DescriptorSetLayoutBindingFlagsCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorSetLayoutBindingFlagsCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorSetLayoutBindingFlagsCreateInfoFreeCSlice must be called on the returned slice.
func DescriptorSetLayoutBindingFlagsCreateInfoMakeCSlice(x ...DescriptorSetLayoutBindingFlagsCreateInfo) []DescriptorSetLayoutBindingFlagsCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetLayoutBindingFlagsCreateInfo * len(x)
	dst := unsafe.Slice((*DescriptorSetLayoutBindingFlagsCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDescriptorSetLayoutBindingFlagsCreateInfo
func (x DescriptorSetLayoutBindingFlagsCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DescriptorSetLayoutBindingFlagsCreateInfo with the value of
// SType to the value provided in the specification.
func (x DescriptorSetLayoutBindingFlagsCreateInfo) WithDefaultSType() DescriptorSetLayoutBindingFlagsCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DescriptorSetLayoutBindingFlagsCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO)
}

// WithSType clones a new DescriptorSetLayoutBindingFlagsCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutBindingFlagsCreateInfo) WithSType(y StructureType) DescriptorSetLayoutBindingFlagsCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DescriptorSetLayoutBindingFlagsCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDescriptorSetLayoutBindingFlagsCreateInfo
func (x DescriptorSetLayoutBindingFlagsCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DescriptorSetLayoutBindingFlagsCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutBindingFlagsCreateInfo) WithPNext(y unsafe.Pointer) DescriptorSetLayoutBindingFlagsCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DescriptorSetLayoutBindingFlagsCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// BindingCount returns the value of bindingCount from VkDescriptorSetLayoutBindingFlagsCreateInfo
func (x DescriptorSetLayoutBindingFlagsCreateInfo) BindingCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.bindingCount)
	return *ptr
}

// WithBindingCount clones a new DescriptorSetLayoutBindingFlagsCreateInfo with the value of
// BindingCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutBindingFlagsCreateInfo) WithBindingCount(y uint32) DescriptorSetLayoutBindingFlagsCreateInfo {
	x.bindingCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DescriptorSetLayoutBindingFlagsCreateInfo) SetBindingCount(y uint32) {
	x.bindingCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PBindingFlags returns the value of pBindingFlags from VkDescriptorSetLayoutBindingFlagsCreateInfo
func (x DescriptorSetLayoutBindingFlagsCreateInfo) PBindingFlags() []DescriptorBindingFlags {
	ptr := func(x **C.VkDescriptorBindingFlags) *[]DescriptorBindingFlags { /* Slice */
		slc := unsafe.Slice((*DescriptorBindingFlags)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pBindingFlags)
	return *ptr
}

// WithPBindingFlags clones a new DescriptorSetLayoutBindingFlagsCreateInfo with the value of
// PBindingFlags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines BindingCount as the length of this field.
// BindingCount is updated with the length of the new value.
func (x DescriptorSetLayoutBindingFlagsCreateInfo) WithPBindingFlags(y []DescriptorBindingFlags) DescriptorSetLayoutBindingFlagsCreateInfo {
	x.pBindingFlags = *(func(x *[]DescriptorBindingFlags) **C.VkDescriptorBindingFlags { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkDescriptorBindingFlags)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkDescriptorBindingFlags)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithBindingCount(uint32(len(y)))
}
func (x *DescriptorSetLayoutBindingFlagsCreateInfo) SetPBindingFlags(y []DescriptorBindingFlags) {
	x.pBindingFlags = *(func(x *[]DescriptorBindingFlags) **C.VkDescriptorBindingFlags { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkDescriptorBindingFlags)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkDescriptorBindingFlags)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetBindingCount(uint32(len(y)))
}

// PhysicalDeviceDescriptorIndexingFeatures provides a go interface for VkPhysicalDeviceDescriptorIndexingFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDescriptorIndexingFeatures.html
type PhysicalDeviceDescriptorIndexingFeatures C.struct_VkPhysicalDeviceDescriptorIndexingFeatures

// SizeofPhysicalDeviceDescriptorIndexingFeatures is the memory size of a PhysicalDeviceDescriptorIndexingFeatures
var SizeofPhysicalDeviceDescriptorIndexingFeatures int = int(unsafe.Sizeof(PhysicalDeviceDescriptorIndexingFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceDescriptorIndexingFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceDescriptorIndexingFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceDescriptorIndexingFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceDescriptorIndexingFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceDescriptorIndexingFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceDescriptorIndexingFeatures) AsCPtr() *PhysicalDeviceDescriptorIndexingFeatures {
	clone := (*PhysicalDeviceDescriptorIndexingFeatures)(newCBlock(cULong(SizeofPhysicalDeviceDescriptorIndexingFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceDescriptorIndexingFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceDescriptorIndexingFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceDescriptorIndexingFeatures) []PhysicalDeviceDescriptorIndexingFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceDescriptorIndexingFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceDescriptorIndexingFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceDescriptorIndexingFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceDescriptorIndexingFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceDescriptorIndexingFeaturesFreeCSlice(x []PhysicalDeviceDescriptorIndexingFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceDescriptorIndexingFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceDescriptorIndexingFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceDescriptorIndexingFeaturesMakeCSlice(x ...PhysicalDeviceDescriptorIndexingFeatures) []PhysicalDeviceDescriptorIndexingFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceDescriptorIndexingFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceDescriptorIndexingFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceDescriptorIndexingFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDefaultSType() PhysicalDeviceDescriptorIndexingFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceDescriptorIndexingFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES)
}

// WithSType clones a new PhysicalDeviceDescriptorIndexingFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithSType(y StructureType) PhysicalDeviceDescriptorIndexingFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceDescriptorIndexingFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceDescriptorIndexingFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceDescriptorIndexingFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceDescriptorIndexingFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// ShaderInputAttachmentArrayDynamicIndexing returns the value of shaderInputAttachmentArrayDynamicIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderInputAttachmentArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInputAttachmentArrayDynamicIndexing)
	return *ptr
}

// WithShaderInputAttachmentArrayDynamicIndexing clones a new PhysicalDeviceDescriptorIndexingFeatures with the value of
// ShaderInputAttachmentArrayDynamicIndexing updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderInputAttachmentArrayDynamicIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.shaderInputAttachmentArrayDynamicIndexing = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceDescriptorIndexingFeatures) SetShaderInputAttachmentArrayDynamicIndexing(y Bool32) {
	x.shaderInputAttachmentArrayDynamicIndexing = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderUniformTexelBufferArrayDynamicIndexing returns the value of shaderUniformTexelBufferArrayDynamicIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderUniformTexelBufferArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderUniformTexelBufferArrayDynamicIndexing)
	return *ptr
}

// WithShaderUniformTexelBufferArrayDynamicIndexing clones a new PhysicalDeviceDescriptorIndexingFeatures with the value of
// ShaderUniformTexelBufferArrayDynamicIndexing updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderUniformTexelBufferArrayDynamicIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.shaderUniformTexelBufferArrayDynamicIndexing = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceDescriptorIndexingFeatures) SetShaderUniformTexelBufferArrayDynamicIndexing(y Bool32) {
	x.shaderUniformTexelBufferArrayDynamicIndexing = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderStorageTexelBufferArrayDynamicIndexing returns the value of shaderStorageTexelBufferArrayDynamicIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderStorageTexelBufferArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageTexelBufferArrayDynamicIndexing)
	return *ptr
}

// WithShaderStorageTexelBufferArrayDynamicIndexing clones a new PhysicalDeviceDescriptorIndexingFeatures with the value of
// ShaderStorageTexelBufferArrayDynamicIndexing updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderStorageTexelBufferArrayDynamicIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.shaderStorageTexelBufferArrayDynamicIndexing = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceDescriptorIndexingFeatures) SetShaderStorageTexelBufferArrayDynamicIndexing(y Bool32) {
	x.shaderStorageTexelBufferArrayDynamicIndexing = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderUniformBufferArrayNonUniformIndexing returns the value of shaderUniformBufferArrayNonUniformIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderUniformBufferArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderUniformBufferArrayNonUniformIndexing)
	return *ptr
}

// WithShaderUniformBufferArrayNonUniformIndexing clones a new PhysicalDeviceDescriptorIndexingFeatures with the value of
// ShaderUniformBufferArrayNonUniformIndexing updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderUniformBufferArrayNonUniformIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.shaderUniformBufferArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceDescriptorIndexingFeatures) SetShaderUniformBufferArrayNonUniformIndexing(y Bool32) {
	x.shaderUniformBufferArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderSampledImageArrayNonUniformIndexing returns the value of shaderSampledImageArrayNonUniformIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderSampledImageArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSampledImageArrayNonUniformIndexing)
	return *ptr
}

// WithShaderSampledImageArrayNonUniformIndexing clones a new PhysicalDeviceDescriptorIndexingFeatures with the value of
// ShaderSampledImageArrayNonUniformIndexing updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderSampledImageArrayNonUniformIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.shaderSampledImageArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceDescriptorIndexingFeatures) SetShaderSampledImageArrayNonUniformIndexing(y Bool32) {
	x.shaderSampledImageArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderStorageBufferArrayNonUniformIndexing returns the value of shaderStorageBufferArrayNonUniformIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderStorageBufferArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageBufferArrayNonUniformIndexing)
	return *ptr
}

// WithShaderStorageBufferArrayNonUniformIndexing clones a new PhysicalDeviceDescriptorIndexingFeatures with the value of
// ShaderStorageBufferArrayNonUniformIndexing updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderStorageBufferArrayNonUniformIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.shaderStorageBufferArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceDescriptorIndexingFeatures) SetShaderStorageBufferArrayNonUniformIndexing(y Bool32) {
	x.shaderStorageBufferArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderStorageImageArrayNonUniformIndexing returns the value of shaderStorageImageArrayNonUniformIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderStorageImageArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageImageArrayNonUniformIndexing)
	return *ptr
}

// WithShaderStorageImageArrayNonUniformIndexing clones a new PhysicalDeviceDescriptorIndexingFeatures with the value of
// ShaderStorageImageArrayNonUniformIndexing updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderStorageImageArrayNonUniformIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.shaderStorageImageArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceDescriptorIndexingFeatures) SetShaderStorageImageArrayNonUniformIndexing(y Bool32) {
	x.shaderStorageImageArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderInputAttachmentArrayNonUniformIndexing returns the value of shaderInputAttachmentArrayNonUniformIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderInputAttachmentArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInputAttachmentArrayNonUniformIndexing)
	return *ptr
}

// WithShaderInputAttachmentArrayNonUniformIndexing clones a new PhysicalDeviceDescriptorIndexingFeatures with the value of
// ShaderInputAttachmentArrayNonUniformIndexing updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderInputAttachmentArrayNonUniformIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.shaderInputAttachmentArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceDescriptorIndexingFeatures) SetShaderInputAttachmentArrayNonUniformIndexing(y Bool32) {
	x.shaderInputAttachmentArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderUniformTexelBufferArrayNonUniformIndexing returns the value of shaderUniformTexelBufferArrayNonUniformIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderUniformTexelBufferArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderUniformTexelBufferArrayNonUniformIndexing)
	return *ptr
}

// WithShaderUniformTexelBufferArrayNonUniformIndexing clones a new PhysicalDeviceDescriptorIndexingFeatures with the value of
// ShaderUniformTexelBufferArrayNonUniformIndexing updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderUniformTexelBufferArrayNonUniformIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.shaderUniformTexelBufferArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceDescriptorIndexingFeatures) SetShaderUniformTexelBufferArrayNonUniformIndexing(y Bool32) {
	x.shaderUniformTexelBufferArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderStorageTexelBufferArrayNonUniformIndexing returns the value of shaderStorageTexelBufferArrayNonUniformIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderStorageTexelBufferArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageTexelBufferArrayNonUniformIndexing)
	return *ptr
}

// WithShaderStorageTexelBufferArrayNonUniformIndexing clones a new PhysicalDeviceDescriptorIndexingFeatures with the value of
// ShaderStorageTexelBufferArrayNonUniformIndexing updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderStorageTexelBufferArrayNonUniformIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.shaderStorageTexelBufferArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceDescriptorIndexingFeatures) SetShaderStorageTexelBufferArrayNonUniformIndexing(y Bool32) {
	x.shaderStorageTexelBufferArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
}

// DescriptorBindingUniformBufferUpdateAfterBind returns the value of descriptorBindingUniformBufferUpdateAfterBind from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) DescriptorBindingUniformBufferUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingUniformBufferUpdateAfterBind)
	return *ptr
}

// WithDescriptorBindingUniformBufferUpdateAfterBind clones a new PhysicalDeviceDescriptorIndexingFeatures with the value of
// DescriptorBindingUniformBufferUpdateAfterBind updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDescriptorBindingUniformBufferUpdateAfterBind(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.descriptorBindingUniformBufferUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceDescriptorIndexingFeatures) SetDescriptorBindingUniformBufferUpdateAfterBind(y Bool32) {
	x.descriptorBindingUniformBufferUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
}

// DescriptorBindingSampledImageUpdateAfterBind returns the value of descriptorBindingSampledImageUpdateAfterBind from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) DescriptorBindingSampledImageUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingSampledImageUpdateAfterBind)
	return *ptr
}

// WithDescriptorBindingSampledImageUpdateAfterBind clones a new PhysicalDeviceDescriptorIndexingFeatures with the value of
// DescriptorBindingSampledImageUpdateAfterBind updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDescriptorBindingSampledImageUpdateAfterBind(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.descriptorBindingSampledImageUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceDescriptorIndexingFeatures) SetDescriptorBindingSampledImageUpdateAfterBind(y Bool32) {
	x.descriptorBindingSampledImageUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
}

// DescriptorBindingStorageImageUpdateAfterBind returns the value of descriptorBindingStorageImageUpdateAfterBind from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) DescriptorBindingStorageImageUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingStorageImageUpdateAfterBind)
	return *ptr
}

// WithDescriptorBindingStorageImageUpdateAfterBind clones a new PhysicalDeviceDescriptorIndexingFeatures with the value of
// DescriptorBindingStorageImageUpdateAfterBind updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDescriptorBindingStorageImageUpdateAfterBind(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.descriptorBindingStorageImageUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceDescriptorIndexingFeatures) SetDescriptorBindingStorageImageUpdateAfterBind(y Bool32) {
	x.descriptorBindingStorageImageUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
}

// DescriptorBindingStorageBufferUpdateAfterBind returns the value of descriptorBindingStorageBufferUpdateAfterBind from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) DescriptorBindingStorageBufferUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingStorageBufferUpdateAfterBind)
	return *ptr
}

// WithDescriptorBindingStorageBufferUpdateAfterBind clones a new PhysicalDeviceDescriptorIndexingFeatures with the value of
// DescriptorBindingStorageBufferUpdateAfterBind updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDescriptorBindingStorageBufferUpdateAfterBind(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.descriptorBindingStorageBufferUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceDescriptorIndexingFeatures) SetDescriptorBindingStorageBufferUpdateAfterBind(y Bool32) {
	x.descriptorBindingStorageBufferUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
}

// DescriptorBindingUniformTexelBufferUpdateAfterBind returns the value of descriptorBindingUniformTexelBufferUpdateAfterBind from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) DescriptorBindingUniformTexelBufferUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingUniformTexelBufferUpdateAfterBind)
	return *ptr
}

// WithDescriptorBindingUniformTexelBufferUpdateAfterBind clones a new PhysicalDeviceDescriptorIndexingFeatures with the value of
// DescriptorBindingUniformTexelBufferUpdateAfterBind updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDescriptorBindingUniformTexelBufferUpdateAfterBind(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.descriptorBindingUniformTexelBufferUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceDescriptorIndexingFeatures) SetDescriptorBindingUniformTexelBufferUpdateAfterBind(y Bool32) {
	x.descriptorBindingUniformTexelBufferUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
}

// DescriptorBindingStorageTexelBufferUpdateAfterBind returns the value of descriptorBindingStorageTexelBufferUpdateAfterBind from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) DescriptorBindingStorageTexelBufferUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingStorageTexelBufferUpdateAfterBind)
	return *ptr
}

// WithDescriptorBindingStorageTexelBufferUpdateAfterBind clones a new PhysicalDeviceDescriptorIndexingFeatures with the value of
// DescriptorBindingStorageTexelBufferUpdateAfterBind updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDescriptorBindingStorageTexelBufferUpdateAfterBind(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.descriptorBindingStorageTexelBufferUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceDescriptorIndexingFeatures) SetDescriptorBindingStorageTexelBufferUpdateAfterBind(y Bool32) {
	x.descriptorBindingStorageTexelBufferUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
}

// DescriptorBindingUpdateUnusedWhilePending returns the value of descriptorBindingUpdateUnusedWhilePending from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) DescriptorBindingUpdateUnusedWhilePending() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingUpdateUnusedWhilePending)
	return *ptr
}

// WithDescriptorBindingUpdateUnusedWhilePending clones a new PhysicalDeviceDescriptorIndexingFeatures with the value of
// DescriptorBindingUpdateUnusedWhilePending updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDescriptorBindingUpdateUnusedWhilePending(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.descriptorBindingUpdateUnusedWhilePending = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceDescriptorIndexingFeatures) SetDescriptorBindingUpdateUnusedWhilePending(y Bool32) {
	x.descriptorBindingUpdateUnusedWhilePending = *( /* typedef */ (*C.VkBool32)(&y))
}

// DescriptorBindingPartiallyBound returns the value of descriptorBindingPartiallyBound from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) DescriptorBindingPartiallyBound() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingPartiallyBound)
	return *ptr
}

// WithDescriptorBindingPartiallyBound clones a new PhysicalDeviceDescriptorIndexingFeatures with the value of
// DescriptorBindingPartiallyBound updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDescriptorBindingPartiallyBound(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.descriptorBindingPartiallyBound = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceDescriptorIndexingFeatures) SetDescriptorBindingPartiallyBound(y Bool32) {
	x.descriptorBindingPartiallyBound = *( /* typedef */ (*C.VkBool32)(&y))
}

// DescriptorBindingVariableDescriptorCount returns the value of descriptorBindingVariableDescriptorCount from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) DescriptorBindingVariableDescriptorCount() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingVariableDescriptorCount)
	return *ptr
}

// WithDescriptorBindingVariableDescriptorCount clones a new PhysicalDeviceDescriptorIndexingFeatures with the value of
// DescriptorBindingVariableDescriptorCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDescriptorBindingVariableDescriptorCount(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.descriptorBindingVariableDescriptorCount = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceDescriptorIndexingFeatures) SetDescriptorBindingVariableDescriptorCount(y Bool32) {
	x.descriptorBindingVariableDescriptorCount = *( /* typedef */ (*C.VkBool32)(&y))
}

// RuntimeDescriptorArray returns the value of runtimeDescriptorArray from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) RuntimeDescriptorArray() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.runtimeDescriptorArray)
	return *ptr
}

// WithRuntimeDescriptorArray clones a new PhysicalDeviceDescriptorIndexingFeatures with the value of
// RuntimeDescriptorArray updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithRuntimeDescriptorArray(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.runtimeDescriptorArray = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceDescriptorIndexingFeatures) SetRuntimeDescriptorArray(y Bool32) {
	x.runtimeDescriptorArray = *( /* typedef */ (*C.VkBool32)(&y))
}

// PhysicalDeviceDescriptorIndexingProperties provides a go interface for VkPhysicalDeviceDescriptorIndexingProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDescriptorIndexingProperties.html
type PhysicalDeviceDescriptorIndexingProperties C.struct_VkPhysicalDeviceDescriptorIndexingProperties

// SizeofPhysicalDeviceDescriptorIndexingProperties is the memory size of a PhysicalDeviceDescriptorIndexingProperties
var SizeofPhysicalDeviceDescriptorIndexingProperties int = int(unsafe.Sizeof(PhysicalDeviceDescriptorIndexingProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceDescriptorIndexingProperties) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceDescriptorIndexingProperties {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceDescriptorIndexingProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceDescriptorIndexingProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceDescriptorIndexingProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceDescriptorIndexingProperties) AsCPtr() *PhysicalDeviceDescriptorIndexingProperties {
	clone := (*PhysicalDeviceDescriptorIndexingProperties)(newCBlock(cULong(SizeofPhysicalDeviceDescriptorIndexingProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceDescriptorIndexingPropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceDescriptorIndexingPropertiesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceDescriptorIndexingProperties) []PhysicalDeviceDescriptorIndexingProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceDescriptorIndexingProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceDescriptorIndexingProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceDescriptorIndexingPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceDescriptorIndexingPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceDescriptorIndexingPropertiesFreeCSlice(x []PhysicalDeviceDescriptorIndexingProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceDescriptorIndexingPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceDescriptorIndexingPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceDescriptorIndexingPropertiesMakeCSlice(x ...PhysicalDeviceDescriptorIndexingProperties) []PhysicalDeviceDescriptorIndexingProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceDescriptorIndexingProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceDescriptorIndexingProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceDescriptorIndexingProperties with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceDescriptorIndexingProperties) WithDefaultSType() PhysicalDeviceDescriptorIndexingProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceDescriptorIndexingProperties) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES)
}

// WithSType clones a new PhysicalDeviceDescriptorIndexingProperties with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingProperties) WithSType(y StructureType) PhysicalDeviceDescriptorIndexingProperties {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceDescriptorIndexingProperties) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceDescriptorIndexingProperties with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceDescriptorIndexingProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceDescriptorIndexingProperties) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// MaxUpdateAfterBindDescriptorsInAllPools returns the value of maxUpdateAfterBindDescriptorsInAllPools from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxUpdateAfterBindDescriptorsInAllPools() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxUpdateAfterBindDescriptorsInAllPools)
	return *ptr
}

// ShaderUniformBufferArrayNonUniformIndexingNative returns the value of shaderUniformBufferArrayNonUniformIndexingNative from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) ShaderUniformBufferArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderUniformBufferArrayNonUniformIndexingNative)
	return *ptr
}

// ShaderSampledImageArrayNonUniformIndexingNative returns the value of shaderSampledImageArrayNonUniformIndexingNative from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) ShaderSampledImageArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSampledImageArrayNonUniformIndexingNative)
	return *ptr
}

// ShaderStorageBufferArrayNonUniformIndexingNative returns the value of shaderStorageBufferArrayNonUniformIndexingNative from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) ShaderStorageBufferArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageBufferArrayNonUniformIndexingNative)
	return *ptr
}

// ShaderStorageImageArrayNonUniformIndexingNative returns the value of shaderStorageImageArrayNonUniformIndexingNative from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) ShaderStorageImageArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageImageArrayNonUniformIndexingNative)
	return *ptr
}

// ShaderInputAttachmentArrayNonUniformIndexingNative returns the value of shaderInputAttachmentArrayNonUniformIndexingNative from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) ShaderInputAttachmentArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInputAttachmentArrayNonUniformIndexingNative)
	return *ptr
}

// RobustBufferAccessUpdateAfterBind returns the value of robustBufferAccessUpdateAfterBind from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) RobustBufferAccessUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.robustBufferAccessUpdateAfterBind)
	return *ptr
}

// QuadDivergentImplicitLod returns the value of quadDivergentImplicitLod from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) QuadDivergentImplicitLod() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.quadDivergentImplicitLod)
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindSamplers returns the value of maxPerStageDescriptorUpdateAfterBindSamplers from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxPerStageDescriptorUpdateAfterBindSamplers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindSamplers)
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindUniformBuffers returns the value of maxPerStageDescriptorUpdateAfterBindUniformBuffers from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxPerStageDescriptorUpdateAfterBindUniformBuffers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindUniformBuffers)
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindStorageBuffers returns the value of maxPerStageDescriptorUpdateAfterBindStorageBuffers from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxPerStageDescriptorUpdateAfterBindStorageBuffers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindStorageBuffers)
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindSampledImages returns the value of maxPerStageDescriptorUpdateAfterBindSampledImages from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxPerStageDescriptorUpdateAfterBindSampledImages() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindSampledImages)
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindStorageImages returns the value of maxPerStageDescriptorUpdateAfterBindStorageImages from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxPerStageDescriptorUpdateAfterBindStorageImages() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindStorageImages)
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindInputAttachments returns the value of maxPerStageDescriptorUpdateAfterBindInputAttachments from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxPerStageDescriptorUpdateAfterBindInputAttachments() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindInputAttachments)
	return *ptr
}

// MaxPerStageUpdateAfterBindResources returns the value of maxPerStageUpdateAfterBindResources from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxPerStageUpdateAfterBindResources() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageUpdateAfterBindResources)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindSamplers returns the value of maxDescriptorSetUpdateAfterBindSamplers from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxDescriptorSetUpdateAfterBindSamplers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindSamplers)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindUniformBuffers returns the value of maxDescriptorSetUpdateAfterBindUniformBuffers from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxDescriptorSetUpdateAfterBindUniformBuffers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindUniformBuffers)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic returns the value of maxDescriptorSetUpdateAfterBindUniformBuffersDynamic from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindStorageBuffers returns the value of maxDescriptorSetUpdateAfterBindStorageBuffers from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxDescriptorSetUpdateAfterBindStorageBuffers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindStorageBuffers)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic returns the value of maxDescriptorSetUpdateAfterBindStorageBuffersDynamic from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindSampledImages returns the value of maxDescriptorSetUpdateAfterBindSampledImages from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxDescriptorSetUpdateAfterBindSampledImages() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindSampledImages)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindStorageImages returns the value of maxDescriptorSetUpdateAfterBindStorageImages from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxDescriptorSetUpdateAfterBindStorageImages() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindStorageImages)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindInputAttachments returns the value of maxDescriptorSetUpdateAfterBindInputAttachments from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxDescriptorSetUpdateAfterBindInputAttachments() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindInputAttachments)
	return *ptr
}

// DescriptorSetVariableDescriptorCountAllocateInfo provides a go interface for VkDescriptorSetVariableDescriptorCountAllocateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetVariableDescriptorCountAllocateInfo.html
type DescriptorSetVariableDescriptorCountAllocateInfo C.struct_VkDescriptorSetVariableDescriptorCountAllocateInfo

// SizeofDescriptorSetVariableDescriptorCountAllocateInfo is the memory size of a DescriptorSetVariableDescriptorCountAllocateInfo
var SizeofDescriptorSetVariableDescriptorCountAllocateInfo int = int(unsafe.Sizeof(DescriptorSetVariableDescriptorCountAllocateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DescriptorSetVariableDescriptorCountAllocateInfo) ArpPtr(arp *AutoReleasePool) *DescriptorSetVariableDescriptorCountAllocateInfo {
	ptr := newCBlock(cULong(SizeofDescriptorSetVariableDescriptorCountAllocateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DescriptorSetVariableDescriptorCountAllocateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorSetVariableDescriptorCountAllocateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorSetVariableDescriptorCountAllocateInfo) AsCPtr() *DescriptorSetVariableDescriptorCountAllocateInfo {
	clone := (*DescriptorSetVariableDescriptorCountAllocateInfo)(newCBlock(cULong(SizeofDescriptorSetVariableDescriptorCountAllocateInfo)))
	*clone = x
	return clone
}

// DescriptorSetVariableDescriptorCountAllocateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DescriptorSetVariableDescriptorCountAllocateInfoCSlice(arp *AutoReleasePool, x ...DescriptorSetVariableDescriptorCountAllocateInfo) []DescriptorSetVariableDescriptorCountAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetVariableDescriptorCountAllocateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DescriptorSetVariableDescriptorCountAllocateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DescriptorSetVariableDescriptorCountAllocateInfoFreeCSlice releases the memory allocated by DescriptorSetVariableDescriptorCountAllocateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorSetVariableDescriptorCountAllocateInfoFreeCSlice(x []DescriptorSetVariableDescriptorCountAllocateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorSetVariableDescriptorCountAllocateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorSetVariableDescriptorCountAllocateInfoFreeCSlice must be called on the returned slice.
func DescriptorSetVariableDescriptorCountAllocateInfoMakeCSlice(x ...DescriptorSetVariableDescriptorCountAllocateInfo) []DescriptorSetVariableDescriptorCountAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetVariableDescriptorCountAllocateInfo * len(x)
	dst := unsafe.Slice((*DescriptorSetVariableDescriptorCountAllocateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDescriptorSetVariableDescriptorCountAllocateInfo
func (x DescriptorSetVariableDescriptorCountAllocateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DescriptorSetVariableDescriptorCountAllocateInfo with the value of
// SType to the value provided in the specification.
func (x DescriptorSetVariableDescriptorCountAllocateInfo) WithDefaultSType() DescriptorSetVariableDescriptorCountAllocateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DescriptorSetVariableDescriptorCountAllocateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO)
}

// WithSType clones a new DescriptorSetVariableDescriptorCountAllocateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetVariableDescriptorCountAllocateInfo) WithSType(y StructureType) DescriptorSetVariableDescriptorCountAllocateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DescriptorSetVariableDescriptorCountAllocateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDescriptorSetVariableDescriptorCountAllocateInfo
func (x DescriptorSetVariableDescriptorCountAllocateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DescriptorSetVariableDescriptorCountAllocateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetVariableDescriptorCountAllocateInfo) WithPNext(y unsafe.Pointer) DescriptorSetVariableDescriptorCountAllocateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DescriptorSetVariableDescriptorCountAllocateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// DescriptorSetCount returns the value of descriptorSetCount from VkDescriptorSetVariableDescriptorCountAllocateInfo
func (x DescriptorSetVariableDescriptorCountAllocateInfo) DescriptorSetCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.descriptorSetCount)
	return *ptr
}

// WithDescriptorSetCount clones a new DescriptorSetVariableDescriptorCountAllocateInfo with the value of
// DescriptorSetCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetVariableDescriptorCountAllocateInfo) WithDescriptorSetCount(y uint32) DescriptorSetVariableDescriptorCountAllocateInfo {
	x.descriptorSetCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DescriptorSetVariableDescriptorCountAllocateInfo) SetDescriptorSetCount(y uint32) {
	x.descriptorSetCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PDescriptorCounts returns the value of pDescriptorCounts from VkDescriptorSetVariableDescriptorCountAllocateInfo
func (x DescriptorSetVariableDescriptorCountAllocateInfo) PDescriptorCounts() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pDescriptorCounts)
	return *ptr
}

// WithPDescriptorCounts clones a new DescriptorSetVariableDescriptorCountAllocateInfo with the value of
// PDescriptorCounts updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DescriptorSetCount as the length of this field.
// DescriptorSetCount is updated with the length of the new value.
func (x DescriptorSetVariableDescriptorCountAllocateInfo) WithPDescriptorCounts(y []uint32) DescriptorSetVariableDescriptorCountAllocateInfo {
	x.pDescriptorCounts = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithDescriptorSetCount(uint32(len(y)))
}
func (x *DescriptorSetVariableDescriptorCountAllocateInfo) SetPDescriptorCounts(y []uint32) {
	x.pDescriptorCounts = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetDescriptorSetCount(uint32(len(y)))
}

// DescriptorSetVariableDescriptorCountLayoutSupport provides a go interface for VkDescriptorSetVariableDescriptorCountLayoutSupport.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetVariableDescriptorCountLayoutSupport.html
type DescriptorSetVariableDescriptorCountLayoutSupport C.struct_VkDescriptorSetVariableDescriptorCountLayoutSupport

// SizeofDescriptorSetVariableDescriptorCountLayoutSupport is the memory size of a DescriptorSetVariableDescriptorCountLayoutSupport
var SizeofDescriptorSetVariableDescriptorCountLayoutSupport int = int(unsafe.Sizeof(DescriptorSetVariableDescriptorCountLayoutSupport{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DescriptorSetVariableDescriptorCountLayoutSupport) ArpPtr(arp *AutoReleasePool) *DescriptorSetVariableDescriptorCountLayoutSupport {
	ptr := newCBlock(cULong(SizeofDescriptorSetVariableDescriptorCountLayoutSupport))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DescriptorSetVariableDescriptorCountLayoutSupport)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorSetVariableDescriptorCountLayoutSupport) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorSetVariableDescriptorCountLayoutSupport) AsCPtr() *DescriptorSetVariableDescriptorCountLayoutSupport {
	clone := (*DescriptorSetVariableDescriptorCountLayoutSupport)(newCBlock(cULong(SizeofDescriptorSetVariableDescriptorCountLayoutSupport)))
	*clone = x
	return clone
}

// DescriptorSetVariableDescriptorCountLayoutSupportCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DescriptorSetVariableDescriptorCountLayoutSupportCSlice(arp *AutoReleasePool, x ...DescriptorSetVariableDescriptorCountLayoutSupport) []DescriptorSetVariableDescriptorCountLayoutSupport {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetVariableDescriptorCountLayoutSupport * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DescriptorSetVariableDescriptorCountLayoutSupport)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DescriptorSetVariableDescriptorCountLayoutSupportFreeCSlice releases the memory allocated by DescriptorSetVariableDescriptorCountLayoutSupportMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorSetVariableDescriptorCountLayoutSupportFreeCSlice(x []DescriptorSetVariableDescriptorCountLayoutSupport) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorSetVariableDescriptorCountLayoutSupportMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorSetVariableDescriptorCountLayoutSupportFreeCSlice must be called on the returned slice.
func DescriptorSetVariableDescriptorCountLayoutSupportMakeCSlice(x ...DescriptorSetVariableDescriptorCountLayoutSupport) []DescriptorSetVariableDescriptorCountLayoutSupport {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetVariableDescriptorCountLayoutSupport * len(x)
	dst := unsafe.Slice((*DescriptorSetVariableDescriptorCountLayoutSupport)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDescriptorSetVariableDescriptorCountLayoutSupport
func (x DescriptorSetVariableDescriptorCountLayoutSupport) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DescriptorSetVariableDescriptorCountLayoutSupport with the value of
// SType to the value provided in the specification.
func (x DescriptorSetVariableDescriptorCountLayoutSupport) WithDefaultSType() DescriptorSetVariableDescriptorCountLayoutSupport {
	return x.WithSType(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DescriptorSetVariableDescriptorCountLayoutSupport) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT)
}

// WithSType clones a new DescriptorSetVariableDescriptorCountLayoutSupport with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetVariableDescriptorCountLayoutSupport) WithSType(y StructureType) DescriptorSetVariableDescriptorCountLayoutSupport {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DescriptorSetVariableDescriptorCountLayoutSupport) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDescriptorSetVariableDescriptorCountLayoutSupport
func (x DescriptorSetVariableDescriptorCountLayoutSupport) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DescriptorSetVariableDescriptorCountLayoutSupport with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetVariableDescriptorCountLayoutSupport) WithPNext(y unsafe.Pointer) DescriptorSetVariableDescriptorCountLayoutSupport {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DescriptorSetVariableDescriptorCountLayoutSupport) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// MaxVariableDescriptorCount returns the value of maxVariableDescriptorCount from VkDescriptorSetVariableDescriptorCountLayoutSupport
func (x DescriptorSetVariableDescriptorCountLayoutSupport) MaxVariableDescriptorCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxVariableDescriptorCount)
	return *ptr
}

// MemoryOpaqueCaptureAddressAllocateInfo provides a go interface for VkMemoryOpaqueCaptureAddressAllocateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryOpaqueCaptureAddressAllocateInfo.html
type MemoryOpaqueCaptureAddressAllocateInfo C.struct_VkMemoryOpaqueCaptureAddressAllocateInfo

// SizeofMemoryOpaqueCaptureAddressAllocateInfo is the memory size of a MemoryOpaqueCaptureAddressAllocateInfo
var SizeofMemoryOpaqueCaptureAddressAllocateInfo int = int(unsafe.Sizeof(MemoryOpaqueCaptureAddressAllocateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x MemoryOpaqueCaptureAddressAllocateInfo) ArpPtr(arp *AutoReleasePool) *MemoryOpaqueCaptureAddressAllocateInfo {
	ptr := newCBlock(cULong(SizeofMemoryOpaqueCaptureAddressAllocateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*MemoryOpaqueCaptureAddressAllocateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryOpaqueCaptureAddressAllocateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryOpaqueCaptureAddressAllocateInfo) AsCPtr() *MemoryOpaqueCaptureAddressAllocateInfo {
	clone := (*MemoryOpaqueCaptureAddressAllocateInfo)(newCBlock(cULong(SizeofMemoryOpaqueCaptureAddressAllocateInfo)))
	*clone = x
	return clone
}

// MemoryOpaqueCaptureAddressAllocateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func MemoryOpaqueCaptureAddressAllocateInfoCSlice(arp *AutoReleasePool, x ...MemoryOpaqueCaptureAddressAllocateInfo) []MemoryOpaqueCaptureAddressAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryOpaqueCaptureAddressAllocateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*MemoryOpaqueCaptureAddressAllocateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// MemoryOpaqueCaptureAddressAllocateInfoFreeCSlice releases the memory allocated by MemoryOpaqueCaptureAddressAllocateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryOpaqueCaptureAddressAllocateInfoFreeCSlice(x []MemoryOpaqueCaptureAddressAllocateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryOpaqueCaptureAddressAllocateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryOpaqueCaptureAddressAllocateInfoFreeCSlice must be called on the returned slice.
func MemoryOpaqueCaptureAddressAllocateInfoMakeCSlice(x ...MemoryOpaqueCaptureAddressAllocateInfo) []MemoryOpaqueCaptureAddressAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryOpaqueCaptureAddressAllocateInfo * len(x)
	dst := unsafe.Slice((*MemoryOpaqueCaptureAddressAllocateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkMemoryOpaqueCaptureAddressAllocateInfo
func (x MemoryOpaqueCaptureAddressAllocateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new MemoryOpaqueCaptureAddressAllocateInfo with the value of
// SType to the value provided in the specification.
func (x MemoryOpaqueCaptureAddressAllocateInfo) WithDefaultSType() MemoryOpaqueCaptureAddressAllocateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *MemoryOpaqueCaptureAddressAllocateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO)
}

// WithSType clones a new MemoryOpaqueCaptureAddressAllocateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryOpaqueCaptureAddressAllocateInfo) WithSType(y StructureType) MemoryOpaqueCaptureAddressAllocateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *MemoryOpaqueCaptureAddressAllocateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkMemoryOpaqueCaptureAddressAllocateInfo
func (x MemoryOpaqueCaptureAddressAllocateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new MemoryOpaqueCaptureAddressAllocateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryOpaqueCaptureAddressAllocateInfo) WithPNext(y unsafe.Pointer) MemoryOpaqueCaptureAddressAllocateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *MemoryOpaqueCaptureAddressAllocateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// OpaqueCaptureAddress returns the value of opaqueCaptureAddress from VkMemoryOpaqueCaptureAddressAllocateInfo
func (x MemoryOpaqueCaptureAddressAllocateInfo) OpaqueCaptureAddress() uint64 {
	ptr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.opaqueCaptureAddress)
	return *ptr
}

// WithOpaqueCaptureAddress clones a new MemoryOpaqueCaptureAddressAllocateInfo with the value of
// OpaqueCaptureAddress updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryOpaqueCaptureAddressAllocateInfo) WithOpaqueCaptureAddress(y uint64) MemoryOpaqueCaptureAddressAllocateInfo {
	x.opaqueCaptureAddress = *(func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&y))
	return x
}
func (x *MemoryOpaqueCaptureAddressAllocateInfo) SetOpaqueCaptureAddress(y uint64) {
	x.opaqueCaptureAddress = *(func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&y))
}

// DeviceMemoryOpaqueCaptureAddressInfo provides a go interface for VkDeviceMemoryOpaqueCaptureAddressInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceMemoryOpaqueCaptureAddressInfo.html
type DeviceMemoryOpaqueCaptureAddressInfo C.struct_VkDeviceMemoryOpaqueCaptureAddressInfo

// SizeofDeviceMemoryOpaqueCaptureAddressInfo is the memory size of a DeviceMemoryOpaqueCaptureAddressInfo
var SizeofDeviceMemoryOpaqueCaptureAddressInfo int = int(unsafe.Sizeof(DeviceMemoryOpaqueCaptureAddressInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DeviceMemoryOpaqueCaptureAddressInfo) ArpPtr(arp *AutoReleasePool) *DeviceMemoryOpaqueCaptureAddressInfo {
	ptr := newCBlock(cULong(SizeofDeviceMemoryOpaqueCaptureAddressInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DeviceMemoryOpaqueCaptureAddressInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceMemoryOpaqueCaptureAddressInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceMemoryOpaqueCaptureAddressInfo) AsCPtr() *DeviceMemoryOpaqueCaptureAddressInfo {
	clone := (*DeviceMemoryOpaqueCaptureAddressInfo)(newCBlock(cULong(SizeofDeviceMemoryOpaqueCaptureAddressInfo)))
	*clone = x
	return clone
}

// DeviceMemoryOpaqueCaptureAddressInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DeviceMemoryOpaqueCaptureAddressInfoCSlice(arp *AutoReleasePool, x ...DeviceMemoryOpaqueCaptureAddressInfo) []DeviceMemoryOpaqueCaptureAddressInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceMemoryOpaqueCaptureAddressInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DeviceMemoryOpaqueCaptureAddressInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DeviceMemoryOpaqueCaptureAddressInfoFreeCSlice releases the memory allocated by DeviceMemoryOpaqueCaptureAddressInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceMemoryOpaqueCaptureAddressInfoFreeCSlice(x []DeviceMemoryOpaqueCaptureAddressInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceMemoryOpaqueCaptureAddressInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceMemoryOpaqueCaptureAddressInfoFreeCSlice must be called on the returned slice.
func DeviceMemoryOpaqueCaptureAddressInfoMakeCSlice(x ...DeviceMemoryOpaqueCaptureAddressInfo) []DeviceMemoryOpaqueCaptureAddressInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceMemoryOpaqueCaptureAddressInfo * len(x)
	dst := unsafe.Slice((*DeviceMemoryOpaqueCaptureAddressInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceMemoryOpaqueCaptureAddressInfo
func (x DeviceMemoryOpaqueCaptureAddressInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DeviceMemoryOpaqueCaptureAddressInfo with the value of
// SType to the value provided in the specification.
func (x DeviceMemoryOpaqueCaptureAddressInfo) WithDefaultSType() DeviceMemoryOpaqueCaptureAddressInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DeviceMemoryOpaqueCaptureAddressInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO)
}

// WithSType clones a new DeviceMemoryOpaqueCaptureAddressInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceMemoryOpaqueCaptureAddressInfo) WithSType(y StructureType) DeviceMemoryOpaqueCaptureAddressInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DeviceMemoryOpaqueCaptureAddressInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDeviceMemoryOpaqueCaptureAddressInfo
func (x DeviceMemoryOpaqueCaptureAddressInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DeviceMemoryOpaqueCaptureAddressInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceMemoryOpaqueCaptureAddressInfo) WithPNext(y unsafe.Pointer) DeviceMemoryOpaqueCaptureAddressInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DeviceMemoryOpaqueCaptureAddressInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Memory returns the value of memory from VkDeviceMemoryOpaqueCaptureAddressInfo
func (x DeviceMemoryOpaqueCaptureAddressInfo) Memory() DeviceMemory {
	ptr := /* handle */ (*DeviceMemory)(&x.memory)
	return *ptr
}

// WithMemory clones a new DeviceMemoryOpaqueCaptureAddressInfo with the value of
// Memory updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceMemoryOpaqueCaptureAddressInfo) WithMemory(y DeviceMemory) DeviceMemoryOpaqueCaptureAddressInfo {
	x.memory = *( /* handle */ (*C.VkDeviceMemory)(&y))
	return x
}
func (x *DeviceMemoryOpaqueCaptureAddressInfo) SetMemory(y DeviceMemory) {
	x.memory = *( /* handle */ (*C.VkDeviceMemory)(&y))
}

// SamplerReductionModeCreateInfo provides a go interface for VkSamplerReductionModeCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerReductionModeCreateInfo.html
type SamplerReductionModeCreateInfo C.struct_VkSamplerReductionModeCreateInfo

// SizeofSamplerReductionModeCreateInfo is the memory size of a SamplerReductionModeCreateInfo
var SizeofSamplerReductionModeCreateInfo int = int(unsafe.Sizeof(SamplerReductionModeCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SamplerReductionModeCreateInfo) ArpPtr(arp *AutoReleasePool) *SamplerReductionModeCreateInfo {
	ptr := newCBlock(cULong(SizeofSamplerReductionModeCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SamplerReductionModeCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SamplerReductionModeCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SamplerReductionModeCreateInfo) AsCPtr() *SamplerReductionModeCreateInfo {
	clone := (*SamplerReductionModeCreateInfo)(newCBlock(cULong(SizeofSamplerReductionModeCreateInfo)))
	*clone = x
	return clone
}

// SamplerReductionModeCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SamplerReductionModeCreateInfoCSlice(arp *AutoReleasePool, x ...SamplerReductionModeCreateInfo) []SamplerReductionModeCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSamplerReductionModeCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SamplerReductionModeCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SamplerReductionModeCreateInfoFreeCSlice releases the memory allocated by SamplerReductionModeCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SamplerReductionModeCreateInfoFreeCSlice(x []SamplerReductionModeCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SamplerReductionModeCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SamplerReductionModeCreateInfoFreeCSlice must be called on the returned slice.
func SamplerReductionModeCreateInfoMakeCSlice(x ...SamplerReductionModeCreateInfo) []SamplerReductionModeCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSamplerReductionModeCreateInfo * len(x)
	dst := unsafe.Slice((*SamplerReductionModeCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSamplerReductionModeCreateInfo
func (x SamplerReductionModeCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new SamplerReductionModeCreateInfo with the value of
// SType to the value provided in the specification.
func (x SamplerReductionModeCreateInfo) WithDefaultSType() SamplerReductionModeCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *SamplerReductionModeCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO)
}

// WithSType clones a new SamplerReductionModeCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerReductionModeCreateInfo) WithSType(y StructureType) SamplerReductionModeCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *SamplerReductionModeCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkSamplerReductionModeCreateInfo
func (x SamplerReductionModeCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new SamplerReductionModeCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerReductionModeCreateInfo) WithPNext(y unsafe.Pointer) SamplerReductionModeCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *SamplerReductionModeCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// ReductionMode returns the value of reductionMode from VkSamplerReductionModeCreateInfo
func (x SamplerReductionModeCreateInfo) ReductionMode() SamplerReductionMode {
	ptr := /* typedef */ (*SamplerReductionMode)(&x.reductionMode)
	return *ptr
}

// WithReductionMode clones a new SamplerReductionModeCreateInfo with the value of
// ReductionMode updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerReductionModeCreateInfo) WithReductionMode(y SamplerReductionMode) SamplerReductionModeCreateInfo {
	x.reductionMode = *( /* typedef */ (*C.VkSamplerReductionMode)(&y))
	return x
}
func (x *SamplerReductionModeCreateInfo) SetReductionMode(y SamplerReductionMode) {
	x.reductionMode = *( /* typedef */ (*C.VkSamplerReductionMode)(&y))
}

// PhysicalDeviceVulkan12Properties provides a go interface for VkPhysicalDeviceVulkan12Properties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Properties.html
type PhysicalDeviceVulkan12Properties C.struct_VkPhysicalDeviceVulkan12Properties

// SizeofPhysicalDeviceVulkan12Properties is the memory size of a PhysicalDeviceVulkan12Properties
var SizeofPhysicalDeviceVulkan12Properties int = int(unsafe.Sizeof(PhysicalDeviceVulkan12Properties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceVulkan12Properties) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceVulkan12Properties {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceVulkan12Properties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceVulkan12Properties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceVulkan12Properties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceVulkan12Properties) AsCPtr() *PhysicalDeviceVulkan12Properties {
	clone := (*PhysicalDeviceVulkan12Properties)(newCBlock(cULong(SizeofPhysicalDeviceVulkan12Properties)))
	*clone = x
	return clone
}

// PhysicalDeviceVulkan12PropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceVulkan12PropertiesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceVulkan12Properties) []PhysicalDeviceVulkan12Properties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVulkan12Properties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceVulkan12Properties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceVulkan12PropertiesFreeCSlice releases the memory allocated by PhysicalDeviceVulkan12PropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceVulkan12PropertiesFreeCSlice(x []PhysicalDeviceVulkan12Properties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceVulkan12PropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceVulkan12PropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceVulkan12PropertiesMakeCSlice(x ...PhysicalDeviceVulkan12Properties) []PhysicalDeviceVulkan12Properties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVulkan12Properties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceVulkan12Properties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceVulkan12Properties with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceVulkan12Properties) WithDefaultSType() PhysicalDeviceVulkan12Properties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceVulkan12Properties) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES)
}

// WithSType clones a new PhysicalDeviceVulkan12Properties with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Properties) WithSType(y StructureType) PhysicalDeviceVulkan12Properties {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Properties) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceVulkan12Properties with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Properties) WithPNext(y unsafe.Pointer) PhysicalDeviceVulkan12Properties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Properties) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// DriverID returns the value of driverID from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) DriverID() DriverId {
	ptr := /* typedef */ (*DriverId)(&x.driverID)
	return *ptr
}

// DriverName returns the value of driverName from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) DriverName() []byte {
	ptr := func(x *[VK_MAX_DRIVER_NAME_SIZE]C.char) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_DRIVER_NAME_SIZE)
		return &slc
	}(&x.driverName)
	return *ptr
}

// DriverInfo returns the value of driverInfo from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) DriverInfo() []byte {
	ptr := func(x *[VK_MAX_DRIVER_INFO_SIZE]C.char) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_DRIVER_INFO_SIZE)
		return &slc
	}(&x.driverInfo)
	return *ptr
}

// ConformanceVersion returns the value of conformanceVersion from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ConformanceVersion() ConformanceVersion {
	ptr := /* typedef */ (*ConformanceVersion)(&x.conformanceVersion)
	return *ptr
}

// DenormBehaviorIndependence returns the value of denormBehaviorIndependence from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) DenormBehaviorIndependence() ShaderFloatControlsIndependence {
	ptr := /* typedef */ (*ShaderFloatControlsIndependence)(&x.denormBehaviorIndependence)
	return *ptr
}

// RoundingModeIndependence returns the value of roundingModeIndependence from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) RoundingModeIndependence() ShaderFloatControlsIndependence {
	ptr := /* typedef */ (*ShaderFloatControlsIndependence)(&x.roundingModeIndependence)
	return *ptr
}

// ShaderSignedZeroInfNanPreserveFloat16 returns the value of shaderSignedZeroInfNanPreserveFloat16 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderSignedZeroInfNanPreserveFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSignedZeroInfNanPreserveFloat16)
	return *ptr
}

// ShaderSignedZeroInfNanPreserveFloat32 returns the value of shaderSignedZeroInfNanPreserveFloat32 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderSignedZeroInfNanPreserveFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSignedZeroInfNanPreserveFloat32)
	return *ptr
}

// ShaderSignedZeroInfNanPreserveFloat64 returns the value of shaderSignedZeroInfNanPreserveFloat64 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderSignedZeroInfNanPreserveFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSignedZeroInfNanPreserveFloat64)
	return *ptr
}

// ShaderDenormPreserveFloat16 returns the value of shaderDenormPreserveFloat16 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderDenormPreserveFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormPreserveFloat16)
	return *ptr
}

// ShaderDenormPreserveFloat32 returns the value of shaderDenormPreserveFloat32 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderDenormPreserveFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormPreserveFloat32)
	return *ptr
}

// ShaderDenormPreserveFloat64 returns the value of shaderDenormPreserveFloat64 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderDenormPreserveFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormPreserveFloat64)
	return *ptr
}

// ShaderDenormFlushToZeroFloat16 returns the value of shaderDenormFlushToZeroFloat16 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderDenormFlushToZeroFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormFlushToZeroFloat16)
	return *ptr
}

// ShaderDenormFlushToZeroFloat32 returns the value of shaderDenormFlushToZeroFloat32 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderDenormFlushToZeroFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormFlushToZeroFloat32)
	return *ptr
}

// ShaderDenormFlushToZeroFloat64 returns the value of shaderDenormFlushToZeroFloat64 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderDenormFlushToZeroFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormFlushToZeroFloat64)
	return *ptr
}

// ShaderRoundingModeRTEFloat16 returns the value of shaderRoundingModeRTEFloat16 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderRoundingModeRTEFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTEFloat16)
	return *ptr
}

// ShaderRoundingModeRTEFloat32 returns the value of shaderRoundingModeRTEFloat32 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderRoundingModeRTEFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTEFloat32)
	return *ptr
}

// ShaderRoundingModeRTEFloat64 returns the value of shaderRoundingModeRTEFloat64 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderRoundingModeRTEFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTEFloat64)
	return *ptr
}

// ShaderRoundingModeRTZFloat16 returns the value of shaderRoundingModeRTZFloat16 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderRoundingModeRTZFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTZFloat16)
	return *ptr
}

// ShaderRoundingModeRTZFloat32 returns the value of shaderRoundingModeRTZFloat32 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderRoundingModeRTZFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTZFloat32)
	return *ptr
}

// ShaderRoundingModeRTZFloat64 returns the value of shaderRoundingModeRTZFloat64 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderRoundingModeRTZFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTZFloat64)
	return *ptr
}

// MaxUpdateAfterBindDescriptorsInAllPools returns the value of maxUpdateAfterBindDescriptorsInAllPools from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxUpdateAfterBindDescriptorsInAllPools() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxUpdateAfterBindDescriptorsInAllPools)
	return *ptr
}

// ShaderUniformBufferArrayNonUniformIndexingNative returns the value of shaderUniformBufferArrayNonUniformIndexingNative from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderUniformBufferArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderUniformBufferArrayNonUniformIndexingNative)
	return *ptr
}

// ShaderSampledImageArrayNonUniformIndexingNative returns the value of shaderSampledImageArrayNonUniformIndexingNative from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderSampledImageArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSampledImageArrayNonUniformIndexingNative)
	return *ptr
}

// ShaderStorageBufferArrayNonUniformIndexingNative returns the value of shaderStorageBufferArrayNonUniformIndexingNative from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderStorageBufferArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageBufferArrayNonUniformIndexingNative)
	return *ptr
}

// ShaderStorageImageArrayNonUniformIndexingNative returns the value of shaderStorageImageArrayNonUniformIndexingNative from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderStorageImageArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageImageArrayNonUniformIndexingNative)
	return *ptr
}

// ShaderInputAttachmentArrayNonUniformIndexingNative returns the value of shaderInputAttachmentArrayNonUniformIndexingNative from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderInputAttachmentArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInputAttachmentArrayNonUniformIndexingNative)
	return *ptr
}

// RobustBufferAccessUpdateAfterBind returns the value of robustBufferAccessUpdateAfterBind from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) RobustBufferAccessUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.robustBufferAccessUpdateAfterBind)
	return *ptr
}

// QuadDivergentImplicitLod returns the value of quadDivergentImplicitLod from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) QuadDivergentImplicitLod() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.quadDivergentImplicitLod)
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindSamplers returns the value of maxPerStageDescriptorUpdateAfterBindSamplers from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxPerStageDescriptorUpdateAfterBindSamplers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindSamplers)
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindUniformBuffers returns the value of maxPerStageDescriptorUpdateAfterBindUniformBuffers from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxPerStageDescriptorUpdateAfterBindUniformBuffers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindUniformBuffers)
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindStorageBuffers returns the value of maxPerStageDescriptorUpdateAfterBindStorageBuffers from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxPerStageDescriptorUpdateAfterBindStorageBuffers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindStorageBuffers)
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindSampledImages returns the value of maxPerStageDescriptorUpdateAfterBindSampledImages from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxPerStageDescriptorUpdateAfterBindSampledImages() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindSampledImages)
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindStorageImages returns the value of maxPerStageDescriptorUpdateAfterBindStorageImages from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxPerStageDescriptorUpdateAfterBindStorageImages() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindStorageImages)
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindInputAttachments returns the value of maxPerStageDescriptorUpdateAfterBindInputAttachments from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxPerStageDescriptorUpdateAfterBindInputAttachments() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindInputAttachments)
	return *ptr
}

// MaxPerStageUpdateAfterBindResources returns the value of maxPerStageUpdateAfterBindResources from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxPerStageUpdateAfterBindResources() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageUpdateAfterBindResources)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindSamplers returns the value of maxDescriptorSetUpdateAfterBindSamplers from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxDescriptorSetUpdateAfterBindSamplers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindSamplers)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindUniformBuffers returns the value of maxDescriptorSetUpdateAfterBindUniformBuffers from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxDescriptorSetUpdateAfterBindUniformBuffers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindUniformBuffers)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic returns the value of maxDescriptorSetUpdateAfterBindUniformBuffersDynamic from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindStorageBuffers returns the value of maxDescriptorSetUpdateAfterBindStorageBuffers from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxDescriptorSetUpdateAfterBindStorageBuffers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindStorageBuffers)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic returns the value of maxDescriptorSetUpdateAfterBindStorageBuffersDynamic from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindSampledImages returns the value of maxDescriptorSetUpdateAfterBindSampledImages from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxDescriptorSetUpdateAfterBindSampledImages() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindSampledImages)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindStorageImages returns the value of maxDescriptorSetUpdateAfterBindStorageImages from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxDescriptorSetUpdateAfterBindStorageImages() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindStorageImages)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindInputAttachments returns the value of maxDescriptorSetUpdateAfterBindInputAttachments from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxDescriptorSetUpdateAfterBindInputAttachments() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindInputAttachments)
	return *ptr
}

// SupportedDepthResolveModes returns the value of supportedDepthResolveModes from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) SupportedDepthResolveModes() ResolveModeFlags {
	ptr := /* typedef */ (*ResolveModeFlags)(&x.supportedDepthResolveModes)
	return *ptr
}

// SupportedStencilResolveModes returns the value of supportedStencilResolveModes from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) SupportedStencilResolveModes() ResolveModeFlags {
	ptr := /* typedef */ (*ResolveModeFlags)(&x.supportedStencilResolveModes)
	return *ptr
}

// IndependentResolveNone returns the value of independentResolveNone from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) IndependentResolveNone() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.independentResolveNone)
	return *ptr
}

// IndependentResolve returns the value of independentResolve from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) IndependentResolve() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.independentResolve)
	return *ptr
}

// FilterMinmaxSingleComponentFormats returns the value of filterMinmaxSingleComponentFormats from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) FilterMinmaxSingleComponentFormats() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.filterMinmaxSingleComponentFormats)
	return *ptr
}

// FilterMinmaxImageComponentMapping returns the value of filterMinmaxImageComponentMapping from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) FilterMinmaxImageComponentMapping() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.filterMinmaxImageComponentMapping)
	return *ptr
}

// MaxTimelineSemaphoreValueDifference returns the value of maxTimelineSemaphoreValueDifference from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxTimelineSemaphoreValueDifference() uint64 {
	ptr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.maxTimelineSemaphoreValueDifference)
	return *ptr
}

// FramebufferIntegerColorSampleCounts returns the value of framebufferIntegerColorSampleCounts from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) FramebufferIntegerColorSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.framebufferIntegerColorSampleCounts)
	return *ptr
}

// ImageStencilUsageCreateInfo provides a go interface for VkImageStencilUsageCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageStencilUsageCreateInfo.html
type ImageStencilUsageCreateInfo C.struct_VkImageStencilUsageCreateInfo

// SizeofImageStencilUsageCreateInfo is the memory size of a ImageStencilUsageCreateInfo
var SizeofImageStencilUsageCreateInfo int = int(unsafe.Sizeof(ImageStencilUsageCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ImageStencilUsageCreateInfo) ArpPtr(arp *AutoReleasePool) *ImageStencilUsageCreateInfo {
	ptr := newCBlock(cULong(SizeofImageStencilUsageCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ImageStencilUsageCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageStencilUsageCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageStencilUsageCreateInfo) AsCPtr() *ImageStencilUsageCreateInfo {
	clone := (*ImageStencilUsageCreateInfo)(newCBlock(cULong(SizeofImageStencilUsageCreateInfo)))
	*clone = x
	return clone
}

// ImageStencilUsageCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ImageStencilUsageCreateInfoCSlice(arp *AutoReleasePool, x ...ImageStencilUsageCreateInfo) []ImageStencilUsageCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageStencilUsageCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ImageStencilUsageCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ImageStencilUsageCreateInfoFreeCSlice releases the memory allocated by ImageStencilUsageCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageStencilUsageCreateInfoFreeCSlice(x []ImageStencilUsageCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageStencilUsageCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageStencilUsageCreateInfoFreeCSlice must be called on the returned slice.
func ImageStencilUsageCreateInfoMakeCSlice(x ...ImageStencilUsageCreateInfo) []ImageStencilUsageCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageStencilUsageCreateInfo * len(x)
	dst := unsafe.Slice((*ImageStencilUsageCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageStencilUsageCreateInfo
func (x ImageStencilUsageCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ImageStencilUsageCreateInfo with the value of
// SType to the value provided in the specification.
func (x ImageStencilUsageCreateInfo) WithDefaultSType() ImageStencilUsageCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ImageStencilUsageCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO)
}

// WithSType clones a new ImageStencilUsageCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageStencilUsageCreateInfo) WithSType(y StructureType) ImageStencilUsageCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ImageStencilUsageCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkImageStencilUsageCreateInfo
func (x ImageStencilUsageCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ImageStencilUsageCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageStencilUsageCreateInfo) WithPNext(y unsafe.Pointer) ImageStencilUsageCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ImageStencilUsageCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// StencilUsage returns the value of stencilUsage from VkImageStencilUsageCreateInfo
func (x ImageStencilUsageCreateInfo) StencilUsage() ImageUsageFlags {
	ptr := /* typedef */ (*ImageUsageFlags)(&x.stencilUsage)
	return *ptr
}

// WithStencilUsage clones a new ImageStencilUsageCreateInfo with the value of
// StencilUsage updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageStencilUsageCreateInfo) WithStencilUsage(y ImageUsageFlags) ImageStencilUsageCreateInfo {
	x.stencilUsage = *( /* typedef */ (*C.VkImageUsageFlags)(&y))
	return x
}
func (x *ImageStencilUsageCreateInfo) SetStencilUsage(y ImageUsageFlags) {
	x.stencilUsage = *( /* typedef */ (*C.VkImageUsageFlags)(&y))
}

// PhysicalDeviceVulkan12Features provides a go interface for VkPhysicalDeviceVulkan12Features.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html
type PhysicalDeviceVulkan12Features C.struct_VkPhysicalDeviceVulkan12Features

// SizeofPhysicalDeviceVulkan12Features is the memory size of a PhysicalDeviceVulkan12Features
var SizeofPhysicalDeviceVulkan12Features int = int(unsafe.Sizeof(PhysicalDeviceVulkan12Features{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceVulkan12Features) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceVulkan12Features {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceVulkan12Features))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceVulkan12Features)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceVulkan12Features) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceVulkan12Features) AsCPtr() *PhysicalDeviceVulkan12Features {
	clone := (*PhysicalDeviceVulkan12Features)(newCBlock(cULong(SizeofPhysicalDeviceVulkan12Features)))
	*clone = x
	return clone
}

// PhysicalDeviceVulkan12FeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceVulkan12FeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceVulkan12Features) []PhysicalDeviceVulkan12Features {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVulkan12Features * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceVulkan12Features)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceVulkan12FeaturesFreeCSlice releases the memory allocated by PhysicalDeviceVulkan12FeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceVulkan12FeaturesFreeCSlice(x []PhysicalDeviceVulkan12Features) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceVulkan12FeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceVulkan12FeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceVulkan12FeaturesMakeCSlice(x ...PhysicalDeviceVulkan12Features) []PhysicalDeviceVulkan12Features {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVulkan12Features * len(x)
	dst := unsafe.Slice((*PhysicalDeviceVulkan12Features)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceVulkan12Features with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceVulkan12Features) WithDefaultSType() PhysicalDeviceVulkan12Features {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceVulkan12Features) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES)
}

// WithSType clones a new PhysicalDeviceVulkan12Features with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithSType(y StructureType) PhysicalDeviceVulkan12Features {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceVulkan12Features with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithPNext(y unsafe.Pointer) PhysicalDeviceVulkan12Features {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SamplerMirrorClampToEdge returns the value of samplerMirrorClampToEdge from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) SamplerMirrorClampToEdge() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.samplerMirrorClampToEdge)
	return *ptr
}

// WithSamplerMirrorClampToEdge clones a new PhysicalDeviceVulkan12Features with the value of
// SamplerMirrorClampToEdge updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithSamplerMirrorClampToEdge(y Bool32) PhysicalDeviceVulkan12Features {
	x.samplerMirrorClampToEdge = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetSamplerMirrorClampToEdge(y Bool32) {
	x.samplerMirrorClampToEdge = *( /* typedef */ (*C.VkBool32)(&y))
}

// DrawIndirectCount returns the value of drawIndirectCount from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DrawIndirectCount() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.drawIndirectCount)
	return *ptr
}

// WithDrawIndirectCount clones a new PhysicalDeviceVulkan12Features with the value of
// DrawIndirectCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDrawIndirectCount(y Bool32) PhysicalDeviceVulkan12Features {
	x.drawIndirectCount = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetDrawIndirectCount(y Bool32) {
	x.drawIndirectCount = *( /* typedef */ (*C.VkBool32)(&y))
}

// StorageBuffer8BitAccess returns the value of storageBuffer8BitAccess from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) StorageBuffer8BitAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storageBuffer8BitAccess)
	return *ptr
}

// WithStorageBuffer8BitAccess clones a new PhysicalDeviceVulkan12Features with the value of
// StorageBuffer8BitAccess updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithStorageBuffer8BitAccess(y Bool32) PhysicalDeviceVulkan12Features {
	x.storageBuffer8BitAccess = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetStorageBuffer8BitAccess(y Bool32) {
	x.storageBuffer8BitAccess = *( /* typedef */ (*C.VkBool32)(&y))
}

// UniformAndStorageBuffer8BitAccess returns the value of uniformAndStorageBuffer8BitAccess from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) UniformAndStorageBuffer8BitAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.uniformAndStorageBuffer8BitAccess)
	return *ptr
}

// WithUniformAndStorageBuffer8BitAccess clones a new PhysicalDeviceVulkan12Features with the value of
// UniformAndStorageBuffer8BitAccess updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithUniformAndStorageBuffer8BitAccess(y Bool32) PhysicalDeviceVulkan12Features {
	x.uniformAndStorageBuffer8BitAccess = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetUniformAndStorageBuffer8BitAccess(y Bool32) {
	x.uniformAndStorageBuffer8BitAccess = *( /* typedef */ (*C.VkBool32)(&y))
}

// StoragePushConstant8 returns the value of storagePushConstant8 from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) StoragePushConstant8() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storagePushConstant8)
	return *ptr
}

// WithStoragePushConstant8 clones a new PhysicalDeviceVulkan12Features with the value of
// StoragePushConstant8 updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithStoragePushConstant8(y Bool32) PhysicalDeviceVulkan12Features {
	x.storagePushConstant8 = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetStoragePushConstant8(y Bool32) {
	x.storagePushConstant8 = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderBufferInt64Atomics returns the value of shaderBufferInt64Atomics from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderBufferInt64Atomics() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderBufferInt64Atomics)
	return *ptr
}

// WithShaderBufferInt64Atomics clones a new PhysicalDeviceVulkan12Features with the value of
// ShaderBufferInt64Atomics updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderBufferInt64Atomics(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderBufferInt64Atomics = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetShaderBufferInt64Atomics(y Bool32) {
	x.shaderBufferInt64Atomics = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderSharedInt64Atomics returns the value of shaderSharedInt64Atomics from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderSharedInt64Atomics() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSharedInt64Atomics)
	return *ptr
}

// WithShaderSharedInt64Atomics clones a new PhysicalDeviceVulkan12Features with the value of
// ShaderSharedInt64Atomics updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderSharedInt64Atomics(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderSharedInt64Atomics = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetShaderSharedInt64Atomics(y Bool32) {
	x.shaderSharedInt64Atomics = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderFloat16 returns the value of shaderFloat16 from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderFloat16)
	return *ptr
}

// WithShaderFloat16 clones a new PhysicalDeviceVulkan12Features with the value of
// ShaderFloat16 updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderFloat16(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderFloat16 = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetShaderFloat16(y Bool32) {
	x.shaderFloat16 = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderInt8 returns the value of shaderInt8 from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderInt8() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInt8)
	return *ptr
}

// WithShaderInt8 clones a new PhysicalDeviceVulkan12Features with the value of
// ShaderInt8 updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderInt8(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderInt8 = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetShaderInt8(y Bool32) {
	x.shaderInt8 = *( /* typedef */ (*C.VkBool32)(&y))
}

// DescriptorIndexing returns the value of descriptorIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorIndexing)
	return *ptr
}

// WithDescriptorIndexing clones a new PhysicalDeviceVulkan12Features with the value of
// DescriptorIndexing updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	x.descriptorIndexing = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetDescriptorIndexing(y Bool32) {
	x.descriptorIndexing = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderInputAttachmentArrayDynamicIndexing returns the value of shaderInputAttachmentArrayDynamicIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderInputAttachmentArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInputAttachmentArrayDynamicIndexing)
	return *ptr
}

// WithShaderInputAttachmentArrayDynamicIndexing clones a new PhysicalDeviceVulkan12Features with the value of
// ShaderInputAttachmentArrayDynamicIndexing updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderInputAttachmentArrayDynamicIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderInputAttachmentArrayDynamicIndexing = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetShaderInputAttachmentArrayDynamicIndexing(y Bool32) {
	x.shaderInputAttachmentArrayDynamicIndexing = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderUniformTexelBufferArrayDynamicIndexing returns the value of shaderUniformTexelBufferArrayDynamicIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderUniformTexelBufferArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderUniformTexelBufferArrayDynamicIndexing)
	return *ptr
}

// WithShaderUniformTexelBufferArrayDynamicIndexing clones a new PhysicalDeviceVulkan12Features with the value of
// ShaderUniformTexelBufferArrayDynamicIndexing updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderUniformTexelBufferArrayDynamicIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderUniformTexelBufferArrayDynamicIndexing = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetShaderUniformTexelBufferArrayDynamicIndexing(y Bool32) {
	x.shaderUniformTexelBufferArrayDynamicIndexing = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderStorageTexelBufferArrayDynamicIndexing returns the value of shaderStorageTexelBufferArrayDynamicIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderStorageTexelBufferArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageTexelBufferArrayDynamicIndexing)
	return *ptr
}

// WithShaderStorageTexelBufferArrayDynamicIndexing clones a new PhysicalDeviceVulkan12Features with the value of
// ShaderStorageTexelBufferArrayDynamicIndexing updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderStorageTexelBufferArrayDynamicIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderStorageTexelBufferArrayDynamicIndexing = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetShaderStorageTexelBufferArrayDynamicIndexing(y Bool32) {
	x.shaderStorageTexelBufferArrayDynamicIndexing = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderUniformBufferArrayNonUniformIndexing returns the value of shaderUniformBufferArrayNonUniformIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderUniformBufferArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderUniformBufferArrayNonUniformIndexing)
	return *ptr
}

// WithShaderUniformBufferArrayNonUniformIndexing clones a new PhysicalDeviceVulkan12Features with the value of
// ShaderUniformBufferArrayNonUniformIndexing updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderUniformBufferArrayNonUniformIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderUniformBufferArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetShaderUniformBufferArrayNonUniformIndexing(y Bool32) {
	x.shaderUniformBufferArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderSampledImageArrayNonUniformIndexing returns the value of shaderSampledImageArrayNonUniformIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderSampledImageArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSampledImageArrayNonUniformIndexing)
	return *ptr
}

// WithShaderSampledImageArrayNonUniformIndexing clones a new PhysicalDeviceVulkan12Features with the value of
// ShaderSampledImageArrayNonUniformIndexing updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderSampledImageArrayNonUniformIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderSampledImageArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetShaderSampledImageArrayNonUniformIndexing(y Bool32) {
	x.shaderSampledImageArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderStorageBufferArrayNonUniformIndexing returns the value of shaderStorageBufferArrayNonUniformIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderStorageBufferArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageBufferArrayNonUniformIndexing)
	return *ptr
}

// WithShaderStorageBufferArrayNonUniformIndexing clones a new PhysicalDeviceVulkan12Features with the value of
// ShaderStorageBufferArrayNonUniformIndexing updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderStorageBufferArrayNonUniformIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderStorageBufferArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetShaderStorageBufferArrayNonUniformIndexing(y Bool32) {
	x.shaderStorageBufferArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderStorageImageArrayNonUniformIndexing returns the value of shaderStorageImageArrayNonUniformIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderStorageImageArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageImageArrayNonUniformIndexing)
	return *ptr
}

// WithShaderStorageImageArrayNonUniformIndexing clones a new PhysicalDeviceVulkan12Features with the value of
// ShaderStorageImageArrayNonUniformIndexing updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderStorageImageArrayNonUniformIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderStorageImageArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetShaderStorageImageArrayNonUniformIndexing(y Bool32) {
	x.shaderStorageImageArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderInputAttachmentArrayNonUniformIndexing returns the value of shaderInputAttachmentArrayNonUniformIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderInputAttachmentArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInputAttachmentArrayNonUniformIndexing)
	return *ptr
}

// WithShaderInputAttachmentArrayNonUniformIndexing clones a new PhysicalDeviceVulkan12Features with the value of
// ShaderInputAttachmentArrayNonUniformIndexing updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderInputAttachmentArrayNonUniformIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderInputAttachmentArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetShaderInputAttachmentArrayNonUniformIndexing(y Bool32) {
	x.shaderInputAttachmentArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderUniformTexelBufferArrayNonUniformIndexing returns the value of shaderUniformTexelBufferArrayNonUniformIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderUniformTexelBufferArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderUniformTexelBufferArrayNonUniformIndexing)
	return *ptr
}

// WithShaderUniformTexelBufferArrayNonUniformIndexing clones a new PhysicalDeviceVulkan12Features with the value of
// ShaderUniformTexelBufferArrayNonUniformIndexing updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderUniformTexelBufferArrayNonUniformIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderUniformTexelBufferArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetShaderUniformTexelBufferArrayNonUniformIndexing(y Bool32) {
	x.shaderUniformTexelBufferArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderStorageTexelBufferArrayNonUniformIndexing returns the value of shaderStorageTexelBufferArrayNonUniformIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderStorageTexelBufferArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageTexelBufferArrayNonUniformIndexing)
	return *ptr
}

// WithShaderStorageTexelBufferArrayNonUniformIndexing clones a new PhysicalDeviceVulkan12Features with the value of
// ShaderStorageTexelBufferArrayNonUniformIndexing updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderStorageTexelBufferArrayNonUniformIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderStorageTexelBufferArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetShaderStorageTexelBufferArrayNonUniformIndexing(y Bool32) {
	x.shaderStorageTexelBufferArrayNonUniformIndexing = *( /* typedef */ (*C.VkBool32)(&y))
}

// DescriptorBindingUniformBufferUpdateAfterBind returns the value of descriptorBindingUniformBufferUpdateAfterBind from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorBindingUniformBufferUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingUniformBufferUpdateAfterBind)
	return *ptr
}

// WithDescriptorBindingUniformBufferUpdateAfterBind clones a new PhysicalDeviceVulkan12Features with the value of
// DescriptorBindingUniformBufferUpdateAfterBind updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorBindingUniformBufferUpdateAfterBind(y Bool32) PhysicalDeviceVulkan12Features {
	x.descriptorBindingUniformBufferUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetDescriptorBindingUniformBufferUpdateAfterBind(y Bool32) {
	x.descriptorBindingUniformBufferUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
}

// DescriptorBindingSampledImageUpdateAfterBind returns the value of descriptorBindingSampledImageUpdateAfterBind from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorBindingSampledImageUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingSampledImageUpdateAfterBind)
	return *ptr
}

// WithDescriptorBindingSampledImageUpdateAfterBind clones a new PhysicalDeviceVulkan12Features with the value of
// DescriptorBindingSampledImageUpdateAfterBind updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorBindingSampledImageUpdateAfterBind(y Bool32) PhysicalDeviceVulkan12Features {
	x.descriptorBindingSampledImageUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetDescriptorBindingSampledImageUpdateAfterBind(y Bool32) {
	x.descriptorBindingSampledImageUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
}

// DescriptorBindingStorageImageUpdateAfterBind returns the value of descriptorBindingStorageImageUpdateAfterBind from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorBindingStorageImageUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingStorageImageUpdateAfterBind)
	return *ptr
}

// WithDescriptorBindingStorageImageUpdateAfterBind clones a new PhysicalDeviceVulkan12Features with the value of
// DescriptorBindingStorageImageUpdateAfterBind updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorBindingStorageImageUpdateAfterBind(y Bool32) PhysicalDeviceVulkan12Features {
	x.descriptorBindingStorageImageUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetDescriptorBindingStorageImageUpdateAfterBind(y Bool32) {
	x.descriptorBindingStorageImageUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
}

// DescriptorBindingStorageBufferUpdateAfterBind returns the value of descriptorBindingStorageBufferUpdateAfterBind from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorBindingStorageBufferUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingStorageBufferUpdateAfterBind)
	return *ptr
}

// WithDescriptorBindingStorageBufferUpdateAfterBind clones a new PhysicalDeviceVulkan12Features with the value of
// DescriptorBindingStorageBufferUpdateAfterBind updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorBindingStorageBufferUpdateAfterBind(y Bool32) PhysicalDeviceVulkan12Features {
	x.descriptorBindingStorageBufferUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetDescriptorBindingStorageBufferUpdateAfterBind(y Bool32) {
	x.descriptorBindingStorageBufferUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
}

// DescriptorBindingUniformTexelBufferUpdateAfterBind returns the value of descriptorBindingUniformTexelBufferUpdateAfterBind from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorBindingUniformTexelBufferUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingUniformTexelBufferUpdateAfterBind)
	return *ptr
}

// WithDescriptorBindingUniformTexelBufferUpdateAfterBind clones a new PhysicalDeviceVulkan12Features with the value of
// DescriptorBindingUniformTexelBufferUpdateAfterBind updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorBindingUniformTexelBufferUpdateAfterBind(y Bool32) PhysicalDeviceVulkan12Features {
	x.descriptorBindingUniformTexelBufferUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetDescriptorBindingUniformTexelBufferUpdateAfterBind(y Bool32) {
	x.descriptorBindingUniformTexelBufferUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
}

// DescriptorBindingStorageTexelBufferUpdateAfterBind returns the value of descriptorBindingStorageTexelBufferUpdateAfterBind from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorBindingStorageTexelBufferUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingStorageTexelBufferUpdateAfterBind)
	return *ptr
}

// WithDescriptorBindingStorageTexelBufferUpdateAfterBind clones a new PhysicalDeviceVulkan12Features with the value of
// DescriptorBindingStorageTexelBufferUpdateAfterBind updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorBindingStorageTexelBufferUpdateAfterBind(y Bool32) PhysicalDeviceVulkan12Features {
	x.descriptorBindingStorageTexelBufferUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetDescriptorBindingStorageTexelBufferUpdateAfterBind(y Bool32) {
	x.descriptorBindingStorageTexelBufferUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
}

// DescriptorBindingUpdateUnusedWhilePending returns the value of descriptorBindingUpdateUnusedWhilePending from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorBindingUpdateUnusedWhilePending() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingUpdateUnusedWhilePending)
	return *ptr
}

// WithDescriptorBindingUpdateUnusedWhilePending clones a new PhysicalDeviceVulkan12Features with the value of
// DescriptorBindingUpdateUnusedWhilePending updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorBindingUpdateUnusedWhilePending(y Bool32) PhysicalDeviceVulkan12Features {
	x.descriptorBindingUpdateUnusedWhilePending = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetDescriptorBindingUpdateUnusedWhilePending(y Bool32) {
	x.descriptorBindingUpdateUnusedWhilePending = *( /* typedef */ (*C.VkBool32)(&y))
}

// DescriptorBindingPartiallyBound returns the value of descriptorBindingPartiallyBound from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorBindingPartiallyBound() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingPartiallyBound)
	return *ptr
}

// WithDescriptorBindingPartiallyBound clones a new PhysicalDeviceVulkan12Features with the value of
// DescriptorBindingPartiallyBound updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorBindingPartiallyBound(y Bool32) PhysicalDeviceVulkan12Features {
	x.descriptorBindingPartiallyBound = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetDescriptorBindingPartiallyBound(y Bool32) {
	x.descriptorBindingPartiallyBound = *( /* typedef */ (*C.VkBool32)(&y))
}

// DescriptorBindingVariableDescriptorCount returns the value of descriptorBindingVariableDescriptorCount from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorBindingVariableDescriptorCount() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingVariableDescriptorCount)
	return *ptr
}

// WithDescriptorBindingVariableDescriptorCount clones a new PhysicalDeviceVulkan12Features with the value of
// DescriptorBindingVariableDescriptorCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorBindingVariableDescriptorCount(y Bool32) PhysicalDeviceVulkan12Features {
	x.descriptorBindingVariableDescriptorCount = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetDescriptorBindingVariableDescriptorCount(y Bool32) {
	x.descriptorBindingVariableDescriptorCount = *( /* typedef */ (*C.VkBool32)(&y))
}

// RuntimeDescriptorArray returns the value of runtimeDescriptorArray from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) RuntimeDescriptorArray() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.runtimeDescriptorArray)
	return *ptr
}

// WithRuntimeDescriptorArray clones a new PhysicalDeviceVulkan12Features with the value of
// RuntimeDescriptorArray updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithRuntimeDescriptorArray(y Bool32) PhysicalDeviceVulkan12Features {
	x.runtimeDescriptorArray = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetRuntimeDescriptorArray(y Bool32) {
	x.runtimeDescriptorArray = *( /* typedef */ (*C.VkBool32)(&y))
}

// SamplerFilterMinmax returns the value of samplerFilterMinmax from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) SamplerFilterMinmax() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.samplerFilterMinmax)
	return *ptr
}

// WithSamplerFilterMinmax clones a new PhysicalDeviceVulkan12Features with the value of
// SamplerFilterMinmax updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithSamplerFilterMinmax(y Bool32) PhysicalDeviceVulkan12Features {
	x.samplerFilterMinmax = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetSamplerFilterMinmax(y Bool32) {
	x.samplerFilterMinmax = *( /* typedef */ (*C.VkBool32)(&y))
}

// ScalarBlockLayout returns the value of scalarBlockLayout from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ScalarBlockLayout() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.scalarBlockLayout)
	return *ptr
}

// WithScalarBlockLayout clones a new PhysicalDeviceVulkan12Features with the value of
// ScalarBlockLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithScalarBlockLayout(y Bool32) PhysicalDeviceVulkan12Features {
	x.scalarBlockLayout = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetScalarBlockLayout(y Bool32) {
	x.scalarBlockLayout = *( /* typedef */ (*C.VkBool32)(&y))
}

// ImagelessFramebuffer returns the value of imagelessFramebuffer from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ImagelessFramebuffer() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.imagelessFramebuffer)
	return *ptr
}

// WithImagelessFramebuffer clones a new PhysicalDeviceVulkan12Features with the value of
// ImagelessFramebuffer updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithImagelessFramebuffer(y Bool32) PhysicalDeviceVulkan12Features {
	x.imagelessFramebuffer = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetImagelessFramebuffer(y Bool32) {
	x.imagelessFramebuffer = *( /* typedef */ (*C.VkBool32)(&y))
}

// UniformBufferStandardLayout returns the value of uniformBufferStandardLayout from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) UniformBufferStandardLayout() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.uniformBufferStandardLayout)
	return *ptr
}

// WithUniformBufferStandardLayout clones a new PhysicalDeviceVulkan12Features with the value of
// UniformBufferStandardLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithUniformBufferStandardLayout(y Bool32) PhysicalDeviceVulkan12Features {
	x.uniformBufferStandardLayout = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetUniformBufferStandardLayout(y Bool32) {
	x.uniformBufferStandardLayout = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderSubgroupExtendedTypes returns the value of shaderSubgroupExtendedTypes from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderSubgroupExtendedTypes() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSubgroupExtendedTypes)
	return *ptr
}

// WithShaderSubgroupExtendedTypes clones a new PhysicalDeviceVulkan12Features with the value of
// ShaderSubgroupExtendedTypes updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderSubgroupExtendedTypes(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderSubgroupExtendedTypes = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetShaderSubgroupExtendedTypes(y Bool32) {
	x.shaderSubgroupExtendedTypes = *( /* typedef */ (*C.VkBool32)(&y))
}

// SeparateDepthStencilLayouts returns the value of separateDepthStencilLayouts from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) SeparateDepthStencilLayouts() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.separateDepthStencilLayouts)
	return *ptr
}

// WithSeparateDepthStencilLayouts clones a new PhysicalDeviceVulkan12Features with the value of
// SeparateDepthStencilLayouts updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithSeparateDepthStencilLayouts(y Bool32) PhysicalDeviceVulkan12Features {
	x.separateDepthStencilLayouts = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetSeparateDepthStencilLayouts(y Bool32) {
	x.separateDepthStencilLayouts = *( /* typedef */ (*C.VkBool32)(&y))
}

// HostQueryReset returns the value of hostQueryReset from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) HostQueryReset() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.hostQueryReset)
	return *ptr
}

// WithHostQueryReset clones a new PhysicalDeviceVulkan12Features with the value of
// HostQueryReset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithHostQueryReset(y Bool32) PhysicalDeviceVulkan12Features {
	x.hostQueryReset = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetHostQueryReset(y Bool32) {
	x.hostQueryReset = *( /* typedef */ (*C.VkBool32)(&y))
}

// TimelineSemaphore returns the value of timelineSemaphore from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) TimelineSemaphore() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.timelineSemaphore)
	return *ptr
}

// WithTimelineSemaphore clones a new PhysicalDeviceVulkan12Features with the value of
// TimelineSemaphore updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithTimelineSemaphore(y Bool32) PhysicalDeviceVulkan12Features {
	x.timelineSemaphore = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetTimelineSemaphore(y Bool32) {
	x.timelineSemaphore = *( /* typedef */ (*C.VkBool32)(&y))
}

// BufferDeviceAddress returns the value of bufferDeviceAddress from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) BufferDeviceAddress() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.bufferDeviceAddress)
	return *ptr
}

// WithBufferDeviceAddress clones a new PhysicalDeviceVulkan12Features with the value of
// BufferDeviceAddress updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithBufferDeviceAddress(y Bool32) PhysicalDeviceVulkan12Features {
	x.bufferDeviceAddress = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetBufferDeviceAddress(y Bool32) {
	x.bufferDeviceAddress = *( /* typedef */ (*C.VkBool32)(&y))
}

// BufferDeviceAddressCaptureReplay returns the value of bufferDeviceAddressCaptureReplay from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) BufferDeviceAddressCaptureReplay() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.bufferDeviceAddressCaptureReplay)
	return *ptr
}

// WithBufferDeviceAddressCaptureReplay clones a new PhysicalDeviceVulkan12Features with the value of
// BufferDeviceAddressCaptureReplay updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithBufferDeviceAddressCaptureReplay(y Bool32) PhysicalDeviceVulkan12Features {
	x.bufferDeviceAddressCaptureReplay = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetBufferDeviceAddressCaptureReplay(y Bool32) {
	x.bufferDeviceAddressCaptureReplay = *( /* typedef */ (*C.VkBool32)(&y))
}

// BufferDeviceAddressMultiDevice returns the value of bufferDeviceAddressMultiDevice from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) BufferDeviceAddressMultiDevice() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.bufferDeviceAddressMultiDevice)
	return *ptr
}

// WithBufferDeviceAddressMultiDevice clones a new PhysicalDeviceVulkan12Features with the value of
// BufferDeviceAddressMultiDevice updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithBufferDeviceAddressMultiDevice(y Bool32) PhysicalDeviceVulkan12Features {
	x.bufferDeviceAddressMultiDevice = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetBufferDeviceAddressMultiDevice(y Bool32) {
	x.bufferDeviceAddressMultiDevice = *( /* typedef */ (*C.VkBool32)(&y))
}

// VulkanMemoryModel returns the value of vulkanMemoryModel from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) VulkanMemoryModel() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.vulkanMemoryModel)
	return *ptr
}

// WithVulkanMemoryModel clones a new PhysicalDeviceVulkan12Features with the value of
// VulkanMemoryModel updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithVulkanMemoryModel(y Bool32) PhysicalDeviceVulkan12Features {
	x.vulkanMemoryModel = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetVulkanMemoryModel(y Bool32) {
	x.vulkanMemoryModel = *( /* typedef */ (*C.VkBool32)(&y))
}

// VulkanMemoryModelDeviceScope returns the value of vulkanMemoryModelDeviceScope from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) VulkanMemoryModelDeviceScope() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.vulkanMemoryModelDeviceScope)
	return *ptr
}

// WithVulkanMemoryModelDeviceScope clones a new PhysicalDeviceVulkan12Features with the value of
// VulkanMemoryModelDeviceScope updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithVulkanMemoryModelDeviceScope(y Bool32) PhysicalDeviceVulkan12Features {
	x.vulkanMemoryModelDeviceScope = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetVulkanMemoryModelDeviceScope(y Bool32) {
	x.vulkanMemoryModelDeviceScope = *( /* typedef */ (*C.VkBool32)(&y))
}

// VulkanMemoryModelAvailabilityVisibilityChains returns the value of vulkanMemoryModelAvailabilityVisibilityChains from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) VulkanMemoryModelAvailabilityVisibilityChains() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.vulkanMemoryModelAvailabilityVisibilityChains)
	return *ptr
}

// WithVulkanMemoryModelAvailabilityVisibilityChains clones a new PhysicalDeviceVulkan12Features with the value of
// VulkanMemoryModelAvailabilityVisibilityChains updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithVulkanMemoryModelAvailabilityVisibilityChains(y Bool32) PhysicalDeviceVulkan12Features {
	x.vulkanMemoryModelAvailabilityVisibilityChains = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetVulkanMemoryModelAvailabilityVisibilityChains(y Bool32) {
	x.vulkanMemoryModelAvailabilityVisibilityChains = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderOutputViewportIndex returns the value of shaderOutputViewportIndex from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderOutputViewportIndex() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderOutputViewportIndex)
	return *ptr
}

// WithShaderOutputViewportIndex clones a new PhysicalDeviceVulkan12Features with the value of
// ShaderOutputViewportIndex updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderOutputViewportIndex(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderOutputViewportIndex = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetShaderOutputViewportIndex(y Bool32) {
	x.shaderOutputViewportIndex = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderOutputLayer returns the value of shaderOutputLayer from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderOutputLayer() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderOutputLayer)
	return *ptr
}

// WithShaderOutputLayer clones a new PhysicalDeviceVulkan12Features with the value of
// ShaderOutputLayer updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderOutputLayer(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderOutputLayer = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetShaderOutputLayer(y Bool32) {
	x.shaderOutputLayer = *( /* typedef */ (*C.VkBool32)(&y))
}

// SubgroupBroadcastDynamicId returns the value of subgroupBroadcastDynamicId from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) SubgroupBroadcastDynamicId() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.subgroupBroadcastDynamicId)
	return *ptr
}

// WithSubgroupBroadcastDynamicId clones a new PhysicalDeviceVulkan12Features with the value of
// SubgroupBroadcastDynamicId updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithSubgroupBroadcastDynamicId(y Bool32) PhysicalDeviceVulkan12Features {
	x.subgroupBroadcastDynamicId = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan12Features) SetSubgroupBroadcastDynamicId(y Bool32) {
	x.subgroupBroadcastDynamicId = *( /* typedef */ (*C.VkBool32)(&y))
}

// PhysicalDeviceScalarBlockLayoutFeatures provides a go interface for VkPhysicalDeviceScalarBlockLayoutFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceScalarBlockLayoutFeatures.html
type PhysicalDeviceScalarBlockLayoutFeatures C.struct_VkPhysicalDeviceScalarBlockLayoutFeatures

// SizeofPhysicalDeviceScalarBlockLayoutFeatures is the memory size of a PhysicalDeviceScalarBlockLayoutFeatures
var SizeofPhysicalDeviceScalarBlockLayoutFeatures int = int(unsafe.Sizeof(PhysicalDeviceScalarBlockLayoutFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceScalarBlockLayoutFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceScalarBlockLayoutFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceScalarBlockLayoutFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceScalarBlockLayoutFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceScalarBlockLayoutFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceScalarBlockLayoutFeatures) AsCPtr() *PhysicalDeviceScalarBlockLayoutFeatures {
	clone := (*PhysicalDeviceScalarBlockLayoutFeatures)(newCBlock(cULong(SizeofPhysicalDeviceScalarBlockLayoutFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceScalarBlockLayoutFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceScalarBlockLayoutFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceScalarBlockLayoutFeatures) []PhysicalDeviceScalarBlockLayoutFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceScalarBlockLayoutFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceScalarBlockLayoutFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceScalarBlockLayoutFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceScalarBlockLayoutFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceScalarBlockLayoutFeaturesFreeCSlice(x []PhysicalDeviceScalarBlockLayoutFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceScalarBlockLayoutFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceScalarBlockLayoutFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceScalarBlockLayoutFeaturesMakeCSlice(x ...PhysicalDeviceScalarBlockLayoutFeatures) []PhysicalDeviceScalarBlockLayoutFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceScalarBlockLayoutFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceScalarBlockLayoutFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceScalarBlockLayoutFeatures
func (x PhysicalDeviceScalarBlockLayoutFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceScalarBlockLayoutFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceScalarBlockLayoutFeatures) WithDefaultSType() PhysicalDeviceScalarBlockLayoutFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceScalarBlockLayoutFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES)
}

// WithSType clones a new PhysicalDeviceScalarBlockLayoutFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceScalarBlockLayoutFeatures) WithSType(y StructureType) PhysicalDeviceScalarBlockLayoutFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceScalarBlockLayoutFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceScalarBlockLayoutFeatures
func (x PhysicalDeviceScalarBlockLayoutFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceScalarBlockLayoutFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceScalarBlockLayoutFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceScalarBlockLayoutFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceScalarBlockLayoutFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// ScalarBlockLayout returns the value of scalarBlockLayout from VkPhysicalDeviceScalarBlockLayoutFeatures
func (x PhysicalDeviceScalarBlockLayoutFeatures) ScalarBlockLayout() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.scalarBlockLayout)
	return *ptr
}

// WithScalarBlockLayout clones a new PhysicalDeviceScalarBlockLayoutFeatures with the value of
// ScalarBlockLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceScalarBlockLayoutFeatures) WithScalarBlockLayout(y Bool32) PhysicalDeviceScalarBlockLayoutFeatures {
	x.scalarBlockLayout = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceScalarBlockLayoutFeatures) SetScalarBlockLayout(y Bool32) {
	x.scalarBlockLayout = *( /* typedef */ (*C.VkBool32)(&y))
}

// PhysicalDeviceVulkan11Properties provides a go interface for VkPhysicalDeviceVulkan11Properties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan11Properties.html
type PhysicalDeviceVulkan11Properties C.struct_VkPhysicalDeviceVulkan11Properties

// SizeofPhysicalDeviceVulkan11Properties is the memory size of a PhysicalDeviceVulkan11Properties
var SizeofPhysicalDeviceVulkan11Properties int = int(unsafe.Sizeof(PhysicalDeviceVulkan11Properties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceVulkan11Properties) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceVulkan11Properties {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceVulkan11Properties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceVulkan11Properties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceVulkan11Properties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceVulkan11Properties) AsCPtr() *PhysicalDeviceVulkan11Properties {
	clone := (*PhysicalDeviceVulkan11Properties)(newCBlock(cULong(SizeofPhysicalDeviceVulkan11Properties)))
	*clone = x
	return clone
}

// PhysicalDeviceVulkan11PropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceVulkan11PropertiesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceVulkan11Properties) []PhysicalDeviceVulkan11Properties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVulkan11Properties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceVulkan11Properties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceVulkan11PropertiesFreeCSlice releases the memory allocated by PhysicalDeviceVulkan11PropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceVulkan11PropertiesFreeCSlice(x []PhysicalDeviceVulkan11Properties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceVulkan11PropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceVulkan11PropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceVulkan11PropertiesMakeCSlice(x ...PhysicalDeviceVulkan11Properties) []PhysicalDeviceVulkan11Properties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVulkan11Properties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceVulkan11Properties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceVulkan11Properties with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceVulkan11Properties) WithDefaultSType() PhysicalDeviceVulkan11Properties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceVulkan11Properties) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES)
}

// WithSType clones a new PhysicalDeviceVulkan11Properties with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Properties) WithSType(y StructureType) PhysicalDeviceVulkan11Properties {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceVulkan11Properties) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceVulkan11Properties with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Properties) WithPNext(y unsafe.Pointer) PhysicalDeviceVulkan11Properties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceVulkan11Properties) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// DeviceUUID returns the value of deviceUUID from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) DeviceUUID() []byte {
	ptr := func(x *[VK_UUID_SIZE]C.uint8_t) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_UUID_SIZE)
		return &slc
	}(&x.deviceUUID)
	return *ptr
}

// DriverUUID returns the value of driverUUID from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) DriverUUID() []byte {
	ptr := func(x *[VK_UUID_SIZE]C.uint8_t) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_UUID_SIZE)
		return &slc
	}(&x.driverUUID)
	return *ptr
}

// DeviceLUID returns the value of deviceLUID from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) DeviceLUID() []byte {
	ptr := func(x *[VK_LUID_SIZE]C.uint8_t) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_LUID_SIZE)
		return &slc
	}(&x.deviceLUID)
	return *ptr
}

// DeviceNodeMask returns the value of deviceNodeMask from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) DeviceNodeMask() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.deviceNodeMask)
	return *ptr
}

// DeviceLUIDValid returns the value of deviceLUIDValid from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) DeviceLUIDValid() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.deviceLUIDValid)
	return *ptr
}

// SubgroupSize returns the value of subgroupSize from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) SubgroupSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.subgroupSize)
	return *ptr
}

// SubgroupSupportedStages returns the value of subgroupSupportedStages from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) SubgroupSupportedStages() ShaderStageFlags {
	ptr := /* typedef */ (*ShaderStageFlags)(&x.subgroupSupportedStages)
	return *ptr
}

// SubgroupSupportedOperations returns the value of subgroupSupportedOperations from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) SubgroupSupportedOperations() SubgroupFeatureFlags {
	ptr := /* typedef */ (*SubgroupFeatureFlags)(&x.subgroupSupportedOperations)
	return *ptr
}

// SubgroupQuadOperationsInAllStages returns the value of subgroupQuadOperationsInAllStages from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) SubgroupQuadOperationsInAllStages() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.subgroupQuadOperationsInAllStages)
	return *ptr
}

// PointClippingBehavior returns the value of pointClippingBehavior from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) PointClippingBehavior() PointClippingBehavior {
	ptr := /* typedef */ (*PointClippingBehavior)(&x.pointClippingBehavior)
	return *ptr
}

// MaxMultiviewViewCount returns the value of maxMultiviewViewCount from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) MaxMultiviewViewCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxMultiviewViewCount)
	return *ptr
}

// MaxMultiviewInstanceIndex returns the value of maxMultiviewInstanceIndex from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) MaxMultiviewInstanceIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxMultiviewInstanceIndex)
	return *ptr
}

// ProtectedNoFault returns the value of protectedNoFault from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) ProtectedNoFault() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.protectedNoFault)
	return *ptr
}

// MaxPerSetDescriptors returns the value of maxPerSetDescriptors from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) MaxPerSetDescriptors() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerSetDescriptors)
	return *ptr
}

// MaxMemoryAllocationSize returns the value of maxMemoryAllocationSize from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) MaxMemoryAllocationSize() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.maxMemoryAllocationSize)
	return *ptr
}

// PhysicalDeviceVulkan11Features provides a go interface for VkPhysicalDeviceVulkan11Features.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan11Features.html
type PhysicalDeviceVulkan11Features C.struct_VkPhysicalDeviceVulkan11Features

// SizeofPhysicalDeviceVulkan11Features is the memory size of a PhysicalDeviceVulkan11Features
var SizeofPhysicalDeviceVulkan11Features int = int(unsafe.Sizeof(PhysicalDeviceVulkan11Features{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceVulkan11Features) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceVulkan11Features {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceVulkan11Features))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceVulkan11Features)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceVulkan11Features) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceVulkan11Features) AsCPtr() *PhysicalDeviceVulkan11Features {
	clone := (*PhysicalDeviceVulkan11Features)(newCBlock(cULong(SizeofPhysicalDeviceVulkan11Features)))
	*clone = x
	return clone
}

// PhysicalDeviceVulkan11FeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceVulkan11FeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceVulkan11Features) []PhysicalDeviceVulkan11Features {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVulkan11Features * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceVulkan11Features)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceVulkan11FeaturesFreeCSlice releases the memory allocated by PhysicalDeviceVulkan11FeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceVulkan11FeaturesFreeCSlice(x []PhysicalDeviceVulkan11Features) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceVulkan11FeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceVulkan11FeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceVulkan11FeaturesMakeCSlice(x ...PhysicalDeviceVulkan11Features) []PhysicalDeviceVulkan11Features {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVulkan11Features * len(x)
	dst := unsafe.Slice((*PhysicalDeviceVulkan11Features)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceVulkan11Features with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceVulkan11Features) WithDefaultSType() PhysicalDeviceVulkan11Features {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceVulkan11Features) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES)
}

// WithSType clones a new PhysicalDeviceVulkan11Features with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithSType(y StructureType) PhysicalDeviceVulkan11Features {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceVulkan11Features) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceVulkan11Features with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithPNext(y unsafe.Pointer) PhysicalDeviceVulkan11Features {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceVulkan11Features) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// StorageBuffer16BitAccess returns the value of storageBuffer16BitAccess from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) StorageBuffer16BitAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storageBuffer16BitAccess)
	return *ptr
}

// WithStorageBuffer16BitAccess clones a new PhysicalDeviceVulkan11Features with the value of
// StorageBuffer16BitAccess updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithStorageBuffer16BitAccess(y Bool32) PhysicalDeviceVulkan11Features {
	x.storageBuffer16BitAccess = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan11Features) SetStorageBuffer16BitAccess(y Bool32) {
	x.storageBuffer16BitAccess = *( /* typedef */ (*C.VkBool32)(&y))
}

// UniformAndStorageBuffer16BitAccess returns the value of uniformAndStorageBuffer16BitAccess from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) UniformAndStorageBuffer16BitAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.uniformAndStorageBuffer16BitAccess)
	return *ptr
}

// WithUniformAndStorageBuffer16BitAccess clones a new PhysicalDeviceVulkan11Features with the value of
// UniformAndStorageBuffer16BitAccess updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithUniformAndStorageBuffer16BitAccess(y Bool32) PhysicalDeviceVulkan11Features {
	x.uniformAndStorageBuffer16BitAccess = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan11Features) SetUniformAndStorageBuffer16BitAccess(y Bool32) {
	x.uniformAndStorageBuffer16BitAccess = *( /* typedef */ (*C.VkBool32)(&y))
}

// StoragePushConstant16 returns the value of storagePushConstant16 from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) StoragePushConstant16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storagePushConstant16)
	return *ptr
}

// WithStoragePushConstant16 clones a new PhysicalDeviceVulkan11Features with the value of
// StoragePushConstant16 updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithStoragePushConstant16(y Bool32) PhysicalDeviceVulkan11Features {
	x.storagePushConstant16 = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan11Features) SetStoragePushConstant16(y Bool32) {
	x.storagePushConstant16 = *( /* typedef */ (*C.VkBool32)(&y))
}

// StorageInputOutput16 returns the value of storageInputOutput16 from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) StorageInputOutput16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storageInputOutput16)
	return *ptr
}

// WithStorageInputOutput16 clones a new PhysicalDeviceVulkan11Features with the value of
// StorageInputOutput16 updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithStorageInputOutput16(y Bool32) PhysicalDeviceVulkan11Features {
	x.storageInputOutput16 = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan11Features) SetStorageInputOutput16(y Bool32) {
	x.storageInputOutput16 = *( /* typedef */ (*C.VkBool32)(&y))
}

// Multiview returns the value of multiview from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) Multiview() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.multiview)
	return *ptr
}

// WithMultiview clones a new PhysicalDeviceVulkan11Features with the value of
// Multiview updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithMultiview(y Bool32) PhysicalDeviceVulkan11Features {
	x.multiview = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan11Features) SetMultiview(y Bool32) {
	x.multiview = *( /* typedef */ (*C.VkBool32)(&y))
}

// MultiviewGeometryShader returns the value of multiviewGeometryShader from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) MultiviewGeometryShader() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.multiviewGeometryShader)
	return *ptr
}

// WithMultiviewGeometryShader clones a new PhysicalDeviceVulkan11Features with the value of
// MultiviewGeometryShader updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithMultiviewGeometryShader(y Bool32) PhysicalDeviceVulkan11Features {
	x.multiviewGeometryShader = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan11Features) SetMultiviewGeometryShader(y Bool32) {
	x.multiviewGeometryShader = *( /* typedef */ (*C.VkBool32)(&y))
}

// MultiviewTessellationShader returns the value of multiviewTessellationShader from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) MultiviewTessellationShader() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.multiviewTessellationShader)
	return *ptr
}

// WithMultiviewTessellationShader clones a new PhysicalDeviceVulkan11Features with the value of
// MultiviewTessellationShader updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithMultiviewTessellationShader(y Bool32) PhysicalDeviceVulkan11Features {
	x.multiviewTessellationShader = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan11Features) SetMultiviewTessellationShader(y Bool32) {
	x.multiviewTessellationShader = *( /* typedef */ (*C.VkBool32)(&y))
}

// VariablePointersStorageBuffer returns the value of variablePointersStorageBuffer from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) VariablePointersStorageBuffer() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.variablePointersStorageBuffer)
	return *ptr
}

// WithVariablePointersStorageBuffer clones a new PhysicalDeviceVulkan11Features with the value of
// VariablePointersStorageBuffer updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithVariablePointersStorageBuffer(y Bool32) PhysicalDeviceVulkan11Features {
	x.variablePointersStorageBuffer = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan11Features) SetVariablePointersStorageBuffer(y Bool32) {
	x.variablePointersStorageBuffer = *( /* typedef */ (*C.VkBool32)(&y))
}

// VariablePointers returns the value of variablePointers from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) VariablePointers() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.variablePointers)
	return *ptr
}

// WithVariablePointers clones a new PhysicalDeviceVulkan11Features with the value of
// VariablePointers updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithVariablePointers(y Bool32) PhysicalDeviceVulkan11Features {
	x.variablePointers = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan11Features) SetVariablePointers(y Bool32) {
	x.variablePointers = *( /* typedef */ (*C.VkBool32)(&y))
}

// ProtectedMemory returns the value of protectedMemory from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) ProtectedMemory() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.protectedMemory)
	return *ptr
}

// WithProtectedMemory clones a new PhysicalDeviceVulkan11Features with the value of
// ProtectedMemory updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithProtectedMemory(y Bool32) PhysicalDeviceVulkan11Features {
	x.protectedMemory = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan11Features) SetProtectedMemory(y Bool32) {
	x.protectedMemory = *( /* typedef */ (*C.VkBool32)(&y))
}

// SamplerYcbcrConversion returns the value of samplerYcbcrConversion from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) SamplerYcbcrConversion() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.samplerYcbcrConversion)
	return *ptr
}

// WithSamplerYcbcrConversion clones a new PhysicalDeviceVulkan11Features with the value of
// SamplerYcbcrConversion updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithSamplerYcbcrConversion(y Bool32) PhysicalDeviceVulkan11Features {
	x.samplerYcbcrConversion = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan11Features) SetSamplerYcbcrConversion(y Bool32) {
	x.samplerYcbcrConversion = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderDrawParameters returns the value of shaderDrawParameters from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) ShaderDrawParameters() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDrawParameters)
	return *ptr
}

// WithShaderDrawParameters clones a new PhysicalDeviceVulkan11Features with the value of
// ShaderDrawParameters updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithShaderDrawParameters(y Bool32) PhysicalDeviceVulkan11Features {
	x.shaderDrawParameters = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan11Features) SetShaderDrawParameters(y Bool32) {
	x.shaderDrawParameters = *( /* typedef */ (*C.VkBool32)(&y))
}

// PhysicalDeviceDepthStencilResolveProperties provides a go interface for VkPhysicalDeviceDepthStencilResolveProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDepthStencilResolveProperties.html
type PhysicalDeviceDepthStencilResolveProperties C.struct_VkPhysicalDeviceDepthStencilResolveProperties

// SizeofPhysicalDeviceDepthStencilResolveProperties is the memory size of a PhysicalDeviceDepthStencilResolveProperties
var SizeofPhysicalDeviceDepthStencilResolveProperties int = int(unsafe.Sizeof(PhysicalDeviceDepthStencilResolveProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceDepthStencilResolveProperties) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceDepthStencilResolveProperties {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceDepthStencilResolveProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceDepthStencilResolveProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceDepthStencilResolveProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceDepthStencilResolveProperties) AsCPtr() *PhysicalDeviceDepthStencilResolveProperties {
	clone := (*PhysicalDeviceDepthStencilResolveProperties)(newCBlock(cULong(SizeofPhysicalDeviceDepthStencilResolveProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceDepthStencilResolvePropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceDepthStencilResolvePropertiesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceDepthStencilResolveProperties) []PhysicalDeviceDepthStencilResolveProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceDepthStencilResolveProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceDepthStencilResolveProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceDepthStencilResolvePropertiesFreeCSlice releases the memory allocated by PhysicalDeviceDepthStencilResolvePropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceDepthStencilResolvePropertiesFreeCSlice(x []PhysicalDeviceDepthStencilResolveProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceDepthStencilResolvePropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceDepthStencilResolvePropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceDepthStencilResolvePropertiesMakeCSlice(x ...PhysicalDeviceDepthStencilResolveProperties) []PhysicalDeviceDepthStencilResolveProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceDepthStencilResolveProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceDepthStencilResolveProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceDepthStencilResolveProperties
func (x PhysicalDeviceDepthStencilResolveProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceDepthStencilResolveProperties with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceDepthStencilResolveProperties) WithDefaultSType() PhysicalDeviceDepthStencilResolveProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceDepthStencilResolveProperties) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES)
}

// WithSType clones a new PhysicalDeviceDepthStencilResolveProperties with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDepthStencilResolveProperties) WithSType(y StructureType) PhysicalDeviceDepthStencilResolveProperties {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceDepthStencilResolveProperties) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceDepthStencilResolveProperties
func (x PhysicalDeviceDepthStencilResolveProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceDepthStencilResolveProperties with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDepthStencilResolveProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceDepthStencilResolveProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceDepthStencilResolveProperties) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SupportedDepthResolveModes returns the value of supportedDepthResolveModes from VkPhysicalDeviceDepthStencilResolveProperties
func (x PhysicalDeviceDepthStencilResolveProperties) SupportedDepthResolveModes() ResolveModeFlags {
	ptr := /* typedef */ (*ResolveModeFlags)(&x.supportedDepthResolveModes)
	return *ptr
}

// SupportedStencilResolveModes returns the value of supportedStencilResolveModes from VkPhysicalDeviceDepthStencilResolveProperties
func (x PhysicalDeviceDepthStencilResolveProperties) SupportedStencilResolveModes() ResolveModeFlags {
	ptr := /* typedef */ (*ResolveModeFlags)(&x.supportedStencilResolveModes)
	return *ptr
}

// IndependentResolveNone returns the value of independentResolveNone from VkPhysicalDeviceDepthStencilResolveProperties
func (x PhysicalDeviceDepthStencilResolveProperties) IndependentResolveNone() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.independentResolveNone)
	return *ptr
}

// IndependentResolve returns the value of independentResolve from VkPhysicalDeviceDepthStencilResolveProperties
func (x PhysicalDeviceDepthStencilResolveProperties) IndependentResolve() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.independentResolve)
	return *ptr
}

// CmdBeginRenderPass2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass2.html
func (x CommandBufferFacade) CmdBeginRenderPass2(pRenderPassBegin *RenderPassBeginInfo, pSubpassBeginInfo *SubpassBeginInfo) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **RenderPassBeginInfo) **C.struct_VkRenderPassBeginInfo { /* Pointer */
		g2c := (*C.struct_VkRenderPassBeginInfo)(*x)
		return &g2c
	}(&pRenderPassBegin)
	p2 := func(x **SubpassBeginInfo) **C.struct_VkSubpassBeginInfo { /* Pointer */
		g2c := (*C.struct_VkSubpassBeginInfo)(*x)
		return &g2c
	}(&pSubpassBeginInfo)
	C.vkCmdBeginRenderPass2(addrs, *p0, *p1, *p2)
}

// GetBufferOpaqueCaptureAddress command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferOpaqueCaptureAddress.html
func (x DeviceFacade) GetBufferOpaqueCaptureAddress(pInfo *BufferDeviceAddressInfo) uint64 {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **BufferDeviceAddressInfo) **C.struct_VkBufferDeviceAddressInfo { /* Pointer */
		g2c := (*C.struct_VkBufferDeviceAddressInfo)(*x)
		return &g2c
	}(&pInfo)
	ret := C.vkGetBufferOpaqueCaptureAddress(addrs, *p0, *p1)
	retPtr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&ret)
	return *retPtr
}

// GetBufferDeviceAddress command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferDeviceAddress.html
func (x DeviceFacade) GetBufferDeviceAddress(pInfo *BufferDeviceAddressInfo) DeviceAddress {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **BufferDeviceAddressInfo) **C.struct_VkBufferDeviceAddressInfo { /* Pointer */
		g2c := (*C.struct_VkBufferDeviceAddressInfo)(*x)
		return &g2c
	}(&pInfo)
	ret := C.vkGetBufferDeviceAddress(addrs, *p0, *p1)
	retPtr := /* typedef */ (*DeviceAddress)(&ret)
	return *retPtr
}

// CmdDrawIndirectCount command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndirectCount.html
func (x CommandBufferFacade) CmdDrawIndirectCount(buffer Buffer, offset DeviceSize, countBuffer Buffer, countBufferOffset DeviceSize, maxDrawCount uint32, stride uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&buffer)
	p2 := /* typedef */ (*C.VkDeviceSize)(&offset)
	p3 := /* handle */ (*C.VkBuffer)(&countBuffer)
	p4 := /* typedef */ (*C.VkDeviceSize)(&countBufferOffset)
	p5 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&maxDrawCount)
	p6 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&stride)
	C.vkCmdDrawIndirectCount(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6)
}

// CmdDrawIndexedIndirectCount command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndexedIndirectCount.html
func (x CommandBufferFacade) CmdDrawIndexedIndirectCount(buffer Buffer, offset DeviceSize, countBuffer Buffer, countBufferOffset DeviceSize, maxDrawCount uint32, stride uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&buffer)
	p2 := /* typedef */ (*C.VkDeviceSize)(&offset)
	p3 := /* handle */ (*C.VkBuffer)(&countBuffer)
	p4 := /* typedef */ (*C.VkDeviceSize)(&countBufferOffset)
	p5 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&maxDrawCount)
	p6 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&stride)
	C.vkCmdDrawIndexedIndirectCount(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6)
}

// CreateRenderPass2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateRenderPass2.html
func (x DeviceFacade) CreateRenderPass2(pCreateInfo *RenderPassCreateInfo2, pAllocator *AllocationCallbacks, pRenderPass *RenderPass) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **RenderPassCreateInfo2) **C.struct_VkRenderPassCreateInfo2 { /* Pointer */
		g2c := (*C.struct_VkRenderPassCreateInfo2)(*x)
		return &g2c
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p3 := func(x **RenderPass) **C.VkRenderPass { /* Pointer */ g2c := (*C.VkRenderPass)(*x); return &g2c }(&pRenderPass)
	ret := C.vkCreateRenderPass2(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetDeviceMemoryOpaqueCaptureAddress command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceMemoryOpaqueCaptureAddress.html
func (x DeviceFacade) GetDeviceMemoryOpaqueCaptureAddress(pInfo *DeviceMemoryOpaqueCaptureAddressInfo) uint64 {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DeviceMemoryOpaqueCaptureAddressInfo) **C.struct_VkDeviceMemoryOpaqueCaptureAddressInfo { /* Pointer */
		g2c := (*C.struct_VkDeviceMemoryOpaqueCaptureAddressInfo)(*x)
		return &g2c
	}(&pInfo)
	ret := C.vkGetDeviceMemoryOpaqueCaptureAddress(addrs, *p0, *p1)
	retPtr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&ret)
	return *retPtr
}

// CmdNextSubpass2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdNextSubpass2.html
func (x CommandBufferFacade) CmdNextSubpass2(pSubpassBeginInfo *SubpassBeginInfo, pSubpassEndInfo *SubpassEndInfo) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **SubpassBeginInfo) **C.struct_VkSubpassBeginInfo { /* Pointer */
		g2c := (*C.struct_VkSubpassBeginInfo)(*x)
		return &g2c
	}(&pSubpassBeginInfo)
	p2 := func(x **SubpassEndInfo) **C.struct_VkSubpassEndInfo { /* Pointer */
		g2c := (*C.struct_VkSubpassEndInfo)(*x)
		return &g2c
	}(&pSubpassEndInfo)
	C.vkCmdNextSubpass2(addrs, *p0, *p1, *p2)
}

// CmdEndRenderPass2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndRenderPass2.html
func (x CommandBufferFacade) CmdEndRenderPass2(pSubpassEndInfo *SubpassEndInfo) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **SubpassEndInfo) **C.struct_VkSubpassEndInfo { /* Pointer */
		g2c := (*C.struct_VkSubpassEndInfo)(*x)
		return &g2c
	}(&pSubpassEndInfo)
	C.vkCmdEndRenderPass2(addrs, *p0, *p1)
}

// SignalSemaphore command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSignalSemaphore.html
func (x DeviceFacade) SignalSemaphore(pSignalInfo *SemaphoreSignalInfo) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **SemaphoreSignalInfo) **C.struct_VkSemaphoreSignalInfo { /* Pointer */
		g2c := (*C.struct_VkSemaphoreSignalInfo)(*x)
		return &g2c
	}(&pSignalInfo)
	ret := C.vkSignalSemaphore(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// WaitSemaphores command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkWaitSemaphores.html
func (x DeviceFacade) WaitSemaphores(pWaitInfo *SemaphoreWaitInfo, timeout uint64) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **SemaphoreWaitInfo) **C.struct_VkSemaphoreWaitInfo { /* Pointer */
		g2c := (*C.struct_VkSemaphoreWaitInfo)(*x)
		return &g2c
	}(&pWaitInfo)
	p2 := func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&timeout)
	ret := C.vkWaitSemaphores(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetSemaphoreCounterValue command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSemaphoreCounterValue.html
func (x DeviceFacade) GetSemaphoreCounterValue(semaphore Semaphore, pValue *uint64) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkSemaphore)(&semaphore)
	p2 := func(x **uint64) **C.uint64_t { /* Pointer */ g2c := (*C.uint64_t)(*x); return &g2c }(&pValue)
	ret := C.vkGetSemaphoreCounterValue(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// ResetQueryPool command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetQueryPool.html
func (x DeviceFacade) ResetQueryPool(queryPool QueryPool, firstQuery uint32, queryCount uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkQueryPool)(&queryPool)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&firstQuery)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&queryCount)
	C.vkResetQueryPool(addrs, *p0, *p1, *p2, *p3)
}

// Flags64 basetype
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFlags64.html
type Flags64 uint64

// PrivateDataSlot is a Handle to a vulkan resource.
// PrivateDataSlot is a child of Device.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPrivateDataSlot.html
type PrivateDataSlot C.VkPrivateDataSlot

// NullPrivateDataSlot is a typed Null value for the PrivateDataSlot type.
var NullPrivateDataSlot PrivateDataSlot

// RenderingFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingFlagBits.html
type RenderingFlagBits uint32

const (
	VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT     RenderingFlagBits = (1 << 0)
	VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR RenderingFlagBits = VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT
	VK_RENDERING_SUSPENDING_BIT                             RenderingFlagBits = (1 << 1)
	VK_RENDERING_SUSPENDING_BIT_KHR                         RenderingFlagBits = VK_RENDERING_SUSPENDING_BIT
	VK_RENDERING_RESUMING_BIT                               RenderingFlagBits = (1 << 2)
	VK_RENDERING_RESUMING_BIT_KHR                           RenderingFlagBits = VK_RENDERING_RESUMING_BIT
)

var (
	reverseRenderingFlagBits map[RenderingFlagBits]string = map[RenderingFlagBits]string{
		VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT: "VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT",
		VK_RENDERING_SUSPENDING_BIT:                         "VK_RENDERING_SUSPENDING_BIT",
		VK_RENDERING_RESUMING_BIT:                           "VK_RENDERING_RESUMING_BIT",
	}
)

func (x RenderingFlagBits) String() string {
	if s, ok := reverseRenderingFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("RenderingFlagBits=%d", x)
}

// PipelineStageFlagBits2 enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineStageFlagBits2.html
type PipelineStageFlagBits2 uint64

const (
	VK_PIPELINE_STAGE_2_NONE                                   PipelineStageFlagBits2 = 0
	VK_PIPELINE_STAGE_2_NONE_KHR                               PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_NONE
	VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT                        PipelineStageFlagBits2 = (1 << 0)
	VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR                    PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT
	VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT                      PipelineStageFlagBits2 = (1 << 1)
	VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR                  PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT
	VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT                       PipelineStageFlagBits2 = (1 << 2)
	VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR                   PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT
	VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT                      PipelineStageFlagBits2 = (1 << 3)
	VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR                  PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT
	VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT        PipelineStageFlagBits2 = (1 << 4)
	VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR    PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT
	VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT     PipelineStageFlagBits2 = (1 << 5)
	VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT
	VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT                    PipelineStageFlagBits2 = (1 << 6)
	VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR                PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT
	VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT                    PipelineStageFlagBits2 = (1 << 7)
	VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR                PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT
	VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT               PipelineStageFlagBits2 = (1 << 8)
	VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR           PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT
	VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT                PipelineStageFlagBits2 = (1 << 9)
	VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR            PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT
	VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT            PipelineStageFlagBits2 = (1 << 10)
	VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR        PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT
	VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT                     PipelineStageFlagBits2 = (1 << 11)
	VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR                 PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT
	VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT                       PipelineStageFlagBits2 = (1 << 12)
	VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR                   PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT
	VK_PIPELINE_STAGE_2_TRANSFER_BIT                           PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR
	VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR                       PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT
	VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT                     PipelineStageFlagBits2 = (1 << 13)
	VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR                 PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT
	VK_PIPELINE_STAGE_2_HOST_BIT                               PipelineStageFlagBits2 = (1 << 14)
	VK_PIPELINE_STAGE_2_HOST_BIT_KHR                           PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_HOST_BIT
	VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT                       PipelineStageFlagBits2 = (1 << 15)
	VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR                   PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT
	VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT                       PipelineStageFlagBits2 = (1 << 16)
	VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR                   PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT
	VK_PIPELINE_STAGE_2_COPY_BIT                               PipelineStageFlagBits2 = (1 << 32)
	VK_PIPELINE_STAGE_2_COPY_BIT_KHR                           PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_COPY_BIT
	VK_PIPELINE_STAGE_2_RESOLVE_BIT                            PipelineStageFlagBits2 = (1 << 33)
	VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR                        PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_RESOLVE_BIT
	VK_PIPELINE_STAGE_2_BLIT_BIT                               PipelineStageFlagBits2 = (1 << 34)
	VK_PIPELINE_STAGE_2_BLIT_BIT_KHR                           PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_BLIT_BIT
	VK_PIPELINE_STAGE_2_CLEAR_BIT                              PipelineStageFlagBits2 = (1 << 35)
	VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR                          PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_CLEAR_BIT
	VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT                        PipelineStageFlagBits2 = (1 << 36)
	VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR                    PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT
	VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT             PipelineStageFlagBits2 = (1 << 37)
	VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR         PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT
	VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT          PipelineStageFlagBits2 = (1 << 38)
	VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR      PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT
)

var (
	reversePipelineStageFlagBits2 map[PipelineStageFlagBits2]string = map[PipelineStageFlagBits2]string{
		VK_PIPELINE_STAGE_2_NONE:                               "VK_PIPELINE_STAGE_2_NONE",
		VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT:                    "VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT",
		VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT:                  "VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT",
		VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT:                   "VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT",
		VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT:                  "VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT",
		VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT:    "VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT",
		VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT: "VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT",
		VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT:                "VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT",
		VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT:                "VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT",
		VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT:           "VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT",
		VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT:            "VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT",
		VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT:        "VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT",
		VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT:                 "VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT",
		VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT:                   "VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT",
		VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT:                 "VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT",
		VK_PIPELINE_STAGE_2_HOST_BIT:                           "VK_PIPELINE_STAGE_2_HOST_BIT",
		VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT:                   "VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT",
		VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT:                   "VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT",
		VK_PIPELINE_STAGE_2_COPY_BIT:                           "VK_PIPELINE_STAGE_2_COPY_BIT",
		VK_PIPELINE_STAGE_2_RESOLVE_BIT:                        "VK_PIPELINE_STAGE_2_RESOLVE_BIT",
		VK_PIPELINE_STAGE_2_BLIT_BIT:                           "VK_PIPELINE_STAGE_2_BLIT_BIT",
		VK_PIPELINE_STAGE_2_CLEAR_BIT:                          "VK_PIPELINE_STAGE_2_CLEAR_BIT",
		VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT:                    "VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT",
		VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT:         "VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT",
		VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT:      "VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT",
	}
)

func (x PipelineStageFlagBits2) String() string {
	if s, ok := reversePipelineStageFlagBits2[x]; ok {
		return s
	}
	return fmt.Sprintf("PipelineStageFlagBits2=%d", x)
}

// ToolPurposeFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkToolPurposeFlagBits.html
type ToolPurposeFlagBits uint32

const (
	VK_TOOL_PURPOSE_VALIDATION_BIT              ToolPurposeFlagBits = (1 << 0)
	VK_TOOL_PURPOSE_VALIDATION_BIT_EXT          ToolPurposeFlagBits = VK_TOOL_PURPOSE_VALIDATION_BIT
	VK_TOOL_PURPOSE_PROFILING_BIT               ToolPurposeFlagBits = (1 << 1)
	VK_TOOL_PURPOSE_PROFILING_BIT_EXT           ToolPurposeFlagBits = VK_TOOL_PURPOSE_PROFILING_BIT
	VK_TOOL_PURPOSE_TRACING_BIT                 ToolPurposeFlagBits = (1 << 2)
	VK_TOOL_PURPOSE_TRACING_BIT_EXT             ToolPurposeFlagBits = VK_TOOL_PURPOSE_TRACING_BIT
	VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT     ToolPurposeFlagBits = (1 << 3)
	VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT ToolPurposeFlagBits = VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT
	VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT      ToolPurposeFlagBits = (1 << 4)
	VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT  ToolPurposeFlagBits = VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT
)

var (
	reverseToolPurposeFlagBits map[ToolPurposeFlagBits]string = map[ToolPurposeFlagBits]string{
		VK_TOOL_PURPOSE_VALIDATION_BIT:          "VK_TOOL_PURPOSE_VALIDATION_BIT",
		VK_TOOL_PURPOSE_PROFILING_BIT:           "VK_TOOL_PURPOSE_PROFILING_BIT",
		VK_TOOL_PURPOSE_TRACING_BIT:             "VK_TOOL_PURPOSE_TRACING_BIT",
		VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT: "VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT",
		VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT:  "VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT",
	}
)

func (x ToolPurposeFlagBits) String() string {
	if s, ok := reverseToolPurposeFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ToolPurposeFlagBits=%d", x)
}

// PipelineCreationFeedbackFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreationFeedbackFlagBits.html
type PipelineCreationFeedbackFlagBits uint32

const (
	VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT                              PipelineCreationFeedbackFlagBits = (1 << 0)
	VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT                          PipelineCreationFeedbackFlagBits = VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT
	VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT     PipelineCreationFeedbackFlagBits = (1 << 1)
	VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT PipelineCreationFeedbackFlagBits = VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT
	VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT         PipelineCreationFeedbackFlagBits = (1 << 2)
	VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT     PipelineCreationFeedbackFlagBits = VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT
)

var (
	reversePipelineCreationFeedbackFlagBits map[PipelineCreationFeedbackFlagBits]string = map[PipelineCreationFeedbackFlagBits]string{
		VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT:                          "VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT",
		VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT: "VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT",
		VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT:     "VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT",
	}
)

func (x PipelineCreationFeedbackFlagBits) String() string {
	if s, ok := reversePipelineCreationFeedbackFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("PipelineCreationFeedbackFlagBits=%d", x)
}

// AccessFlagBits2 enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccessFlagBits2.html
type AccessFlagBits2 uint64

const (
	VK_ACCESS_2_NONE                                   AccessFlagBits2 = 0
	VK_ACCESS_2_NONE_KHR                               AccessFlagBits2 = VK_ACCESS_2_NONE
	VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT              AccessFlagBits2 = (1 << 0)
	VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR          AccessFlagBits2 = VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT
	VK_ACCESS_2_INDEX_READ_BIT                         AccessFlagBits2 = (1 << 1)
	VK_ACCESS_2_INDEX_READ_BIT_KHR                     AccessFlagBits2 = VK_ACCESS_2_INDEX_READ_BIT
	VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT              AccessFlagBits2 = (1 << 2)
	VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR          AccessFlagBits2 = VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT
	VK_ACCESS_2_UNIFORM_READ_BIT                       AccessFlagBits2 = (1 << 3)
	VK_ACCESS_2_UNIFORM_READ_BIT_KHR                   AccessFlagBits2 = VK_ACCESS_2_UNIFORM_READ_BIT
	VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT              AccessFlagBits2 = (1 << 4)
	VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR          AccessFlagBits2 = VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT
	VK_ACCESS_2_SHADER_READ_BIT                        AccessFlagBits2 = (1 << 5)
	VK_ACCESS_2_SHADER_READ_BIT_KHR                    AccessFlagBits2 = VK_ACCESS_2_SHADER_READ_BIT
	VK_ACCESS_2_SHADER_WRITE_BIT                       AccessFlagBits2 = (1 << 6)
	VK_ACCESS_2_SHADER_WRITE_BIT_KHR                   AccessFlagBits2 = VK_ACCESS_2_SHADER_WRITE_BIT
	VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT              AccessFlagBits2 = (1 << 7)
	VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR          AccessFlagBits2 = VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT
	VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT             AccessFlagBits2 = (1 << 8)
	VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR         AccessFlagBits2 = VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT
	VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT      AccessFlagBits2 = (1 << 9)
	VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR  AccessFlagBits2 = VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT
	VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT     AccessFlagBits2 = (1 << 10)
	VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR AccessFlagBits2 = VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT
	VK_ACCESS_2_TRANSFER_READ_BIT                      AccessFlagBits2 = (1 << 11)
	VK_ACCESS_2_TRANSFER_READ_BIT_KHR                  AccessFlagBits2 = VK_ACCESS_2_TRANSFER_READ_BIT
	VK_ACCESS_2_TRANSFER_WRITE_BIT                     AccessFlagBits2 = (1 << 12)
	VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR                 AccessFlagBits2 = VK_ACCESS_2_TRANSFER_WRITE_BIT
	VK_ACCESS_2_HOST_READ_BIT                          AccessFlagBits2 = (1 << 13)
	VK_ACCESS_2_HOST_READ_BIT_KHR                      AccessFlagBits2 = VK_ACCESS_2_HOST_READ_BIT
	VK_ACCESS_2_HOST_WRITE_BIT                         AccessFlagBits2 = (1 << 14)
	VK_ACCESS_2_HOST_WRITE_BIT_KHR                     AccessFlagBits2 = VK_ACCESS_2_HOST_WRITE_BIT
	VK_ACCESS_2_MEMORY_READ_BIT                        AccessFlagBits2 = (1 << 15)
	VK_ACCESS_2_MEMORY_READ_BIT_KHR                    AccessFlagBits2 = VK_ACCESS_2_MEMORY_READ_BIT
	VK_ACCESS_2_MEMORY_WRITE_BIT                       AccessFlagBits2 = (1 << 16)
	VK_ACCESS_2_MEMORY_WRITE_BIT_KHR                   AccessFlagBits2 = VK_ACCESS_2_MEMORY_WRITE_BIT
	VK_ACCESS_2_SHADER_SAMPLED_READ_BIT                AccessFlagBits2 = (1 << 32)
	VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR            AccessFlagBits2 = VK_ACCESS_2_SHADER_SAMPLED_READ_BIT
	VK_ACCESS_2_SHADER_STORAGE_READ_BIT                AccessFlagBits2 = (1 << 33)
	VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR            AccessFlagBits2 = VK_ACCESS_2_SHADER_STORAGE_READ_BIT
	VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT               AccessFlagBits2 = (1 << 34)
	VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR           AccessFlagBits2 = VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT
)

var (
	reverseAccessFlagBits2 map[AccessFlagBits2]string = map[AccessFlagBits2]string{
		VK_ACCESS_2_NONE:                               "VK_ACCESS_2_NONE",
		VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT:          "VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT",
		VK_ACCESS_2_INDEX_READ_BIT:                     "VK_ACCESS_2_INDEX_READ_BIT",
		VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT:          "VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT",
		VK_ACCESS_2_UNIFORM_READ_BIT:                   "VK_ACCESS_2_UNIFORM_READ_BIT",
		VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT:          "VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT",
		VK_ACCESS_2_SHADER_READ_BIT:                    "VK_ACCESS_2_SHADER_READ_BIT",
		VK_ACCESS_2_SHADER_WRITE_BIT:                   "VK_ACCESS_2_SHADER_WRITE_BIT",
		VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT:          "VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT",
		VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT:         "VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT",
		VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT:  "VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT",
		VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT: "VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT",
		VK_ACCESS_2_TRANSFER_READ_BIT:                  "VK_ACCESS_2_TRANSFER_READ_BIT",
		VK_ACCESS_2_TRANSFER_WRITE_BIT:                 "VK_ACCESS_2_TRANSFER_WRITE_BIT",
		VK_ACCESS_2_HOST_READ_BIT:                      "VK_ACCESS_2_HOST_READ_BIT",
		VK_ACCESS_2_HOST_WRITE_BIT:                     "VK_ACCESS_2_HOST_WRITE_BIT",
		VK_ACCESS_2_MEMORY_READ_BIT:                    "VK_ACCESS_2_MEMORY_READ_BIT",
		VK_ACCESS_2_MEMORY_WRITE_BIT:                   "VK_ACCESS_2_MEMORY_WRITE_BIT",
		VK_ACCESS_2_SHADER_SAMPLED_READ_BIT:            "VK_ACCESS_2_SHADER_SAMPLED_READ_BIT",
		VK_ACCESS_2_SHADER_STORAGE_READ_BIT:            "VK_ACCESS_2_SHADER_STORAGE_READ_BIT",
		VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT:           "VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT",
	}
)

func (x AccessFlagBits2) String() string {
	if s, ok := reverseAccessFlagBits2[x]; ok {
		return s
	}
	return fmt.Sprintf("AccessFlagBits2=%d", x)
}

// FormatFeatureFlagBits2 enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatFeatureFlagBits2.html
type FormatFeatureFlagBits2 uint64

const (
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT                                                               FormatFeatureFlagBits2 = (1 << 0)
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR                                                           FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT
	VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT                                                               FormatFeatureFlagBits2 = (1 << 1)
	VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR                                                           FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT
	VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT                                                        FormatFeatureFlagBits2 = (1 << 2)
	VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR                                                    FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT
	VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT                                                        FormatFeatureFlagBits2 = (1 << 3)
	VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR                                                    FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT
	VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT                                                        FormatFeatureFlagBits2 = (1 << 4)
	VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR                                                    FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT
	VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT                                                 FormatFeatureFlagBits2 = (1 << 5)
	VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR                                             FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
	VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT                                                               FormatFeatureFlagBits2 = (1 << 6)
	VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR                                                           FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT
	VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT                                                            FormatFeatureFlagBits2 = (1 << 7)
	VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR                                                        FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT
	VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT                                                      FormatFeatureFlagBits2 = (1 << 8)
	VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR                                                  FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT
	VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT                                                    FormatFeatureFlagBits2 = (1 << 9)
	VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR                                                FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT
	VK_FORMAT_FEATURE_2_BLIT_SRC_BIT                                                                    FormatFeatureFlagBits2 = (1 << 10)
	VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR                                                                FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_BLIT_SRC_BIT
	VK_FORMAT_FEATURE_2_BLIT_DST_BIT                                                                    FormatFeatureFlagBits2 = (1 << 11)
	VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR                                                                FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_BLIT_DST_BIT
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT                                                 FormatFeatureFlagBits2 = (1 << 12)
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR                                             FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT                                                  FormatFeatureFlagBits2 = (1 << 13)
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT                                              FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT
	VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT                                                                FormatFeatureFlagBits2 = (1 << 14)
	VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR                                                            FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT
	VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT                                                                FormatFeatureFlagBits2 = (1 << 15)
	VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR                                                            FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT                                                 FormatFeatureFlagBits2 = (1 << 16)
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR                                             FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT
	VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT                                                     FormatFeatureFlagBits2 = (1 << 17)
	VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR                                                 FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT                                FormatFeatureFlagBits2 = (1 << 18)
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR                            FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT               FormatFeatureFlagBits2 = (1 << 19)
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR           FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT               FormatFeatureFlagBits2 = (1 << 20)
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR           FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT     FormatFeatureFlagBits2 = (1 << 21)
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT
	VK_FORMAT_FEATURE_2_DISJOINT_BIT                                                                    FormatFeatureFlagBits2 = (1 << 22)
	VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR                                                                FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_DISJOINT_BIT
	VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT                                                      FormatFeatureFlagBits2 = (1 << 23)
	VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR                                                  FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT
	VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT                                                 FormatFeatureFlagBits2 = (1 << 31)
	VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR                                             FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
	VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT                                                FormatFeatureFlagBits2 = (1 << 32)
	VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR                                            FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT                                              FormatFeatureFlagBits2 = (1 << 33)
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR                                          FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT
)

var (
	reverseFormatFeatureFlagBits2 map[FormatFeatureFlagBits2]string = map[FormatFeatureFlagBits2]string{
		VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT:                                                           "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT",
		VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT:                                                           "VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT",
		VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT:                                                    "VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT",
		VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT:                                                    "VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT",
		VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT:                                                    "VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT",
		VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT:                                             "VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT",
		VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT:                                                           "VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT",
		VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT:                                                        "VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT",
		VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT:                                                  "VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT",
		VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT:                                                "VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT",
		VK_FORMAT_FEATURE_2_BLIT_SRC_BIT:                                                                "VK_FORMAT_FEATURE_2_BLIT_SRC_BIT",
		VK_FORMAT_FEATURE_2_BLIT_DST_BIT:                                                                "VK_FORMAT_FEATURE_2_BLIT_DST_BIT",
		VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT:                                             "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT",
		VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT:                                              "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT",
		VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT:                                                            "VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT",
		VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT:                                                            "VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT",
		VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT:                                             "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT",
		VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT:                                                 "VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT",
		VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT:                            "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT",
		VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT:           "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT",
		VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT:           "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT",
		VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT: "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT",
		VK_FORMAT_FEATURE_2_DISJOINT_BIT:                                                                "VK_FORMAT_FEATURE_2_DISJOINT_BIT",
		VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT:                                                  "VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT",
		VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT:                                             "VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT",
		VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT:                                            "VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT",
		VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT:                                          "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT",
	}
)

func (x FormatFeatureFlagBits2) String() string {
	if s, ok := reverseFormatFeatureFlagBits2[x]; ok {
		return s
	}
	return fmt.Sprintf("FormatFeatureFlagBits2=%d", x)
}

// SubmitFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubmitFlagBits.html
type SubmitFlagBits uint32

const (
	VK_SUBMIT_PROTECTED_BIT     SubmitFlagBits = (1 << 0)
	VK_SUBMIT_PROTECTED_BIT_KHR SubmitFlagBits = VK_SUBMIT_PROTECTED_BIT
)

var (
	reverseSubmitFlagBits map[SubmitFlagBits]string = map[SubmitFlagBits]string{
		VK_SUBMIT_PROTECTED_BIT: "VK_SUBMIT_PROTECTED_BIT",
	}
)

func (x SubmitFlagBits) String() string {
	if s, ok := reverseSubmitFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("SubmitFlagBits=%d", x)
}

// SubmitFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubmitFlags.html
type SubmitFlags Flags

// PipelineCreationFeedbackFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreationFeedbackFlags.html
type PipelineCreationFeedbackFlags Flags

// AccessFlags2 bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccessFlags2.html
type AccessFlags2 Flags64

// FormatFeatureFlags2 bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatFeatureFlags2.html
type FormatFeatureFlags2 Flags64

// RenderingFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingFlags.html
type RenderingFlags Flags

// ToolPurposeFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkToolPurposeFlags.html
type ToolPurposeFlags Flags

// PipelineStageFlags2 bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineStageFlags2.html
type PipelineStageFlags2 Flags64

// PrivateDataSlotCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPrivateDataSlotCreateFlags.html
type PrivateDataSlotCreateFlags Flags

// PhysicalDeviceSubgroupSizeControlProperties provides a go interface for VkPhysicalDeviceSubgroupSizeControlProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubgroupSizeControlProperties.html
type PhysicalDeviceSubgroupSizeControlProperties C.struct_VkPhysicalDeviceSubgroupSizeControlProperties

// SizeofPhysicalDeviceSubgroupSizeControlProperties is the memory size of a PhysicalDeviceSubgroupSizeControlProperties
var SizeofPhysicalDeviceSubgroupSizeControlProperties int = int(unsafe.Sizeof(PhysicalDeviceSubgroupSizeControlProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceSubgroupSizeControlProperties) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceSubgroupSizeControlProperties {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceSubgroupSizeControlProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceSubgroupSizeControlProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceSubgroupSizeControlProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceSubgroupSizeControlProperties) AsCPtr() *PhysicalDeviceSubgroupSizeControlProperties {
	clone := (*PhysicalDeviceSubgroupSizeControlProperties)(newCBlock(cULong(SizeofPhysicalDeviceSubgroupSizeControlProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceSubgroupSizeControlPropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceSubgroupSizeControlPropertiesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceSubgroupSizeControlProperties) []PhysicalDeviceSubgroupSizeControlProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSubgroupSizeControlProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceSubgroupSizeControlProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceSubgroupSizeControlPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceSubgroupSizeControlPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceSubgroupSizeControlPropertiesFreeCSlice(x []PhysicalDeviceSubgroupSizeControlProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceSubgroupSizeControlPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceSubgroupSizeControlPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceSubgroupSizeControlPropertiesMakeCSlice(x ...PhysicalDeviceSubgroupSizeControlProperties) []PhysicalDeviceSubgroupSizeControlProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSubgroupSizeControlProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceSubgroupSizeControlProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceSubgroupSizeControlProperties
func (x PhysicalDeviceSubgroupSizeControlProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceSubgroupSizeControlProperties with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceSubgroupSizeControlProperties) WithDefaultSType() PhysicalDeviceSubgroupSizeControlProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceSubgroupSizeControlProperties) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES)
}

// WithSType clones a new PhysicalDeviceSubgroupSizeControlProperties with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSubgroupSizeControlProperties) WithSType(y StructureType) PhysicalDeviceSubgroupSizeControlProperties {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceSubgroupSizeControlProperties) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceSubgroupSizeControlProperties
func (x PhysicalDeviceSubgroupSizeControlProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceSubgroupSizeControlProperties with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSubgroupSizeControlProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceSubgroupSizeControlProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceSubgroupSizeControlProperties) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// MinSubgroupSize returns the value of minSubgroupSize from VkPhysicalDeviceSubgroupSizeControlProperties
func (x PhysicalDeviceSubgroupSizeControlProperties) MinSubgroupSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.minSubgroupSize)
	return *ptr
}

// MaxSubgroupSize returns the value of maxSubgroupSize from VkPhysicalDeviceSubgroupSizeControlProperties
func (x PhysicalDeviceSubgroupSizeControlProperties) MaxSubgroupSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxSubgroupSize)
	return *ptr
}

// MaxComputeWorkgroupSubgroups returns the value of maxComputeWorkgroupSubgroups from VkPhysicalDeviceSubgroupSizeControlProperties
func (x PhysicalDeviceSubgroupSizeControlProperties) MaxComputeWorkgroupSubgroups() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxComputeWorkgroupSubgroups)
	return *ptr
}

// RequiredSubgroupSizeStages returns the value of requiredSubgroupSizeStages from VkPhysicalDeviceSubgroupSizeControlProperties
func (x PhysicalDeviceSubgroupSizeControlProperties) RequiredSubgroupSizeStages() ShaderStageFlags {
	ptr := /* typedef */ (*ShaderStageFlags)(&x.requiredSubgroupSizeStages)
	return *ptr
}

// PhysicalDeviceInlineUniformBlockFeatures provides a go interface for VkPhysicalDeviceInlineUniformBlockFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceInlineUniformBlockFeatures.html
type PhysicalDeviceInlineUniformBlockFeatures C.struct_VkPhysicalDeviceInlineUniformBlockFeatures

// SizeofPhysicalDeviceInlineUniformBlockFeatures is the memory size of a PhysicalDeviceInlineUniformBlockFeatures
var SizeofPhysicalDeviceInlineUniformBlockFeatures int = int(unsafe.Sizeof(PhysicalDeviceInlineUniformBlockFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceInlineUniformBlockFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceInlineUniformBlockFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceInlineUniformBlockFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceInlineUniformBlockFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceInlineUniformBlockFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceInlineUniformBlockFeatures) AsCPtr() *PhysicalDeviceInlineUniformBlockFeatures {
	clone := (*PhysicalDeviceInlineUniformBlockFeatures)(newCBlock(cULong(SizeofPhysicalDeviceInlineUniformBlockFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceInlineUniformBlockFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceInlineUniformBlockFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceInlineUniformBlockFeatures) []PhysicalDeviceInlineUniformBlockFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceInlineUniformBlockFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceInlineUniformBlockFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceInlineUniformBlockFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceInlineUniformBlockFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceInlineUniformBlockFeaturesFreeCSlice(x []PhysicalDeviceInlineUniformBlockFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceInlineUniformBlockFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceInlineUniformBlockFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceInlineUniformBlockFeaturesMakeCSlice(x ...PhysicalDeviceInlineUniformBlockFeatures) []PhysicalDeviceInlineUniformBlockFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceInlineUniformBlockFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceInlineUniformBlockFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceInlineUniformBlockFeatures
func (x PhysicalDeviceInlineUniformBlockFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceInlineUniformBlockFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceInlineUniformBlockFeatures) WithDefaultSType() PhysicalDeviceInlineUniformBlockFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceInlineUniformBlockFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES)
}

// WithSType clones a new PhysicalDeviceInlineUniformBlockFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceInlineUniformBlockFeatures) WithSType(y StructureType) PhysicalDeviceInlineUniformBlockFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceInlineUniformBlockFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceInlineUniformBlockFeatures
func (x PhysicalDeviceInlineUniformBlockFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceInlineUniformBlockFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceInlineUniformBlockFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceInlineUniformBlockFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceInlineUniformBlockFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// InlineUniformBlock returns the value of inlineUniformBlock from VkPhysicalDeviceInlineUniformBlockFeatures
func (x PhysicalDeviceInlineUniformBlockFeatures) InlineUniformBlock() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.inlineUniformBlock)
	return *ptr
}

// WithInlineUniformBlock clones a new PhysicalDeviceInlineUniformBlockFeatures with the value of
// InlineUniformBlock updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceInlineUniformBlockFeatures) WithInlineUniformBlock(y Bool32) PhysicalDeviceInlineUniformBlockFeatures {
	x.inlineUniformBlock = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceInlineUniformBlockFeatures) SetInlineUniformBlock(y Bool32) {
	x.inlineUniformBlock = *( /* typedef */ (*C.VkBool32)(&y))
}

// DescriptorBindingInlineUniformBlockUpdateAfterBind returns the value of descriptorBindingInlineUniformBlockUpdateAfterBind from VkPhysicalDeviceInlineUniformBlockFeatures
func (x PhysicalDeviceInlineUniformBlockFeatures) DescriptorBindingInlineUniformBlockUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingInlineUniformBlockUpdateAfterBind)
	return *ptr
}

// WithDescriptorBindingInlineUniformBlockUpdateAfterBind clones a new PhysicalDeviceInlineUniformBlockFeatures with the value of
// DescriptorBindingInlineUniformBlockUpdateAfterBind updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceInlineUniformBlockFeatures) WithDescriptorBindingInlineUniformBlockUpdateAfterBind(y Bool32) PhysicalDeviceInlineUniformBlockFeatures {
	x.descriptorBindingInlineUniformBlockUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceInlineUniformBlockFeatures) SetDescriptorBindingInlineUniformBlockUpdateAfterBind(y Bool32) {
	x.descriptorBindingInlineUniformBlockUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
}

// WriteDescriptorSetInlineUniformBlock provides a go interface for VkWriteDescriptorSetInlineUniformBlock.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWriteDescriptorSetInlineUniformBlock.html
type WriteDescriptorSetInlineUniformBlock C.struct_VkWriteDescriptorSetInlineUniformBlock

// SizeofWriteDescriptorSetInlineUniformBlock is the memory size of a WriteDescriptorSetInlineUniformBlock
var SizeofWriteDescriptorSetInlineUniformBlock int = int(unsafe.Sizeof(WriteDescriptorSetInlineUniformBlock{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x WriteDescriptorSetInlineUniformBlock) ArpPtr(arp *AutoReleasePool) *WriteDescriptorSetInlineUniformBlock {
	ptr := newCBlock(cULong(SizeofWriteDescriptorSetInlineUniformBlock))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*WriteDescriptorSetInlineUniformBlock)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *WriteDescriptorSetInlineUniformBlock) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x WriteDescriptorSetInlineUniformBlock) AsCPtr() *WriteDescriptorSetInlineUniformBlock {
	clone := (*WriteDescriptorSetInlineUniformBlock)(newCBlock(cULong(SizeofWriteDescriptorSetInlineUniformBlock)))
	*clone = x
	return clone
}

// WriteDescriptorSetInlineUniformBlockCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func WriteDescriptorSetInlineUniformBlockCSlice(arp *AutoReleasePool, x ...WriteDescriptorSetInlineUniformBlock) []WriteDescriptorSetInlineUniformBlock {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofWriteDescriptorSetInlineUniformBlock * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*WriteDescriptorSetInlineUniformBlock)(ptr), len(x))
	copy(dst, x)
	return dst
}

// WriteDescriptorSetInlineUniformBlockFreeCSlice releases the memory allocated by WriteDescriptorSetInlineUniformBlockMakeCSlice.
// It does not free pointers stored inside the slice.
func WriteDescriptorSetInlineUniformBlockFreeCSlice(x []WriteDescriptorSetInlineUniformBlock) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// WriteDescriptorSetInlineUniformBlockMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. WriteDescriptorSetInlineUniformBlockFreeCSlice must be called on the returned slice.
func WriteDescriptorSetInlineUniformBlockMakeCSlice(x ...WriteDescriptorSetInlineUniformBlock) []WriteDescriptorSetInlineUniformBlock {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofWriteDescriptorSetInlineUniformBlock * len(x)
	dst := unsafe.Slice((*WriteDescriptorSetInlineUniformBlock)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkWriteDescriptorSetInlineUniformBlock
func (x WriteDescriptorSetInlineUniformBlock) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new WriteDescriptorSetInlineUniformBlock with the value of
// SType to the value provided in the specification.
func (x WriteDescriptorSetInlineUniformBlock) WithDefaultSType() WriteDescriptorSetInlineUniformBlock {
	return x.WithSType(VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *WriteDescriptorSetInlineUniformBlock) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK)
}

// WithSType clones a new WriteDescriptorSetInlineUniformBlock with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSetInlineUniformBlock) WithSType(y StructureType) WriteDescriptorSetInlineUniformBlock {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *WriteDescriptorSetInlineUniformBlock) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkWriteDescriptorSetInlineUniformBlock
func (x WriteDescriptorSetInlineUniformBlock) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new WriteDescriptorSetInlineUniformBlock with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSetInlineUniformBlock) WithPNext(y unsafe.Pointer) WriteDescriptorSetInlineUniformBlock {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *WriteDescriptorSetInlineUniformBlock) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// DataSize returns the value of dataSize from VkWriteDescriptorSetInlineUniformBlock
func (x WriteDescriptorSetInlineUniformBlock) DataSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dataSize)
	return *ptr
}

// WithDataSize clones a new WriteDescriptorSetInlineUniformBlock with the value of
// DataSize updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSetInlineUniformBlock) WithDataSize(y uint32) WriteDescriptorSetInlineUniformBlock {
	x.dataSize = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *WriteDescriptorSetInlineUniformBlock) SetDataSize(y uint32) {
	x.dataSize = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PData returns the value of pData from VkWriteDescriptorSetInlineUniformBlock
func (x WriteDescriptorSetInlineUniformBlock) PData() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pData)
	return *ptr
}

// WithPData clones a new WriteDescriptorSetInlineUniformBlock with the value of
// PData updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSetInlineUniformBlock) WithPData(y unsafe.Pointer) WriteDescriptorSetInlineUniformBlock {
	x.pData = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *WriteDescriptorSetInlineUniformBlock) SetPData(y unsafe.Pointer) {
	x.pData = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// DeviceBufferMemoryRequirements provides a go interface for VkDeviceBufferMemoryRequirements.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceBufferMemoryRequirements.html
type DeviceBufferMemoryRequirements C.struct_VkDeviceBufferMemoryRequirements

// SizeofDeviceBufferMemoryRequirements is the memory size of a DeviceBufferMemoryRequirements
var SizeofDeviceBufferMemoryRequirements int = int(unsafe.Sizeof(DeviceBufferMemoryRequirements{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DeviceBufferMemoryRequirements) ArpPtr(arp *AutoReleasePool) *DeviceBufferMemoryRequirements {
	ptr := newCBlock(cULong(SizeofDeviceBufferMemoryRequirements))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DeviceBufferMemoryRequirements)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceBufferMemoryRequirements) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceBufferMemoryRequirements) AsCPtr() *DeviceBufferMemoryRequirements {
	clone := (*DeviceBufferMemoryRequirements)(newCBlock(cULong(SizeofDeviceBufferMemoryRequirements)))
	*clone = x
	return clone
}

// DeviceBufferMemoryRequirementsCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DeviceBufferMemoryRequirementsCSlice(arp *AutoReleasePool, x ...DeviceBufferMemoryRequirements) []DeviceBufferMemoryRequirements {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceBufferMemoryRequirements * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DeviceBufferMemoryRequirements)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DeviceBufferMemoryRequirementsFreeCSlice releases the memory allocated by DeviceBufferMemoryRequirementsMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceBufferMemoryRequirementsFreeCSlice(x []DeviceBufferMemoryRequirements) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceBufferMemoryRequirementsMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceBufferMemoryRequirementsFreeCSlice must be called on the returned slice.
func DeviceBufferMemoryRequirementsMakeCSlice(x ...DeviceBufferMemoryRequirements) []DeviceBufferMemoryRequirements {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceBufferMemoryRequirements * len(x)
	dst := unsafe.Slice((*DeviceBufferMemoryRequirements)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceBufferMemoryRequirements
func (x DeviceBufferMemoryRequirements) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DeviceBufferMemoryRequirements with the value of
// SType to the value provided in the specification.
func (x DeviceBufferMemoryRequirements) WithDefaultSType() DeviceBufferMemoryRequirements {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DeviceBufferMemoryRequirements) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS)
}

// WithSType clones a new DeviceBufferMemoryRequirements with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceBufferMemoryRequirements) WithSType(y StructureType) DeviceBufferMemoryRequirements {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DeviceBufferMemoryRequirements) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDeviceBufferMemoryRequirements
func (x DeviceBufferMemoryRequirements) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DeviceBufferMemoryRequirements with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceBufferMemoryRequirements) WithPNext(y unsafe.Pointer) DeviceBufferMemoryRequirements {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DeviceBufferMemoryRequirements) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// PCreateInfo returns the value of pCreateInfo from VkDeviceBufferMemoryRequirements
func (x DeviceBufferMemoryRequirements) PCreateInfo() *BufferCreateInfo {
	ptr := func(x **C.struct_VkBufferCreateInfo) **BufferCreateInfo { /* Pointer */
		c2g := (*BufferCreateInfo)(*x)
		return &c2g
	}(&x.pCreateInfo)
	return *ptr
}

// WithPCreateInfo clones a new DeviceBufferMemoryRequirements with the value of
// PCreateInfo updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceBufferMemoryRequirements) WithPCreateInfo(y *BufferCreateInfo) DeviceBufferMemoryRequirements {
	x.pCreateInfo = *(func(x **BufferCreateInfo) **C.struct_VkBufferCreateInfo { /* Pointer */
		g2c := (*C.struct_VkBufferCreateInfo)(*x)
		return &g2c
	}(&y))
	return x
}
func (x *DeviceBufferMemoryRequirements) SetPCreateInfo(y *BufferCreateInfo) {
	x.pCreateInfo = *(func(x **BufferCreateInfo) **C.struct_VkBufferCreateInfo { /* Pointer */
		g2c := (*C.struct_VkBufferCreateInfo)(*x)
		return &g2c
	}(&y))
}

// PhysicalDeviceMaintenance4Properties provides a go interface for VkPhysicalDeviceMaintenance4Properties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance4Properties.html
type PhysicalDeviceMaintenance4Properties C.struct_VkPhysicalDeviceMaintenance4Properties

// SizeofPhysicalDeviceMaintenance4Properties is the memory size of a PhysicalDeviceMaintenance4Properties
var SizeofPhysicalDeviceMaintenance4Properties int = int(unsafe.Sizeof(PhysicalDeviceMaintenance4Properties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceMaintenance4Properties) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceMaintenance4Properties {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceMaintenance4Properties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceMaintenance4Properties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceMaintenance4Properties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceMaintenance4Properties) AsCPtr() *PhysicalDeviceMaintenance4Properties {
	clone := (*PhysicalDeviceMaintenance4Properties)(newCBlock(cULong(SizeofPhysicalDeviceMaintenance4Properties)))
	*clone = x
	return clone
}

// PhysicalDeviceMaintenance4PropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceMaintenance4PropertiesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceMaintenance4Properties) []PhysicalDeviceMaintenance4Properties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceMaintenance4Properties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceMaintenance4Properties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceMaintenance4PropertiesFreeCSlice releases the memory allocated by PhysicalDeviceMaintenance4PropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceMaintenance4PropertiesFreeCSlice(x []PhysicalDeviceMaintenance4Properties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceMaintenance4PropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceMaintenance4PropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceMaintenance4PropertiesMakeCSlice(x ...PhysicalDeviceMaintenance4Properties) []PhysicalDeviceMaintenance4Properties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceMaintenance4Properties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceMaintenance4Properties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceMaintenance4Properties
func (x PhysicalDeviceMaintenance4Properties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceMaintenance4Properties with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceMaintenance4Properties) WithDefaultSType() PhysicalDeviceMaintenance4Properties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceMaintenance4Properties) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES)
}

// WithSType clones a new PhysicalDeviceMaintenance4Properties with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMaintenance4Properties) WithSType(y StructureType) PhysicalDeviceMaintenance4Properties {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceMaintenance4Properties) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceMaintenance4Properties
func (x PhysicalDeviceMaintenance4Properties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceMaintenance4Properties with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMaintenance4Properties) WithPNext(y unsafe.Pointer) PhysicalDeviceMaintenance4Properties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceMaintenance4Properties) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// MaxBufferSize returns the value of maxBufferSize from VkPhysicalDeviceMaintenance4Properties
func (x PhysicalDeviceMaintenance4Properties) MaxBufferSize() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.maxBufferSize)
	return *ptr
}

// PhysicalDeviceMaintenance4Features provides a go interface for VkPhysicalDeviceMaintenance4Features.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance4Features.html
type PhysicalDeviceMaintenance4Features C.struct_VkPhysicalDeviceMaintenance4Features

// SizeofPhysicalDeviceMaintenance4Features is the memory size of a PhysicalDeviceMaintenance4Features
var SizeofPhysicalDeviceMaintenance4Features int = int(unsafe.Sizeof(PhysicalDeviceMaintenance4Features{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceMaintenance4Features) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceMaintenance4Features {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceMaintenance4Features))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceMaintenance4Features)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceMaintenance4Features) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceMaintenance4Features) AsCPtr() *PhysicalDeviceMaintenance4Features {
	clone := (*PhysicalDeviceMaintenance4Features)(newCBlock(cULong(SizeofPhysicalDeviceMaintenance4Features)))
	*clone = x
	return clone
}

// PhysicalDeviceMaintenance4FeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceMaintenance4FeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceMaintenance4Features) []PhysicalDeviceMaintenance4Features {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceMaintenance4Features * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceMaintenance4Features)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceMaintenance4FeaturesFreeCSlice releases the memory allocated by PhysicalDeviceMaintenance4FeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceMaintenance4FeaturesFreeCSlice(x []PhysicalDeviceMaintenance4Features) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceMaintenance4FeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceMaintenance4FeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceMaintenance4FeaturesMakeCSlice(x ...PhysicalDeviceMaintenance4Features) []PhysicalDeviceMaintenance4Features {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceMaintenance4Features * len(x)
	dst := unsafe.Slice((*PhysicalDeviceMaintenance4Features)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceMaintenance4Features
func (x PhysicalDeviceMaintenance4Features) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceMaintenance4Features with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceMaintenance4Features) WithDefaultSType() PhysicalDeviceMaintenance4Features {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceMaintenance4Features) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES)
}

// WithSType clones a new PhysicalDeviceMaintenance4Features with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMaintenance4Features) WithSType(y StructureType) PhysicalDeviceMaintenance4Features {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceMaintenance4Features) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceMaintenance4Features
func (x PhysicalDeviceMaintenance4Features) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceMaintenance4Features with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMaintenance4Features) WithPNext(y unsafe.Pointer) PhysicalDeviceMaintenance4Features {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceMaintenance4Features) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Maintenance4 returns the value of maintenance4 from VkPhysicalDeviceMaintenance4Features
func (x PhysicalDeviceMaintenance4Features) Maintenance4() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.maintenance4)
	return *ptr
}

// WithMaintenance4 clones a new PhysicalDeviceMaintenance4Features with the value of
// Maintenance4 updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMaintenance4Features) WithMaintenance4(y Bool32) PhysicalDeviceMaintenance4Features {
	x.maintenance4 = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceMaintenance4Features) SetMaintenance4(y Bool32) {
	x.maintenance4 = *( /* typedef */ (*C.VkBool32)(&y))
}

// PhysicalDevicePrivateDataFeatures provides a go interface for VkPhysicalDevicePrivateDataFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePrivateDataFeatures.html
type PhysicalDevicePrivateDataFeatures C.struct_VkPhysicalDevicePrivateDataFeatures

// SizeofPhysicalDevicePrivateDataFeatures is the memory size of a PhysicalDevicePrivateDataFeatures
var SizeofPhysicalDevicePrivateDataFeatures int = int(unsafe.Sizeof(PhysicalDevicePrivateDataFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDevicePrivateDataFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDevicePrivateDataFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDevicePrivateDataFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDevicePrivateDataFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDevicePrivateDataFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDevicePrivateDataFeatures) AsCPtr() *PhysicalDevicePrivateDataFeatures {
	clone := (*PhysicalDevicePrivateDataFeatures)(newCBlock(cULong(SizeofPhysicalDevicePrivateDataFeatures)))
	*clone = x
	return clone
}

// PhysicalDevicePrivateDataFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDevicePrivateDataFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDevicePrivateDataFeatures) []PhysicalDevicePrivateDataFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDevicePrivateDataFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDevicePrivateDataFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDevicePrivateDataFeaturesFreeCSlice releases the memory allocated by PhysicalDevicePrivateDataFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDevicePrivateDataFeaturesFreeCSlice(x []PhysicalDevicePrivateDataFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDevicePrivateDataFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDevicePrivateDataFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDevicePrivateDataFeaturesMakeCSlice(x ...PhysicalDevicePrivateDataFeatures) []PhysicalDevicePrivateDataFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDevicePrivateDataFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDevicePrivateDataFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDevicePrivateDataFeatures
func (x PhysicalDevicePrivateDataFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDevicePrivateDataFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDevicePrivateDataFeatures) WithDefaultSType() PhysicalDevicePrivateDataFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDevicePrivateDataFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES)
}

// WithSType clones a new PhysicalDevicePrivateDataFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePrivateDataFeatures) WithSType(y StructureType) PhysicalDevicePrivateDataFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDevicePrivateDataFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDevicePrivateDataFeatures
func (x PhysicalDevicePrivateDataFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDevicePrivateDataFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePrivateDataFeatures) WithPNext(y unsafe.Pointer) PhysicalDevicePrivateDataFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDevicePrivateDataFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// PrivateData returns the value of privateData from VkPhysicalDevicePrivateDataFeatures
func (x PhysicalDevicePrivateDataFeatures) PrivateData() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.privateData)
	return *ptr
}

// WithPrivateData clones a new PhysicalDevicePrivateDataFeatures with the value of
// PrivateData updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePrivateDataFeatures) WithPrivateData(y Bool32) PhysicalDevicePrivateDataFeatures {
	x.privateData = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDevicePrivateDataFeatures) SetPrivateData(y Bool32) {
	x.privateData = *( /* typedef */ (*C.VkBool32)(&y))
}

// DevicePrivateDataCreateInfo provides a go interface for VkDevicePrivateDataCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDevicePrivateDataCreateInfo.html
type DevicePrivateDataCreateInfo C.struct_VkDevicePrivateDataCreateInfo

// SizeofDevicePrivateDataCreateInfo is the memory size of a DevicePrivateDataCreateInfo
var SizeofDevicePrivateDataCreateInfo int = int(unsafe.Sizeof(DevicePrivateDataCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DevicePrivateDataCreateInfo) ArpPtr(arp *AutoReleasePool) *DevicePrivateDataCreateInfo {
	ptr := newCBlock(cULong(SizeofDevicePrivateDataCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DevicePrivateDataCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DevicePrivateDataCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DevicePrivateDataCreateInfo) AsCPtr() *DevicePrivateDataCreateInfo {
	clone := (*DevicePrivateDataCreateInfo)(newCBlock(cULong(SizeofDevicePrivateDataCreateInfo)))
	*clone = x
	return clone
}

// DevicePrivateDataCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DevicePrivateDataCreateInfoCSlice(arp *AutoReleasePool, x ...DevicePrivateDataCreateInfo) []DevicePrivateDataCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDevicePrivateDataCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DevicePrivateDataCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DevicePrivateDataCreateInfoFreeCSlice releases the memory allocated by DevicePrivateDataCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DevicePrivateDataCreateInfoFreeCSlice(x []DevicePrivateDataCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DevicePrivateDataCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DevicePrivateDataCreateInfoFreeCSlice must be called on the returned slice.
func DevicePrivateDataCreateInfoMakeCSlice(x ...DevicePrivateDataCreateInfo) []DevicePrivateDataCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDevicePrivateDataCreateInfo * len(x)
	dst := unsafe.Slice((*DevicePrivateDataCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDevicePrivateDataCreateInfo
func (x DevicePrivateDataCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DevicePrivateDataCreateInfo with the value of
// SType to the value provided in the specification.
func (x DevicePrivateDataCreateInfo) WithDefaultSType() DevicePrivateDataCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DevicePrivateDataCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO)
}

// WithSType clones a new DevicePrivateDataCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DevicePrivateDataCreateInfo) WithSType(y StructureType) DevicePrivateDataCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DevicePrivateDataCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDevicePrivateDataCreateInfo
func (x DevicePrivateDataCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DevicePrivateDataCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DevicePrivateDataCreateInfo) WithPNext(y unsafe.Pointer) DevicePrivateDataCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DevicePrivateDataCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// PrivateDataSlotRequestCount returns the value of privateDataSlotRequestCount from VkDevicePrivateDataCreateInfo
func (x DevicePrivateDataCreateInfo) PrivateDataSlotRequestCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.privateDataSlotRequestCount)
	return *ptr
}

// WithPrivateDataSlotRequestCount clones a new DevicePrivateDataCreateInfo with the value of
// PrivateDataSlotRequestCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DevicePrivateDataCreateInfo) WithPrivateDataSlotRequestCount(y uint32) DevicePrivateDataCreateInfo {
	x.privateDataSlotRequestCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DevicePrivateDataCreateInfo) SetPrivateDataSlotRequestCount(y uint32) {
	x.privateDataSlotRequestCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PrivateDataSlotCreateInfo provides a go interface for VkPrivateDataSlotCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPrivateDataSlotCreateInfo.html
type PrivateDataSlotCreateInfo C.struct_VkPrivateDataSlotCreateInfo

// SizeofPrivateDataSlotCreateInfo is the memory size of a PrivateDataSlotCreateInfo
var SizeofPrivateDataSlotCreateInfo int = int(unsafe.Sizeof(PrivateDataSlotCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PrivateDataSlotCreateInfo) ArpPtr(arp *AutoReleasePool) *PrivateDataSlotCreateInfo {
	ptr := newCBlock(cULong(SizeofPrivateDataSlotCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PrivateDataSlotCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PrivateDataSlotCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PrivateDataSlotCreateInfo) AsCPtr() *PrivateDataSlotCreateInfo {
	clone := (*PrivateDataSlotCreateInfo)(newCBlock(cULong(SizeofPrivateDataSlotCreateInfo)))
	*clone = x
	return clone
}

// PrivateDataSlotCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PrivateDataSlotCreateInfoCSlice(arp *AutoReleasePool, x ...PrivateDataSlotCreateInfo) []PrivateDataSlotCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPrivateDataSlotCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PrivateDataSlotCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PrivateDataSlotCreateInfoFreeCSlice releases the memory allocated by PrivateDataSlotCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PrivateDataSlotCreateInfoFreeCSlice(x []PrivateDataSlotCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PrivateDataSlotCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PrivateDataSlotCreateInfoFreeCSlice must be called on the returned slice.
func PrivateDataSlotCreateInfoMakeCSlice(x ...PrivateDataSlotCreateInfo) []PrivateDataSlotCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPrivateDataSlotCreateInfo * len(x)
	dst := unsafe.Slice((*PrivateDataSlotCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPrivateDataSlotCreateInfo
func (x PrivateDataSlotCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PrivateDataSlotCreateInfo with the value of
// SType to the value provided in the specification.
func (x PrivateDataSlotCreateInfo) WithDefaultSType() PrivateDataSlotCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PrivateDataSlotCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO)
}

// WithSType clones a new PrivateDataSlotCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PrivateDataSlotCreateInfo) WithSType(y StructureType) PrivateDataSlotCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PrivateDataSlotCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPrivateDataSlotCreateInfo
func (x PrivateDataSlotCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PrivateDataSlotCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PrivateDataSlotCreateInfo) WithPNext(y unsafe.Pointer) PrivateDataSlotCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PrivateDataSlotCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkPrivateDataSlotCreateInfo
func (x PrivateDataSlotCreateInfo) Flags() PrivateDataSlotCreateFlags {
	ptr := /* typedef */ (*PrivateDataSlotCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new PrivateDataSlotCreateInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PrivateDataSlotCreateInfo) WithFlags(y PrivateDataSlotCreateFlags) PrivateDataSlotCreateInfo {
	x.flags = *( /* typedef */ (*C.VkPrivateDataSlotCreateFlags)(&y))
	return x
}
func (x *PrivateDataSlotCreateInfo) SetFlags(y PrivateDataSlotCreateFlags) {
	x.flags = *( /* typedef */ (*C.VkPrivateDataSlotCreateFlags)(&y))
}

// PhysicalDeviceShaderDemoteToHelperInvocationFeatures provides a go interface for VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures.html
type PhysicalDeviceShaderDemoteToHelperInvocationFeatures C.struct_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures

// SizeofPhysicalDeviceShaderDemoteToHelperInvocationFeatures is the memory size of a PhysicalDeviceShaderDemoteToHelperInvocationFeatures
var SizeofPhysicalDeviceShaderDemoteToHelperInvocationFeatures int = int(unsafe.Sizeof(PhysicalDeviceShaderDemoteToHelperInvocationFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceShaderDemoteToHelperInvocationFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceShaderDemoteToHelperInvocationFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceShaderDemoteToHelperInvocationFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceShaderDemoteToHelperInvocationFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceShaderDemoteToHelperInvocationFeatures) AsCPtr() *PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
	clone := (*PhysicalDeviceShaderDemoteToHelperInvocationFeatures)(newCBlock(cULong(SizeofPhysicalDeviceShaderDemoteToHelperInvocationFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceShaderDemoteToHelperInvocationFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceShaderDemoteToHelperInvocationFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceShaderDemoteToHelperInvocationFeatures) []PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderDemoteToHelperInvocationFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceShaderDemoteToHelperInvocationFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceShaderDemoteToHelperInvocationFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceShaderDemoteToHelperInvocationFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceShaderDemoteToHelperInvocationFeaturesFreeCSlice(x []PhysicalDeviceShaderDemoteToHelperInvocationFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceShaderDemoteToHelperInvocationFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceShaderDemoteToHelperInvocationFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceShaderDemoteToHelperInvocationFeaturesMakeCSlice(x ...PhysicalDeviceShaderDemoteToHelperInvocationFeatures) []PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderDemoteToHelperInvocationFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceShaderDemoteToHelperInvocationFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures
func (x PhysicalDeviceShaderDemoteToHelperInvocationFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceShaderDemoteToHelperInvocationFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceShaderDemoteToHelperInvocationFeatures) WithDefaultSType() PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceShaderDemoteToHelperInvocationFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES)
}

// WithSType clones a new PhysicalDeviceShaderDemoteToHelperInvocationFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderDemoteToHelperInvocationFeatures) WithSType(y StructureType) PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceShaderDemoteToHelperInvocationFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures
func (x PhysicalDeviceShaderDemoteToHelperInvocationFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceShaderDemoteToHelperInvocationFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderDemoteToHelperInvocationFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceShaderDemoteToHelperInvocationFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// ShaderDemoteToHelperInvocation returns the value of shaderDemoteToHelperInvocation from VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures
func (x PhysicalDeviceShaderDemoteToHelperInvocationFeatures) ShaderDemoteToHelperInvocation() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDemoteToHelperInvocation)
	return *ptr
}

// WithShaderDemoteToHelperInvocation clones a new PhysicalDeviceShaderDemoteToHelperInvocationFeatures with the value of
// ShaderDemoteToHelperInvocation updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderDemoteToHelperInvocationFeatures) WithShaderDemoteToHelperInvocation(y Bool32) PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
	x.shaderDemoteToHelperInvocation = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceShaderDemoteToHelperInvocationFeatures) SetShaderDemoteToHelperInvocation(y Bool32) {
	x.shaderDemoteToHelperInvocation = *( /* typedef */ (*C.VkBool32)(&y))
}

// FormatProperties3 provides a go interface for VkFormatProperties3.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatProperties3.html
type FormatProperties3 C.struct_VkFormatProperties3

// SizeofFormatProperties3 is the memory size of a FormatProperties3
var SizeofFormatProperties3 int = int(unsafe.Sizeof(FormatProperties3{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x FormatProperties3) ArpPtr(arp *AutoReleasePool) *FormatProperties3 {
	ptr := newCBlock(cULong(SizeofFormatProperties3))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*FormatProperties3)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *FormatProperties3) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x FormatProperties3) AsCPtr() *FormatProperties3 {
	clone := (*FormatProperties3)(newCBlock(cULong(SizeofFormatProperties3)))
	*clone = x
	return clone
}

// FormatProperties3CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func FormatProperties3CSlice(arp *AutoReleasePool, x ...FormatProperties3) []FormatProperties3 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFormatProperties3 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*FormatProperties3)(ptr), len(x))
	copy(dst, x)
	return dst
}

// FormatProperties3FreeCSlice releases the memory allocated by FormatProperties3MakeCSlice.
// It does not free pointers stored inside the slice.
func FormatProperties3FreeCSlice(x []FormatProperties3) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// FormatProperties3MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. FormatProperties3FreeCSlice must be called on the returned slice.
func FormatProperties3MakeCSlice(x ...FormatProperties3) []FormatProperties3 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFormatProperties3 * len(x)
	dst := unsafe.Slice((*FormatProperties3)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkFormatProperties3
func (x FormatProperties3) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new FormatProperties3 with the value of
// SType to the value provided in the specification.
func (x FormatProperties3) WithDefaultSType() FormatProperties3 {
	return x.WithSType(VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *FormatProperties3) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3)
}

// WithSType clones a new FormatProperties3 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FormatProperties3) WithSType(y StructureType) FormatProperties3 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *FormatProperties3) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkFormatProperties3
func (x FormatProperties3) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new FormatProperties3 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FormatProperties3) WithPNext(y unsafe.Pointer) FormatProperties3 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *FormatProperties3) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// LinearTilingFeatures returns the value of linearTilingFeatures from VkFormatProperties3
func (x FormatProperties3) LinearTilingFeatures() FormatFeatureFlags2 {
	ptr := /* typedef */ (*FormatFeatureFlags2)(&x.linearTilingFeatures)
	return *ptr
}

// OptimalTilingFeatures returns the value of optimalTilingFeatures from VkFormatProperties3
func (x FormatProperties3) OptimalTilingFeatures() FormatFeatureFlags2 {
	ptr := /* typedef */ (*FormatFeatureFlags2)(&x.optimalTilingFeatures)
	return *ptr
}

// BufferFeatures returns the value of bufferFeatures from VkFormatProperties3
func (x FormatProperties3) BufferFeatures() FormatFeatureFlags2 {
	ptr := /* typedef */ (*FormatFeatureFlags2)(&x.bufferFeatures)
	return *ptr
}

// PhysicalDeviceVulkan13Features provides a go interface for VkPhysicalDeviceVulkan13Features.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Features.html
type PhysicalDeviceVulkan13Features C.struct_VkPhysicalDeviceVulkan13Features

// SizeofPhysicalDeviceVulkan13Features is the memory size of a PhysicalDeviceVulkan13Features
var SizeofPhysicalDeviceVulkan13Features int = int(unsafe.Sizeof(PhysicalDeviceVulkan13Features{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceVulkan13Features) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceVulkan13Features {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceVulkan13Features))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceVulkan13Features)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceVulkan13Features) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceVulkan13Features) AsCPtr() *PhysicalDeviceVulkan13Features {
	clone := (*PhysicalDeviceVulkan13Features)(newCBlock(cULong(SizeofPhysicalDeviceVulkan13Features)))
	*clone = x
	return clone
}

// PhysicalDeviceVulkan13FeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceVulkan13FeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceVulkan13Features) []PhysicalDeviceVulkan13Features {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVulkan13Features * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceVulkan13Features)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceVulkan13FeaturesFreeCSlice releases the memory allocated by PhysicalDeviceVulkan13FeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceVulkan13FeaturesFreeCSlice(x []PhysicalDeviceVulkan13Features) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceVulkan13FeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceVulkan13FeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceVulkan13FeaturesMakeCSlice(x ...PhysicalDeviceVulkan13Features) []PhysicalDeviceVulkan13Features {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVulkan13Features * len(x)
	dst := unsafe.Slice((*PhysicalDeviceVulkan13Features)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceVulkan13Features with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceVulkan13Features) WithDefaultSType() PhysicalDeviceVulkan13Features {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceVulkan13Features) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES)
}

// WithSType clones a new PhysicalDeviceVulkan13Features with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithSType(y StructureType) PhysicalDeviceVulkan13Features {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceVulkan13Features) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceVulkan13Features with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithPNext(y unsafe.Pointer) PhysicalDeviceVulkan13Features {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceVulkan13Features) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// RobustImageAccess returns the value of robustImageAccess from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) RobustImageAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.robustImageAccess)
	return *ptr
}

// WithRobustImageAccess clones a new PhysicalDeviceVulkan13Features with the value of
// RobustImageAccess updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithRobustImageAccess(y Bool32) PhysicalDeviceVulkan13Features {
	x.robustImageAccess = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan13Features) SetRobustImageAccess(y Bool32) {
	x.robustImageAccess = *( /* typedef */ (*C.VkBool32)(&y))
}

// InlineUniformBlock returns the value of inlineUniformBlock from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) InlineUniformBlock() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.inlineUniformBlock)
	return *ptr
}

// WithInlineUniformBlock clones a new PhysicalDeviceVulkan13Features with the value of
// InlineUniformBlock updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithInlineUniformBlock(y Bool32) PhysicalDeviceVulkan13Features {
	x.inlineUniformBlock = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan13Features) SetInlineUniformBlock(y Bool32) {
	x.inlineUniformBlock = *( /* typedef */ (*C.VkBool32)(&y))
}

// DescriptorBindingInlineUniformBlockUpdateAfterBind returns the value of descriptorBindingInlineUniformBlockUpdateAfterBind from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) DescriptorBindingInlineUniformBlockUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingInlineUniformBlockUpdateAfterBind)
	return *ptr
}

// WithDescriptorBindingInlineUniformBlockUpdateAfterBind clones a new PhysicalDeviceVulkan13Features with the value of
// DescriptorBindingInlineUniformBlockUpdateAfterBind updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithDescriptorBindingInlineUniformBlockUpdateAfterBind(y Bool32) PhysicalDeviceVulkan13Features {
	x.descriptorBindingInlineUniformBlockUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan13Features) SetDescriptorBindingInlineUniformBlockUpdateAfterBind(y Bool32) {
	x.descriptorBindingInlineUniformBlockUpdateAfterBind = *( /* typedef */ (*C.VkBool32)(&y))
}

// PipelineCreationCacheControl returns the value of pipelineCreationCacheControl from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) PipelineCreationCacheControl() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.pipelineCreationCacheControl)
	return *ptr
}

// WithPipelineCreationCacheControl clones a new PhysicalDeviceVulkan13Features with the value of
// PipelineCreationCacheControl updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithPipelineCreationCacheControl(y Bool32) PhysicalDeviceVulkan13Features {
	x.pipelineCreationCacheControl = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan13Features) SetPipelineCreationCacheControl(y Bool32) {
	x.pipelineCreationCacheControl = *( /* typedef */ (*C.VkBool32)(&y))
}

// PrivateData returns the value of privateData from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) PrivateData() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.privateData)
	return *ptr
}

// WithPrivateData clones a new PhysicalDeviceVulkan13Features with the value of
// PrivateData updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithPrivateData(y Bool32) PhysicalDeviceVulkan13Features {
	x.privateData = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan13Features) SetPrivateData(y Bool32) {
	x.privateData = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderDemoteToHelperInvocation returns the value of shaderDemoteToHelperInvocation from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) ShaderDemoteToHelperInvocation() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDemoteToHelperInvocation)
	return *ptr
}

// WithShaderDemoteToHelperInvocation clones a new PhysicalDeviceVulkan13Features with the value of
// ShaderDemoteToHelperInvocation updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithShaderDemoteToHelperInvocation(y Bool32) PhysicalDeviceVulkan13Features {
	x.shaderDemoteToHelperInvocation = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan13Features) SetShaderDemoteToHelperInvocation(y Bool32) {
	x.shaderDemoteToHelperInvocation = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderTerminateInvocation returns the value of shaderTerminateInvocation from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) ShaderTerminateInvocation() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderTerminateInvocation)
	return *ptr
}

// WithShaderTerminateInvocation clones a new PhysicalDeviceVulkan13Features with the value of
// ShaderTerminateInvocation updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithShaderTerminateInvocation(y Bool32) PhysicalDeviceVulkan13Features {
	x.shaderTerminateInvocation = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan13Features) SetShaderTerminateInvocation(y Bool32) {
	x.shaderTerminateInvocation = *( /* typedef */ (*C.VkBool32)(&y))
}

// SubgroupSizeControl returns the value of subgroupSizeControl from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) SubgroupSizeControl() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.subgroupSizeControl)
	return *ptr
}

// WithSubgroupSizeControl clones a new PhysicalDeviceVulkan13Features with the value of
// SubgroupSizeControl updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithSubgroupSizeControl(y Bool32) PhysicalDeviceVulkan13Features {
	x.subgroupSizeControl = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan13Features) SetSubgroupSizeControl(y Bool32) {
	x.subgroupSizeControl = *( /* typedef */ (*C.VkBool32)(&y))
}

// ComputeFullSubgroups returns the value of computeFullSubgroups from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) ComputeFullSubgroups() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.computeFullSubgroups)
	return *ptr
}

// WithComputeFullSubgroups clones a new PhysicalDeviceVulkan13Features with the value of
// ComputeFullSubgroups updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithComputeFullSubgroups(y Bool32) PhysicalDeviceVulkan13Features {
	x.computeFullSubgroups = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan13Features) SetComputeFullSubgroups(y Bool32) {
	x.computeFullSubgroups = *( /* typedef */ (*C.VkBool32)(&y))
}

// Synchronization2 returns the value of synchronization2 from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) Synchronization2() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.synchronization2)
	return *ptr
}

// WithSynchronization2 clones a new PhysicalDeviceVulkan13Features with the value of
// Synchronization2 updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithSynchronization2(y Bool32) PhysicalDeviceVulkan13Features {
	x.synchronization2 = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan13Features) SetSynchronization2(y Bool32) {
	x.synchronization2 = *( /* typedef */ (*C.VkBool32)(&y))
}

// TextureCompressionASTC_HDR returns the value of textureCompressionASTC_HDR from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) TextureCompressionASTC_HDR() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.textureCompressionASTC_HDR)
	return *ptr
}

// WithTextureCompressionASTC_HDR clones a new PhysicalDeviceVulkan13Features with the value of
// TextureCompressionASTC_HDR updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithTextureCompressionASTC_HDR(y Bool32) PhysicalDeviceVulkan13Features {
	x.textureCompressionASTC_HDR = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan13Features) SetTextureCompressionASTC_HDR(y Bool32) {
	x.textureCompressionASTC_HDR = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderZeroInitializeWorkgroupMemory returns the value of shaderZeroInitializeWorkgroupMemory from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) ShaderZeroInitializeWorkgroupMemory() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderZeroInitializeWorkgroupMemory)
	return *ptr
}

// WithShaderZeroInitializeWorkgroupMemory clones a new PhysicalDeviceVulkan13Features with the value of
// ShaderZeroInitializeWorkgroupMemory updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithShaderZeroInitializeWorkgroupMemory(y Bool32) PhysicalDeviceVulkan13Features {
	x.shaderZeroInitializeWorkgroupMemory = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan13Features) SetShaderZeroInitializeWorkgroupMemory(y Bool32) {
	x.shaderZeroInitializeWorkgroupMemory = *( /* typedef */ (*C.VkBool32)(&y))
}

// DynamicRendering returns the value of dynamicRendering from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) DynamicRendering() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.dynamicRendering)
	return *ptr
}

// WithDynamicRendering clones a new PhysicalDeviceVulkan13Features with the value of
// DynamicRendering updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithDynamicRendering(y Bool32) PhysicalDeviceVulkan13Features {
	x.dynamicRendering = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan13Features) SetDynamicRendering(y Bool32) {
	x.dynamicRendering = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderIntegerDotProduct returns the value of shaderIntegerDotProduct from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) ShaderIntegerDotProduct() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderIntegerDotProduct)
	return *ptr
}

// WithShaderIntegerDotProduct clones a new PhysicalDeviceVulkan13Features with the value of
// ShaderIntegerDotProduct updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithShaderIntegerDotProduct(y Bool32) PhysicalDeviceVulkan13Features {
	x.shaderIntegerDotProduct = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan13Features) SetShaderIntegerDotProduct(y Bool32) {
	x.shaderIntegerDotProduct = *( /* typedef */ (*C.VkBool32)(&y))
}

// Maintenance4 returns the value of maintenance4 from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) Maintenance4() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.maintenance4)
	return *ptr
}

// WithMaintenance4 clones a new PhysicalDeviceVulkan13Features with the value of
// Maintenance4 updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithMaintenance4(y Bool32) PhysicalDeviceVulkan13Features {
	x.maintenance4 = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceVulkan13Features) SetMaintenance4(y Bool32) {
	x.maintenance4 = *( /* typedef */ (*C.VkBool32)(&y))
}

// PhysicalDeviceVulkan13Properties provides a go interface for VkPhysicalDeviceVulkan13Properties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Properties.html
type PhysicalDeviceVulkan13Properties C.struct_VkPhysicalDeviceVulkan13Properties

// SizeofPhysicalDeviceVulkan13Properties is the memory size of a PhysicalDeviceVulkan13Properties
var SizeofPhysicalDeviceVulkan13Properties int = int(unsafe.Sizeof(PhysicalDeviceVulkan13Properties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceVulkan13Properties) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceVulkan13Properties {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceVulkan13Properties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceVulkan13Properties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceVulkan13Properties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceVulkan13Properties) AsCPtr() *PhysicalDeviceVulkan13Properties {
	clone := (*PhysicalDeviceVulkan13Properties)(newCBlock(cULong(SizeofPhysicalDeviceVulkan13Properties)))
	*clone = x
	return clone
}

// PhysicalDeviceVulkan13PropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceVulkan13PropertiesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceVulkan13Properties) []PhysicalDeviceVulkan13Properties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVulkan13Properties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceVulkan13Properties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceVulkan13PropertiesFreeCSlice releases the memory allocated by PhysicalDeviceVulkan13PropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceVulkan13PropertiesFreeCSlice(x []PhysicalDeviceVulkan13Properties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceVulkan13PropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceVulkan13PropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceVulkan13PropertiesMakeCSlice(x ...PhysicalDeviceVulkan13Properties) []PhysicalDeviceVulkan13Properties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVulkan13Properties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceVulkan13Properties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceVulkan13Properties with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceVulkan13Properties) WithDefaultSType() PhysicalDeviceVulkan13Properties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceVulkan13Properties) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES)
}

// WithSType clones a new PhysicalDeviceVulkan13Properties with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Properties) WithSType(y StructureType) PhysicalDeviceVulkan13Properties {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceVulkan13Properties) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceVulkan13Properties with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Properties) WithPNext(y unsafe.Pointer) PhysicalDeviceVulkan13Properties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceVulkan13Properties) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// MinSubgroupSize returns the value of minSubgroupSize from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) MinSubgroupSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.minSubgroupSize)
	return *ptr
}

// MaxSubgroupSize returns the value of maxSubgroupSize from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) MaxSubgroupSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxSubgroupSize)
	return *ptr
}

// MaxComputeWorkgroupSubgroups returns the value of maxComputeWorkgroupSubgroups from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) MaxComputeWorkgroupSubgroups() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxComputeWorkgroupSubgroups)
	return *ptr
}

// RequiredSubgroupSizeStages returns the value of requiredSubgroupSizeStages from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) RequiredSubgroupSizeStages() ShaderStageFlags {
	ptr := /* typedef */ (*ShaderStageFlags)(&x.requiredSubgroupSizeStages)
	return *ptr
}

// MaxInlineUniformBlockSize returns the value of maxInlineUniformBlockSize from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) MaxInlineUniformBlockSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxInlineUniformBlockSize)
	return *ptr
}

// MaxPerStageDescriptorInlineUniformBlocks returns the value of maxPerStageDescriptorInlineUniformBlocks from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) MaxPerStageDescriptorInlineUniformBlocks() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorInlineUniformBlocks)
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks returns the value of maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks)
	return *ptr
}

// MaxDescriptorSetInlineUniformBlocks returns the value of maxDescriptorSetInlineUniformBlocks from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) MaxDescriptorSetInlineUniformBlocks() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetInlineUniformBlocks)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindInlineUniformBlocks returns the value of maxDescriptorSetUpdateAfterBindInlineUniformBlocks from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) MaxDescriptorSetUpdateAfterBindInlineUniformBlocks() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindInlineUniformBlocks)
	return *ptr
}

// MaxInlineUniformTotalSize returns the value of maxInlineUniformTotalSize from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) MaxInlineUniformTotalSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxInlineUniformTotalSize)
	return *ptr
}

// IntegerDotProduct8BitUnsignedAccelerated returns the value of integerDotProduct8BitUnsignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct8BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct8BitUnsignedAccelerated)
	return *ptr
}

// IntegerDotProduct8BitSignedAccelerated returns the value of integerDotProduct8BitSignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct8BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct8BitSignedAccelerated)
	return *ptr
}

// IntegerDotProduct8BitMixedSignednessAccelerated returns the value of integerDotProduct8BitMixedSignednessAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct8BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct8BitMixedSignednessAccelerated)
	return *ptr
}

// IntegerDotProduct4x8BitPackedUnsignedAccelerated returns the value of integerDotProduct4x8BitPackedUnsignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct4x8BitPackedUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct4x8BitPackedUnsignedAccelerated)
	return *ptr
}

// IntegerDotProduct4x8BitPackedSignedAccelerated returns the value of integerDotProduct4x8BitPackedSignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct4x8BitPackedSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct4x8BitPackedSignedAccelerated)
	return *ptr
}

// IntegerDotProduct4x8BitPackedMixedSignednessAccelerated returns the value of integerDotProduct4x8BitPackedMixedSignednessAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct4x8BitPackedMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct4x8BitPackedMixedSignednessAccelerated)
	return *ptr
}

// IntegerDotProduct16BitUnsignedAccelerated returns the value of integerDotProduct16BitUnsignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct16BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct16BitUnsignedAccelerated)
	return *ptr
}

// IntegerDotProduct16BitSignedAccelerated returns the value of integerDotProduct16BitSignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct16BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct16BitSignedAccelerated)
	return *ptr
}

// IntegerDotProduct16BitMixedSignednessAccelerated returns the value of integerDotProduct16BitMixedSignednessAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct16BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct16BitMixedSignednessAccelerated)
	return *ptr
}

// IntegerDotProduct32BitUnsignedAccelerated returns the value of integerDotProduct32BitUnsignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct32BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct32BitUnsignedAccelerated)
	return *ptr
}

// IntegerDotProduct32BitSignedAccelerated returns the value of integerDotProduct32BitSignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct32BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct32BitSignedAccelerated)
	return *ptr
}

// IntegerDotProduct32BitMixedSignednessAccelerated returns the value of integerDotProduct32BitMixedSignednessAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct32BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct32BitMixedSignednessAccelerated)
	return *ptr
}

// IntegerDotProduct64BitUnsignedAccelerated returns the value of integerDotProduct64BitUnsignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct64BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct64BitUnsignedAccelerated)
	return *ptr
}

// IntegerDotProduct64BitSignedAccelerated returns the value of integerDotProduct64BitSignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct64BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct64BitSignedAccelerated)
	return *ptr
}

// IntegerDotProduct64BitMixedSignednessAccelerated returns the value of integerDotProduct64BitMixedSignednessAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct64BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct64BitMixedSignednessAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating8BitUnsignedAccelerated returns the value of integerDotProductAccumulatingSaturating8BitUnsignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating8BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating8BitSignedAccelerated returns the value of integerDotProductAccumulatingSaturating8BitSignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating8BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating8BitSignedAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated returns the value of integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated returns the value of integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated returns the value of integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated returns the value of integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating16BitUnsignedAccelerated returns the value of integerDotProductAccumulatingSaturating16BitUnsignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating16BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating16BitSignedAccelerated returns the value of integerDotProductAccumulatingSaturating16BitSignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating16BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating16BitSignedAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated returns the value of integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating32BitUnsignedAccelerated returns the value of integerDotProductAccumulatingSaturating32BitUnsignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating32BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating32BitSignedAccelerated returns the value of integerDotProductAccumulatingSaturating32BitSignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating32BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating32BitSignedAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated returns the value of integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating64BitUnsignedAccelerated returns the value of integerDotProductAccumulatingSaturating64BitUnsignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating64BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating64BitSignedAccelerated returns the value of integerDotProductAccumulatingSaturating64BitSignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating64BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating64BitSignedAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated returns the value of integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated)
	return *ptr
}

// StorageTexelBufferOffsetAlignmentBytes returns the value of storageTexelBufferOffsetAlignmentBytes from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) StorageTexelBufferOffsetAlignmentBytes() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.storageTexelBufferOffsetAlignmentBytes)
	return *ptr
}

// StorageTexelBufferOffsetSingleTexelAlignment returns the value of storageTexelBufferOffsetSingleTexelAlignment from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) StorageTexelBufferOffsetSingleTexelAlignment() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storageTexelBufferOffsetSingleTexelAlignment)
	return *ptr
}

// UniformTexelBufferOffsetAlignmentBytes returns the value of uniformTexelBufferOffsetAlignmentBytes from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) UniformTexelBufferOffsetAlignmentBytes() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.uniformTexelBufferOffsetAlignmentBytes)
	return *ptr
}

// UniformTexelBufferOffsetSingleTexelAlignment returns the value of uniformTexelBufferOffsetSingleTexelAlignment from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) UniformTexelBufferOffsetSingleTexelAlignment() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.uniformTexelBufferOffsetSingleTexelAlignment)
	return *ptr
}

// MaxBufferSize returns the value of maxBufferSize from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) MaxBufferSize() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.maxBufferSize)
	return *ptr
}

// PhysicalDeviceTexelBufferAlignmentProperties provides a go interface for VkPhysicalDeviceTexelBufferAlignmentProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTexelBufferAlignmentProperties.html
type PhysicalDeviceTexelBufferAlignmentProperties C.struct_VkPhysicalDeviceTexelBufferAlignmentProperties

// SizeofPhysicalDeviceTexelBufferAlignmentProperties is the memory size of a PhysicalDeviceTexelBufferAlignmentProperties
var SizeofPhysicalDeviceTexelBufferAlignmentProperties int = int(unsafe.Sizeof(PhysicalDeviceTexelBufferAlignmentProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceTexelBufferAlignmentProperties) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceTexelBufferAlignmentProperties {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceTexelBufferAlignmentProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceTexelBufferAlignmentProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceTexelBufferAlignmentProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceTexelBufferAlignmentProperties) AsCPtr() *PhysicalDeviceTexelBufferAlignmentProperties {
	clone := (*PhysicalDeviceTexelBufferAlignmentProperties)(newCBlock(cULong(SizeofPhysicalDeviceTexelBufferAlignmentProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceTexelBufferAlignmentPropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceTexelBufferAlignmentPropertiesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceTexelBufferAlignmentProperties) []PhysicalDeviceTexelBufferAlignmentProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceTexelBufferAlignmentProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceTexelBufferAlignmentProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceTexelBufferAlignmentPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceTexelBufferAlignmentPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceTexelBufferAlignmentPropertiesFreeCSlice(x []PhysicalDeviceTexelBufferAlignmentProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceTexelBufferAlignmentPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceTexelBufferAlignmentPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceTexelBufferAlignmentPropertiesMakeCSlice(x ...PhysicalDeviceTexelBufferAlignmentProperties) []PhysicalDeviceTexelBufferAlignmentProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceTexelBufferAlignmentProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceTexelBufferAlignmentProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceTexelBufferAlignmentProperties
func (x PhysicalDeviceTexelBufferAlignmentProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceTexelBufferAlignmentProperties with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceTexelBufferAlignmentProperties) WithDefaultSType() PhysicalDeviceTexelBufferAlignmentProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceTexelBufferAlignmentProperties) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES)
}

// WithSType clones a new PhysicalDeviceTexelBufferAlignmentProperties with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceTexelBufferAlignmentProperties) WithSType(y StructureType) PhysicalDeviceTexelBufferAlignmentProperties {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceTexelBufferAlignmentProperties) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceTexelBufferAlignmentProperties
func (x PhysicalDeviceTexelBufferAlignmentProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceTexelBufferAlignmentProperties with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceTexelBufferAlignmentProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceTexelBufferAlignmentProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceTexelBufferAlignmentProperties) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// StorageTexelBufferOffsetAlignmentBytes returns the value of storageTexelBufferOffsetAlignmentBytes from VkPhysicalDeviceTexelBufferAlignmentProperties
func (x PhysicalDeviceTexelBufferAlignmentProperties) StorageTexelBufferOffsetAlignmentBytes() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.storageTexelBufferOffsetAlignmentBytes)
	return *ptr
}

// StorageTexelBufferOffsetSingleTexelAlignment returns the value of storageTexelBufferOffsetSingleTexelAlignment from VkPhysicalDeviceTexelBufferAlignmentProperties
func (x PhysicalDeviceTexelBufferAlignmentProperties) StorageTexelBufferOffsetSingleTexelAlignment() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storageTexelBufferOffsetSingleTexelAlignment)
	return *ptr
}

// UniformTexelBufferOffsetAlignmentBytes returns the value of uniformTexelBufferOffsetAlignmentBytes from VkPhysicalDeviceTexelBufferAlignmentProperties
func (x PhysicalDeviceTexelBufferAlignmentProperties) UniformTexelBufferOffsetAlignmentBytes() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.uniformTexelBufferOffsetAlignmentBytes)
	return *ptr
}

// UniformTexelBufferOffsetSingleTexelAlignment returns the value of uniformTexelBufferOffsetSingleTexelAlignment from VkPhysicalDeviceTexelBufferAlignmentProperties
func (x PhysicalDeviceTexelBufferAlignmentProperties) UniformTexelBufferOffsetSingleTexelAlignment() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.uniformTexelBufferOffsetSingleTexelAlignment)
	return *ptr
}

// PhysicalDeviceShaderIntegerDotProductProperties provides a go interface for VkPhysicalDeviceShaderIntegerDotProductProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderIntegerDotProductProperties.html
type PhysicalDeviceShaderIntegerDotProductProperties C.struct_VkPhysicalDeviceShaderIntegerDotProductProperties

// SizeofPhysicalDeviceShaderIntegerDotProductProperties is the memory size of a PhysicalDeviceShaderIntegerDotProductProperties
var SizeofPhysicalDeviceShaderIntegerDotProductProperties int = int(unsafe.Sizeof(PhysicalDeviceShaderIntegerDotProductProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceShaderIntegerDotProductProperties) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceShaderIntegerDotProductProperties {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceShaderIntegerDotProductProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceShaderIntegerDotProductProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceShaderIntegerDotProductProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceShaderIntegerDotProductProperties) AsCPtr() *PhysicalDeviceShaderIntegerDotProductProperties {
	clone := (*PhysicalDeviceShaderIntegerDotProductProperties)(newCBlock(cULong(SizeofPhysicalDeviceShaderIntegerDotProductProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceShaderIntegerDotProductPropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceShaderIntegerDotProductPropertiesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceShaderIntegerDotProductProperties) []PhysicalDeviceShaderIntegerDotProductProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderIntegerDotProductProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceShaderIntegerDotProductProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceShaderIntegerDotProductPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceShaderIntegerDotProductPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceShaderIntegerDotProductPropertiesFreeCSlice(x []PhysicalDeviceShaderIntegerDotProductProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceShaderIntegerDotProductPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceShaderIntegerDotProductPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceShaderIntegerDotProductPropertiesMakeCSlice(x ...PhysicalDeviceShaderIntegerDotProductProperties) []PhysicalDeviceShaderIntegerDotProductProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderIntegerDotProductProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceShaderIntegerDotProductProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceShaderIntegerDotProductProperties with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceShaderIntegerDotProductProperties) WithDefaultSType() PhysicalDeviceShaderIntegerDotProductProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceShaderIntegerDotProductProperties) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES)
}

// WithSType clones a new PhysicalDeviceShaderIntegerDotProductProperties with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderIntegerDotProductProperties) WithSType(y StructureType) PhysicalDeviceShaderIntegerDotProductProperties {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceShaderIntegerDotProductProperties) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceShaderIntegerDotProductProperties with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderIntegerDotProductProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceShaderIntegerDotProductProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceShaderIntegerDotProductProperties) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// IntegerDotProduct8BitUnsignedAccelerated returns the value of integerDotProduct8BitUnsignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct8BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct8BitUnsignedAccelerated)
	return *ptr
}

// IntegerDotProduct8BitSignedAccelerated returns the value of integerDotProduct8BitSignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct8BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct8BitSignedAccelerated)
	return *ptr
}

// IntegerDotProduct8BitMixedSignednessAccelerated returns the value of integerDotProduct8BitMixedSignednessAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct8BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct8BitMixedSignednessAccelerated)
	return *ptr
}

// IntegerDotProduct4x8BitPackedUnsignedAccelerated returns the value of integerDotProduct4x8BitPackedUnsignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct4x8BitPackedUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct4x8BitPackedUnsignedAccelerated)
	return *ptr
}

// IntegerDotProduct4x8BitPackedSignedAccelerated returns the value of integerDotProduct4x8BitPackedSignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct4x8BitPackedSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct4x8BitPackedSignedAccelerated)
	return *ptr
}

// IntegerDotProduct4x8BitPackedMixedSignednessAccelerated returns the value of integerDotProduct4x8BitPackedMixedSignednessAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct4x8BitPackedMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct4x8BitPackedMixedSignednessAccelerated)
	return *ptr
}

// IntegerDotProduct16BitUnsignedAccelerated returns the value of integerDotProduct16BitUnsignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct16BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct16BitUnsignedAccelerated)
	return *ptr
}

// IntegerDotProduct16BitSignedAccelerated returns the value of integerDotProduct16BitSignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct16BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct16BitSignedAccelerated)
	return *ptr
}

// IntegerDotProduct16BitMixedSignednessAccelerated returns the value of integerDotProduct16BitMixedSignednessAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct16BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct16BitMixedSignednessAccelerated)
	return *ptr
}

// IntegerDotProduct32BitUnsignedAccelerated returns the value of integerDotProduct32BitUnsignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct32BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct32BitUnsignedAccelerated)
	return *ptr
}

// IntegerDotProduct32BitSignedAccelerated returns the value of integerDotProduct32BitSignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct32BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct32BitSignedAccelerated)
	return *ptr
}

// IntegerDotProduct32BitMixedSignednessAccelerated returns the value of integerDotProduct32BitMixedSignednessAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct32BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct32BitMixedSignednessAccelerated)
	return *ptr
}

// IntegerDotProduct64BitUnsignedAccelerated returns the value of integerDotProduct64BitUnsignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct64BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct64BitUnsignedAccelerated)
	return *ptr
}

// IntegerDotProduct64BitSignedAccelerated returns the value of integerDotProduct64BitSignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct64BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct64BitSignedAccelerated)
	return *ptr
}

// IntegerDotProduct64BitMixedSignednessAccelerated returns the value of integerDotProduct64BitMixedSignednessAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct64BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct64BitMixedSignednessAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating8BitUnsignedAccelerated returns the value of integerDotProductAccumulatingSaturating8BitUnsignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating8BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating8BitSignedAccelerated returns the value of integerDotProductAccumulatingSaturating8BitSignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating8BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating8BitSignedAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated returns the value of integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated returns the value of integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated returns the value of integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated returns the value of integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating16BitUnsignedAccelerated returns the value of integerDotProductAccumulatingSaturating16BitUnsignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating16BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating16BitSignedAccelerated returns the value of integerDotProductAccumulatingSaturating16BitSignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating16BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating16BitSignedAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated returns the value of integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating32BitUnsignedAccelerated returns the value of integerDotProductAccumulatingSaturating32BitUnsignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating32BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating32BitSignedAccelerated returns the value of integerDotProductAccumulatingSaturating32BitSignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating32BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating32BitSignedAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated returns the value of integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating64BitUnsignedAccelerated returns the value of integerDotProductAccumulatingSaturating64BitUnsignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating64BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating64BitSignedAccelerated returns the value of integerDotProductAccumulatingSaturating64BitSignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating64BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating64BitSignedAccelerated)
	return *ptr
}

// IntegerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated returns the value of integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated)
	return *ptr
}

// PhysicalDevicePipelineCreationCacheControlFeatures provides a go interface for VkPhysicalDevicePipelineCreationCacheControlFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePipelineCreationCacheControlFeatures.html
type PhysicalDevicePipelineCreationCacheControlFeatures C.struct_VkPhysicalDevicePipelineCreationCacheControlFeatures

// SizeofPhysicalDevicePipelineCreationCacheControlFeatures is the memory size of a PhysicalDevicePipelineCreationCacheControlFeatures
var SizeofPhysicalDevicePipelineCreationCacheControlFeatures int = int(unsafe.Sizeof(PhysicalDevicePipelineCreationCacheControlFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDevicePipelineCreationCacheControlFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDevicePipelineCreationCacheControlFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDevicePipelineCreationCacheControlFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDevicePipelineCreationCacheControlFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDevicePipelineCreationCacheControlFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDevicePipelineCreationCacheControlFeatures) AsCPtr() *PhysicalDevicePipelineCreationCacheControlFeatures {
	clone := (*PhysicalDevicePipelineCreationCacheControlFeatures)(newCBlock(cULong(SizeofPhysicalDevicePipelineCreationCacheControlFeatures)))
	*clone = x
	return clone
}

// PhysicalDevicePipelineCreationCacheControlFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDevicePipelineCreationCacheControlFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDevicePipelineCreationCacheControlFeatures) []PhysicalDevicePipelineCreationCacheControlFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDevicePipelineCreationCacheControlFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDevicePipelineCreationCacheControlFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDevicePipelineCreationCacheControlFeaturesFreeCSlice releases the memory allocated by PhysicalDevicePipelineCreationCacheControlFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDevicePipelineCreationCacheControlFeaturesFreeCSlice(x []PhysicalDevicePipelineCreationCacheControlFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDevicePipelineCreationCacheControlFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDevicePipelineCreationCacheControlFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDevicePipelineCreationCacheControlFeaturesMakeCSlice(x ...PhysicalDevicePipelineCreationCacheControlFeatures) []PhysicalDevicePipelineCreationCacheControlFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDevicePipelineCreationCacheControlFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDevicePipelineCreationCacheControlFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDevicePipelineCreationCacheControlFeatures
func (x PhysicalDevicePipelineCreationCacheControlFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDevicePipelineCreationCacheControlFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDevicePipelineCreationCacheControlFeatures) WithDefaultSType() PhysicalDevicePipelineCreationCacheControlFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDevicePipelineCreationCacheControlFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES)
}

// WithSType clones a new PhysicalDevicePipelineCreationCacheControlFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePipelineCreationCacheControlFeatures) WithSType(y StructureType) PhysicalDevicePipelineCreationCacheControlFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDevicePipelineCreationCacheControlFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDevicePipelineCreationCacheControlFeatures
func (x PhysicalDevicePipelineCreationCacheControlFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDevicePipelineCreationCacheControlFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePipelineCreationCacheControlFeatures) WithPNext(y unsafe.Pointer) PhysicalDevicePipelineCreationCacheControlFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDevicePipelineCreationCacheControlFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// PipelineCreationCacheControl returns the value of pipelineCreationCacheControl from VkPhysicalDevicePipelineCreationCacheControlFeatures
func (x PhysicalDevicePipelineCreationCacheControlFeatures) PipelineCreationCacheControl() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.pipelineCreationCacheControl)
	return *ptr
}

// WithPipelineCreationCacheControl clones a new PhysicalDevicePipelineCreationCacheControlFeatures with the value of
// PipelineCreationCacheControl updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePipelineCreationCacheControlFeatures) WithPipelineCreationCacheControl(y Bool32) PhysicalDevicePipelineCreationCacheControlFeatures {
	x.pipelineCreationCacheControl = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDevicePipelineCreationCacheControlFeatures) SetPipelineCreationCacheControl(y Bool32) {
	x.pipelineCreationCacheControl = *( /* typedef */ (*C.VkBool32)(&y))
}

// PhysicalDeviceShaderIntegerDotProductFeatures provides a go interface for VkPhysicalDeviceShaderIntegerDotProductFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderIntegerDotProductFeatures.html
type PhysicalDeviceShaderIntegerDotProductFeatures C.struct_VkPhysicalDeviceShaderIntegerDotProductFeatures

// SizeofPhysicalDeviceShaderIntegerDotProductFeatures is the memory size of a PhysicalDeviceShaderIntegerDotProductFeatures
var SizeofPhysicalDeviceShaderIntegerDotProductFeatures int = int(unsafe.Sizeof(PhysicalDeviceShaderIntegerDotProductFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceShaderIntegerDotProductFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceShaderIntegerDotProductFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceShaderIntegerDotProductFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceShaderIntegerDotProductFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceShaderIntegerDotProductFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceShaderIntegerDotProductFeatures) AsCPtr() *PhysicalDeviceShaderIntegerDotProductFeatures {
	clone := (*PhysicalDeviceShaderIntegerDotProductFeatures)(newCBlock(cULong(SizeofPhysicalDeviceShaderIntegerDotProductFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceShaderIntegerDotProductFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceShaderIntegerDotProductFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceShaderIntegerDotProductFeatures) []PhysicalDeviceShaderIntegerDotProductFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderIntegerDotProductFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceShaderIntegerDotProductFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceShaderIntegerDotProductFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceShaderIntegerDotProductFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceShaderIntegerDotProductFeaturesFreeCSlice(x []PhysicalDeviceShaderIntegerDotProductFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceShaderIntegerDotProductFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceShaderIntegerDotProductFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceShaderIntegerDotProductFeaturesMakeCSlice(x ...PhysicalDeviceShaderIntegerDotProductFeatures) []PhysicalDeviceShaderIntegerDotProductFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderIntegerDotProductFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceShaderIntegerDotProductFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceShaderIntegerDotProductFeatures
func (x PhysicalDeviceShaderIntegerDotProductFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceShaderIntegerDotProductFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceShaderIntegerDotProductFeatures) WithDefaultSType() PhysicalDeviceShaderIntegerDotProductFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceShaderIntegerDotProductFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES)
}

// WithSType clones a new PhysicalDeviceShaderIntegerDotProductFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderIntegerDotProductFeatures) WithSType(y StructureType) PhysicalDeviceShaderIntegerDotProductFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceShaderIntegerDotProductFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceShaderIntegerDotProductFeatures
func (x PhysicalDeviceShaderIntegerDotProductFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceShaderIntegerDotProductFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderIntegerDotProductFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceShaderIntegerDotProductFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceShaderIntegerDotProductFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// ShaderIntegerDotProduct returns the value of shaderIntegerDotProduct from VkPhysicalDeviceShaderIntegerDotProductFeatures
func (x PhysicalDeviceShaderIntegerDotProductFeatures) ShaderIntegerDotProduct() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderIntegerDotProduct)
	return *ptr
}

// WithShaderIntegerDotProduct clones a new PhysicalDeviceShaderIntegerDotProductFeatures with the value of
// ShaderIntegerDotProduct updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderIntegerDotProductFeatures) WithShaderIntegerDotProduct(y Bool32) PhysicalDeviceShaderIntegerDotProductFeatures {
	x.shaderIntegerDotProduct = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceShaderIntegerDotProductFeatures) SetShaderIntegerDotProduct(y Bool32) {
	x.shaderIntegerDotProduct = *( /* typedef */ (*C.VkBool32)(&y))
}

// CommandBufferInheritanceRenderingInfo provides a go interface for VkCommandBufferInheritanceRenderingInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferInheritanceRenderingInfo.html
type CommandBufferInheritanceRenderingInfo C.struct_VkCommandBufferInheritanceRenderingInfo

// SizeofCommandBufferInheritanceRenderingInfo is the memory size of a CommandBufferInheritanceRenderingInfo
var SizeofCommandBufferInheritanceRenderingInfo int = int(unsafe.Sizeof(CommandBufferInheritanceRenderingInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x CommandBufferInheritanceRenderingInfo) ArpPtr(arp *AutoReleasePool) *CommandBufferInheritanceRenderingInfo {
	ptr := newCBlock(cULong(SizeofCommandBufferInheritanceRenderingInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*CommandBufferInheritanceRenderingInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *CommandBufferInheritanceRenderingInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x CommandBufferInheritanceRenderingInfo) AsCPtr() *CommandBufferInheritanceRenderingInfo {
	clone := (*CommandBufferInheritanceRenderingInfo)(newCBlock(cULong(SizeofCommandBufferInheritanceRenderingInfo)))
	*clone = x
	return clone
}

// CommandBufferInheritanceRenderingInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func CommandBufferInheritanceRenderingInfoCSlice(arp *AutoReleasePool, x ...CommandBufferInheritanceRenderingInfo) []CommandBufferInheritanceRenderingInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCommandBufferInheritanceRenderingInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*CommandBufferInheritanceRenderingInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// CommandBufferInheritanceRenderingInfoFreeCSlice releases the memory allocated by CommandBufferInheritanceRenderingInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func CommandBufferInheritanceRenderingInfoFreeCSlice(x []CommandBufferInheritanceRenderingInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// CommandBufferInheritanceRenderingInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. CommandBufferInheritanceRenderingInfoFreeCSlice must be called on the returned slice.
func CommandBufferInheritanceRenderingInfoMakeCSlice(x ...CommandBufferInheritanceRenderingInfo) []CommandBufferInheritanceRenderingInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCommandBufferInheritanceRenderingInfo * len(x)
	dst := unsafe.Slice((*CommandBufferInheritanceRenderingInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkCommandBufferInheritanceRenderingInfo
func (x CommandBufferInheritanceRenderingInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new CommandBufferInheritanceRenderingInfo with the value of
// SType to the value provided in the specification.
func (x CommandBufferInheritanceRenderingInfo) WithDefaultSType() CommandBufferInheritanceRenderingInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *CommandBufferInheritanceRenderingInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO)
}

// WithSType clones a new CommandBufferInheritanceRenderingInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceRenderingInfo) WithSType(y StructureType) CommandBufferInheritanceRenderingInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *CommandBufferInheritanceRenderingInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkCommandBufferInheritanceRenderingInfo
func (x CommandBufferInheritanceRenderingInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new CommandBufferInheritanceRenderingInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceRenderingInfo) WithPNext(y unsafe.Pointer) CommandBufferInheritanceRenderingInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *CommandBufferInheritanceRenderingInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkCommandBufferInheritanceRenderingInfo
func (x CommandBufferInheritanceRenderingInfo) Flags() RenderingFlags {
	ptr := /* typedef */ (*RenderingFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new CommandBufferInheritanceRenderingInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceRenderingInfo) WithFlags(y RenderingFlags) CommandBufferInheritanceRenderingInfo {
	x.flags = *( /* typedef */ (*C.VkRenderingFlags)(&y))
	return x
}
func (x *CommandBufferInheritanceRenderingInfo) SetFlags(y RenderingFlags) {
	x.flags = *( /* typedef */ (*C.VkRenderingFlags)(&y))
}

// ViewMask returns the value of viewMask from VkCommandBufferInheritanceRenderingInfo
func (x CommandBufferInheritanceRenderingInfo) ViewMask() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.viewMask)
	return *ptr
}

// WithViewMask clones a new CommandBufferInheritanceRenderingInfo with the value of
// ViewMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceRenderingInfo) WithViewMask(y uint32) CommandBufferInheritanceRenderingInfo {
	x.viewMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *CommandBufferInheritanceRenderingInfo) SetViewMask(y uint32) {
	x.viewMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// ColorAttachmentCount returns the value of colorAttachmentCount from VkCommandBufferInheritanceRenderingInfo
func (x CommandBufferInheritanceRenderingInfo) ColorAttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.colorAttachmentCount)
	return *ptr
}

// WithColorAttachmentCount clones a new CommandBufferInheritanceRenderingInfo with the value of
// ColorAttachmentCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceRenderingInfo) WithColorAttachmentCount(y uint32) CommandBufferInheritanceRenderingInfo {
	x.colorAttachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *CommandBufferInheritanceRenderingInfo) SetColorAttachmentCount(y uint32) {
	x.colorAttachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PColorAttachmentFormats returns the value of pColorAttachmentFormats from VkCommandBufferInheritanceRenderingInfo
func (x CommandBufferInheritanceRenderingInfo) PColorAttachmentFormats() []Format {
	ptr := func(x **C.VkFormat) *[]Format { /* Slice */
		slc := unsafe.Slice((*Format)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pColorAttachmentFormats)
	return *ptr
}

// WithPColorAttachmentFormats clones a new CommandBufferInheritanceRenderingInfo with the value of
// PColorAttachmentFormats updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines ColorAttachmentCount as the length of this field.
// ColorAttachmentCount is updated with the length of the new value.
func (x CommandBufferInheritanceRenderingInfo) WithPColorAttachmentFormats(y []Format) CommandBufferInheritanceRenderingInfo {
	x.pColorAttachmentFormats = *(func(x *[]Format) **C.VkFormat { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkFormat)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkFormat)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithColorAttachmentCount(uint32(len(y)))
}
func (x *CommandBufferInheritanceRenderingInfo) SetPColorAttachmentFormats(y []Format) {
	x.pColorAttachmentFormats = *(func(x *[]Format) **C.VkFormat { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkFormat)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkFormat)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetColorAttachmentCount(uint32(len(y)))
}

// DepthAttachmentFormat returns the value of depthAttachmentFormat from VkCommandBufferInheritanceRenderingInfo
func (x CommandBufferInheritanceRenderingInfo) DepthAttachmentFormat() Format {
	ptr := /* typedef */ (*Format)(&x.depthAttachmentFormat)
	return *ptr
}

// WithDepthAttachmentFormat clones a new CommandBufferInheritanceRenderingInfo with the value of
// DepthAttachmentFormat updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceRenderingInfo) WithDepthAttachmentFormat(y Format) CommandBufferInheritanceRenderingInfo {
	x.depthAttachmentFormat = *( /* typedef */ (*C.VkFormat)(&y))
	return x
}
func (x *CommandBufferInheritanceRenderingInfo) SetDepthAttachmentFormat(y Format) {
	x.depthAttachmentFormat = *( /* typedef */ (*C.VkFormat)(&y))
}

// StencilAttachmentFormat returns the value of stencilAttachmentFormat from VkCommandBufferInheritanceRenderingInfo
func (x CommandBufferInheritanceRenderingInfo) StencilAttachmentFormat() Format {
	ptr := /* typedef */ (*Format)(&x.stencilAttachmentFormat)
	return *ptr
}

// WithStencilAttachmentFormat clones a new CommandBufferInheritanceRenderingInfo with the value of
// StencilAttachmentFormat updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceRenderingInfo) WithStencilAttachmentFormat(y Format) CommandBufferInheritanceRenderingInfo {
	x.stencilAttachmentFormat = *( /* typedef */ (*C.VkFormat)(&y))
	return x
}
func (x *CommandBufferInheritanceRenderingInfo) SetStencilAttachmentFormat(y Format) {
	x.stencilAttachmentFormat = *( /* typedef */ (*C.VkFormat)(&y))
}

// RasterizationSamples returns the value of rasterizationSamples from VkCommandBufferInheritanceRenderingInfo
func (x CommandBufferInheritanceRenderingInfo) RasterizationSamples() SampleCountFlagBits {
	ptr := /* typedef */ (*SampleCountFlagBits)(&x.rasterizationSamples)
	return *ptr
}

// WithRasterizationSamples clones a new CommandBufferInheritanceRenderingInfo with the value of
// RasterizationSamples updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceRenderingInfo) WithRasterizationSamples(y SampleCountFlagBits) CommandBufferInheritanceRenderingInfo {
	x.rasterizationSamples = *( /* typedef */ (*C.VkSampleCountFlagBits)(&y))
	return x
}
func (x *CommandBufferInheritanceRenderingInfo) SetRasterizationSamples(y SampleCountFlagBits) {
	x.rasterizationSamples = *( /* typedef */ (*C.VkSampleCountFlagBits)(&y))
}

// PhysicalDeviceDynamicRenderingFeatures provides a go interface for VkPhysicalDeviceDynamicRenderingFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDynamicRenderingFeatures.html
type PhysicalDeviceDynamicRenderingFeatures C.struct_VkPhysicalDeviceDynamicRenderingFeatures

// SizeofPhysicalDeviceDynamicRenderingFeatures is the memory size of a PhysicalDeviceDynamicRenderingFeatures
var SizeofPhysicalDeviceDynamicRenderingFeatures int = int(unsafe.Sizeof(PhysicalDeviceDynamicRenderingFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceDynamicRenderingFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceDynamicRenderingFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceDynamicRenderingFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceDynamicRenderingFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceDynamicRenderingFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceDynamicRenderingFeatures) AsCPtr() *PhysicalDeviceDynamicRenderingFeatures {
	clone := (*PhysicalDeviceDynamicRenderingFeatures)(newCBlock(cULong(SizeofPhysicalDeviceDynamicRenderingFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceDynamicRenderingFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceDynamicRenderingFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceDynamicRenderingFeatures) []PhysicalDeviceDynamicRenderingFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceDynamicRenderingFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceDynamicRenderingFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceDynamicRenderingFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceDynamicRenderingFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceDynamicRenderingFeaturesFreeCSlice(x []PhysicalDeviceDynamicRenderingFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceDynamicRenderingFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceDynamicRenderingFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceDynamicRenderingFeaturesMakeCSlice(x ...PhysicalDeviceDynamicRenderingFeatures) []PhysicalDeviceDynamicRenderingFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceDynamicRenderingFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceDynamicRenderingFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceDynamicRenderingFeatures
func (x PhysicalDeviceDynamicRenderingFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceDynamicRenderingFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceDynamicRenderingFeatures) WithDefaultSType() PhysicalDeviceDynamicRenderingFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceDynamicRenderingFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES)
}

// WithSType clones a new PhysicalDeviceDynamicRenderingFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDynamicRenderingFeatures) WithSType(y StructureType) PhysicalDeviceDynamicRenderingFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceDynamicRenderingFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceDynamicRenderingFeatures
func (x PhysicalDeviceDynamicRenderingFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceDynamicRenderingFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDynamicRenderingFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceDynamicRenderingFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceDynamicRenderingFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// DynamicRendering returns the value of dynamicRendering from VkPhysicalDeviceDynamicRenderingFeatures
func (x PhysicalDeviceDynamicRenderingFeatures) DynamicRendering() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.dynamicRendering)
	return *ptr
}

// WithDynamicRendering clones a new PhysicalDeviceDynamicRenderingFeatures with the value of
// DynamicRendering updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDynamicRenderingFeatures) WithDynamicRendering(y Bool32) PhysicalDeviceDynamicRenderingFeatures {
	x.dynamicRendering = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceDynamicRenderingFeatures) SetDynamicRendering(y Bool32) {
	x.dynamicRendering = *( /* typedef */ (*C.VkBool32)(&y))
}

// PipelineRenderingCreateInfo provides a go interface for VkPipelineRenderingCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRenderingCreateInfo.html
type PipelineRenderingCreateInfo C.struct_VkPipelineRenderingCreateInfo

// SizeofPipelineRenderingCreateInfo is the memory size of a PipelineRenderingCreateInfo
var SizeofPipelineRenderingCreateInfo int = int(unsafe.Sizeof(PipelineRenderingCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PipelineRenderingCreateInfo) ArpPtr(arp *AutoReleasePool) *PipelineRenderingCreateInfo {
	ptr := newCBlock(cULong(SizeofPipelineRenderingCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PipelineRenderingCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineRenderingCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineRenderingCreateInfo) AsCPtr() *PipelineRenderingCreateInfo {
	clone := (*PipelineRenderingCreateInfo)(newCBlock(cULong(SizeofPipelineRenderingCreateInfo)))
	*clone = x
	return clone
}

// PipelineRenderingCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PipelineRenderingCreateInfoCSlice(arp *AutoReleasePool, x ...PipelineRenderingCreateInfo) []PipelineRenderingCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineRenderingCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PipelineRenderingCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PipelineRenderingCreateInfoFreeCSlice releases the memory allocated by PipelineRenderingCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineRenderingCreateInfoFreeCSlice(x []PipelineRenderingCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineRenderingCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineRenderingCreateInfoFreeCSlice must be called on the returned slice.
func PipelineRenderingCreateInfoMakeCSlice(x ...PipelineRenderingCreateInfo) []PipelineRenderingCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineRenderingCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineRenderingCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineRenderingCreateInfo
func (x PipelineRenderingCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PipelineRenderingCreateInfo with the value of
// SType to the value provided in the specification.
func (x PipelineRenderingCreateInfo) WithDefaultSType() PipelineRenderingCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PipelineRenderingCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO)
}

// WithSType clones a new PipelineRenderingCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRenderingCreateInfo) WithSType(y StructureType) PipelineRenderingCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PipelineRenderingCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPipelineRenderingCreateInfo
func (x PipelineRenderingCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PipelineRenderingCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRenderingCreateInfo) WithPNext(y unsafe.Pointer) PipelineRenderingCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PipelineRenderingCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// ViewMask returns the value of viewMask from VkPipelineRenderingCreateInfo
func (x PipelineRenderingCreateInfo) ViewMask() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.viewMask)
	return *ptr
}

// WithViewMask clones a new PipelineRenderingCreateInfo with the value of
// ViewMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRenderingCreateInfo) WithViewMask(y uint32) PipelineRenderingCreateInfo {
	x.viewMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *PipelineRenderingCreateInfo) SetViewMask(y uint32) {
	x.viewMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// ColorAttachmentCount returns the value of colorAttachmentCount from VkPipelineRenderingCreateInfo
func (x PipelineRenderingCreateInfo) ColorAttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.colorAttachmentCount)
	return *ptr
}

// WithColorAttachmentCount clones a new PipelineRenderingCreateInfo with the value of
// ColorAttachmentCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRenderingCreateInfo) WithColorAttachmentCount(y uint32) PipelineRenderingCreateInfo {
	x.colorAttachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *PipelineRenderingCreateInfo) SetColorAttachmentCount(y uint32) {
	x.colorAttachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PColorAttachmentFormats returns the value of pColorAttachmentFormats from VkPipelineRenderingCreateInfo
func (x PipelineRenderingCreateInfo) PColorAttachmentFormats() []Format {
	ptr := func(x **C.VkFormat) *[]Format { /* Slice */
		slc := unsafe.Slice((*Format)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pColorAttachmentFormats)
	return *ptr
}

// WithPColorAttachmentFormats clones a new PipelineRenderingCreateInfo with the value of
// PColorAttachmentFormats updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines ColorAttachmentCount as the length of this field.
// ColorAttachmentCount is updated with the length of the new value.
func (x PipelineRenderingCreateInfo) WithPColorAttachmentFormats(y []Format) PipelineRenderingCreateInfo {
	x.pColorAttachmentFormats = *(func(x *[]Format) **C.VkFormat { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkFormat)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkFormat)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithColorAttachmentCount(uint32(len(y)))
}
func (x *PipelineRenderingCreateInfo) SetPColorAttachmentFormats(y []Format) {
	x.pColorAttachmentFormats = *(func(x *[]Format) **C.VkFormat { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkFormat)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkFormat)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetColorAttachmentCount(uint32(len(y)))
}

// DepthAttachmentFormat returns the value of depthAttachmentFormat from VkPipelineRenderingCreateInfo
func (x PipelineRenderingCreateInfo) DepthAttachmentFormat() Format {
	ptr := /* typedef */ (*Format)(&x.depthAttachmentFormat)
	return *ptr
}

// WithDepthAttachmentFormat clones a new PipelineRenderingCreateInfo with the value of
// DepthAttachmentFormat updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRenderingCreateInfo) WithDepthAttachmentFormat(y Format) PipelineRenderingCreateInfo {
	x.depthAttachmentFormat = *( /* typedef */ (*C.VkFormat)(&y))
	return x
}
func (x *PipelineRenderingCreateInfo) SetDepthAttachmentFormat(y Format) {
	x.depthAttachmentFormat = *( /* typedef */ (*C.VkFormat)(&y))
}

// StencilAttachmentFormat returns the value of stencilAttachmentFormat from VkPipelineRenderingCreateInfo
func (x PipelineRenderingCreateInfo) StencilAttachmentFormat() Format {
	ptr := /* typedef */ (*Format)(&x.stencilAttachmentFormat)
	return *ptr
}

// WithStencilAttachmentFormat clones a new PipelineRenderingCreateInfo with the value of
// StencilAttachmentFormat updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRenderingCreateInfo) WithStencilAttachmentFormat(y Format) PipelineRenderingCreateInfo {
	x.stencilAttachmentFormat = *( /* typedef */ (*C.VkFormat)(&y))
	return x
}
func (x *PipelineRenderingCreateInfo) SetStencilAttachmentFormat(y Format) {
	x.stencilAttachmentFormat = *( /* typedef */ (*C.VkFormat)(&y))
}

// RenderingAttachmentInfo provides a go interface for VkRenderingAttachmentInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingAttachmentInfo.html
type RenderingAttachmentInfo C.struct_VkRenderingAttachmentInfo

// SizeofRenderingAttachmentInfo is the memory size of a RenderingAttachmentInfo
var SizeofRenderingAttachmentInfo int = int(unsafe.Sizeof(RenderingAttachmentInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x RenderingAttachmentInfo) ArpPtr(arp *AutoReleasePool) *RenderingAttachmentInfo {
	ptr := newCBlock(cULong(SizeofRenderingAttachmentInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*RenderingAttachmentInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *RenderingAttachmentInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x RenderingAttachmentInfo) AsCPtr() *RenderingAttachmentInfo {
	clone := (*RenderingAttachmentInfo)(newCBlock(cULong(SizeofRenderingAttachmentInfo)))
	*clone = x
	return clone
}

// RenderingAttachmentInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func RenderingAttachmentInfoCSlice(arp *AutoReleasePool, x ...RenderingAttachmentInfo) []RenderingAttachmentInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderingAttachmentInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*RenderingAttachmentInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// RenderingAttachmentInfoFreeCSlice releases the memory allocated by RenderingAttachmentInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func RenderingAttachmentInfoFreeCSlice(x []RenderingAttachmentInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// RenderingAttachmentInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. RenderingAttachmentInfoFreeCSlice must be called on the returned slice.
func RenderingAttachmentInfoMakeCSlice(x ...RenderingAttachmentInfo) []RenderingAttachmentInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderingAttachmentInfo * len(x)
	dst := unsafe.Slice((*RenderingAttachmentInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkRenderingAttachmentInfo
func (x RenderingAttachmentInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new RenderingAttachmentInfo with the value of
// SType to the value provided in the specification.
func (x RenderingAttachmentInfo) WithDefaultSType() RenderingAttachmentInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *RenderingAttachmentInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO)
}

// WithSType clones a new RenderingAttachmentInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingAttachmentInfo) WithSType(y StructureType) RenderingAttachmentInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *RenderingAttachmentInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkRenderingAttachmentInfo
func (x RenderingAttachmentInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new RenderingAttachmentInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingAttachmentInfo) WithPNext(y unsafe.Pointer) RenderingAttachmentInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *RenderingAttachmentInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// ImageView returns the value of imageView from VkRenderingAttachmentInfo
func (x RenderingAttachmentInfo) ImageView() ImageView {
	ptr := /* handle */ (*ImageView)(&x.imageView)
	return *ptr
}

// WithImageView clones a new RenderingAttachmentInfo with the value of
// ImageView updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingAttachmentInfo) WithImageView(y ImageView) RenderingAttachmentInfo {
	x.imageView = *( /* handle */ (*C.VkImageView)(&y))
	return x
}
func (x *RenderingAttachmentInfo) SetImageView(y ImageView) {
	x.imageView = *( /* handle */ (*C.VkImageView)(&y))
}

// ImageLayout returns the value of imageLayout from VkRenderingAttachmentInfo
func (x RenderingAttachmentInfo) ImageLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.imageLayout)
	return *ptr
}

// WithImageLayout clones a new RenderingAttachmentInfo with the value of
// ImageLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingAttachmentInfo) WithImageLayout(y ImageLayout) RenderingAttachmentInfo {
	x.imageLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
	return x
}
func (x *RenderingAttachmentInfo) SetImageLayout(y ImageLayout) {
	x.imageLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
}

// ResolveMode returns the value of resolveMode from VkRenderingAttachmentInfo
func (x RenderingAttachmentInfo) ResolveMode() ResolveModeFlagBits {
	ptr := /* typedef */ (*ResolveModeFlagBits)(&x.resolveMode)
	return *ptr
}

// WithResolveMode clones a new RenderingAttachmentInfo with the value of
// ResolveMode updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingAttachmentInfo) WithResolveMode(y ResolveModeFlagBits) RenderingAttachmentInfo {
	x.resolveMode = *( /* typedef */ (*C.VkResolveModeFlagBits)(&y))
	return x
}
func (x *RenderingAttachmentInfo) SetResolveMode(y ResolveModeFlagBits) {
	x.resolveMode = *( /* typedef */ (*C.VkResolveModeFlagBits)(&y))
}

// ResolveImageView returns the value of resolveImageView from VkRenderingAttachmentInfo
func (x RenderingAttachmentInfo) ResolveImageView() ImageView {
	ptr := /* handle */ (*ImageView)(&x.resolveImageView)
	return *ptr
}

// WithResolveImageView clones a new RenderingAttachmentInfo with the value of
// ResolveImageView updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingAttachmentInfo) WithResolveImageView(y ImageView) RenderingAttachmentInfo {
	x.resolveImageView = *( /* handle */ (*C.VkImageView)(&y))
	return x
}
func (x *RenderingAttachmentInfo) SetResolveImageView(y ImageView) {
	x.resolveImageView = *( /* handle */ (*C.VkImageView)(&y))
}

// ResolveImageLayout returns the value of resolveImageLayout from VkRenderingAttachmentInfo
func (x RenderingAttachmentInfo) ResolveImageLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.resolveImageLayout)
	return *ptr
}

// WithResolveImageLayout clones a new RenderingAttachmentInfo with the value of
// ResolveImageLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingAttachmentInfo) WithResolveImageLayout(y ImageLayout) RenderingAttachmentInfo {
	x.resolveImageLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
	return x
}
func (x *RenderingAttachmentInfo) SetResolveImageLayout(y ImageLayout) {
	x.resolveImageLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
}

// LoadOp returns the value of loadOp from VkRenderingAttachmentInfo
func (x RenderingAttachmentInfo) LoadOp() AttachmentLoadOp {
	ptr := /* typedef */ (*AttachmentLoadOp)(&x.loadOp)
	return *ptr
}

// WithLoadOp clones a new RenderingAttachmentInfo with the value of
// LoadOp updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingAttachmentInfo) WithLoadOp(y AttachmentLoadOp) RenderingAttachmentInfo {
	x.loadOp = *( /* typedef */ (*C.VkAttachmentLoadOp)(&y))
	return x
}
func (x *RenderingAttachmentInfo) SetLoadOp(y AttachmentLoadOp) {
	x.loadOp = *( /* typedef */ (*C.VkAttachmentLoadOp)(&y))
}

// StoreOp returns the value of storeOp from VkRenderingAttachmentInfo
func (x RenderingAttachmentInfo) StoreOp() AttachmentStoreOp {
	ptr := /* typedef */ (*AttachmentStoreOp)(&x.storeOp)
	return *ptr
}

// WithStoreOp clones a new RenderingAttachmentInfo with the value of
// StoreOp updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingAttachmentInfo) WithStoreOp(y AttachmentStoreOp) RenderingAttachmentInfo {
	x.storeOp = *( /* typedef */ (*C.VkAttachmentStoreOp)(&y))
	return x
}
func (x *RenderingAttachmentInfo) SetStoreOp(y AttachmentStoreOp) {
	x.storeOp = *( /* typedef */ (*C.VkAttachmentStoreOp)(&y))
}

// ClearValue returns the value of clearValue from VkRenderingAttachmentInfo
func (x RenderingAttachmentInfo) ClearValue() ClearValue {
	ptr := /* typedef */ (*ClearValue)(&x.clearValue)
	return *ptr
}

// WithClearValue clones a new RenderingAttachmentInfo with the value of
// ClearValue updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingAttachmentInfo) WithClearValue(y ClearValue) RenderingAttachmentInfo {
	x.clearValue = *( /* typedef */ (*C.VkClearValue)(&y))
	return x
}
func (x *RenderingAttachmentInfo) SetClearValue(y ClearValue) {
	x.clearValue = *( /* typedef */ (*C.VkClearValue)(&y))
}

// RenderingInfo provides a go interface for VkRenderingInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingInfo.html
type RenderingInfo C.struct_VkRenderingInfo

// SizeofRenderingInfo is the memory size of a RenderingInfo
var SizeofRenderingInfo int = int(unsafe.Sizeof(RenderingInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x RenderingInfo) ArpPtr(arp *AutoReleasePool) *RenderingInfo {
	ptr := newCBlock(cULong(SizeofRenderingInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*RenderingInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *RenderingInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x RenderingInfo) AsCPtr() *RenderingInfo {
	clone := (*RenderingInfo)(newCBlock(cULong(SizeofRenderingInfo)))
	*clone = x
	return clone
}

// RenderingInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func RenderingInfoCSlice(arp *AutoReleasePool, x ...RenderingInfo) []RenderingInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderingInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*RenderingInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// RenderingInfoFreeCSlice releases the memory allocated by RenderingInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func RenderingInfoFreeCSlice(x []RenderingInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// RenderingInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. RenderingInfoFreeCSlice must be called on the returned slice.
func RenderingInfoMakeCSlice(x ...RenderingInfo) []RenderingInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderingInfo * len(x)
	dst := unsafe.Slice((*RenderingInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkRenderingInfo
func (x RenderingInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new RenderingInfo with the value of
// SType to the value provided in the specification.
func (x RenderingInfo) WithDefaultSType() RenderingInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_RENDERING_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *RenderingInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_RENDERING_INFO)
}

// WithSType clones a new RenderingInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingInfo) WithSType(y StructureType) RenderingInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *RenderingInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkRenderingInfo
func (x RenderingInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new RenderingInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingInfo) WithPNext(y unsafe.Pointer) RenderingInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *RenderingInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkRenderingInfo
func (x RenderingInfo) Flags() RenderingFlags {
	ptr := /* typedef */ (*RenderingFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new RenderingInfo with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingInfo) WithFlags(y RenderingFlags) RenderingInfo {
	x.flags = *( /* typedef */ (*C.VkRenderingFlags)(&y))
	return x
}
func (x *RenderingInfo) SetFlags(y RenderingFlags) {
	x.flags = *( /* typedef */ (*C.VkRenderingFlags)(&y))
}

// RenderArea returns the value of renderArea from VkRenderingInfo
func (x RenderingInfo) RenderArea() Rect2D {
	ptr := /* typedef */ (*Rect2D)(&x.renderArea)
	return *ptr
}

// WithRenderArea clones a new RenderingInfo with the value of
// RenderArea updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingInfo) WithRenderArea(y Rect2D) RenderingInfo {
	x.renderArea = *( /* typedef */ (*C.struct_VkRect2D)(&y))
	return x
}
func (x *RenderingInfo) SetRenderArea(y Rect2D) {
	x.renderArea = *( /* typedef */ (*C.struct_VkRect2D)(&y))
}

// LayerCount returns the value of layerCount from VkRenderingInfo
func (x RenderingInfo) LayerCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.layerCount)
	return *ptr
}

// WithLayerCount clones a new RenderingInfo with the value of
// LayerCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingInfo) WithLayerCount(y uint32) RenderingInfo {
	x.layerCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *RenderingInfo) SetLayerCount(y uint32) {
	x.layerCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// ViewMask returns the value of viewMask from VkRenderingInfo
func (x RenderingInfo) ViewMask() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.viewMask)
	return *ptr
}

// WithViewMask clones a new RenderingInfo with the value of
// ViewMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingInfo) WithViewMask(y uint32) RenderingInfo {
	x.viewMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *RenderingInfo) SetViewMask(y uint32) {
	x.viewMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// ColorAttachmentCount returns the value of colorAttachmentCount from VkRenderingInfo
func (x RenderingInfo) ColorAttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.colorAttachmentCount)
	return *ptr
}

// WithColorAttachmentCount clones a new RenderingInfo with the value of
// ColorAttachmentCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingInfo) WithColorAttachmentCount(y uint32) RenderingInfo {
	x.colorAttachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *RenderingInfo) SetColorAttachmentCount(y uint32) {
	x.colorAttachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PColorAttachments returns the value of pColorAttachments from VkRenderingInfo
func (x RenderingInfo) PColorAttachments() []RenderingAttachmentInfo {
	ptr := func(x **C.struct_VkRenderingAttachmentInfo) *[]RenderingAttachmentInfo { /* Slice */
		slc := unsafe.Slice((*RenderingAttachmentInfo)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pColorAttachments)
	return *ptr
}

// WithPColorAttachments clones a new RenderingInfo with the value of
// PColorAttachments updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines ColorAttachmentCount as the length of this field.
// ColorAttachmentCount is updated with the length of the new value.
func (x RenderingInfo) WithPColorAttachments(y []RenderingAttachmentInfo) RenderingInfo {
	x.pColorAttachments = *(func(x *[]RenderingAttachmentInfo) **C.struct_VkRenderingAttachmentInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkRenderingAttachmentInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkRenderingAttachmentInfo)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithColorAttachmentCount(uint32(len(y)))
}
func (x *RenderingInfo) SetPColorAttachments(y []RenderingAttachmentInfo) {
	x.pColorAttachments = *(func(x *[]RenderingAttachmentInfo) **C.struct_VkRenderingAttachmentInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkRenderingAttachmentInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkRenderingAttachmentInfo)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetColorAttachmentCount(uint32(len(y)))
}

// PDepthAttachment returns the value of pDepthAttachment from VkRenderingInfo
func (x RenderingInfo) PDepthAttachment() *RenderingAttachmentInfo {
	ptr := func(x **C.struct_VkRenderingAttachmentInfo) **RenderingAttachmentInfo { /* Pointer */
		c2g := (*RenderingAttachmentInfo)(*x)
		return &c2g
	}(&x.pDepthAttachment)
	return *ptr
}

// WithPDepthAttachment clones a new RenderingInfo with the value of
// PDepthAttachment updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingInfo) WithPDepthAttachment(y *RenderingAttachmentInfo) RenderingInfo {
	x.pDepthAttachment = *(func(x **RenderingAttachmentInfo) **C.struct_VkRenderingAttachmentInfo { /* Pointer */
		g2c := (*C.struct_VkRenderingAttachmentInfo)(*x)
		return &g2c
	}(&y))
	return x
}
func (x *RenderingInfo) SetPDepthAttachment(y *RenderingAttachmentInfo) {
	x.pDepthAttachment = *(func(x **RenderingAttachmentInfo) **C.struct_VkRenderingAttachmentInfo { /* Pointer */
		g2c := (*C.struct_VkRenderingAttachmentInfo)(*x)
		return &g2c
	}(&y))
}

// PStencilAttachment returns the value of pStencilAttachment from VkRenderingInfo
func (x RenderingInfo) PStencilAttachment() *RenderingAttachmentInfo {
	ptr := func(x **C.struct_VkRenderingAttachmentInfo) **RenderingAttachmentInfo { /* Pointer */
		c2g := (*RenderingAttachmentInfo)(*x)
		return &c2g
	}(&x.pStencilAttachment)
	return *ptr
}

// WithPStencilAttachment clones a new RenderingInfo with the value of
// PStencilAttachment updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingInfo) WithPStencilAttachment(y *RenderingAttachmentInfo) RenderingInfo {
	x.pStencilAttachment = *(func(x **RenderingAttachmentInfo) **C.struct_VkRenderingAttachmentInfo { /* Pointer */
		g2c := (*C.struct_VkRenderingAttachmentInfo)(*x)
		return &g2c
	}(&y))
	return x
}
func (x *RenderingInfo) SetPStencilAttachment(y *RenderingAttachmentInfo) {
	x.pStencilAttachment = *(func(x **RenderingAttachmentInfo) **C.struct_VkRenderingAttachmentInfo { /* Pointer */
		g2c := (*C.struct_VkRenderingAttachmentInfo)(*x)
		return &g2c
	}(&y))
}

// PhysicalDeviceTextureCompressionASTCHDRFeatures provides a go interface for VkPhysicalDeviceTextureCompressionASTCHDRFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTextureCompressionASTCHDRFeatures.html
type PhysicalDeviceTextureCompressionASTCHDRFeatures C.struct_VkPhysicalDeviceTextureCompressionASTCHDRFeatures

// SizeofPhysicalDeviceTextureCompressionASTCHDRFeatures is the memory size of a PhysicalDeviceTextureCompressionASTCHDRFeatures
var SizeofPhysicalDeviceTextureCompressionASTCHDRFeatures int = int(unsafe.Sizeof(PhysicalDeviceTextureCompressionASTCHDRFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceTextureCompressionASTCHDRFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceTextureCompressionASTCHDRFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceTextureCompressionASTCHDRFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceTextureCompressionASTCHDRFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceTextureCompressionASTCHDRFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceTextureCompressionASTCHDRFeatures) AsCPtr() *PhysicalDeviceTextureCompressionASTCHDRFeatures {
	clone := (*PhysicalDeviceTextureCompressionASTCHDRFeatures)(newCBlock(cULong(SizeofPhysicalDeviceTextureCompressionASTCHDRFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceTextureCompressionASTCHDRFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceTextureCompressionASTCHDRFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceTextureCompressionASTCHDRFeatures) []PhysicalDeviceTextureCompressionASTCHDRFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceTextureCompressionASTCHDRFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceTextureCompressionASTCHDRFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceTextureCompressionASTCHDRFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceTextureCompressionASTCHDRFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceTextureCompressionASTCHDRFeaturesFreeCSlice(x []PhysicalDeviceTextureCompressionASTCHDRFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceTextureCompressionASTCHDRFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceTextureCompressionASTCHDRFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceTextureCompressionASTCHDRFeaturesMakeCSlice(x ...PhysicalDeviceTextureCompressionASTCHDRFeatures) []PhysicalDeviceTextureCompressionASTCHDRFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceTextureCompressionASTCHDRFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceTextureCompressionASTCHDRFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceTextureCompressionASTCHDRFeatures
func (x PhysicalDeviceTextureCompressionASTCHDRFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceTextureCompressionASTCHDRFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceTextureCompressionASTCHDRFeatures) WithDefaultSType() PhysicalDeviceTextureCompressionASTCHDRFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceTextureCompressionASTCHDRFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES)
}

// WithSType clones a new PhysicalDeviceTextureCompressionASTCHDRFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceTextureCompressionASTCHDRFeatures) WithSType(y StructureType) PhysicalDeviceTextureCompressionASTCHDRFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceTextureCompressionASTCHDRFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceTextureCompressionASTCHDRFeatures
func (x PhysicalDeviceTextureCompressionASTCHDRFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceTextureCompressionASTCHDRFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceTextureCompressionASTCHDRFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceTextureCompressionASTCHDRFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceTextureCompressionASTCHDRFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// TextureCompressionASTC_HDR returns the value of textureCompressionASTC_HDR from VkPhysicalDeviceTextureCompressionASTCHDRFeatures
func (x PhysicalDeviceTextureCompressionASTCHDRFeatures) TextureCompressionASTC_HDR() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.textureCompressionASTC_HDR)
	return *ptr
}

// WithTextureCompressionASTC_HDR clones a new PhysicalDeviceTextureCompressionASTCHDRFeatures with the value of
// TextureCompressionASTC_HDR updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceTextureCompressionASTCHDRFeatures) WithTextureCompressionASTC_HDR(y Bool32) PhysicalDeviceTextureCompressionASTCHDRFeatures {
	x.textureCompressionASTC_HDR = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceTextureCompressionASTCHDRFeatures) SetTextureCompressionASTC_HDR(y Bool32) {
	x.textureCompressionASTC_HDR = *( /* typedef */ (*C.VkBool32)(&y))
}

// PhysicalDeviceInlineUniformBlockProperties provides a go interface for VkPhysicalDeviceInlineUniformBlockProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceInlineUniformBlockProperties.html
type PhysicalDeviceInlineUniformBlockProperties C.struct_VkPhysicalDeviceInlineUniformBlockProperties

// SizeofPhysicalDeviceInlineUniformBlockProperties is the memory size of a PhysicalDeviceInlineUniformBlockProperties
var SizeofPhysicalDeviceInlineUniformBlockProperties int = int(unsafe.Sizeof(PhysicalDeviceInlineUniformBlockProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceInlineUniformBlockProperties) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceInlineUniformBlockProperties {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceInlineUniformBlockProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceInlineUniformBlockProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceInlineUniformBlockProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceInlineUniformBlockProperties) AsCPtr() *PhysicalDeviceInlineUniformBlockProperties {
	clone := (*PhysicalDeviceInlineUniformBlockProperties)(newCBlock(cULong(SizeofPhysicalDeviceInlineUniformBlockProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceInlineUniformBlockPropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceInlineUniformBlockPropertiesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceInlineUniformBlockProperties) []PhysicalDeviceInlineUniformBlockProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceInlineUniformBlockProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceInlineUniformBlockProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceInlineUniformBlockPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceInlineUniformBlockPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceInlineUniformBlockPropertiesFreeCSlice(x []PhysicalDeviceInlineUniformBlockProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceInlineUniformBlockPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceInlineUniformBlockPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceInlineUniformBlockPropertiesMakeCSlice(x ...PhysicalDeviceInlineUniformBlockProperties) []PhysicalDeviceInlineUniformBlockProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceInlineUniformBlockProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceInlineUniformBlockProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceInlineUniformBlockProperties
func (x PhysicalDeviceInlineUniformBlockProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceInlineUniformBlockProperties with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceInlineUniformBlockProperties) WithDefaultSType() PhysicalDeviceInlineUniformBlockProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceInlineUniformBlockProperties) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES)
}

// WithSType clones a new PhysicalDeviceInlineUniformBlockProperties with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceInlineUniformBlockProperties) WithSType(y StructureType) PhysicalDeviceInlineUniformBlockProperties {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceInlineUniformBlockProperties) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceInlineUniformBlockProperties
func (x PhysicalDeviceInlineUniformBlockProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceInlineUniformBlockProperties with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceInlineUniformBlockProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceInlineUniformBlockProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceInlineUniformBlockProperties) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// MaxInlineUniformBlockSize returns the value of maxInlineUniformBlockSize from VkPhysicalDeviceInlineUniformBlockProperties
func (x PhysicalDeviceInlineUniformBlockProperties) MaxInlineUniformBlockSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxInlineUniformBlockSize)
	return *ptr
}

// MaxPerStageDescriptorInlineUniformBlocks returns the value of maxPerStageDescriptorInlineUniformBlocks from VkPhysicalDeviceInlineUniformBlockProperties
func (x PhysicalDeviceInlineUniformBlockProperties) MaxPerStageDescriptorInlineUniformBlocks() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorInlineUniformBlocks)
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks returns the value of maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks from VkPhysicalDeviceInlineUniformBlockProperties
func (x PhysicalDeviceInlineUniformBlockProperties) MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks)
	return *ptr
}

// MaxDescriptorSetInlineUniformBlocks returns the value of maxDescriptorSetInlineUniformBlocks from VkPhysicalDeviceInlineUniformBlockProperties
func (x PhysicalDeviceInlineUniformBlockProperties) MaxDescriptorSetInlineUniformBlocks() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetInlineUniformBlocks)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindInlineUniformBlocks returns the value of maxDescriptorSetUpdateAfterBindInlineUniformBlocks from VkPhysicalDeviceInlineUniformBlockProperties
func (x PhysicalDeviceInlineUniformBlockProperties) MaxDescriptorSetUpdateAfterBindInlineUniformBlocks() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindInlineUniformBlocks)
	return *ptr
}

// DescriptorPoolInlineUniformBlockCreateInfo provides a go interface for VkDescriptorPoolInlineUniformBlockCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolInlineUniformBlockCreateInfo.html
type DescriptorPoolInlineUniformBlockCreateInfo C.struct_VkDescriptorPoolInlineUniformBlockCreateInfo

// SizeofDescriptorPoolInlineUniformBlockCreateInfo is the memory size of a DescriptorPoolInlineUniformBlockCreateInfo
var SizeofDescriptorPoolInlineUniformBlockCreateInfo int = int(unsafe.Sizeof(DescriptorPoolInlineUniformBlockCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DescriptorPoolInlineUniformBlockCreateInfo) ArpPtr(arp *AutoReleasePool) *DescriptorPoolInlineUniformBlockCreateInfo {
	ptr := newCBlock(cULong(SizeofDescriptorPoolInlineUniformBlockCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DescriptorPoolInlineUniformBlockCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorPoolInlineUniformBlockCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorPoolInlineUniformBlockCreateInfo) AsCPtr() *DescriptorPoolInlineUniformBlockCreateInfo {
	clone := (*DescriptorPoolInlineUniformBlockCreateInfo)(newCBlock(cULong(SizeofDescriptorPoolInlineUniformBlockCreateInfo)))
	*clone = x
	return clone
}

// DescriptorPoolInlineUniformBlockCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DescriptorPoolInlineUniformBlockCreateInfoCSlice(arp *AutoReleasePool, x ...DescriptorPoolInlineUniformBlockCreateInfo) []DescriptorPoolInlineUniformBlockCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorPoolInlineUniformBlockCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DescriptorPoolInlineUniformBlockCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DescriptorPoolInlineUniformBlockCreateInfoFreeCSlice releases the memory allocated by DescriptorPoolInlineUniformBlockCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorPoolInlineUniformBlockCreateInfoFreeCSlice(x []DescriptorPoolInlineUniformBlockCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorPoolInlineUniformBlockCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorPoolInlineUniformBlockCreateInfoFreeCSlice must be called on the returned slice.
func DescriptorPoolInlineUniformBlockCreateInfoMakeCSlice(x ...DescriptorPoolInlineUniformBlockCreateInfo) []DescriptorPoolInlineUniformBlockCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorPoolInlineUniformBlockCreateInfo * len(x)
	dst := unsafe.Slice((*DescriptorPoolInlineUniformBlockCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDescriptorPoolInlineUniformBlockCreateInfo
func (x DescriptorPoolInlineUniformBlockCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DescriptorPoolInlineUniformBlockCreateInfo with the value of
// SType to the value provided in the specification.
func (x DescriptorPoolInlineUniformBlockCreateInfo) WithDefaultSType() DescriptorPoolInlineUniformBlockCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DescriptorPoolInlineUniformBlockCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO)
}

// WithSType clones a new DescriptorPoolInlineUniformBlockCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorPoolInlineUniformBlockCreateInfo) WithSType(y StructureType) DescriptorPoolInlineUniformBlockCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DescriptorPoolInlineUniformBlockCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDescriptorPoolInlineUniformBlockCreateInfo
func (x DescriptorPoolInlineUniformBlockCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DescriptorPoolInlineUniformBlockCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorPoolInlineUniformBlockCreateInfo) WithPNext(y unsafe.Pointer) DescriptorPoolInlineUniformBlockCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DescriptorPoolInlineUniformBlockCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// MaxInlineUniformBlockBindings returns the value of maxInlineUniformBlockBindings from VkDescriptorPoolInlineUniformBlockCreateInfo
func (x DescriptorPoolInlineUniformBlockCreateInfo) MaxInlineUniformBlockBindings() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxInlineUniformBlockBindings)
	return *ptr
}

// WithMaxInlineUniformBlockBindings clones a new DescriptorPoolInlineUniformBlockCreateInfo with the value of
// MaxInlineUniformBlockBindings updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorPoolInlineUniformBlockCreateInfo) WithMaxInlineUniformBlockBindings(y uint32) DescriptorPoolInlineUniformBlockCreateInfo {
	x.maxInlineUniformBlockBindings = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DescriptorPoolInlineUniformBlockCreateInfo) SetMaxInlineUniformBlockBindings(y uint32) {
	x.maxInlineUniformBlockBindings = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// DeviceImageMemoryRequirements provides a go interface for VkDeviceImageMemoryRequirements.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceImageMemoryRequirements.html
type DeviceImageMemoryRequirements C.struct_VkDeviceImageMemoryRequirements

// SizeofDeviceImageMemoryRequirements is the memory size of a DeviceImageMemoryRequirements
var SizeofDeviceImageMemoryRequirements int = int(unsafe.Sizeof(DeviceImageMemoryRequirements{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DeviceImageMemoryRequirements) ArpPtr(arp *AutoReleasePool) *DeviceImageMemoryRequirements {
	ptr := newCBlock(cULong(SizeofDeviceImageMemoryRequirements))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DeviceImageMemoryRequirements)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceImageMemoryRequirements) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceImageMemoryRequirements) AsCPtr() *DeviceImageMemoryRequirements {
	clone := (*DeviceImageMemoryRequirements)(newCBlock(cULong(SizeofDeviceImageMemoryRequirements)))
	*clone = x
	return clone
}

// DeviceImageMemoryRequirementsCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DeviceImageMemoryRequirementsCSlice(arp *AutoReleasePool, x ...DeviceImageMemoryRequirements) []DeviceImageMemoryRequirements {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceImageMemoryRequirements * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DeviceImageMemoryRequirements)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DeviceImageMemoryRequirementsFreeCSlice releases the memory allocated by DeviceImageMemoryRequirementsMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceImageMemoryRequirementsFreeCSlice(x []DeviceImageMemoryRequirements) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceImageMemoryRequirementsMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceImageMemoryRequirementsFreeCSlice must be called on the returned slice.
func DeviceImageMemoryRequirementsMakeCSlice(x ...DeviceImageMemoryRequirements) []DeviceImageMemoryRequirements {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceImageMemoryRequirements * len(x)
	dst := unsafe.Slice((*DeviceImageMemoryRequirements)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceImageMemoryRequirements
func (x DeviceImageMemoryRequirements) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DeviceImageMemoryRequirements with the value of
// SType to the value provided in the specification.
func (x DeviceImageMemoryRequirements) WithDefaultSType() DeviceImageMemoryRequirements {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DeviceImageMemoryRequirements) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS)
}

// WithSType clones a new DeviceImageMemoryRequirements with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceImageMemoryRequirements) WithSType(y StructureType) DeviceImageMemoryRequirements {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DeviceImageMemoryRequirements) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDeviceImageMemoryRequirements
func (x DeviceImageMemoryRequirements) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DeviceImageMemoryRequirements with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceImageMemoryRequirements) WithPNext(y unsafe.Pointer) DeviceImageMemoryRequirements {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DeviceImageMemoryRequirements) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// PCreateInfo returns the value of pCreateInfo from VkDeviceImageMemoryRequirements
func (x DeviceImageMemoryRequirements) PCreateInfo() *ImageCreateInfo {
	ptr := func(x **C.struct_VkImageCreateInfo) **ImageCreateInfo { /* Pointer */
		c2g := (*ImageCreateInfo)(*x)
		return &c2g
	}(&x.pCreateInfo)
	return *ptr
}

// WithPCreateInfo clones a new DeviceImageMemoryRequirements with the value of
// PCreateInfo updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceImageMemoryRequirements) WithPCreateInfo(y *ImageCreateInfo) DeviceImageMemoryRequirements {
	x.pCreateInfo = *(func(x **ImageCreateInfo) **C.struct_VkImageCreateInfo { /* Pointer */
		g2c := (*C.struct_VkImageCreateInfo)(*x)
		return &g2c
	}(&y))
	return x
}
func (x *DeviceImageMemoryRequirements) SetPCreateInfo(y *ImageCreateInfo) {
	x.pCreateInfo = *(func(x **ImageCreateInfo) **C.struct_VkImageCreateInfo { /* Pointer */
		g2c := (*C.struct_VkImageCreateInfo)(*x)
		return &g2c
	}(&y))
}

// PlaneAspect returns the value of planeAspect from VkDeviceImageMemoryRequirements
func (x DeviceImageMemoryRequirements) PlaneAspect() ImageAspectFlagBits {
	ptr := /* typedef */ (*ImageAspectFlagBits)(&x.planeAspect)
	return *ptr
}

// WithPlaneAspect clones a new DeviceImageMemoryRequirements with the value of
// PlaneAspect updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceImageMemoryRequirements) WithPlaneAspect(y ImageAspectFlagBits) DeviceImageMemoryRequirements {
	x.planeAspect = *( /* typedef */ (*C.VkImageAspectFlagBits)(&y))
	return x
}
func (x *DeviceImageMemoryRequirements) SetPlaneAspect(y ImageAspectFlagBits) {
	x.planeAspect = *( /* typedef */ (*C.VkImageAspectFlagBits)(&y))
}

// PipelineShaderStageRequiredSubgroupSizeCreateInfo provides a go interface for VkPipelineShaderStageRequiredSubgroupSizeCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageRequiredSubgroupSizeCreateInfo.html
type PipelineShaderStageRequiredSubgroupSizeCreateInfo C.struct_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo

// SizeofPipelineShaderStageRequiredSubgroupSizeCreateInfo is the memory size of a PipelineShaderStageRequiredSubgroupSizeCreateInfo
var SizeofPipelineShaderStageRequiredSubgroupSizeCreateInfo int = int(unsafe.Sizeof(PipelineShaderStageRequiredSubgroupSizeCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PipelineShaderStageRequiredSubgroupSizeCreateInfo) ArpPtr(arp *AutoReleasePool) *PipelineShaderStageRequiredSubgroupSizeCreateInfo {
	ptr := newCBlock(cULong(SizeofPipelineShaderStageRequiredSubgroupSizeCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PipelineShaderStageRequiredSubgroupSizeCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineShaderStageRequiredSubgroupSizeCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineShaderStageRequiredSubgroupSizeCreateInfo) AsCPtr() *PipelineShaderStageRequiredSubgroupSizeCreateInfo {
	clone := (*PipelineShaderStageRequiredSubgroupSizeCreateInfo)(newCBlock(cULong(SizeofPipelineShaderStageRequiredSubgroupSizeCreateInfo)))
	*clone = x
	return clone
}

// PipelineShaderStageRequiredSubgroupSizeCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PipelineShaderStageRequiredSubgroupSizeCreateInfoCSlice(arp *AutoReleasePool, x ...PipelineShaderStageRequiredSubgroupSizeCreateInfo) []PipelineShaderStageRequiredSubgroupSizeCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineShaderStageRequiredSubgroupSizeCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PipelineShaderStageRequiredSubgroupSizeCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PipelineShaderStageRequiredSubgroupSizeCreateInfoFreeCSlice releases the memory allocated by PipelineShaderStageRequiredSubgroupSizeCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineShaderStageRequiredSubgroupSizeCreateInfoFreeCSlice(x []PipelineShaderStageRequiredSubgroupSizeCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineShaderStageRequiredSubgroupSizeCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineShaderStageRequiredSubgroupSizeCreateInfoFreeCSlice must be called on the returned slice.
func PipelineShaderStageRequiredSubgroupSizeCreateInfoMakeCSlice(x ...PipelineShaderStageRequiredSubgroupSizeCreateInfo) []PipelineShaderStageRequiredSubgroupSizeCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineShaderStageRequiredSubgroupSizeCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineShaderStageRequiredSubgroupSizeCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineShaderStageRequiredSubgroupSizeCreateInfo
func (x PipelineShaderStageRequiredSubgroupSizeCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PipelineShaderStageRequiredSubgroupSizeCreateInfo with the value of
// SType to the value provided in the specification.
func (x PipelineShaderStageRequiredSubgroupSizeCreateInfo) WithDefaultSType() PipelineShaderStageRequiredSubgroupSizeCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PipelineShaderStageRequiredSubgroupSizeCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO)
}

// WithSType clones a new PipelineShaderStageRequiredSubgroupSizeCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineShaderStageRequiredSubgroupSizeCreateInfo) WithSType(y StructureType) PipelineShaderStageRequiredSubgroupSizeCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PipelineShaderStageRequiredSubgroupSizeCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPipelineShaderStageRequiredSubgroupSizeCreateInfo
func (x PipelineShaderStageRequiredSubgroupSizeCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PipelineShaderStageRequiredSubgroupSizeCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineShaderStageRequiredSubgroupSizeCreateInfo) WithPNext(y unsafe.Pointer) PipelineShaderStageRequiredSubgroupSizeCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PipelineShaderStageRequiredSubgroupSizeCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// RequiredSubgroupSize returns the value of requiredSubgroupSize from VkPipelineShaderStageRequiredSubgroupSizeCreateInfo
func (x PipelineShaderStageRequiredSubgroupSizeCreateInfo) RequiredSubgroupSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.requiredSubgroupSize)
	return *ptr
}

// PhysicalDeviceToolProperties provides a go interface for VkPhysicalDeviceToolProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceToolProperties.html
type PhysicalDeviceToolProperties C.struct_VkPhysicalDeviceToolProperties

// SizeofPhysicalDeviceToolProperties is the memory size of a PhysicalDeviceToolProperties
var SizeofPhysicalDeviceToolProperties int = int(unsafe.Sizeof(PhysicalDeviceToolProperties{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceToolProperties) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceToolProperties {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceToolProperties))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceToolProperties)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceToolProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceToolProperties) AsCPtr() *PhysicalDeviceToolProperties {
	clone := (*PhysicalDeviceToolProperties)(newCBlock(cULong(SizeofPhysicalDeviceToolProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceToolPropertiesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceToolPropertiesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceToolProperties) []PhysicalDeviceToolProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceToolProperties * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceToolProperties)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceToolPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceToolPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceToolPropertiesFreeCSlice(x []PhysicalDeviceToolProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceToolPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceToolPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceToolPropertiesMakeCSlice(x ...PhysicalDeviceToolProperties) []PhysicalDeviceToolProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceToolProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceToolProperties)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceToolProperties
func (x PhysicalDeviceToolProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceToolProperties with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceToolProperties) WithDefaultSType() PhysicalDeviceToolProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceToolProperties) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES)
}

// WithSType clones a new PhysicalDeviceToolProperties with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceToolProperties) WithSType(y StructureType) PhysicalDeviceToolProperties {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceToolProperties) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceToolProperties
func (x PhysicalDeviceToolProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceToolProperties with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceToolProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceToolProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceToolProperties) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Name returns the value of name from VkPhysicalDeviceToolProperties
func (x PhysicalDeviceToolProperties) Name() []byte {
	ptr := func(x *[VK_MAX_EXTENSION_NAME_SIZE]C.char) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_EXTENSION_NAME_SIZE)
		return &slc
	}(&x.name)
	return *ptr
}

// Version returns the value of version from VkPhysicalDeviceToolProperties
func (x PhysicalDeviceToolProperties) Version() []byte {
	ptr := func(x *[VK_MAX_EXTENSION_NAME_SIZE]C.char) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_EXTENSION_NAME_SIZE)
		return &slc
	}(&x.version)
	return *ptr
}

// Purposes returns the value of purposes from VkPhysicalDeviceToolProperties
func (x PhysicalDeviceToolProperties) Purposes() ToolPurposeFlags {
	ptr := /* typedef */ (*ToolPurposeFlags)(&x.purposes)
	return *ptr
}

// Description returns the value of description from VkPhysicalDeviceToolProperties
func (x PhysicalDeviceToolProperties) Description() []byte {
	ptr := func(x *[VK_MAX_DESCRIPTION_SIZE]C.char) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_DESCRIPTION_SIZE)
		return &slc
	}(&x.description)
	return *ptr
}

// Layer returns the value of layer from VkPhysicalDeviceToolProperties
func (x PhysicalDeviceToolProperties) Layer() []byte {
	ptr := func(x *[VK_MAX_EXTENSION_NAME_SIZE]C.char) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_EXTENSION_NAME_SIZE)
		return &slc
	}(&x.layer)
	return *ptr
}

// PipelineCreationFeedback provides a go interface for VkPipelineCreationFeedback.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreationFeedback.html
type PipelineCreationFeedback C.struct_VkPipelineCreationFeedback

// SizeofPipelineCreationFeedback is the memory size of a PipelineCreationFeedback
var SizeofPipelineCreationFeedback int = int(unsafe.Sizeof(PipelineCreationFeedback{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PipelineCreationFeedback) ArpPtr(arp *AutoReleasePool) *PipelineCreationFeedback {
	ptr := newCBlock(cULong(SizeofPipelineCreationFeedback))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PipelineCreationFeedback)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineCreationFeedback) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineCreationFeedback) AsCPtr() *PipelineCreationFeedback {
	clone := (*PipelineCreationFeedback)(newCBlock(cULong(SizeofPipelineCreationFeedback)))
	*clone = x
	return clone
}

// PipelineCreationFeedbackCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PipelineCreationFeedbackCSlice(arp *AutoReleasePool, x ...PipelineCreationFeedback) []PipelineCreationFeedback {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineCreationFeedback * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PipelineCreationFeedback)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PipelineCreationFeedbackFreeCSlice releases the memory allocated by PipelineCreationFeedbackMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineCreationFeedbackFreeCSlice(x []PipelineCreationFeedback) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineCreationFeedbackMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineCreationFeedbackFreeCSlice must be called on the returned slice.
func PipelineCreationFeedbackMakeCSlice(x ...PipelineCreationFeedback) []PipelineCreationFeedback {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineCreationFeedback * len(x)
	dst := unsafe.Slice((*PipelineCreationFeedback)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Flags returns the value of flags from VkPipelineCreationFeedback
func (x PipelineCreationFeedback) Flags() PipelineCreationFeedbackFlags {
	ptr := /* typedef */ (*PipelineCreationFeedbackFlags)(&x.flags)
	return *ptr
}

// Duration returns the value of duration from VkPipelineCreationFeedback
func (x PipelineCreationFeedback) Duration() uint64 {
	ptr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.duration)
	return *ptr
}

// PipelineCreationFeedbackCreateInfo provides a go interface for VkPipelineCreationFeedbackCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreationFeedbackCreateInfo.html
type PipelineCreationFeedbackCreateInfo C.struct_VkPipelineCreationFeedbackCreateInfo

// SizeofPipelineCreationFeedbackCreateInfo is the memory size of a PipelineCreationFeedbackCreateInfo
var SizeofPipelineCreationFeedbackCreateInfo int = int(unsafe.Sizeof(PipelineCreationFeedbackCreateInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PipelineCreationFeedbackCreateInfo) ArpPtr(arp *AutoReleasePool) *PipelineCreationFeedbackCreateInfo {
	ptr := newCBlock(cULong(SizeofPipelineCreationFeedbackCreateInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PipelineCreationFeedbackCreateInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineCreationFeedbackCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineCreationFeedbackCreateInfo) AsCPtr() *PipelineCreationFeedbackCreateInfo {
	clone := (*PipelineCreationFeedbackCreateInfo)(newCBlock(cULong(SizeofPipelineCreationFeedbackCreateInfo)))
	*clone = x
	return clone
}

// PipelineCreationFeedbackCreateInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PipelineCreationFeedbackCreateInfoCSlice(arp *AutoReleasePool, x ...PipelineCreationFeedbackCreateInfo) []PipelineCreationFeedbackCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineCreationFeedbackCreateInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PipelineCreationFeedbackCreateInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PipelineCreationFeedbackCreateInfoFreeCSlice releases the memory allocated by PipelineCreationFeedbackCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineCreationFeedbackCreateInfoFreeCSlice(x []PipelineCreationFeedbackCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineCreationFeedbackCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineCreationFeedbackCreateInfoFreeCSlice must be called on the returned slice.
func PipelineCreationFeedbackCreateInfoMakeCSlice(x ...PipelineCreationFeedbackCreateInfo) []PipelineCreationFeedbackCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineCreationFeedbackCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineCreationFeedbackCreateInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineCreationFeedbackCreateInfo
func (x PipelineCreationFeedbackCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PipelineCreationFeedbackCreateInfo with the value of
// SType to the value provided in the specification.
func (x PipelineCreationFeedbackCreateInfo) WithDefaultSType() PipelineCreationFeedbackCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PipelineCreationFeedbackCreateInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO)
}

// WithSType clones a new PipelineCreationFeedbackCreateInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCreationFeedbackCreateInfo) WithSType(y StructureType) PipelineCreationFeedbackCreateInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PipelineCreationFeedbackCreateInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPipelineCreationFeedbackCreateInfo
func (x PipelineCreationFeedbackCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PipelineCreationFeedbackCreateInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCreationFeedbackCreateInfo) WithPNext(y unsafe.Pointer) PipelineCreationFeedbackCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PipelineCreationFeedbackCreateInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// PPipelineCreationFeedback returns the value of pPipelineCreationFeedback from VkPipelineCreationFeedbackCreateInfo
func (x PipelineCreationFeedbackCreateInfo) PPipelineCreationFeedback() *PipelineCreationFeedback {
	ptr := func(x **C.struct_VkPipelineCreationFeedback) **PipelineCreationFeedback { /* Pointer */
		c2g := (*PipelineCreationFeedback)(*x)
		return &c2g
	}(&x.pPipelineCreationFeedback)
	return *ptr
}

// WithPPipelineCreationFeedback clones a new PipelineCreationFeedbackCreateInfo with the value of
// PPipelineCreationFeedback updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCreationFeedbackCreateInfo) WithPPipelineCreationFeedback(y *PipelineCreationFeedback) PipelineCreationFeedbackCreateInfo {
	x.pPipelineCreationFeedback = *(func(x **PipelineCreationFeedback) **C.struct_VkPipelineCreationFeedback { /* Pointer */
		g2c := (*C.struct_VkPipelineCreationFeedback)(*x)
		return &g2c
	}(&y))
	return x
}
func (x *PipelineCreationFeedbackCreateInfo) SetPPipelineCreationFeedback(y *PipelineCreationFeedback) {
	x.pPipelineCreationFeedback = *(func(x **PipelineCreationFeedback) **C.struct_VkPipelineCreationFeedback { /* Pointer */
		g2c := (*C.struct_VkPipelineCreationFeedback)(*x)
		return &g2c
	}(&y))
}

// PipelineStageCreationFeedbackCount returns the value of pipelineStageCreationFeedbackCount from VkPipelineCreationFeedbackCreateInfo
func (x PipelineCreationFeedbackCreateInfo) PipelineStageCreationFeedbackCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.pipelineStageCreationFeedbackCount)
	return *ptr
}

// WithPipelineStageCreationFeedbackCount clones a new PipelineCreationFeedbackCreateInfo with the value of
// PipelineStageCreationFeedbackCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCreationFeedbackCreateInfo) WithPipelineStageCreationFeedbackCount(y uint32) PipelineCreationFeedbackCreateInfo {
	x.pipelineStageCreationFeedbackCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *PipelineCreationFeedbackCreateInfo) SetPipelineStageCreationFeedbackCount(y uint32) {
	x.pipelineStageCreationFeedbackCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PPipelineStageCreationFeedbacks returns the value of pPipelineStageCreationFeedbacks from VkPipelineCreationFeedbackCreateInfo
func (x PipelineCreationFeedbackCreateInfo) PPipelineStageCreationFeedbacks() []PipelineCreationFeedback {
	ptr := func(x **C.struct_VkPipelineCreationFeedback) *[]PipelineCreationFeedback { /* Slice */
		slc := unsafe.Slice((*PipelineCreationFeedback)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pPipelineStageCreationFeedbacks)
	return *ptr
}

// WithPPipelineStageCreationFeedbacks clones a new PipelineCreationFeedbackCreateInfo with the value of
// PPipelineStageCreationFeedbacks updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines PipelineStageCreationFeedbackCount as the length of this field.
// PipelineStageCreationFeedbackCount is updated with the length of the new value.
func (x PipelineCreationFeedbackCreateInfo) WithPPipelineStageCreationFeedbacks(y []PipelineCreationFeedback) PipelineCreationFeedbackCreateInfo {
	x.pPipelineStageCreationFeedbacks = *(func(x *[]PipelineCreationFeedback) **C.struct_VkPipelineCreationFeedback { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkPipelineCreationFeedback)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkPipelineCreationFeedback)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithPipelineStageCreationFeedbackCount(uint32(len(y)))
}
func (x *PipelineCreationFeedbackCreateInfo) SetPPipelineStageCreationFeedbacks(y []PipelineCreationFeedback) {
	x.pPipelineStageCreationFeedbacks = *(func(x *[]PipelineCreationFeedback) **C.struct_VkPipelineCreationFeedback { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkPipelineCreationFeedback)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkPipelineCreationFeedback)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetPipelineStageCreationFeedbackCount(uint32(len(y)))
}

// PhysicalDeviceSubgroupSizeControlFeatures provides a go interface for VkPhysicalDeviceSubgroupSizeControlFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubgroupSizeControlFeatures.html
type PhysicalDeviceSubgroupSizeControlFeatures C.struct_VkPhysicalDeviceSubgroupSizeControlFeatures

// SizeofPhysicalDeviceSubgroupSizeControlFeatures is the memory size of a PhysicalDeviceSubgroupSizeControlFeatures
var SizeofPhysicalDeviceSubgroupSizeControlFeatures int = int(unsafe.Sizeof(PhysicalDeviceSubgroupSizeControlFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceSubgroupSizeControlFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceSubgroupSizeControlFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceSubgroupSizeControlFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceSubgroupSizeControlFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceSubgroupSizeControlFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceSubgroupSizeControlFeatures) AsCPtr() *PhysicalDeviceSubgroupSizeControlFeatures {
	clone := (*PhysicalDeviceSubgroupSizeControlFeatures)(newCBlock(cULong(SizeofPhysicalDeviceSubgroupSizeControlFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceSubgroupSizeControlFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceSubgroupSizeControlFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceSubgroupSizeControlFeatures) []PhysicalDeviceSubgroupSizeControlFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSubgroupSizeControlFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceSubgroupSizeControlFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceSubgroupSizeControlFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceSubgroupSizeControlFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceSubgroupSizeControlFeaturesFreeCSlice(x []PhysicalDeviceSubgroupSizeControlFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceSubgroupSizeControlFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceSubgroupSizeControlFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceSubgroupSizeControlFeaturesMakeCSlice(x ...PhysicalDeviceSubgroupSizeControlFeatures) []PhysicalDeviceSubgroupSizeControlFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSubgroupSizeControlFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceSubgroupSizeControlFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceSubgroupSizeControlFeatures
func (x PhysicalDeviceSubgroupSizeControlFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceSubgroupSizeControlFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceSubgroupSizeControlFeatures) WithDefaultSType() PhysicalDeviceSubgroupSizeControlFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceSubgroupSizeControlFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES)
}

// WithSType clones a new PhysicalDeviceSubgroupSizeControlFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSubgroupSizeControlFeatures) WithSType(y StructureType) PhysicalDeviceSubgroupSizeControlFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceSubgroupSizeControlFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceSubgroupSizeControlFeatures
func (x PhysicalDeviceSubgroupSizeControlFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceSubgroupSizeControlFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSubgroupSizeControlFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceSubgroupSizeControlFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceSubgroupSizeControlFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SubgroupSizeControl returns the value of subgroupSizeControl from VkPhysicalDeviceSubgroupSizeControlFeatures
func (x PhysicalDeviceSubgroupSizeControlFeatures) SubgroupSizeControl() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.subgroupSizeControl)
	return *ptr
}

// WithSubgroupSizeControl clones a new PhysicalDeviceSubgroupSizeControlFeatures with the value of
// SubgroupSizeControl updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSubgroupSizeControlFeatures) WithSubgroupSizeControl(y Bool32) PhysicalDeviceSubgroupSizeControlFeatures {
	x.subgroupSizeControl = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceSubgroupSizeControlFeatures) SetSubgroupSizeControl(y Bool32) {
	x.subgroupSizeControl = *( /* typedef */ (*C.VkBool32)(&y))
}

// ComputeFullSubgroups returns the value of computeFullSubgroups from VkPhysicalDeviceSubgroupSizeControlFeatures
func (x PhysicalDeviceSubgroupSizeControlFeatures) ComputeFullSubgroups() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.computeFullSubgroups)
	return *ptr
}

// WithComputeFullSubgroups clones a new PhysicalDeviceSubgroupSizeControlFeatures with the value of
// ComputeFullSubgroups updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSubgroupSizeControlFeatures) WithComputeFullSubgroups(y Bool32) PhysicalDeviceSubgroupSizeControlFeatures {
	x.computeFullSubgroups = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceSubgroupSizeControlFeatures) SetComputeFullSubgroups(y Bool32) {
	x.computeFullSubgroups = *( /* typedef */ (*C.VkBool32)(&y))
}

// PhysicalDeviceShaderTerminateInvocationFeatures provides a go interface for VkPhysicalDeviceShaderTerminateInvocationFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderTerminateInvocationFeatures.html
type PhysicalDeviceShaderTerminateInvocationFeatures C.struct_VkPhysicalDeviceShaderTerminateInvocationFeatures

// SizeofPhysicalDeviceShaderTerminateInvocationFeatures is the memory size of a PhysicalDeviceShaderTerminateInvocationFeatures
var SizeofPhysicalDeviceShaderTerminateInvocationFeatures int = int(unsafe.Sizeof(PhysicalDeviceShaderTerminateInvocationFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceShaderTerminateInvocationFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceShaderTerminateInvocationFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceShaderTerminateInvocationFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceShaderTerminateInvocationFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceShaderTerminateInvocationFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceShaderTerminateInvocationFeatures) AsCPtr() *PhysicalDeviceShaderTerminateInvocationFeatures {
	clone := (*PhysicalDeviceShaderTerminateInvocationFeatures)(newCBlock(cULong(SizeofPhysicalDeviceShaderTerminateInvocationFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceShaderTerminateInvocationFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceShaderTerminateInvocationFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceShaderTerminateInvocationFeatures) []PhysicalDeviceShaderTerminateInvocationFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderTerminateInvocationFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceShaderTerminateInvocationFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceShaderTerminateInvocationFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceShaderTerminateInvocationFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceShaderTerminateInvocationFeaturesFreeCSlice(x []PhysicalDeviceShaderTerminateInvocationFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceShaderTerminateInvocationFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceShaderTerminateInvocationFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceShaderTerminateInvocationFeaturesMakeCSlice(x ...PhysicalDeviceShaderTerminateInvocationFeatures) []PhysicalDeviceShaderTerminateInvocationFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderTerminateInvocationFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceShaderTerminateInvocationFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceShaderTerminateInvocationFeatures
func (x PhysicalDeviceShaderTerminateInvocationFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceShaderTerminateInvocationFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceShaderTerminateInvocationFeatures) WithDefaultSType() PhysicalDeviceShaderTerminateInvocationFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceShaderTerminateInvocationFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES)
}

// WithSType clones a new PhysicalDeviceShaderTerminateInvocationFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderTerminateInvocationFeatures) WithSType(y StructureType) PhysicalDeviceShaderTerminateInvocationFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceShaderTerminateInvocationFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceShaderTerminateInvocationFeatures
func (x PhysicalDeviceShaderTerminateInvocationFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceShaderTerminateInvocationFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderTerminateInvocationFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceShaderTerminateInvocationFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceShaderTerminateInvocationFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// ShaderTerminateInvocation returns the value of shaderTerminateInvocation from VkPhysicalDeviceShaderTerminateInvocationFeatures
func (x PhysicalDeviceShaderTerminateInvocationFeatures) ShaderTerminateInvocation() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderTerminateInvocation)
	return *ptr
}

// WithShaderTerminateInvocation clones a new PhysicalDeviceShaderTerminateInvocationFeatures with the value of
// ShaderTerminateInvocation updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderTerminateInvocationFeatures) WithShaderTerminateInvocation(y Bool32) PhysicalDeviceShaderTerminateInvocationFeatures {
	x.shaderTerminateInvocation = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceShaderTerminateInvocationFeatures) SetShaderTerminateInvocation(y Bool32) {
	x.shaderTerminateInvocation = *( /* typedef */ (*C.VkBool32)(&y))
}

// MemoryBarrier2 provides a go interface for VkMemoryBarrier2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryBarrier2.html
type MemoryBarrier2 C.struct_VkMemoryBarrier2

// SizeofMemoryBarrier2 is the memory size of a MemoryBarrier2
var SizeofMemoryBarrier2 int = int(unsafe.Sizeof(MemoryBarrier2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x MemoryBarrier2) ArpPtr(arp *AutoReleasePool) *MemoryBarrier2 {
	ptr := newCBlock(cULong(SizeofMemoryBarrier2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*MemoryBarrier2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryBarrier2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryBarrier2) AsCPtr() *MemoryBarrier2 {
	clone := (*MemoryBarrier2)(newCBlock(cULong(SizeofMemoryBarrier2)))
	*clone = x
	return clone
}

// MemoryBarrier2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func MemoryBarrier2CSlice(arp *AutoReleasePool, x ...MemoryBarrier2) []MemoryBarrier2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryBarrier2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*MemoryBarrier2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// MemoryBarrier2FreeCSlice releases the memory allocated by MemoryBarrier2MakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryBarrier2FreeCSlice(x []MemoryBarrier2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryBarrier2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryBarrier2FreeCSlice must be called on the returned slice.
func MemoryBarrier2MakeCSlice(x ...MemoryBarrier2) []MemoryBarrier2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryBarrier2 * len(x)
	dst := unsafe.Slice((*MemoryBarrier2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkMemoryBarrier2
func (x MemoryBarrier2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new MemoryBarrier2 with the value of
// SType to the value provided in the specification.
func (x MemoryBarrier2) WithDefaultSType() MemoryBarrier2 {
	return x.WithSType(VK_STRUCTURE_TYPE_MEMORY_BARRIER_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *MemoryBarrier2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_MEMORY_BARRIER_2)
}

// WithSType clones a new MemoryBarrier2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryBarrier2) WithSType(y StructureType) MemoryBarrier2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *MemoryBarrier2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkMemoryBarrier2
func (x MemoryBarrier2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new MemoryBarrier2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryBarrier2) WithPNext(y unsafe.Pointer) MemoryBarrier2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *MemoryBarrier2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SrcStageMask returns the value of srcStageMask from VkMemoryBarrier2
func (x MemoryBarrier2) SrcStageMask() PipelineStageFlags2 {
	ptr := /* typedef */ (*PipelineStageFlags2)(&x.srcStageMask)
	return *ptr
}

// WithSrcStageMask clones a new MemoryBarrier2 with the value of
// SrcStageMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryBarrier2) WithSrcStageMask(y PipelineStageFlags2) MemoryBarrier2 {
	x.srcStageMask = *( /* typedef */ (*C.VkPipelineStageFlags2)(&y))
	return x
}
func (x *MemoryBarrier2) SetSrcStageMask(y PipelineStageFlags2) {
	x.srcStageMask = *( /* typedef */ (*C.VkPipelineStageFlags2)(&y))
}

// SrcAccessMask returns the value of srcAccessMask from VkMemoryBarrier2
func (x MemoryBarrier2) SrcAccessMask() AccessFlags2 {
	ptr := /* typedef */ (*AccessFlags2)(&x.srcAccessMask)
	return *ptr
}

// WithSrcAccessMask clones a new MemoryBarrier2 with the value of
// SrcAccessMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryBarrier2) WithSrcAccessMask(y AccessFlags2) MemoryBarrier2 {
	x.srcAccessMask = *( /* typedef */ (*C.VkAccessFlags2)(&y))
	return x
}
func (x *MemoryBarrier2) SetSrcAccessMask(y AccessFlags2) {
	x.srcAccessMask = *( /* typedef */ (*C.VkAccessFlags2)(&y))
}

// DstStageMask returns the value of dstStageMask from VkMemoryBarrier2
func (x MemoryBarrier2) DstStageMask() PipelineStageFlags2 {
	ptr := /* typedef */ (*PipelineStageFlags2)(&x.dstStageMask)
	return *ptr
}

// WithDstStageMask clones a new MemoryBarrier2 with the value of
// DstStageMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryBarrier2) WithDstStageMask(y PipelineStageFlags2) MemoryBarrier2 {
	x.dstStageMask = *( /* typedef */ (*C.VkPipelineStageFlags2)(&y))
	return x
}
func (x *MemoryBarrier2) SetDstStageMask(y PipelineStageFlags2) {
	x.dstStageMask = *( /* typedef */ (*C.VkPipelineStageFlags2)(&y))
}

// DstAccessMask returns the value of dstAccessMask from VkMemoryBarrier2
func (x MemoryBarrier2) DstAccessMask() AccessFlags2 {
	ptr := /* typedef */ (*AccessFlags2)(&x.dstAccessMask)
	return *ptr
}

// WithDstAccessMask clones a new MemoryBarrier2 with the value of
// DstAccessMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryBarrier2) WithDstAccessMask(y AccessFlags2) MemoryBarrier2 {
	x.dstAccessMask = *( /* typedef */ (*C.VkAccessFlags2)(&y))
	return x
}
func (x *MemoryBarrier2) SetDstAccessMask(y AccessFlags2) {
	x.dstAccessMask = *( /* typedef */ (*C.VkAccessFlags2)(&y))
}

// BufferMemoryBarrier2 provides a go interface for VkBufferMemoryBarrier2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferMemoryBarrier2.html
type BufferMemoryBarrier2 C.struct_VkBufferMemoryBarrier2

// SizeofBufferMemoryBarrier2 is the memory size of a BufferMemoryBarrier2
var SizeofBufferMemoryBarrier2 int = int(unsafe.Sizeof(BufferMemoryBarrier2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x BufferMemoryBarrier2) ArpPtr(arp *AutoReleasePool) *BufferMemoryBarrier2 {
	ptr := newCBlock(cULong(SizeofBufferMemoryBarrier2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*BufferMemoryBarrier2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferMemoryBarrier2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferMemoryBarrier2) AsCPtr() *BufferMemoryBarrier2 {
	clone := (*BufferMemoryBarrier2)(newCBlock(cULong(SizeofBufferMemoryBarrier2)))
	*clone = x
	return clone
}

// BufferMemoryBarrier2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func BufferMemoryBarrier2CSlice(arp *AutoReleasePool, x ...BufferMemoryBarrier2) []BufferMemoryBarrier2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferMemoryBarrier2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*BufferMemoryBarrier2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// BufferMemoryBarrier2FreeCSlice releases the memory allocated by BufferMemoryBarrier2MakeCSlice.
// It does not free pointers stored inside the slice.
func BufferMemoryBarrier2FreeCSlice(x []BufferMemoryBarrier2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferMemoryBarrier2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferMemoryBarrier2FreeCSlice must be called on the returned slice.
func BufferMemoryBarrier2MakeCSlice(x ...BufferMemoryBarrier2) []BufferMemoryBarrier2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferMemoryBarrier2 * len(x)
	dst := unsafe.Slice((*BufferMemoryBarrier2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBufferMemoryBarrier2
func (x BufferMemoryBarrier2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new BufferMemoryBarrier2 with the value of
// SType to the value provided in the specification.
func (x BufferMemoryBarrier2) WithDefaultSType() BufferMemoryBarrier2 {
	return x.WithSType(VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *BufferMemoryBarrier2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2)
}

// WithSType clones a new BufferMemoryBarrier2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier2) WithSType(y StructureType) BufferMemoryBarrier2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *BufferMemoryBarrier2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkBufferMemoryBarrier2
func (x BufferMemoryBarrier2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new BufferMemoryBarrier2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier2) WithPNext(y unsafe.Pointer) BufferMemoryBarrier2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *BufferMemoryBarrier2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SrcStageMask returns the value of srcStageMask from VkBufferMemoryBarrier2
func (x BufferMemoryBarrier2) SrcStageMask() PipelineStageFlags2 {
	ptr := /* typedef */ (*PipelineStageFlags2)(&x.srcStageMask)
	return *ptr
}

// WithSrcStageMask clones a new BufferMemoryBarrier2 with the value of
// SrcStageMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier2) WithSrcStageMask(y PipelineStageFlags2) BufferMemoryBarrier2 {
	x.srcStageMask = *( /* typedef */ (*C.VkPipelineStageFlags2)(&y))
	return x
}
func (x *BufferMemoryBarrier2) SetSrcStageMask(y PipelineStageFlags2) {
	x.srcStageMask = *( /* typedef */ (*C.VkPipelineStageFlags2)(&y))
}

// SrcAccessMask returns the value of srcAccessMask from VkBufferMemoryBarrier2
func (x BufferMemoryBarrier2) SrcAccessMask() AccessFlags2 {
	ptr := /* typedef */ (*AccessFlags2)(&x.srcAccessMask)
	return *ptr
}

// WithSrcAccessMask clones a new BufferMemoryBarrier2 with the value of
// SrcAccessMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier2) WithSrcAccessMask(y AccessFlags2) BufferMemoryBarrier2 {
	x.srcAccessMask = *( /* typedef */ (*C.VkAccessFlags2)(&y))
	return x
}
func (x *BufferMemoryBarrier2) SetSrcAccessMask(y AccessFlags2) {
	x.srcAccessMask = *( /* typedef */ (*C.VkAccessFlags2)(&y))
}

// DstStageMask returns the value of dstStageMask from VkBufferMemoryBarrier2
func (x BufferMemoryBarrier2) DstStageMask() PipelineStageFlags2 {
	ptr := /* typedef */ (*PipelineStageFlags2)(&x.dstStageMask)
	return *ptr
}

// WithDstStageMask clones a new BufferMemoryBarrier2 with the value of
// DstStageMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier2) WithDstStageMask(y PipelineStageFlags2) BufferMemoryBarrier2 {
	x.dstStageMask = *( /* typedef */ (*C.VkPipelineStageFlags2)(&y))
	return x
}
func (x *BufferMemoryBarrier2) SetDstStageMask(y PipelineStageFlags2) {
	x.dstStageMask = *( /* typedef */ (*C.VkPipelineStageFlags2)(&y))
}

// DstAccessMask returns the value of dstAccessMask from VkBufferMemoryBarrier2
func (x BufferMemoryBarrier2) DstAccessMask() AccessFlags2 {
	ptr := /* typedef */ (*AccessFlags2)(&x.dstAccessMask)
	return *ptr
}

// WithDstAccessMask clones a new BufferMemoryBarrier2 with the value of
// DstAccessMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier2) WithDstAccessMask(y AccessFlags2) BufferMemoryBarrier2 {
	x.dstAccessMask = *( /* typedef */ (*C.VkAccessFlags2)(&y))
	return x
}
func (x *BufferMemoryBarrier2) SetDstAccessMask(y AccessFlags2) {
	x.dstAccessMask = *( /* typedef */ (*C.VkAccessFlags2)(&y))
}

// SrcQueueFamilyIndex returns the value of srcQueueFamilyIndex from VkBufferMemoryBarrier2
func (x BufferMemoryBarrier2) SrcQueueFamilyIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.srcQueueFamilyIndex)
	return *ptr
}

// WithSrcQueueFamilyIndex clones a new BufferMemoryBarrier2 with the value of
// SrcQueueFamilyIndex updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier2) WithSrcQueueFamilyIndex(y uint32) BufferMemoryBarrier2 {
	x.srcQueueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *BufferMemoryBarrier2) SetSrcQueueFamilyIndex(y uint32) {
	x.srcQueueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// DstQueueFamilyIndex returns the value of dstQueueFamilyIndex from VkBufferMemoryBarrier2
func (x BufferMemoryBarrier2) DstQueueFamilyIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dstQueueFamilyIndex)
	return *ptr
}

// WithDstQueueFamilyIndex clones a new BufferMemoryBarrier2 with the value of
// DstQueueFamilyIndex updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier2) WithDstQueueFamilyIndex(y uint32) BufferMemoryBarrier2 {
	x.dstQueueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *BufferMemoryBarrier2) SetDstQueueFamilyIndex(y uint32) {
	x.dstQueueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// Buffer returns the value of buffer from VkBufferMemoryBarrier2
func (x BufferMemoryBarrier2) Buffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.buffer)
	return *ptr
}

// WithBuffer clones a new BufferMemoryBarrier2 with the value of
// Buffer updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier2) WithBuffer(y Buffer) BufferMemoryBarrier2 {
	x.buffer = *( /* handle */ (*C.VkBuffer)(&y))
	return x
}
func (x *BufferMemoryBarrier2) SetBuffer(y Buffer) {
	x.buffer = *( /* handle */ (*C.VkBuffer)(&y))
}

// Offset returns the value of offset from VkBufferMemoryBarrier2
func (x BufferMemoryBarrier2) Offset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.offset)
	return *ptr
}

// WithOffset clones a new BufferMemoryBarrier2 with the value of
// Offset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier2) WithOffset(y DeviceSize) BufferMemoryBarrier2 {
	x.offset = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *BufferMemoryBarrier2) SetOffset(y DeviceSize) {
	x.offset = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// Size returns the value of size from VkBufferMemoryBarrier2
func (x BufferMemoryBarrier2) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size)
	return *ptr
}

// WithSize clones a new BufferMemoryBarrier2 with the value of
// Size updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier2) WithSize(y DeviceSize) BufferMemoryBarrier2 {
	x.size = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *BufferMemoryBarrier2) SetSize(y DeviceSize) {
	x.size = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// ImageMemoryBarrier2 provides a go interface for VkImageMemoryBarrier2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageMemoryBarrier2.html
type ImageMemoryBarrier2 C.struct_VkImageMemoryBarrier2

// SizeofImageMemoryBarrier2 is the memory size of a ImageMemoryBarrier2
var SizeofImageMemoryBarrier2 int = int(unsafe.Sizeof(ImageMemoryBarrier2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ImageMemoryBarrier2) ArpPtr(arp *AutoReleasePool) *ImageMemoryBarrier2 {
	ptr := newCBlock(cULong(SizeofImageMemoryBarrier2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ImageMemoryBarrier2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageMemoryBarrier2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageMemoryBarrier2) AsCPtr() *ImageMemoryBarrier2 {
	clone := (*ImageMemoryBarrier2)(newCBlock(cULong(SizeofImageMemoryBarrier2)))
	*clone = x
	return clone
}

// ImageMemoryBarrier2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ImageMemoryBarrier2CSlice(arp *AutoReleasePool, x ...ImageMemoryBarrier2) []ImageMemoryBarrier2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageMemoryBarrier2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ImageMemoryBarrier2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ImageMemoryBarrier2FreeCSlice releases the memory allocated by ImageMemoryBarrier2MakeCSlice.
// It does not free pointers stored inside the slice.
func ImageMemoryBarrier2FreeCSlice(x []ImageMemoryBarrier2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageMemoryBarrier2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageMemoryBarrier2FreeCSlice must be called on the returned slice.
func ImageMemoryBarrier2MakeCSlice(x ...ImageMemoryBarrier2) []ImageMemoryBarrier2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageMemoryBarrier2 * len(x)
	dst := unsafe.Slice((*ImageMemoryBarrier2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageMemoryBarrier2
func (x ImageMemoryBarrier2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ImageMemoryBarrier2 with the value of
// SType to the value provided in the specification.
func (x ImageMemoryBarrier2) WithDefaultSType() ImageMemoryBarrier2 {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ImageMemoryBarrier2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2)
}

// WithSType clones a new ImageMemoryBarrier2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier2) WithSType(y StructureType) ImageMemoryBarrier2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ImageMemoryBarrier2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkImageMemoryBarrier2
func (x ImageMemoryBarrier2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ImageMemoryBarrier2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier2) WithPNext(y unsafe.Pointer) ImageMemoryBarrier2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ImageMemoryBarrier2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SrcStageMask returns the value of srcStageMask from VkImageMemoryBarrier2
func (x ImageMemoryBarrier2) SrcStageMask() PipelineStageFlags2 {
	ptr := /* typedef */ (*PipelineStageFlags2)(&x.srcStageMask)
	return *ptr
}

// WithSrcStageMask clones a new ImageMemoryBarrier2 with the value of
// SrcStageMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier2) WithSrcStageMask(y PipelineStageFlags2) ImageMemoryBarrier2 {
	x.srcStageMask = *( /* typedef */ (*C.VkPipelineStageFlags2)(&y))
	return x
}
func (x *ImageMemoryBarrier2) SetSrcStageMask(y PipelineStageFlags2) {
	x.srcStageMask = *( /* typedef */ (*C.VkPipelineStageFlags2)(&y))
}

// SrcAccessMask returns the value of srcAccessMask from VkImageMemoryBarrier2
func (x ImageMemoryBarrier2) SrcAccessMask() AccessFlags2 {
	ptr := /* typedef */ (*AccessFlags2)(&x.srcAccessMask)
	return *ptr
}

// WithSrcAccessMask clones a new ImageMemoryBarrier2 with the value of
// SrcAccessMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier2) WithSrcAccessMask(y AccessFlags2) ImageMemoryBarrier2 {
	x.srcAccessMask = *( /* typedef */ (*C.VkAccessFlags2)(&y))
	return x
}
func (x *ImageMemoryBarrier2) SetSrcAccessMask(y AccessFlags2) {
	x.srcAccessMask = *( /* typedef */ (*C.VkAccessFlags2)(&y))
}

// DstStageMask returns the value of dstStageMask from VkImageMemoryBarrier2
func (x ImageMemoryBarrier2) DstStageMask() PipelineStageFlags2 {
	ptr := /* typedef */ (*PipelineStageFlags2)(&x.dstStageMask)
	return *ptr
}

// WithDstStageMask clones a new ImageMemoryBarrier2 with the value of
// DstStageMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier2) WithDstStageMask(y PipelineStageFlags2) ImageMemoryBarrier2 {
	x.dstStageMask = *( /* typedef */ (*C.VkPipelineStageFlags2)(&y))
	return x
}
func (x *ImageMemoryBarrier2) SetDstStageMask(y PipelineStageFlags2) {
	x.dstStageMask = *( /* typedef */ (*C.VkPipelineStageFlags2)(&y))
}

// DstAccessMask returns the value of dstAccessMask from VkImageMemoryBarrier2
func (x ImageMemoryBarrier2) DstAccessMask() AccessFlags2 {
	ptr := /* typedef */ (*AccessFlags2)(&x.dstAccessMask)
	return *ptr
}

// WithDstAccessMask clones a new ImageMemoryBarrier2 with the value of
// DstAccessMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier2) WithDstAccessMask(y AccessFlags2) ImageMemoryBarrier2 {
	x.dstAccessMask = *( /* typedef */ (*C.VkAccessFlags2)(&y))
	return x
}
func (x *ImageMemoryBarrier2) SetDstAccessMask(y AccessFlags2) {
	x.dstAccessMask = *( /* typedef */ (*C.VkAccessFlags2)(&y))
}

// OldLayout returns the value of oldLayout from VkImageMemoryBarrier2
func (x ImageMemoryBarrier2) OldLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.oldLayout)
	return *ptr
}

// WithOldLayout clones a new ImageMemoryBarrier2 with the value of
// OldLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier2) WithOldLayout(y ImageLayout) ImageMemoryBarrier2 {
	x.oldLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
	return x
}
func (x *ImageMemoryBarrier2) SetOldLayout(y ImageLayout) {
	x.oldLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
}

// NewLayout returns the value of newLayout from VkImageMemoryBarrier2
func (x ImageMemoryBarrier2) NewLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.newLayout)
	return *ptr
}

// WithNewLayout clones a new ImageMemoryBarrier2 with the value of
// NewLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier2) WithNewLayout(y ImageLayout) ImageMemoryBarrier2 {
	x.newLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
	return x
}
func (x *ImageMemoryBarrier2) SetNewLayout(y ImageLayout) {
	x.newLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
}

// SrcQueueFamilyIndex returns the value of srcQueueFamilyIndex from VkImageMemoryBarrier2
func (x ImageMemoryBarrier2) SrcQueueFamilyIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.srcQueueFamilyIndex)
	return *ptr
}

// WithSrcQueueFamilyIndex clones a new ImageMemoryBarrier2 with the value of
// SrcQueueFamilyIndex updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier2) WithSrcQueueFamilyIndex(y uint32) ImageMemoryBarrier2 {
	x.srcQueueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *ImageMemoryBarrier2) SetSrcQueueFamilyIndex(y uint32) {
	x.srcQueueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// DstQueueFamilyIndex returns the value of dstQueueFamilyIndex from VkImageMemoryBarrier2
func (x ImageMemoryBarrier2) DstQueueFamilyIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dstQueueFamilyIndex)
	return *ptr
}

// WithDstQueueFamilyIndex clones a new ImageMemoryBarrier2 with the value of
// DstQueueFamilyIndex updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier2) WithDstQueueFamilyIndex(y uint32) ImageMemoryBarrier2 {
	x.dstQueueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *ImageMemoryBarrier2) SetDstQueueFamilyIndex(y uint32) {
	x.dstQueueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// Image returns the value of image from VkImageMemoryBarrier2
func (x ImageMemoryBarrier2) Image() Image {
	ptr := /* handle */ (*Image)(&x.image)
	return *ptr
}

// WithImage clones a new ImageMemoryBarrier2 with the value of
// Image updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier2) WithImage(y Image) ImageMemoryBarrier2 {
	x.image = *( /* handle */ (*C.VkImage)(&y))
	return x
}
func (x *ImageMemoryBarrier2) SetImage(y Image) {
	x.image = *( /* handle */ (*C.VkImage)(&y))
}

// SubresourceRange returns the value of subresourceRange from VkImageMemoryBarrier2
func (x ImageMemoryBarrier2) SubresourceRange() ImageSubresourceRange {
	ptr := /* typedef */ (*ImageSubresourceRange)(&x.subresourceRange)
	return *ptr
}

// WithSubresourceRange clones a new ImageMemoryBarrier2 with the value of
// SubresourceRange updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier2) WithSubresourceRange(y ImageSubresourceRange) ImageMemoryBarrier2 {
	x.subresourceRange = *( /* typedef */ (*C.struct_VkImageSubresourceRange)(&y))
	return x
}
func (x *ImageMemoryBarrier2) SetSubresourceRange(y ImageSubresourceRange) {
	x.subresourceRange = *( /* typedef */ (*C.struct_VkImageSubresourceRange)(&y))
}

// DependencyInfo provides a go interface for VkDependencyInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDependencyInfo.html
type DependencyInfo C.struct_VkDependencyInfo

// SizeofDependencyInfo is the memory size of a DependencyInfo
var SizeofDependencyInfo int = int(unsafe.Sizeof(DependencyInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DependencyInfo) ArpPtr(arp *AutoReleasePool) *DependencyInfo {
	ptr := newCBlock(cULong(SizeofDependencyInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DependencyInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DependencyInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DependencyInfo) AsCPtr() *DependencyInfo {
	clone := (*DependencyInfo)(newCBlock(cULong(SizeofDependencyInfo)))
	*clone = x
	return clone
}

// DependencyInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DependencyInfoCSlice(arp *AutoReleasePool, x ...DependencyInfo) []DependencyInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDependencyInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DependencyInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DependencyInfoFreeCSlice releases the memory allocated by DependencyInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DependencyInfoFreeCSlice(x []DependencyInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DependencyInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DependencyInfoFreeCSlice must be called on the returned slice.
func DependencyInfoMakeCSlice(x ...DependencyInfo) []DependencyInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDependencyInfo * len(x)
	dst := unsafe.Slice((*DependencyInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDependencyInfo
func (x DependencyInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DependencyInfo with the value of
// SType to the value provided in the specification.
func (x DependencyInfo) WithDefaultSType() DependencyInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEPENDENCY_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DependencyInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DEPENDENCY_INFO)
}

// WithSType clones a new DependencyInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DependencyInfo) WithSType(y StructureType) DependencyInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DependencyInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDependencyInfo
func (x DependencyInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DependencyInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DependencyInfo) WithPNext(y unsafe.Pointer) DependencyInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DependencyInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// DependencyFlags returns the value of dependencyFlags from VkDependencyInfo
func (x DependencyInfo) DependencyFlags() DependencyFlags {
	ptr := /* typedef */ (*DependencyFlags)(&x.dependencyFlags)
	return *ptr
}

// WithDependencyFlags clones a new DependencyInfo with the value of
// DependencyFlags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DependencyInfo) WithDependencyFlags(y DependencyFlags) DependencyInfo {
	x.dependencyFlags = *( /* typedef */ (*C.VkDependencyFlags)(&y))
	return x
}
func (x *DependencyInfo) SetDependencyFlags(y DependencyFlags) {
	x.dependencyFlags = *( /* typedef */ (*C.VkDependencyFlags)(&y))
}

// MemoryBarrierCount returns the value of memoryBarrierCount from VkDependencyInfo
func (x DependencyInfo) MemoryBarrierCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.memoryBarrierCount)
	return *ptr
}

// WithMemoryBarrierCount clones a new DependencyInfo with the value of
// MemoryBarrierCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DependencyInfo) WithMemoryBarrierCount(y uint32) DependencyInfo {
	x.memoryBarrierCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DependencyInfo) SetMemoryBarrierCount(y uint32) {
	x.memoryBarrierCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PMemoryBarriers returns the value of pMemoryBarriers from VkDependencyInfo
func (x DependencyInfo) PMemoryBarriers() []MemoryBarrier2 {
	ptr := func(x **C.struct_VkMemoryBarrier2) *[]MemoryBarrier2 { /* Slice */
		slc := unsafe.Slice((*MemoryBarrier2)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pMemoryBarriers)
	return *ptr
}

// WithPMemoryBarriers clones a new DependencyInfo with the value of
// PMemoryBarriers updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines MemoryBarrierCount as the length of this field.
// MemoryBarrierCount is updated with the length of the new value.
func (x DependencyInfo) WithPMemoryBarriers(y []MemoryBarrier2) DependencyInfo {
	x.pMemoryBarriers = *(func(x *[]MemoryBarrier2) **C.struct_VkMemoryBarrier2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkMemoryBarrier2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkMemoryBarrier2)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithMemoryBarrierCount(uint32(len(y)))
}
func (x *DependencyInfo) SetPMemoryBarriers(y []MemoryBarrier2) {
	x.pMemoryBarriers = *(func(x *[]MemoryBarrier2) **C.struct_VkMemoryBarrier2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkMemoryBarrier2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkMemoryBarrier2)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetMemoryBarrierCount(uint32(len(y)))
}

// BufferMemoryBarrierCount returns the value of bufferMemoryBarrierCount from VkDependencyInfo
func (x DependencyInfo) BufferMemoryBarrierCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.bufferMemoryBarrierCount)
	return *ptr
}

// WithBufferMemoryBarrierCount clones a new DependencyInfo with the value of
// BufferMemoryBarrierCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DependencyInfo) WithBufferMemoryBarrierCount(y uint32) DependencyInfo {
	x.bufferMemoryBarrierCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DependencyInfo) SetBufferMemoryBarrierCount(y uint32) {
	x.bufferMemoryBarrierCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PBufferMemoryBarriers returns the value of pBufferMemoryBarriers from VkDependencyInfo
func (x DependencyInfo) PBufferMemoryBarriers() []BufferMemoryBarrier2 {
	ptr := func(x **C.struct_VkBufferMemoryBarrier2) *[]BufferMemoryBarrier2 { /* Slice */
		slc := unsafe.Slice((*BufferMemoryBarrier2)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pBufferMemoryBarriers)
	return *ptr
}

// WithPBufferMemoryBarriers clones a new DependencyInfo with the value of
// PBufferMemoryBarriers updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines BufferMemoryBarrierCount as the length of this field.
// BufferMemoryBarrierCount is updated with the length of the new value.
func (x DependencyInfo) WithPBufferMemoryBarriers(y []BufferMemoryBarrier2) DependencyInfo {
	x.pBufferMemoryBarriers = *(func(x *[]BufferMemoryBarrier2) **C.struct_VkBufferMemoryBarrier2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkBufferMemoryBarrier2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkBufferMemoryBarrier2)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithBufferMemoryBarrierCount(uint32(len(y)))
}
func (x *DependencyInfo) SetPBufferMemoryBarriers(y []BufferMemoryBarrier2) {
	x.pBufferMemoryBarriers = *(func(x *[]BufferMemoryBarrier2) **C.struct_VkBufferMemoryBarrier2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkBufferMemoryBarrier2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkBufferMemoryBarrier2)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetBufferMemoryBarrierCount(uint32(len(y)))
}

// ImageMemoryBarrierCount returns the value of imageMemoryBarrierCount from VkDependencyInfo
func (x DependencyInfo) ImageMemoryBarrierCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.imageMemoryBarrierCount)
	return *ptr
}

// WithImageMemoryBarrierCount clones a new DependencyInfo with the value of
// ImageMemoryBarrierCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DependencyInfo) WithImageMemoryBarrierCount(y uint32) DependencyInfo {
	x.imageMemoryBarrierCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DependencyInfo) SetImageMemoryBarrierCount(y uint32) {
	x.imageMemoryBarrierCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PImageMemoryBarriers returns the value of pImageMemoryBarriers from VkDependencyInfo
func (x DependencyInfo) PImageMemoryBarriers() []ImageMemoryBarrier2 {
	ptr := func(x **C.struct_VkImageMemoryBarrier2) *[]ImageMemoryBarrier2 { /* Slice */
		slc := unsafe.Slice((*ImageMemoryBarrier2)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pImageMemoryBarriers)
	return *ptr
}

// WithPImageMemoryBarriers clones a new DependencyInfo with the value of
// PImageMemoryBarriers updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines ImageMemoryBarrierCount as the length of this field.
// ImageMemoryBarrierCount is updated with the length of the new value.
func (x DependencyInfo) WithPImageMemoryBarriers(y []ImageMemoryBarrier2) DependencyInfo {
	x.pImageMemoryBarriers = *(func(x *[]ImageMemoryBarrier2) **C.struct_VkImageMemoryBarrier2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkImageMemoryBarrier2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkImageMemoryBarrier2)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithImageMemoryBarrierCount(uint32(len(y)))
}
func (x *DependencyInfo) SetPImageMemoryBarriers(y []ImageMemoryBarrier2) {
	x.pImageMemoryBarriers = *(func(x *[]ImageMemoryBarrier2) **C.struct_VkImageMemoryBarrier2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkImageMemoryBarrier2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkImageMemoryBarrier2)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetImageMemoryBarrierCount(uint32(len(y)))
}

// SemaphoreSubmitInfo provides a go interface for VkSemaphoreSubmitInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreSubmitInfo.html
type SemaphoreSubmitInfo C.struct_VkSemaphoreSubmitInfo

// SizeofSemaphoreSubmitInfo is the memory size of a SemaphoreSubmitInfo
var SizeofSemaphoreSubmitInfo int = int(unsafe.Sizeof(SemaphoreSubmitInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SemaphoreSubmitInfo) ArpPtr(arp *AutoReleasePool) *SemaphoreSubmitInfo {
	ptr := newCBlock(cULong(SizeofSemaphoreSubmitInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SemaphoreSubmitInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SemaphoreSubmitInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SemaphoreSubmitInfo) AsCPtr() *SemaphoreSubmitInfo {
	clone := (*SemaphoreSubmitInfo)(newCBlock(cULong(SizeofSemaphoreSubmitInfo)))
	*clone = x
	return clone
}

// SemaphoreSubmitInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SemaphoreSubmitInfoCSlice(arp *AutoReleasePool, x ...SemaphoreSubmitInfo) []SemaphoreSubmitInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSemaphoreSubmitInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SemaphoreSubmitInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SemaphoreSubmitInfoFreeCSlice releases the memory allocated by SemaphoreSubmitInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SemaphoreSubmitInfoFreeCSlice(x []SemaphoreSubmitInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SemaphoreSubmitInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SemaphoreSubmitInfoFreeCSlice must be called on the returned slice.
func SemaphoreSubmitInfoMakeCSlice(x ...SemaphoreSubmitInfo) []SemaphoreSubmitInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSemaphoreSubmitInfo * len(x)
	dst := unsafe.Slice((*SemaphoreSubmitInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSemaphoreSubmitInfo
func (x SemaphoreSubmitInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new SemaphoreSubmitInfo with the value of
// SType to the value provided in the specification.
func (x SemaphoreSubmitInfo) WithDefaultSType() SemaphoreSubmitInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *SemaphoreSubmitInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO)
}

// WithSType clones a new SemaphoreSubmitInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreSubmitInfo) WithSType(y StructureType) SemaphoreSubmitInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *SemaphoreSubmitInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkSemaphoreSubmitInfo
func (x SemaphoreSubmitInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new SemaphoreSubmitInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreSubmitInfo) WithPNext(y unsafe.Pointer) SemaphoreSubmitInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *SemaphoreSubmitInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Semaphore returns the value of semaphore from VkSemaphoreSubmitInfo
func (x SemaphoreSubmitInfo) Semaphore() Semaphore {
	ptr := /* handle */ (*Semaphore)(&x.semaphore)
	return *ptr
}

// WithSemaphore clones a new SemaphoreSubmitInfo with the value of
// Semaphore updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreSubmitInfo) WithSemaphore(y Semaphore) SemaphoreSubmitInfo {
	x.semaphore = *( /* handle */ (*C.VkSemaphore)(&y))
	return x
}
func (x *SemaphoreSubmitInfo) SetSemaphore(y Semaphore) {
	x.semaphore = *( /* handle */ (*C.VkSemaphore)(&y))
}

// Value returns the value of value from VkSemaphoreSubmitInfo
func (x SemaphoreSubmitInfo) Value() uint64 {
	ptr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.value)
	return *ptr
}

// WithValue clones a new SemaphoreSubmitInfo with the value of
// Value updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreSubmitInfo) WithValue(y uint64) SemaphoreSubmitInfo {
	x.value = *(func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&y))
	return x
}
func (x *SemaphoreSubmitInfo) SetValue(y uint64) {
	x.value = *(func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&y))
}

// StageMask returns the value of stageMask from VkSemaphoreSubmitInfo
func (x SemaphoreSubmitInfo) StageMask() PipelineStageFlags2 {
	ptr := /* typedef */ (*PipelineStageFlags2)(&x.stageMask)
	return *ptr
}

// WithStageMask clones a new SemaphoreSubmitInfo with the value of
// StageMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreSubmitInfo) WithStageMask(y PipelineStageFlags2) SemaphoreSubmitInfo {
	x.stageMask = *( /* typedef */ (*C.VkPipelineStageFlags2)(&y))
	return x
}
func (x *SemaphoreSubmitInfo) SetStageMask(y PipelineStageFlags2) {
	x.stageMask = *( /* typedef */ (*C.VkPipelineStageFlags2)(&y))
}

// DeviceIndex returns the value of deviceIndex from VkSemaphoreSubmitInfo
func (x SemaphoreSubmitInfo) DeviceIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.deviceIndex)
	return *ptr
}

// WithDeviceIndex clones a new SemaphoreSubmitInfo with the value of
// DeviceIndex updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreSubmitInfo) WithDeviceIndex(y uint32) SemaphoreSubmitInfo {
	x.deviceIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SemaphoreSubmitInfo) SetDeviceIndex(y uint32) {
	x.deviceIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// CommandBufferSubmitInfo provides a go interface for VkCommandBufferSubmitInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferSubmitInfo.html
type CommandBufferSubmitInfo C.struct_VkCommandBufferSubmitInfo

// SizeofCommandBufferSubmitInfo is the memory size of a CommandBufferSubmitInfo
var SizeofCommandBufferSubmitInfo int = int(unsafe.Sizeof(CommandBufferSubmitInfo{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x CommandBufferSubmitInfo) ArpPtr(arp *AutoReleasePool) *CommandBufferSubmitInfo {
	ptr := newCBlock(cULong(SizeofCommandBufferSubmitInfo))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*CommandBufferSubmitInfo)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *CommandBufferSubmitInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x CommandBufferSubmitInfo) AsCPtr() *CommandBufferSubmitInfo {
	clone := (*CommandBufferSubmitInfo)(newCBlock(cULong(SizeofCommandBufferSubmitInfo)))
	*clone = x
	return clone
}

// CommandBufferSubmitInfoCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func CommandBufferSubmitInfoCSlice(arp *AutoReleasePool, x ...CommandBufferSubmitInfo) []CommandBufferSubmitInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCommandBufferSubmitInfo * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*CommandBufferSubmitInfo)(ptr), len(x))
	copy(dst, x)
	return dst
}

// CommandBufferSubmitInfoFreeCSlice releases the memory allocated by CommandBufferSubmitInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func CommandBufferSubmitInfoFreeCSlice(x []CommandBufferSubmitInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// CommandBufferSubmitInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. CommandBufferSubmitInfoFreeCSlice must be called on the returned slice.
func CommandBufferSubmitInfoMakeCSlice(x ...CommandBufferSubmitInfo) []CommandBufferSubmitInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCommandBufferSubmitInfo * len(x)
	dst := unsafe.Slice((*CommandBufferSubmitInfo)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkCommandBufferSubmitInfo
func (x CommandBufferSubmitInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new CommandBufferSubmitInfo with the value of
// SType to the value provided in the specification.
func (x CommandBufferSubmitInfo) WithDefaultSType() CommandBufferSubmitInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *CommandBufferSubmitInfo) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO)
}

// WithSType clones a new CommandBufferSubmitInfo with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferSubmitInfo) WithSType(y StructureType) CommandBufferSubmitInfo {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *CommandBufferSubmitInfo) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkCommandBufferSubmitInfo
func (x CommandBufferSubmitInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new CommandBufferSubmitInfo with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferSubmitInfo) WithPNext(y unsafe.Pointer) CommandBufferSubmitInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *CommandBufferSubmitInfo) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// CommandBuffer returns the value of commandBuffer from VkCommandBufferSubmitInfo
func (x CommandBufferSubmitInfo) CommandBuffer() CommandBuffer {
	ptr := /* handle */ (*CommandBuffer)(&x.commandBuffer)
	return *ptr
}

// WithCommandBuffer clones a new CommandBufferSubmitInfo with the value of
// CommandBuffer updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferSubmitInfo) WithCommandBuffer(y CommandBuffer) CommandBufferSubmitInfo {
	x.commandBuffer = *( /* handle */ (*C.VkCommandBuffer)(&y))
	return x
}
func (x *CommandBufferSubmitInfo) SetCommandBuffer(y CommandBuffer) {
	x.commandBuffer = *( /* handle */ (*C.VkCommandBuffer)(&y))
}

// DeviceMask returns the value of deviceMask from VkCommandBufferSubmitInfo
func (x CommandBufferSubmitInfo) DeviceMask() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.deviceMask)
	return *ptr
}

// WithDeviceMask clones a new CommandBufferSubmitInfo with the value of
// DeviceMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferSubmitInfo) WithDeviceMask(y uint32) CommandBufferSubmitInfo {
	x.deviceMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *CommandBufferSubmitInfo) SetDeviceMask(y uint32) {
	x.deviceMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// SubmitInfo2 provides a go interface for VkSubmitInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubmitInfo2.html
type SubmitInfo2 C.struct_VkSubmitInfo2

// SizeofSubmitInfo2 is the memory size of a SubmitInfo2
var SizeofSubmitInfo2 int = int(unsafe.Sizeof(SubmitInfo2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SubmitInfo2) ArpPtr(arp *AutoReleasePool) *SubmitInfo2 {
	ptr := newCBlock(cULong(SizeofSubmitInfo2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SubmitInfo2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubmitInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubmitInfo2) AsCPtr() *SubmitInfo2 {
	clone := (*SubmitInfo2)(newCBlock(cULong(SizeofSubmitInfo2)))
	*clone = x
	return clone
}

// SubmitInfo2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SubmitInfo2CSlice(arp *AutoReleasePool, x ...SubmitInfo2) []SubmitInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubmitInfo2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SubmitInfo2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SubmitInfo2FreeCSlice releases the memory allocated by SubmitInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func SubmitInfo2FreeCSlice(x []SubmitInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubmitInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubmitInfo2FreeCSlice must be called on the returned slice.
func SubmitInfo2MakeCSlice(x ...SubmitInfo2) []SubmitInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubmitInfo2 * len(x)
	dst := unsafe.Slice((*SubmitInfo2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSubmitInfo2
func (x SubmitInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new SubmitInfo2 with the value of
// SType to the value provided in the specification.
func (x SubmitInfo2) WithDefaultSType() SubmitInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_SUBMIT_INFO_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *SubmitInfo2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_SUBMIT_INFO_2)
}

// WithSType clones a new SubmitInfo2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubmitInfo2) WithSType(y StructureType) SubmitInfo2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *SubmitInfo2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkSubmitInfo2
func (x SubmitInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new SubmitInfo2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubmitInfo2) WithPNext(y unsafe.Pointer) SubmitInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *SubmitInfo2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkSubmitInfo2
func (x SubmitInfo2) Flags() SubmitFlags {
	ptr := /* typedef */ (*SubmitFlags)(&x.flags)
	return *ptr
}

// WithFlags clones a new SubmitInfo2 with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubmitInfo2) WithFlags(y SubmitFlags) SubmitInfo2 {
	x.flags = *( /* typedef */ (*C.VkSubmitFlags)(&y))
	return x
}
func (x *SubmitInfo2) SetFlags(y SubmitFlags) {
	x.flags = *( /* typedef */ (*C.VkSubmitFlags)(&y))
}

// WaitSemaphoreInfoCount returns the value of waitSemaphoreInfoCount from VkSubmitInfo2
func (x SubmitInfo2) WaitSemaphoreInfoCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.waitSemaphoreInfoCount)
	return *ptr
}

// WithWaitSemaphoreInfoCount clones a new SubmitInfo2 with the value of
// WaitSemaphoreInfoCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubmitInfo2) WithWaitSemaphoreInfoCount(y uint32) SubmitInfo2 {
	x.waitSemaphoreInfoCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SubmitInfo2) SetWaitSemaphoreInfoCount(y uint32) {
	x.waitSemaphoreInfoCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PWaitSemaphoreInfos returns the value of pWaitSemaphoreInfos from VkSubmitInfo2
func (x SubmitInfo2) PWaitSemaphoreInfos() []SemaphoreSubmitInfo {
	ptr := func(x **C.struct_VkSemaphoreSubmitInfo) *[]SemaphoreSubmitInfo { /* Slice */
		slc := unsafe.Slice((*SemaphoreSubmitInfo)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pWaitSemaphoreInfos)
	return *ptr
}

// WithPWaitSemaphoreInfos clones a new SubmitInfo2 with the value of
// PWaitSemaphoreInfos updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines WaitSemaphoreInfoCount as the length of this field.
// WaitSemaphoreInfoCount is updated with the length of the new value.
func (x SubmitInfo2) WithPWaitSemaphoreInfos(y []SemaphoreSubmitInfo) SubmitInfo2 {
	x.pWaitSemaphoreInfos = *(func(x *[]SemaphoreSubmitInfo) **C.struct_VkSemaphoreSubmitInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSemaphoreSubmitInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSemaphoreSubmitInfo)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithWaitSemaphoreInfoCount(uint32(len(y)))
}
func (x *SubmitInfo2) SetPWaitSemaphoreInfos(y []SemaphoreSubmitInfo) {
	x.pWaitSemaphoreInfos = *(func(x *[]SemaphoreSubmitInfo) **C.struct_VkSemaphoreSubmitInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSemaphoreSubmitInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSemaphoreSubmitInfo)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetWaitSemaphoreInfoCount(uint32(len(y)))
}

// CommandBufferInfoCount returns the value of commandBufferInfoCount from VkSubmitInfo2
func (x SubmitInfo2) CommandBufferInfoCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.commandBufferInfoCount)
	return *ptr
}

// WithCommandBufferInfoCount clones a new SubmitInfo2 with the value of
// CommandBufferInfoCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubmitInfo2) WithCommandBufferInfoCount(y uint32) SubmitInfo2 {
	x.commandBufferInfoCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SubmitInfo2) SetCommandBufferInfoCount(y uint32) {
	x.commandBufferInfoCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PCommandBufferInfos returns the value of pCommandBufferInfos from VkSubmitInfo2
func (x SubmitInfo2) PCommandBufferInfos() []CommandBufferSubmitInfo {
	ptr := func(x **C.struct_VkCommandBufferSubmitInfo) *[]CommandBufferSubmitInfo { /* Slice */
		slc := unsafe.Slice((*CommandBufferSubmitInfo)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pCommandBufferInfos)
	return *ptr
}

// WithPCommandBufferInfos clones a new SubmitInfo2 with the value of
// PCommandBufferInfos updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines CommandBufferInfoCount as the length of this field.
// CommandBufferInfoCount is updated with the length of the new value.
func (x SubmitInfo2) WithPCommandBufferInfos(y []CommandBufferSubmitInfo) SubmitInfo2 {
	x.pCommandBufferInfos = *(func(x *[]CommandBufferSubmitInfo) **C.struct_VkCommandBufferSubmitInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkCommandBufferSubmitInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkCommandBufferSubmitInfo)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithCommandBufferInfoCount(uint32(len(y)))
}
func (x *SubmitInfo2) SetPCommandBufferInfos(y []CommandBufferSubmitInfo) {
	x.pCommandBufferInfos = *(func(x *[]CommandBufferSubmitInfo) **C.struct_VkCommandBufferSubmitInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkCommandBufferSubmitInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkCommandBufferSubmitInfo)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetCommandBufferInfoCount(uint32(len(y)))
}

// SignalSemaphoreInfoCount returns the value of signalSemaphoreInfoCount from VkSubmitInfo2
func (x SubmitInfo2) SignalSemaphoreInfoCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.signalSemaphoreInfoCount)
	return *ptr
}

// WithSignalSemaphoreInfoCount clones a new SubmitInfo2 with the value of
// SignalSemaphoreInfoCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubmitInfo2) WithSignalSemaphoreInfoCount(y uint32) SubmitInfo2 {
	x.signalSemaphoreInfoCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SubmitInfo2) SetSignalSemaphoreInfoCount(y uint32) {
	x.signalSemaphoreInfoCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PSignalSemaphoreInfos returns the value of pSignalSemaphoreInfos from VkSubmitInfo2
func (x SubmitInfo2) PSignalSemaphoreInfos() []SemaphoreSubmitInfo {
	ptr := func(x **C.struct_VkSemaphoreSubmitInfo) *[]SemaphoreSubmitInfo { /* Slice */
		slc := unsafe.Slice((*SemaphoreSubmitInfo)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pSignalSemaphoreInfos)
	return *ptr
}

// WithPSignalSemaphoreInfos clones a new SubmitInfo2 with the value of
// PSignalSemaphoreInfos updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SignalSemaphoreInfoCount as the length of this field.
// SignalSemaphoreInfoCount is updated with the length of the new value.
func (x SubmitInfo2) WithPSignalSemaphoreInfos(y []SemaphoreSubmitInfo) SubmitInfo2 {
	x.pSignalSemaphoreInfos = *(func(x *[]SemaphoreSubmitInfo) **C.struct_VkSemaphoreSubmitInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSemaphoreSubmitInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSemaphoreSubmitInfo)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithSignalSemaphoreInfoCount(uint32(len(y)))
}
func (x *SubmitInfo2) SetPSignalSemaphoreInfos(y []SemaphoreSubmitInfo) {
	x.pSignalSemaphoreInfos = *(func(x *[]SemaphoreSubmitInfo) **C.struct_VkSemaphoreSubmitInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSemaphoreSubmitInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSemaphoreSubmitInfo)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetSignalSemaphoreInfoCount(uint32(len(y)))
}

// ImageResolve2 provides a go interface for VkImageResolve2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageResolve2.html
type ImageResolve2 C.struct_VkImageResolve2

// SizeofImageResolve2 is the memory size of a ImageResolve2
var SizeofImageResolve2 int = int(unsafe.Sizeof(ImageResolve2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ImageResolve2) ArpPtr(arp *AutoReleasePool) *ImageResolve2 {
	ptr := newCBlock(cULong(SizeofImageResolve2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ImageResolve2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageResolve2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageResolve2) AsCPtr() *ImageResolve2 {
	clone := (*ImageResolve2)(newCBlock(cULong(SizeofImageResolve2)))
	*clone = x
	return clone
}

// ImageResolve2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ImageResolve2CSlice(arp *AutoReleasePool, x ...ImageResolve2) []ImageResolve2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageResolve2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ImageResolve2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ImageResolve2FreeCSlice releases the memory allocated by ImageResolve2MakeCSlice.
// It does not free pointers stored inside the slice.
func ImageResolve2FreeCSlice(x []ImageResolve2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageResolve2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageResolve2FreeCSlice must be called on the returned slice.
func ImageResolve2MakeCSlice(x ...ImageResolve2) []ImageResolve2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageResolve2 * len(x)
	dst := unsafe.Slice((*ImageResolve2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageResolve2
func (x ImageResolve2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ImageResolve2 with the value of
// SType to the value provided in the specification.
func (x ImageResolve2) WithDefaultSType() ImageResolve2 {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ImageResolve2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2)
}

// WithSType clones a new ImageResolve2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve2) WithSType(y StructureType) ImageResolve2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ImageResolve2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkImageResolve2
func (x ImageResolve2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ImageResolve2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve2) WithPNext(y unsafe.Pointer) ImageResolve2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ImageResolve2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SrcSubresource returns the value of srcSubresource from VkImageResolve2
func (x ImageResolve2) SrcSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.srcSubresource)
	return *ptr
}

// WithSrcSubresource clones a new ImageResolve2 with the value of
// SrcSubresource updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve2) WithSrcSubresource(y ImageSubresourceLayers) ImageResolve2 {
	x.srcSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}
func (x *ImageResolve2) SetSrcSubresource(y ImageSubresourceLayers) {
	x.srcSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
}

// SrcOffset returns the value of srcOffset from VkImageResolve2
func (x ImageResolve2) SrcOffset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.srcOffset)
	return *ptr
}

// WithSrcOffset clones a new ImageResolve2 with the value of
// SrcOffset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve2) WithSrcOffset(y Offset3D) ImageResolve2 {
	x.srcOffset = *( /* typedef */ (*C.struct_VkOffset3D)(&y))
	return x
}
func (x *ImageResolve2) SetSrcOffset(y Offset3D) {
	x.srcOffset = *( /* typedef */ (*C.struct_VkOffset3D)(&y))
}

// DstSubresource returns the value of dstSubresource from VkImageResolve2
func (x ImageResolve2) DstSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.dstSubresource)
	return *ptr
}

// WithDstSubresource clones a new ImageResolve2 with the value of
// DstSubresource updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve2) WithDstSubresource(y ImageSubresourceLayers) ImageResolve2 {
	x.dstSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}
func (x *ImageResolve2) SetDstSubresource(y ImageSubresourceLayers) {
	x.dstSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
}

// DstOffset returns the value of dstOffset from VkImageResolve2
func (x ImageResolve2) DstOffset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.dstOffset)
	return *ptr
}

// WithDstOffset clones a new ImageResolve2 with the value of
// DstOffset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve2) WithDstOffset(y Offset3D) ImageResolve2 {
	x.dstOffset = *( /* typedef */ (*C.struct_VkOffset3D)(&y))
	return x
}
func (x *ImageResolve2) SetDstOffset(y Offset3D) {
	x.dstOffset = *( /* typedef */ (*C.struct_VkOffset3D)(&y))
}

// Extent returns the value of extent from VkImageResolve2
func (x ImageResolve2) Extent() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.extent)
	return *ptr
}

// WithExtent clones a new ImageResolve2 with the value of
// Extent updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve2) WithExtent(y Extent3D) ImageResolve2 {
	x.extent = *( /* typedef */ (*C.struct_VkExtent3D)(&y))
	return x
}
func (x *ImageResolve2) SetExtent(y Extent3D) {
	x.extent = *( /* typedef */ (*C.struct_VkExtent3D)(&y))
}

// PhysicalDeviceSynchronization2Features provides a go interface for VkPhysicalDeviceSynchronization2Features.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSynchronization2Features.html
type PhysicalDeviceSynchronization2Features C.struct_VkPhysicalDeviceSynchronization2Features

// SizeofPhysicalDeviceSynchronization2Features is the memory size of a PhysicalDeviceSynchronization2Features
var SizeofPhysicalDeviceSynchronization2Features int = int(unsafe.Sizeof(PhysicalDeviceSynchronization2Features{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceSynchronization2Features) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceSynchronization2Features {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceSynchronization2Features))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceSynchronization2Features)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceSynchronization2Features) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceSynchronization2Features) AsCPtr() *PhysicalDeviceSynchronization2Features {
	clone := (*PhysicalDeviceSynchronization2Features)(newCBlock(cULong(SizeofPhysicalDeviceSynchronization2Features)))
	*clone = x
	return clone
}

// PhysicalDeviceSynchronization2FeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceSynchronization2FeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceSynchronization2Features) []PhysicalDeviceSynchronization2Features {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSynchronization2Features * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceSynchronization2Features)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceSynchronization2FeaturesFreeCSlice releases the memory allocated by PhysicalDeviceSynchronization2FeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceSynchronization2FeaturesFreeCSlice(x []PhysicalDeviceSynchronization2Features) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceSynchronization2FeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceSynchronization2FeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceSynchronization2FeaturesMakeCSlice(x ...PhysicalDeviceSynchronization2Features) []PhysicalDeviceSynchronization2Features {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSynchronization2Features * len(x)
	dst := unsafe.Slice((*PhysicalDeviceSynchronization2Features)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceSynchronization2Features
func (x PhysicalDeviceSynchronization2Features) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceSynchronization2Features with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceSynchronization2Features) WithDefaultSType() PhysicalDeviceSynchronization2Features {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceSynchronization2Features) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES)
}

// WithSType clones a new PhysicalDeviceSynchronization2Features with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSynchronization2Features) WithSType(y StructureType) PhysicalDeviceSynchronization2Features {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceSynchronization2Features) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceSynchronization2Features
func (x PhysicalDeviceSynchronization2Features) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceSynchronization2Features with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSynchronization2Features) WithPNext(y unsafe.Pointer) PhysicalDeviceSynchronization2Features {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceSynchronization2Features) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Synchronization2 returns the value of synchronization2 from VkPhysicalDeviceSynchronization2Features
func (x PhysicalDeviceSynchronization2Features) Synchronization2() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.synchronization2)
	return *ptr
}

// WithSynchronization2 clones a new PhysicalDeviceSynchronization2Features with the value of
// Synchronization2 updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSynchronization2Features) WithSynchronization2(y Bool32) PhysicalDeviceSynchronization2Features {
	x.synchronization2 = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceSynchronization2Features) SetSynchronization2(y Bool32) {
	x.synchronization2 = *( /* typedef */ (*C.VkBool32)(&y))
}

// BufferImageCopy2 provides a go interface for VkBufferImageCopy2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferImageCopy2.html
type BufferImageCopy2 C.struct_VkBufferImageCopy2

// SizeofBufferImageCopy2 is the memory size of a BufferImageCopy2
var SizeofBufferImageCopy2 int = int(unsafe.Sizeof(BufferImageCopy2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x BufferImageCopy2) ArpPtr(arp *AutoReleasePool) *BufferImageCopy2 {
	ptr := newCBlock(cULong(SizeofBufferImageCopy2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*BufferImageCopy2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferImageCopy2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferImageCopy2) AsCPtr() *BufferImageCopy2 {
	clone := (*BufferImageCopy2)(newCBlock(cULong(SizeofBufferImageCopy2)))
	*clone = x
	return clone
}

// BufferImageCopy2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func BufferImageCopy2CSlice(arp *AutoReleasePool, x ...BufferImageCopy2) []BufferImageCopy2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferImageCopy2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*BufferImageCopy2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// BufferImageCopy2FreeCSlice releases the memory allocated by BufferImageCopy2MakeCSlice.
// It does not free pointers stored inside the slice.
func BufferImageCopy2FreeCSlice(x []BufferImageCopy2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferImageCopy2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferImageCopy2FreeCSlice must be called on the returned slice.
func BufferImageCopy2MakeCSlice(x ...BufferImageCopy2) []BufferImageCopy2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferImageCopy2 * len(x)
	dst := unsafe.Slice((*BufferImageCopy2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBufferImageCopy2
func (x BufferImageCopy2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new BufferImageCopy2 with the value of
// SType to the value provided in the specification.
func (x BufferImageCopy2) WithDefaultSType() BufferImageCopy2 {
	return x.WithSType(VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *BufferImageCopy2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2)
}

// WithSType clones a new BufferImageCopy2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy2) WithSType(y StructureType) BufferImageCopy2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *BufferImageCopy2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkBufferImageCopy2
func (x BufferImageCopy2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new BufferImageCopy2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy2) WithPNext(y unsafe.Pointer) BufferImageCopy2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *BufferImageCopy2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// BufferOffset returns the value of bufferOffset from VkBufferImageCopy2
func (x BufferImageCopy2) BufferOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.bufferOffset)
	return *ptr
}

// WithBufferOffset clones a new BufferImageCopy2 with the value of
// BufferOffset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy2) WithBufferOffset(y DeviceSize) BufferImageCopy2 {
	x.bufferOffset = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *BufferImageCopy2) SetBufferOffset(y DeviceSize) {
	x.bufferOffset = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// BufferRowLength returns the value of bufferRowLength from VkBufferImageCopy2
func (x BufferImageCopy2) BufferRowLength() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.bufferRowLength)
	return *ptr
}

// WithBufferRowLength clones a new BufferImageCopy2 with the value of
// BufferRowLength updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy2) WithBufferRowLength(y uint32) BufferImageCopy2 {
	x.bufferRowLength = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *BufferImageCopy2) SetBufferRowLength(y uint32) {
	x.bufferRowLength = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// BufferImageHeight returns the value of bufferImageHeight from VkBufferImageCopy2
func (x BufferImageCopy2) BufferImageHeight() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.bufferImageHeight)
	return *ptr
}

// WithBufferImageHeight clones a new BufferImageCopy2 with the value of
// BufferImageHeight updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy2) WithBufferImageHeight(y uint32) BufferImageCopy2 {
	x.bufferImageHeight = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *BufferImageCopy2) SetBufferImageHeight(y uint32) {
	x.bufferImageHeight = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// ImageSubresource returns the value of imageSubresource from VkBufferImageCopy2
func (x BufferImageCopy2) ImageSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.imageSubresource)
	return *ptr
}

// WithImageSubresource clones a new BufferImageCopy2 with the value of
// ImageSubresource updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy2) WithImageSubresource(y ImageSubresourceLayers) BufferImageCopy2 {
	x.imageSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}
func (x *BufferImageCopy2) SetImageSubresource(y ImageSubresourceLayers) {
	x.imageSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
}

// ImageOffset returns the value of imageOffset from VkBufferImageCopy2
func (x BufferImageCopy2) ImageOffset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.imageOffset)
	return *ptr
}

// WithImageOffset clones a new BufferImageCopy2 with the value of
// ImageOffset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy2) WithImageOffset(y Offset3D) BufferImageCopy2 {
	x.imageOffset = *( /* typedef */ (*C.struct_VkOffset3D)(&y))
	return x
}
func (x *BufferImageCopy2) SetImageOffset(y Offset3D) {
	x.imageOffset = *( /* typedef */ (*C.struct_VkOffset3D)(&y))
}

// ImageExtent returns the value of imageExtent from VkBufferImageCopy2
func (x BufferImageCopy2) ImageExtent() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.imageExtent)
	return *ptr
}

// WithImageExtent clones a new BufferImageCopy2 with the value of
// ImageExtent updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy2) WithImageExtent(y Extent3D) BufferImageCopy2 {
	x.imageExtent = *( /* typedef */ (*C.struct_VkExtent3D)(&y))
	return x
}
func (x *BufferImageCopy2) SetImageExtent(y Extent3D) {
	x.imageExtent = *( /* typedef */ (*C.struct_VkExtent3D)(&y))
}

// ImageBlit2 provides a go interface for VkImageBlit2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageBlit2.html
type ImageBlit2 C.struct_VkImageBlit2

// SizeofImageBlit2 is the memory size of a ImageBlit2
var SizeofImageBlit2 int = int(unsafe.Sizeof(ImageBlit2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ImageBlit2) ArpPtr(arp *AutoReleasePool) *ImageBlit2 {
	ptr := newCBlock(cULong(SizeofImageBlit2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ImageBlit2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageBlit2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageBlit2) AsCPtr() *ImageBlit2 {
	clone := (*ImageBlit2)(newCBlock(cULong(SizeofImageBlit2)))
	*clone = x
	return clone
}

// ImageBlit2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ImageBlit2CSlice(arp *AutoReleasePool, x ...ImageBlit2) []ImageBlit2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageBlit2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ImageBlit2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ImageBlit2FreeCSlice releases the memory allocated by ImageBlit2MakeCSlice.
// It does not free pointers stored inside the slice.
func ImageBlit2FreeCSlice(x []ImageBlit2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageBlit2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageBlit2FreeCSlice must be called on the returned slice.
func ImageBlit2MakeCSlice(x ...ImageBlit2) []ImageBlit2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageBlit2 * len(x)
	dst := unsafe.Slice((*ImageBlit2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageBlit2
func (x ImageBlit2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ImageBlit2 with the value of
// SType to the value provided in the specification.
func (x ImageBlit2) WithDefaultSType() ImageBlit2 {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_BLIT_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ImageBlit2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_IMAGE_BLIT_2)
}

// WithSType clones a new ImageBlit2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageBlit2) WithSType(y StructureType) ImageBlit2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ImageBlit2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkImageBlit2
func (x ImageBlit2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ImageBlit2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageBlit2) WithPNext(y unsafe.Pointer) ImageBlit2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ImageBlit2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SrcSubresource returns the value of srcSubresource from VkImageBlit2
func (x ImageBlit2) SrcSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.srcSubresource)
	return *ptr
}

// WithSrcSubresource clones a new ImageBlit2 with the value of
// SrcSubresource updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageBlit2) WithSrcSubresource(y ImageSubresourceLayers) ImageBlit2 {
	x.srcSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}
func (x *ImageBlit2) SetSrcSubresource(y ImageSubresourceLayers) {
	x.srcSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
}

// SrcOffsets returns the value of srcOffsets from VkImageBlit2
func (x ImageBlit2) SrcOffsets() []Offset3D {
	ptr := func(x *[2]C.struct_VkOffset3D) *[]Offset3D { /* Array */
		slc := unsafe.Slice((*Offset3D)(unsafe.Pointer(x)), 2)
		return &slc
	}(&x.srcOffsets)
	return *ptr
}

// WithSrcOffsets clones a new ImageBlit2 with the value of
// SrcOffsets updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageBlit2) WithSrcOffsets(y []Offset3D) ImageBlit2 {
	ptr := func(x *[]Offset3D) **C.struct_VkOffset3D { /* Array */
		if len(*x) > 0 {
			slc := (*C.struct_VkOffset3D)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkOffset3D)(unsafe.Pointer((&ptr)))
	}(&y)
	copy(x.srcOffsets[:], unsafe.Slice(*ptr, len(y)))
	return x
}
func (x *ImageBlit2) SetSrcOffsets(y []Offset3D) {
	ptr := func(x *[]Offset3D) **C.struct_VkOffset3D { /* Array */
		if len(*x) > 0 {
			slc := (*C.struct_VkOffset3D)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkOffset3D)(unsafe.Pointer((&ptr)))
	}(&y)
	copy(x.srcOffsets[:], unsafe.Slice(*ptr, len(y)))
}

// DstSubresource returns the value of dstSubresource from VkImageBlit2
func (x ImageBlit2) DstSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.dstSubresource)
	return *ptr
}

// WithDstSubresource clones a new ImageBlit2 with the value of
// DstSubresource updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageBlit2) WithDstSubresource(y ImageSubresourceLayers) ImageBlit2 {
	x.dstSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}
func (x *ImageBlit2) SetDstSubresource(y ImageSubresourceLayers) {
	x.dstSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
}

// DstOffsets returns the value of dstOffsets from VkImageBlit2
func (x ImageBlit2) DstOffsets() []Offset3D {
	ptr := func(x *[2]C.struct_VkOffset3D) *[]Offset3D { /* Array */
		slc := unsafe.Slice((*Offset3D)(unsafe.Pointer(x)), 2)
		return &slc
	}(&x.dstOffsets)
	return *ptr
}

// WithDstOffsets clones a new ImageBlit2 with the value of
// DstOffsets updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageBlit2) WithDstOffsets(y []Offset3D) ImageBlit2 {
	ptr := func(x *[]Offset3D) **C.struct_VkOffset3D { /* Array */
		if len(*x) > 0 {
			slc := (*C.struct_VkOffset3D)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkOffset3D)(unsafe.Pointer((&ptr)))
	}(&y)
	copy(x.dstOffsets[:], unsafe.Slice(*ptr, len(y)))
	return x
}
func (x *ImageBlit2) SetDstOffsets(y []Offset3D) {
	ptr := func(x *[]Offset3D) **C.struct_VkOffset3D { /* Array */
		if len(*x) > 0 {
			slc := (*C.struct_VkOffset3D)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkOffset3D)(unsafe.Pointer((&ptr)))
	}(&y)
	copy(x.dstOffsets[:], unsafe.Slice(*ptr, len(y)))
}

// ImageCopy2 provides a go interface for VkImageCopy2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCopy2.html
type ImageCopy2 C.struct_VkImageCopy2

// SizeofImageCopy2 is the memory size of a ImageCopy2
var SizeofImageCopy2 int = int(unsafe.Sizeof(ImageCopy2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ImageCopy2) ArpPtr(arp *AutoReleasePool) *ImageCopy2 {
	ptr := newCBlock(cULong(SizeofImageCopy2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ImageCopy2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageCopy2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageCopy2) AsCPtr() *ImageCopy2 {
	clone := (*ImageCopy2)(newCBlock(cULong(SizeofImageCopy2)))
	*clone = x
	return clone
}

// ImageCopy2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ImageCopy2CSlice(arp *AutoReleasePool, x ...ImageCopy2) []ImageCopy2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageCopy2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ImageCopy2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ImageCopy2FreeCSlice releases the memory allocated by ImageCopy2MakeCSlice.
// It does not free pointers stored inside the slice.
func ImageCopy2FreeCSlice(x []ImageCopy2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageCopy2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageCopy2FreeCSlice must be called on the returned slice.
func ImageCopy2MakeCSlice(x ...ImageCopy2) []ImageCopy2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageCopy2 * len(x)
	dst := unsafe.Slice((*ImageCopy2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageCopy2
func (x ImageCopy2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ImageCopy2 with the value of
// SType to the value provided in the specification.
func (x ImageCopy2) WithDefaultSType() ImageCopy2 {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_COPY_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ImageCopy2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_IMAGE_COPY_2)
}

// WithSType clones a new ImageCopy2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy2) WithSType(y StructureType) ImageCopy2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ImageCopy2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkImageCopy2
func (x ImageCopy2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ImageCopy2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy2) WithPNext(y unsafe.Pointer) ImageCopy2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ImageCopy2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SrcSubresource returns the value of srcSubresource from VkImageCopy2
func (x ImageCopy2) SrcSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.srcSubresource)
	return *ptr
}

// WithSrcSubresource clones a new ImageCopy2 with the value of
// SrcSubresource updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy2) WithSrcSubresource(y ImageSubresourceLayers) ImageCopy2 {
	x.srcSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}
func (x *ImageCopy2) SetSrcSubresource(y ImageSubresourceLayers) {
	x.srcSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
}

// SrcOffset returns the value of srcOffset from VkImageCopy2
func (x ImageCopy2) SrcOffset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.srcOffset)
	return *ptr
}

// WithSrcOffset clones a new ImageCopy2 with the value of
// SrcOffset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy2) WithSrcOffset(y Offset3D) ImageCopy2 {
	x.srcOffset = *( /* typedef */ (*C.struct_VkOffset3D)(&y))
	return x
}
func (x *ImageCopy2) SetSrcOffset(y Offset3D) {
	x.srcOffset = *( /* typedef */ (*C.struct_VkOffset3D)(&y))
}

// DstSubresource returns the value of dstSubresource from VkImageCopy2
func (x ImageCopy2) DstSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.dstSubresource)
	return *ptr
}

// WithDstSubresource clones a new ImageCopy2 with the value of
// DstSubresource updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy2) WithDstSubresource(y ImageSubresourceLayers) ImageCopy2 {
	x.dstSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}
func (x *ImageCopy2) SetDstSubresource(y ImageSubresourceLayers) {
	x.dstSubresource = *( /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
}

// DstOffset returns the value of dstOffset from VkImageCopy2
func (x ImageCopy2) DstOffset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.dstOffset)
	return *ptr
}

// WithDstOffset clones a new ImageCopy2 with the value of
// DstOffset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy2) WithDstOffset(y Offset3D) ImageCopy2 {
	x.dstOffset = *( /* typedef */ (*C.struct_VkOffset3D)(&y))
	return x
}
func (x *ImageCopy2) SetDstOffset(y Offset3D) {
	x.dstOffset = *( /* typedef */ (*C.struct_VkOffset3D)(&y))
}

// Extent returns the value of extent from VkImageCopy2
func (x ImageCopy2) Extent() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.extent)
	return *ptr
}

// WithExtent clones a new ImageCopy2 with the value of
// Extent updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy2) WithExtent(y Extent3D) ImageCopy2 {
	x.extent = *( /* typedef */ (*C.struct_VkExtent3D)(&y))
	return x
}
func (x *ImageCopy2) SetExtent(y Extent3D) {
	x.extent = *( /* typedef */ (*C.struct_VkExtent3D)(&y))
}

// BufferCopy2 provides a go interface for VkBufferCopy2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCopy2.html
type BufferCopy2 C.struct_VkBufferCopy2

// SizeofBufferCopy2 is the memory size of a BufferCopy2
var SizeofBufferCopy2 int = int(unsafe.Sizeof(BufferCopy2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x BufferCopy2) ArpPtr(arp *AutoReleasePool) *BufferCopy2 {
	ptr := newCBlock(cULong(SizeofBufferCopy2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*BufferCopy2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferCopy2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferCopy2) AsCPtr() *BufferCopy2 {
	clone := (*BufferCopy2)(newCBlock(cULong(SizeofBufferCopy2)))
	*clone = x
	return clone
}

// BufferCopy2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func BufferCopy2CSlice(arp *AutoReleasePool, x ...BufferCopy2) []BufferCopy2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferCopy2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*BufferCopy2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// BufferCopy2FreeCSlice releases the memory allocated by BufferCopy2MakeCSlice.
// It does not free pointers stored inside the slice.
func BufferCopy2FreeCSlice(x []BufferCopy2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferCopy2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferCopy2FreeCSlice must be called on the returned slice.
func BufferCopy2MakeCSlice(x ...BufferCopy2) []BufferCopy2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferCopy2 * len(x)
	dst := unsafe.Slice((*BufferCopy2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBufferCopy2
func (x BufferCopy2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new BufferCopy2 with the value of
// SType to the value provided in the specification.
func (x BufferCopy2) WithDefaultSType() BufferCopy2 {
	return x.WithSType(VK_STRUCTURE_TYPE_BUFFER_COPY_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *BufferCopy2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_BUFFER_COPY_2)
}

// WithSType clones a new BufferCopy2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCopy2) WithSType(y StructureType) BufferCopy2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *BufferCopy2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkBufferCopy2
func (x BufferCopy2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new BufferCopy2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCopy2) WithPNext(y unsafe.Pointer) BufferCopy2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *BufferCopy2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SrcOffset returns the value of srcOffset from VkBufferCopy2
func (x BufferCopy2) SrcOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.srcOffset)
	return *ptr
}

// WithSrcOffset clones a new BufferCopy2 with the value of
// SrcOffset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCopy2) WithSrcOffset(y DeviceSize) BufferCopy2 {
	x.srcOffset = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *BufferCopy2) SetSrcOffset(y DeviceSize) {
	x.srcOffset = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// DstOffset returns the value of dstOffset from VkBufferCopy2
func (x BufferCopy2) DstOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.dstOffset)
	return *ptr
}

// WithDstOffset clones a new BufferCopy2 with the value of
// DstOffset updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCopy2) WithDstOffset(y DeviceSize) BufferCopy2 {
	x.dstOffset = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *BufferCopy2) SetDstOffset(y DeviceSize) {
	x.dstOffset = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// Size returns the value of size from VkBufferCopy2
func (x BufferCopy2) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size)
	return *ptr
}

// WithSize clones a new BufferCopy2 with the value of
// Size updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCopy2) WithSize(y DeviceSize) BufferCopy2 {
	x.size = *( /* typedef */ (*C.VkDeviceSize)(&y))
	return x
}
func (x *BufferCopy2) SetSize(y DeviceSize) {
	x.size = *( /* typedef */ (*C.VkDeviceSize)(&y))
}

// ResolveImageInfo2 provides a go interface for VkResolveImageInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkResolveImageInfo2.html
type ResolveImageInfo2 C.struct_VkResolveImageInfo2

// SizeofResolveImageInfo2 is the memory size of a ResolveImageInfo2
var SizeofResolveImageInfo2 int = int(unsafe.Sizeof(ResolveImageInfo2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ResolveImageInfo2) ArpPtr(arp *AutoReleasePool) *ResolveImageInfo2 {
	ptr := newCBlock(cULong(SizeofResolveImageInfo2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ResolveImageInfo2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ResolveImageInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ResolveImageInfo2) AsCPtr() *ResolveImageInfo2 {
	clone := (*ResolveImageInfo2)(newCBlock(cULong(SizeofResolveImageInfo2)))
	*clone = x
	return clone
}

// ResolveImageInfo2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ResolveImageInfo2CSlice(arp *AutoReleasePool, x ...ResolveImageInfo2) []ResolveImageInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofResolveImageInfo2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ResolveImageInfo2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ResolveImageInfo2FreeCSlice releases the memory allocated by ResolveImageInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func ResolveImageInfo2FreeCSlice(x []ResolveImageInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ResolveImageInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ResolveImageInfo2FreeCSlice must be called on the returned slice.
func ResolveImageInfo2MakeCSlice(x ...ResolveImageInfo2) []ResolveImageInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofResolveImageInfo2 * len(x)
	dst := unsafe.Slice((*ResolveImageInfo2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkResolveImageInfo2
func (x ResolveImageInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ResolveImageInfo2 with the value of
// SType to the value provided in the specification.
func (x ResolveImageInfo2) WithDefaultSType() ResolveImageInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ResolveImageInfo2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2)
}

// WithSType clones a new ResolveImageInfo2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ResolveImageInfo2) WithSType(y StructureType) ResolveImageInfo2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ResolveImageInfo2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkResolveImageInfo2
func (x ResolveImageInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ResolveImageInfo2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ResolveImageInfo2) WithPNext(y unsafe.Pointer) ResolveImageInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ResolveImageInfo2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SrcImage returns the value of srcImage from VkResolveImageInfo2
func (x ResolveImageInfo2) SrcImage() Image {
	ptr := /* handle */ (*Image)(&x.srcImage)
	return *ptr
}

// WithSrcImage clones a new ResolveImageInfo2 with the value of
// SrcImage updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ResolveImageInfo2) WithSrcImage(y Image) ResolveImageInfo2 {
	x.srcImage = *( /* handle */ (*C.VkImage)(&y))
	return x
}
func (x *ResolveImageInfo2) SetSrcImage(y Image) {
	x.srcImage = *( /* handle */ (*C.VkImage)(&y))
}

// SrcImageLayout returns the value of srcImageLayout from VkResolveImageInfo2
func (x ResolveImageInfo2) SrcImageLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.srcImageLayout)
	return *ptr
}

// WithSrcImageLayout clones a new ResolveImageInfo2 with the value of
// SrcImageLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ResolveImageInfo2) WithSrcImageLayout(y ImageLayout) ResolveImageInfo2 {
	x.srcImageLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
	return x
}
func (x *ResolveImageInfo2) SetSrcImageLayout(y ImageLayout) {
	x.srcImageLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
}

// DstImage returns the value of dstImage from VkResolveImageInfo2
func (x ResolveImageInfo2) DstImage() Image {
	ptr := /* handle */ (*Image)(&x.dstImage)
	return *ptr
}

// WithDstImage clones a new ResolveImageInfo2 with the value of
// DstImage updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ResolveImageInfo2) WithDstImage(y Image) ResolveImageInfo2 {
	x.dstImage = *( /* handle */ (*C.VkImage)(&y))
	return x
}
func (x *ResolveImageInfo2) SetDstImage(y Image) {
	x.dstImage = *( /* handle */ (*C.VkImage)(&y))
}

// DstImageLayout returns the value of dstImageLayout from VkResolveImageInfo2
func (x ResolveImageInfo2) DstImageLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.dstImageLayout)
	return *ptr
}

// WithDstImageLayout clones a new ResolveImageInfo2 with the value of
// DstImageLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ResolveImageInfo2) WithDstImageLayout(y ImageLayout) ResolveImageInfo2 {
	x.dstImageLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
	return x
}
func (x *ResolveImageInfo2) SetDstImageLayout(y ImageLayout) {
	x.dstImageLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
}

// RegionCount returns the value of regionCount from VkResolveImageInfo2
func (x ResolveImageInfo2) RegionCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.regionCount)
	return *ptr
}

// WithRegionCount clones a new ResolveImageInfo2 with the value of
// RegionCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ResolveImageInfo2) WithRegionCount(y uint32) ResolveImageInfo2 {
	x.regionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *ResolveImageInfo2) SetRegionCount(y uint32) {
	x.regionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PRegions returns the value of pRegions from VkResolveImageInfo2
func (x ResolveImageInfo2) PRegions() []ImageResolve2 {
	ptr := func(x **C.struct_VkImageResolve2) *[]ImageResolve2 { /* Slice */
		slc := unsafe.Slice((*ImageResolve2)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pRegions)
	return *ptr
}

// WithPRegions clones a new ResolveImageInfo2 with the value of
// PRegions updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines RegionCount as the length of this field.
// RegionCount is updated with the length of the new value.
func (x ResolveImageInfo2) WithPRegions(y []ImageResolve2) ResolveImageInfo2 {
	x.pRegions = *(func(x *[]ImageResolve2) **C.struct_VkImageResolve2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkImageResolve2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkImageResolve2)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithRegionCount(uint32(len(y)))
}
func (x *ResolveImageInfo2) SetPRegions(y []ImageResolve2) {
	x.pRegions = *(func(x *[]ImageResolve2) **C.struct_VkImageResolve2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkImageResolve2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkImageResolve2)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetRegionCount(uint32(len(y)))
}

// BlitImageInfo2 provides a go interface for VkBlitImageInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBlitImageInfo2.html
type BlitImageInfo2 C.struct_VkBlitImageInfo2

// SizeofBlitImageInfo2 is the memory size of a BlitImageInfo2
var SizeofBlitImageInfo2 int = int(unsafe.Sizeof(BlitImageInfo2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x BlitImageInfo2) ArpPtr(arp *AutoReleasePool) *BlitImageInfo2 {
	ptr := newCBlock(cULong(SizeofBlitImageInfo2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*BlitImageInfo2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BlitImageInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BlitImageInfo2) AsCPtr() *BlitImageInfo2 {
	clone := (*BlitImageInfo2)(newCBlock(cULong(SizeofBlitImageInfo2)))
	*clone = x
	return clone
}

// BlitImageInfo2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func BlitImageInfo2CSlice(arp *AutoReleasePool, x ...BlitImageInfo2) []BlitImageInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBlitImageInfo2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*BlitImageInfo2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// BlitImageInfo2FreeCSlice releases the memory allocated by BlitImageInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func BlitImageInfo2FreeCSlice(x []BlitImageInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BlitImageInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BlitImageInfo2FreeCSlice must be called on the returned slice.
func BlitImageInfo2MakeCSlice(x ...BlitImageInfo2) []BlitImageInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBlitImageInfo2 * len(x)
	dst := unsafe.Slice((*BlitImageInfo2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBlitImageInfo2
func (x BlitImageInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new BlitImageInfo2 with the value of
// SType to the value provided in the specification.
func (x BlitImageInfo2) WithDefaultSType() BlitImageInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *BlitImageInfo2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2)
}

// WithSType clones a new BlitImageInfo2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BlitImageInfo2) WithSType(y StructureType) BlitImageInfo2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *BlitImageInfo2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkBlitImageInfo2
func (x BlitImageInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new BlitImageInfo2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BlitImageInfo2) WithPNext(y unsafe.Pointer) BlitImageInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *BlitImageInfo2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SrcImage returns the value of srcImage from VkBlitImageInfo2
func (x BlitImageInfo2) SrcImage() Image {
	ptr := /* handle */ (*Image)(&x.srcImage)
	return *ptr
}

// WithSrcImage clones a new BlitImageInfo2 with the value of
// SrcImage updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BlitImageInfo2) WithSrcImage(y Image) BlitImageInfo2 {
	x.srcImage = *( /* handle */ (*C.VkImage)(&y))
	return x
}
func (x *BlitImageInfo2) SetSrcImage(y Image) {
	x.srcImage = *( /* handle */ (*C.VkImage)(&y))
}

// SrcImageLayout returns the value of srcImageLayout from VkBlitImageInfo2
func (x BlitImageInfo2) SrcImageLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.srcImageLayout)
	return *ptr
}

// WithSrcImageLayout clones a new BlitImageInfo2 with the value of
// SrcImageLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BlitImageInfo2) WithSrcImageLayout(y ImageLayout) BlitImageInfo2 {
	x.srcImageLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
	return x
}
func (x *BlitImageInfo2) SetSrcImageLayout(y ImageLayout) {
	x.srcImageLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
}

// DstImage returns the value of dstImage from VkBlitImageInfo2
func (x BlitImageInfo2) DstImage() Image {
	ptr := /* handle */ (*Image)(&x.dstImage)
	return *ptr
}

// WithDstImage clones a new BlitImageInfo2 with the value of
// DstImage updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BlitImageInfo2) WithDstImage(y Image) BlitImageInfo2 {
	x.dstImage = *( /* handle */ (*C.VkImage)(&y))
	return x
}
func (x *BlitImageInfo2) SetDstImage(y Image) {
	x.dstImage = *( /* handle */ (*C.VkImage)(&y))
}

// DstImageLayout returns the value of dstImageLayout from VkBlitImageInfo2
func (x BlitImageInfo2) DstImageLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.dstImageLayout)
	return *ptr
}

// WithDstImageLayout clones a new BlitImageInfo2 with the value of
// DstImageLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BlitImageInfo2) WithDstImageLayout(y ImageLayout) BlitImageInfo2 {
	x.dstImageLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
	return x
}
func (x *BlitImageInfo2) SetDstImageLayout(y ImageLayout) {
	x.dstImageLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
}

// RegionCount returns the value of regionCount from VkBlitImageInfo2
func (x BlitImageInfo2) RegionCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.regionCount)
	return *ptr
}

// WithRegionCount clones a new BlitImageInfo2 with the value of
// RegionCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BlitImageInfo2) WithRegionCount(y uint32) BlitImageInfo2 {
	x.regionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *BlitImageInfo2) SetRegionCount(y uint32) {
	x.regionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PRegions returns the value of pRegions from VkBlitImageInfo2
func (x BlitImageInfo2) PRegions() []ImageBlit2 {
	ptr := func(x **C.struct_VkImageBlit2) *[]ImageBlit2 { /* Slice */
		slc := unsafe.Slice((*ImageBlit2)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pRegions)
	return *ptr
}

// WithPRegions clones a new BlitImageInfo2 with the value of
// PRegions updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines RegionCount as the length of this field.
// RegionCount is updated with the length of the new value.
func (x BlitImageInfo2) WithPRegions(y []ImageBlit2) BlitImageInfo2 {
	x.pRegions = *(func(x *[]ImageBlit2) **C.struct_VkImageBlit2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkImageBlit2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkImageBlit2)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithRegionCount(uint32(len(y)))
}
func (x *BlitImageInfo2) SetPRegions(y []ImageBlit2) {
	x.pRegions = *(func(x *[]ImageBlit2) **C.struct_VkImageBlit2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkImageBlit2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkImageBlit2)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetRegionCount(uint32(len(y)))
}

// Filter returns the value of filter from VkBlitImageInfo2
func (x BlitImageInfo2) Filter() Filter {
	ptr := /* typedef */ (*Filter)(&x.filter)
	return *ptr
}

// WithFilter clones a new BlitImageInfo2 with the value of
// Filter updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BlitImageInfo2) WithFilter(y Filter) BlitImageInfo2 {
	x.filter = *( /* typedef */ (*C.VkFilter)(&y))
	return x
}
func (x *BlitImageInfo2) SetFilter(y Filter) {
	x.filter = *( /* typedef */ (*C.VkFilter)(&y))
}

// CopyImageToBufferInfo2 provides a go interface for VkCopyImageToBufferInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyImageToBufferInfo2.html
type CopyImageToBufferInfo2 C.struct_VkCopyImageToBufferInfo2

// SizeofCopyImageToBufferInfo2 is the memory size of a CopyImageToBufferInfo2
var SizeofCopyImageToBufferInfo2 int = int(unsafe.Sizeof(CopyImageToBufferInfo2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x CopyImageToBufferInfo2) ArpPtr(arp *AutoReleasePool) *CopyImageToBufferInfo2 {
	ptr := newCBlock(cULong(SizeofCopyImageToBufferInfo2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*CopyImageToBufferInfo2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *CopyImageToBufferInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x CopyImageToBufferInfo2) AsCPtr() *CopyImageToBufferInfo2 {
	clone := (*CopyImageToBufferInfo2)(newCBlock(cULong(SizeofCopyImageToBufferInfo2)))
	*clone = x
	return clone
}

// CopyImageToBufferInfo2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func CopyImageToBufferInfo2CSlice(arp *AutoReleasePool, x ...CopyImageToBufferInfo2) []CopyImageToBufferInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCopyImageToBufferInfo2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*CopyImageToBufferInfo2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// CopyImageToBufferInfo2FreeCSlice releases the memory allocated by CopyImageToBufferInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func CopyImageToBufferInfo2FreeCSlice(x []CopyImageToBufferInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// CopyImageToBufferInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. CopyImageToBufferInfo2FreeCSlice must be called on the returned slice.
func CopyImageToBufferInfo2MakeCSlice(x ...CopyImageToBufferInfo2) []CopyImageToBufferInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCopyImageToBufferInfo2 * len(x)
	dst := unsafe.Slice((*CopyImageToBufferInfo2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkCopyImageToBufferInfo2
func (x CopyImageToBufferInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new CopyImageToBufferInfo2 with the value of
// SType to the value provided in the specification.
func (x CopyImageToBufferInfo2) WithDefaultSType() CopyImageToBufferInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *CopyImageToBufferInfo2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2)
}

// WithSType clones a new CopyImageToBufferInfo2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyImageToBufferInfo2) WithSType(y StructureType) CopyImageToBufferInfo2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *CopyImageToBufferInfo2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkCopyImageToBufferInfo2
func (x CopyImageToBufferInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new CopyImageToBufferInfo2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyImageToBufferInfo2) WithPNext(y unsafe.Pointer) CopyImageToBufferInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *CopyImageToBufferInfo2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SrcImage returns the value of srcImage from VkCopyImageToBufferInfo2
func (x CopyImageToBufferInfo2) SrcImage() Image {
	ptr := /* handle */ (*Image)(&x.srcImage)
	return *ptr
}

// WithSrcImage clones a new CopyImageToBufferInfo2 with the value of
// SrcImage updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyImageToBufferInfo2) WithSrcImage(y Image) CopyImageToBufferInfo2 {
	x.srcImage = *( /* handle */ (*C.VkImage)(&y))
	return x
}
func (x *CopyImageToBufferInfo2) SetSrcImage(y Image) {
	x.srcImage = *( /* handle */ (*C.VkImage)(&y))
}

// SrcImageLayout returns the value of srcImageLayout from VkCopyImageToBufferInfo2
func (x CopyImageToBufferInfo2) SrcImageLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.srcImageLayout)
	return *ptr
}

// WithSrcImageLayout clones a new CopyImageToBufferInfo2 with the value of
// SrcImageLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyImageToBufferInfo2) WithSrcImageLayout(y ImageLayout) CopyImageToBufferInfo2 {
	x.srcImageLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
	return x
}
func (x *CopyImageToBufferInfo2) SetSrcImageLayout(y ImageLayout) {
	x.srcImageLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
}

// DstBuffer returns the value of dstBuffer from VkCopyImageToBufferInfo2
func (x CopyImageToBufferInfo2) DstBuffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.dstBuffer)
	return *ptr
}

// WithDstBuffer clones a new CopyImageToBufferInfo2 with the value of
// DstBuffer updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyImageToBufferInfo2) WithDstBuffer(y Buffer) CopyImageToBufferInfo2 {
	x.dstBuffer = *( /* handle */ (*C.VkBuffer)(&y))
	return x
}
func (x *CopyImageToBufferInfo2) SetDstBuffer(y Buffer) {
	x.dstBuffer = *( /* handle */ (*C.VkBuffer)(&y))
}

// RegionCount returns the value of regionCount from VkCopyImageToBufferInfo2
func (x CopyImageToBufferInfo2) RegionCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.regionCount)
	return *ptr
}

// WithRegionCount clones a new CopyImageToBufferInfo2 with the value of
// RegionCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyImageToBufferInfo2) WithRegionCount(y uint32) CopyImageToBufferInfo2 {
	x.regionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *CopyImageToBufferInfo2) SetRegionCount(y uint32) {
	x.regionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PRegions returns the value of pRegions from VkCopyImageToBufferInfo2
func (x CopyImageToBufferInfo2) PRegions() []BufferImageCopy2 {
	ptr := func(x **C.struct_VkBufferImageCopy2) *[]BufferImageCopy2 { /* Slice */
		slc := unsafe.Slice((*BufferImageCopy2)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pRegions)
	return *ptr
}

// WithPRegions clones a new CopyImageToBufferInfo2 with the value of
// PRegions updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines RegionCount as the length of this field.
// RegionCount is updated with the length of the new value.
func (x CopyImageToBufferInfo2) WithPRegions(y []BufferImageCopy2) CopyImageToBufferInfo2 {
	x.pRegions = *(func(x *[]BufferImageCopy2) **C.struct_VkBufferImageCopy2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkBufferImageCopy2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkBufferImageCopy2)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithRegionCount(uint32(len(y)))
}
func (x *CopyImageToBufferInfo2) SetPRegions(y []BufferImageCopy2) {
	x.pRegions = *(func(x *[]BufferImageCopy2) **C.struct_VkBufferImageCopy2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkBufferImageCopy2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkBufferImageCopy2)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetRegionCount(uint32(len(y)))
}

// CopyBufferToImageInfo2 provides a go interface for VkCopyBufferToImageInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyBufferToImageInfo2.html
type CopyBufferToImageInfo2 C.struct_VkCopyBufferToImageInfo2

// SizeofCopyBufferToImageInfo2 is the memory size of a CopyBufferToImageInfo2
var SizeofCopyBufferToImageInfo2 int = int(unsafe.Sizeof(CopyBufferToImageInfo2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x CopyBufferToImageInfo2) ArpPtr(arp *AutoReleasePool) *CopyBufferToImageInfo2 {
	ptr := newCBlock(cULong(SizeofCopyBufferToImageInfo2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*CopyBufferToImageInfo2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *CopyBufferToImageInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x CopyBufferToImageInfo2) AsCPtr() *CopyBufferToImageInfo2 {
	clone := (*CopyBufferToImageInfo2)(newCBlock(cULong(SizeofCopyBufferToImageInfo2)))
	*clone = x
	return clone
}

// CopyBufferToImageInfo2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func CopyBufferToImageInfo2CSlice(arp *AutoReleasePool, x ...CopyBufferToImageInfo2) []CopyBufferToImageInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCopyBufferToImageInfo2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*CopyBufferToImageInfo2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// CopyBufferToImageInfo2FreeCSlice releases the memory allocated by CopyBufferToImageInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func CopyBufferToImageInfo2FreeCSlice(x []CopyBufferToImageInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// CopyBufferToImageInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. CopyBufferToImageInfo2FreeCSlice must be called on the returned slice.
func CopyBufferToImageInfo2MakeCSlice(x ...CopyBufferToImageInfo2) []CopyBufferToImageInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCopyBufferToImageInfo2 * len(x)
	dst := unsafe.Slice((*CopyBufferToImageInfo2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkCopyBufferToImageInfo2
func (x CopyBufferToImageInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new CopyBufferToImageInfo2 with the value of
// SType to the value provided in the specification.
func (x CopyBufferToImageInfo2) WithDefaultSType() CopyBufferToImageInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *CopyBufferToImageInfo2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2)
}

// WithSType clones a new CopyBufferToImageInfo2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyBufferToImageInfo2) WithSType(y StructureType) CopyBufferToImageInfo2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *CopyBufferToImageInfo2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkCopyBufferToImageInfo2
func (x CopyBufferToImageInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new CopyBufferToImageInfo2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyBufferToImageInfo2) WithPNext(y unsafe.Pointer) CopyBufferToImageInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *CopyBufferToImageInfo2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SrcBuffer returns the value of srcBuffer from VkCopyBufferToImageInfo2
func (x CopyBufferToImageInfo2) SrcBuffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.srcBuffer)
	return *ptr
}

// WithSrcBuffer clones a new CopyBufferToImageInfo2 with the value of
// SrcBuffer updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyBufferToImageInfo2) WithSrcBuffer(y Buffer) CopyBufferToImageInfo2 {
	x.srcBuffer = *( /* handle */ (*C.VkBuffer)(&y))
	return x
}
func (x *CopyBufferToImageInfo2) SetSrcBuffer(y Buffer) {
	x.srcBuffer = *( /* handle */ (*C.VkBuffer)(&y))
}

// DstImage returns the value of dstImage from VkCopyBufferToImageInfo2
func (x CopyBufferToImageInfo2) DstImage() Image {
	ptr := /* handle */ (*Image)(&x.dstImage)
	return *ptr
}

// WithDstImage clones a new CopyBufferToImageInfo2 with the value of
// DstImage updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyBufferToImageInfo2) WithDstImage(y Image) CopyBufferToImageInfo2 {
	x.dstImage = *( /* handle */ (*C.VkImage)(&y))
	return x
}
func (x *CopyBufferToImageInfo2) SetDstImage(y Image) {
	x.dstImage = *( /* handle */ (*C.VkImage)(&y))
}

// DstImageLayout returns the value of dstImageLayout from VkCopyBufferToImageInfo2
func (x CopyBufferToImageInfo2) DstImageLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.dstImageLayout)
	return *ptr
}

// WithDstImageLayout clones a new CopyBufferToImageInfo2 with the value of
// DstImageLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyBufferToImageInfo2) WithDstImageLayout(y ImageLayout) CopyBufferToImageInfo2 {
	x.dstImageLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
	return x
}
func (x *CopyBufferToImageInfo2) SetDstImageLayout(y ImageLayout) {
	x.dstImageLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
}

// RegionCount returns the value of regionCount from VkCopyBufferToImageInfo2
func (x CopyBufferToImageInfo2) RegionCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.regionCount)
	return *ptr
}

// WithRegionCount clones a new CopyBufferToImageInfo2 with the value of
// RegionCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyBufferToImageInfo2) WithRegionCount(y uint32) CopyBufferToImageInfo2 {
	x.regionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *CopyBufferToImageInfo2) SetRegionCount(y uint32) {
	x.regionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PRegions returns the value of pRegions from VkCopyBufferToImageInfo2
func (x CopyBufferToImageInfo2) PRegions() []BufferImageCopy2 {
	ptr := func(x **C.struct_VkBufferImageCopy2) *[]BufferImageCopy2 { /* Slice */
		slc := unsafe.Slice((*BufferImageCopy2)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pRegions)
	return *ptr
}

// WithPRegions clones a new CopyBufferToImageInfo2 with the value of
// PRegions updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines RegionCount as the length of this field.
// RegionCount is updated with the length of the new value.
func (x CopyBufferToImageInfo2) WithPRegions(y []BufferImageCopy2) CopyBufferToImageInfo2 {
	x.pRegions = *(func(x *[]BufferImageCopy2) **C.struct_VkBufferImageCopy2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkBufferImageCopy2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkBufferImageCopy2)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithRegionCount(uint32(len(y)))
}
func (x *CopyBufferToImageInfo2) SetPRegions(y []BufferImageCopy2) {
	x.pRegions = *(func(x *[]BufferImageCopy2) **C.struct_VkBufferImageCopy2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkBufferImageCopy2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkBufferImageCopy2)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetRegionCount(uint32(len(y)))
}

// CopyImageInfo2 provides a go interface for VkCopyImageInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyImageInfo2.html
type CopyImageInfo2 C.struct_VkCopyImageInfo2

// SizeofCopyImageInfo2 is the memory size of a CopyImageInfo2
var SizeofCopyImageInfo2 int = int(unsafe.Sizeof(CopyImageInfo2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x CopyImageInfo2) ArpPtr(arp *AutoReleasePool) *CopyImageInfo2 {
	ptr := newCBlock(cULong(SizeofCopyImageInfo2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*CopyImageInfo2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *CopyImageInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x CopyImageInfo2) AsCPtr() *CopyImageInfo2 {
	clone := (*CopyImageInfo2)(newCBlock(cULong(SizeofCopyImageInfo2)))
	*clone = x
	return clone
}

// CopyImageInfo2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func CopyImageInfo2CSlice(arp *AutoReleasePool, x ...CopyImageInfo2) []CopyImageInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCopyImageInfo2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*CopyImageInfo2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// CopyImageInfo2FreeCSlice releases the memory allocated by CopyImageInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func CopyImageInfo2FreeCSlice(x []CopyImageInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// CopyImageInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. CopyImageInfo2FreeCSlice must be called on the returned slice.
func CopyImageInfo2MakeCSlice(x ...CopyImageInfo2) []CopyImageInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCopyImageInfo2 * len(x)
	dst := unsafe.Slice((*CopyImageInfo2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkCopyImageInfo2
func (x CopyImageInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new CopyImageInfo2 with the value of
// SType to the value provided in the specification.
func (x CopyImageInfo2) WithDefaultSType() CopyImageInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *CopyImageInfo2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2)
}

// WithSType clones a new CopyImageInfo2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyImageInfo2) WithSType(y StructureType) CopyImageInfo2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *CopyImageInfo2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkCopyImageInfo2
func (x CopyImageInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new CopyImageInfo2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyImageInfo2) WithPNext(y unsafe.Pointer) CopyImageInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *CopyImageInfo2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SrcImage returns the value of srcImage from VkCopyImageInfo2
func (x CopyImageInfo2) SrcImage() Image {
	ptr := /* handle */ (*Image)(&x.srcImage)
	return *ptr
}

// WithSrcImage clones a new CopyImageInfo2 with the value of
// SrcImage updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyImageInfo2) WithSrcImage(y Image) CopyImageInfo2 {
	x.srcImage = *( /* handle */ (*C.VkImage)(&y))
	return x
}
func (x *CopyImageInfo2) SetSrcImage(y Image) {
	x.srcImage = *( /* handle */ (*C.VkImage)(&y))
}

// SrcImageLayout returns the value of srcImageLayout from VkCopyImageInfo2
func (x CopyImageInfo2) SrcImageLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.srcImageLayout)
	return *ptr
}

// WithSrcImageLayout clones a new CopyImageInfo2 with the value of
// SrcImageLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyImageInfo2) WithSrcImageLayout(y ImageLayout) CopyImageInfo2 {
	x.srcImageLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
	return x
}
func (x *CopyImageInfo2) SetSrcImageLayout(y ImageLayout) {
	x.srcImageLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
}

// DstImage returns the value of dstImage from VkCopyImageInfo2
func (x CopyImageInfo2) DstImage() Image {
	ptr := /* handle */ (*Image)(&x.dstImage)
	return *ptr
}

// WithDstImage clones a new CopyImageInfo2 with the value of
// DstImage updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyImageInfo2) WithDstImage(y Image) CopyImageInfo2 {
	x.dstImage = *( /* handle */ (*C.VkImage)(&y))
	return x
}
func (x *CopyImageInfo2) SetDstImage(y Image) {
	x.dstImage = *( /* handle */ (*C.VkImage)(&y))
}

// DstImageLayout returns the value of dstImageLayout from VkCopyImageInfo2
func (x CopyImageInfo2) DstImageLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.dstImageLayout)
	return *ptr
}

// WithDstImageLayout clones a new CopyImageInfo2 with the value of
// DstImageLayout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyImageInfo2) WithDstImageLayout(y ImageLayout) CopyImageInfo2 {
	x.dstImageLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
	return x
}
func (x *CopyImageInfo2) SetDstImageLayout(y ImageLayout) {
	x.dstImageLayout = *( /* typedef */ (*C.VkImageLayout)(&y))
}

// RegionCount returns the value of regionCount from VkCopyImageInfo2
func (x CopyImageInfo2) RegionCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.regionCount)
	return *ptr
}

// WithRegionCount clones a new CopyImageInfo2 with the value of
// RegionCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyImageInfo2) WithRegionCount(y uint32) CopyImageInfo2 {
	x.regionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *CopyImageInfo2) SetRegionCount(y uint32) {
	x.regionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PRegions returns the value of pRegions from VkCopyImageInfo2
func (x CopyImageInfo2) PRegions() []ImageCopy2 {
	ptr := func(x **C.struct_VkImageCopy2) *[]ImageCopy2 { /* Slice */
		slc := unsafe.Slice((*ImageCopy2)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pRegions)
	return *ptr
}

// WithPRegions clones a new CopyImageInfo2 with the value of
// PRegions updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines RegionCount as the length of this field.
// RegionCount is updated with the length of the new value.
func (x CopyImageInfo2) WithPRegions(y []ImageCopy2) CopyImageInfo2 {
	x.pRegions = *(func(x *[]ImageCopy2) **C.struct_VkImageCopy2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkImageCopy2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkImageCopy2)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithRegionCount(uint32(len(y)))
}
func (x *CopyImageInfo2) SetPRegions(y []ImageCopy2) {
	x.pRegions = *(func(x *[]ImageCopy2) **C.struct_VkImageCopy2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkImageCopy2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkImageCopy2)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetRegionCount(uint32(len(y)))
}

// CopyBufferInfo2 provides a go interface for VkCopyBufferInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyBufferInfo2.html
type CopyBufferInfo2 C.struct_VkCopyBufferInfo2

// SizeofCopyBufferInfo2 is the memory size of a CopyBufferInfo2
var SizeofCopyBufferInfo2 int = int(unsafe.Sizeof(CopyBufferInfo2{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x CopyBufferInfo2) ArpPtr(arp *AutoReleasePool) *CopyBufferInfo2 {
	ptr := newCBlock(cULong(SizeofCopyBufferInfo2))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*CopyBufferInfo2)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *CopyBufferInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x CopyBufferInfo2) AsCPtr() *CopyBufferInfo2 {
	clone := (*CopyBufferInfo2)(newCBlock(cULong(SizeofCopyBufferInfo2)))
	*clone = x
	return clone
}

// CopyBufferInfo2CSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func CopyBufferInfo2CSlice(arp *AutoReleasePool, x ...CopyBufferInfo2) []CopyBufferInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCopyBufferInfo2 * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*CopyBufferInfo2)(ptr), len(x))
	copy(dst, x)
	return dst
}

// CopyBufferInfo2FreeCSlice releases the memory allocated by CopyBufferInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func CopyBufferInfo2FreeCSlice(x []CopyBufferInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// CopyBufferInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. CopyBufferInfo2FreeCSlice must be called on the returned slice.
func CopyBufferInfo2MakeCSlice(x ...CopyBufferInfo2) []CopyBufferInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCopyBufferInfo2 * len(x)
	dst := unsafe.Slice((*CopyBufferInfo2)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkCopyBufferInfo2
func (x CopyBufferInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new CopyBufferInfo2 with the value of
// SType to the value provided in the specification.
func (x CopyBufferInfo2) WithDefaultSType() CopyBufferInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *CopyBufferInfo2) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2)
}

// WithSType clones a new CopyBufferInfo2 with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyBufferInfo2) WithSType(y StructureType) CopyBufferInfo2 {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *CopyBufferInfo2) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkCopyBufferInfo2
func (x CopyBufferInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new CopyBufferInfo2 with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyBufferInfo2) WithPNext(y unsafe.Pointer) CopyBufferInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *CopyBufferInfo2) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SrcBuffer returns the value of srcBuffer from VkCopyBufferInfo2
func (x CopyBufferInfo2) SrcBuffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.srcBuffer)
	return *ptr
}

// WithSrcBuffer clones a new CopyBufferInfo2 with the value of
// SrcBuffer updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyBufferInfo2) WithSrcBuffer(y Buffer) CopyBufferInfo2 {
	x.srcBuffer = *( /* handle */ (*C.VkBuffer)(&y))
	return x
}
func (x *CopyBufferInfo2) SetSrcBuffer(y Buffer) {
	x.srcBuffer = *( /* handle */ (*C.VkBuffer)(&y))
}

// DstBuffer returns the value of dstBuffer from VkCopyBufferInfo2
func (x CopyBufferInfo2) DstBuffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.dstBuffer)
	return *ptr
}

// WithDstBuffer clones a new CopyBufferInfo2 with the value of
// DstBuffer updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyBufferInfo2) WithDstBuffer(y Buffer) CopyBufferInfo2 {
	x.dstBuffer = *( /* handle */ (*C.VkBuffer)(&y))
	return x
}
func (x *CopyBufferInfo2) SetDstBuffer(y Buffer) {
	x.dstBuffer = *( /* handle */ (*C.VkBuffer)(&y))
}

// RegionCount returns the value of regionCount from VkCopyBufferInfo2
func (x CopyBufferInfo2) RegionCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.regionCount)
	return *ptr
}

// WithRegionCount clones a new CopyBufferInfo2 with the value of
// RegionCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyBufferInfo2) WithRegionCount(y uint32) CopyBufferInfo2 {
	x.regionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *CopyBufferInfo2) SetRegionCount(y uint32) {
	x.regionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PRegions returns the value of pRegions from VkCopyBufferInfo2
func (x CopyBufferInfo2) PRegions() []BufferCopy2 {
	ptr := func(x **C.struct_VkBufferCopy2) *[]BufferCopy2 { /* Slice */
		slc := unsafe.Slice((*BufferCopy2)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pRegions)
	return *ptr
}

// WithPRegions clones a new CopyBufferInfo2 with the value of
// PRegions updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines RegionCount as the length of this field.
// RegionCount is updated with the length of the new value.
func (x CopyBufferInfo2) WithPRegions(y []BufferCopy2) CopyBufferInfo2 {
	x.pRegions = *(func(x *[]BufferCopy2) **C.struct_VkBufferCopy2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkBufferCopy2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkBufferCopy2)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithRegionCount(uint32(len(y)))
}
func (x *CopyBufferInfo2) SetPRegions(y []BufferCopy2) {
	x.pRegions = *(func(x *[]BufferCopy2) **C.struct_VkBufferCopy2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkBufferCopy2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkBufferCopy2)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetRegionCount(uint32(len(y)))
}

// PhysicalDeviceImageRobustnessFeatures provides a go interface for VkPhysicalDeviceImageRobustnessFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageRobustnessFeatures.html
type PhysicalDeviceImageRobustnessFeatures C.struct_VkPhysicalDeviceImageRobustnessFeatures

// SizeofPhysicalDeviceImageRobustnessFeatures is the memory size of a PhysicalDeviceImageRobustnessFeatures
var SizeofPhysicalDeviceImageRobustnessFeatures int = int(unsafe.Sizeof(PhysicalDeviceImageRobustnessFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceImageRobustnessFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceImageRobustnessFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceImageRobustnessFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceImageRobustnessFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceImageRobustnessFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceImageRobustnessFeatures) AsCPtr() *PhysicalDeviceImageRobustnessFeatures {
	clone := (*PhysicalDeviceImageRobustnessFeatures)(newCBlock(cULong(SizeofPhysicalDeviceImageRobustnessFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceImageRobustnessFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceImageRobustnessFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceImageRobustnessFeatures) []PhysicalDeviceImageRobustnessFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceImageRobustnessFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceImageRobustnessFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceImageRobustnessFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceImageRobustnessFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceImageRobustnessFeaturesFreeCSlice(x []PhysicalDeviceImageRobustnessFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceImageRobustnessFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceImageRobustnessFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceImageRobustnessFeaturesMakeCSlice(x ...PhysicalDeviceImageRobustnessFeatures) []PhysicalDeviceImageRobustnessFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceImageRobustnessFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceImageRobustnessFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceImageRobustnessFeatures
func (x PhysicalDeviceImageRobustnessFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceImageRobustnessFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceImageRobustnessFeatures) WithDefaultSType() PhysicalDeviceImageRobustnessFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceImageRobustnessFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES)
}

// WithSType clones a new PhysicalDeviceImageRobustnessFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImageRobustnessFeatures) WithSType(y StructureType) PhysicalDeviceImageRobustnessFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceImageRobustnessFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceImageRobustnessFeatures
func (x PhysicalDeviceImageRobustnessFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceImageRobustnessFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImageRobustnessFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceImageRobustnessFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceImageRobustnessFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// RobustImageAccess returns the value of robustImageAccess from VkPhysicalDeviceImageRobustnessFeatures
func (x PhysicalDeviceImageRobustnessFeatures) RobustImageAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.robustImageAccess)
	return *ptr
}

// WithRobustImageAccess clones a new PhysicalDeviceImageRobustnessFeatures with the value of
// RobustImageAccess updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImageRobustnessFeatures) WithRobustImageAccess(y Bool32) PhysicalDeviceImageRobustnessFeatures {
	x.robustImageAccess = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceImageRobustnessFeatures) SetRobustImageAccess(y Bool32) {
	x.robustImageAccess = *( /* typedef */ (*C.VkBool32)(&y))
}

// PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures provides a go interface for VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures.html
type PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures C.struct_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures

// SizeofPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures is the memory size of a PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures
var SizeofPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures int = int(unsafe.Sizeof(PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) AsCPtr() *PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
	clone := (*PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures)(newCBlock(cULong(SizeofPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesCSlice(arp *AutoReleasePool, x ...PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) []PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesFreeCSlice(x []PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesMakeCSlice(x ...PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) []PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures
func (x PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) WithDefaultSType() PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES)
}

// WithSType clones a new PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) WithSType(y StructureType) PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures
func (x PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// ShaderZeroInitializeWorkgroupMemory returns the value of shaderZeroInitializeWorkgroupMemory from VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures
func (x PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) ShaderZeroInitializeWorkgroupMemory() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderZeroInitializeWorkgroupMemory)
	return *ptr
}

// WithShaderZeroInitializeWorkgroupMemory clones a new PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures with the value of
// ShaderZeroInitializeWorkgroupMemory updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) WithShaderZeroInitializeWorkgroupMemory(y Bool32) PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
	x.shaderZeroInitializeWorkgroupMemory = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) SetShaderZeroInitializeWorkgroupMemory(y Bool32) {
	x.shaderZeroInitializeWorkgroupMemory = *( /* typedef */ (*C.VkBool32)(&y))
}

// CmdWriteTimestamp2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteTimestamp2.html
func (x CommandBufferFacade) CmdWriteTimestamp2(stage PipelineStageFlags2, queryPool QueryPool, query uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkPipelineStageFlags2)(&stage)
	p2 := /* handle */ (*C.VkQueryPool)(&queryPool)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&query)
	C.vkCmdWriteTimestamp2(addrs, *p0, *p1, *p2, *p3)
}

// CmdCopyImage2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImage2.html
func (x CommandBufferFacade) CmdCopyImage2(pCopyImageInfo *CopyImageInfo2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **CopyImageInfo2) **C.struct_VkCopyImageInfo2 { /* Pointer */
		g2c := (*C.struct_VkCopyImageInfo2)(*x)
		return &g2c
	}(&pCopyImageInfo)
	C.vkCmdCopyImage2(addrs, *p0, *p1)
}

// CmdSetDepthBoundsTestEnable command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBoundsTestEnable.html
func (x CommandBufferFacade) CmdSetDepthBoundsTestEnable(depthBoundsTestEnable Bool32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkBool32)(&depthBoundsTestEnable)
	C.vkCmdSetDepthBoundsTestEnable(addrs, *p0, *p1)
}

// CmdSetStencilOp command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilOp.html
func (x CommandBufferFacade) CmdSetStencilOp(faceMask StencilFaceFlags, failOp StencilOp, passOp StencilOp, depthFailOp StencilOp, compareOp CompareOp) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkStencilFaceFlags)(&faceMask)
	p2 := /* typedef */ (*C.VkStencilOp)(&failOp)
	p3 := /* typedef */ (*C.VkStencilOp)(&passOp)
	p4 := /* typedef */ (*C.VkStencilOp)(&depthFailOp)
	p5 := /* typedef */ (*C.VkCompareOp)(&compareOp)
	C.vkCmdSetStencilOp(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
}

// CmdSetDepthWriteEnable command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthWriteEnable.html
func (x CommandBufferFacade) CmdSetDepthWriteEnable(depthWriteEnable Bool32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkBool32)(&depthWriteEnable)
	C.vkCmdSetDepthWriteEnable(addrs, *p0, *p1)
}

// CmdSetDepthTestEnable command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthTestEnable.html
func (x CommandBufferFacade) CmdSetDepthTestEnable(depthTestEnable Bool32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkBool32)(&depthTestEnable)
	C.vkCmdSetDepthTestEnable(addrs, *p0, *p1)
}

// CmdBindVertexBuffers2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindVertexBuffers2.html
func (x CommandBufferFacade) CmdBindVertexBuffers2(firstBinding uint32, bindingCount uint32, pBuffers []Buffer, pOffsets []DeviceSize, pSizes []DeviceSize, pStrides []DeviceSize) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&firstBinding)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&bindingCount)
	p3 := func(x *[]Buffer) **C.VkBuffer { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkBuffer)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkBuffer)(unsafe.Pointer((&ptr)))
	}(&pBuffers)
	p4 := func(x *[]DeviceSize) **C.VkDeviceSize { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkDeviceSize)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkDeviceSize)(unsafe.Pointer((&ptr)))
	}(&pOffsets)
	p5 := func(x *[]DeviceSize) **C.VkDeviceSize { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkDeviceSize)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkDeviceSize)(unsafe.Pointer((&ptr)))
	}(&pSizes)
	p6 := func(x *[]DeviceSize) **C.VkDeviceSize { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkDeviceSize)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkDeviceSize)(unsafe.Pointer((&ptr)))
	}(&pStrides)
	C.vkCmdBindVertexBuffers2(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6)
}

// CmdSetScissorWithCount command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetScissorWithCount.html
func (x CommandBufferFacade) CmdSetScissorWithCount(scissorCount uint32, pScissors []Rect2D) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&scissorCount)
	p2 := func(x *[]Rect2D) **C.struct_VkRect2D { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkRect2D)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkRect2D)(unsafe.Pointer((&ptr)))
	}(&pScissors)
	C.vkCmdSetScissorWithCount(addrs, *p0, *p1, *p2)
}

// CmdSetViewportWithCount command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportWithCount.html
func (x CommandBufferFacade) CmdSetViewportWithCount(viewportCount uint32, pViewports []Viewport) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&viewportCount)
	p2 := func(x *[]Viewport) **C.struct_VkViewport { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkViewport)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkViewport)(unsafe.Pointer((&ptr)))
	}(&pViewports)
	C.vkCmdSetViewportWithCount(addrs, *p0, *p1, *p2)
}

// CmdSetPrimitiveTopology command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPrimitiveTopology.html
func (x CommandBufferFacade) CmdSetPrimitiveTopology(primitiveTopology PrimitiveTopology) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkPrimitiveTopology)(&primitiveTopology)
	C.vkCmdSetPrimitiveTopology(addrs, *p0, *p1)
}

// CmdSetFrontFace command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetFrontFace.html
func (x CommandBufferFacade) CmdSetFrontFace(frontFace FrontFace) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkFrontFace)(&frontFace)
	C.vkCmdSetFrontFace(addrs, *p0, *p1)
}

// CmdSetCullMode command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCullMode.html
func (x CommandBufferFacade) CmdSetCullMode(cullMode CullModeFlags) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkCullModeFlags)(&cullMode)
	C.vkCmdSetCullMode(addrs, *p0, *p1)
}

// CmdSetEvent2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetEvent2.html
func (x CommandBufferFacade) CmdSetEvent2(event Event, pDependencyInfo *DependencyInfo) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkEvent)(&event)
	p2 := func(x **DependencyInfo) **C.struct_VkDependencyInfo { /* Pointer */
		g2c := (*C.struct_VkDependencyInfo)(*x)
		return &g2c
	}(&pDependencyInfo)
	C.vkCmdSetEvent2(addrs, *p0, *p1, *p2)
}

// CmdEndRendering command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndRendering.html
func (x CommandBufferFacade) CmdEndRendering() {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	C.vkCmdEndRendering(addrs, *p0)
}

// CmdBeginRendering command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRendering.html
func (x CommandBufferFacade) CmdBeginRendering(pRenderingInfo *RenderingInfo) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **RenderingInfo) **C.struct_VkRenderingInfo { /* Pointer */
		g2c := (*C.struct_VkRenderingInfo)(*x)
		return &g2c
	}(&pRenderingInfo)
	C.vkCmdBeginRendering(addrs, *p0, *p1)
}

// CmdResetEvent2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResetEvent2.html
func (x CommandBufferFacade) CmdResetEvent2(event Event, stageMask PipelineStageFlags2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkEvent)(&event)
	p2 := /* typedef */ (*C.VkPipelineStageFlags2)(&stageMask)
	C.vkCmdResetEvent2(addrs, *p0, *p1, *p2)
}

// CmdWaitEvents2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWaitEvents2.html
func (x CommandBufferFacade) CmdWaitEvents2(eventCount uint32, pEvents []Event, pDependencyInfos []DependencyInfo) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&eventCount)
	p2 := func(x *[]Event) **C.VkEvent { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkEvent)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkEvent)(unsafe.Pointer((&ptr)))
	}(&pEvents)
	p3 := func(x *[]DependencyInfo) **C.struct_VkDependencyInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDependencyInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDependencyInfo)(unsafe.Pointer((&ptr)))
	}(&pDependencyInfos)
	C.vkCmdWaitEvents2(addrs, *p0, *p1, *p2, *p3)
}

// CmdPipelineBarrier2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPipelineBarrier2.html
func (x CommandBufferFacade) CmdPipelineBarrier2(pDependencyInfo *DependencyInfo) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **DependencyInfo) **C.struct_VkDependencyInfo { /* Pointer */
		g2c := (*C.struct_VkDependencyInfo)(*x)
		return &g2c
	}(&pDependencyInfo)
	C.vkCmdPipelineBarrier2(addrs, *p0, *p1)
}

// CmdSetDepthCompareOp command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthCompareOp.html
func (x CommandBufferFacade) CmdSetDepthCompareOp(depthCompareOp CompareOp) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkCompareOp)(&depthCompareOp)
	C.vkCmdSetDepthCompareOp(addrs, *p0, *p1)
}

// CmdSetStencilTestEnable command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilTestEnable.html
func (x CommandBufferFacade) CmdSetStencilTestEnable(stencilTestEnable Bool32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkBool32)(&stencilTestEnable)
	C.vkCmdSetStencilTestEnable(addrs, *p0, *p1)
}

// CmdSetPrimitiveRestartEnable command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPrimitiveRestartEnable.html
func (x CommandBufferFacade) CmdSetPrimitiveRestartEnable(primitiveRestartEnable Bool32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkBool32)(&primitiveRestartEnable)
	C.vkCmdSetPrimitiveRestartEnable(addrs, *p0, *p1)
}

// CmdSetDepthBiasEnable command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBiasEnable.html
func (x CommandBufferFacade) CmdSetDepthBiasEnable(depthBiasEnable Bool32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkBool32)(&depthBiasEnable)
	C.vkCmdSetDepthBiasEnable(addrs, *p0, *p1)
}

// QueueSubmit2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueSubmit2.html
func (x QueueFacade) QueueSubmit2(submitCount uint32, pSubmits []SubmitInfo2, fence Fence) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkQueue)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&submitCount)
	p2 := func(x *[]SubmitInfo2) **C.struct_VkSubmitInfo2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSubmitInfo2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSubmitInfo2)(unsafe.Pointer((&ptr)))
	}(&pSubmits)
	p3 := /* handle */ (*C.VkFence)(&fence)
	ret := C.vkQueueSubmit2(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceToolProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceToolProperties.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceToolProperties(pToolCount *uint32, pToolProperties []PhysicalDeviceToolProperties) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pToolCount)
	p2 := func(x *[]PhysicalDeviceToolProperties) **C.struct_VkPhysicalDeviceToolProperties { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkPhysicalDeviceToolProperties)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkPhysicalDeviceToolProperties)(unsafe.Pointer((&ptr)))
	}(&pToolProperties)
	ret := C.vkGetPhysicalDeviceToolProperties(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CmdResolveImage2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResolveImage2.html
func (x CommandBufferFacade) CmdResolveImage2(pResolveImageInfo *ResolveImageInfo2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **ResolveImageInfo2) **C.struct_VkResolveImageInfo2 { /* Pointer */
		g2c := (*C.struct_VkResolveImageInfo2)(*x)
		return &g2c
	}(&pResolveImageInfo)
	C.vkCmdResolveImage2(addrs, *p0, *p1)
}

// GetDeviceBufferMemoryRequirements command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceBufferMemoryRequirements.html
func (x DeviceFacade) GetDeviceBufferMemoryRequirements(pInfo *DeviceBufferMemoryRequirements, pMemoryRequirements *MemoryRequirements2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DeviceBufferMemoryRequirements) **C.struct_VkDeviceBufferMemoryRequirements { /* Pointer */
		g2c := (*C.struct_VkDeviceBufferMemoryRequirements)(*x)
		return &g2c
	}(&pInfo)
	p2 := func(x **MemoryRequirements2) **C.struct_VkMemoryRequirements2 { /* Pointer */
		g2c := (*C.struct_VkMemoryRequirements2)(*x)
		return &g2c
	}(&pMemoryRequirements)
	C.vkGetDeviceBufferMemoryRequirements(addrs, *p0, *p1, *p2)
}

// GetDeviceImageMemoryRequirements command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceImageMemoryRequirements.html
func (x DeviceFacade) GetDeviceImageMemoryRequirements(pInfo *DeviceImageMemoryRequirements, pMemoryRequirements *MemoryRequirements2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DeviceImageMemoryRequirements) **C.struct_VkDeviceImageMemoryRequirements { /* Pointer */
		g2c := (*C.struct_VkDeviceImageMemoryRequirements)(*x)
		return &g2c
	}(&pInfo)
	p2 := func(x **MemoryRequirements2) **C.struct_VkMemoryRequirements2 { /* Pointer */
		g2c := (*C.struct_VkMemoryRequirements2)(*x)
		return &g2c
	}(&pMemoryRequirements)
	C.vkGetDeviceImageMemoryRequirements(addrs, *p0, *p1, *p2)
}

// GetDeviceImageSparseMemoryRequirements command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceImageSparseMemoryRequirements.html
func (x DeviceFacade) GetDeviceImageSparseMemoryRequirements(pInfo *DeviceImageMemoryRequirements, pSparseMemoryRequirementCount *uint32, pSparseMemoryRequirements []SparseImageMemoryRequirements2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DeviceImageMemoryRequirements) **C.struct_VkDeviceImageMemoryRequirements { /* Pointer */
		g2c := (*C.struct_VkDeviceImageMemoryRequirements)(*x)
		return &g2c
	}(&pInfo)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pSparseMemoryRequirementCount)
	p3 := func(x *[]SparseImageMemoryRequirements2) **C.struct_VkSparseImageMemoryRequirements2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSparseImageMemoryRequirements2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSparseImageMemoryRequirements2)(unsafe.Pointer((&ptr)))
	}(&pSparseMemoryRequirements)
	C.vkGetDeviceImageSparseMemoryRequirements(addrs, *p0, *p1, *p2, *p3)
}

// GetPrivateData command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPrivateData.html
func (x DeviceFacade) GetPrivateData(objectType ObjectType, objectHandle uint64, privateDataSlot PrivateDataSlot, pData *uint64) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* typedef */ (*C.VkObjectType)(&objectType)
	p2 := func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&objectHandle)
	p3 := /* handle */ (*C.VkPrivateDataSlot)(&privateDataSlot)
	p4 := func(x **uint64) **C.uint64_t { /* Pointer */ g2c := (*C.uint64_t)(*x); return &g2c }(&pData)
	C.vkGetPrivateData(addrs, *p0, *p1, *p2, *p3, *p4)
}

// SetPrivateData command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetPrivateData.html
func (x DeviceFacade) SetPrivateData(objectType ObjectType, objectHandle uint64, privateDataSlot PrivateDataSlot, data uint64) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* typedef */ (*C.VkObjectType)(&objectType)
	p2 := func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&objectHandle)
	p3 := /* handle */ (*C.VkPrivateDataSlot)(&privateDataSlot)
	p4 := func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&data)
	ret := C.vkSetPrivateData(addrs, *p0, *p1, *p2, *p3, *p4)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroyPrivateDataSlot command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPrivateDataSlot.html
func (x DeviceFacade) DestroyPrivateDataSlot(privateDataSlot PrivateDataSlot, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkPrivateDataSlot)(&privateDataSlot)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	C.vkDestroyPrivateDataSlot(addrs, *p0, *p1, *p2)
}

// CreatePrivateDataSlot command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreatePrivateDataSlot.html
func (x DeviceFacade) CreatePrivateDataSlot(pCreateInfo *PrivateDataSlotCreateInfo, pAllocator *AllocationCallbacks, pPrivateDataSlot *PrivateDataSlot) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **PrivateDataSlotCreateInfo) **C.struct_VkPrivateDataSlotCreateInfo { /* Pointer */
		g2c := (*C.struct_VkPrivateDataSlotCreateInfo)(*x)
		return &g2c
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p3 := func(x **PrivateDataSlot) **C.VkPrivateDataSlot { /* Pointer */
		g2c := (*C.VkPrivateDataSlot)(*x)
		return &g2c
	}(&pPrivateDataSlot)
	ret := C.vkCreatePrivateDataSlot(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CmdBlitImage2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBlitImage2.html
func (x CommandBufferFacade) CmdBlitImage2(pBlitImageInfo *BlitImageInfo2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **BlitImageInfo2) **C.struct_VkBlitImageInfo2 { /* Pointer */
		g2c := (*C.struct_VkBlitImageInfo2)(*x)
		return &g2c
	}(&pBlitImageInfo)
	C.vkCmdBlitImage2(addrs, *p0, *p1)
}

// CmdCopyImageToBuffer2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImageToBuffer2.html
func (x CommandBufferFacade) CmdCopyImageToBuffer2(pCopyImageToBufferInfo *CopyImageToBufferInfo2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **CopyImageToBufferInfo2) **C.struct_VkCopyImageToBufferInfo2 { /* Pointer */
		g2c := (*C.struct_VkCopyImageToBufferInfo2)(*x)
		return &g2c
	}(&pCopyImageToBufferInfo)
	C.vkCmdCopyImageToBuffer2(addrs, *p0, *p1)
}

// CmdCopyBufferToImage2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBufferToImage2.html
func (x CommandBufferFacade) CmdCopyBufferToImage2(pCopyBufferToImageInfo *CopyBufferToImageInfo2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **CopyBufferToImageInfo2) **C.struct_VkCopyBufferToImageInfo2 { /* Pointer */
		g2c := (*C.struct_VkCopyBufferToImageInfo2)(*x)
		return &g2c
	}(&pCopyBufferToImageInfo)
	C.vkCmdCopyBufferToImage2(addrs, *p0, *p1)
}

// CmdSetRasterizerDiscardEnable command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRasterizerDiscardEnable.html
func (x CommandBufferFacade) CmdSetRasterizerDiscardEnable(rasterizerDiscardEnable Bool32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkBool32)(&rasterizerDiscardEnable)
	C.vkCmdSetRasterizerDiscardEnable(addrs, *p0, *p1)
}

// CmdCopyBuffer2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBuffer2.html
func (x CommandBufferFacade) CmdCopyBuffer2(pCopyBufferInfo *CopyBufferInfo2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **CopyBufferInfo2) **C.struct_VkCopyBufferInfo2 { /* Pointer */
		g2c := (*C.struct_VkCopyBufferInfo2)(*x)
		return &g2c
	}(&pCopyBufferInfo)
	C.vkCmdCopyBuffer2(addrs, *p0, *p1)
}

// DebugReportCallbackEXT is a Handle to a vulkan resource.
// DebugReportCallbackEXT is a child of Instance.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugReportCallbackEXT.html
type DebugReportCallbackEXT C.VkDebugReportCallbackEXT

// NullDebugReportCallbackEXT is a typed Null value for the DebugReportCallbackEXT type.
var NullDebugReportCallbackEXT DebugReportCallbackEXT

// DebugReportObjectTypeEXT enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugReportObjectTypeEXT.html
type DebugReportObjectTypeEXT uint32

const (
	VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT                    DebugReportObjectTypeEXT = 0
	VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT                   DebugReportObjectTypeEXT = 1
	VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT            DebugReportObjectTypeEXT = 2
	VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT                     DebugReportObjectTypeEXT = 3
	VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT                      DebugReportObjectTypeEXT = 4
	VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT                  DebugReportObjectTypeEXT = 5
	VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT             DebugReportObjectTypeEXT = 6
	VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT                      DebugReportObjectTypeEXT = 7
	VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT              DebugReportObjectTypeEXT = 8
	VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT                     DebugReportObjectTypeEXT = 9
	VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT                      DebugReportObjectTypeEXT = 10
	VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT                      DebugReportObjectTypeEXT = 11
	VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT                 DebugReportObjectTypeEXT = 12
	VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT                DebugReportObjectTypeEXT = 13
	VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT                 DebugReportObjectTypeEXT = 14
	VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT              DebugReportObjectTypeEXT = 15
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT             DebugReportObjectTypeEXT = 16
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT            DebugReportObjectTypeEXT = 17
	VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT                DebugReportObjectTypeEXT = 18
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT                   DebugReportObjectTypeEXT = 19
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT      DebugReportObjectTypeEXT = 20
	VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT                    DebugReportObjectTypeEXT = 21
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT            DebugReportObjectTypeEXT = 22
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT             DebugReportObjectTypeEXT = 23
	VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT                DebugReportObjectTypeEXT = 24
	VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT               DebugReportObjectTypeEXT = 25
	VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT                DebugReportObjectTypeEXT = 26
	VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT              DebugReportObjectTypeEXT = 27
	VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT  DebugReportObjectTypeEXT = 28
	VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT               DebugReportObjectTypeEXT = VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT
	VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT                DebugReportObjectTypeEXT = 29
	VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT           DebugReportObjectTypeEXT = 30
	VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT       DebugReportObjectTypeEXT = 33
	VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT           DebugReportObjectTypeEXT = VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT
	VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT   DebugReportObjectTypeEXT = 1000156000
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT DebugReportObjectTypeEXT = 1000085000
)

var (
	reverseDebugReportObjectTypeEXT map[DebugReportObjectTypeEXT]string = map[DebugReportObjectTypeEXT]string{
		VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT:                    "VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT:                   "VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT:            "VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT:                     "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT:                      "VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT:                  "VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT:             "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT:                      "VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT:              "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT:                     "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT:                      "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT:                      "VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT:                 "VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT:                "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT:                 "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT:              "VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT:             "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT:            "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT:                "VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT:                   "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT:      "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT:                    "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT:            "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT:             "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT:                "VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT:               "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT:                "VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT:              "VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT:  "VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT:                "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT:           "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT:       "VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT:   "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT",
		VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT: "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT",
	}
)

func (x DebugReportObjectTypeEXT) String() string {
	if s, ok := reverseDebugReportObjectTypeEXT[x]; ok {
		return s
	}
	return fmt.Sprintf("DebugReportObjectTypeEXT=%d", x)
}

// DebugReportFlagBitsEXT enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugReportFlagBitsEXT.html
type DebugReportFlagBitsEXT uint32

const (
	VK_DEBUG_REPORT_INFORMATION_BIT_EXT         DebugReportFlagBitsEXT = (1 << 0)
	VK_DEBUG_REPORT_WARNING_BIT_EXT             DebugReportFlagBitsEXT = (1 << 1)
	VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT DebugReportFlagBitsEXT = (1 << 2)
	VK_DEBUG_REPORT_ERROR_BIT_EXT               DebugReportFlagBitsEXT = (1 << 3)
	VK_DEBUG_REPORT_DEBUG_BIT_EXT               DebugReportFlagBitsEXT = (1 << 4)
)

var (
	reverseDebugReportFlagBitsEXT map[DebugReportFlagBitsEXT]string = map[DebugReportFlagBitsEXT]string{
		VK_DEBUG_REPORT_INFORMATION_BIT_EXT:         "VK_DEBUG_REPORT_INFORMATION_BIT_EXT",
		VK_DEBUG_REPORT_WARNING_BIT_EXT:             "VK_DEBUG_REPORT_WARNING_BIT_EXT",
		VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT: "VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT",
		VK_DEBUG_REPORT_ERROR_BIT_EXT:               "VK_DEBUG_REPORT_ERROR_BIT_EXT",
		VK_DEBUG_REPORT_DEBUG_BIT_EXT:               "VK_DEBUG_REPORT_DEBUG_BIT_EXT",
	}
)

func (x DebugReportFlagBitsEXT) String() string {
	if s, ok := reverseDebugReportFlagBitsEXT[x]; ok {
		return s
	}
	return fmt.Sprintf("DebugReportFlagBitsEXT=%d", x)
}

// DebugReportFlagsEXT bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugReportFlagsEXT.html
type DebugReportFlagsEXT Flags

// PFN_vkDebugReportCallbackEXT function pointer
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkDebugReportCallbackEXT.html
type PFN_vkDebugReportCallbackEXT C.PFN_vkDebugReportCallbackEXT

// DebugReportCallbackCreateInfoEXT provides a go interface for VkDebugReportCallbackCreateInfoEXT.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDebugReportCallbackCreateInfoEXT.html
type DebugReportCallbackCreateInfoEXT C.struct_VkDebugReportCallbackCreateInfoEXT

// SizeofDebugReportCallbackCreateInfoEXT is the memory size of a DebugReportCallbackCreateInfoEXT
var SizeofDebugReportCallbackCreateInfoEXT int = int(unsafe.Sizeof(DebugReportCallbackCreateInfoEXT{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DebugReportCallbackCreateInfoEXT) ArpPtr(arp *AutoReleasePool) *DebugReportCallbackCreateInfoEXT {
	ptr := newCBlock(cULong(SizeofDebugReportCallbackCreateInfoEXT))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DebugReportCallbackCreateInfoEXT)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DebugReportCallbackCreateInfoEXT) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DebugReportCallbackCreateInfoEXT) AsCPtr() *DebugReportCallbackCreateInfoEXT {
	clone := (*DebugReportCallbackCreateInfoEXT)(newCBlock(cULong(SizeofDebugReportCallbackCreateInfoEXT)))
	*clone = x
	return clone
}

// DebugReportCallbackCreateInfoEXTCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DebugReportCallbackCreateInfoEXTCSlice(arp *AutoReleasePool, x ...DebugReportCallbackCreateInfoEXT) []DebugReportCallbackCreateInfoEXT {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDebugReportCallbackCreateInfoEXT * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DebugReportCallbackCreateInfoEXT)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DebugReportCallbackCreateInfoEXTFreeCSlice releases the memory allocated by DebugReportCallbackCreateInfoEXTMakeCSlice.
// It does not free pointers stored inside the slice.
func DebugReportCallbackCreateInfoEXTFreeCSlice(x []DebugReportCallbackCreateInfoEXT) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DebugReportCallbackCreateInfoEXTMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DebugReportCallbackCreateInfoEXTFreeCSlice must be called on the returned slice.
func DebugReportCallbackCreateInfoEXTMakeCSlice(x ...DebugReportCallbackCreateInfoEXT) []DebugReportCallbackCreateInfoEXT {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDebugReportCallbackCreateInfoEXT * len(x)
	dst := unsafe.Slice((*DebugReportCallbackCreateInfoEXT)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDebugReportCallbackCreateInfoEXT
func (x DebugReportCallbackCreateInfoEXT) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DebugReportCallbackCreateInfoEXT with the value of
// SType to the value provided in the specification.
func (x DebugReportCallbackCreateInfoEXT) WithDefaultSType() DebugReportCallbackCreateInfoEXT {
	return x.WithSType(VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DebugReportCallbackCreateInfoEXT) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT)
}

// WithSType clones a new DebugReportCallbackCreateInfoEXT with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DebugReportCallbackCreateInfoEXT) WithSType(y StructureType) DebugReportCallbackCreateInfoEXT {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DebugReportCallbackCreateInfoEXT) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDebugReportCallbackCreateInfoEXT
func (x DebugReportCallbackCreateInfoEXT) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DebugReportCallbackCreateInfoEXT with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DebugReportCallbackCreateInfoEXT) WithPNext(y unsafe.Pointer) DebugReportCallbackCreateInfoEXT {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DebugReportCallbackCreateInfoEXT) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkDebugReportCallbackCreateInfoEXT
func (x DebugReportCallbackCreateInfoEXT) Flags() DebugReportFlagsEXT {
	ptr := /* typedef */ (*DebugReportFlagsEXT)(&x.flags)
	return *ptr
}

// WithFlags clones a new DebugReportCallbackCreateInfoEXT with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DebugReportCallbackCreateInfoEXT) WithFlags(y DebugReportFlagsEXT) DebugReportCallbackCreateInfoEXT {
	x.flags = *( /* typedef */ (*C.VkDebugReportFlagsEXT)(&y))
	return x
}
func (x *DebugReportCallbackCreateInfoEXT) SetFlags(y DebugReportFlagsEXT) {
	x.flags = *( /* typedef */ (*C.VkDebugReportFlagsEXT)(&y))
}

// PfnCallback returns the value of pfnCallback from VkDebugReportCallbackCreateInfoEXT
func (x DebugReportCallbackCreateInfoEXT) PfnCallback() PFN_vkDebugReportCallbackEXT {
	ptr := /* typedef */ (*PFN_vkDebugReportCallbackEXT)(&x.pfnCallback)
	return *ptr
}

// WithPfnCallback clones a new DebugReportCallbackCreateInfoEXT with the value of
// PfnCallback updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DebugReportCallbackCreateInfoEXT) WithPfnCallback(y PFN_vkDebugReportCallbackEXT) DebugReportCallbackCreateInfoEXT {
	x.pfnCallback = *( /* typedef */ (*C.PFN_vkDebugReportCallbackEXT)(&y))
	return x
}
func (x *DebugReportCallbackCreateInfoEXT) SetPfnCallback(y PFN_vkDebugReportCallbackEXT) {
	x.pfnCallback = *( /* typedef */ (*C.PFN_vkDebugReportCallbackEXT)(&y))
}

// PUserData returns the value of pUserData from VkDebugReportCallbackCreateInfoEXT
func (x DebugReportCallbackCreateInfoEXT) PUserData() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pUserData)
	return *ptr
}

// WithPUserData clones a new DebugReportCallbackCreateInfoEXT with the value of
// PUserData updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DebugReportCallbackCreateInfoEXT) WithPUserData(y unsafe.Pointer) DebugReportCallbackCreateInfoEXT {
	x.pUserData = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DebugReportCallbackCreateInfoEXT) SetPUserData(y unsafe.Pointer) {
	x.pUserData = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// CreateDebugReportCallbackEXT command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDebugReportCallbackEXT.html
func (x InstanceFacade) CreateDebugReportCallbackEXT(pCreateInfo *DebugReportCallbackCreateInfoEXT, pAllocator *AllocationCallbacks, pCallback *DebugReportCallbackEXT) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkInstance)(&x.H)
	p1 := func(x **DebugReportCallbackCreateInfoEXT) **C.struct_VkDebugReportCallbackCreateInfoEXT { /* Pointer */
		g2c := (*C.struct_VkDebugReportCallbackCreateInfoEXT)(*x)
		return &g2c
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p3 := func(x **DebugReportCallbackEXT) **C.VkDebugReportCallbackEXT { /* Pointer */
		g2c := (*C.VkDebugReportCallbackEXT)(*x)
		return &g2c
	}(&pCallback)
	ret := C.vkCreateDebugReportCallbackEXT(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DebugReportMessageEXT command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDebugReportMessageEXT.html
func (x InstanceFacade) DebugReportMessageEXT(flags DebugReportFlagsEXT, objectType DebugReportObjectTypeEXT, object uint64, location uint64, messageCode int32, pLayerPrefix *byte, pMessage *byte) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkInstance)(&x.H)
	p1 := /* typedef */ (*C.VkDebugReportFlagsEXT)(&flags)
	p2 := /* typedef */ (*C.VkDebugReportObjectTypeEXT)(&objectType)
	p3 := func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&object)
	p4 := func(x *uint64) *C.size_t { /* Scalar */ g2c := C.size_t(*x); return &g2c }(&location)
	p5 := func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&messageCode)
	p6 := func(x **byte) **C.char { /* Pointer */ return (**C.char)(unsafe.Pointer(x)) }(&pLayerPrefix)
	p7 := func(x **byte) **C.char { /* Pointer */ return (**C.char)(unsafe.Pointer(x)) }(&pMessage)
	C.vkDebugReportMessageEXT(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7)
}

// DestroyDebugReportCallbackEXT command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDebugReportCallbackEXT.html
func (x InstanceFacade) DestroyDebugReportCallbackEXT(callback DebugReportCallbackEXT, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkInstance)(&x.H)
	p1 := /* handle */ (*C.VkDebugReportCallbackEXT)(&callback)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	C.vkDestroyDebugReportCallbackEXT(addrs, *p0, *p1, *p2)
}

// FormatProperties2KHR is an alias to FormatProperties2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatProperties2KHR.html
//
// Deprecated: Most Aliases in the Vulkan spec are for compatibility purposes as extensions get
// promoted to features. If possible, update code to use the promoted name: FormatProperties2.
type FormatProperties2KHR = FormatProperties2

// PhysicalDeviceSparseImageFormatInfo2KHR is an alias to PhysicalDeviceSparseImageFormatInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSparseImageFormatInfo2KHR.html
//
// Deprecated: Most Aliases in the Vulkan spec are for compatibility purposes as extensions get
// promoted to features. If possible, update code to use the promoted name: PhysicalDeviceSparseImageFormatInfo2.
type PhysicalDeviceSparseImageFormatInfo2KHR = PhysicalDeviceSparseImageFormatInfo2

// SparseImageFormatProperties2KHR is an alias to SparseImageFormatProperties2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageFormatProperties2KHR.html
//
// Deprecated: Most Aliases in the Vulkan spec are for compatibility purposes as extensions get
// promoted to features. If possible, update code to use the promoted name: SparseImageFormatProperties2.
type SparseImageFormatProperties2KHR = SparseImageFormatProperties2

// PhysicalDeviceMemoryProperties2KHR is an alias to PhysicalDeviceMemoryProperties2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryProperties2KHR.html
//
// Deprecated: Most Aliases in the Vulkan spec are for compatibility purposes as extensions get
// promoted to features. If possible, update code to use the promoted name: PhysicalDeviceMemoryProperties2.
type PhysicalDeviceMemoryProperties2KHR = PhysicalDeviceMemoryProperties2

// QueueFamilyProperties2KHR is an alias to QueueFamilyProperties2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFamilyProperties2KHR.html
//
// Deprecated: Most Aliases in the Vulkan spec are for compatibility purposes as extensions get
// promoted to features. If possible, update code to use the promoted name: QueueFamilyProperties2.
type QueueFamilyProperties2KHR = QueueFamilyProperties2

// PhysicalDeviceImageFormatInfo2KHR is an alias to PhysicalDeviceImageFormatInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageFormatInfo2KHR.html
//
// Deprecated: Most Aliases in the Vulkan spec are for compatibility purposes as extensions get
// promoted to features. If possible, update code to use the promoted name: PhysicalDeviceImageFormatInfo2.
type PhysicalDeviceImageFormatInfo2KHR = PhysicalDeviceImageFormatInfo2

// ImageFormatProperties2KHR is an alias to ImageFormatProperties2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageFormatProperties2KHR.html
//
// Deprecated: Most Aliases in the Vulkan spec are for compatibility purposes as extensions get
// promoted to features. If possible, update code to use the promoted name: ImageFormatProperties2.
type ImageFormatProperties2KHR = ImageFormatProperties2

// PhysicalDeviceFeatures2KHR is an alias to PhysicalDeviceFeatures2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures2KHR.html
//
// Deprecated: Most Aliases in the Vulkan spec are for compatibility purposes as extensions get
// promoted to features. If possible, update code to use the promoted name: PhysicalDeviceFeatures2.
type PhysicalDeviceFeatures2KHR = PhysicalDeviceFeatures2

// PhysicalDeviceProperties2KHR is an alias to PhysicalDeviceProperties2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProperties2KHR.html
//
// Deprecated: Most Aliases in the Vulkan spec are for compatibility purposes as extensions get
// promoted to features. If possible, update code to use the promoted name: PhysicalDeviceProperties2.
type PhysicalDeviceProperties2KHR = PhysicalDeviceProperties2

// SurfaceKHR is a Handle to a vulkan resource.
// SurfaceKHR is a child of Instance.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html
type SurfaceKHR C.VkSurfaceKHR

// NullSurfaceKHR is a typed Null value for the SurfaceKHR type.
var NullSurfaceKHR SurfaceKHR

// SurfaceTransformFlagBitsKHR enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceTransformFlagBitsKHR.html
type SurfaceTransformFlagBitsKHR uint32

const (
	VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR                     SurfaceTransformFlagBitsKHR = (1 << 0)
	VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR                    SurfaceTransformFlagBitsKHR = (1 << 1)
	VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR                   SurfaceTransformFlagBitsKHR = (1 << 2)
	VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR                   SurfaceTransformFlagBitsKHR = (1 << 3)
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR            SurfaceTransformFlagBitsKHR = (1 << 4)
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR  SurfaceTransformFlagBitsKHR = (1 << 5)
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR SurfaceTransformFlagBitsKHR = (1 << 6)
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR SurfaceTransformFlagBitsKHR = (1 << 7)
	VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR                      SurfaceTransformFlagBitsKHR = (1 << 8)
)

var (
	reverseSurfaceTransformFlagBitsKHR map[SurfaceTransformFlagBitsKHR]string = map[SurfaceTransformFlagBitsKHR]string{
		VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR:                     "VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR",
		VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR:                    "VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR",
		VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR:                   "VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR",
		VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR:                   "VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR",
		VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR:            "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR",
		VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR:  "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR",
		VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR: "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR",
		VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR: "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR",
		VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR:                      "VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR",
	}
)

func (x SurfaceTransformFlagBitsKHR) String() string {
	if s, ok := reverseSurfaceTransformFlagBitsKHR[x]; ok {
		return s
	}
	return fmt.Sprintf("SurfaceTransformFlagBitsKHR=%d", x)
}

// CompositeAlphaFlagBitsKHR enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCompositeAlphaFlagBitsKHR.html
type CompositeAlphaFlagBitsKHR uint32

const (
	VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR          CompositeAlphaFlagBitsKHR = (1 << 0)
	VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR  CompositeAlphaFlagBitsKHR = (1 << 1)
	VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR CompositeAlphaFlagBitsKHR = (1 << 2)
	VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR         CompositeAlphaFlagBitsKHR = (1 << 3)
)

var (
	reverseCompositeAlphaFlagBitsKHR map[CompositeAlphaFlagBitsKHR]string = map[CompositeAlphaFlagBitsKHR]string{
		VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR:          "VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR",
		VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR:  "VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR",
		VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR: "VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR",
		VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR:         "VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR",
	}
)

func (x CompositeAlphaFlagBitsKHR) String() string {
	if s, ok := reverseCompositeAlphaFlagBitsKHR[x]; ok {
		return s
	}
	return fmt.Sprintf("CompositeAlphaFlagBitsKHR=%d", x)
}

// ColorSpaceKHR enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkColorSpaceKHR.html
type ColorSpaceKHR uint32

const (
	VK_COLOR_SPACE_SRGB_NONLINEAR_KHR ColorSpaceKHR = 0
	VK_COLORSPACE_SRGB_NONLINEAR_KHR  ColorSpaceKHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR
)

var (
	reverseColorSpaceKHR map[ColorSpaceKHR]string = map[ColorSpaceKHR]string{
		VK_COLOR_SPACE_SRGB_NONLINEAR_KHR: "VK_COLOR_SPACE_SRGB_NONLINEAR_KHR",
	}
)

func (x ColorSpaceKHR) String() string {
	if s, ok := reverseColorSpaceKHR[x]; ok {
		return s
	}
	return fmt.Sprintf("ColorSpaceKHR=%d", x)
}

// PresentModeKHR enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentModeKHR.html
type PresentModeKHR uint32

const (
	VK_PRESENT_MODE_IMMEDIATE_KHR    PresentModeKHR = 0
	VK_PRESENT_MODE_MAILBOX_KHR      PresentModeKHR = 1
	VK_PRESENT_MODE_FIFO_KHR         PresentModeKHR = 2
	VK_PRESENT_MODE_FIFO_RELAXED_KHR PresentModeKHR = 3
)

var (
	reversePresentModeKHR map[PresentModeKHR]string = map[PresentModeKHR]string{
		VK_PRESENT_MODE_IMMEDIATE_KHR:    "VK_PRESENT_MODE_IMMEDIATE_KHR",
		VK_PRESENT_MODE_MAILBOX_KHR:      "VK_PRESENT_MODE_MAILBOX_KHR",
		VK_PRESENT_MODE_FIFO_KHR:         "VK_PRESENT_MODE_FIFO_KHR",
		VK_PRESENT_MODE_FIFO_RELAXED_KHR: "VK_PRESENT_MODE_FIFO_RELAXED_KHR",
	}
)

func (x PresentModeKHR) String() string {
	if s, ok := reversePresentModeKHR[x]; ok {
		return s
	}
	return fmt.Sprintf("PresentModeKHR=%d", x)
}

// CompositeAlphaFlagsKHR bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCompositeAlphaFlagsKHR.html
type CompositeAlphaFlagsKHR Flags

// SurfaceFormatKHR provides a go interface for VkSurfaceFormatKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceFormatKHR.html
type SurfaceFormatKHR C.struct_VkSurfaceFormatKHR

// SizeofSurfaceFormatKHR is the memory size of a SurfaceFormatKHR
var SizeofSurfaceFormatKHR int = int(unsafe.Sizeof(SurfaceFormatKHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SurfaceFormatKHR) ArpPtr(arp *AutoReleasePool) *SurfaceFormatKHR {
	ptr := newCBlock(cULong(SizeofSurfaceFormatKHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SurfaceFormatKHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SurfaceFormatKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SurfaceFormatKHR) AsCPtr() *SurfaceFormatKHR {
	clone := (*SurfaceFormatKHR)(newCBlock(cULong(SizeofSurfaceFormatKHR)))
	*clone = x
	return clone
}

// SurfaceFormatKHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SurfaceFormatKHRCSlice(arp *AutoReleasePool, x ...SurfaceFormatKHR) []SurfaceFormatKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSurfaceFormatKHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SurfaceFormatKHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SurfaceFormatKHRFreeCSlice releases the memory allocated by SurfaceFormatKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func SurfaceFormatKHRFreeCSlice(x []SurfaceFormatKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SurfaceFormatKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SurfaceFormatKHRFreeCSlice must be called on the returned slice.
func SurfaceFormatKHRMakeCSlice(x ...SurfaceFormatKHR) []SurfaceFormatKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSurfaceFormatKHR * len(x)
	dst := unsafe.Slice((*SurfaceFormatKHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Format returns the value of format from VkSurfaceFormatKHR
func (x SurfaceFormatKHR) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format)
	return *ptr
}

// ColorSpace returns the value of colorSpace from VkSurfaceFormatKHR
func (x SurfaceFormatKHR) ColorSpace() ColorSpaceKHR {
	ptr := /* typedef */ (*ColorSpaceKHR)(&x.colorSpace)
	return *ptr
}

// SurfaceTransformFlagsKHR bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceTransformFlagsKHR.html
type SurfaceTransformFlagsKHR Flags

// SurfaceCapabilitiesKHR provides a go interface for VkSurfaceCapabilitiesKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceCapabilitiesKHR.html
type SurfaceCapabilitiesKHR C.struct_VkSurfaceCapabilitiesKHR

// SizeofSurfaceCapabilitiesKHR is the memory size of a SurfaceCapabilitiesKHR
var SizeofSurfaceCapabilitiesKHR int = int(unsafe.Sizeof(SurfaceCapabilitiesKHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SurfaceCapabilitiesKHR) ArpPtr(arp *AutoReleasePool) *SurfaceCapabilitiesKHR {
	ptr := newCBlock(cULong(SizeofSurfaceCapabilitiesKHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SurfaceCapabilitiesKHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SurfaceCapabilitiesKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SurfaceCapabilitiesKHR) AsCPtr() *SurfaceCapabilitiesKHR {
	clone := (*SurfaceCapabilitiesKHR)(newCBlock(cULong(SizeofSurfaceCapabilitiesKHR)))
	*clone = x
	return clone
}

// SurfaceCapabilitiesKHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SurfaceCapabilitiesKHRCSlice(arp *AutoReleasePool, x ...SurfaceCapabilitiesKHR) []SurfaceCapabilitiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSurfaceCapabilitiesKHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SurfaceCapabilitiesKHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SurfaceCapabilitiesKHRFreeCSlice releases the memory allocated by SurfaceCapabilitiesKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func SurfaceCapabilitiesKHRFreeCSlice(x []SurfaceCapabilitiesKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SurfaceCapabilitiesKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SurfaceCapabilitiesKHRFreeCSlice must be called on the returned slice.
func SurfaceCapabilitiesKHRMakeCSlice(x ...SurfaceCapabilitiesKHR) []SurfaceCapabilitiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSurfaceCapabilitiesKHR * len(x)
	dst := unsafe.Slice((*SurfaceCapabilitiesKHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// MinImageCount returns the value of minImageCount from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) MinImageCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.minImageCount)
	return *ptr
}

// MaxImageCount returns the value of maxImageCount from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) MaxImageCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxImageCount)
	return *ptr
}

// CurrentExtent returns the value of currentExtent from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) CurrentExtent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.currentExtent)
	return *ptr
}

// MinImageExtent returns the value of minImageExtent from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) MinImageExtent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.minImageExtent)
	return *ptr
}

// MaxImageExtent returns the value of maxImageExtent from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) MaxImageExtent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.maxImageExtent)
	return *ptr
}

// MaxImageArrayLayers returns the value of maxImageArrayLayers from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) MaxImageArrayLayers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxImageArrayLayers)
	return *ptr
}

// SupportedTransforms returns the value of supportedTransforms from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) SupportedTransforms() SurfaceTransformFlagsKHR {
	ptr := /* typedef */ (*SurfaceTransformFlagsKHR)(&x.supportedTransforms)
	return *ptr
}

// CurrentTransform returns the value of currentTransform from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) CurrentTransform() SurfaceTransformFlagBitsKHR {
	ptr := /* typedef */ (*SurfaceTransformFlagBitsKHR)(&x.currentTransform)
	return *ptr
}

// SupportedCompositeAlpha returns the value of supportedCompositeAlpha from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) SupportedCompositeAlpha() CompositeAlphaFlagsKHR {
	ptr := /* typedef */ (*CompositeAlphaFlagsKHR)(&x.supportedCompositeAlpha)
	return *ptr
}

// SupportedUsageFlags returns the value of supportedUsageFlags from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) SupportedUsageFlags() ImageUsageFlags {
	ptr := /* typedef */ (*ImageUsageFlags)(&x.supportedUsageFlags)
	return *ptr
}

// GetPhysicalDeviceSurfacePresentModesKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfacePresentModesKHR.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceSurfacePresentModesKHR(surface SurfaceKHR, pPresentModeCount *uint32, pPresentModes []PresentModeKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* handle */ (*C.VkSurfaceKHR)(&surface)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPresentModeCount)
	p3 := func(x *[]PresentModeKHR) **C.VkPresentModeKHR { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkPresentModeKHR)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkPresentModeKHR)(unsafe.Pointer((&ptr)))
	}(&pPresentModes)
	ret := C.vkGetPhysicalDeviceSurfacePresentModesKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceSurfaceFormatsKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceFormatsKHR.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceSurfaceFormatsKHR(surface SurfaceKHR, pSurfaceFormatCount *uint32, pSurfaceFormats []SurfaceFormatKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* handle */ (*C.VkSurfaceKHR)(&surface)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pSurfaceFormatCount)
	p3 := func(x *[]SurfaceFormatKHR) **C.struct_VkSurfaceFormatKHR { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSurfaceFormatKHR)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSurfaceFormatKHR)(unsafe.Pointer((&ptr)))
	}(&pSurfaceFormats)
	ret := C.vkGetPhysicalDeviceSurfaceFormatsKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceSurfaceCapabilitiesKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceCapabilitiesKHR.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceSurfaceCapabilitiesKHR(surface SurfaceKHR, pSurfaceCapabilities *SurfaceCapabilitiesKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* handle */ (*C.VkSurfaceKHR)(&surface)
	p2 := func(x **SurfaceCapabilitiesKHR) **C.struct_VkSurfaceCapabilitiesKHR { /* Pointer */
		g2c := (*C.struct_VkSurfaceCapabilitiesKHR)(*x)
		return &g2c
	}(&pSurfaceCapabilities)
	ret := C.vkGetPhysicalDeviceSurfaceCapabilitiesKHR(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceSurfaceSupportKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceSupportKHR.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceSurfaceSupportKHR(queueFamilyIndex uint32, surface SurfaceKHR, pSupported *Bool32) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&queueFamilyIndex)
	p2 := /* handle */ (*C.VkSurfaceKHR)(&surface)
	p3 := func(x **Bool32) **C.VkBool32 { /* Pointer */ g2c := (*C.VkBool32)(*x); return &g2c }(&pSupported)
	ret := C.vkGetPhysicalDeviceSurfaceSupportKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroySurfaceKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySurfaceKHR.html
func (x InstanceFacade) DestroySurfaceKHR(surface SurfaceKHR, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkInstance)(&x.H)
	p1 := /* handle */ (*C.VkSurfaceKHR)(&surface)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	C.vkDestroySurfaceKHR(addrs, *p0, *p1, *p2)
}

// PhysicalDeviceSurfaceInfo2KHR provides a go interface for VkPhysicalDeviceSurfaceInfo2KHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSurfaceInfo2KHR.html
type PhysicalDeviceSurfaceInfo2KHR C.struct_VkPhysicalDeviceSurfaceInfo2KHR

// SizeofPhysicalDeviceSurfaceInfo2KHR is the memory size of a PhysicalDeviceSurfaceInfo2KHR
var SizeofPhysicalDeviceSurfaceInfo2KHR int = int(unsafe.Sizeof(PhysicalDeviceSurfaceInfo2KHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDeviceSurfaceInfo2KHR) ArpPtr(arp *AutoReleasePool) *PhysicalDeviceSurfaceInfo2KHR {
	ptr := newCBlock(cULong(SizeofPhysicalDeviceSurfaceInfo2KHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDeviceSurfaceInfo2KHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceSurfaceInfo2KHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceSurfaceInfo2KHR) AsCPtr() *PhysicalDeviceSurfaceInfo2KHR {
	clone := (*PhysicalDeviceSurfaceInfo2KHR)(newCBlock(cULong(SizeofPhysicalDeviceSurfaceInfo2KHR)))
	*clone = x
	return clone
}

// PhysicalDeviceSurfaceInfo2KHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDeviceSurfaceInfo2KHRCSlice(arp *AutoReleasePool, x ...PhysicalDeviceSurfaceInfo2KHR) []PhysicalDeviceSurfaceInfo2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSurfaceInfo2KHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDeviceSurfaceInfo2KHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDeviceSurfaceInfo2KHRFreeCSlice releases the memory allocated by PhysicalDeviceSurfaceInfo2KHRMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceSurfaceInfo2KHRFreeCSlice(x []PhysicalDeviceSurfaceInfo2KHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceSurfaceInfo2KHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceSurfaceInfo2KHRFreeCSlice must be called on the returned slice.
func PhysicalDeviceSurfaceInfo2KHRMakeCSlice(x ...PhysicalDeviceSurfaceInfo2KHR) []PhysicalDeviceSurfaceInfo2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSurfaceInfo2KHR * len(x)
	dst := unsafe.Slice((*PhysicalDeviceSurfaceInfo2KHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceSurfaceInfo2KHR
func (x PhysicalDeviceSurfaceInfo2KHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDeviceSurfaceInfo2KHR with the value of
// SType to the value provided in the specification.
func (x PhysicalDeviceSurfaceInfo2KHR) WithDefaultSType() PhysicalDeviceSurfaceInfo2KHR {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDeviceSurfaceInfo2KHR) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR)
}

// WithSType clones a new PhysicalDeviceSurfaceInfo2KHR with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSurfaceInfo2KHR) WithSType(y StructureType) PhysicalDeviceSurfaceInfo2KHR {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDeviceSurfaceInfo2KHR) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDeviceSurfaceInfo2KHR
func (x PhysicalDeviceSurfaceInfo2KHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDeviceSurfaceInfo2KHR with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSurfaceInfo2KHR) WithPNext(y unsafe.Pointer) PhysicalDeviceSurfaceInfo2KHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDeviceSurfaceInfo2KHR) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Surface returns the value of surface from VkPhysicalDeviceSurfaceInfo2KHR
func (x PhysicalDeviceSurfaceInfo2KHR) Surface() SurfaceKHR {
	ptr := /* handle */ (*SurfaceKHR)(&x.surface)
	return *ptr
}

// WithSurface clones a new PhysicalDeviceSurfaceInfo2KHR with the value of
// Surface updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSurfaceInfo2KHR) WithSurface(y SurfaceKHR) PhysicalDeviceSurfaceInfo2KHR {
	x.surface = *( /* handle */ (*C.VkSurfaceKHR)(&y))
	return x
}
func (x *PhysicalDeviceSurfaceInfo2KHR) SetSurface(y SurfaceKHR) {
	x.surface = *( /* handle */ (*C.VkSurfaceKHR)(&y))
}

// SurfaceCapabilities2KHR provides a go interface for VkSurfaceCapabilities2KHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceCapabilities2KHR.html
type SurfaceCapabilities2KHR C.struct_VkSurfaceCapabilities2KHR

// SizeofSurfaceCapabilities2KHR is the memory size of a SurfaceCapabilities2KHR
var SizeofSurfaceCapabilities2KHR int = int(unsafe.Sizeof(SurfaceCapabilities2KHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SurfaceCapabilities2KHR) ArpPtr(arp *AutoReleasePool) *SurfaceCapabilities2KHR {
	ptr := newCBlock(cULong(SizeofSurfaceCapabilities2KHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SurfaceCapabilities2KHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SurfaceCapabilities2KHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SurfaceCapabilities2KHR) AsCPtr() *SurfaceCapabilities2KHR {
	clone := (*SurfaceCapabilities2KHR)(newCBlock(cULong(SizeofSurfaceCapabilities2KHR)))
	*clone = x
	return clone
}

// SurfaceCapabilities2KHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SurfaceCapabilities2KHRCSlice(arp *AutoReleasePool, x ...SurfaceCapabilities2KHR) []SurfaceCapabilities2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSurfaceCapabilities2KHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SurfaceCapabilities2KHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SurfaceCapabilities2KHRFreeCSlice releases the memory allocated by SurfaceCapabilities2KHRMakeCSlice.
// It does not free pointers stored inside the slice.
func SurfaceCapabilities2KHRFreeCSlice(x []SurfaceCapabilities2KHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SurfaceCapabilities2KHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SurfaceCapabilities2KHRFreeCSlice must be called on the returned slice.
func SurfaceCapabilities2KHRMakeCSlice(x ...SurfaceCapabilities2KHR) []SurfaceCapabilities2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSurfaceCapabilities2KHR * len(x)
	dst := unsafe.Slice((*SurfaceCapabilities2KHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSurfaceCapabilities2KHR
func (x SurfaceCapabilities2KHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new SurfaceCapabilities2KHR with the value of
// SType to the value provided in the specification.
func (x SurfaceCapabilities2KHR) WithDefaultSType() SurfaceCapabilities2KHR {
	return x.WithSType(VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *SurfaceCapabilities2KHR) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR)
}

// WithSType clones a new SurfaceCapabilities2KHR with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SurfaceCapabilities2KHR) WithSType(y StructureType) SurfaceCapabilities2KHR {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *SurfaceCapabilities2KHR) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkSurfaceCapabilities2KHR
func (x SurfaceCapabilities2KHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new SurfaceCapabilities2KHR with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SurfaceCapabilities2KHR) WithPNext(y unsafe.Pointer) SurfaceCapabilities2KHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *SurfaceCapabilities2KHR) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SurfaceCapabilities returns the value of surfaceCapabilities from VkSurfaceCapabilities2KHR
func (x SurfaceCapabilities2KHR) SurfaceCapabilities() SurfaceCapabilitiesKHR {
	ptr := /* typedef */ (*SurfaceCapabilitiesKHR)(&x.surfaceCapabilities)
	return *ptr
}

// SurfaceFormat2KHR provides a go interface for VkSurfaceFormat2KHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceFormat2KHR.html
type SurfaceFormat2KHR C.struct_VkSurfaceFormat2KHR

// SizeofSurfaceFormat2KHR is the memory size of a SurfaceFormat2KHR
var SizeofSurfaceFormat2KHR int = int(unsafe.Sizeof(SurfaceFormat2KHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SurfaceFormat2KHR) ArpPtr(arp *AutoReleasePool) *SurfaceFormat2KHR {
	ptr := newCBlock(cULong(SizeofSurfaceFormat2KHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SurfaceFormat2KHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SurfaceFormat2KHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SurfaceFormat2KHR) AsCPtr() *SurfaceFormat2KHR {
	clone := (*SurfaceFormat2KHR)(newCBlock(cULong(SizeofSurfaceFormat2KHR)))
	*clone = x
	return clone
}

// SurfaceFormat2KHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SurfaceFormat2KHRCSlice(arp *AutoReleasePool, x ...SurfaceFormat2KHR) []SurfaceFormat2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSurfaceFormat2KHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SurfaceFormat2KHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SurfaceFormat2KHRFreeCSlice releases the memory allocated by SurfaceFormat2KHRMakeCSlice.
// It does not free pointers stored inside the slice.
func SurfaceFormat2KHRFreeCSlice(x []SurfaceFormat2KHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SurfaceFormat2KHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SurfaceFormat2KHRFreeCSlice must be called on the returned slice.
func SurfaceFormat2KHRMakeCSlice(x ...SurfaceFormat2KHR) []SurfaceFormat2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSurfaceFormat2KHR * len(x)
	dst := unsafe.Slice((*SurfaceFormat2KHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSurfaceFormat2KHR
func (x SurfaceFormat2KHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new SurfaceFormat2KHR with the value of
// SType to the value provided in the specification.
func (x SurfaceFormat2KHR) WithDefaultSType() SurfaceFormat2KHR {
	return x.WithSType(VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *SurfaceFormat2KHR) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR)
}

// WithSType clones a new SurfaceFormat2KHR with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SurfaceFormat2KHR) WithSType(y StructureType) SurfaceFormat2KHR {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *SurfaceFormat2KHR) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkSurfaceFormat2KHR
func (x SurfaceFormat2KHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new SurfaceFormat2KHR with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SurfaceFormat2KHR) WithPNext(y unsafe.Pointer) SurfaceFormat2KHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *SurfaceFormat2KHR) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SurfaceFormat returns the value of surfaceFormat from VkSurfaceFormat2KHR
func (x SurfaceFormat2KHR) SurfaceFormat() SurfaceFormatKHR {
	ptr := /* typedef */ (*SurfaceFormatKHR)(&x.surfaceFormat)
	return *ptr
}

// GetPhysicalDeviceSurfaceCapabilities2KHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceCapabilities2KHR.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceSurfaceCapabilities2KHR(pSurfaceInfo *PhysicalDeviceSurfaceInfo2KHR, pSurfaceCapabilities *SurfaceCapabilities2KHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceSurfaceInfo2KHR) **C.struct_VkPhysicalDeviceSurfaceInfo2KHR { /* Pointer */
		g2c := (*C.struct_VkPhysicalDeviceSurfaceInfo2KHR)(*x)
		return &g2c
	}(&pSurfaceInfo)
	p2 := func(x **SurfaceCapabilities2KHR) **C.struct_VkSurfaceCapabilities2KHR { /* Pointer */
		g2c := (*C.struct_VkSurfaceCapabilities2KHR)(*x)
		return &g2c
	}(&pSurfaceCapabilities)
	ret := C.vkGetPhysicalDeviceSurfaceCapabilities2KHR(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceSurfaceFormats2KHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceFormats2KHR.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceSurfaceFormats2KHR(pSurfaceInfo *PhysicalDeviceSurfaceInfo2KHR, pSurfaceFormatCount *uint32, pSurfaceFormats []SurfaceFormat2KHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceSurfaceInfo2KHR) **C.struct_VkPhysicalDeviceSurfaceInfo2KHR { /* Pointer */
		g2c := (*C.struct_VkPhysicalDeviceSurfaceInfo2KHR)(*x)
		return &g2c
	}(&pSurfaceInfo)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pSurfaceFormatCount)
	p3 := func(x *[]SurfaceFormat2KHR) **C.struct_VkSurfaceFormat2KHR { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSurfaceFormat2KHR)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSurfaceFormat2KHR)(unsafe.Pointer((&ptr)))
	}(&pSurfaceFormats)
	ret := C.vkGetPhysicalDeviceSurfaceFormats2KHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// SurfaceProtectedCapabilitiesKHR provides a go interface for VkSurfaceProtectedCapabilitiesKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceProtectedCapabilitiesKHR.html
type SurfaceProtectedCapabilitiesKHR C.struct_VkSurfaceProtectedCapabilitiesKHR

// SizeofSurfaceProtectedCapabilitiesKHR is the memory size of a SurfaceProtectedCapabilitiesKHR
var SizeofSurfaceProtectedCapabilitiesKHR int = int(unsafe.Sizeof(SurfaceProtectedCapabilitiesKHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SurfaceProtectedCapabilitiesKHR) ArpPtr(arp *AutoReleasePool) *SurfaceProtectedCapabilitiesKHR {
	ptr := newCBlock(cULong(SizeofSurfaceProtectedCapabilitiesKHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SurfaceProtectedCapabilitiesKHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SurfaceProtectedCapabilitiesKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SurfaceProtectedCapabilitiesKHR) AsCPtr() *SurfaceProtectedCapabilitiesKHR {
	clone := (*SurfaceProtectedCapabilitiesKHR)(newCBlock(cULong(SizeofSurfaceProtectedCapabilitiesKHR)))
	*clone = x
	return clone
}

// SurfaceProtectedCapabilitiesKHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SurfaceProtectedCapabilitiesKHRCSlice(arp *AutoReleasePool, x ...SurfaceProtectedCapabilitiesKHR) []SurfaceProtectedCapabilitiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSurfaceProtectedCapabilitiesKHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SurfaceProtectedCapabilitiesKHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SurfaceProtectedCapabilitiesKHRFreeCSlice releases the memory allocated by SurfaceProtectedCapabilitiesKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func SurfaceProtectedCapabilitiesKHRFreeCSlice(x []SurfaceProtectedCapabilitiesKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SurfaceProtectedCapabilitiesKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SurfaceProtectedCapabilitiesKHRFreeCSlice must be called on the returned slice.
func SurfaceProtectedCapabilitiesKHRMakeCSlice(x ...SurfaceProtectedCapabilitiesKHR) []SurfaceProtectedCapabilitiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSurfaceProtectedCapabilitiesKHR * len(x)
	dst := unsafe.Slice((*SurfaceProtectedCapabilitiesKHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSurfaceProtectedCapabilitiesKHR
func (x SurfaceProtectedCapabilitiesKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new SurfaceProtectedCapabilitiesKHR with the value of
// SType to the value provided in the specification.
func (x SurfaceProtectedCapabilitiesKHR) WithDefaultSType() SurfaceProtectedCapabilitiesKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *SurfaceProtectedCapabilitiesKHR) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR)
}

// WithSType clones a new SurfaceProtectedCapabilitiesKHR with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SurfaceProtectedCapabilitiesKHR) WithSType(y StructureType) SurfaceProtectedCapabilitiesKHR {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *SurfaceProtectedCapabilitiesKHR) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkSurfaceProtectedCapabilitiesKHR
func (x SurfaceProtectedCapabilitiesKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new SurfaceProtectedCapabilitiesKHR with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SurfaceProtectedCapabilitiesKHR) WithPNext(y unsafe.Pointer) SurfaceProtectedCapabilitiesKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *SurfaceProtectedCapabilitiesKHR) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SupportsProtected returns the value of supportsProtected from VkSurfaceProtectedCapabilitiesKHR
func (x SurfaceProtectedCapabilitiesKHR) SupportsProtected() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.supportsProtected)
	return *ptr
}

// WithSupportsProtected clones a new SurfaceProtectedCapabilitiesKHR with the value of
// SupportsProtected updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SurfaceProtectedCapabilitiesKHR) WithSupportsProtected(y Bool32) SurfaceProtectedCapabilitiesKHR {
	x.supportsProtected = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *SurfaceProtectedCapabilitiesKHR) SetSupportsProtected(y Bool32) {
	x.supportsProtected = *( /* typedef */ (*C.VkBool32)(&y))
}

// SwapchainKHR is a Handle to a vulkan resource.
// SwapchainKHR is a child of Device.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainKHR.html
type SwapchainKHR C.VkSwapchainKHR

// NullSwapchainKHR is a typed Null value for the SwapchainKHR type.
var NullSwapchainKHR SwapchainKHR

// SwapchainCreateFlagBitsKHR enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateFlagBitsKHR.html
type SwapchainCreateFlagBitsKHR uint32

const (
	VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR SwapchainCreateFlagBitsKHR = (1 << 0)
	VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR                   SwapchainCreateFlagBitsKHR = (1 << 1)
)

var (
	reverseSwapchainCreateFlagBitsKHR map[SwapchainCreateFlagBitsKHR]string = map[SwapchainCreateFlagBitsKHR]string{
		VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR: "VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR",
		VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR:                   "VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR",
	}
)

func (x SwapchainCreateFlagBitsKHR) String() string {
	if s, ok := reverseSwapchainCreateFlagBitsKHR[x]; ok {
		return s
	}
	return fmt.Sprintf("SwapchainCreateFlagBitsKHR=%d", x)
}

// DeviceGroupPresentModeFlagBitsKHR enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupPresentModeFlagBitsKHR.html
type DeviceGroupPresentModeFlagBitsKHR uint32

const (
	VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR              DeviceGroupPresentModeFlagBitsKHR = (1 << 0)
	VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR             DeviceGroupPresentModeFlagBitsKHR = (1 << 1)
	VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR                DeviceGroupPresentModeFlagBitsKHR = (1 << 2)
	VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR DeviceGroupPresentModeFlagBitsKHR = (1 << 3)
)

var (
	reverseDeviceGroupPresentModeFlagBitsKHR map[DeviceGroupPresentModeFlagBitsKHR]string = map[DeviceGroupPresentModeFlagBitsKHR]string{
		VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR:              "VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR",
		VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR:             "VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR",
		VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR:                "VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR",
		VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR: "VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR",
	}
)

func (x DeviceGroupPresentModeFlagBitsKHR) String() string {
	if s, ok := reverseDeviceGroupPresentModeFlagBitsKHR[x]; ok {
		return s
	}
	return fmt.Sprintf("DeviceGroupPresentModeFlagBitsKHR=%d", x)
}

// DeviceGroupPresentModeFlagsKHR bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupPresentModeFlagsKHR.html
type DeviceGroupPresentModeFlagsKHR Flags

// SwapchainCreateFlagsKHR bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateFlagsKHR.html
type SwapchainCreateFlagsKHR Flags

// DeviceGroupSwapchainCreateInfoKHR provides a go interface for VkDeviceGroupSwapchainCreateInfoKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupSwapchainCreateInfoKHR.html
type DeviceGroupSwapchainCreateInfoKHR C.struct_VkDeviceGroupSwapchainCreateInfoKHR

// SizeofDeviceGroupSwapchainCreateInfoKHR is the memory size of a DeviceGroupSwapchainCreateInfoKHR
var SizeofDeviceGroupSwapchainCreateInfoKHR int = int(unsafe.Sizeof(DeviceGroupSwapchainCreateInfoKHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DeviceGroupSwapchainCreateInfoKHR) ArpPtr(arp *AutoReleasePool) *DeviceGroupSwapchainCreateInfoKHR {
	ptr := newCBlock(cULong(SizeofDeviceGroupSwapchainCreateInfoKHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DeviceGroupSwapchainCreateInfoKHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceGroupSwapchainCreateInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceGroupSwapchainCreateInfoKHR) AsCPtr() *DeviceGroupSwapchainCreateInfoKHR {
	clone := (*DeviceGroupSwapchainCreateInfoKHR)(newCBlock(cULong(SizeofDeviceGroupSwapchainCreateInfoKHR)))
	*clone = x
	return clone
}

// DeviceGroupSwapchainCreateInfoKHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DeviceGroupSwapchainCreateInfoKHRCSlice(arp *AutoReleasePool, x ...DeviceGroupSwapchainCreateInfoKHR) []DeviceGroupSwapchainCreateInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupSwapchainCreateInfoKHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DeviceGroupSwapchainCreateInfoKHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DeviceGroupSwapchainCreateInfoKHRFreeCSlice releases the memory allocated by DeviceGroupSwapchainCreateInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceGroupSwapchainCreateInfoKHRFreeCSlice(x []DeviceGroupSwapchainCreateInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceGroupSwapchainCreateInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceGroupSwapchainCreateInfoKHRFreeCSlice must be called on the returned slice.
func DeviceGroupSwapchainCreateInfoKHRMakeCSlice(x ...DeviceGroupSwapchainCreateInfoKHR) []DeviceGroupSwapchainCreateInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupSwapchainCreateInfoKHR * len(x)
	dst := unsafe.Slice((*DeviceGroupSwapchainCreateInfoKHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceGroupSwapchainCreateInfoKHR
func (x DeviceGroupSwapchainCreateInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DeviceGroupSwapchainCreateInfoKHR with the value of
// SType to the value provided in the specification.
func (x DeviceGroupSwapchainCreateInfoKHR) WithDefaultSType() DeviceGroupSwapchainCreateInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DeviceGroupSwapchainCreateInfoKHR) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR)
}

// WithSType clones a new DeviceGroupSwapchainCreateInfoKHR with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupSwapchainCreateInfoKHR) WithSType(y StructureType) DeviceGroupSwapchainCreateInfoKHR {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DeviceGroupSwapchainCreateInfoKHR) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDeviceGroupSwapchainCreateInfoKHR
func (x DeviceGroupSwapchainCreateInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DeviceGroupSwapchainCreateInfoKHR with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupSwapchainCreateInfoKHR) WithPNext(y unsafe.Pointer) DeviceGroupSwapchainCreateInfoKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DeviceGroupSwapchainCreateInfoKHR) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Modes returns the value of modes from VkDeviceGroupSwapchainCreateInfoKHR
func (x DeviceGroupSwapchainCreateInfoKHR) Modes() DeviceGroupPresentModeFlagsKHR {
	ptr := /* typedef */ (*DeviceGroupPresentModeFlagsKHR)(&x.modes)
	return *ptr
}

// WithModes clones a new DeviceGroupSwapchainCreateInfoKHR with the value of
// Modes updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupSwapchainCreateInfoKHR) WithModes(y DeviceGroupPresentModeFlagsKHR) DeviceGroupSwapchainCreateInfoKHR {
	x.modes = *( /* typedef */ (*C.VkDeviceGroupPresentModeFlagsKHR)(&y))
	return x
}
func (x *DeviceGroupSwapchainCreateInfoKHR) SetModes(y DeviceGroupPresentModeFlagsKHR) {
	x.modes = *( /* typedef */ (*C.VkDeviceGroupPresentModeFlagsKHR)(&y))
}

// SwapchainCreateInfoKHR provides a go interface for VkSwapchainCreateInfoKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateInfoKHR.html
type SwapchainCreateInfoKHR C.struct_VkSwapchainCreateInfoKHR

// SizeofSwapchainCreateInfoKHR is the memory size of a SwapchainCreateInfoKHR
var SizeofSwapchainCreateInfoKHR int = int(unsafe.Sizeof(SwapchainCreateInfoKHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x SwapchainCreateInfoKHR) ArpPtr(arp *AutoReleasePool) *SwapchainCreateInfoKHR {
	ptr := newCBlock(cULong(SizeofSwapchainCreateInfoKHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*SwapchainCreateInfoKHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SwapchainCreateInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SwapchainCreateInfoKHR) AsCPtr() *SwapchainCreateInfoKHR {
	clone := (*SwapchainCreateInfoKHR)(newCBlock(cULong(SizeofSwapchainCreateInfoKHR)))
	*clone = x
	return clone
}

// SwapchainCreateInfoKHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func SwapchainCreateInfoKHRCSlice(arp *AutoReleasePool, x ...SwapchainCreateInfoKHR) []SwapchainCreateInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSwapchainCreateInfoKHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*SwapchainCreateInfoKHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// SwapchainCreateInfoKHRFreeCSlice releases the memory allocated by SwapchainCreateInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func SwapchainCreateInfoKHRFreeCSlice(x []SwapchainCreateInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SwapchainCreateInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SwapchainCreateInfoKHRFreeCSlice must be called on the returned slice.
func SwapchainCreateInfoKHRMakeCSlice(x ...SwapchainCreateInfoKHR) []SwapchainCreateInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSwapchainCreateInfoKHR * len(x)
	dst := unsafe.Slice((*SwapchainCreateInfoKHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new SwapchainCreateInfoKHR with the value of
// SType to the value provided in the specification.
func (x SwapchainCreateInfoKHR) WithDefaultSType() SwapchainCreateInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *SwapchainCreateInfoKHR) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR)
}

// WithSType clones a new SwapchainCreateInfoKHR with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithSType(y StructureType) SwapchainCreateInfoKHR {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *SwapchainCreateInfoKHR) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new SwapchainCreateInfoKHR with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithPNext(y unsafe.Pointer) SwapchainCreateInfoKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *SwapchainCreateInfoKHR) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) Flags() SwapchainCreateFlagsKHR {
	ptr := /* typedef */ (*SwapchainCreateFlagsKHR)(&x.flags)
	return *ptr
}

// WithFlags clones a new SwapchainCreateInfoKHR with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithFlags(y SwapchainCreateFlagsKHR) SwapchainCreateInfoKHR {
	x.flags = *( /* typedef */ (*C.VkSwapchainCreateFlagsKHR)(&y))
	return x
}
func (x *SwapchainCreateInfoKHR) SetFlags(y SwapchainCreateFlagsKHR) {
	x.flags = *( /* typedef */ (*C.VkSwapchainCreateFlagsKHR)(&y))
}

// Surface returns the value of surface from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) Surface() SurfaceKHR {
	ptr := /* handle */ (*SurfaceKHR)(&x.surface)
	return *ptr
}

// WithSurface clones a new SwapchainCreateInfoKHR with the value of
// Surface updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithSurface(y SurfaceKHR) SwapchainCreateInfoKHR {
	x.surface = *( /* handle */ (*C.VkSurfaceKHR)(&y))
	return x
}
func (x *SwapchainCreateInfoKHR) SetSurface(y SurfaceKHR) {
	x.surface = *( /* handle */ (*C.VkSurfaceKHR)(&y))
}

// MinImageCount returns the value of minImageCount from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) MinImageCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.minImageCount)
	return *ptr
}

// WithMinImageCount clones a new SwapchainCreateInfoKHR with the value of
// MinImageCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithMinImageCount(y uint32) SwapchainCreateInfoKHR {
	x.minImageCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SwapchainCreateInfoKHR) SetMinImageCount(y uint32) {
	x.minImageCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// ImageFormat returns the value of imageFormat from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) ImageFormat() Format {
	ptr := /* typedef */ (*Format)(&x.imageFormat)
	return *ptr
}

// WithImageFormat clones a new SwapchainCreateInfoKHR with the value of
// ImageFormat updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithImageFormat(y Format) SwapchainCreateInfoKHR {
	x.imageFormat = *( /* typedef */ (*C.VkFormat)(&y))
	return x
}
func (x *SwapchainCreateInfoKHR) SetImageFormat(y Format) {
	x.imageFormat = *( /* typedef */ (*C.VkFormat)(&y))
}

// ImageColorSpace returns the value of imageColorSpace from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) ImageColorSpace() ColorSpaceKHR {
	ptr := /* typedef */ (*ColorSpaceKHR)(&x.imageColorSpace)
	return *ptr
}

// WithImageColorSpace clones a new SwapchainCreateInfoKHR with the value of
// ImageColorSpace updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithImageColorSpace(y ColorSpaceKHR) SwapchainCreateInfoKHR {
	x.imageColorSpace = *( /* typedef */ (*C.VkColorSpaceKHR)(&y))
	return x
}
func (x *SwapchainCreateInfoKHR) SetImageColorSpace(y ColorSpaceKHR) {
	x.imageColorSpace = *( /* typedef */ (*C.VkColorSpaceKHR)(&y))
}

// ImageExtent returns the value of imageExtent from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) ImageExtent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.imageExtent)
	return *ptr
}

// WithImageExtent clones a new SwapchainCreateInfoKHR with the value of
// ImageExtent updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithImageExtent(y Extent2D) SwapchainCreateInfoKHR {
	x.imageExtent = *( /* typedef */ (*C.struct_VkExtent2D)(&y))
	return x
}
func (x *SwapchainCreateInfoKHR) SetImageExtent(y Extent2D) {
	x.imageExtent = *( /* typedef */ (*C.struct_VkExtent2D)(&y))
}

// ImageArrayLayers returns the value of imageArrayLayers from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) ImageArrayLayers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.imageArrayLayers)
	return *ptr
}

// WithImageArrayLayers clones a new SwapchainCreateInfoKHR with the value of
// ImageArrayLayers updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithImageArrayLayers(y uint32) SwapchainCreateInfoKHR {
	x.imageArrayLayers = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SwapchainCreateInfoKHR) SetImageArrayLayers(y uint32) {
	x.imageArrayLayers = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// ImageUsage returns the value of imageUsage from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) ImageUsage() ImageUsageFlags {
	ptr := /* typedef */ (*ImageUsageFlags)(&x.imageUsage)
	return *ptr
}

// WithImageUsage clones a new SwapchainCreateInfoKHR with the value of
// ImageUsage updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithImageUsage(y ImageUsageFlags) SwapchainCreateInfoKHR {
	x.imageUsage = *( /* typedef */ (*C.VkImageUsageFlags)(&y))
	return x
}
func (x *SwapchainCreateInfoKHR) SetImageUsage(y ImageUsageFlags) {
	x.imageUsage = *( /* typedef */ (*C.VkImageUsageFlags)(&y))
}

// ImageSharingMode returns the value of imageSharingMode from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) ImageSharingMode() SharingMode {
	ptr := /* typedef */ (*SharingMode)(&x.imageSharingMode)
	return *ptr
}

// WithImageSharingMode clones a new SwapchainCreateInfoKHR with the value of
// ImageSharingMode updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithImageSharingMode(y SharingMode) SwapchainCreateInfoKHR {
	x.imageSharingMode = *( /* typedef */ (*C.VkSharingMode)(&y))
	return x
}
func (x *SwapchainCreateInfoKHR) SetImageSharingMode(y SharingMode) {
	x.imageSharingMode = *( /* typedef */ (*C.VkSharingMode)(&y))
}

// QueueFamilyIndexCount returns the value of queueFamilyIndexCount from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) QueueFamilyIndexCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.queueFamilyIndexCount)
	return *ptr
}

// WithQueueFamilyIndexCount clones a new SwapchainCreateInfoKHR with the value of
// QueueFamilyIndexCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithQueueFamilyIndexCount(y uint32) SwapchainCreateInfoKHR {
	x.queueFamilyIndexCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *SwapchainCreateInfoKHR) SetQueueFamilyIndexCount(y uint32) {
	x.queueFamilyIndexCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PQueueFamilyIndices returns the value of pQueueFamilyIndices from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) PQueueFamilyIndices() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pQueueFamilyIndices)
	return *ptr
}

// WithPQueueFamilyIndices clones a new SwapchainCreateInfoKHR with the value of
// PQueueFamilyIndices updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines QueueFamilyIndexCount as the length of this field.
// QueueFamilyIndexCount is updated with the length of the new value.
func (x SwapchainCreateInfoKHR) WithPQueueFamilyIndices(y []uint32) SwapchainCreateInfoKHR {
	x.pQueueFamilyIndices = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithQueueFamilyIndexCount(uint32(len(y)))
}
func (x *SwapchainCreateInfoKHR) SetPQueueFamilyIndices(y []uint32) {
	x.pQueueFamilyIndices = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetQueueFamilyIndexCount(uint32(len(y)))
}

// PreTransform returns the value of preTransform from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) PreTransform() SurfaceTransformFlagBitsKHR {
	ptr := /* typedef */ (*SurfaceTransformFlagBitsKHR)(&x.preTransform)
	return *ptr
}

// WithPreTransform clones a new SwapchainCreateInfoKHR with the value of
// PreTransform updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithPreTransform(y SurfaceTransformFlagBitsKHR) SwapchainCreateInfoKHR {
	x.preTransform = *( /* typedef */ (*C.VkSurfaceTransformFlagBitsKHR)(&y))
	return x
}
func (x *SwapchainCreateInfoKHR) SetPreTransform(y SurfaceTransformFlagBitsKHR) {
	x.preTransform = *( /* typedef */ (*C.VkSurfaceTransformFlagBitsKHR)(&y))
}

// CompositeAlpha returns the value of compositeAlpha from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) CompositeAlpha() CompositeAlphaFlagBitsKHR {
	ptr := /* typedef */ (*CompositeAlphaFlagBitsKHR)(&x.compositeAlpha)
	return *ptr
}

// WithCompositeAlpha clones a new SwapchainCreateInfoKHR with the value of
// CompositeAlpha updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithCompositeAlpha(y CompositeAlphaFlagBitsKHR) SwapchainCreateInfoKHR {
	x.compositeAlpha = *( /* typedef */ (*C.VkCompositeAlphaFlagBitsKHR)(&y))
	return x
}
func (x *SwapchainCreateInfoKHR) SetCompositeAlpha(y CompositeAlphaFlagBitsKHR) {
	x.compositeAlpha = *( /* typedef */ (*C.VkCompositeAlphaFlagBitsKHR)(&y))
}

// PresentMode returns the value of presentMode from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) PresentMode() PresentModeKHR {
	ptr := /* typedef */ (*PresentModeKHR)(&x.presentMode)
	return *ptr
}

// WithPresentMode clones a new SwapchainCreateInfoKHR with the value of
// PresentMode updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithPresentMode(y PresentModeKHR) SwapchainCreateInfoKHR {
	x.presentMode = *( /* typedef */ (*C.VkPresentModeKHR)(&y))
	return x
}
func (x *SwapchainCreateInfoKHR) SetPresentMode(y PresentModeKHR) {
	x.presentMode = *( /* typedef */ (*C.VkPresentModeKHR)(&y))
}

// Clipped returns the value of clipped from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) Clipped() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.clipped)
	return *ptr
}

// WithClipped clones a new SwapchainCreateInfoKHR with the value of
// Clipped updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithClipped(y Bool32) SwapchainCreateInfoKHR {
	x.clipped = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *SwapchainCreateInfoKHR) SetClipped(y Bool32) {
	x.clipped = *( /* typedef */ (*C.VkBool32)(&y))
}

// OldSwapchain returns the value of oldSwapchain from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) OldSwapchain() SwapchainKHR {
	ptr := /* handle */ (*SwapchainKHR)(&x.oldSwapchain)
	return *ptr
}

// WithOldSwapchain clones a new SwapchainCreateInfoKHR with the value of
// OldSwapchain updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithOldSwapchain(y SwapchainKHR) SwapchainCreateInfoKHR {
	x.oldSwapchain = *( /* handle */ (*C.VkSwapchainKHR)(&y))
	return x
}
func (x *SwapchainCreateInfoKHR) SetOldSwapchain(y SwapchainKHR) {
	x.oldSwapchain = *( /* handle */ (*C.VkSwapchainKHR)(&y))
}

// PresentInfoKHR provides a go interface for VkPresentInfoKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentInfoKHR.html
type PresentInfoKHR C.struct_VkPresentInfoKHR

// SizeofPresentInfoKHR is the memory size of a PresentInfoKHR
var SizeofPresentInfoKHR int = int(unsafe.Sizeof(PresentInfoKHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PresentInfoKHR) ArpPtr(arp *AutoReleasePool) *PresentInfoKHR {
	ptr := newCBlock(cULong(SizeofPresentInfoKHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PresentInfoKHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PresentInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PresentInfoKHR) AsCPtr() *PresentInfoKHR {
	clone := (*PresentInfoKHR)(newCBlock(cULong(SizeofPresentInfoKHR)))
	*clone = x
	return clone
}

// PresentInfoKHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PresentInfoKHRCSlice(arp *AutoReleasePool, x ...PresentInfoKHR) []PresentInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPresentInfoKHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PresentInfoKHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PresentInfoKHRFreeCSlice releases the memory allocated by PresentInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func PresentInfoKHRFreeCSlice(x []PresentInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PresentInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PresentInfoKHRFreeCSlice must be called on the returned slice.
func PresentInfoKHRMakeCSlice(x ...PresentInfoKHR) []PresentInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPresentInfoKHR * len(x)
	dst := unsafe.Slice((*PresentInfoKHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPresentInfoKHR
func (x PresentInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PresentInfoKHR with the value of
// SType to the value provided in the specification.
func (x PresentInfoKHR) WithDefaultSType() PresentInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_PRESENT_INFO_KHR)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PresentInfoKHR) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PRESENT_INFO_KHR)
}

// WithSType clones a new PresentInfoKHR with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PresentInfoKHR) WithSType(y StructureType) PresentInfoKHR {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PresentInfoKHR) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPresentInfoKHR
func (x PresentInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PresentInfoKHR with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PresentInfoKHR) WithPNext(y unsafe.Pointer) PresentInfoKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PresentInfoKHR) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// WaitSemaphoreCount returns the value of waitSemaphoreCount from VkPresentInfoKHR
func (x PresentInfoKHR) WaitSemaphoreCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.waitSemaphoreCount)
	return *ptr
}

// WithWaitSemaphoreCount clones a new PresentInfoKHR with the value of
// WaitSemaphoreCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PresentInfoKHR) WithWaitSemaphoreCount(y uint32) PresentInfoKHR {
	x.waitSemaphoreCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *PresentInfoKHR) SetWaitSemaphoreCount(y uint32) {
	x.waitSemaphoreCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PWaitSemaphores returns the value of pWaitSemaphores from VkPresentInfoKHR
func (x PresentInfoKHR) PWaitSemaphores() []Semaphore {
	ptr := func(x **C.VkSemaphore) *[]Semaphore { /* Slice */
		slc := unsafe.Slice((*Semaphore)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pWaitSemaphores)
	return *ptr
}

// WithPWaitSemaphores clones a new PresentInfoKHR with the value of
// PWaitSemaphores updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines WaitSemaphoreCount as the length of this field.
// WaitSemaphoreCount is updated with the length of the new value.
func (x PresentInfoKHR) WithPWaitSemaphores(y []Semaphore) PresentInfoKHR {
	x.pWaitSemaphores = *(func(x *[]Semaphore) **C.VkSemaphore { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSemaphore)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSemaphore)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithWaitSemaphoreCount(uint32(len(y)))
}
func (x *PresentInfoKHR) SetPWaitSemaphores(y []Semaphore) {
	x.pWaitSemaphores = *(func(x *[]Semaphore) **C.VkSemaphore { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSemaphore)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSemaphore)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetWaitSemaphoreCount(uint32(len(y)))
}

// SwapchainCount returns the value of swapchainCount from VkPresentInfoKHR
func (x PresentInfoKHR) SwapchainCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.swapchainCount)
	return *ptr
}

// WithSwapchainCount clones a new PresentInfoKHR with the value of
// SwapchainCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PresentInfoKHR) WithSwapchainCount(y uint32) PresentInfoKHR {
	x.swapchainCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *PresentInfoKHR) SetSwapchainCount(y uint32) {
	x.swapchainCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PSwapchains returns the value of pSwapchains from VkPresentInfoKHR
func (x PresentInfoKHR) PSwapchains() []SwapchainKHR {
	ptr := func(x **C.VkSwapchainKHR) *[]SwapchainKHR { /* Slice */
		slc := unsafe.Slice((*SwapchainKHR)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pSwapchains)
	return *ptr
}

// WithPSwapchains clones a new PresentInfoKHR with the value of
// PSwapchains updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SwapchainCount as the length of this field.
// SwapchainCount is updated with the length of the new value.
func (x PresentInfoKHR) WithPSwapchains(y []SwapchainKHR) PresentInfoKHR {
	x.pSwapchains = *(func(x *[]SwapchainKHR) **C.VkSwapchainKHR { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSwapchainKHR)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSwapchainKHR)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithSwapchainCount(uint32(len(y)))
}
func (x *PresentInfoKHR) SetPSwapchains(y []SwapchainKHR) {
	x.pSwapchains = *(func(x *[]SwapchainKHR) **C.VkSwapchainKHR { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSwapchainKHR)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSwapchainKHR)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetSwapchainCount(uint32(len(y)))
}

// PImageIndices returns the value of pImageIndices from VkPresentInfoKHR
func (x PresentInfoKHR) PImageIndices() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pImageIndices)
	return *ptr
}

// WithPImageIndices clones a new PresentInfoKHR with the value of
// PImageIndices updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SwapchainCount as the length of this field.
// SwapchainCount is updated with the length of the new value.
func (x PresentInfoKHR) WithPImageIndices(y []uint32) PresentInfoKHR {
	x.pImageIndices = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithSwapchainCount(uint32(len(y)))
}
func (x *PresentInfoKHR) SetPImageIndices(y []uint32) {
	x.pImageIndices = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetSwapchainCount(uint32(len(y)))
}

// PResults returns the value of pResults from VkPresentInfoKHR
func (x PresentInfoKHR) PResults() []Result {
	ptr := func(x **C.VkResult) *[]Result { /* Slice */
		slc := unsafe.Slice((*Result)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pResults)
	return *ptr
}

// WithPResults clones a new PresentInfoKHR with the value of
// PResults updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SwapchainCount as the length of this field.
// SwapchainCount is updated with the length of the new value.
func (x PresentInfoKHR) WithPResults(y []Result) PresentInfoKHR {
	x.pResults = *(func(x *[]Result) **C.VkResult { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkResult)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkResult)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithSwapchainCount(uint32(len(y)))
}
func (x *PresentInfoKHR) SetPResults(y []Result) {
	x.pResults = *(func(x *[]Result) **C.VkResult { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkResult)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkResult)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetSwapchainCount(uint32(len(y)))
}

// DeviceGroupPresentCapabilitiesKHR provides a go interface for VkDeviceGroupPresentCapabilitiesKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupPresentCapabilitiesKHR.html
type DeviceGroupPresentCapabilitiesKHR C.struct_VkDeviceGroupPresentCapabilitiesKHR

// SizeofDeviceGroupPresentCapabilitiesKHR is the memory size of a DeviceGroupPresentCapabilitiesKHR
var SizeofDeviceGroupPresentCapabilitiesKHR int = int(unsafe.Sizeof(DeviceGroupPresentCapabilitiesKHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DeviceGroupPresentCapabilitiesKHR) ArpPtr(arp *AutoReleasePool) *DeviceGroupPresentCapabilitiesKHR {
	ptr := newCBlock(cULong(SizeofDeviceGroupPresentCapabilitiesKHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DeviceGroupPresentCapabilitiesKHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceGroupPresentCapabilitiesKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceGroupPresentCapabilitiesKHR) AsCPtr() *DeviceGroupPresentCapabilitiesKHR {
	clone := (*DeviceGroupPresentCapabilitiesKHR)(newCBlock(cULong(SizeofDeviceGroupPresentCapabilitiesKHR)))
	*clone = x
	return clone
}

// DeviceGroupPresentCapabilitiesKHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DeviceGroupPresentCapabilitiesKHRCSlice(arp *AutoReleasePool, x ...DeviceGroupPresentCapabilitiesKHR) []DeviceGroupPresentCapabilitiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupPresentCapabilitiesKHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DeviceGroupPresentCapabilitiesKHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DeviceGroupPresentCapabilitiesKHRFreeCSlice releases the memory allocated by DeviceGroupPresentCapabilitiesKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceGroupPresentCapabilitiesKHRFreeCSlice(x []DeviceGroupPresentCapabilitiesKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceGroupPresentCapabilitiesKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceGroupPresentCapabilitiesKHRFreeCSlice must be called on the returned slice.
func DeviceGroupPresentCapabilitiesKHRMakeCSlice(x ...DeviceGroupPresentCapabilitiesKHR) []DeviceGroupPresentCapabilitiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupPresentCapabilitiesKHR * len(x)
	dst := unsafe.Slice((*DeviceGroupPresentCapabilitiesKHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceGroupPresentCapabilitiesKHR
func (x DeviceGroupPresentCapabilitiesKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DeviceGroupPresentCapabilitiesKHR with the value of
// SType to the value provided in the specification.
func (x DeviceGroupPresentCapabilitiesKHR) WithDefaultSType() DeviceGroupPresentCapabilitiesKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DeviceGroupPresentCapabilitiesKHR) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR)
}

// WithSType clones a new DeviceGroupPresentCapabilitiesKHR with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupPresentCapabilitiesKHR) WithSType(y StructureType) DeviceGroupPresentCapabilitiesKHR {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DeviceGroupPresentCapabilitiesKHR) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDeviceGroupPresentCapabilitiesKHR
func (x DeviceGroupPresentCapabilitiesKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DeviceGroupPresentCapabilitiesKHR with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupPresentCapabilitiesKHR) WithPNext(y unsafe.Pointer) DeviceGroupPresentCapabilitiesKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DeviceGroupPresentCapabilitiesKHR) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// PresentMask returns the value of presentMask from VkDeviceGroupPresentCapabilitiesKHR
func (x DeviceGroupPresentCapabilitiesKHR) PresentMask() []uint32 {
	ptr := func(x *[VK_MAX_DEVICE_GROUP_SIZE]C.uint32_t) *[]uint32 { /* Array */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), VK_MAX_DEVICE_GROUP_SIZE)
		return &slc
	}(&x.presentMask)
	return *ptr
}

// Modes returns the value of modes from VkDeviceGroupPresentCapabilitiesKHR
func (x DeviceGroupPresentCapabilitiesKHR) Modes() DeviceGroupPresentModeFlagsKHR {
	ptr := /* typedef */ (*DeviceGroupPresentModeFlagsKHR)(&x.modes)
	return *ptr
}

// DeviceGroupPresentInfoKHR provides a go interface for VkDeviceGroupPresentInfoKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupPresentInfoKHR.html
type DeviceGroupPresentInfoKHR C.struct_VkDeviceGroupPresentInfoKHR

// SizeofDeviceGroupPresentInfoKHR is the memory size of a DeviceGroupPresentInfoKHR
var SizeofDeviceGroupPresentInfoKHR int = int(unsafe.Sizeof(DeviceGroupPresentInfoKHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DeviceGroupPresentInfoKHR) ArpPtr(arp *AutoReleasePool) *DeviceGroupPresentInfoKHR {
	ptr := newCBlock(cULong(SizeofDeviceGroupPresentInfoKHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DeviceGroupPresentInfoKHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceGroupPresentInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceGroupPresentInfoKHR) AsCPtr() *DeviceGroupPresentInfoKHR {
	clone := (*DeviceGroupPresentInfoKHR)(newCBlock(cULong(SizeofDeviceGroupPresentInfoKHR)))
	*clone = x
	return clone
}

// DeviceGroupPresentInfoKHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DeviceGroupPresentInfoKHRCSlice(arp *AutoReleasePool, x ...DeviceGroupPresentInfoKHR) []DeviceGroupPresentInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupPresentInfoKHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DeviceGroupPresentInfoKHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DeviceGroupPresentInfoKHRFreeCSlice releases the memory allocated by DeviceGroupPresentInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceGroupPresentInfoKHRFreeCSlice(x []DeviceGroupPresentInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceGroupPresentInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceGroupPresentInfoKHRFreeCSlice must be called on the returned slice.
func DeviceGroupPresentInfoKHRMakeCSlice(x ...DeviceGroupPresentInfoKHR) []DeviceGroupPresentInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupPresentInfoKHR * len(x)
	dst := unsafe.Slice((*DeviceGroupPresentInfoKHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceGroupPresentInfoKHR
func (x DeviceGroupPresentInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DeviceGroupPresentInfoKHR with the value of
// SType to the value provided in the specification.
func (x DeviceGroupPresentInfoKHR) WithDefaultSType() DeviceGroupPresentInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DeviceGroupPresentInfoKHR) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR)
}

// WithSType clones a new DeviceGroupPresentInfoKHR with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupPresentInfoKHR) WithSType(y StructureType) DeviceGroupPresentInfoKHR {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DeviceGroupPresentInfoKHR) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDeviceGroupPresentInfoKHR
func (x DeviceGroupPresentInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DeviceGroupPresentInfoKHR with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupPresentInfoKHR) WithPNext(y unsafe.Pointer) DeviceGroupPresentInfoKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DeviceGroupPresentInfoKHR) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SwapchainCount returns the value of swapchainCount from VkDeviceGroupPresentInfoKHR
func (x DeviceGroupPresentInfoKHR) SwapchainCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.swapchainCount)
	return *ptr
}

// WithSwapchainCount clones a new DeviceGroupPresentInfoKHR with the value of
// SwapchainCount updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupPresentInfoKHR) WithSwapchainCount(y uint32) DeviceGroupPresentInfoKHR {
	x.swapchainCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DeviceGroupPresentInfoKHR) SetSwapchainCount(y uint32) {
	x.swapchainCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PDeviceMasks returns the value of pDeviceMasks from VkDeviceGroupPresentInfoKHR
func (x DeviceGroupPresentInfoKHR) PDeviceMasks() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pDeviceMasks)
	return *ptr
}

// WithPDeviceMasks clones a new DeviceGroupPresentInfoKHR with the value of
// PDeviceMasks updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SwapchainCount as the length of this field.
// SwapchainCount is updated with the length of the new value.
func (x DeviceGroupPresentInfoKHR) WithPDeviceMasks(y []uint32) DeviceGroupPresentInfoKHR {
	x.pDeviceMasks = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	return x.WithSwapchainCount(uint32(len(y)))
}
func (x *DeviceGroupPresentInfoKHR) SetPDeviceMasks(y []uint32) {
	x.pDeviceMasks = *(func(x *[]uint32) **C.uint32_t { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint32_t)(unsafe.Pointer((&ptr)))
	}(&y))
	x.SetSwapchainCount(uint32(len(y)))
}

// Mode returns the value of mode from VkDeviceGroupPresentInfoKHR
func (x DeviceGroupPresentInfoKHR) Mode() DeviceGroupPresentModeFlagBitsKHR {
	ptr := /* typedef */ (*DeviceGroupPresentModeFlagBitsKHR)(&x.mode)
	return *ptr
}

// WithMode clones a new DeviceGroupPresentInfoKHR with the value of
// Mode updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupPresentInfoKHR) WithMode(y DeviceGroupPresentModeFlagBitsKHR) DeviceGroupPresentInfoKHR {
	x.mode = *( /* typedef */ (*C.VkDeviceGroupPresentModeFlagBitsKHR)(&y))
	return x
}
func (x *DeviceGroupPresentInfoKHR) SetMode(y DeviceGroupPresentModeFlagBitsKHR) {
	x.mode = *( /* typedef */ (*C.VkDeviceGroupPresentModeFlagBitsKHR)(&y))
}

// ImageSwapchainCreateInfoKHR provides a go interface for VkImageSwapchainCreateInfoKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSwapchainCreateInfoKHR.html
type ImageSwapchainCreateInfoKHR C.struct_VkImageSwapchainCreateInfoKHR

// SizeofImageSwapchainCreateInfoKHR is the memory size of a ImageSwapchainCreateInfoKHR
var SizeofImageSwapchainCreateInfoKHR int = int(unsafe.Sizeof(ImageSwapchainCreateInfoKHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x ImageSwapchainCreateInfoKHR) ArpPtr(arp *AutoReleasePool) *ImageSwapchainCreateInfoKHR {
	ptr := newCBlock(cULong(SizeofImageSwapchainCreateInfoKHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*ImageSwapchainCreateInfoKHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageSwapchainCreateInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageSwapchainCreateInfoKHR) AsCPtr() *ImageSwapchainCreateInfoKHR {
	clone := (*ImageSwapchainCreateInfoKHR)(newCBlock(cULong(SizeofImageSwapchainCreateInfoKHR)))
	*clone = x
	return clone
}

// ImageSwapchainCreateInfoKHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func ImageSwapchainCreateInfoKHRCSlice(arp *AutoReleasePool, x ...ImageSwapchainCreateInfoKHR) []ImageSwapchainCreateInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageSwapchainCreateInfoKHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*ImageSwapchainCreateInfoKHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// ImageSwapchainCreateInfoKHRFreeCSlice releases the memory allocated by ImageSwapchainCreateInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageSwapchainCreateInfoKHRFreeCSlice(x []ImageSwapchainCreateInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageSwapchainCreateInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageSwapchainCreateInfoKHRFreeCSlice must be called on the returned slice.
func ImageSwapchainCreateInfoKHRMakeCSlice(x ...ImageSwapchainCreateInfoKHR) []ImageSwapchainCreateInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageSwapchainCreateInfoKHR * len(x)
	dst := unsafe.Slice((*ImageSwapchainCreateInfoKHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageSwapchainCreateInfoKHR
func (x ImageSwapchainCreateInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new ImageSwapchainCreateInfoKHR with the value of
// SType to the value provided in the specification.
func (x ImageSwapchainCreateInfoKHR) WithDefaultSType() ImageSwapchainCreateInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *ImageSwapchainCreateInfoKHR) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR)
}

// WithSType clones a new ImageSwapchainCreateInfoKHR with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSwapchainCreateInfoKHR) WithSType(y StructureType) ImageSwapchainCreateInfoKHR {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *ImageSwapchainCreateInfoKHR) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkImageSwapchainCreateInfoKHR
func (x ImageSwapchainCreateInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new ImageSwapchainCreateInfoKHR with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSwapchainCreateInfoKHR) WithPNext(y unsafe.Pointer) ImageSwapchainCreateInfoKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *ImageSwapchainCreateInfoKHR) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Swapchain returns the value of swapchain from VkImageSwapchainCreateInfoKHR
func (x ImageSwapchainCreateInfoKHR) Swapchain() SwapchainKHR {
	ptr := /* handle */ (*SwapchainKHR)(&x.swapchain)
	return *ptr
}

// WithSwapchain clones a new ImageSwapchainCreateInfoKHR with the value of
// Swapchain updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSwapchainCreateInfoKHR) WithSwapchain(y SwapchainKHR) ImageSwapchainCreateInfoKHR {
	x.swapchain = *( /* handle */ (*C.VkSwapchainKHR)(&y))
	return x
}
func (x *ImageSwapchainCreateInfoKHR) SetSwapchain(y SwapchainKHR) {
	x.swapchain = *( /* handle */ (*C.VkSwapchainKHR)(&y))
}

// AcquireNextImageInfoKHR provides a go interface for VkAcquireNextImageInfoKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAcquireNextImageInfoKHR.html
type AcquireNextImageInfoKHR C.struct_VkAcquireNextImageInfoKHR

// SizeofAcquireNextImageInfoKHR is the memory size of a AcquireNextImageInfoKHR
var SizeofAcquireNextImageInfoKHR int = int(unsafe.Sizeof(AcquireNextImageInfoKHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x AcquireNextImageInfoKHR) ArpPtr(arp *AutoReleasePool) *AcquireNextImageInfoKHR {
	ptr := newCBlock(cULong(SizeofAcquireNextImageInfoKHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*AcquireNextImageInfoKHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *AcquireNextImageInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x AcquireNextImageInfoKHR) AsCPtr() *AcquireNextImageInfoKHR {
	clone := (*AcquireNextImageInfoKHR)(newCBlock(cULong(SizeofAcquireNextImageInfoKHR)))
	*clone = x
	return clone
}

// AcquireNextImageInfoKHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func AcquireNextImageInfoKHRCSlice(arp *AutoReleasePool, x ...AcquireNextImageInfoKHR) []AcquireNextImageInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAcquireNextImageInfoKHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*AcquireNextImageInfoKHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// AcquireNextImageInfoKHRFreeCSlice releases the memory allocated by AcquireNextImageInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func AcquireNextImageInfoKHRFreeCSlice(x []AcquireNextImageInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// AcquireNextImageInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. AcquireNextImageInfoKHRFreeCSlice must be called on the returned slice.
func AcquireNextImageInfoKHRMakeCSlice(x ...AcquireNextImageInfoKHR) []AcquireNextImageInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAcquireNextImageInfoKHR * len(x)
	dst := unsafe.Slice((*AcquireNextImageInfoKHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkAcquireNextImageInfoKHR
func (x AcquireNextImageInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new AcquireNextImageInfoKHR with the value of
// SType to the value provided in the specification.
func (x AcquireNextImageInfoKHR) WithDefaultSType() AcquireNextImageInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *AcquireNextImageInfoKHR) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR)
}

// WithSType clones a new AcquireNextImageInfoKHR with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AcquireNextImageInfoKHR) WithSType(y StructureType) AcquireNextImageInfoKHR {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *AcquireNextImageInfoKHR) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkAcquireNextImageInfoKHR
func (x AcquireNextImageInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new AcquireNextImageInfoKHR with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AcquireNextImageInfoKHR) WithPNext(y unsafe.Pointer) AcquireNextImageInfoKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *AcquireNextImageInfoKHR) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Swapchain returns the value of swapchain from VkAcquireNextImageInfoKHR
func (x AcquireNextImageInfoKHR) Swapchain() SwapchainKHR {
	ptr := /* handle */ (*SwapchainKHR)(&x.swapchain)
	return *ptr
}

// WithSwapchain clones a new AcquireNextImageInfoKHR with the value of
// Swapchain updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AcquireNextImageInfoKHR) WithSwapchain(y SwapchainKHR) AcquireNextImageInfoKHR {
	x.swapchain = *( /* handle */ (*C.VkSwapchainKHR)(&y))
	return x
}
func (x *AcquireNextImageInfoKHR) SetSwapchain(y SwapchainKHR) {
	x.swapchain = *( /* handle */ (*C.VkSwapchainKHR)(&y))
}

// Timeout returns the value of timeout from VkAcquireNextImageInfoKHR
func (x AcquireNextImageInfoKHR) Timeout() uint64 {
	ptr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.timeout)
	return *ptr
}

// WithTimeout clones a new AcquireNextImageInfoKHR with the value of
// Timeout updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AcquireNextImageInfoKHR) WithTimeout(y uint64) AcquireNextImageInfoKHR {
	x.timeout = *(func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&y))
	return x
}
func (x *AcquireNextImageInfoKHR) SetTimeout(y uint64) {
	x.timeout = *(func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&y))
}

// Semaphore returns the value of semaphore from VkAcquireNextImageInfoKHR
func (x AcquireNextImageInfoKHR) Semaphore() Semaphore {
	ptr := /* handle */ (*Semaphore)(&x.semaphore)
	return *ptr
}

// WithSemaphore clones a new AcquireNextImageInfoKHR with the value of
// Semaphore updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AcquireNextImageInfoKHR) WithSemaphore(y Semaphore) AcquireNextImageInfoKHR {
	x.semaphore = *( /* handle */ (*C.VkSemaphore)(&y))
	return x
}
func (x *AcquireNextImageInfoKHR) SetSemaphore(y Semaphore) {
	x.semaphore = *( /* handle */ (*C.VkSemaphore)(&y))
}

// Fence returns the value of fence from VkAcquireNextImageInfoKHR
func (x AcquireNextImageInfoKHR) Fence() Fence {
	ptr := /* handle */ (*Fence)(&x.fence)
	return *ptr
}

// WithFence clones a new AcquireNextImageInfoKHR with the value of
// Fence updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AcquireNextImageInfoKHR) WithFence(y Fence) AcquireNextImageInfoKHR {
	x.fence = *( /* handle */ (*C.VkFence)(&y))
	return x
}
func (x *AcquireNextImageInfoKHR) SetFence(y Fence) {
	x.fence = *( /* handle */ (*C.VkFence)(&y))
}

// DeviceMask returns the value of deviceMask from VkAcquireNextImageInfoKHR
func (x AcquireNextImageInfoKHR) DeviceMask() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.deviceMask)
	return *ptr
}

// WithDeviceMask clones a new AcquireNextImageInfoKHR with the value of
// DeviceMask updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AcquireNextImageInfoKHR) WithDeviceMask(y uint32) AcquireNextImageInfoKHR {
	x.deviceMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *AcquireNextImageInfoKHR) SetDeviceMask(y uint32) {
	x.deviceMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// BindImageMemorySwapchainInfoKHR provides a go interface for VkBindImageMemorySwapchainInfoKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindImageMemorySwapchainInfoKHR.html
type BindImageMemorySwapchainInfoKHR C.struct_VkBindImageMemorySwapchainInfoKHR

// SizeofBindImageMemorySwapchainInfoKHR is the memory size of a BindImageMemorySwapchainInfoKHR
var SizeofBindImageMemorySwapchainInfoKHR int = int(unsafe.Sizeof(BindImageMemorySwapchainInfoKHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x BindImageMemorySwapchainInfoKHR) ArpPtr(arp *AutoReleasePool) *BindImageMemorySwapchainInfoKHR {
	ptr := newCBlock(cULong(SizeofBindImageMemorySwapchainInfoKHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*BindImageMemorySwapchainInfoKHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BindImageMemorySwapchainInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BindImageMemorySwapchainInfoKHR) AsCPtr() *BindImageMemorySwapchainInfoKHR {
	clone := (*BindImageMemorySwapchainInfoKHR)(newCBlock(cULong(SizeofBindImageMemorySwapchainInfoKHR)))
	*clone = x
	return clone
}

// BindImageMemorySwapchainInfoKHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func BindImageMemorySwapchainInfoKHRCSlice(arp *AutoReleasePool, x ...BindImageMemorySwapchainInfoKHR) []BindImageMemorySwapchainInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindImageMemorySwapchainInfoKHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*BindImageMemorySwapchainInfoKHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// BindImageMemorySwapchainInfoKHRFreeCSlice releases the memory allocated by BindImageMemorySwapchainInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func BindImageMemorySwapchainInfoKHRFreeCSlice(x []BindImageMemorySwapchainInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BindImageMemorySwapchainInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BindImageMemorySwapchainInfoKHRFreeCSlice must be called on the returned slice.
func BindImageMemorySwapchainInfoKHRMakeCSlice(x ...BindImageMemorySwapchainInfoKHR) []BindImageMemorySwapchainInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindImageMemorySwapchainInfoKHR * len(x)
	dst := unsafe.Slice((*BindImageMemorySwapchainInfoKHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBindImageMemorySwapchainInfoKHR
func (x BindImageMemorySwapchainInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new BindImageMemorySwapchainInfoKHR with the value of
// SType to the value provided in the specification.
func (x BindImageMemorySwapchainInfoKHR) WithDefaultSType() BindImageMemorySwapchainInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *BindImageMemorySwapchainInfoKHR) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR)
}

// WithSType clones a new BindImageMemorySwapchainInfoKHR with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemorySwapchainInfoKHR) WithSType(y StructureType) BindImageMemorySwapchainInfoKHR {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *BindImageMemorySwapchainInfoKHR) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkBindImageMemorySwapchainInfoKHR
func (x BindImageMemorySwapchainInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new BindImageMemorySwapchainInfoKHR with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemorySwapchainInfoKHR) WithPNext(y unsafe.Pointer) BindImageMemorySwapchainInfoKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *BindImageMemorySwapchainInfoKHR) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Swapchain returns the value of swapchain from VkBindImageMemorySwapchainInfoKHR
func (x BindImageMemorySwapchainInfoKHR) Swapchain() SwapchainKHR {
	ptr := /* handle */ (*SwapchainKHR)(&x.swapchain)
	return *ptr
}

// WithSwapchain clones a new BindImageMemorySwapchainInfoKHR with the value of
// Swapchain updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemorySwapchainInfoKHR) WithSwapchain(y SwapchainKHR) BindImageMemorySwapchainInfoKHR {
	x.swapchain = *( /* handle */ (*C.VkSwapchainKHR)(&y))
	return x
}
func (x *BindImageMemorySwapchainInfoKHR) SetSwapchain(y SwapchainKHR) {
	x.swapchain = *( /* handle */ (*C.VkSwapchainKHR)(&y))
}

// ImageIndex returns the value of imageIndex from VkBindImageMemorySwapchainInfoKHR
func (x BindImageMemorySwapchainInfoKHR) ImageIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.imageIndex)
	return *ptr
}

// WithImageIndex clones a new BindImageMemorySwapchainInfoKHR with the value of
// ImageIndex updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemorySwapchainInfoKHR) WithImageIndex(y uint32) BindImageMemorySwapchainInfoKHR {
	x.imageIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *BindImageMemorySwapchainInfoKHR) SetImageIndex(y uint32) {
	x.imageIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// CreateSwapchainKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSwapchainKHR.html
func (x DeviceFacade) CreateSwapchainKHR(pCreateInfo *SwapchainCreateInfoKHR, pAllocator *AllocationCallbacks, pSwapchain *SwapchainKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **SwapchainCreateInfoKHR) **C.struct_VkSwapchainCreateInfoKHR { /* Pointer */
		g2c := (*C.struct_VkSwapchainCreateInfoKHR)(*x)
		return &g2c
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p3 := func(x **SwapchainKHR) **C.VkSwapchainKHR { /* Pointer */ g2c := (*C.VkSwapchainKHR)(*x); return &g2c }(&pSwapchain)
	ret := C.vkCreateSwapchainKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// AcquireNextImageKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImageKHR.html
func (x DeviceFacade) AcquireNextImageKHR(swapchain SwapchainKHR, timeout uint64, semaphore Semaphore, fence Fence, pImageIndex *uint32) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkSwapchainKHR)(&swapchain)
	p2 := func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&timeout)
	p3 := /* handle */ (*C.VkSemaphore)(&semaphore)
	p4 := /* handle */ (*C.VkFence)(&fence)
	p5 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pImageIndex)
	ret := C.vkAcquireNextImageKHR(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// QueuePresentKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html
func (x QueueFacade) QueuePresentKHR(pPresentInfo *PresentInfoKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkQueue)(&x.H)
	p1 := func(x **PresentInfoKHR) **C.struct_VkPresentInfoKHR { /* Pointer */
		g2c := (*C.struct_VkPresentInfoKHR)(*x)
		return &g2c
	}(&pPresentInfo)
	ret := C.vkQueuePresentKHR(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// AcquireNextImage2KHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImage2KHR.html
func (x DeviceFacade) AcquireNextImage2KHR(pAcquireInfo *AcquireNextImageInfoKHR, pImageIndex *uint32) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **AcquireNextImageInfoKHR) **C.struct_VkAcquireNextImageInfoKHR { /* Pointer */
		g2c := (*C.struct_VkAcquireNextImageInfoKHR)(*x)
		return &g2c
	}(&pAcquireInfo)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pImageIndex)
	ret := C.vkAcquireNextImage2KHR(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDevicePresentRectanglesKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDevicePresentRectanglesKHR.html
func (x PhysicalDeviceFacade) GetPhysicalDevicePresentRectanglesKHR(surface SurfaceKHR, pRectCount *uint32, pRects []Rect2D) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* handle */ (*C.VkSurfaceKHR)(&surface)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pRectCount)
	p3 := func(x *[]Rect2D) **C.struct_VkRect2D { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkRect2D)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkRect2D)(unsafe.Pointer((&ptr)))
	}(&pRects)
	ret := C.vkGetPhysicalDevicePresentRectanglesKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetSwapchainImagesKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSwapchainImagesKHR.html
func (x DeviceFacade) GetSwapchainImagesKHR(swapchain SwapchainKHR, pSwapchainImageCount *uint32, pSwapchainImages []Image) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkSwapchainKHR)(&swapchain)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pSwapchainImageCount)
	p3 := func(x *[]Image) **C.VkImage { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkImage)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkImage)(unsafe.Pointer((&ptr)))
	}(&pSwapchainImages)
	ret := C.vkGetSwapchainImagesKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetDeviceGroupSurfacePresentModesKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceGroupSurfacePresentModesKHR.html
func (x DeviceFacade) GetDeviceGroupSurfacePresentModesKHR(surface SurfaceKHR, pModes *DeviceGroupPresentModeFlagsKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkSurfaceKHR)(&surface)
	p2 := func(x **DeviceGroupPresentModeFlagsKHR) **C.VkDeviceGroupPresentModeFlagsKHR { /* Pointer */
		g2c := (*C.VkDeviceGroupPresentModeFlagsKHR)(*x)
		return &g2c
	}(&pModes)
	ret := C.vkGetDeviceGroupSurfacePresentModesKHR(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroySwapchainKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySwapchainKHR.html
func (x DeviceFacade) DestroySwapchainKHR(swapchain SwapchainKHR, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkSwapchainKHR)(&swapchain)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	C.vkDestroySwapchainKHR(addrs, *p0, *p1, *p2)
}

// GetDeviceGroupPresentCapabilitiesKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceGroupPresentCapabilitiesKHR.html
func (x DeviceFacade) GetDeviceGroupPresentCapabilitiesKHR(pDeviceGroupPresentCapabilities *DeviceGroupPresentCapabilitiesKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DeviceGroupPresentCapabilitiesKHR) **C.struct_VkDeviceGroupPresentCapabilitiesKHR { /* Pointer */
		g2c := (*C.struct_VkDeviceGroupPresentCapabilitiesKHR)(*x)
		return &g2c
	}(&pDeviceGroupPresentCapabilities)
	ret := C.vkGetDeviceGroupPresentCapabilitiesKHR(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DisplayKHR is a Handle to a vulkan resource.
// DisplayKHR is a child of PhysicalDevice.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayKHR.html
type DisplayKHR C.VkDisplayKHR

// NullDisplayKHR is a typed Null value for the DisplayKHR type.
var NullDisplayKHR DisplayKHR

// DisplayModeKHR is a Handle to a vulkan resource.
// DisplayModeKHR is a child of DisplayKHR.
//
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModeKHR.html
type DisplayModeKHR C.VkDisplayModeKHR

// NullDisplayModeKHR is a typed Null value for the DisplayModeKHR type.
var NullDisplayModeKHR DisplayModeKHR

// DisplayPlaneAlphaFlagBitsKHR enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlaneAlphaFlagBitsKHR.html
type DisplayPlaneAlphaFlagBitsKHR uint32

const (
	VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR                  DisplayPlaneAlphaFlagBitsKHR = (1 << 0)
	VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR                  DisplayPlaneAlphaFlagBitsKHR = (1 << 1)
	VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR               DisplayPlaneAlphaFlagBitsKHR = (1 << 2)
	VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR DisplayPlaneAlphaFlagBitsKHR = (1 << 3)
)

var (
	reverseDisplayPlaneAlphaFlagBitsKHR map[DisplayPlaneAlphaFlagBitsKHR]string = map[DisplayPlaneAlphaFlagBitsKHR]string{
		VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR:                  "VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR",
		VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR:                  "VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR",
		VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR:               "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR",
		VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR: "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR",
	}
)

func (x DisplayPlaneAlphaFlagBitsKHR) String() string {
	if s, ok := reverseDisplayPlaneAlphaFlagBitsKHR[x]; ok {
		return s
	}
	return fmt.Sprintf("DisplayPlaneAlphaFlagBitsKHR=%d", x)
}

// DisplaySurfaceCreateFlagsKHR bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplaySurfaceCreateFlagsKHR.html
type DisplaySurfaceCreateFlagsKHR Flags

// DisplayPlaneAlphaFlagsKHR bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlaneAlphaFlagsKHR.html
type DisplayPlaneAlphaFlagsKHR Flags

// DisplayModeCreateFlagsKHR bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModeCreateFlagsKHR.html
type DisplayModeCreateFlagsKHR Flags

// DisplayModeParametersKHR provides a go interface for VkDisplayModeParametersKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModeParametersKHR.html
type DisplayModeParametersKHR C.struct_VkDisplayModeParametersKHR

// SizeofDisplayModeParametersKHR is the memory size of a DisplayModeParametersKHR
var SizeofDisplayModeParametersKHR int = int(unsafe.Sizeof(DisplayModeParametersKHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DisplayModeParametersKHR) ArpPtr(arp *AutoReleasePool) *DisplayModeParametersKHR {
	ptr := newCBlock(cULong(SizeofDisplayModeParametersKHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DisplayModeParametersKHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayModeParametersKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayModeParametersKHR) AsCPtr() *DisplayModeParametersKHR {
	clone := (*DisplayModeParametersKHR)(newCBlock(cULong(SizeofDisplayModeParametersKHR)))
	*clone = x
	return clone
}

// DisplayModeParametersKHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DisplayModeParametersKHRCSlice(arp *AutoReleasePool, x ...DisplayModeParametersKHR) []DisplayModeParametersKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayModeParametersKHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DisplayModeParametersKHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DisplayModeParametersKHRFreeCSlice releases the memory allocated by DisplayModeParametersKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayModeParametersKHRFreeCSlice(x []DisplayModeParametersKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayModeParametersKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayModeParametersKHRFreeCSlice must be called on the returned slice.
func DisplayModeParametersKHRMakeCSlice(x ...DisplayModeParametersKHR) []DisplayModeParametersKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayModeParametersKHR * len(x)
	dst := unsafe.Slice((*DisplayModeParametersKHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// VisibleRegion returns the value of visibleRegion from VkDisplayModeParametersKHR
func (x DisplayModeParametersKHR) VisibleRegion() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.visibleRegion)
	return *ptr
}

// WithVisibleRegion clones a new DisplayModeParametersKHR with the value of
// VisibleRegion updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayModeParametersKHR) WithVisibleRegion(y Extent2D) DisplayModeParametersKHR {
	x.visibleRegion = *( /* typedef */ (*C.struct_VkExtent2D)(&y))
	return x
}
func (x *DisplayModeParametersKHR) SetVisibleRegion(y Extent2D) {
	x.visibleRegion = *( /* typedef */ (*C.struct_VkExtent2D)(&y))
}

// RefreshRate returns the value of refreshRate from VkDisplayModeParametersKHR
func (x DisplayModeParametersKHR) RefreshRate() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.refreshRate)
	return *ptr
}

// WithRefreshRate clones a new DisplayModeParametersKHR with the value of
// RefreshRate updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayModeParametersKHR) WithRefreshRate(y uint32) DisplayModeParametersKHR {
	x.refreshRate = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DisplayModeParametersKHR) SetRefreshRate(y uint32) {
	x.refreshRate = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// DisplayModePropertiesKHR provides a go interface for VkDisplayModePropertiesKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModePropertiesKHR.html
type DisplayModePropertiesKHR C.struct_VkDisplayModePropertiesKHR

// SizeofDisplayModePropertiesKHR is the memory size of a DisplayModePropertiesKHR
var SizeofDisplayModePropertiesKHR int = int(unsafe.Sizeof(DisplayModePropertiesKHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DisplayModePropertiesKHR) ArpPtr(arp *AutoReleasePool) *DisplayModePropertiesKHR {
	ptr := newCBlock(cULong(SizeofDisplayModePropertiesKHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DisplayModePropertiesKHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayModePropertiesKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayModePropertiesKHR) AsCPtr() *DisplayModePropertiesKHR {
	clone := (*DisplayModePropertiesKHR)(newCBlock(cULong(SizeofDisplayModePropertiesKHR)))
	*clone = x
	return clone
}

// DisplayModePropertiesKHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DisplayModePropertiesKHRCSlice(arp *AutoReleasePool, x ...DisplayModePropertiesKHR) []DisplayModePropertiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayModePropertiesKHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DisplayModePropertiesKHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DisplayModePropertiesKHRFreeCSlice releases the memory allocated by DisplayModePropertiesKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayModePropertiesKHRFreeCSlice(x []DisplayModePropertiesKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayModePropertiesKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayModePropertiesKHRFreeCSlice must be called on the returned slice.
func DisplayModePropertiesKHRMakeCSlice(x ...DisplayModePropertiesKHR) []DisplayModePropertiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayModePropertiesKHR * len(x)
	dst := unsafe.Slice((*DisplayModePropertiesKHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// DisplayMode returns the value of displayMode from VkDisplayModePropertiesKHR
func (x DisplayModePropertiesKHR) DisplayMode() DisplayModeKHR {
	ptr := /* handle */ (*DisplayModeKHR)(&x.displayMode)
	return *ptr
}

// Parameters returns the value of parameters from VkDisplayModePropertiesKHR
func (x DisplayModePropertiesKHR) Parameters() DisplayModeParametersKHR {
	ptr := /* typedef */ (*DisplayModeParametersKHR)(&x.parameters)
	return *ptr
}

// DisplayPlaneCapabilitiesKHR provides a go interface for VkDisplayPlaneCapabilitiesKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlaneCapabilitiesKHR.html
type DisplayPlaneCapabilitiesKHR C.struct_VkDisplayPlaneCapabilitiesKHR

// SizeofDisplayPlaneCapabilitiesKHR is the memory size of a DisplayPlaneCapabilitiesKHR
var SizeofDisplayPlaneCapabilitiesKHR int = int(unsafe.Sizeof(DisplayPlaneCapabilitiesKHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DisplayPlaneCapabilitiesKHR) ArpPtr(arp *AutoReleasePool) *DisplayPlaneCapabilitiesKHR {
	ptr := newCBlock(cULong(SizeofDisplayPlaneCapabilitiesKHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DisplayPlaneCapabilitiesKHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayPlaneCapabilitiesKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayPlaneCapabilitiesKHR) AsCPtr() *DisplayPlaneCapabilitiesKHR {
	clone := (*DisplayPlaneCapabilitiesKHR)(newCBlock(cULong(SizeofDisplayPlaneCapabilitiesKHR)))
	*clone = x
	return clone
}

// DisplayPlaneCapabilitiesKHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DisplayPlaneCapabilitiesKHRCSlice(arp *AutoReleasePool, x ...DisplayPlaneCapabilitiesKHR) []DisplayPlaneCapabilitiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPlaneCapabilitiesKHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DisplayPlaneCapabilitiesKHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DisplayPlaneCapabilitiesKHRFreeCSlice releases the memory allocated by DisplayPlaneCapabilitiesKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayPlaneCapabilitiesKHRFreeCSlice(x []DisplayPlaneCapabilitiesKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayPlaneCapabilitiesKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayPlaneCapabilitiesKHRFreeCSlice must be called on the returned slice.
func DisplayPlaneCapabilitiesKHRMakeCSlice(x ...DisplayPlaneCapabilitiesKHR) []DisplayPlaneCapabilitiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPlaneCapabilitiesKHR * len(x)
	dst := unsafe.Slice((*DisplayPlaneCapabilitiesKHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SupportedAlpha returns the value of supportedAlpha from VkDisplayPlaneCapabilitiesKHR
func (x DisplayPlaneCapabilitiesKHR) SupportedAlpha() DisplayPlaneAlphaFlagsKHR {
	ptr := /* typedef */ (*DisplayPlaneAlphaFlagsKHR)(&x.supportedAlpha)
	return *ptr
}

// MinSrcPosition returns the value of minSrcPosition from VkDisplayPlaneCapabilitiesKHR
func (x DisplayPlaneCapabilitiesKHR) MinSrcPosition() Offset2D {
	ptr := /* typedef */ (*Offset2D)(&x.minSrcPosition)
	return *ptr
}

// MaxSrcPosition returns the value of maxSrcPosition from VkDisplayPlaneCapabilitiesKHR
func (x DisplayPlaneCapabilitiesKHR) MaxSrcPosition() Offset2D {
	ptr := /* typedef */ (*Offset2D)(&x.maxSrcPosition)
	return *ptr
}

// MinSrcExtent returns the value of minSrcExtent from VkDisplayPlaneCapabilitiesKHR
func (x DisplayPlaneCapabilitiesKHR) MinSrcExtent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.minSrcExtent)
	return *ptr
}

// MaxSrcExtent returns the value of maxSrcExtent from VkDisplayPlaneCapabilitiesKHR
func (x DisplayPlaneCapabilitiesKHR) MaxSrcExtent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.maxSrcExtent)
	return *ptr
}

// MinDstPosition returns the value of minDstPosition from VkDisplayPlaneCapabilitiesKHR
func (x DisplayPlaneCapabilitiesKHR) MinDstPosition() Offset2D {
	ptr := /* typedef */ (*Offset2D)(&x.minDstPosition)
	return *ptr
}

// MaxDstPosition returns the value of maxDstPosition from VkDisplayPlaneCapabilitiesKHR
func (x DisplayPlaneCapabilitiesKHR) MaxDstPosition() Offset2D {
	ptr := /* typedef */ (*Offset2D)(&x.maxDstPosition)
	return *ptr
}

// MinDstExtent returns the value of minDstExtent from VkDisplayPlaneCapabilitiesKHR
func (x DisplayPlaneCapabilitiesKHR) MinDstExtent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.minDstExtent)
	return *ptr
}

// MaxDstExtent returns the value of maxDstExtent from VkDisplayPlaneCapabilitiesKHR
func (x DisplayPlaneCapabilitiesKHR) MaxDstExtent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.maxDstExtent)
	return *ptr
}

// DisplaySurfaceCreateInfoKHR provides a go interface for VkDisplaySurfaceCreateInfoKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplaySurfaceCreateInfoKHR.html
type DisplaySurfaceCreateInfoKHR C.struct_VkDisplaySurfaceCreateInfoKHR

// SizeofDisplaySurfaceCreateInfoKHR is the memory size of a DisplaySurfaceCreateInfoKHR
var SizeofDisplaySurfaceCreateInfoKHR int = int(unsafe.Sizeof(DisplaySurfaceCreateInfoKHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DisplaySurfaceCreateInfoKHR) ArpPtr(arp *AutoReleasePool) *DisplaySurfaceCreateInfoKHR {
	ptr := newCBlock(cULong(SizeofDisplaySurfaceCreateInfoKHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DisplaySurfaceCreateInfoKHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplaySurfaceCreateInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplaySurfaceCreateInfoKHR) AsCPtr() *DisplaySurfaceCreateInfoKHR {
	clone := (*DisplaySurfaceCreateInfoKHR)(newCBlock(cULong(SizeofDisplaySurfaceCreateInfoKHR)))
	*clone = x
	return clone
}

// DisplaySurfaceCreateInfoKHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DisplaySurfaceCreateInfoKHRCSlice(arp *AutoReleasePool, x ...DisplaySurfaceCreateInfoKHR) []DisplaySurfaceCreateInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplaySurfaceCreateInfoKHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DisplaySurfaceCreateInfoKHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DisplaySurfaceCreateInfoKHRFreeCSlice releases the memory allocated by DisplaySurfaceCreateInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplaySurfaceCreateInfoKHRFreeCSlice(x []DisplaySurfaceCreateInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplaySurfaceCreateInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplaySurfaceCreateInfoKHRFreeCSlice must be called on the returned slice.
func DisplaySurfaceCreateInfoKHRMakeCSlice(x ...DisplaySurfaceCreateInfoKHR) []DisplaySurfaceCreateInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplaySurfaceCreateInfoKHR * len(x)
	dst := unsafe.Slice((*DisplaySurfaceCreateInfoKHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DisplaySurfaceCreateInfoKHR with the value of
// SType to the value provided in the specification.
func (x DisplaySurfaceCreateInfoKHR) WithDefaultSType() DisplaySurfaceCreateInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DisplaySurfaceCreateInfoKHR) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR)
}

// WithSType clones a new DisplaySurfaceCreateInfoKHR with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithSType(y StructureType) DisplaySurfaceCreateInfoKHR {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DisplaySurfaceCreateInfoKHR) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DisplaySurfaceCreateInfoKHR with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithPNext(y unsafe.Pointer) DisplaySurfaceCreateInfoKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DisplaySurfaceCreateInfoKHR) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) Flags() DisplaySurfaceCreateFlagsKHR {
	ptr := /* typedef */ (*DisplaySurfaceCreateFlagsKHR)(&x.flags)
	return *ptr
}

// WithFlags clones a new DisplaySurfaceCreateInfoKHR with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithFlags(y DisplaySurfaceCreateFlagsKHR) DisplaySurfaceCreateInfoKHR {
	x.flags = *( /* typedef */ (*C.VkDisplaySurfaceCreateFlagsKHR)(&y))
	return x
}
func (x *DisplaySurfaceCreateInfoKHR) SetFlags(y DisplaySurfaceCreateFlagsKHR) {
	x.flags = *( /* typedef */ (*C.VkDisplaySurfaceCreateFlagsKHR)(&y))
}

// DisplayMode returns the value of displayMode from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) DisplayMode() DisplayModeKHR {
	ptr := /* handle */ (*DisplayModeKHR)(&x.displayMode)
	return *ptr
}

// WithDisplayMode clones a new DisplaySurfaceCreateInfoKHR with the value of
// DisplayMode updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithDisplayMode(y DisplayModeKHR) DisplaySurfaceCreateInfoKHR {
	x.displayMode = *( /* handle */ (*C.VkDisplayModeKHR)(&y))
	return x
}
func (x *DisplaySurfaceCreateInfoKHR) SetDisplayMode(y DisplayModeKHR) {
	x.displayMode = *( /* handle */ (*C.VkDisplayModeKHR)(&y))
}

// PlaneIndex returns the value of planeIndex from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) PlaneIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.planeIndex)
	return *ptr
}

// WithPlaneIndex clones a new DisplaySurfaceCreateInfoKHR with the value of
// PlaneIndex updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithPlaneIndex(y uint32) DisplaySurfaceCreateInfoKHR {
	x.planeIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DisplaySurfaceCreateInfoKHR) SetPlaneIndex(y uint32) {
	x.planeIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// PlaneStackIndex returns the value of planeStackIndex from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) PlaneStackIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.planeStackIndex)
	return *ptr
}

// WithPlaneStackIndex clones a new DisplaySurfaceCreateInfoKHR with the value of
// PlaneStackIndex updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithPlaneStackIndex(y uint32) DisplaySurfaceCreateInfoKHR {
	x.planeStackIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DisplaySurfaceCreateInfoKHR) SetPlaneStackIndex(y uint32) {
	x.planeStackIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// Transform returns the value of transform from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) Transform() SurfaceTransformFlagBitsKHR {
	ptr := /* typedef */ (*SurfaceTransformFlagBitsKHR)(&x.transform)
	return *ptr
}

// WithTransform clones a new DisplaySurfaceCreateInfoKHR with the value of
// Transform updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithTransform(y SurfaceTransformFlagBitsKHR) DisplaySurfaceCreateInfoKHR {
	x.transform = *( /* typedef */ (*C.VkSurfaceTransformFlagBitsKHR)(&y))
	return x
}
func (x *DisplaySurfaceCreateInfoKHR) SetTransform(y SurfaceTransformFlagBitsKHR) {
	x.transform = *( /* typedef */ (*C.VkSurfaceTransformFlagBitsKHR)(&y))
}

// GlobalAlpha returns the value of globalAlpha from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) GlobalAlpha() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.globalAlpha)
	return *ptr
}

// WithGlobalAlpha clones a new DisplaySurfaceCreateInfoKHR with the value of
// GlobalAlpha updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithGlobalAlpha(y float32) DisplaySurfaceCreateInfoKHR {
	x.globalAlpha = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}
func (x *DisplaySurfaceCreateInfoKHR) SetGlobalAlpha(y float32) {
	x.globalAlpha = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
}

// AlphaMode returns the value of alphaMode from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) AlphaMode() DisplayPlaneAlphaFlagBitsKHR {
	ptr := /* typedef */ (*DisplayPlaneAlphaFlagBitsKHR)(&x.alphaMode)
	return *ptr
}

// WithAlphaMode clones a new DisplaySurfaceCreateInfoKHR with the value of
// AlphaMode updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithAlphaMode(y DisplayPlaneAlphaFlagBitsKHR) DisplaySurfaceCreateInfoKHR {
	x.alphaMode = *( /* typedef */ (*C.VkDisplayPlaneAlphaFlagBitsKHR)(&y))
	return x
}
func (x *DisplaySurfaceCreateInfoKHR) SetAlphaMode(y DisplayPlaneAlphaFlagBitsKHR) {
	x.alphaMode = *( /* typedef */ (*C.VkDisplayPlaneAlphaFlagBitsKHR)(&y))
}

// ImageExtent returns the value of imageExtent from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) ImageExtent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.imageExtent)
	return *ptr
}

// WithImageExtent clones a new DisplaySurfaceCreateInfoKHR with the value of
// ImageExtent updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithImageExtent(y Extent2D) DisplaySurfaceCreateInfoKHR {
	x.imageExtent = *( /* typedef */ (*C.struct_VkExtent2D)(&y))
	return x
}
func (x *DisplaySurfaceCreateInfoKHR) SetImageExtent(y Extent2D) {
	x.imageExtent = *( /* typedef */ (*C.struct_VkExtent2D)(&y))
}

// DisplayModeCreateInfoKHR provides a go interface for VkDisplayModeCreateInfoKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModeCreateInfoKHR.html
type DisplayModeCreateInfoKHR C.struct_VkDisplayModeCreateInfoKHR

// SizeofDisplayModeCreateInfoKHR is the memory size of a DisplayModeCreateInfoKHR
var SizeofDisplayModeCreateInfoKHR int = int(unsafe.Sizeof(DisplayModeCreateInfoKHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DisplayModeCreateInfoKHR) ArpPtr(arp *AutoReleasePool) *DisplayModeCreateInfoKHR {
	ptr := newCBlock(cULong(SizeofDisplayModeCreateInfoKHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DisplayModeCreateInfoKHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayModeCreateInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayModeCreateInfoKHR) AsCPtr() *DisplayModeCreateInfoKHR {
	clone := (*DisplayModeCreateInfoKHR)(newCBlock(cULong(SizeofDisplayModeCreateInfoKHR)))
	*clone = x
	return clone
}

// DisplayModeCreateInfoKHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DisplayModeCreateInfoKHRCSlice(arp *AutoReleasePool, x ...DisplayModeCreateInfoKHR) []DisplayModeCreateInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayModeCreateInfoKHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DisplayModeCreateInfoKHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DisplayModeCreateInfoKHRFreeCSlice releases the memory allocated by DisplayModeCreateInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayModeCreateInfoKHRFreeCSlice(x []DisplayModeCreateInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayModeCreateInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayModeCreateInfoKHRFreeCSlice must be called on the returned slice.
func DisplayModeCreateInfoKHRMakeCSlice(x ...DisplayModeCreateInfoKHR) []DisplayModeCreateInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayModeCreateInfoKHR * len(x)
	dst := unsafe.Slice((*DisplayModeCreateInfoKHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDisplayModeCreateInfoKHR
func (x DisplayModeCreateInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DisplayModeCreateInfoKHR with the value of
// SType to the value provided in the specification.
func (x DisplayModeCreateInfoKHR) WithDefaultSType() DisplayModeCreateInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DisplayModeCreateInfoKHR) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR)
}

// WithSType clones a new DisplayModeCreateInfoKHR with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayModeCreateInfoKHR) WithSType(y StructureType) DisplayModeCreateInfoKHR {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DisplayModeCreateInfoKHR) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDisplayModeCreateInfoKHR
func (x DisplayModeCreateInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DisplayModeCreateInfoKHR with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayModeCreateInfoKHR) WithPNext(y unsafe.Pointer) DisplayModeCreateInfoKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DisplayModeCreateInfoKHR) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Flags returns the value of flags from VkDisplayModeCreateInfoKHR
func (x DisplayModeCreateInfoKHR) Flags() DisplayModeCreateFlagsKHR {
	ptr := /* typedef */ (*DisplayModeCreateFlagsKHR)(&x.flags)
	return *ptr
}

// WithFlags clones a new DisplayModeCreateInfoKHR with the value of
// Flags updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayModeCreateInfoKHR) WithFlags(y DisplayModeCreateFlagsKHR) DisplayModeCreateInfoKHR {
	x.flags = *( /* typedef */ (*C.VkDisplayModeCreateFlagsKHR)(&y))
	return x
}
func (x *DisplayModeCreateInfoKHR) SetFlags(y DisplayModeCreateFlagsKHR) {
	x.flags = *( /* typedef */ (*C.VkDisplayModeCreateFlagsKHR)(&y))
}

// Parameters returns the value of parameters from VkDisplayModeCreateInfoKHR
func (x DisplayModeCreateInfoKHR) Parameters() DisplayModeParametersKHR {
	ptr := /* typedef */ (*DisplayModeParametersKHR)(&x.parameters)
	return *ptr
}

// WithParameters clones a new DisplayModeCreateInfoKHR with the value of
// Parameters updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayModeCreateInfoKHR) WithParameters(y DisplayModeParametersKHR) DisplayModeCreateInfoKHR {
	x.parameters = *( /* typedef */ (*C.struct_VkDisplayModeParametersKHR)(&y))
	return x
}
func (x *DisplayModeCreateInfoKHR) SetParameters(y DisplayModeParametersKHR) {
	x.parameters = *( /* typedef */ (*C.struct_VkDisplayModeParametersKHR)(&y))
}

// DisplayPropertiesKHR provides a go interface for VkDisplayPropertiesKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPropertiesKHR.html
type DisplayPropertiesKHR C.struct_VkDisplayPropertiesKHR

// SizeofDisplayPropertiesKHR is the memory size of a DisplayPropertiesKHR
var SizeofDisplayPropertiesKHR int = int(unsafe.Sizeof(DisplayPropertiesKHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DisplayPropertiesKHR) ArpPtr(arp *AutoReleasePool) *DisplayPropertiesKHR {
	ptr := newCBlock(cULong(SizeofDisplayPropertiesKHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DisplayPropertiesKHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayPropertiesKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayPropertiesKHR) AsCPtr() *DisplayPropertiesKHR {
	clone := (*DisplayPropertiesKHR)(newCBlock(cULong(SizeofDisplayPropertiesKHR)))
	*clone = x
	return clone
}

// DisplayPropertiesKHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DisplayPropertiesKHRCSlice(arp *AutoReleasePool, x ...DisplayPropertiesKHR) []DisplayPropertiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPropertiesKHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DisplayPropertiesKHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DisplayPropertiesKHRFreeCSlice releases the memory allocated by DisplayPropertiesKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayPropertiesKHRFreeCSlice(x []DisplayPropertiesKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayPropertiesKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayPropertiesKHRFreeCSlice must be called on the returned slice.
func DisplayPropertiesKHRMakeCSlice(x ...DisplayPropertiesKHR) []DisplayPropertiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPropertiesKHR * len(x)
	dst := unsafe.Slice((*DisplayPropertiesKHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Display returns the value of display from VkDisplayPropertiesKHR
func (x DisplayPropertiesKHR) Display() DisplayKHR {
	ptr := /* handle */ (*DisplayKHR)(&x.display)
	return *ptr
}

// DisplayName returns the value of displayName from VkDisplayPropertiesKHR
func (x DisplayPropertiesKHR) DisplayName() *byte {
	ptr := func(x **C.char) **byte { /* Pointer */ return (**byte)(unsafe.Pointer(x)) }(&x.displayName)
	return *ptr
}

// PhysicalDimensions returns the value of physicalDimensions from VkDisplayPropertiesKHR
func (x DisplayPropertiesKHR) PhysicalDimensions() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.physicalDimensions)
	return *ptr
}

// PhysicalResolution returns the value of physicalResolution from VkDisplayPropertiesKHR
func (x DisplayPropertiesKHR) PhysicalResolution() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.physicalResolution)
	return *ptr
}

// SupportedTransforms returns the value of supportedTransforms from VkDisplayPropertiesKHR
func (x DisplayPropertiesKHR) SupportedTransforms() SurfaceTransformFlagsKHR {
	ptr := /* typedef */ (*SurfaceTransformFlagsKHR)(&x.supportedTransforms)
	return *ptr
}

// PlaneReorderPossible returns the value of planeReorderPossible from VkDisplayPropertiesKHR
func (x DisplayPropertiesKHR) PlaneReorderPossible() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.planeReorderPossible)
	return *ptr
}

// PersistentContent returns the value of persistentContent from VkDisplayPropertiesKHR
func (x DisplayPropertiesKHR) PersistentContent() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.persistentContent)
	return *ptr
}

// DisplayPlanePropertiesKHR provides a go interface for VkDisplayPlanePropertiesKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlanePropertiesKHR.html
type DisplayPlanePropertiesKHR C.struct_VkDisplayPlanePropertiesKHR

// SizeofDisplayPlanePropertiesKHR is the memory size of a DisplayPlanePropertiesKHR
var SizeofDisplayPlanePropertiesKHR int = int(unsafe.Sizeof(DisplayPlanePropertiesKHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DisplayPlanePropertiesKHR) ArpPtr(arp *AutoReleasePool) *DisplayPlanePropertiesKHR {
	ptr := newCBlock(cULong(SizeofDisplayPlanePropertiesKHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DisplayPlanePropertiesKHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayPlanePropertiesKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayPlanePropertiesKHR) AsCPtr() *DisplayPlanePropertiesKHR {
	clone := (*DisplayPlanePropertiesKHR)(newCBlock(cULong(SizeofDisplayPlanePropertiesKHR)))
	*clone = x
	return clone
}

// DisplayPlanePropertiesKHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DisplayPlanePropertiesKHRCSlice(arp *AutoReleasePool, x ...DisplayPlanePropertiesKHR) []DisplayPlanePropertiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPlanePropertiesKHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DisplayPlanePropertiesKHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DisplayPlanePropertiesKHRFreeCSlice releases the memory allocated by DisplayPlanePropertiesKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayPlanePropertiesKHRFreeCSlice(x []DisplayPlanePropertiesKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayPlanePropertiesKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayPlanePropertiesKHRFreeCSlice must be called on the returned slice.
func DisplayPlanePropertiesKHRMakeCSlice(x ...DisplayPlanePropertiesKHR) []DisplayPlanePropertiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPlanePropertiesKHR * len(x)
	dst := unsafe.Slice((*DisplayPlanePropertiesKHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// CurrentDisplay returns the value of currentDisplay from VkDisplayPlanePropertiesKHR
func (x DisplayPlanePropertiesKHR) CurrentDisplay() DisplayKHR {
	ptr := /* handle */ (*DisplayKHR)(&x.currentDisplay)
	return *ptr
}

// CurrentStackIndex returns the value of currentStackIndex from VkDisplayPlanePropertiesKHR
func (x DisplayPlanePropertiesKHR) CurrentStackIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.currentStackIndex)
	return *ptr
}

// GetPhysicalDeviceDisplayPropertiesKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayPropertiesKHR.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceDisplayPropertiesKHR(pPropertyCount *uint32, pProperties []DisplayPropertiesKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPropertyCount)
	p2 := func(x *[]DisplayPropertiesKHR) **C.struct_VkDisplayPropertiesKHR { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDisplayPropertiesKHR)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDisplayPropertiesKHR)(unsafe.Pointer((&ptr)))
	}(&pProperties)
	ret := C.vkGetPhysicalDeviceDisplayPropertiesKHR(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetDisplayPlaneCapabilitiesKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayPlaneCapabilitiesKHR.html
func (x PhysicalDeviceFacade) GetDisplayPlaneCapabilitiesKHR(mode DisplayModeKHR, planeIndex uint32, pCapabilities *DisplayPlaneCapabilitiesKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* handle */ (*C.VkDisplayModeKHR)(&mode)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&planeIndex)
	p3 := func(x **DisplayPlaneCapabilitiesKHR) **C.struct_VkDisplayPlaneCapabilitiesKHR { /* Pointer */
		g2c := (*C.struct_VkDisplayPlaneCapabilitiesKHR)(*x)
		return &g2c
	}(&pCapabilities)
	ret := C.vkGetDisplayPlaneCapabilitiesKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceDisplayPlanePropertiesKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayPlanePropertiesKHR.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceDisplayPlanePropertiesKHR(pPropertyCount *uint32, pProperties []DisplayPlanePropertiesKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPropertyCount)
	p2 := func(x *[]DisplayPlanePropertiesKHR) **C.struct_VkDisplayPlanePropertiesKHR { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDisplayPlanePropertiesKHR)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDisplayPlanePropertiesKHR)(unsafe.Pointer((&ptr)))
	}(&pProperties)
	ret := C.vkGetPhysicalDeviceDisplayPlanePropertiesKHR(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CreateDisplayModeKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDisplayModeKHR.html
func (x PhysicalDeviceFacade) CreateDisplayModeKHR(display DisplayKHR, pCreateInfo *DisplayModeCreateInfoKHR, pAllocator *AllocationCallbacks, pMode *DisplayModeKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* handle */ (*C.VkDisplayKHR)(&display)
	p2 := func(x **DisplayModeCreateInfoKHR) **C.struct_VkDisplayModeCreateInfoKHR { /* Pointer */
		g2c := (*C.struct_VkDisplayModeCreateInfoKHR)(*x)
		return &g2c
	}(&pCreateInfo)
	p3 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p4 := func(x **DisplayModeKHR) **C.VkDisplayModeKHR { /* Pointer */
		g2c := (*C.VkDisplayModeKHR)(*x)
		return &g2c
	}(&pMode)
	ret := C.vkCreateDisplayModeKHR(addrs, *p0, *p1, *p2, *p3, *p4)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetDisplayModePropertiesKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayModePropertiesKHR.html
func (x PhysicalDeviceFacade) GetDisplayModePropertiesKHR(display DisplayKHR, pPropertyCount *uint32, pProperties []DisplayModePropertiesKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* handle */ (*C.VkDisplayKHR)(&display)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPropertyCount)
	p3 := func(x *[]DisplayModePropertiesKHR) **C.struct_VkDisplayModePropertiesKHR { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDisplayModePropertiesKHR)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDisplayModePropertiesKHR)(unsafe.Pointer((&ptr)))
	}(&pProperties)
	ret := C.vkGetDisplayModePropertiesKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CreateDisplayPlaneSurfaceKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDisplayPlaneSurfaceKHR.html
func (x InstanceFacade) CreateDisplayPlaneSurfaceKHR(pCreateInfo *DisplaySurfaceCreateInfoKHR, pAllocator *AllocationCallbacks, pSurface *SurfaceKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkInstance)(&x.H)
	p1 := func(x **DisplaySurfaceCreateInfoKHR) **C.struct_VkDisplaySurfaceCreateInfoKHR { /* Pointer */
		g2c := (*C.struct_VkDisplaySurfaceCreateInfoKHR)(*x)
		return &g2c
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p3 := func(x **SurfaceKHR) **C.VkSurfaceKHR { /* Pointer */ g2c := (*C.VkSurfaceKHR)(*x); return &g2c }(&pSurface)
	ret := C.vkCreateDisplayPlaneSurfaceKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetDisplayPlaneSupportedDisplaysKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayPlaneSupportedDisplaysKHR.html
func (x PhysicalDeviceFacade) GetDisplayPlaneSupportedDisplaysKHR(planeIndex uint32, pDisplayCount *uint32, pDisplays []DisplayKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&planeIndex)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pDisplayCount)
	p3 := func(x *[]DisplayKHR) **C.VkDisplayKHR { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkDisplayKHR)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkDisplayKHR)(unsafe.Pointer((&ptr)))
	}(&pDisplays)
	ret := C.vkGetDisplayPlaneSupportedDisplaysKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DisplayPlaneCapabilities2KHR provides a go interface for VkDisplayPlaneCapabilities2KHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlaneCapabilities2KHR.html
type DisplayPlaneCapabilities2KHR C.struct_VkDisplayPlaneCapabilities2KHR

// SizeofDisplayPlaneCapabilities2KHR is the memory size of a DisplayPlaneCapabilities2KHR
var SizeofDisplayPlaneCapabilities2KHR int = int(unsafe.Sizeof(DisplayPlaneCapabilities2KHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DisplayPlaneCapabilities2KHR) ArpPtr(arp *AutoReleasePool) *DisplayPlaneCapabilities2KHR {
	ptr := newCBlock(cULong(SizeofDisplayPlaneCapabilities2KHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DisplayPlaneCapabilities2KHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayPlaneCapabilities2KHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayPlaneCapabilities2KHR) AsCPtr() *DisplayPlaneCapabilities2KHR {
	clone := (*DisplayPlaneCapabilities2KHR)(newCBlock(cULong(SizeofDisplayPlaneCapabilities2KHR)))
	*clone = x
	return clone
}

// DisplayPlaneCapabilities2KHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DisplayPlaneCapabilities2KHRCSlice(arp *AutoReleasePool, x ...DisplayPlaneCapabilities2KHR) []DisplayPlaneCapabilities2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPlaneCapabilities2KHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DisplayPlaneCapabilities2KHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DisplayPlaneCapabilities2KHRFreeCSlice releases the memory allocated by DisplayPlaneCapabilities2KHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayPlaneCapabilities2KHRFreeCSlice(x []DisplayPlaneCapabilities2KHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayPlaneCapabilities2KHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayPlaneCapabilities2KHRFreeCSlice must be called on the returned slice.
func DisplayPlaneCapabilities2KHRMakeCSlice(x ...DisplayPlaneCapabilities2KHR) []DisplayPlaneCapabilities2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPlaneCapabilities2KHR * len(x)
	dst := unsafe.Slice((*DisplayPlaneCapabilities2KHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDisplayPlaneCapabilities2KHR
func (x DisplayPlaneCapabilities2KHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DisplayPlaneCapabilities2KHR with the value of
// SType to the value provided in the specification.
func (x DisplayPlaneCapabilities2KHR) WithDefaultSType() DisplayPlaneCapabilities2KHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DisplayPlaneCapabilities2KHR) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR)
}

// WithSType clones a new DisplayPlaneCapabilities2KHR with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPlaneCapabilities2KHR) WithSType(y StructureType) DisplayPlaneCapabilities2KHR {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DisplayPlaneCapabilities2KHR) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDisplayPlaneCapabilities2KHR
func (x DisplayPlaneCapabilities2KHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DisplayPlaneCapabilities2KHR with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPlaneCapabilities2KHR) WithPNext(y unsafe.Pointer) DisplayPlaneCapabilities2KHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DisplayPlaneCapabilities2KHR) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Capabilities returns the value of capabilities from VkDisplayPlaneCapabilities2KHR
func (x DisplayPlaneCapabilities2KHR) Capabilities() DisplayPlaneCapabilitiesKHR {
	ptr := /* typedef */ (*DisplayPlaneCapabilitiesKHR)(&x.capabilities)
	return *ptr
}

// DisplayPlaneProperties2KHR provides a go interface for VkDisplayPlaneProperties2KHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlaneProperties2KHR.html
type DisplayPlaneProperties2KHR C.struct_VkDisplayPlaneProperties2KHR

// SizeofDisplayPlaneProperties2KHR is the memory size of a DisplayPlaneProperties2KHR
var SizeofDisplayPlaneProperties2KHR int = int(unsafe.Sizeof(DisplayPlaneProperties2KHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DisplayPlaneProperties2KHR) ArpPtr(arp *AutoReleasePool) *DisplayPlaneProperties2KHR {
	ptr := newCBlock(cULong(SizeofDisplayPlaneProperties2KHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DisplayPlaneProperties2KHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayPlaneProperties2KHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayPlaneProperties2KHR) AsCPtr() *DisplayPlaneProperties2KHR {
	clone := (*DisplayPlaneProperties2KHR)(newCBlock(cULong(SizeofDisplayPlaneProperties2KHR)))
	*clone = x
	return clone
}

// DisplayPlaneProperties2KHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DisplayPlaneProperties2KHRCSlice(arp *AutoReleasePool, x ...DisplayPlaneProperties2KHR) []DisplayPlaneProperties2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPlaneProperties2KHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DisplayPlaneProperties2KHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DisplayPlaneProperties2KHRFreeCSlice releases the memory allocated by DisplayPlaneProperties2KHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayPlaneProperties2KHRFreeCSlice(x []DisplayPlaneProperties2KHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayPlaneProperties2KHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayPlaneProperties2KHRFreeCSlice must be called on the returned slice.
func DisplayPlaneProperties2KHRMakeCSlice(x ...DisplayPlaneProperties2KHR) []DisplayPlaneProperties2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPlaneProperties2KHR * len(x)
	dst := unsafe.Slice((*DisplayPlaneProperties2KHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDisplayPlaneProperties2KHR
func (x DisplayPlaneProperties2KHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DisplayPlaneProperties2KHR with the value of
// SType to the value provided in the specification.
func (x DisplayPlaneProperties2KHR) WithDefaultSType() DisplayPlaneProperties2KHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DisplayPlaneProperties2KHR) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR)
}

// WithSType clones a new DisplayPlaneProperties2KHR with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPlaneProperties2KHR) WithSType(y StructureType) DisplayPlaneProperties2KHR {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DisplayPlaneProperties2KHR) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDisplayPlaneProperties2KHR
func (x DisplayPlaneProperties2KHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DisplayPlaneProperties2KHR with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPlaneProperties2KHR) WithPNext(y unsafe.Pointer) DisplayPlaneProperties2KHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DisplayPlaneProperties2KHR) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// DisplayPlaneProperties returns the value of displayPlaneProperties from VkDisplayPlaneProperties2KHR
func (x DisplayPlaneProperties2KHR) DisplayPlaneProperties() DisplayPlanePropertiesKHR {
	ptr := /* typedef */ (*DisplayPlanePropertiesKHR)(&x.displayPlaneProperties)
	return *ptr
}

// DisplayPlaneInfo2KHR provides a go interface for VkDisplayPlaneInfo2KHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlaneInfo2KHR.html
type DisplayPlaneInfo2KHR C.struct_VkDisplayPlaneInfo2KHR

// SizeofDisplayPlaneInfo2KHR is the memory size of a DisplayPlaneInfo2KHR
var SizeofDisplayPlaneInfo2KHR int = int(unsafe.Sizeof(DisplayPlaneInfo2KHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DisplayPlaneInfo2KHR) ArpPtr(arp *AutoReleasePool) *DisplayPlaneInfo2KHR {
	ptr := newCBlock(cULong(SizeofDisplayPlaneInfo2KHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DisplayPlaneInfo2KHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayPlaneInfo2KHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayPlaneInfo2KHR) AsCPtr() *DisplayPlaneInfo2KHR {
	clone := (*DisplayPlaneInfo2KHR)(newCBlock(cULong(SizeofDisplayPlaneInfo2KHR)))
	*clone = x
	return clone
}

// DisplayPlaneInfo2KHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DisplayPlaneInfo2KHRCSlice(arp *AutoReleasePool, x ...DisplayPlaneInfo2KHR) []DisplayPlaneInfo2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPlaneInfo2KHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DisplayPlaneInfo2KHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DisplayPlaneInfo2KHRFreeCSlice releases the memory allocated by DisplayPlaneInfo2KHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayPlaneInfo2KHRFreeCSlice(x []DisplayPlaneInfo2KHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayPlaneInfo2KHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayPlaneInfo2KHRFreeCSlice must be called on the returned slice.
func DisplayPlaneInfo2KHRMakeCSlice(x ...DisplayPlaneInfo2KHR) []DisplayPlaneInfo2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPlaneInfo2KHR * len(x)
	dst := unsafe.Slice((*DisplayPlaneInfo2KHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDisplayPlaneInfo2KHR
func (x DisplayPlaneInfo2KHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DisplayPlaneInfo2KHR with the value of
// SType to the value provided in the specification.
func (x DisplayPlaneInfo2KHR) WithDefaultSType() DisplayPlaneInfo2KHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DisplayPlaneInfo2KHR) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR)
}

// WithSType clones a new DisplayPlaneInfo2KHR with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPlaneInfo2KHR) WithSType(y StructureType) DisplayPlaneInfo2KHR {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DisplayPlaneInfo2KHR) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDisplayPlaneInfo2KHR
func (x DisplayPlaneInfo2KHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DisplayPlaneInfo2KHR with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPlaneInfo2KHR) WithPNext(y unsafe.Pointer) DisplayPlaneInfo2KHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DisplayPlaneInfo2KHR) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// Mode returns the value of mode from VkDisplayPlaneInfo2KHR
func (x DisplayPlaneInfo2KHR) Mode() DisplayModeKHR {
	ptr := /* handle */ (*DisplayModeKHR)(&x.mode)
	return *ptr
}

// WithMode clones a new DisplayPlaneInfo2KHR with the value of
// Mode updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPlaneInfo2KHR) WithMode(y DisplayModeKHR) DisplayPlaneInfo2KHR {
	x.mode = *( /* handle */ (*C.VkDisplayModeKHR)(&y))
	return x
}
func (x *DisplayPlaneInfo2KHR) SetMode(y DisplayModeKHR) {
	x.mode = *( /* handle */ (*C.VkDisplayModeKHR)(&y))
}

// PlaneIndex returns the value of planeIndex from VkDisplayPlaneInfo2KHR
func (x DisplayPlaneInfo2KHR) PlaneIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.planeIndex)
	return *ptr
}

// WithPlaneIndex clones a new DisplayPlaneInfo2KHR with the value of
// PlaneIndex updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPlaneInfo2KHR) WithPlaneIndex(y uint32) DisplayPlaneInfo2KHR {
	x.planeIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *DisplayPlaneInfo2KHR) SetPlaneIndex(y uint32) {
	x.planeIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

// DisplayProperties2KHR provides a go interface for VkDisplayProperties2KHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayProperties2KHR.html
type DisplayProperties2KHR C.struct_VkDisplayProperties2KHR

// SizeofDisplayProperties2KHR is the memory size of a DisplayProperties2KHR
var SizeofDisplayProperties2KHR int = int(unsafe.Sizeof(DisplayProperties2KHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DisplayProperties2KHR) ArpPtr(arp *AutoReleasePool) *DisplayProperties2KHR {
	ptr := newCBlock(cULong(SizeofDisplayProperties2KHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DisplayProperties2KHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayProperties2KHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayProperties2KHR) AsCPtr() *DisplayProperties2KHR {
	clone := (*DisplayProperties2KHR)(newCBlock(cULong(SizeofDisplayProperties2KHR)))
	*clone = x
	return clone
}

// DisplayProperties2KHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DisplayProperties2KHRCSlice(arp *AutoReleasePool, x ...DisplayProperties2KHR) []DisplayProperties2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayProperties2KHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DisplayProperties2KHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DisplayProperties2KHRFreeCSlice releases the memory allocated by DisplayProperties2KHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayProperties2KHRFreeCSlice(x []DisplayProperties2KHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayProperties2KHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayProperties2KHRFreeCSlice must be called on the returned slice.
func DisplayProperties2KHRMakeCSlice(x ...DisplayProperties2KHR) []DisplayProperties2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayProperties2KHR * len(x)
	dst := unsafe.Slice((*DisplayProperties2KHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDisplayProperties2KHR
func (x DisplayProperties2KHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DisplayProperties2KHR with the value of
// SType to the value provided in the specification.
func (x DisplayProperties2KHR) WithDefaultSType() DisplayProperties2KHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DisplayProperties2KHR) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR)
}

// WithSType clones a new DisplayProperties2KHR with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayProperties2KHR) WithSType(y StructureType) DisplayProperties2KHR {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DisplayProperties2KHR) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDisplayProperties2KHR
func (x DisplayProperties2KHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DisplayProperties2KHR with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayProperties2KHR) WithPNext(y unsafe.Pointer) DisplayProperties2KHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DisplayProperties2KHR) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// DisplayProperties returns the value of displayProperties from VkDisplayProperties2KHR
func (x DisplayProperties2KHR) DisplayProperties() DisplayPropertiesKHR {
	ptr := /* typedef */ (*DisplayPropertiesKHR)(&x.displayProperties)
	return *ptr
}

// DisplayModeProperties2KHR provides a go interface for VkDisplayModeProperties2KHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModeProperties2KHR.html
type DisplayModeProperties2KHR C.struct_VkDisplayModeProperties2KHR

// SizeofDisplayModeProperties2KHR is the memory size of a DisplayModeProperties2KHR
var SizeofDisplayModeProperties2KHR int = int(unsafe.Sizeof(DisplayModeProperties2KHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DisplayModeProperties2KHR) ArpPtr(arp *AutoReleasePool) *DisplayModeProperties2KHR {
	ptr := newCBlock(cULong(SizeofDisplayModeProperties2KHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DisplayModeProperties2KHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayModeProperties2KHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayModeProperties2KHR) AsCPtr() *DisplayModeProperties2KHR {
	clone := (*DisplayModeProperties2KHR)(newCBlock(cULong(SizeofDisplayModeProperties2KHR)))
	*clone = x
	return clone
}

// DisplayModeProperties2KHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DisplayModeProperties2KHRCSlice(arp *AutoReleasePool, x ...DisplayModeProperties2KHR) []DisplayModeProperties2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayModeProperties2KHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DisplayModeProperties2KHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DisplayModeProperties2KHRFreeCSlice releases the memory allocated by DisplayModeProperties2KHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayModeProperties2KHRFreeCSlice(x []DisplayModeProperties2KHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayModeProperties2KHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayModeProperties2KHRFreeCSlice must be called on the returned slice.
func DisplayModeProperties2KHRMakeCSlice(x ...DisplayModeProperties2KHR) []DisplayModeProperties2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayModeProperties2KHR * len(x)
	dst := unsafe.Slice((*DisplayModeProperties2KHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDisplayModeProperties2KHR
func (x DisplayModeProperties2KHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DisplayModeProperties2KHR with the value of
// SType to the value provided in the specification.
func (x DisplayModeProperties2KHR) WithDefaultSType() DisplayModeProperties2KHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DisplayModeProperties2KHR) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR)
}

// WithSType clones a new DisplayModeProperties2KHR with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayModeProperties2KHR) WithSType(y StructureType) DisplayModeProperties2KHR {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DisplayModeProperties2KHR) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDisplayModeProperties2KHR
func (x DisplayModeProperties2KHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DisplayModeProperties2KHR with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayModeProperties2KHR) WithPNext(y unsafe.Pointer) DisplayModeProperties2KHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DisplayModeProperties2KHR) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// DisplayModeProperties returns the value of displayModeProperties from VkDisplayModeProperties2KHR
func (x DisplayModeProperties2KHR) DisplayModeProperties() DisplayModePropertiesKHR {
	ptr := /* typedef */ (*DisplayModePropertiesKHR)(&x.displayModeProperties)
	return *ptr
}

// GetPhysicalDeviceDisplayPlaneProperties2KHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayPlaneProperties2KHR.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceDisplayPlaneProperties2KHR(pPropertyCount *uint32, pProperties []DisplayPlaneProperties2KHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPropertyCount)
	p2 := func(x *[]DisplayPlaneProperties2KHR) **C.struct_VkDisplayPlaneProperties2KHR { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDisplayPlaneProperties2KHR)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDisplayPlaneProperties2KHR)(unsafe.Pointer((&ptr)))
	}(&pProperties)
	ret := C.vkGetPhysicalDeviceDisplayPlaneProperties2KHR(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceDisplayProperties2KHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayProperties2KHR.html
func (x PhysicalDeviceFacade) GetPhysicalDeviceDisplayProperties2KHR(pPropertyCount *uint32, pProperties []DisplayProperties2KHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPropertyCount)
	p2 := func(x *[]DisplayProperties2KHR) **C.struct_VkDisplayProperties2KHR { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDisplayProperties2KHR)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDisplayProperties2KHR)(unsafe.Pointer((&ptr)))
	}(&pProperties)
	ret := C.vkGetPhysicalDeviceDisplayProperties2KHR(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetDisplayPlaneCapabilities2KHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayPlaneCapabilities2KHR.html
func (x PhysicalDeviceFacade) GetDisplayPlaneCapabilities2KHR(pDisplayPlaneInfo *DisplayPlaneInfo2KHR, pCapabilities *DisplayPlaneCapabilities2KHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **DisplayPlaneInfo2KHR) **C.struct_VkDisplayPlaneInfo2KHR { /* Pointer */
		g2c := (*C.struct_VkDisplayPlaneInfo2KHR)(*x)
		return &g2c
	}(&pDisplayPlaneInfo)
	p2 := func(x **DisplayPlaneCapabilities2KHR) **C.struct_VkDisplayPlaneCapabilities2KHR { /* Pointer */
		g2c := (*C.struct_VkDisplayPlaneCapabilities2KHR)(*x)
		return &g2c
	}(&pCapabilities)
	ret := C.vkGetDisplayPlaneCapabilities2KHR(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetDisplayModeProperties2KHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayModeProperties2KHR.html
func (x PhysicalDeviceFacade) GetDisplayModeProperties2KHR(display DisplayKHR, pPropertyCount *uint32, pProperties []DisplayModeProperties2KHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* handle */ (*C.VkDisplayKHR)(&display)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPropertyCount)
	p3 := func(x *[]DisplayModeProperties2KHR) **C.struct_VkDisplayModeProperties2KHR { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDisplayModeProperties2KHR)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDisplayModeProperties2KHR)(unsafe.Pointer((&ptr)))
	}(&pProperties)
	ret := C.vkGetDisplayModeProperties2KHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DisplayPresentInfoKHR provides a go interface for VkDisplayPresentInfoKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPresentInfoKHR.html
type DisplayPresentInfoKHR C.struct_VkDisplayPresentInfoKHR

// SizeofDisplayPresentInfoKHR is the memory size of a DisplayPresentInfoKHR
var SizeofDisplayPresentInfoKHR int = int(unsafe.Sizeof(DisplayPresentInfoKHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x DisplayPresentInfoKHR) ArpPtr(arp *AutoReleasePool) *DisplayPresentInfoKHR {
	ptr := newCBlock(cULong(SizeofDisplayPresentInfoKHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*DisplayPresentInfoKHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayPresentInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayPresentInfoKHR) AsCPtr() *DisplayPresentInfoKHR {
	clone := (*DisplayPresentInfoKHR)(newCBlock(cULong(SizeofDisplayPresentInfoKHR)))
	*clone = x
	return clone
}

// DisplayPresentInfoKHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func DisplayPresentInfoKHRCSlice(arp *AutoReleasePool, x ...DisplayPresentInfoKHR) []DisplayPresentInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPresentInfoKHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*DisplayPresentInfoKHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// DisplayPresentInfoKHRFreeCSlice releases the memory allocated by DisplayPresentInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayPresentInfoKHRFreeCSlice(x []DisplayPresentInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayPresentInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayPresentInfoKHRFreeCSlice must be called on the returned slice.
func DisplayPresentInfoKHRMakeCSlice(x ...DisplayPresentInfoKHR) []DisplayPresentInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPresentInfoKHR * len(x)
	dst := unsafe.Slice((*DisplayPresentInfoKHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDisplayPresentInfoKHR
func (x DisplayPresentInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new DisplayPresentInfoKHR with the value of
// SType to the value provided in the specification.
func (x DisplayPresentInfoKHR) WithDefaultSType() DisplayPresentInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *DisplayPresentInfoKHR) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR)
}

// WithSType clones a new DisplayPresentInfoKHR with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPresentInfoKHR) WithSType(y StructureType) DisplayPresentInfoKHR {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *DisplayPresentInfoKHR) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkDisplayPresentInfoKHR
func (x DisplayPresentInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new DisplayPresentInfoKHR with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPresentInfoKHR) WithPNext(y unsafe.Pointer) DisplayPresentInfoKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *DisplayPresentInfoKHR) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// SrcRect returns the value of srcRect from VkDisplayPresentInfoKHR
func (x DisplayPresentInfoKHR) SrcRect() Rect2D {
	ptr := /* typedef */ (*Rect2D)(&x.srcRect)
	return *ptr
}

// WithSrcRect clones a new DisplayPresentInfoKHR with the value of
// SrcRect updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPresentInfoKHR) WithSrcRect(y Rect2D) DisplayPresentInfoKHR {
	x.srcRect = *( /* typedef */ (*C.struct_VkRect2D)(&y))
	return x
}
func (x *DisplayPresentInfoKHR) SetSrcRect(y Rect2D) {
	x.srcRect = *( /* typedef */ (*C.struct_VkRect2D)(&y))
}

// DstRect returns the value of dstRect from VkDisplayPresentInfoKHR
func (x DisplayPresentInfoKHR) DstRect() Rect2D {
	ptr := /* typedef */ (*Rect2D)(&x.dstRect)
	return *ptr
}

// WithDstRect clones a new DisplayPresentInfoKHR with the value of
// DstRect updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPresentInfoKHR) WithDstRect(y Rect2D) DisplayPresentInfoKHR {
	x.dstRect = *( /* typedef */ (*C.struct_VkRect2D)(&y))
	return x
}
func (x *DisplayPresentInfoKHR) SetDstRect(y Rect2D) {
	x.dstRect = *( /* typedef */ (*C.struct_VkRect2D)(&y))
}

// Persistent returns the value of persistent from VkDisplayPresentInfoKHR
func (x DisplayPresentInfoKHR) Persistent() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.persistent)
	return *ptr
}

// WithPersistent clones a new DisplayPresentInfoKHR with the value of
// Persistent updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPresentInfoKHR) WithPersistent(y Bool32) DisplayPresentInfoKHR {
	x.persistent = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *DisplayPresentInfoKHR) SetPersistent(y Bool32) {
	x.persistent = *( /* typedef */ (*C.VkBool32)(&y))
}

// CreateSharedSwapchainsKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSharedSwapchainsKHR.html
func (x DeviceFacade) CreateSharedSwapchainsKHR(swapchainCount uint32, pCreateInfos []SwapchainCreateInfoKHR, pAllocator *AllocationCallbacks, pSwapchains []SwapchainKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&swapchainCount)
	p2 := func(x *[]SwapchainCreateInfoKHR) **C.struct_VkSwapchainCreateInfoKHR { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSwapchainCreateInfoKHR)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSwapchainCreateInfoKHR)(unsafe.Pointer((&ptr)))
	}(&pCreateInfos)
	p3 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		g2c := (*C.struct_VkAllocationCallbacks)(*x)
		return &g2c
	}(&pAllocator)
	p4 := func(x *[]SwapchainKHR) **C.VkSwapchainKHR { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSwapchainKHR)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSwapchainKHR)(unsafe.Pointer((&ptr)))
	}(&pSwapchains)
	ret := C.vkCreateSharedSwapchainsKHR(addrs, *p0, *p1, *p2, *p3, *p4)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// FormatFeatureFlagBits2KHR enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatFeatureFlagBits2KHR.html
type FormatFeatureFlagBits2KHR uint32

// FormatFeatureFlags2KHR bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatFeatureFlags2KHR.html
type FormatFeatureFlags2KHR uint32

// FormatProperties3KHR is an alias to FormatProperties3.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatProperties3KHR.html
//
// Deprecated: Most Aliases in the Vulkan spec are for compatibility purposes as extensions get
// promoted to features. If possible, update code to use the promoted name: FormatProperties3.
type FormatProperties3KHR = FormatProperties3

// PhysicalDevicePortabilitySubsetFeaturesKHR provides a go interface for VkPhysicalDevicePortabilitySubsetFeaturesKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html
type PhysicalDevicePortabilitySubsetFeaturesKHR C.struct_VkPhysicalDevicePortabilitySubsetFeaturesKHR

// SizeofPhysicalDevicePortabilitySubsetFeaturesKHR is the memory size of a PhysicalDevicePortabilitySubsetFeaturesKHR
var SizeofPhysicalDevicePortabilitySubsetFeaturesKHR int = int(unsafe.Sizeof(PhysicalDevicePortabilitySubsetFeaturesKHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) ArpPtr(arp *AutoReleasePool) *PhysicalDevicePortabilitySubsetFeaturesKHR {
	ptr := newCBlock(cULong(SizeofPhysicalDevicePortabilitySubsetFeaturesKHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDevicePortabilitySubsetFeaturesKHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDevicePortabilitySubsetFeaturesKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) AsCPtr() *PhysicalDevicePortabilitySubsetFeaturesKHR {
	clone := (*PhysicalDevicePortabilitySubsetFeaturesKHR)(newCBlock(cULong(SizeofPhysicalDevicePortabilitySubsetFeaturesKHR)))
	*clone = x
	return clone
}

// PhysicalDevicePortabilitySubsetFeaturesKHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDevicePortabilitySubsetFeaturesKHRCSlice(arp *AutoReleasePool, x ...PhysicalDevicePortabilitySubsetFeaturesKHR) []PhysicalDevicePortabilitySubsetFeaturesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDevicePortabilitySubsetFeaturesKHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDevicePortabilitySubsetFeaturesKHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDevicePortabilitySubsetFeaturesKHRFreeCSlice releases the memory allocated by PhysicalDevicePortabilitySubsetFeaturesKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDevicePortabilitySubsetFeaturesKHRFreeCSlice(x []PhysicalDevicePortabilitySubsetFeaturesKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDevicePortabilitySubsetFeaturesKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDevicePortabilitySubsetFeaturesKHRFreeCSlice must be called on the returned slice.
func PhysicalDevicePortabilitySubsetFeaturesKHRMakeCSlice(x ...PhysicalDevicePortabilitySubsetFeaturesKHR) []PhysicalDevicePortabilitySubsetFeaturesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDevicePortabilitySubsetFeaturesKHR * len(x)
	dst := unsafe.Slice((*PhysicalDevicePortabilitySubsetFeaturesKHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDevicePortabilitySubsetFeaturesKHR with the value of
// SType to the value provided in the specification.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithDefaultSType() PhysicalDevicePortabilitySubsetFeaturesKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDevicePortabilitySubsetFeaturesKHR) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR)
}

// WithSType clones a new PhysicalDevicePortabilitySubsetFeaturesKHR with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithSType(y StructureType) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDevicePortabilitySubsetFeaturesKHR) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDevicePortabilitySubsetFeaturesKHR with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithPNext(y unsafe.Pointer) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDevicePortabilitySubsetFeaturesKHR) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// ConstantAlphaColorBlendFactors returns the value of constantAlphaColorBlendFactors from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) ConstantAlphaColorBlendFactors() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.constantAlphaColorBlendFactors)
	return *ptr
}

// WithConstantAlphaColorBlendFactors clones a new PhysicalDevicePortabilitySubsetFeaturesKHR with the value of
// ConstantAlphaColorBlendFactors updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithConstantAlphaColorBlendFactors(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.constantAlphaColorBlendFactors = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDevicePortabilitySubsetFeaturesKHR) SetConstantAlphaColorBlendFactors(y Bool32) {
	x.constantAlphaColorBlendFactors = *( /* typedef */ (*C.VkBool32)(&y))
}

// Events returns the value of events from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) Events() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.events)
	return *ptr
}

// WithEvents clones a new PhysicalDevicePortabilitySubsetFeaturesKHR with the value of
// Events updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithEvents(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.events = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDevicePortabilitySubsetFeaturesKHR) SetEvents(y Bool32) {
	x.events = *( /* typedef */ (*C.VkBool32)(&y))
}

// ImageViewFormatReinterpretation returns the value of imageViewFormatReinterpretation from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) ImageViewFormatReinterpretation() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.imageViewFormatReinterpretation)
	return *ptr
}

// WithImageViewFormatReinterpretation clones a new PhysicalDevicePortabilitySubsetFeaturesKHR with the value of
// ImageViewFormatReinterpretation updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithImageViewFormatReinterpretation(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.imageViewFormatReinterpretation = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDevicePortabilitySubsetFeaturesKHR) SetImageViewFormatReinterpretation(y Bool32) {
	x.imageViewFormatReinterpretation = *( /* typedef */ (*C.VkBool32)(&y))
}

// ImageViewFormatSwizzle returns the value of imageViewFormatSwizzle from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) ImageViewFormatSwizzle() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.imageViewFormatSwizzle)
	return *ptr
}

// WithImageViewFormatSwizzle clones a new PhysicalDevicePortabilitySubsetFeaturesKHR with the value of
// ImageViewFormatSwizzle updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithImageViewFormatSwizzle(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.imageViewFormatSwizzle = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDevicePortabilitySubsetFeaturesKHR) SetImageViewFormatSwizzle(y Bool32) {
	x.imageViewFormatSwizzle = *( /* typedef */ (*C.VkBool32)(&y))
}

// ImageView2DOn3DImage returns the value of imageView2DOn3DImage from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) ImageView2DOn3DImage() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.imageView2DOn3DImage)
	return *ptr
}

// WithImageView2DOn3DImage clones a new PhysicalDevicePortabilitySubsetFeaturesKHR with the value of
// ImageView2DOn3DImage updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithImageView2DOn3DImage(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.imageView2DOn3DImage = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDevicePortabilitySubsetFeaturesKHR) SetImageView2DOn3DImage(y Bool32) {
	x.imageView2DOn3DImage = *( /* typedef */ (*C.VkBool32)(&y))
}

// MultisampleArrayImage returns the value of multisampleArrayImage from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) MultisampleArrayImage() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.multisampleArrayImage)
	return *ptr
}

// WithMultisampleArrayImage clones a new PhysicalDevicePortabilitySubsetFeaturesKHR with the value of
// MultisampleArrayImage updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithMultisampleArrayImage(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.multisampleArrayImage = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDevicePortabilitySubsetFeaturesKHR) SetMultisampleArrayImage(y Bool32) {
	x.multisampleArrayImage = *( /* typedef */ (*C.VkBool32)(&y))
}

// MutableComparisonSamplers returns the value of mutableComparisonSamplers from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) MutableComparisonSamplers() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.mutableComparisonSamplers)
	return *ptr
}

// WithMutableComparisonSamplers clones a new PhysicalDevicePortabilitySubsetFeaturesKHR with the value of
// MutableComparisonSamplers updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithMutableComparisonSamplers(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.mutableComparisonSamplers = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDevicePortabilitySubsetFeaturesKHR) SetMutableComparisonSamplers(y Bool32) {
	x.mutableComparisonSamplers = *( /* typedef */ (*C.VkBool32)(&y))
}

// PointPolygons returns the value of pointPolygons from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) PointPolygons() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.pointPolygons)
	return *ptr
}

// WithPointPolygons clones a new PhysicalDevicePortabilitySubsetFeaturesKHR with the value of
// PointPolygons updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithPointPolygons(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.pointPolygons = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDevicePortabilitySubsetFeaturesKHR) SetPointPolygons(y Bool32) {
	x.pointPolygons = *( /* typedef */ (*C.VkBool32)(&y))
}

// SamplerMipLodBias returns the value of samplerMipLodBias from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) SamplerMipLodBias() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.samplerMipLodBias)
	return *ptr
}

// WithSamplerMipLodBias clones a new PhysicalDevicePortabilitySubsetFeaturesKHR with the value of
// SamplerMipLodBias updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithSamplerMipLodBias(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.samplerMipLodBias = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDevicePortabilitySubsetFeaturesKHR) SetSamplerMipLodBias(y Bool32) {
	x.samplerMipLodBias = *( /* typedef */ (*C.VkBool32)(&y))
}

// SeparateStencilMaskRef returns the value of separateStencilMaskRef from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) SeparateStencilMaskRef() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.separateStencilMaskRef)
	return *ptr
}

// WithSeparateStencilMaskRef clones a new PhysicalDevicePortabilitySubsetFeaturesKHR with the value of
// SeparateStencilMaskRef updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithSeparateStencilMaskRef(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.separateStencilMaskRef = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDevicePortabilitySubsetFeaturesKHR) SetSeparateStencilMaskRef(y Bool32) {
	x.separateStencilMaskRef = *( /* typedef */ (*C.VkBool32)(&y))
}

// ShaderSampleRateInterpolationFunctions returns the value of shaderSampleRateInterpolationFunctions from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) ShaderSampleRateInterpolationFunctions() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSampleRateInterpolationFunctions)
	return *ptr
}

// WithShaderSampleRateInterpolationFunctions clones a new PhysicalDevicePortabilitySubsetFeaturesKHR with the value of
// ShaderSampleRateInterpolationFunctions updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithShaderSampleRateInterpolationFunctions(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.shaderSampleRateInterpolationFunctions = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDevicePortabilitySubsetFeaturesKHR) SetShaderSampleRateInterpolationFunctions(y Bool32) {
	x.shaderSampleRateInterpolationFunctions = *( /* typedef */ (*C.VkBool32)(&y))
}

// TessellationIsolines returns the value of tessellationIsolines from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) TessellationIsolines() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.tessellationIsolines)
	return *ptr
}

// WithTessellationIsolines clones a new PhysicalDevicePortabilitySubsetFeaturesKHR with the value of
// TessellationIsolines updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithTessellationIsolines(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.tessellationIsolines = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDevicePortabilitySubsetFeaturesKHR) SetTessellationIsolines(y Bool32) {
	x.tessellationIsolines = *( /* typedef */ (*C.VkBool32)(&y))
}

// TessellationPointMode returns the value of tessellationPointMode from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) TessellationPointMode() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.tessellationPointMode)
	return *ptr
}

// WithTessellationPointMode clones a new PhysicalDevicePortabilitySubsetFeaturesKHR with the value of
// TessellationPointMode updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithTessellationPointMode(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.tessellationPointMode = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDevicePortabilitySubsetFeaturesKHR) SetTessellationPointMode(y Bool32) {
	x.tessellationPointMode = *( /* typedef */ (*C.VkBool32)(&y))
}

// TriangleFans returns the value of triangleFans from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) TriangleFans() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.triangleFans)
	return *ptr
}

// WithTriangleFans clones a new PhysicalDevicePortabilitySubsetFeaturesKHR with the value of
// TriangleFans updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithTriangleFans(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.triangleFans = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDevicePortabilitySubsetFeaturesKHR) SetTriangleFans(y Bool32) {
	x.triangleFans = *( /* typedef */ (*C.VkBool32)(&y))
}

// VertexAttributeAccessBeyondStride returns the value of vertexAttributeAccessBeyondStride from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) VertexAttributeAccessBeyondStride() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.vertexAttributeAccessBeyondStride)
	return *ptr
}

// WithVertexAttributeAccessBeyondStride clones a new PhysicalDevicePortabilitySubsetFeaturesKHR with the value of
// VertexAttributeAccessBeyondStride updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithVertexAttributeAccessBeyondStride(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.vertexAttributeAccessBeyondStride = *( /* typedef */ (*C.VkBool32)(&y))
	return x
}
func (x *PhysicalDevicePortabilitySubsetFeaturesKHR) SetVertexAttributeAccessBeyondStride(y Bool32) {
	x.vertexAttributeAccessBeyondStride = *( /* typedef */ (*C.VkBool32)(&y))
}

// PhysicalDevicePortabilitySubsetPropertiesKHR provides a go interface for VkPhysicalDevicePortabilitySubsetPropertiesKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePortabilitySubsetPropertiesKHR.html
type PhysicalDevicePortabilitySubsetPropertiesKHR C.struct_VkPhysicalDevicePortabilitySubsetPropertiesKHR

// SizeofPhysicalDevicePortabilitySubsetPropertiesKHR is the memory size of a PhysicalDevicePortabilitySubsetPropertiesKHR
var SizeofPhysicalDevicePortabilitySubsetPropertiesKHR int = int(unsafe.Sizeof(PhysicalDevicePortabilitySubsetPropertiesKHR{}))

// ArpPtr copies the object to the C heap and returns the pointer.  The
// AutoReleasePool is responsible for releasing the C memory.
func (x PhysicalDevicePortabilitySubsetPropertiesKHR) ArpPtr(arp *AutoReleasePool) *PhysicalDevicePortabilitySubsetPropertiesKHR {
	ptr := newCBlock(cULong(SizeofPhysicalDevicePortabilitySubsetPropertiesKHR))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	clone := (*PhysicalDevicePortabilitySubsetPropertiesKHR)(ptr)
	*clone = x
	return clone
}

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDevicePortabilitySubsetPropertiesKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDevicePortabilitySubsetPropertiesKHR) AsCPtr() *PhysicalDevicePortabilitySubsetPropertiesKHR {
	clone := (*PhysicalDevicePortabilitySubsetPropertiesKHR)(newCBlock(cULong(SizeofPhysicalDevicePortabilitySubsetPropertiesKHR)))
	*clone = x
	return clone
}

// PhysicalDevicePortabilitySubsetPropertiesKHRCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. The AutoReleasePool is responsible for releasing the C memory.
func PhysicalDevicePortabilitySubsetPropertiesKHRCSlice(arp *AutoReleasePool, x ...PhysicalDevicePortabilitySubsetPropertiesKHR) []PhysicalDevicePortabilitySubsetPropertiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDevicePortabilitySubsetPropertiesKHR * len(x)
	ptr := newCBlock(cULong(sz))
	if arp != nil {
		arp.Add(cFreer(uintptr(ptr)))
	}
	dst := unsafe.Slice((*PhysicalDevicePortabilitySubsetPropertiesKHR)(ptr), len(x))
	copy(dst, x)
	return dst
}

// PhysicalDevicePortabilitySubsetPropertiesKHRFreeCSlice releases the memory allocated by PhysicalDevicePortabilitySubsetPropertiesKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDevicePortabilitySubsetPropertiesKHRFreeCSlice(x []PhysicalDevicePortabilitySubsetPropertiesKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDevicePortabilitySubsetPropertiesKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDevicePortabilitySubsetPropertiesKHRFreeCSlice must be called on the returned slice.
func PhysicalDevicePortabilitySubsetPropertiesKHRMakeCSlice(x ...PhysicalDevicePortabilitySubsetPropertiesKHR) []PhysicalDevicePortabilitySubsetPropertiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDevicePortabilitySubsetPropertiesKHR * len(x)
	dst := unsafe.Slice((*PhysicalDevicePortabilitySubsetPropertiesKHR)(newCBlock(cULong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDevicePortabilitySubsetPropertiesKHR
func (x PhysicalDevicePortabilitySubsetPropertiesKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType clones a new PhysicalDevicePortabilitySubsetPropertiesKHR with the value of
// SType to the value provided in the specification.
func (x PhysicalDevicePortabilitySubsetPropertiesKHR) WithDefaultSType() PhysicalDevicePortabilitySubsetPropertiesKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR)
}

// SetDefaultSType sets the value of SType to the value provided in the
// specification.
func (x *PhysicalDevicePortabilitySubsetPropertiesKHR) SetDefaultSType() {
	x.SetSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR)
}

// WithSType clones a new PhysicalDevicePortabilitySubsetPropertiesKHR with the value of
// SType updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetPropertiesKHR) WithSType(y StructureType) PhysicalDevicePortabilitySubsetPropertiesKHR {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
	return x
}
func (x *PhysicalDevicePortabilitySubsetPropertiesKHR) SetSType(y StructureType) {
	x.sType = *( /* typedef */ (*C.VkStructureType)(&y))
}

// PNext returns the value of pNext from VkPhysicalDevicePortabilitySubsetPropertiesKHR
func (x PhysicalDevicePortabilitySubsetPropertiesKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext)
	return *ptr
}

// WithPNext clones a new PhysicalDevicePortabilitySubsetPropertiesKHR with the value of
// PNext updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetPropertiesKHR) WithPNext(y unsafe.Pointer) PhysicalDevicePortabilitySubsetPropertiesKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDevicePortabilitySubsetPropertiesKHR) SetPNext(y unsafe.Pointer) {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
}

// MinVertexInputBindingStrideAlignment returns the value of minVertexInputBindingStrideAlignment from VkPhysicalDevicePortabilitySubsetPropertiesKHR
func (x PhysicalDevicePortabilitySubsetPropertiesKHR) MinVertexInputBindingStrideAlignment() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.minVertexInputBindingStrideAlignment)
	return *ptr
}

// WithMinVertexInputBindingStrideAlignment clones a new PhysicalDevicePortabilitySubsetPropertiesKHR with the value of
// MinVertexInputBindingStrideAlignment updated on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetPropertiesKHR) WithMinVertexInputBindingStrideAlignment(y uint32) PhysicalDevicePortabilitySubsetPropertiesKHR {
	x.minVertexInputBindingStrideAlignment = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}
func (x *PhysicalDevicePortabilitySubsetPropertiesKHR) SetMinVertexInputBindingStrideAlignment(y uint32) {
	x.minVertexInputBindingStrideAlignment = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
}

type cULong C.ulong

type cFreer uintptr

func (ptr cFreer) Free() {
	if unsafe.Pointer(ptr) != nil {
		C.free(unsafe.Pointer(ptr))
	}
}

func newCBlock(s cULong) unsafe.Pointer {
	sz := C.ulong(s)
	ptr := C.malloc(sz)
	C.memset(ptr, 0, sz)
	return ptr
}

func nullTerminatedBuffer(s string) *bytes.Buffer {
	var str bytes.Buffer
	var isNullTerminated bool
	for _, c := range ([]byte)(s) {
		if c == 0 {
			isNullTerminated = true
		}
		str.WriteByte(c)
		if isNullTerminated {
			break
		}
	}
	if !isNullTerminated {
		str.WriteByte(0)
	}
	return &str
}
