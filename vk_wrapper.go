package vks

//#cgo LDFLAGS: -lvulkan
//#include <stdlib.h>
//#include <string.h>
//#include "vk_wrapper.h"
import "C"
import (
	"bytes"
	"fmt"
	"unsafe"
)

// Init loads the Vulkan library.
func Init() Result {
	ret := C.vksDynamicLoad()
	ptr := (*Result)(&ret)
	return *ptr
}

// Destroy unloads the Vulkan Library.
func Destroy() {
	C.vksDynamicUnload()
}

// NewCString allocates the provided string on the C heap. FreeCString must be
// called when the string is no longer needed.
func NewCString(s string) *byte {
	b := nullTerminatedBuffer(s).Bytes()
	ptr := C.malloc(C.ulong(len(b)))
	C.memcpy(ptr, unsafe.Pointer(&b[0]), C.ulong(len(b)))
	return (*byte)(ptr)
}

// FreeCString releases the C heap memory allocated by NewCString.
func FreeCString(ptr *byte) {
	if ptr != nil {
		C.free(unsafe.Pointer(ptr))
	}
}

// These are API constants.
const (
	VK_MAX_PHYSICAL_DEVICE_NAME_SIZE                     = 256
	VK_UUID_SIZE                                         = 16
	VK_LUID_SIZE                                         = 8
	VK_LUID_SIZE_KHR                                     = VK_LUID_SIZE
	VK_MAX_EXTENSION_NAME_SIZE                           = 256
	VK_MAX_DESCRIPTION_SIZE                              = 256
	VK_MAX_MEMORY_TYPES                                  = 32
	VK_MAX_MEMORY_HEAPS                                  = 16
	VK_LOD_CLAMP_NONE                                    = 1000.0
	VK_REMAINING_MIP_LEVELS                              = ^uint32(0)
	VK_REMAINING_ARRAY_LAYERS                            = ^uint32(0)
	VK_WHOLE_SIZE                                        = ^uint64(0)
	VK_ATTACHMENT_UNUSED                                 = ^uint32(0)
	VK_TRUE                                              = 1
	VK_FALSE                                             = 0
	VK_QUEUE_FAMILY_IGNORED                              = ^uint32(0)
	VK_QUEUE_FAMILY_EXTERNAL                             = ^uint32(1)
	VK_QUEUE_FAMILY_EXTERNAL_KHR                         = VK_QUEUE_FAMILY_EXTERNAL
	VK_QUEUE_FAMILY_FOREIGN_EXT                          = ^uint32(2)
	VK_SUBPASS_EXTERNAL                                  = ^uint32(0)
	VK_MAX_DEVICE_GROUP_SIZE                             = 32
	VK_MAX_DEVICE_GROUP_SIZE_KHR                         = VK_MAX_DEVICE_GROUP_SIZE
	VK_MAX_DRIVER_NAME_SIZE                              = 256
	VK_MAX_DRIVER_NAME_SIZE_KHR                          = VK_MAX_DRIVER_NAME_SIZE
	VK_MAX_DRIVER_INFO_SIZE                              = 256
	VK_MAX_DRIVER_INFO_SIZE_KHR                          = VK_MAX_DRIVER_INFO_SIZE
	VK_SHADER_UNUSED_KHR                                 = ^uint32(0)
	VK_SHADER_UNUSED_NV                                  = VK_SHADER_UNUSED_KHR
	VK_MAX_GLOBAL_PRIORITY_SIZE_EXT                      = 16
	VK_KHR_SURFACE_SPEC_VERSION                          = 25
	VK_KHR_SURFACE_EXTENSION_NAME                        = "VK_KHR_surface"
	VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION       = 1
	VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME     = "VK_KHR_get_surface_capabilities2"
	VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION   = 1
	VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME = "VK_KHR_surface_protected_capabilities"
	VK_KHR_SWAPCHAIN_SPEC_VERSION                        = 70
	VK_KHR_SWAPCHAIN_EXTENSION_NAME                      = "VK_KHR_swapchain"
	VK_KHR_DISPLAY_SPEC_VERSION                          = 23
	VK_KHR_DISPLAY_EXTENSION_NAME                        = "VK_KHR_display"
	VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION         = 1
	VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME       = "VK_KHR_get_display_properties2"
	VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION                = 10
	VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME              = "VK_KHR_display_swapchain"
	VK_KHR_FORMAT_FEATURE_FLAGS_2_SPEC_VERSION           = 1
	VK_KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME         = "VK_KHR_format_feature_flags2"
	VK_KHR_PORTABILITY_SUBSET_SPEC_VERSION               = 1
	VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME             = "VK_KHR_portability_subset"
)

// Version of the vk specification used to generate this.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VK_API_VERSION.html
const HeaderVersion = 198

// ApiVersion is an implementation of the Vulkan Make Api Version
// defines. See
// https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VK_MAKE_API_VERSION.html
type ApiVersion uint32

// MakeApiVersion creates a Version based on the provided Variant, maJor, miNor,
// and Patch.
func MakeApiVersion(v, j, n, p int) ApiVersion {
	return ApiVersion((uint32(v) << 29) | (uint32(j) << 22) | (uint32(n) << 12) | (uint32(p)))
}

func (v ApiVersion) Major() uint32   { return uint32((v >> 22) & 0x7F) }
func (v ApiVersion) Minor() uint32   { return uint32((v >> 12) & 0x3FF) }
func (v ApiVersion) Patch() uint32   { return uint32(v & 0xFFF) }
func (v ApiVersion) Variant() uint32 { return uint32(v >> 29) }
func (v ApiVersion) String() string {
	return fmt.Sprintf("%d[v.%d.%d.%d.%d]", v, v.Variant(), v.Major(), v.Minor(), v.Patch())
}

var (
	VK_API_VERSION_1_0         ApiVersion = MakeApiVersion(0, 1, 0, 0)
	VK_API_VERSION_1_1         ApiVersion = MakeApiVersion(0, 1, 1, 0)
	VK_API_VERSION_1_2         ApiVersion = MakeApiVersion(0, 1, 2, 0)
	VK_HEADER_VERSION_COMPLETE ApiVersion = MakeApiVersion(0, 1, 2, HeaderVersion)
)

// SampleMask is a base type in the vulkan specification.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSampleMask.html
type SampleMask uint32

// DeviceSize is a base type in the vulkan specification.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDeviceSize.html
type DeviceSize uint64

// DeviceAddress is a base type in the vulkan specification.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDeviceAddress.html
type DeviceAddress uint64

// Bool32 is a base type in the vulkan specification.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBool32.html
type Bool32 uint32

// Flags is a base type in the vulkan specification.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFlags.html
type Flags uint32

// DescriptorSet is a Handle to a vulkan resource.
// DescriptorSet is a child of DescriptorPool.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorSet.html
type DescriptorSet C.VkDescriptorSet

// NullDescriptorSet is a typed Null value for the DescriptorSet type.
var NullDescriptorSet DescriptorSet

// MakeDescriptorSetFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DescriptorPoolFacade) MakeDescriptorSetFacade(x DescriptorSet) DescriptorSetFacade {
	return DescriptorSetFacade{
		H:     x,
		procs: parent.procs,
	}
}

// DescriptorSetFacade is a DescriptorSet handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type DescriptorSetFacade struct {
	H     DescriptorSet  // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// Instance is a Handle to a vulkan resource.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkInstance.html
type Instance C.VkInstance

// NullInstance is a typed Null value for the Instance type.
var NullInstance Instance

// MakeInstanceFacadeFacade provides a facade interface to the handle. It load the proc
// addresses for the provided Instance handle.
func MakeInstanceFacade(x Instance) InstanceFacade {
	var addrs C.vksProcAddr
	C.vksLoadInstanceProcAddrs(x, &addrs)
	return InstanceFacade{
		H:     x,
		procs: &addrs,
	}
}

// InstanceFacade is a Instance handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type InstanceFacade struct {
	H     Instance       // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// Framebuffer is a Handle to a vulkan resource.
// Framebuffer is a child of Device.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFramebuffer.html
type Framebuffer C.VkFramebuffer

// NullFramebuffer is a typed Null value for the Framebuffer type.
var NullFramebuffer Framebuffer

// MakeFramebufferFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DeviceFacade) MakeFramebufferFacade(x Framebuffer) FramebufferFacade {
	return FramebufferFacade{
		H:     x,
		procs: parent.procs,
	}
}

// FramebufferFacade is a Framebuffer handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type FramebufferFacade struct {
	H     Framebuffer    // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// BufferView is a Handle to a vulkan resource.
// BufferView is a child of Device.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBufferView.html
type BufferView C.VkBufferView

// NullBufferView is a typed Null value for the BufferView type.
var NullBufferView BufferView

// MakeBufferViewFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DeviceFacade) MakeBufferViewFacade(x BufferView) BufferViewFacade {
	return BufferViewFacade{
		H:     x,
		procs: parent.procs,
	}
}

// BufferViewFacade is a BufferView handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type BufferViewFacade struct {
	H     BufferView     // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// Event is a Handle to a vulkan resource.
// Event is a child of Device.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkEvent.html
type Event C.VkEvent

// NullEvent is a typed Null value for the Event type.
var NullEvent Event

// MakeEventFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DeviceFacade) MakeEventFacade(x Event) EventFacade {
	return EventFacade{
		H:     x,
		procs: parent.procs,
	}
}

// EventFacade is a Event handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type EventFacade struct {
	H     Event          // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// CommandPool is a Handle to a vulkan resource.
// CommandPool is a child of Device.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCommandPool.html
type CommandPool C.VkCommandPool

// NullCommandPool is a typed Null value for the CommandPool type.
var NullCommandPool CommandPool

// MakeCommandPoolFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DeviceFacade) MakeCommandPoolFacade(x CommandPool) CommandPoolFacade {
	return CommandPoolFacade{
		H:     x,
		procs: parent.procs,
	}
}

// CommandPoolFacade is a CommandPool handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type CommandPoolFacade struct {
	H     CommandPool    // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// DeviceMemory is a Handle to a vulkan resource.
// DeviceMemory is a child of Device.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDeviceMemory.html
type DeviceMemory C.VkDeviceMemory

// NullDeviceMemory is a typed Null value for the DeviceMemory type.
var NullDeviceMemory DeviceMemory

// MakeDeviceMemoryFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DeviceFacade) MakeDeviceMemoryFacade(x DeviceMemory) DeviceMemoryFacade {
	return DeviceMemoryFacade{
		H:     x,
		procs: parent.procs,
	}
}

// DeviceMemoryFacade is a DeviceMemory handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type DeviceMemoryFacade struct {
	H     DeviceMemory   // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// Pipeline is a Handle to a vulkan resource.
// Pipeline is a child of Device.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipeline.html
type Pipeline C.VkPipeline

// NullPipeline is a typed Null value for the Pipeline type.
var NullPipeline Pipeline

// MakePipelineFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DeviceFacade) MakePipelineFacade(x Pipeline) PipelineFacade {
	return PipelineFacade{
		H:     x,
		procs: parent.procs,
	}
}

// PipelineFacade is a Pipeline handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type PipelineFacade struct {
	H     Pipeline       // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// QueryPool is a Handle to a vulkan resource.
// QueryPool is a child of Device.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkQueryPool.html
type QueryPool C.VkQueryPool

// NullQueryPool is a typed Null value for the QueryPool type.
var NullQueryPool QueryPool

// MakeQueryPoolFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DeviceFacade) MakeQueryPoolFacade(x QueryPool) QueryPoolFacade {
	return QueryPoolFacade{
		H:     x,
		procs: parent.procs,
	}
}

// QueryPoolFacade is a QueryPool handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type QueryPoolFacade struct {
	H     QueryPool      // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// Image is a Handle to a vulkan resource.
// Image is a child of Device.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImage.html
type Image C.VkImage

// NullImage is a typed Null value for the Image type.
var NullImage Image

// MakeImageFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DeviceFacade) MakeImageFacade(x Image) ImageFacade {
	return ImageFacade{
		H:     x,
		procs: parent.procs,
	}
}

// ImageFacade is a Image handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type ImageFacade struct {
	H     Image          // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// PipelineCache is a Handle to a vulkan resource.
// PipelineCache is a child of Device.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineCache.html
type PipelineCache C.VkPipelineCache

// NullPipelineCache is a typed Null value for the PipelineCache type.
var NullPipelineCache PipelineCache

// MakePipelineCacheFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DeviceFacade) MakePipelineCacheFacade(x PipelineCache) PipelineCacheFacade {
	return PipelineCacheFacade{
		H:     x,
		procs: parent.procs,
	}
}

// PipelineCacheFacade is a PipelineCache handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type PipelineCacheFacade struct {
	H     PipelineCache  // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// Device is a Handle to a vulkan resource.
// Device is a child of PhysicalDevice.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDevice.html
type Device C.VkDevice

// NullDevice is a typed Null value for the Device type.
var NullDevice Device

// MakeDeviceFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent PhysicalDeviceFacade) MakeDeviceFacade(x Device) DeviceFacade {
	return DeviceFacade{
		H:     x,
		procs: parent.procs,
	}
}

// DeviceFacade is a Device handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type DeviceFacade struct {
	H     Device         // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// CommandBuffer is a Handle to a vulkan resource.
// CommandBuffer is a child of CommandPool.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCommandBuffer.html
type CommandBuffer C.VkCommandBuffer

// NullCommandBuffer is a typed Null value for the CommandBuffer type.
var NullCommandBuffer CommandBuffer

// MakeCommandBufferFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent CommandPoolFacade) MakeCommandBufferFacade(x CommandBuffer) CommandBufferFacade {
	return CommandBufferFacade{
		H:     x,
		procs: parent.procs,
	}
}

// CommandBufferFacade is a CommandBuffer handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type CommandBufferFacade struct {
	H     CommandBuffer  // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// Semaphore is a Handle to a vulkan resource.
// Semaphore is a child of Device.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSemaphore.html
type Semaphore C.VkSemaphore

// NullSemaphore is a typed Null value for the Semaphore type.
var NullSemaphore Semaphore

// MakeSemaphoreFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DeviceFacade) MakeSemaphoreFacade(x Semaphore) SemaphoreFacade {
	return SemaphoreFacade{
		H:     x,
		procs: parent.procs,
	}
}

// SemaphoreFacade is a Semaphore handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type SemaphoreFacade struct {
	H     Semaphore      // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// DescriptorSetLayout is a Handle to a vulkan resource.
// DescriptorSetLayout is a child of Device.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorSetLayout.html
type DescriptorSetLayout C.VkDescriptorSetLayout

// NullDescriptorSetLayout is a typed Null value for the DescriptorSetLayout type.
var NullDescriptorSetLayout DescriptorSetLayout

// MakeDescriptorSetLayoutFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DeviceFacade) MakeDescriptorSetLayoutFacade(x DescriptorSetLayout) DescriptorSetLayoutFacade {
	return DescriptorSetLayoutFacade{
		H:     x,
		procs: parent.procs,
	}
}

// DescriptorSetLayoutFacade is a DescriptorSetLayout handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type DescriptorSetLayoutFacade struct {
	H     DescriptorSetLayout // The vulkan Handle
	procs *C.vksProcAddr      // The addresses for commands.
}

// ImageView is a Handle to a vulkan resource.
// ImageView is a child of Device.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageView.html
type ImageView C.VkImageView

// NullImageView is a typed Null value for the ImageView type.
var NullImageView ImageView

// MakeImageViewFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DeviceFacade) MakeImageViewFacade(x ImageView) ImageViewFacade {
	return ImageViewFacade{
		H:     x,
		procs: parent.procs,
	}
}

// ImageViewFacade is a ImageView handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type ImageViewFacade struct {
	H     ImageView      // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// Sampler is a Handle to a vulkan resource.
// Sampler is a child of Device.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSampler.html
type Sampler C.VkSampler

// NullSampler is a typed Null value for the Sampler type.
var NullSampler Sampler

// MakeSamplerFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DeviceFacade) MakeSamplerFacade(x Sampler) SamplerFacade {
	return SamplerFacade{
		H:     x,
		procs: parent.procs,
	}
}

// SamplerFacade is a Sampler handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type SamplerFacade struct {
	H     Sampler        // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// Queue is a Handle to a vulkan resource.
// Queue is a child of Device.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkQueue.html
type Queue C.VkQueue

// NullQueue is a typed Null value for the Queue type.
var NullQueue Queue

// MakeQueueFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DeviceFacade) MakeQueueFacade(x Queue) QueueFacade {
	return QueueFacade{
		H:     x,
		procs: parent.procs,
	}
}

// QueueFacade is a Queue handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type QueueFacade struct {
	H     Queue          // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// ShaderModule is a Handle to a vulkan resource.
// ShaderModule is a child of Device.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkShaderModule.html
type ShaderModule C.VkShaderModule

// NullShaderModule is a typed Null value for the ShaderModule type.
var NullShaderModule ShaderModule

// MakeShaderModuleFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DeviceFacade) MakeShaderModuleFacade(x ShaderModule) ShaderModuleFacade {
	return ShaderModuleFacade{
		H:     x,
		procs: parent.procs,
	}
}

// ShaderModuleFacade is a ShaderModule handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type ShaderModuleFacade struct {
	H     ShaderModule   // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// Fence is a Handle to a vulkan resource.
// Fence is a child of Device.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFence.html
type Fence C.VkFence

// NullFence is a typed Null value for the Fence type.
var NullFence Fence

// MakeFenceFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DeviceFacade) MakeFenceFacade(x Fence) FenceFacade {
	return FenceFacade{
		H:     x,
		procs: parent.procs,
	}
}

// FenceFacade is a Fence handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type FenceFacade struct {
	H     Fence          // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// PipelineLayout is a Handle to a vulkan resource.
// PipelineLayout is a child of Device.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineLayout.html
type PipelineLayout C.VkPipelineLayout

// NullPipelineLayout is a typed Null value for the PipelineLayout type.
var NullPipelineLayout PipelineLayout

// MakePipelineLayoutFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DeviceFacade) MakePipelineLayoutFacade(x PipelineLayout) PipelineLayoutFacade {
	return PipelineLayoutFacade{
		H:     x,
		procs: parent.procs,
	}
}

// PipelineLayoutFacade is a PipelineLayout handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type PipelineLayoutFacade struct {
	H     PipelineLayout // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// RenderPass is a Handle to a vulkan resource.
// RenderPass is a child of Device.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkRenderPass.html
type RenderPass C.VkRenderPass

// NullRenderPass is a typed Null value for the RenderPass type.
var NullRenderPass RenderPass

// MakeRenderPassFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DeviceFacade) MakeRenderPassFacade(x RenderPass) RenderPassFacade {
	return RenderPassFacade{
		H:     x,
		procs: parent.procs,
	}
}

// RenderPassFacade is a RenderPass handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type RenderPassFacade struct {
	H     RenderPass     // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// Buffer is a Handle to a vulkan resource.
// Buffer is a child of Device.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBuffer.html
type Buffer C.VkBuffer

// NullBuffer is a typed Null value for the Buffer type.
var NullBuffer Buffer

// MakeBufferFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DeviceFacade) MakeBufferFacade(x Buffer) BufferFacade {
	return BufferFacade{
		H:     x,
		procs: parent.procs,
	}
}

// BufferFacade is a Buffer handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type BufferFacade struct {
	H     Buffer         // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// DescriptorPool is a Handle to a vulkan resource.
// DescriptorPool is a child of Device.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorPool.html
type DescriptorPool C.VkDescriptorPool

// NullDescriptorPool is a typed Null value for the DescriptorPool type.
var NullDescriptorPool DescriptorPool

// MakeDescriptorPoolFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DeviceFacade) MakeDescriptorPoolFacade(x DescriptorPool) DescriptorPoolFacade {
	return DescriptorPoolFacade{
		H:     x,
		procs: parent.procs,
	}
}

// DescriptorPoolFacade is a DescriptorPool handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type DescriptorPoolFacade struct {
	H     DescriptorPool // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// PhysicalDevice is a Handle to a vulkan resource.
// PhysicalDevice is a child of Instance.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevice.html
type PhysicalDevice C.VkPhysicalDevice

// NullPhysicalDevice is a typed Null value for the PhysicalDevice type.
var NullPhysicalDevice PhysicalDevice

// MakePhysicalDeviceFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent InstanceFacade) MakePhysicalDeviceFacade(x PhysicalDevice) PhysicalDeviceFacade {
	return PhysicalDeviceFacade{
		H:     x,
		procs: parent.procs,
	}
}

// PhysicalDeviceFacade is a PhysicalDevice handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type PhysicalDeviceFacade struct {
	H     PhysicalDevice // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// Filter is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFilter.html
type Filter uint32

const (
	VK_FILTER_NEAREST Filter = 0
	VK_FILTER_LINEAR  Filter = 1
)

var (
	reverseFilter map[Filter]string = map[Filter]string{
		VK_FILTER_NEAREST: "VK_FILTER_NEAREST",
		VK_FILTER_LINEAR:  "VK_FILTER_LINEAR",
	}
)

func (x Filter) String() string {
	if s, ok := reverseFilter[x]; ok {
		return s
	}
	return fmt.Sprintf("Filter=%d", x)
}

// BorderColor is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBorderColor.html
type BorderColor uint32

const (
	VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK BorderColor = 0
	VK_BORDER_COLOR_INT_TRANSPARENT_BLACK   BorderColor = 1
	VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK      BorderColor = 2
	VK_BORDER_COLOR_INT_OPAQUE_BLACK        BorderColor = 3
	VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE      BorderColor = 4
	VK_BORDER_COLOR_INT_OPAQUE_WHITE        BorderColor = 5
)

var (
	reverseBorderColor map[BorderColor]string = map[BorderColor]string{
		VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK: "VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK",
		VK_BORDER_COLOR_INT_TRANSPARENT_BLACK:   "VK_BORDER_COLOR_INT_TRANSPARENT_BLACK",
		VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK:      "VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK",
		VK_BORDER_COLOR_INT_OPAQUE_BLACK:        "VK_BORDER_COLOR_INT_OPAQUE_BLACK",
		VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE:      "VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE",
		VK_BORDER_COLOR_INT_OPAQUE_WHITE:        "VK_BORDER_COLOR_INT_OPAQUE_WHITE",
	}
)

func (x BorderColor) String() string {
	if s, ok := reverseBorderColor[x]; ok {
		return s
	}
	return fmt.Sprintf("BorderColor=%d", x)
}

// AttachmentLoadOp is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkAttachmentLoadOp.html
type AttachmentLoadOp uint32

const (
	VK_ATTACHMENT_LOAD_OP_LOAD      AttachmentLoadOp = 0
	VK_ATTACHMENT_LOAD_OP_CLEAR     AttachmentLoadOp = 1
	VK_ATTACHMENT_LOAD_OP_DONT_CARE AttachmentLoadOp = 2
)

var (
	reverseAttachmentLoadOp map[AttachmentLoadOp]string = map[AttachmentLoadOp]string{
		VK_ATTACHMENT_LOAD_OP_LOAD:      "VK_ATTACHMENT_LOAD_OP_LOAD",
		VK_ATTACHMENT_LOAD_OP_CLEAR:     "VK_ATTACHMENT_LOAD_OP_CLEAR",
		VK_ATTACHMENT_LOAD_OP_DONT_CARE: "VK_ATTACHMENT_LOAD_OP_DONT_CARE",
	}
)

func (x AttachmentLoadOp) String() string {
	if s, ok := reverseAttachmentLoadOp[x]; ok {
		return s
	}
	return fmt.Sprintf("AttachmentLoadOp=%d", x)
}

// StencilFaceFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkStencilFaceFlagBits.html
type StencilFaceFlagBits uint32

const (
	VK_STENCIL_FACE_FRONT_BIT      StencilFaceFlagBits = (1 << 0)
	VK_STENCIL_FACE_BACK_BIT       StencilFaceFlagBits = (1 << 1)
	VK_STENCIL_FACE_FRONT_AND_BACK StencilFaceFlagBits = 0x00000003
	VK_STENCIL_FRONT_AND_BACK      StencilFaceFlagBits = VK_STENCIL_FACE_FRONT_AND_BACK
)

var (
	reverseStencilFaceFlagBits map[StencilFaceFlagBits]string = map[StencilFaceFlagBits]string{
		VK_STENCIL_FACE_FRONT_BIT:      "VK_STENCIL_FACE_FRONT_BIT",
		VK_STENCIL_FACE_BACK_BIT:       "VK_STENCIL_FACE_BACK_BIT",
		VK_STENCIL_FACE_FRONT_AND_BACK: "VK_STENCIL_FACE_FRONT_AND_BACK",
	}
)

func (x StencilFaceFlagBits) String() string {
	if s, ok := reverseStencilFaceFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("StencilFaceFlagBits=%d", x)
}

// RenderPassCreateFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkRenderPassCreateFlagBits.html
type RenderPassCreateFlagBits uint32

// IndexType is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkIndexType.html
type IndexType uint32

const (
	VK_INDEX_TYPE_UINT16 IndexType = 0
	VK_INDEX_TYPE_UINT32 IndexType = 1
)

var (
	reverseIndexType map[IndexType]string = map[IndexType]string{
		VK_INDEX_TYPE_UINT16: "VK_INDEX_TYPE_UINT16",
		VK_INDEX_TYPE_UINT32: "VK_INDEX_TYPE_UINT32",
	}
)

func (x IndexType) String() string {
	if s, ok := reverseIndexType[x]; ok {
		return s
	}
	return fmt.Sprintf("IndexType=%d", x)
}

// PolygonMode is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPolygonMode.html
type PolygonMode uint32

const (
	VK_POLYGON_MODE_FILL  PolygonMode = 0
	VK_POLYGON_MODE_LINE  PolygonMode = 1
	VK_POLYGON_MODE_POINT PolygonMode = 2
)

var (
	reversePolygonMode map[PolygonMode]string = map[PolygonMode]string{
		VK_POLYGON_MODE_FILL:  "VK_POLYGON_MODE_FILL",
		VK_POLYGON_MODE_LINE:  "VK_POLYGON_MODE_LINE",
		VK_POLYGON_MODE_POINT: "VK_POLYGON_MODE_POINT",
	}
)

func (x PolygonMode) String() string {
	if s, ok := reversePolygonMode[x]; ok {
		return s
	}
	return fmt.Sprintf("PolygonMode=%d", x)
}

// PipelineBindPoint is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineBindPoint.html
type PipelineBindPoint uint32

const (
	VK_PIPELINE_BIND_POINT_GRAPHICS PipelineBindPoint = 0
	VK_PIPELINE_BIND_POINT_COMPUTE  PipelineBindPoint = 1
)

var (
	reversePipelineBindPoint map[PipelineBindPoint]string = map[PipelineBindPoint]string{
		VK_PIPELINE_BIND_POINT_GRAPHICS: "VK_PIPELINE_BIND_POINT_GRAPHICS",
		VK_PIPELINE_BIND_POINT_COMPUTE:  "VK_PIPELINE_BIND_POINT_COMPUTE",
	}
)

func (x PipelineBindPoint) String() string {
	if s, ok := reversePipelineBindPoint[x]; ok {
		return s
	}
	return fmt.Sprintf("PipelineBindPoint=%d", x)
}

// FenceCreateFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFenceCreateFlagBits.html
type FenceCreateFlagBits uint32

const (
	VK_FENCE_CREATE_SIGNALED_BIT FenceCreateFlagBits = (1 << 0)
)

var (
	reverseFenceCreateFlagBits map[FenceCreateFlagBits]string = map[FenceCreateFlagBits]string{
		VK_FENCE_CREATE_SIGNALED_BIT: "VK_FENCE_CREATE_SIGNALED_BIT",
	}
)

func (x FenceCreateFlagBits) String() string {
	if s, ok := reverseFenceCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("FenceCreateFlagBits=%d", x)
}

// SamplerMipmapMode is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSamplerMipmapMode.html
type SamplerMipmapMode uint32

const (
	VK_SAMPLER_MIPMAP_MODE_NEAREST SamplerMipmapMode = 0
	VK_SAMPLER_MIPMAP_MODE_LINEAR  SamplerMipmapMode = 1
)

var (
	reverseSamplerMipmapMode map[SamplerMipmapMode]string = map[SamplerMipmapMode]string{
		VK_SAMPLER_MIPMAP_MODE_NEAREST: "VK_SAMPLER_MIPMAP_MODE_NEAREST",
		VK_SAMPLER_MIPMAP_MODE_LINEAR:  "VK_SAMPLER_MIPMAP_MODE_LINEAR",
	}
)

func (x SamplerMipmapMode) String() string {
	if s, ok := reverseSamplerMipmapMode[x]; ok {
		return s
	}
	return fmt.Sprintf("SamplerMipmapMode=%d", x)
}

// PipelineCreateFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineCreateFlagBits.html
type PipelineCreateFlagBits uint32

const (
	VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT         PipelineCreateFlagBits = (1 << 0)
	VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT            PipelineCreateFlagBits = (1 << 1)
	VK_PIPELINE_CREATE_DERIVATIVE_BIT                   PipelineCreateFlagBits = (1 << 2)
	VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT PipelineCreateFlagBits = (1 << 3)
	VK_PIPELINE_CREATE_DISPATCH_BASE_BIT                PipelineCreateFlagBits = (1 << 4)
	VK_PIPELINE_CREATE_DISPATCH_BASE                    PipelineCreateFlagBits = VK_PIPELINE_CREATE_DISPATCH_BASE_BIT
)

var (
	reversePipelineCreateFlagBits map[PipelineCreateFlagBits]string = map[PipelineCreateFlagBits]string{
		VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT:         "VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT",
		VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT:            "VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT",
		VK_PIPELINE_CREATE_DERIVATIVE_BIT:                   "VK_PIPELINE_CREATE_DERIVATIVE_BIT",
		VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT: "VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT",
		VK_PIPELINE_CREATE_DISPATCH_BASE_BIT:                "VK_PIPELINE_CREATE_DISPATCH_BASE_BIT",
	}
)

func (x PipelineCreateFlagBits) String() string {
	if s, ok := reversePipelineCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("PipelineCreateFlagBits=%d", x)
}

// FramebufferCreateFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFramebufferCreateFlagBits.html
type FramebufferCreateFlagBits uint32

const (
	VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT FramebufferCreateFlagBits = (1 << 0)
)

var (
	reverseFramebufferCreateFlagBits map[FramebufferCreateFlagBits]string = map[FramebufferCreateFlagBits]string{
		VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT: "VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT",
	}
)

func (x FramebufferCreateFlagBits) String() string {
	if s, ok := reverseFramebufferCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("FramebufferCreateFlagBits=%d", x)
}

// PipelineCacheHeaderVersion is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineCacheHeaderVersion.html
type PipelineCacheHeaderVersion uint32

const (
	VK_PIPELINE_CACHE_HEADER_VERSION_ONE PipelineCacheHeaderVersion = 1
)

var (
	reversePipelineCacheHeaderVersion map[PipelineCacheHeaderVersion]string = map[PipelineCacheHeaderVersion]string{
		VK_PIPELINE_CACHE_HEADER_VERSION_ONE: "VK_PIPELINE_CACHE_HEADER_VERSION_ONE",
	}
)

func (x PipelineCacheHeaderVersion) String() string {
	if s, ok := reversePipelineCacheHeaderVersion[x]; ok {
		return s
	}
	return fmt.Sprintf("PipelineCacheHeaderVersion=%d", x)
}

// BufferCreateFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBufferCreateFlagBits.html
type BufferCreateFlagBits uint32

const (
	VK_BUFFER_CREATE_SPARSE_BINDING_BIT                BufferCreateFlagBits = (1 << 0)
	VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT              BufferCreateFlagBits = (1 << 1)
	VK_BUFFER_CREATE_SPARSE_ALIASED_BIT                BufferCreateFlagBits = (1 << 2)
	VK_BUFFER_CREATE_PROTECTED_BIT                     BufferCreateFlagBits = (1 << 3)
	VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT BufferCreateFlagBits = (1 << 4)
)

var (
	reverseBufferCreateFlagBits map[BufferCreateFlagBits]string = map[BufferCreateFlagBits]string{
		VK_BUFFER_CREATE_SPARSE_BINDING_BIT:                "VK_BUFFER_CREATE_SPARSE_BINDING_BIT",
		VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT:              "VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT",
		VK_BUFFER_CREATE_SPARSE_ALIASED_BIT:                "VK_BUFFER_CREATE_SPARSE_ALIASED_BIT",
		VK_BUFFER_CREATE_PROTECTED_BIT:                     "VK_BUFFER_CREATE_PROTECTED_BIT",
		VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT: "VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT",
	}
)

func (x BufferCreateFlagBits) String() string {
	if s, ok := reverseBufferCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("BufferCreateFlagBits=%d", x)
}

// SubpassDescriptionFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSubpassDescriptionFlagBits.html
type SubpassDescriptionFlagBits uint32

// SparseMemoryBindFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSparseMemoryBindFlagBits.html
type SparseMemoryBindFlagBits uint32

const (
	VK_SPARSE_MEMORY_BIND_METADATA_BIT SparseMemoryBindFlagBits = (1 << 0)
)

var (
	reverseSparseMemoryBindFlagBits map[SparseMemoryBindFlagBits]string = map[SparseMemoryBindFlagBits]string{
		VK_SPARSE_MEMORY_BIND_METADATA_BIT: "VK_SPARSE_MEMORY_BIND_METADATA_BIT",
	}
)

func (x SparseMemoryBindFlagBits) String() string {
	if s, ok := reverseSparseMemoryBindFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("SparseMemoryBindFlagBits=%d", x)
}

// BufferUsageFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBufferUsageFlagBits.html
type BufferUsageFlagBits uint32

const (
	VK_BUFFER_USAGE_TRANSFER_SRC_BIT          BufferUsageFlagBits = (1 << 0)
	VK_BUFFER_USAGE_TRANSFER_DST_BIT          BufferUsageFlagBits = (1 << 1)
	VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT  BufferUsageFlagBits = (1 << 2)
	VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT  BufferUsageFlagBits = (1 << 3)
	VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT        BufferUsageFlagBits = (1 << 4)
	VK_BUFFER_USAGE_STORAGE_BUFFER_BIT        BufferUsageFlagBits = (1 << 5)
	VK_BUFFER_USAGE_INDEX_BUFFER_BIT          BufferUsageFlagBits = (1 << 6)
	VK_BUFFER_USAGE_VERTEX_BUFFER_BIT         BufferUsageFlagBits = (1 << 7)
	VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT       BufferUsageFlagBits = (1 << 8)
	VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT BufferUsageFlagBits = (1 << 17)
)

var (
	reverseBufferUsageFlagBits map[BufferUsageFlagBits]string = map[BufferUsageFlagBits]string{
		VK_BUFFER_USAGE_TRANSFER_SRC_BIT:          "VK_BUFFER_USAGE_TRANSFER_SRC_BIT",
		VK_BUFFER_USAGE_TRANSFER_DST_BIT:          "VK_BUFFER_USAGE_TRANSFER_DST_BIT",
		VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT:  "VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT",
		VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT:  "VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT",
		VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT:        "VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT",
		VK_BUFFER_USAGE_STORAGE_BUFFER_BIT:        "VK_BUFFER_USAGE_STORAGE_BUFFER_BIT",
		VK_BUFFER_USAGE_INDEX_BUFFER_BIT:          "VK_BUFFER_USAGE_INDEX_BUFFER_BIT",
		VK_BUFFER_USAGE_VERTEX_BUFFER_BIT:         "VK_BUFFER_USAGE_VERTEX_BUFFER_BIT",
		VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT:       "VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT",
		VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT: "VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT",
	}
)

func (x BufferUsageFlagBits) String() string {
	if s, ok := reverseBufferUsageFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("BufferUsageFlagBits=%d", x)
}

// ImageTiling is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageTiling.html
type ImageTiling uint32

const (
	VK_IMAGE_TILING_OPTIMAL ImageTiling = 0
	VK_IMAGE_TILING_LINEAR  ImageTiling = 1
)

var (
	reverseImageTiling map[ImageTiling]string = map[ImageTiling]string{
		VK_IMAGE_TILING_OPTIMAL: "VK_IMAGE_TILING_OPTIMAL",
		VK_IMAGE_TILING_LINEAR:  "VK_IMAGE_TILING_LINEAR",
	}
)

func (x ImageTiling) String() string {
	if s, ok := reverseImageTiling[x]; ok {
		return s
	}
	return fmt.Sprintf("ImageTiling=%d", x)
}

// SharingMode is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSharingMode.html
type SharingMode uint32

const (
	VK_SHARING_MODE_EXCLUSIVE  SharingMode = 0
	VK_SHARING_MODE_CONCURRENT SharingMode = 1
)

var (
	reverseSharingMode map[SharingMode]string = map[SharingMode]string{
		VK_SHARING_MODE_EXCLUSIVE:  "VK_SHARING_MODE_EXCLUSIVE",
		VK_SHARING_MODE_CONCURRENT: "VK_SHARING_MODE_CONCURRENT",
	}
)

func (x SharingMode) String() string {
	if s, ok := reverseSharingMode[x]; ok {
		return s
	}
	return fmt.Sprintf("SharingMode=%d", x)
}

// StructureType is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkStructureType.html
type StructureType uint32

const (
	VK_STRUCTURE_TYPE_APPLICATION_INFO                                        StructureType = 0
	VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO                                    StructureType = 1
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO                                StructureType = 2
	VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO                                      StructureType = 3
	VK_STRUCTURE_TYPE_SUBMIT_INFO                                             StructureType = 4
	VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO                                    StructureType = 5
	VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE                                     StructureType = 6
	VK_STRUCTURE_TYPE_BIND_SPARSE_INFO                                        StructureType = 7
	VK_STRUCTURE_TYPE_FENCE_CREATE_INFO                                       StructureType = 8
	VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO                                   StructureType = 9
	VK_STRUCTURE_TYPE_EVENT_CREATE_INFO                                       StructureType = 10
	VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO                                  StructureType = 11
	VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO                                      StructureType = 12
	VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO                                 StructureType = 13
	VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO                                       StructureType = 14
	VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO                                  StructureType = 15
	VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO                               StructureType = 16
	VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO                              StructureType = 17
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO                       StructureType = 18
	VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO                 StructureType = 19
	VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO               StructureType = 20
	VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO                 StructureType = 21
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO                     StructureType = 22
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO                StructureType = 23
	VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO                  StructureType = 24
	VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO                StructureType = 25
	VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO                  StructureType = 26
	VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO                      StructureType = 27
	VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO                           StructureType = 28
	VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO                            StructureType = 29
	VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO                             StructureType = 30
	VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO                                     StructureType = 31
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO                       StructureType = 32
	VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO                             StructureType = 33
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO                            StructureType = 34
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET                                    StructureType = 35
	VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET                                     StructureType = 36
	VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO                                 StructureType = 37
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO                                 StructureType = 38
	VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO                                StructureType = 39
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO                            StructureType = 40
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO                         StructureType = 41
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO                               StructureType = 42
	VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO                                  StructureType = 43
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER                                   StructureType = 44
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER                                    StructureType = 45
	VK_STRUCTURE_TYPE_MEMORY_BARRIER                                          StructureType = 46
	VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO                             StructureType = 47
	VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO                               StructureType = 48
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES                     StructureType = 1000094000
	VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO                                 StructureType = 1000157000
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO                                  StructureType = 1000157001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES                  StructureType = 1000083000
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS                           StructureType = 1000127000
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO                          StructureType = 1000127001
	VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO                              StructureType = 1000060000
	VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO                     StructureType = 1000060003
	VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO                  StructureType = 1000060004
	VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO                                StructureType = 1000060005
	VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO                           StructureType = 1000060006
	VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO                    StructureType = 1000060013
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO                     StructureType = 1000060014
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES                        StructureType = 1000070000
	VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO                         StructureType = 1000070001
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2                       StructureType = 1000146000
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2                        StructureType = 1000146001
	VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2                 StructureType = 1000146002
	VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2                                   StructureType = 1000146003
	VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2                      StructureType = 1000146004
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2                              StructureType = 1000059000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2                            StructureType = 1000059001
	VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2                                     StructureType = 1000059002
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2                               StructureType = 1000059003
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2                     StructureType = 1000059004
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2                               StructureType = 1000059005
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2                     StructureType = 1000059006
	VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2                        StructureType = 1000059007
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2              StructureType = 1000059008
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES               StructureType = 1000117000
	VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO         StructureType = 1000117001
	VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO                            StructureType = 1000117002
	VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO   StructureType = 1000117003
	VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO                       StructureType = 1000053000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES                      StructureType = 1000053001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES                    StructureType = 1000053002
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES              StructureType = 1000120000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES               StructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES
	VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO                                   StructureType = 1000145000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES               StructureType = 1000145001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES             StructureType = 1000145002
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2                                     StructureType = 1000145003
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO                    StructureType = 1000156000
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO                           StructureType = 1000156001
	VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO                            StructureType = 1000156002
	VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO                    StructureType = 1000156003
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES       StructureType = 1000156004
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES        StructureType = 1000156005
	VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO                  StructureType = 1000085000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO              StructureType = 1000071000
	VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES                        StructureType = 1000071001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO                    StructureType = 1000071002
	VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES                              StructureType = 1000071003
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES                           StructureType = 1000071004
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO                      StructureType = 1000072000
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO                       StructureType = 1000072001
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO                             StructureType = 1000072002
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO                     StructureType = 1000112000
	VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES                               StructureType = 1000112001
	VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO                                StructureType = 1000113000
	VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO                            StructureType = 1000077000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO                 StructureType = 1000076000
	VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES                           StructureType = 1000076001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES                StructureType = 1000168000
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT                           StructureType = 1000168001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES         StructureType = 1000063000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES          StructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES                     StructureType = 49
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES                   StructureType = 50
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES                     StructureType = 51
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES                   StructureType = 52
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO                           StructureType = 1000147000
	VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2                                StructureType = 1000109000
	VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2                                  StructureType = 1000109001
	VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2                                   StructureType = 1000109002
	VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2                                    StructureType = 1000109003
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2                               StructureType = 1000109004
	VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO                                      StructureType = 1000109005
	VK_STRUCTURE_TYPE_SUBPASS_END_INFO                                        StructureType = 1000109006
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES                   StructureType = 1000177000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES                       StructureType = 1000196000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES            StructureType = 1000180000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES            StructureType = 1000082000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES               StructureType = 1000197000
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO         StructureType = 1000161000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES            StructureType = 1000161001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES          StructureType = 1000161002
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO  StructureType = 1000161003
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT StructureType = 1000161004
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES        StructureType = 1000199000
	VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE               StructureType = 1000199001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES            StructureType = 1000221000
	VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO                         StructureType = 1000246000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES        StructureType = 1000130000
	VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO                      StructureType = 1000130001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES            StructureType = 1000211000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES          StructureType = 1000108000
	VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO                     StructureType = 1000108001
	VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO                       StructureType = 1000108002
	VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO                       StructureType = 1000108003
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES StructureType = 1000253000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES StructureType = 1000175000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES StructureType = 1000241000
	VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT                     StructureType = 1000241001
	VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT                   StructureType = 1000241002
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES               StructureType = 1000261000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES             StructureType = 1000207000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES           StructureType = 1000207001
	VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO                              StructureType = 1000207002
	VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO                          StructureType = 1000207003
	VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO                                     StructureType = 1000207004
	VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO                                   StructureType = 1000207005
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES          StructureType = 1000257000
	VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO                              StructureType = 1000244001
	VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO               StructureType = 1000257002
	VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO             StructureType = 1000257003
	VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO               StructureType = 1000257004
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR                      StructureType = 1000119000
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR                              StructureType = 1000119001
	VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR                                    StructureType = 1000119002
	VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR                      StructureType = 1000239000
	VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR                               StructureType = 1000001000
	VK_STRUCTURE_TYPE_PRESENT_INFO_KHR                                        StructureType = 1000001001
	VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR                   StructureType = 1000060007
	VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR                         StructureType = 1000060008
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR                    StructureType = 1000060009
	VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR                             StructureType = 1000060010
	VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR                           StructureType = 1000060011
	VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR                  StructureType = 1000060012
	VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR                            StructureType = 1000002000
	VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR                         StructureType = 1000002001
	VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR                                StructureType = 1000121000
	VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR                          StructureType = 1000121001
	VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR                           StructureType = 1000121002
	VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR                                StructureType = 1000121003
	VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR                        StructureType = 1000121004
	VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR                                StructureType = 1000003000
	VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR                                 StructureType = 1000360000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR         StructureType = 1000163000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR       StructureType = 1000163001
)

var (
	reverseStructureType map[StructureType]string = map[StructureType]string{
		VK_STRUCTURE_TYPE_APPLICATION_INFO:                                        "VK_STRUCTURE_TYPE_APPLICATION_INFO",
		VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO:                                    "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO",
		VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO:                                "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO",
		VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO:                                      "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO",
		VK_STRUCTURE_TYPE_SUBMIT_INFO:                                             "VK_STRUCTURE_TYPE_SUBMIT_INFO",
		VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO:                                    "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO",
		VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE:                                     "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE",
		VK_STRUCTURE_TYPE_BIND_SPARSE_INFO:                                        "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO",
		VK_STRUCTURE_TYPE_FENCE_CREATE_INFO:                                       "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO",
		VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO:                                   "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO",
		VK_STRUCTURE_TYPE_EVENT_CREATE_INFO:                                       "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO",
		VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO:                                  "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO",
		VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO:                                      "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO",
		VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO:                                 "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO",
		VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO:                                       "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO",
		VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO:                                  "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO",
		VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO:                               "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO:                              "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO:                       "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO:                 "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO:               "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO:                 "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO:                     "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO:                "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO:                  "VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO:                "VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO:                  "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO:                      "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO:                           "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO",
		VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO:                            "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO:                             "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO",
		VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO:                                     "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO",
		VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO:                       "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO",
		VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO:                             "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO",
		VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO:                            "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO",
		VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET:                                    "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET",
		VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET:                                     "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET",
		VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO:                                 "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO",
		VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO:                                 "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO",
		VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO:                                "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO",
		VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO:                            "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO",
		VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO:                         "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO",
		VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO:                               "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO",
		VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO:                                  "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO",
		VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER:                                   "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER",
		VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER:                                    "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER",
		VK_STRUCTURE_TYPE_MEMORY_BARRIER:                                          "VK_STRUCTURE_TYPE_MEMORY_BARRIER",
		VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO:                             "VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO",
		VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO:                               "VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:                     "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES",
		VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO:                                 "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO",
		VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO:                                  "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:                  "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES",
		VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:                           "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS",
		VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:                          "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO",
		VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:                              "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO",
		VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:                     "VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO",
		VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:                  "VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO",
		VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:                                "VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO",
		VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:                           "VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO",
		VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:                    "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO",
		VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:                     "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES:                        "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES",
		VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:                         "VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO",
		VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2:                       "VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2",
		VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2:                        "VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2",
		VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2:                 "VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2",
		VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2:                                   "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2",
		VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2:                      "VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:                              "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2:                            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2",
		VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2:                                     "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2",
		VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2:                               "VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2:                     "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2",
		VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2:                               "VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2:                     "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2",
		VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2:                        "VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2:              "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:               "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES",
		VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:         "VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO",
		VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:                            "VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:   "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:                       "VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:                      "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:                    "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:              "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES",
		VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:                                   "VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:               "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:             "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES",
		VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2:                                     "VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2",
		VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO:                    "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO",
		VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:                           "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO",
		VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:                            "VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO",
		VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:                    "VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:       "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES",
		VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:        "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES",
		VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO:                  "VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:              "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO",
		VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:                        "VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO:                    "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO",
		VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES:                              "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:                           "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES",
		VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:                      "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO",
		VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:                       "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO",
		VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:                             "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO:                     "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO",
		VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES:                               "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES",
		VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:                                "VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO",
		VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:                            "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO:                 "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO",
		VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES:                           "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:                "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES",
		VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT:                           "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:         "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:                     "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES:                   "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES:                     "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES:                   "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES",
		VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:                           "VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO",
		VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2:                                "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2",
		VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2:                                  "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2",
		VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2:                                   "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2",
		VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2:                                    "VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2",
		VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2:                               "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2",
		VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO:                                      "VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO",
		VK_STRUCTURE_TYPE_SUBPASS_END_INFO:                                        "VK_STRUCTURE_TYPE_SUBPASS_END_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES:                   "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES:                       "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES:               "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES",
		VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO:         "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES:          "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES",
		VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO:  "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO",
		VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT: "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES:        "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES",
		VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE:               "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES",
		VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:                         "VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES:        "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES",
		VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO:                      "VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:            "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:          "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES",
		VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO:                     "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO",
		VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO:                       "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO",
		VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO:                       "VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES",
		VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT:                     "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT",
		VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT:                   "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:               "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:             "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES:           "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES",
		VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO:                              "VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO",
		VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO:                          "VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO",
		VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO:                                     "VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO",
		VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO:                                   "VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:          "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES",
		VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO:                              "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO",
		VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO:               "VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO",
		VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO:             "VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO",
		VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO:               "VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR:                      "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR",
		VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR:                              "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR",
		VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR:                                    "VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR",
		VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR:                      "VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR",
		VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR:                               "VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR",
		VK_STRUCTURE_TYPE_PRESENT_INFO_KHR:                                        "VK_STRUCTURE_TYPE_PRESENT_INFO_KHR",
		VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR:                   "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR",
		VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:                         "VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR",
		VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:                    "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR",
		VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR:                             "VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR",
		VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:                           "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR",
		VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:                  "VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR",
		VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR:                            "VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR",
		VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR:                         "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR",
		VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR:                                "VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR",
		VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR:                          "VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR",
		VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR:                           "VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR",
		VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR:                                "VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR",
		VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR:                        "VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR",
		VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:                                "VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR",
		VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR:                                 "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR:         "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR:       "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR",
	}
)

func (x StructureType) String() string {
	if s, ok := reverseStructureType[x]; ok {
		return s
	}
	return fmt.Sprintf("StructureType=%d", x)
}

// LogicOp is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkLogicOp.html
type LogicOp uint32

const (
	VK_LOGIC_OP_CLEAR         LogicOp = 0
	VK_LOGIC_OP_AND           LogicOp = 1
	VK_LOGIC_OP_AND_REVERSE   LogicOp = 2
	VK_LOGIC_OP_COPY          LogicOp = 3
	VK_LOGIC_OP_AND_INVERTED  LogicOp = 4
	VK_LOGIC_OP_NO_OP         LogicOp = 5
	VK_LOGIC_OP_XOR           LogicOp = 6
	VK_LOGIC_OP_OR            LogicOp = 7
	VK_LOGIC_OP_NOR           LogicOp = 8
	VK_LOGIC_OP_EQUIVALENT    LogicOp = 9
	VK_LOGIC_OP_INVERT        LogicOp = 10
	VK_LOGIC_OP_OR_REVERSE    LogicOp = 11
	VK_LOGIC_OP_COPY_INVERTED LogicOp = 12
	VK_LOGIC_OP_OR_INVERTED   LogicOp = 13
	VK_LOGIC_OP_NAND          LogicOp = 14
	VK_LOGIC_OP_SET           LogicOp = 15
)

var (
	reverseLogicOp map[LogicOp]string = map[LogicOp]string{
		VK_LOGIC_OP_CLEAR:         "VK_LOGIC_OP_CLEAR",
		VK_LOGIC_OP_AND:           "VK_LOGIC_OP_AND",
		VK_LOGIC_OP_AND_REVERSE:   "VK_LOGIC_OP_AND_REVERSE",
		VK_LOGIC_OP_COPY:          "VK_LOGIC_OP_COPY",
		VK_LOGIC_OP_AND_INVERTED:  "VK_LOGIC_OP_AND_INVERTED",
		VK_LOGIC_OP_NO_OP:         "VK_LOGIC_OP_NO_OP",
		VK_LOGIC_OP_XOR:           "VK_LOGIC_OP_XOR",
		VK_LOGIC_OP_OR:            "VK_LOGIC_OP_OR",
		VK_LOGIC_OP_NOR:           "VK_LOGIC_OP_NOR",
		VK_LOGIC_OP_EQUIVALENT:    "VK_LOGIC_OP_EQUIVALENT",
		VK_LOGIC_OP_INVERT:        "VK_LOGIC_OP_INVERT",
		VK_LOGIC_OP_OR_REVERSE:    "VK_LOGIC_OP_OR_REVERSE",
		VK_LOGIC_OP_COPY_INVERTED: "VK_LOGIC_OP_COPY_INVERTED",
		VK_LOGIC_OP_OR_INVERTED:   "VK_LOGIC_OP_OR_INVERTED",
		VK_LOGIC_OP_NAND:          "VK_LOGIC_OP_NAND",
		VK_LOGIC_OP_SET:           "VK_LOGIC_OP_SET",
	}
)

func (x LogicOp) String() string {
	if s, ok := reverseLogicOp[x]; ok {
		return s
	}
	return fmt.Sprintf("LogicOp=%d", x)
}

// Format is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFormat.html
type Format uint32

const (
	VK_FORMAT_UNDEFINED                                  Format = 0
	VK_FORMAT_R4G4_UNORM_PACK8                           Format = 1
	VK_FORMAT_R4G4B4A4_UNORM_PACK16                      Format = 2
	VK_FORMAT_B4G4R4A4_UNORM_PACK16                      Format = 3
	VK_FORMAT_R5G6B5_UNORM_PACK16                        Format = 4
	VK_FORMAT_B5G6R5_UNORM_PACK16                        Format = 5
	VK_FORMAT_R5G5B5A1_UNORM_PACK16                      Format = 6
	VK_FORMAT_B5G5R5A1_UNORM_PACK16                      Format = 7
	VK_FORMAT_A1R5G5B5_UNORM_PACK16                      Format = 8
	VK_FORMAT_R8_UNORM                                   Format = 9
	VK_FORMAT_R8_SNORM                                   Format = 10
	VK_FORMAT_R8_USCALED                                 Format = 11
	VK_FORMAT_R8_SSCALED                                 Format = 12
	VK_FORMAT_R8_UINT                                    Format = 13
	VK_FORMAT_R8_SINT                                    Format = 14
	VK_FORMAT_R8_SRGB                                    Format = 15
	VK_FORMAT_R8G8_UNORM                                 Format = 16
	VK_FORMAT_R8G8_SNORM                                 Format = 17
	VK_FORMAT_R8G8_USCALED                               Format = 18
	VK_FORMAT_R8G8_SSCALED                               Format = 19
	VK_FORMAT_R8G8_UINT                                  Format = 20
	VK_FORMAT_R8G8_SINT                                  Format = 21
	VK_FORMAT_R8G8_SRGB                                  Format = 22
	VK_FORMAT_R8G8B8_UNORM                               Format = 23
	VK_FORMAT_R8G8B8_SNORM                               Format = 24
	VK_FORMAT_R8G8B8_USCALED                             Format = 25
	VK_FORMAT_R8G8B8_SSCALED                             Format = 26
	VK_FORMAT_R8G8B8_UINT                                Format = 27
	VK_FORMAT_R8G8B8_SINT                                Format = 28
	VK_FORMAT_R8G8B8_SRGB                                Format = 29
	VK_FORMAT_B8G8R8_UNORM                               Format = 30
	VK_FORMAT_B8G8R8_SNORM                               Format = 31
	VK_FORMAT_B8G8R8_USCALED                             Format = 32
	VK_FORMAT_B8G8R8_SSCALED                             Format = 33
	VK_FORMAT_B8G8R8_UINT                                Format = 34
	VK_FORMAT_B8G8R8_SINT                                Format = 35
	VK_FORMAT_B8G8R8_SRGB                                Format = 36
	VK_FORMAT_R8G8B8A8_UNORM                             Format = 37
	VK_FORMAT_R8G8B8A8_SNORM                             Format = 38
	VK_FORMAT_R8G8B8A8_USCALED                           Format = 39
	VK_FORMAT_R8G8B8A8_SSCALED                           Format = 40
	VK_FORMAT_R8G8B8A8_UINT                              Format = 41
	VK_FORMAT_R8G8B8A8_SINT                              Format = 42
	VK_FORMAT_R8G8B8A8_SRGB                              Format = 43
	VK_FORMAT_B8G8R8A8_UNORM                             Format = 44
	VK_FORMAT_B8G8R8A8_SNORM                             Format = 45
	VK_FORMAT_B8G8R8A8_USCALED                           Format = 46
	VK_FORMAT_B8G8R8A8_SSCALED                           Format = 47
	VK_FORMAT_B8G8R8A8_UINT                              Format = 48
	VK_FORMAT_B8G8R8A8_SINT                              Format = 49
	VK_FORMAT_B8G8R8A8_SRGB                              Format = 50
	VK_FORMAT_A8B8G8R8_UNORM_PACK32                      Format = 51
	VK_FORMAT_A8B8G8R8_SNORM_PACK32                      Format = 52
	VK_FORMAT_A8B8G8R8_USCALED_PACK32                    Format = 53
	VK_FORMAT_A8B8G8R8_SSCALED_PACK32                    Format = 54
	VK_FORMAT_A8B8G8R8_UINT_PACK32                       Format = 55
	VK_FORMAT_A8B8G8R8_SINT_PACK32                       Format = 56
	VK_FORMAT_A8B8G8R8_SRGB_PACK32                       Format = 57
	VK_FORMAT_A2R10G10B10_UNORM_PACK32                   Format = 58
	VK_FORMAT_A2R10G10B10_SNORM_PACK32                   Format = 59
	VK_FORMAT_A2R10G10B10_USCALED_PACK32                 Format = 60
	VK_FORMAT_A2R10G10B10_SSCALED_PACK32                 Format = 61
	VK_FORMAT_A2R10G10B10_UINT_PACK32                    Format = 62
	VK_FORMAT_A2R10G10B10_SINT_PACK32                    Format = 63
	VK_FORMAT_A2B10G10R10_UNORM_PACK32                   Format = 64
	VK_FORMAT_A2B10G10R10_SNORM_PACK32                   Format = 65
	VK_FORMAT_A2B10G10R10_USCALED_PACK32                 Format = 66
	VK_FORMAT_A2B10G10R10_SSCALED_PACK32                 Format = 67
	VK_FORMAT_A2B10G10R10_UINT_PACK32                    Format = 68
	VK_FORMAT_A2B10G10R10_SINT_PACK32                    Format = 69
	VK_FORMAT_R16_UNORM                                  Format = 70
	VK_FORMAT_R16_SNORM                                  Format = 71
	VK_FORMAT_R16_USCALED                                Format = 72
	VK_FORMAT_R16_SSCALED                                Format = 73
	VK_FORMAT_R16_UINT                                   Format = 74
	VK_FORMAT_R16_SINT                                   Format = 75
	VK_FORMAT_R16_SFLOAT                                 Format = 76
	VK_FORMAT_R16G16_UNORM                               Format = 77
	VK_FORMAT_R16G16_SNORM                               Format = 78
	VK_FORMAT_R16G16_USCALED                             Format = 79
	VK_FORMAT_R16G16_SSCALED                             Format = 80
	VK_FORMAT_R16G16_UINT                                Format = 81
	VK_FORMAT_R16G16_SINT                                Format = 82
	VK_FORMAT_R16G16_SFLOAT                              Format = 83
	VK_FORMAT_R16G16B16_UNORM                            Format = 84
	VK_FORMAT_R16G16B16_SNORM                            Format = 85
	VK_FORMAT_R16G16B16_USCALED                          Format = 86
	VK_FORMAT_R16G16B16_SSCALED                          Format = 87
	VK_FORMAT_R16G16B16_UINT                             Format = 88
	VK_FORMAT_R16G16B16_SINT                             Format = 89
	VK_FORMAT_R16G16B16_SFLOAT                           Format = 90
	VK_FORMAT_R16G16B16A16_UNORM                         Format = 91
	VK_FORMAT_R16G16B16A16_SNORM                         Format = 92
	VK_FORMAT_R16G16B16A16_USCALED                       Format = 93
	VK_FORMAT_R16G16B16A16_SSCALED                       Format = 94
	VK_FORMAT_R16G16B16A16_UINT                          Format = 95
	VK_FORMAT_R16G16B16A16_SINT                          Format = 96
	VK_FORMAT_R16G16B16A16_SFLOAT                        Format = 97
	VK_FORMAT_R32_UINT                                   Format = 98
	VK_FORMAT_R32_SINT                                   Format = 99
	VK_FORMAT_R32_SFLOAT                                 Format = 100
	VK_FORMAT_R32G32_UINT                                Format = 101
	VK_FORMAT_R32G32_SINT                                Format = 102
	VK_FORMAT_R32G32_SFLOAT                              Format = 103
	VK_FORMAT_R32G32B32_UINT                             Format = 104
	VK_FORMAT_R32G32B32_SINT                             Format = 105
	VK_FORMAT_R32G32B32_SFLOAT                           Format = 106
	VK_FORMAT_R32G32B32A32_UINT                          Format = 107
	VK_FORMAT_R32G32B32A32_SINT                          Format = 108
	VK_FORMAT_R32G32B32A32_SFLOAT                        Format = 109
	VK_FORMAT_R64_UINT                                   Format = 110
	VK_FORMAT_R64_SINT                                   Format = 111
	VK_FORMAT_R64_SFLOAT                                 Format = 112
	VK_FORMAT_R64G64_UINT                                Format = 113
	VK_FORMAT_R64G64_SINT                                Format = 114
	VK_FORMAT_R64G64_SFLOAT                              Format = 115
	VK_FORMAT_R64G64B64_UINT                             Format = 116
	VK_FORMAT_R64G64B64_SINT                             Format = 117
	VK_FORMAT_R64G64B64_SFLOAT                           Format = 118
	VK_FORMAT_R64G64B64A64_UINT                          Format = 119
	VK_FORMAT_R64G64B64A64_SINT                          Format = 120
	VK_FORMAT_R64G64B64A64_SFLOAT                        Format = 121
	VK_FORMAT_B10G11R11_UFLOAT_PACK32                    Format = 122
	VK_FORMAT_E5B9G9R9_UFLOAT_PACK32                     Format = 123
	VK_FORMAT_D16_UNORM                                  Format = 124
	VK_FORMAT_X8_D24_UNORM_PACK32                        Format = 125
	VK_FORMAT_D32_SFLOAT                                 Format = 126
	VK_FORMAT_S8_UINT                                    Format = 127
	VK_FORMAT_D16_UNORM_S8_UINT                          Format = 128
	VK_FORMAT_D24_UNORM_S8_UINT                          Format = 129
	VK_FORMAT_D32_SFLOAT_S8_UINT                         Format = 130
	VK_FORMAT_BC1_RGB_UNORM_BLOCK                        Format = 131
	VK_FORMAT_BC1_RGB_SRGB_BLOCK                         Format = 132
	VK_FORMAT_BC1_RGBA_UNORM_BLOCK                       Format = 133
	VK_FORMAT_BC1_RGBA_SRGB_BLOCK                        Format = 134
	VK_FORMAT_BC2_UNORM_BLOCK                            Format = 135
	VK_FORMAT_BC2_SRGB_BLOCK                             Format = 136
	VK_FORMAT_BC3_UNORM_BLOCK                            Format = 137
	VK_FORMAT_BC3_SRGB_BLOCK                             Format = 138
	VK_FORMAT_BC4_UNORM_BLOCK                            Format = 139
	VK_FORMAT_BC4_SNORM_BLOCK                            Format = 140
	VK_FORMAT_BC5_UNORM_BLOCK                            Format = 141
	VK_FORMAT_BC5_SNORM_BLOCK                            Format = 142
	VK_FORMAT_BC6H_UFLOAT_BLOCK                          Format = 143
	VK_FORMAT_BC6H_SFLOAT_BLOCK                          Format = 144
	VK_FORMAT_BC7_UNORM_BLOCK                            Format = 145
	VK_FORMAT_BC7_SRGB_BLOCK                             Format = 146
	VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK                    Format = 147
	VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK                     Format = 148
	VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK                  Format = 149
	VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK                   Format = 150
	VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK                  Format = 151
	VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK                   Format = 152
	VK_FORMAT_EAC_R11_UNORM_BLOCK                        Format = 153
	VK_FORMAT_EAC_R11_SNORM_BLOCK                        Format = 154
	VK_FORMAT_EAC_R11G11_UNORM_BLOCK                     Format = 155
	VK_FORMAT_EAC_R11G11_SNORM_BLOCK                     Format = 156
	VK_FORMAT_ASTC_4x4_UNORM_BLOCK                       Format = 157
	VK_FORMAT_ASTC_4x4_SRGB_BLOCK                        Format = 158
	VK_FORMAT_ASTC_5x4_UNORM_BLOCK                       Format = 159
	VK_FORMAT_ASTC_5x4_SRGB_BLOCK                        Format = 160
	VK_FORMAT_ASTC_5x5_UNORM_BLOCK                       Format = 161
	VK_FORMAT_ASTC_5x5_SRGB_BLOCK                        Format = 162
	VK_FORMAT_ASTC_6x5_UNORM_BLOCK                       Format = 163
	VK_FORMAT_ASTC_6x5_SRGB_BLOCK                        Format = 164
	VK_FORMAT_ASTC_6x6_UNORM_BLOCK                       Format = 165
	VK_FORMAT_ASTC_6x6_SRGB_BLOCK                        Format = 166
	VK_FORMAT_ASTC_8x5_UNORM_BLOCK                       Format = 167
	VK_FORMAT_ASTC_8x5_SRGB_BLOCK                        Format = 168
	VK_FORMAT_ASTC_8x6_UNORM_BLOCK                       Format = 169
	VK_FORMAT_ASTC_8x6_SRGB_BLOCK                        Format = 170
	VK_FORMAT_ASTC_8x8_UNORM_BLOCK                       Format = 171
	VK_FORMAT_ASTC_8x8_SRGB_BLOCK                        Format = 172
	VK_FORMAT_ASTC_10x5_UNORM_BLOCK                      Format = 173
	VK_FORMAT_ASTC_10x5_SRGB_BLOCK                       Format = 174
	VK_FORMAT_ASTC_10x6_UNORM_BLOCK                      Format = 175
	VK_FORMAT_ASTC_10x6_SRGB_BLOCK                       Format = 176
	VK_FORMAT_ASTC_10x8_UNORM_BLOCK                      Format = 177
	VK_FORMAT_ASTC_10x8_SRGB_BLOCK                       Format = 178
	VK_FORMAT_ASTC_10x10_UNORM_BLOCK                     Format = 179
	VK_FORMAT_ASTC_10x10_SRGB_BLOCK                      Format = 180
	VK_FORMAT_ASTC_12x10_UNORM_BLOCK                     Format = 181
	VK_FORMAT_ASTC_12x10_SRGB_BLOCK                      Format = 182
	VK_FORMAT_ASTC_12x12_UNORM_BLOCK                     Format = 183
	VK_FORMAT_ASTC_12x12_SRGB_BLOCK                      Format = 184
	VK_FORMAT_G8B8G8R8_422_UNORM                         Format = 1000156000
	VK_FORMAT_B8G8R8G8_422_UNORM                         Format = 1000156001
	VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM                  Format = 1000156002
	VK_FORMAT_G8_B8R8_2PLANE_420_UNORM                   Format = 1000156003
	VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM                  Format = 1000156004
	VK_FORMAT_G8_B8R8_2PLANE_422_UNORM                   Format = 1000156005
	VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM                  Format = 1000156006
	VK_FORMAT_R10X6_UNORM_PACK16                         Format = 1000156007
	VK_FORMAT_R10X6G10X6_UNORM_2PACK16                   Format = 1000156008
	VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16         Format = 1000156009
	VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16     Format = 1000156010
	VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16     Format = 1000156011
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 Format = 1000156012
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16  Format = 1000156013
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 Format = 1000156014
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16  Format = 1000156015
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 Format = 1000156016
	VK_FORMAT_R12X4_UNORM_PACK16                         Format = 1000156017
	VK_FORMAT_R12X4G12X4_UNORM_2PACK16                   Format = 1000156018
	VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16         Format = 1000156019
	VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16     Format = 1000156020
	VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16     Format = 1000156021
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 Format = 1000156022
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16  Format = 1000156023
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 Format = 1000156024
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16  Format = 1000156025
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 Format = 1000156026
	VK_FORMAT_G16B16G16R16_422_UNORM                     Format = 1000156027
	VK_FORMAT_B16G16R16G16_422_UNORM                     Format = 1000156028
	VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM               Format = 1000156029
	VK_FORMAT_G16_B16R16_2PLANE_420_UNORM                Format = 1000156030
	VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM               Format = 1000156031
	VK_FORMAT_G16_B16R16_2PLANE_422_UNORM                Format = 1000156032
	VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM               Format = 1000156033
)

var (
	reverseFormat map[Format]string = map[Format]string{
		VK_FORMAT_UNDEFINED:                                  "VK_FORMAT_UNDEFINED",
		VK_FORMAT_R4G4_UNORM_PACK8:                           "VK_FORMAT_R4G4_UNORM_PACK8",
		VK_FORMAT_R4G4B4A4_UNORM_PACK16:                      "VK_FORMAT_R4G4B4A4_UNORM_PACK16",
		VK_FORMAT_B4G4R4A4_UNORM_PACK16:                      "VK_FORMAT_B4G4R4A4_UNORM_PACK16",
		VK_FORMAT_R5G6B5_UNORM_PACK16:                        "VK_FORMAT_R5G6B5_UNORM_PACK16",
		VK_FORMAT_B5G6R5_UNORM_PACK16:                        "VK_FORMAT_B5G6R5_UNORM_PACK16",
		VK_FORMAT_R5G5B5A1_UNORM_PACK16:                      "VK_FORMAT_R5G5B5A1_UNORM_PACK16",
		VK_FORMAT_B5G5R5A1_UNORM_PACK16:                      "VK_FORMAT_B5G5R5A1_UNORM_PACK16",
		VK_FORMAT_A1R5G5B5_UNORM_PACK16:                      "VK_FORMAT_A1R5G5B5_UNORM_PACK16",
		VK_FORMAT_R8_UNORM:                                   "VK_FORMAT_R8_UNORM",
		VK_FORMAT_R8_SNORM:                                   "VK_FORMAT_R8_SNORM",
		VK_FORMAT_R8_USCALED:                                 "VK_FORMAT_R8_USCALED",
		VK_FORMAT_R8_SSCALED:                                 "VK_FORMAT_R8_SSCALED",
		VK_FORMAT_R8_UINT:                                    "VK_FORMAT_R8_UINT",
		VK_FORMAT_R8_SINT:                                    "VK_FORMAT_R8_SINT",
		VK_FORMAT_R8_SRGB:                                    "VK_FORMAT_R8_SRGB",
		VK_FORMAT_R8G8_UNORM:                                 "VK_FORMAT_R8G8_UNORM",
		VK_FORMAT_R8G8_SNORM:                                 "VK_FORMAT_R8G8_SNORM",
		VK_FORMAT_R8G8_USCALED:                               "VK_FORMAT_R8G8_USCALED",
		VK_FORMAT_R8G8_SSCALED:                               "VK_FORMAT_R8G8_SSCALED",
		VK_FORMAT_R8G8_UINT:                                  "VK_FORMAT_R8G8_UINT",
		VK_FORMAT_R8G8_SINT:                                  "VK_FORMAT_R8G8_SINT",
		VK_FORMAT_R8G8_SRGB:                                  "VK_FORMAT_R8G8_SRGB",
		VK_FORMAT_R8G8B8_UNORM:                               "VK_FORMAT_R8G8B8_UNORM",
		VK_FORMAT_R8G8B8_SNORM:                               "VK_FORMAT_R8G8B8_SNORM",
		VK_FORMAT_R8G8B8_USCALED:                             "VK_FORMAT_R8G8B8_USCALED",
		VK_FORMAT_R8G8B8_SSCALED:                             "VK_FORMAT_R8G8B8_SSCALED",
		VK_FORMAT_R8G8B8_UINT:                                "VK_FORMAT_R8G8B8_UINT",
		VK_FORMAT_R8G8B8_SINT:                                "VK_FORMAT_R8G8B8_SINT",
		VK_FORMAT_R8G8B8_SRGB:                                "VK_FORMAT_R8G8B8_SRGB",
		VK_FORMAT_B8G8R8_UNORM:                               "VK_FORMAT_B8G8R8_UNORM",
		VK_FORMAT_B8G8R8_SNORM:                               "VK_FORMAT_B8G8R8_SNORM",
		VK_FORMAT_B8G8R8_USCALED:                             "VK_FORMAT_B8G8R8_USCALED",
		VK_FORMAT_B8G8R8_SSCALED:                             "VK_FORMAT_B8G8R8_SSCALED",
		VK_FORMAT_B8G8R8_UINT:                                "VK_FORMAT_B8G8R8_UINT",
		VK_FORMAT_B8G8R8_SINT:                                "VK_FORMAT_B8G8R8_SINT",
		VK_FORMAT_B8G8R8_SRGB:                                "VK_FORMAT_B8G8R8_SRGB",
		VK_FORMAT_R8G8B8A8_UNORM:                             "VK_FORMAT_R8G8B8A8_UNORM",
		VK_FORMAT_R8G8B8A8_SNORM:                             "VK_FORMAT_R8G8B8A8_SNORM",
		VK_FORMAT_R8G8B8A8_USCALED:                           "VK_FORMAT_R8G8B8A8_USCALED",
		VK_FORMAT_R8G8B8A8_SSCALED:                           "VK_FORMAT_R8G8B8A8_SSCALED",
		VK_FORMAT_R8G8B8A8_UINT:                              "VK_FORMAT_R8G8B8A8_UINT",
		VK_FORMAT_R8G8B8A8_SINT:                              "VK_FORMAT_R8G8B8A8_SINT",
		VK_FORMAT_R8G8B8A8_SRGB:                              "VK_FORMAT_R8G8B8A8_SRGB",
		VK_FORMAT_B8G8R8A8_UNORM:                             "VK_FORMAT_B8G8R8A8_UNORM",
		VK_FORMAT_B8G8R8A8_SNORM:                             "VK_FORMAT_B8G8R8A8_SNORM",
		VK_FORMAT_B8G8R8A8_USCALED:                           "VK_FORMAT_B8G8R8A8_USCALED",
		VK_FORMAT_B8G8R8A8_SSCALED:                           "VK_FORMAT_B8G8R8A8_SSCALED",
		VK_FORMAT_B8G8R8A8_UINT:                              "VK_FORMAT_B8G8R8A8_UINT",
		VK_FORMAT_B8G8R8A8_SINT:                              "VK_FORMAT_B8G8R8A8_SINT",
		VK_FORMAT_B8G8R8A8_SRGB:                              "VK_FORMAT_B8G8R8A8_SRGB",
		VK_FORMAT_A8B8G8R8_UNORM_PACK32:                      "VK_FORMAT_A8B8G8R8_UNORM_PACK32",
		VK_FORMAT_A8B8G8R8_SNORM_PACK32:                      "VK_FORMAT_A8B8G8R8_SNORM_PACK32",
		VK_FORMAT_A8B8G8R8_USCALED_PACK32:                    "VK_FORMAT_A8B8G8R8_USCALED_PACK32",
		VK_FORMAT_A8B8G8R8_SSCALED_PACK32:                    "VK_FORMAT_A8B8G8R8_SSCALED_PACK32",
		VK_FORMAT_A8B8G8R8_UINT_PACK32:                       "VK_FORMAT_A8B8G8R8_UINT_PACK32",
		VK_FORMAT_A8B8G8R8_SINT_PACK32:                       "VK_FORMAT_A8B8G8R8_SINT_PACK32",
		VK_FORMAT_A8B8G8R8_SRGB_PACK32:                       "VK_FORMAT_A8B8G8R8_SRGB_PACK32",
		VK_FORMAT_A2R10G10B10_UNORM_PACK32:                   "VK_FORMAT_A2R10G10B10_UNORM_PACK32",
		VK_FORMAT_A2R10G10B10_SNORM_PACK32:                   "VK_FORMAT_A2R10G10B10_SNORM_PACK32",
		VK_FORMAT_A2R10G10B10_USCALED_PACK32:                 "VK_FORMAT_A2R10G10B10_USCALED_PACK32",
		VK_FORMAT_A2R10G10B10_SSCALED_PACK32:                 "VK_FORMAT_A2R10G10B10_SSCALED_PACK32",
		VK_FORMAT_A2R10G10B10_UINT_PACK32:                    "VK_FORMAT_A2R10G10B10_UINT_PACK32",
		VK_FORMAT_A2R10G10B10_SINT_PACK32:                    "VK_FORMAT_A2R10G10B10_SINT_PACK32",
		VK_FORMAT_A2B10G10R10_UNORM_PACK32:                   "VK_FORMAT_A2B10G10R10_UNORM_PACK32",
		VK_FORMAT_A2B10G10R10_SNORM_PACK32:                   "VK_FORMAT_A2B10G10R10_SNORM_PACK32",
		VK_FORMAT_A2B10G10R10_USCALED_PACK32:                 "VK_FORMAT_A2B10G10R10_USCALED_PACK32",
		VK_FORMAT_A2B10G10R10_SSCALED_PACK32:                 "VK_FORMAT_A2B10G10R10_SSCALED_PACK32",
		VK_FORMAT_A2B10G10R10_UINT_PACK32:                    "VK_FORMAT_A2B10G10R10_UINT_PACK32",
		VK_FORMAT_A2B10G10R10_SINT_PACK32:                    "VK_FORMAT_A2B10G10R10_SINT_PACK32",
		VK_FORMAT_R16_UNORM:                                  "VK_FORMAT_R16_UNORM",
		VK_FORMAT_R16_SNORM:                                  "VK_FORMAT_R16_SNORM",
		VK_FORMAT_R16_USCALED:                                "VK_FORMAT_R16_USCALED",
		VK_FORMAT_R16_SSCALED:                                "VK_FORMAT_R16_SSCALED",
		VK_FORMAT_R16_UINT:                                   "VK_FORMAT_R16_UINT",
		VK_FORMAT_R16_SINT:                                   "VK_FORMAT_R16_SINT",
		VK_FORMAT_R16_SFLOAT:                                 "VK_FORMAT_R16_SFLOAT",
		VK_FORMAT_R16G16_UNORM:                               "VK_FORMAT_R16G16_UNORM",
		VK_FORMAT_R16G16_SNORM:                               "VK_FORMAT_R16G16_SNORM",
		VK_FORMAT_R16G16_USCALED:                             "VK_FORMAT_R16G16_USCALED",
		VK_FORMAT_R16G16_SSCALED:                             "VK_FORMAT_R16G16_SSCALED",
		VK_FORMAT_R16G16_UINT:                                "VK_FORMAT_R16G16_UINT",
		VK_FORMAT_R16G16_SINT:                                "VK_FORMAT_R16G16_SINT",
		VK_FORMAT_R16G16_SFLOAT:                              "VK_FORMAT_R16G16_SFLOAT",
		VK_FORMAT_R16G16B16_UNORM:                            "VK_FORMAT_R16G16B16_UNORM",
		VK_FORMAT_R16G16B16_SNORM:                            "VK_FORMAT_R16G16B16_SNORM",
		VK_FORMAT_R16G16B16_USCALED:                          "VK_FORMAT_R16G16B16_USCALED",
		VK_FORMAT_R16G16B16_SSCALED:                          "VK_FORMAT_R16G16B16_SSCALED",
		VK_FORMAT_R16G16B16_UINT:                             "VK_FORMAT_R16G16B16_UINT",
		VK_FORMAT_R16G16B16_SINT:                             "VK_FORMAT_R16G16B16_SINT",
		VK_FORMAT_R16G16B16_SFLOAT:                           "VK_FORMAT_R16G16B16_SFLOAT",
		VK_FORMAT_R16G16B16A16_UNORM:                         "VK_FORMAT_R16G16B16A16_UNORM",
		VK_FORMAT_R16G16B16A16_SNORM:                         "VK_FORMAT_R16G16B16A16_SNORM",
		VK_FORMAT_R16G16B16A16_USCALED:                       "VK_FORMAT_R16G16B16A16_USCALED",
		VK_FORMAT_R16G16B16A16_SSCALED:                       "VK_FORMAT_R16G16B16A16_SSCALED",
		VK_FORMAT_R16G16B16A16_UINT:                          "VK_FORMAT_R16G16B16A16_UINT",
		VK_FORMAT_R16G16B16A16_SINT:                          "VK_FORMAT_R16G16B16A16_SINT",
		VK_FORMAT_R16G16B16A16_SFLOAT:                        "VK_FORMAT_R16G16B16A16_SFLOAT",
		VK_FORMAT_R32_UINT:                                   "VK_FORMAT_R32_UINT",
		VK_FORMAT_R32_SINT:                                   "VK_FORMAT_R32_SINT",
		VK_FORMAT_R32_SFLOAT:                                 "VK_FORMAT_R32_SFLOAT",
		VK_FORMAT_R32G32_UINT:                                "VK_FORMAT_R32G32_UINT",
		VK_FORMAT_R32G32_SINT:                                "VK_FORMAT_R32G32_SINT",
		VK_FORMAT_R32G32_SFLOAT:                              "VK_FORMAT_R32G32_SFLOAT",
		VK_FORMAT_R32G32B32_UINT:                             "VK_FORMAT_R32G32B32_UINT",
		VK_FORMAT_R32G32B32_SINT:                             "VK_FORMAT_R32G32B32_SINT",
		VK_FORMAT_R32G32B32_SFLOAT:                           "VK_FORMAT_R32G32B32_SFLOAT",
		VK_FORMAT_R32G32B32A32_UINT:                          "VK_FORMAT_R32G32B32A32_UINT",
		VK_FORMAT_R32G32B32A32_SINT:                          "VK_FORMAT_R32G32B32A32_SINT",
		VK_FORMAT_R32G32B32A32_SFLOAT:                        "VK_FORMAT_R32G32B32A32_SFLOAT",
		VK_FORMAT_R64_UINT:                                   "VK_FORMAT_R64_UINT",
		VK_FORMAT_R64_SINT:                                   "VK_FORMAT_R64_SINT",
		VK_FORMAT_R64_SFLOAT:                                 "VK_FORMAT_R64_SFLOAT",
		VK_FORMAT_R64G64_UINT:                                "VK_FORMAT_R64G64_UINT",
		VK_FORMAT_R64G64_SINT:                                "VK_FORMAT_R64G64_SINT",
		VK_FORMAT_R64G64_SFLOAT:                              "VK_FORMAT_R64G64_SFLOAT",
		VK_FORMAT_R64G64B64_UINT:                             "VK_FORMAT_R64G64B64_UINT",
		VK_FORMAT_R64G64B64_SINT:                             "VK_FORMAT_R64G64B64_SINT",
		VK_FORMAT_R64G64B64_SFLOAT:                           "VK_FORMAT_R64G64B64_SFLOAT",
		VK_FORMAT_R64G64B64A64_UINT:                          "VK_FORMAT_R64G64B64A64_UINT",
		VK_FORMAT_R64G64B64A64_SINT:                          "VK_FORMAT_R64G64B64A64_SINT",
		VK_FORMAT_R64G64B64A64_SFLOAT:                        "VK_FORMAT_R64G64B64A64_SFLOAT",
		VK_FORMAT_B10G11R11_UFLOAT_PACK32:                    "VK_FORMAT_B10G11R11_UFLOAT_PACK32",
		VK_FORMAT_E5B9G9R9_UFLOAT_PACK32:                     "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32",
		VK_FORMAT_D16_UNORM:                                  "VK_FORMAT_D16_UNORM",
		VK_FORMAT_X8_D24_UNORM_PACK32:                        "VK_FORMAT_X8_D24_UNORM_PACK32",
		VK_FORMAT_D32_SFLOAT:                                 "VK_FORMAT_D32_SFLOAT",
		VK_FORMAT_S8_UINT:                                    "VK_FORMAT_S8_UINT",
		VK_FORMAT_D16_UNORM_S8_UINT:                          "VK_FORMAT_D16_UNORM_S8_UINT",
		VK_FORMAT_D24_UNORM_S8_UINT:                          "VK_FORMAT_D24_UNORM_S8_UINT",
		VK_FORMAT_D32_SFLOAT_S8_UINT:                         "VK_FORMAT_D32_SFLOAT_S8_UINT",
		VK_FORMAT_BC1_RGB_UNORM_BLOCK:                        "VK_FORMAT_BC1_RGB_UNORM_BLOCK",
		VK_FORMAT_BC1_RGB_SRGB_BLOCK:                         "VK_FORMAT_BC1_RGB_SRGB_BLOCK",
		VK_FORMAT_BC1_RGBA_UNORM_BLOCK:                       "VK_FORMAT_BC1_RGBA_UNORM_BLOCK",
		VK_FORMAT_BC1_RGBA_SRGB_BLOCK:                        "VK_FORMAT_BC1_RGBA_SRGB_BLOCK",
		VK_FORMAT_BC2_UNORM_BLOCK:                            "VK_FORMAT_BC2_UNORM_BLOCK",
		VK_FORMAT_BC2_SRGB_BLOCK:                             "VK_FORMAT_BC2_SRGB_BLOCK",
		VK_FORMAT_BC3_UNORM_BLOCK:                            "VK_FORMAT_BC3_UNORM_BLOCK",
		VK_FORMAT_BC3_SRGB_BLOCK:                             "VK_FORMAT_BC3_SRGB_BLOCK",
		VK_FORMAT_BC4_UNORM_BLOCK:                            "VK_FORMAT_BC4_UNORM_BLOCK",
		VK_FORMAT_BC4_SNORM_BLOCK:                            "VK_FORMAT_BC4_SNORM_BLOCK",
		VK_FORMAT_BC5_UNORM_BLOCK:                            "VK_FORMAT_BC5_UNORM_BLOCK",
		VK_FORMAT_BC5_SNORM_BLOCK:                            "VK_FORMAT_BC5_SNORM_BLOCK",
		VK_FORMAT_BC6H_UFLOAT_BLOCK:                          "VK_FORMAT_BC6H_UFLOAT_BLOCK",
		VK_FORMAT_BC6H_SFLOAT_BLOCK:                          "VK_FORMAT_BC6H_SFLOAT_BLOCK",
		VK_FORMAT_BC7_UNORM_BLOCK:                            "VK_FORMAT_BC7_UNORM_BLOCK",
		VK_FORMAT_BC7_SRGB_BLOCK:                             "VK_FORMAT_BC7_SRGB_BLOCK",
		VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK:                    "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK",
		VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK:                     "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK",
		VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK:                  "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK",
		VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK:                   "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK",
		VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK:                  "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK",
		VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK:                   "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK",
		VK_FORMAT_EAC_R11_UNORM_BLOCK:                        "VK_FORMAT_EAC_R11_UNORM_BLOCK",
		VK_FORMAT_EAC_R11_SNORM_BLOCK:                        "VK_FORMAT_EAC_R11_SNORM_BLOCK",
		VK_FORMAT_EAC_R11G11_UNORM_BLOCK:                     "VK_FORMAT_EAC_R11G11_UNORM_BLOCK",
		VK_FORMAT_EAC_R11G11_SNORM_BLOCK:                     "VK_FORMAT_EAC_R11G11_SNORM_BLOCK",
		VK_FORMAT_ASTC_4x4_UNORM_BLOCK:                       "VK_FORMAT_ASTC_4x4_UNORM_BLOCK",
		VK_FORMAT_ASTC_4x4_SRGB_BLOCK:                        "VK_FORMAT_ASTC_4x4_SRGB_BLOCK",
		VK_FORMAT_ASTC_5x4_UNORM_BLOCK:                       "VK_FORMAT_ASTC_5x4_UNORM_BLOCK",
		VK_FORMAT_ASTC_5x4_SRGB_BLOCK:                        "VK_FORMAT_ASTC_5x4_SRGB_BLOCK",
		VK_FORMAT_ASTC_5x5_UNORM_BLOCK:                       "VK_FORMAT_ASTC_5x5_UNORM_BLOCK",
		VK_FORMAT_ASTC_5x5_SRGB_BLOCK:                        "VK_FORMAT_ASTC_5x5_SRGB_BLOCK",
		VK_FORMAT_ASTC_6x5_UNORM_BLOCK:                       "VK_FORMAT_ASTC_6x5_UNORM_BLOCK",
		VK_FORMAT_ASTC_6x5_SRGB_BLOCK:                        "VK_FORMAT_ASTC_6x5_SRGB_BLOCK",
		VK_FORMAT_ASTC_6x6_UNORM_BLOCK:                       "VK_FORMAT_ASTC_6x6_UNORM_BLOCK",
		VK_FORMAT_ASTC_6x6_SRGB_BLOCK:                        "VK_FORMAT_ASTC_6x6_SRGB_BLOCK",
		VK_FORMAT_ASTC_8x5_UNORM_BLOCK:                       "VK_FORMAT_ASTC_8x5_UNORM_BLOCK",
		VK_FORMAT_ASTC_8x5_SRGB_BLOCK:                        "VK_FORMAT_ASTC_8x5_SRGB_BLOCK",
		VK_FORMAT_ASTC_8x6_UNORM_BLOCK:                       "VK_FORMAT_ASTC_8x6_UNORM_BLOCK",
		VK_FORMAT_ASTC_8x6_SRGB_BLOCK:                        "VK_FORMAT_ASTC_8x6_SRGB_BLOCK",
		VK_FORMAT_ASTC_8x8_UNORM_BLOCK:                       "VK_FORMAT_ASTC_8x8_UNORM_BLOCK",
		VK_FORMAT_ASTC_8x8_SRGB_BLOCK:                        "VK_FORMAT_ASTC_8x8_SRGB_BLOCK",
		VK_FORMAT_ASTC_10x5_UNORM_BLOCK:                      "VK_FORMAT_ASTC_10x5_UNORM_BLOCK",
		VK_FORMAT_ASTC_10x5_SRGB_BLOCK:                       "VK_FORMAT_ASTC_10x5_SRGB_BLOCK",
		VK_FORMAT_ASTC_10x6_UNORM_BLOCK:                      "VK_FORMAT_ASTC_10x6_UNORM_BLOCK",
		VK_FORMAT_ASTC_10x6_SRGB_BLOCK:                       "VK_FORMAT_ASTC_10x6_SRGB_BLOCK",
		VK_FORMAT_ASTC_10x8_UNORM_BLOCK:                      "VK_FORMAT_ASTC_10x8_UNORM_BLOCK",
		VK_FORMAT_ASTC_10x8_SRGB_BLOCK:                       "VK_FORMAT_ASTC_10x8_SRGB_BLOCK",
		VK_FORMAT_ASTC_10x10_UNORM_BLOCK:                     "VK_FORMAT_ASTC_10x10_UNORM_BLOCK",
		VK_FORMAT_ASTC_10x10_SRGB_BLOCK:                      "VK_FORMAT_ASTC_10x10_SRGB_BLOCK",
		VK_FORMAT_ASTC_12x10_UNORM_BLOCK:                     "VK_FORMAT_ASTC_12x10_UNORM_BLOCK",
		VK_FORMAT_ASTC_12x10_SRGB_BLOCK:                      "VK_FORMAT_ASTC_12x10_SRGB_BLOCK",
		VK_FORMAT_ASTC_12x12_UNORM_BLOCK:                     "VK_FORMAT_ASTC_12x12_UNORM_BLOCK",
		VK_FORMAT_ASTC_12x12_SRGB_BLOCK:                      "VK_FORMAT_ASTC_12x12_SRGB_BLOCK",
		VK_FORMAT_G8B8G8R8_422_UNORM:                         "VK_FORMAT_G8B8G8R8_422_UNORM",
		VK_FORMAT_B8G8R8G8_422_UNORM:                         "VK_FORMAT_B8G8R8G8_422_UNORM",
		VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM:                  "VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM",
		VK_FORMAT_G8_B8R8_2PLANE_420_UNORM:                   "VK_FORMAT_G8_B8R8_2PLANE_420_UNORM",
		VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM:                  "VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM",
		VK_FORMAT_G8_B8R8_2PLANE_422_UNORM:                   "VK_FORMAT_G8_B8R8_2PLANE_422_UNORM",
		VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM:                  "VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM",
		VK_FORMAT_R10X6_UNORM_PACK16:                         "VK_FORMAT_R10X6_UNORM_PACK16",
		VK_FORMAT_R10X6G10X6_UNORM_2PACK16:                   "VK_FORMAT_R10X6G10X6_UNORM_2PACK16",
		VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16:         "VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16",
		VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16:     "VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16",
		VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16:     "VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16",
		VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16: "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16",
		VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16:  "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16",
		VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16: "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16",
		VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16:  "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16",
		VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16: "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16",
		VK_FORMAT_R12X4_UNORM_PACK16:                         "VK_FORMAT_R12X4_UNORM_PACK16",
		VK_FORMAT_R12X4G12X4_UNORM_2PACK16:                   "VK_FORMAT_R12X4G12X4_UNORM_2PACK16",
		VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16:         "VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16",
		VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16:     "VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16",
		VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16:     "VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16",
		VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16: "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16",
		VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16:  "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16",
		VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16: "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16",
		VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16:  "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16",
		VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16: "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16",
		VK_FORMAT_G16B16G16R16_422_UNORM:                     "VK_FORMAT_G16B16G16R16_422_UNORM",
		VK_FORMAT_B16G16R16G16_422_UNORM:                     "VK_FORMAT_B16G16R16G16_422_UNORM",
		VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM:               "VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM",
		VK_FORMAT_G16_B16R16_2PLANE_420_UNORM:                "VK_FORMAT_G16_B16R16_2PLANE_420_UNORM",
		VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM:               "VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM",
		VK_FORMAT_G16_B16R16_2PLANE_422_UNORM:                "VK_FORMAT_G16_B16R16_2PLANE_422_UNORM",
		VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM:               "VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM",
	}
)

func (x Format) String() string {
	if s, ok := reverseFormat[x]; ok {
		return s
	}
	return fmt.Sprintf("Format=%d", x)
}

// FormatFeatureFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFormatFeatureFlagBits.html
type FormatFeatureFlagBits uint32

const (
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT                                                           FormatFeatureFlagBits = (1 << 0)
	VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT                                                           FormatFeatureFlagBits = (1 << 1)
	VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT                                                    FormatFeatureFlagBits = (1 << 2)
	VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT                                                    FormatFeatureFlagBits = (1 << 3)
	VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT                                                    FormatFeatureFlagBits = (1 << 4)
	VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT                                             FormatFeatureFlagBits = (1 << 5)
	VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT                                                           FormatFeatureFlagBits = (1 << 6)
	VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT                                                        FormatFeatureFlagBits = (1 << 7)
	VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT                                                  FormatFeatureFlagBits = (1 << 8)
	VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT                                                FormatFeatureFlagBits = (1 << 9)
	VK_FORMAT_FEATURE_BLIT_SRC_BIT                                                                FormatFeatureFlagBits = (1 << 10)
	VK_FORMAT_FEATURE_BLIT_DST_BIT                                                                FormatFeatureFlagBits = (1 << 11)
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT                                             FormatFeatureFlagBits = (1 << 12)
	VK_FORMAT_FEATURE_TRANSFER_SRC_BIT                                                            FormatFeatureFlagBits = (1 << 14)
	VK_FORMAT_FEATURE_TRANSFER_DST_BIT                                                            FormatFeatureFlagBits = (1 << 15)
	VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT                                                 FormatFeatureFlagBits = (1 << 17)
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT                            FormatFeatureFlagBits = (1 << 18)
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT           FormatFeatureFlagBits = (1 << 19)
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT           FormatFeatureFlagBits = (1 << 20)
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT FormatFeatureFlagBits = (1 << 21)
	VK_FORMAT_FEATURE_DISJOINT_BIT                                                                FormatFeatureFlagBits = (1 << 22)
	VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT                                                  FormatFeatureFlagBits = (1 << 23)
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT                                             FormatFeatureFlagBits = (1 << 16)
)

var (
	reverseFormatFeatureFlagBits map[FormatFeatureFlagBits]string = map[FormatFeatureFlagBits]string{
		VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT:                                                           "VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT",
		VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT:                                                           "VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT",
		VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT:                                                    "VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT",
		VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT:                                                    "VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT",
		VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT:                                                    "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT",
		VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT:                                             "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT",
		VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT:                                                           "VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT",
		VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT:                                                        "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT",
		VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT:                                                  "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT",
		VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT:                                                "VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT",
		VK_FORMAT_FEATURE_BLIT_SRC_BIT:                                                                "VK_FORMAT_FEATURE_BLIT_SRC_BIT",
		VK_FORMAT_FEATURE_BLIT_DST_BIT:                                                                "VK_FORMAT_FEATURE_BLIT_DST_BIT",
		VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT:                                             "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT",
		VK_FORMAT_FEATURE_TRANSFER_SRC_BIT:                                                            "VK_FORMAT_FEATURE_TRANSFER_SRC_BIT",
		VK_FORMAT_FEATURE_TRANSFER_DST_BIT:                                                            "VK_FORMAT_FEATURE_TRANSFER_DST_BIT",
		VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT:                                                 "VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT",
		VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT:                            "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT",
		VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT:           "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT",
		VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT:           "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT",
		VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT: "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT",
		VK_FORMAT_FEATURE_DISJOINT_BIT:                                                                "VK_FORMAT_FEATURE_DISJOINT_BIT",
		VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT:                                                  "VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT",
		VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT:                                             "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT",
	}
)

func (x FormatFeatureFlagBits) String() string {
	if s, ok := reverseFormatFeatureFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("FormatFeatureFlagBits=%d", x)
}

// AttachmentDescriptionFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkAttachmentDescriptionFlagBits.html
type AttachmentDescriptionFlagBits uint32

const (
	VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT AttachmentDescriptionFlagBits = (1 << 0)
)

var (
	reverseAttachmentDescriptionFlagBits map[AttachmentDescriptionFlagBits]string = map[AttachmentDescriptionFlagBits]string{
		VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT: "VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT",
	}
)

func (x AttachmentDescriptionFlagBits) String() string {
	if s, ok := reverseAttachmentDescriptionFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("AttachmentDescriptionFlagBits=%d", x)
}

// FrontFace is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFrontFace.html
type FrontFace uint32

const (
	VK_FRONT_FACE_COUNTER_CLOCKWISE FrontFace = 0
	VK_FRONT_FACE_CLOCKWISE         FrontFace = 1
)

var (
	reverseFrontFace map[FrontFace]string = map[FrontFace]string{
		VK_FRONT_FACE_COUNTER_CLOCKWISE: "VK_FRONT_FACE_COUNTER_CLOCKWISE",
		VK_FRONT_FACE_CLOCKWISE:         "VK_FRONT_FACE_CLOCKWISE",
	}
)

func (x FrontFace) String() string {
	if s, ok := reverseFrontFace[x]; ok {
		return s
	}
	return fmt.Sprintf("FrontFace=%d", x)
}

// ImageCreateFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageCreateFlagBits.html
type ImageCreateFlagBits uint32

const (
	VK_IMAGE_CREATE_SPARSE_BINDING_BIT              ImageCreateFlagBits = (1 << 0)
	VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT            ImageCreateFlagBits = (1 << 1)
	VK_IMAGE_CREATE_SPARSE_ALIASED_BIT              ImageCreateFlagBits = (1 << 2)
	VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT              ImageCreateFlagBits = (1 << 3)
	VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT             ImageCreateFlagBits = (1 << 4)
	VK_IMAGE_CREATE_ALIAS_BIT                       ImageCreateFlagBits = (1 << 10)
	VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT ImageCreateFlagBits = (1 << 6)
	VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT         ImageCreateFlagBits = (1 << 5)
	VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT ImageCreateFlagBits = (1 << 7)
	VK_IMAGE_CREATE_EXTENDED_USAGE_BIT              ImageCreateFlagBits = (1 << 8)
	VK_IMAGE_CREATE_PROTECTED_BIT                   ImageCreateFlagBits = (1 << 11)
	VK_IMAGE_CREATE_DISJOINT_BIT                    ImageCreateFlagBits = (1 << 9)
)

var (
	reverseImageCreateFlagBits map[ImageCreateFlagBits]string = map[ImageCreateFlagBits]string{
		VK_IMAGE_CREATE_SPARSE_BINDING_BIT:              "VK_IMAGE_CREATE_SPARSE_BINDING_BIT",
		VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT:            "VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT",
		VK_IMAGE_CREATE_SPARSE_ALIASED_BIT:              "VK_IMAGE_CREATE_SPARSE_ALIASED_BIT",
		VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT:              "VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT",
		VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT:             "VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT",
		VK_IMAGE_CREATE_ALIAS_BIT:                       "VK_IMAGE_CREATE_ALIAS_BIT",
		VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT: "VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT",
		VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT:         "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT",
		VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT: "VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT",
		VK_IMAGE_CREATE_EXTENDED_USAGE_BIT:              "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT",
		VK_IMAGE_CREATE_PROTECTED_BIT:                   "VK_IMAGE_CREATE_PROTECTED_BIT",
		VK_IMAGE_CREATE_DISJOINT_BIT:                    "VK_IMAGE_CREATE_DISJOINT_BIT",
	}
)

func (x ImageCreateFlagBits) String() string {
	if s, ok := reverseImageCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ImageCreateFlagBits=%d", x)
}

// SparseImageFormatFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSparseImageFormatFlagBits.html
type SparseImageFormatFlagBits uint32

const (
	VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT         SparseImageFormatFlagBits = (1 << 0)
	VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT       SparseImageFormatFlagBits = (1 << 1)
	VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT SparseImageFormatFlagBits = (1 << 2)
)

var (
	reverseSparseImageFormatFlagBits map[SparseImageFormatFlagBits]string = map[SparseImageFormatFlagBits]string{
		VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT:         "VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT",
		VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT:       "VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT",
		VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT: "VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT",
	}
)

func (x SparseImageFormatFlagBits) String() string {
	if s, ok := reverseSparseImageFormatFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("SparseImageFormatFlagBits=%d", x)
}

// DynamicState is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDynamicState.html
type DynamicState uint32

const (
	VK_DYNAMIC_STATE_VIEWPORT             DynamicState = 0
	VK_DYNAMIC_STATE_SCISSOR              DynamicState = 1
	VK_DYNAMIC_STATE_LINE_WIDTH           DynamicState = 2
	VK_DYNAMIC_STATE_DEPTH_BIAS           DynamicState = 3
	VK_DYNAMIC_STATE_BLEND_CONSTANTS      DynamicState = 4
	VK_DYNAMIC_STATE_DEPTH_BOUNDS         DynamicState = 5
	VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK DynamicState = 6
	VK_DYNAMIC_STATE_STENCIL_WRITE_MASK   DynamicState = 7
	VK_DYNAMIC_STATE_STENCIL_REFERENCE    DynamicState = 8
)

var (
	reverseDynamicState map[DynamicState]string = map[DynamicState]string{
		VK_DYNAMIC_STATE_VIEWPORT:             "VK_DYNAMIC_STATE_VIEWPORT",
		VK_DYNAMIC_STATE_SCISSOR:              "VK_DYNAMIC_STATE_SCISSOR",
		VK_DYNAMIC_STATE_LINE_WIDTH:           "VK_DYNAMIC_STATE_LINE_WIDTH",
		VK_DYNAMIC_STATE_DEPTH_BIAS:           "VK_DYNAMIC_STATE_DEPTH_BIAS",
		VK_DYNAMIC_STATE_BLEND_CONSTANTS:      "VK_DYNAMIC_STATE_BLEND_CONSTANTS",
		VK_DYNAMIC_STATE_DEPTH_BOUNDS:         "VK_DYNAMIC_STATE_DEPTH_BOUNDS",
		VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK: "VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK",
		VK_DYNAMIC_STATE_STENCIL_WRITE_MASK:   "VK_DYNAMIC_STATE_STENCIL_WRITE_MASK",
		VK_DYNAMIC_STATE_STENCIL_REFERENCE:    "VK_DYNAMIC_STATE_STENCIL_REFERENCE",
	}
)

func (x DynamicState) String() string {
	if s, ok := reverseDynamicState[x]; ok {
		return s
	}
	return fmt.Sprintf("DynamicState=%d", x)
}

// VendorId is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVendorId.html
type VendorId uint32

const (
	VK_VENDOR_ID_VIV      VendorId = 0x10001
	VK_VENDOR_ID_VSI      VendorId = 0x10002
	VK_VENDOR_ID_KAZAN    VendorId = 0x10003
	VK_VENDOR_ID_CODEPLAY VendorId = 0x10004
	VK_VENDOR_ID_MESA     VendorId = 0x10005
	VK_VENDOR_ID_POCL     VendorId = 0x10006
)

var (
	reverseVendorId map[VendorId]string = map[VendorId]string{
		VK_VENDOR_ID_VIV:      "VK_VENDOR_ID_VIV",
		VK_VENDOR_ID_VSI:      "VK_VENDOR_ID_VSI",
		VK_VENDOR_ID_KAZAN:    "VK_VENDOR_ID_KAZAN",
		VK_VENDOR_ID_CODEPLAY: "VK_VENDOR_ID_CODEPLAY",
		VK_VENDOR_ID_MESA:     "VK_VENDOR_ID_MESA",
		VK_VENDOR_ID_POCL:     "VK_VENDOR_ID_POCL",
	}
)

func (x VendorId) String() string {
	if s, ok := reverseVendorId[x]; ok {
		return s
	}
	return fmt.Sprintf("VendorId=%d", x)
}

// ImageType is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageType.html
type ImageType uint32

const (
	VK_IMAGE_TYPE_1D ImageType = 0
	VK_IMAGE_TYPE_2D ImageType = 1
	VK_IMAGE_TYPE_3D ImageType = 2
)

var (
	reverseImageType map[ImageType]string = map[ImageType]string{
		VK_IMAGE_TYPE_1D: "VK_IMAGE_TYPE_1D",
		VK_IMAGE_TYPE_2D: "VK_IMAGE_TYPE_2D",
		VK_IMAGE_TYPE_3D: "VK_IMAGE_TYPE_3D",
	}
)

func (x ImageType) String() string {
	if s, ok := reverseImageType[x]; ok {
		return s
	}
	return fmt.Sprintf("ImageType=%d", x)
}

// ImageUsageFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageUsageFlagBits.html
type ImageUsageFlagBits uint32

const (
	VK_IMAGE_USAGE_TRANSFER_SRC_BIT             ImageUsageFlagBits = (1 << 0)
	VK_IMAGE_USAGE_TRANSFER_DST_BIT             ImageUsageFlagBits = (1 << 1)
	VK_IMAGE_USAGE_SAMPLED_BIT                  ImageUsageFlagBits = (1 << 2)
	VK_IMAGE_USAGE_STORAGE_BIT                  ImageUsageFlagBits = (1 << 3)
	VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT         ImageUsageFlagBits = (1 << 4)
	VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT ImageUsageFlagBits = (1 << 5)
	VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT     ImageUsageFlagBits = (1 << 6)
	VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT         ImageUsageFlagBits = (1 << 7)
)

var (
	reverseImageUsageFlagBits map[ImageUsageFlagBits]string = map[ImageUsageFlagBits]string{
		VK_IMAGE_USAGE_TRANSFER_SRC_BIT:             "VK_IMAGE_USAGE_TRANSFER_SRC_BIT",
		VK_IMAGE_USAGE_TRANSFER_DST_BIT:             "VK_IMAGE_USAGE_TRANSFER_DST_BIT",
		VK_IMAGE_USAGE_SAMPLED_BIT:                  "VK_IMAGE_USAGE_SAMPLED_BIT",
		VK_IMAGE_USAGE_STORAGE_BIT:                  "VK_IMAGE_USAGE_STORAGE_BIT",
		VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT:         "VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT",
		VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT: "VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT",
		VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT:     "VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT",
		VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT:         "VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT",
	}
)

func (x ImageUsageFlagBits) String() string {
	if s, ok := reverseImageUsageFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ImageUsageFlagBits=%d", x)
}

// ImageAspectFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageAspectFlagBits.html
type ImageAspectFlagBits uint32

const (
	VK_IMAGE_ASPECT_COLOR_BIT    ImageAspectFlagBits = (1 << 0)
	VK_IMAGE_ASPECT_DEPTH_BIT    ImageAspectFlagBits = (1 << 1)
	VK_IMAGE_ASPECT_STENCIL_BIT  ImageAspectFlagBits = (1 << 2)
	VK_IMAGE_ASPECT_METADATA_BIT ImageAspectFlagBits = (1 << 3)
	VK_IMAGE_ASPECT_PLANE_0_BIT  ImageAspectFlagBits = (1 << 4)
	VK_IMAGE_ASPECT_PLANE_1_BIT  ImageAspectFlagBits = (1 << 5)
	VK_IMAGE_ASPECT_PLANE_2_BIT  ImageAspectFlagBits = (1 << 6)
)

var (
	reverseImageAspectFlagBits map[ImageAspectFlagBits]string = map[ImageAspectFlagBits]string{
		VK_IMAGE_ASPECT_COLOR_BIT:    "VK_IMAGE_ASPECT_COLOR_BIT",
		VK_IMAGE_ASPECT_DEPTH_BIT:    "VK_IMAGE_ASPECT_DEPTH_BIT",
		VK_IMAGE_ASPECT_STENCIL_BIT:  "VK_IMAGE_ASPECT_STENCIL_BIT",
		VK_IMAGE_ASPECT_METADATA_BIT: "VK_IMAGE_ASPECT_METADATA_BIT",
		VK_IMAGE_ASPECT_PLANE_0_BIT:  "VK_IMAGE_ASPECT_PLANE_0_BIT",
		VK_IMAGE_ASPECT_PLANE_1_BIT:  "VK_IMAGE_ASPECT_PLANE_1_BIT",
		VK_IMAGE_ASPECT_PLANE_2_BIT:  "VK_IMAGE_ASPECT_PLANE_2_BIT",
	}
)

func (x ImageAspectFlagBits) String() string {
	if s, ok := reverseImageAspectFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ImageAspectFlagBits=%d", x)
}

// ObjectType is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkObjectType.html
type ObjectType uint32

const (
	VK_OBJECT_TYPE_UNKNOWN                    ObjectType = 0
	VK_OBJECT_TYPE_INSTANCE                   ObjectType = 1
	VK_OBJECT_TYPE_PHYSICAL_DEVICE            ObjectType = 2
	VK_OBJECT_TYPE_DEVICE                     ObjectType = 3
	VK_OBJECT_TYPE_QUEUE                      ObjectType = 4
	VK_OBJECT_TYPE_SEMAPHORE                  ObjectType = 5
	VK_OBJECT_TYPE_COMMAND_BUFFER             ObjectType = 6
	VK_OBJECT_TYPE_FENCE                      ObjectType = 7
	VK_OBJECT_TYPE_DEVICE_MEMORY              ObjectType = 8
	VK_OBJECT_TYPE_BUFFER                     ObjectType = 9
	VK_OBJECT_TYPE_IMAGE                      ObjectType = 10
	VK_OBJECT_TYPE_EVENT                      ObjectType = 11
	VK_OBJECT_TYPE_QUERY_POOL                 ObjectType = 12
	VK_OBJECT_TYPE_BUFFER_VIEW                ObjectType = 13
	VK_OBJECT_TYPE_IMAGE_VIEW                 ObjectType = 14
	VK_OBJECT_TYPE_SHADER_MODULE              ObjectType = 15
	VK_OBJECT_TYPE_PIPELINE_CACHE             ObjectType = 16
	VK_OBJECT_TYPE_PIPELINE_LAYOUT            ObjectType = 17
	VK_OBJECT_TYPE_RENDER_PASS                ObjectType = 18
	VK_OBJECT_TYPE_PIPELINE                   ObjectType = 19
	VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT      ObjectType = 20
	VK_OBJECT_TYPE_SAMPLER                    ObjectType = 21
	VK_OBJECT_TYPE_DESCRIPTOR_POOL            ObjectType = 22
	VK_OBJECT_TYPE_DESCRIPTOR_SET             ObjectType = 23
	VK_OBJECT_TYPE_FRAMEBUFFER                ObjectType = 24
	VK_OBJECT_TYPE_COMMAND_POOL               ObjectType = 25
	VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION   ObjectType = 1000156000
	VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE ObjectType = 1000085000
	VK_OBJECT_TYPE_SURFACE_KHR                ObjectType = 1000000000
	VK_OBJECT_TYPE_SWAPCHAIN_KHR              ObjectType = 1000001000
	VK_OBJECT_TYPE_DISPLAY_KHR                ObjectType = 1000002000
	VK_OBJECT_TYPE_DISPLAY_MODE_KHR           ObjectType = 1000002001
)

var (
	reverseObjectType map[ObjectType]string = map[ObjectType]string{
		VK_OBJECT_TYPE_UNKNOWN:                    "VK_OBJECT_TYPE_UNKNOWN",
		VK_OBJECT_TYPE_INSTANCE:                   "VK_OBJECT_TYPE_INSTANCE",
		VK_OBJECT_TYPE_PHYSICAL_DEVICE:            "VK_OBJECT_TYPE_PHYSICAL_DEVICE",
		VK_OBJECT_TYPE_DEVICE:                     "VK_OBJECT_TYPE_DEVICE",
		VK_OBJECT_TYPE_QUEUE:                      "VK_OBJECT_TYPE_QUEUE",
		VK_OBJECT_TYPE_SEMAPHORE:                  "VK_OBJECT_TYPE_SEMAPHORE",
		VK_OBJECT_TYPE_COMMAND_BUFFER:             "VK_OBJECT_TYPE_COMMAND_BUFFER",
		VK_OBJECT_TYPE_FENCE:                      "VK_OBJECT_TYPE_FENCE",
		VK_OBJECT_TYPE_DEVICE_MEMORY:              "VK_OBJECT_TYPE_DEVICE_MEMORY",
		VK_OBJECT_TYPE_BUFFER:                     "VK_OBJECT_TYPE_BUFFER",
		VK_OBJECT_TYPE_IMAGE:                      "VK_OBJECT_TYPE_IMAGE",
		VK_OBJECT_TYPE_EVENT:                      "VK_OBJECT_TYPE_EVENT",
		VK_OBJECT_TYPE_QUERY_POOL:                 "VK_OBJECT_TYPE_QUERY_POOL",
		VK_OBJECT_TYPE_BUFFER_VIEW:                "VK_OBJECT_TYPE_BUFFER_VIEW",
		VK_OBJECT_TYPE_IMAGE_VIEW:                 "VK_OBJECT_TYPE_IMAGE_VIEW",
		VK_OBJECT_TYPE_SHADER_MODULE:              "VK_OBJECT_TYPE_SHADER_MODULE",
		VK_OBJECT_TYPE_PIPELINE_CACHE:             "VK_OBJECT_TYPE_PIPELINE_CACHE",
		VK_OBJECT_TYPE_PIPELINE_LAYOUT:            "VK_OBJECT_TYPE_PIPELINE_LAYOUT",
		VK_OBJECT_TYPE_RENDER_PASS:                "VK_OBJECT_TYPE_RENDER_PASS",
		VK_OBJECT_TYPE_PIPELINE:                   "VK_OBJECT_TYPE_PIPELINE",
		VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT:      "VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT",
		VK_OBJECT_TYPE_SAMPLER:                    "VK_OBJECT_TYPE_SAMPLER",
		VK_OBJECT_TYPE_DESCRIPTOR_POOL:            "VK_OBJECT_TYPE_DESCRIPTOR_POOL",
		VK_OBJECT_TYPE_DESCRIPTOR_SET:             "VK_OBJECT_TYPE_DESCRIPTOR_SET",
		VK_OBJECT_TYPE_FRAMEBUFFER:                "VK_OBJECT_TYPE_FRAMEBUFFER",
		VK_OBJECT_TYPE_COMMAND_POOL:               "VK_OBJECT_TYPE_COMMAND_POOL",
		VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION:   "VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION",
		VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE: "VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE",
		VK_OBJECT_TYPE_SURFACE_KHR:                "VK_OBJECT_TYPE_SURFACE_KHR",
		VK_OBJECT_TYPE_SWAPCHAIN_KHR:              "VK_OBJECT_TYPE_SWAPCHAIN_KHR",
		VK_OBJECT_TYPE_DISPLAY_KHR:                "VK_OBJECT_TYPE_DISPLAY_KHR",
		VK_OBJECT_TYPE_DISPLAY_MODE_KHR:           "VK_OBJECT_TYPE_DISPLAY_MODE_KHR",
	}
)

func (x ObjectType) String() string {
	if s, ok := reverseObjectType[x]; ok {
		return s
	}
	return fmt.Sprintf("ObjectType=%d", x)
}

// PipelineShaderStageCreateFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineShaderStageCreateFlagBits.html
type PipelineShaderStageCreateFlagBits uint32

// CullModeFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCullModeFlagBits.html
type CullModeFlagBits uint32

const (
	VK_CULL_MODE_NONE           CullModeFlagBits = 0
	VK_CULL_MODE_FRONT_BIT      CullModeFlagBits = (1 << 0)
	VK_CULL_MODE_BACK_BIT       CullModeFlagBits = (1 << 1)
	VK_CULL_MODE_FRONT_AND_BACK CullModeFlagBits = 0x00000003
)

var (
	reverseCullModeFlagBits map[CullModeFlagBits]string = map[CullModeFlagBits]string{
		VK_CULL_MODE_NONE:           "VK_CULL_MODE_NONE",
		VK_CULL_MODE_FRONT_BIT:      "VK_CULL_MODE_FRONT_BIT",
		VK_CULL_MODE_BACK_BIT:       "VK_CULL_MODE_BACK_BIT",
		VK_CULL_MODE_FRONT_AND_BACK: "VK_CULL_MODE_FRONT_AND_BACK",
	}
)

func (x CullModeFlagBits) String() string {
	if s, ok := reverseCullModeFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("CullModeFlagBits=%d", x)
}

// InternalAllocationType is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkInternalAllocationType.html
type InternalAllocationType uint32

const (
	VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE InternalAllocationType = 0
)

var (
	reverseInternalAllocationType map[InternalAllocationType]string = map[InternalAllocationType]string{
		VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE: "VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE",
	}
)

func (x InternalAllocationType) String() string {
	if s, ok := reverseInternalAllocationType[x]; ok {
		return s
	}
	return fmt.Sprintf("InternalAllocationType=%d", x)
}

// CompareOp is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCompareOp.html
type CompareOp uint32

const (
	VK_COMPARE_OP_NEVER            CompareOp = 0
	VK_COMPARE_OP_LESS             CompareOp = 1
	VK_COMPARE_OP_EQUAL            CompareOp = 2
	VK_COMPARE_OP_LESS_OR_EQUAL    CompareOp = 3
	VK_COMPARE_OP_GREATER          CompareOp = 4
	VK_COMPARE_OP_NOT_EQUAL        CompareOp = 5
	VK_COMPARE_OP_GREATER_OR_EQUAL CompareOp = 6
	VK_COMPARE_OP_ALWAYS           CompareOp = 7
)

var (
	reverseCompareOp map[CompareOp]string = map[CompareOp]string{
		VK_COMPARE_OP_NEVER:            "VK_COMPARE_OP_NEVER",
		VK_COMPARE_OP_LESS:             "VK_COMPARE_OP_LESS",
		VK_COMPARE_OP_EQUAL:            "VK_COMPARE_OP_EQUAL",
		VK_COMPARE_OP_LESS_OR_EQUAL:    "VK_COMPARE_OP_LESS_OR_EQUAL",
		VK_COMPARE_OP_GREATER:          "VK_COMPARE_OP_GREATER",
		VK_COMPARE_OP_NOT_EQUAL:        "VK_COMPARE_OP_NOT_EQUAL",
		VK_COMPARE_OP_GREATER_OR_EQUAL: "VK_COMPARE_OP_GREATER_OR_EQUAL",
		VK_COMPARE_OP_ALWAYS:           "VK_COMPARE_OP_ALWAYS",
	}
)

func (x CompareOp) String() string {
	if s, ok := reverseCompareOp[x]; ok {
		return s
	}
	return fmt.Sprintf("CompareOp=%d", x)
}

// MemoryHeapFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkMemoryHeapFlagBits.html
type MemoryHeapFlagBits uint32

const (
	VK_MEMORY_HEAP_DEVICE_LOCAL_BIT   MemoryHeapFlagBits = (1 << 0)
	VK_MEMORY_HEAP_MULTI_INSTANCE_BIT MemoryHeapFlagBits = (1 << 1)
)

var (
	reverseMemoryHeapFlagBits map[MemoryHeapFlagBits]string = map[MemoryHeapFlagBits]string{
		VK_MEMORY_HEAP_DEVICE_LOCAL_BIT:   "VK_MEMORY_HEAP_DEVICE_LOCAL_BIT",
		VK_MEMORY_HEAP_MULTI_INSTANCE_BIT: "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT",
	}
)

func (x MemoryHeapFlagBits) String() string {
	if s, ok := reverseMemoryHeapFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("MemoryHeapFlagBits=%d", x)
}

// CommandPoolCreateFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCommandPoolCreateFlagBits.html
type CommandPoolCreateFlagBits uint32

const (
	VK_COMMAND_POOL_CREATE_TRANSIENT_BIT            CommandPoolCreateFlagBits = (1 << 0)
	VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT CommandPoolCreateFlagBits = (1 << 1)
	VK_COMMAND_POOL_CREATE_PROTECTED_BIT            CommandPoolCreateFlagBits = (1 << 2)
)

var (
	reverseCommandPoolCreateFlagBits map[CommandPoolCreateFlagBits]string = map[CommandPoolCreateFlagBits]string{
		VK_COMMAND_POOL_CREATE_TRANSIENT_BIT:            "VK_COMMAND_POOL_CREATE_TRANSIENT_BIT",
		VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT: "VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT",
		VK_COMMAND_POOL_CREATE_PROTECTED_BIT:            "VK_COMMAND_POOL_CREATE_PROTECTED_BIT",
	}
)

func (x CommandPoolCreateFlagBits) String() string {
	if s, ok := reverseCommandPoolCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("CommandPoolCreateFlagBits=%d", x)
}

// MemoryPropertyFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkMemoryPropertyFlagBits.html
type MemoryPropertyFlagBits uint32

const (
	VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT     MemoryPropertyFlagBits = (1 << 0)
	VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT     MemoryPropertyFlagBits = (1 << 1)
	VK_MEMORY_PROPERTY_HOST_COHERENT_BIT    MemoryPropertyFlagBits = (1 << 2)
	VK_MEMORY_PROPERTY_HOST_CACHED_BIT      MemoryPropertyFlagBits = (1 << 3)
	VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT MemoryPropertyFlagBits = (1 << 4)
	VK_MEMORY_PROPERTY_PROTECTED_BIT        MemoryPropertyFlagBits = (1 << 5)
)

var (
	reverseMemoryPropertyFlagBits map[MemoryPropertyFlagBits]string = map[MemoryPropertyFlagBits]string{
		VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT:     "VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT",
		VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT:     "VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT",
		VK_MEMORY_PROPERTY_HOST_COHERENT_BIT:    "VK_MEMORY_PROPERTY_HOST_COHERENT_BIT",
		VK_MEMORY_PROPERTY_HOST_CACHED_BIT:      "VK_MEMORY_PROPERTY_HOST_CACHED_BIT",
		VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT: "VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT",
		VK_MEMORY_PROPERTY_PROTECTED_BIT:        "VK_MEMORY_PROPERTY_PROTECTED_BIT",
	}
)

func (x MemoryPropertyFlagBits) String() string {
	if s, ok := reverseMemoryPropertyFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("MemoryPropertyFlagBits=%d", x)
}

// AccessFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkAccessFlagBits.html
type AccessFlagBits uint32

const (
	VK_ACCESS_INDIRECT_COMMAND_READ_BIT          AccessFlagBits = (1 << 0)
	VK_ACCESS_INDEX_READ_BIT                     AccessFlagBits = (1 << 1)
	VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT          AccessFlagBits = (1 << 2)
	VK_ACCESS_UNIFORM_READ_BIT                   AccessFlagBits = (1 << 3)
	VK_ACCESS_INPUT_ATTACHMENT_READ_BIT          AccessFlagBits = (1 << 4)
	VK_ACCESS_SHADER_READ_BIT                    AccessFlagBits = (1 << 5)
	VK_ACCESS_SHADER_WRITE_BIT                   AccessFlagBits = (1 << 6)
	VK_ACCESS_COLOR_ATTACHMENT_READ_BIT          AccessFlagBits = (1 << 7)
	VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT         AccessFlagBits = (1 << 8)
	VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT  AccessFlagBits = (1 << 9)
	VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT AccessFlagBits = (1 << 10)
	VK_ACCESS_TRANSFER_READ_BIT                  AccessFlagBits = (1 << 11)
	VK_ACCESS_TRANSFER_WRITE_BIT                 AccessFlagBits = (1 << 12)
	VK_ACCESS_HOST_READ_BIT                      AccessFlagBits = (1 << 13)
	VK_ACCESS_HOST_WRITE_BIT                     AccessFlagBits = (1 << 14)
	VK_ACCESS_MEMORY_READ_BIT                    AccessFlagBits = (1 << 15)
	VK_ACCESS_MEMORY_WRITE_BIT                   AccessFlagBits = (1 << 16)
)

var (
	reverseAccessFlagBits map[AccessFlagBits]string = map[AccessFlagBits]string{
		VK_ACCESS_INDIRECT_COMMAND_READ_BIT:          "VK_ACCESS_INDIRECT_COMMAND_READ_BIT",
		VK_ACCESS_INDEX_READ_BIT:                     "VK_ACCESS_INDEX_READ_BIT",
		VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT:          "VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT",
		VK_ACCESS_UNIFORM_READ_BIT:                   "VK_ACCESS_UNIFORM_READ_BIT",
		VK_ACCESS_INPUT_ATTACHMENT_READ_BIT:          "VK_ACCESS_INPUT_ATTACHMENT_READ_BIT",
		VK_ACCESS_SHADER_READ_BIT:                    "VK_ACCESS_SHADER_READ_BIT",
		VK_ACCESS_SHADER_WRITE_BIT:                   "VK_ACCESS_SHADER_WRITE_BIT",
		VK_ACCESS_COLOR_ATTACHMENT_READ_BIT:          "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT",
		VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT:         "VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT",
		VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT:  "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT",
		VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT: "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT",
		VK_ACCESS_TRANSFER_READ_BIT:                  "VK_ACCESS_TRANSFER_READ_BIT",
		VK_ACCESS_TRANSFER_WRITE_BIT:                 "VK_ACCESS_TRANSFER_WRITE_BIT",
		VK_ACCESS_HOST_READ_BIT:                      "VK_ACCESS_HOST_READ_BIT",
		VK_ACCESS_HOST_WRITE_BIT:                     "VK_ACCESS_HOST_WRITE_BIT",
		VK_ACCESS_MEMORY_READ_BIT:                    "VK_ACCESS_MEMORY_READ_BIT",
		VK_ACCESS_MEMORY_WRITE_BIT:                   "VK_ACCESS_MEMORY_WRITE_BIT",
	}
)

func (x AccessFlagBits) String() string {
	if s, ok := reverseAccessFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("AccessFlagBits=%d", x)
}

// EventCreateFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkEventCreateFlagBits.html
type EventCreateFlagBits uint32

// PipelineStageFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineStageFlagBits.html
type PipelineStageFlagBits uint32

const (
	VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT                    PipelineStageFlagBits = (1 << 0)
	VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT                  PipelineStageFlagBits = (1 << 1)
	VK_PIPELINE_STAGE_VERTEX_INPUT_BIT                   PipelineStageFlagBits = (1 << 2)
	VK_PIPELINE_STAGE_VERTEX_SHADER_BIT                  PipelineStageFlagBits = (1 << 3)
	VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT    PipelineStageFlagBits = (1 << 4)
	VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT PipelineStageFlagBits = (1 << 5)
	VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT                PipelineStageFlagBits = (1 << 6)
	VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT                PipelineStageFlagBits = (1 << 7)
	VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT           PipelineStageFlagBits = (1 << 8)
	VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT            PipelineStageFlagBits = (1 << 9)
	VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT        PipelineStageFlagBits = (1 << 10)
	VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT                 PipelineStageFlagBits = (1 << 11)
	VK_PIPELINE_STAGE_TRANSFER_BIT                       PipelineStageFlagBits = (1 << 12)
	VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT                 PipelineStageFlagBits = (1 << 13)
	VK_PIPELINE_STAGE_HOST_BIT                           PipelineStageFlagBits = (1 << 14)
	VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT                   PipelineStageFlagBits = (1 << 15)
	VK_PIPELINE_STAGE_ALL_COMMANDS_BIT                   PipelineStageFlagBits = (1 << 16)
)

var (
	reversePipelineStageFlagBits map[PipelineStageFlagBits]string = map[PipelineStageFlagBits]string{
		VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT:                    "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT",
		VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT:                  "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT",
		VK_PIPELINE_STAGE_VERTEX_INPUT_BIT:                   "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT",
		VK_PIPELINE_STAGE_VERTEX_SHADER_BIT:                  "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT",
		VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT:    "VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT",
		VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT: "VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT",
		VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT:                "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT",
		VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT:                "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT",
		VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT:           "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT",
		VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT:            "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT",
		VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT:        "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT",
		VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT:                 "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT",
		VK_PIPELINE_STAGE_TRANSFER_BIT:                       "VK_PIPELINE_STAGE_TRANSFER_BIT",
		VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT:                 "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT",
		VK_PIPELINE_STAGE_HOST_BIT:                           "VK_PIPELINE_STAGE_HOST_BIT",
		VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT:                   "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT",
		VK_PIPELINE_STAGE_ALL_COMMANDS_BIT:                   "VK_PIPELINE_STAGE_ALL_COMMANDS_BIT",
	}
)

func (x PipelineStageFlagBits) String() string {
	if s, ok := reversePipelineStageFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("PipelineStageFlagBits=%d", x)
}

// ColorComponentFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkColorComponentFlagBits.html
type ColorComponentFlagBits uint32

const (
	VK_COLOR_COMPONENT_R_BIT ColorComponentFlagBits = (1 << 0)
	VK_COLOR_COMPONENT_G_BIT ColorComponentFlagBits = (1 << 1)
	VK_COLOR_COMPONENT_B_BIT ColorComponentFlagBits = (1 << 2)
	VK_COLOR_COMPONENT_A_BIT ColorComponentFlagBits = (1 << 3)
)

var (
	reverseColorComponentFlagBits map[ColorComponentFlagBits]string = map[ColorComponentFlagBits]string{
		VK_COLOR_COMPONENT_R_BIT: "VK_COLOR_COMPONENT_R_BIT",
		VK_COLOR_COMPONENT_G_BIT: "VK_COLOR_COMPONENT_G_BIT",
		VK_COLOR_COMPONENT_B_BIT: "VK_COLOR_COMPONENT_B_BIT",
		VK_COLOR_COMPONENT_A_BIT: "VK_COLOR_COMPONENT_A_BIT",
	}
)

func (x ColorComponentFlagBits) String() string {
	if s, ok := reverseColorComponentFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ColorComponentFlagBits=%d", x)
}

// BlendOp is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBlendOp.html
type BlendOp uint32

const (
	VK_BLEND_OP_ADD              BlendOp = 0
	VK_BLEND_OP_SUBTRACT         BlendOp = 1
	VK_BLEND_OP_REVERSE_SUBTRACT BlendOp = 2
	VK_BLEND_OP_MIN              BlendOp = 3
	VK_BLEND_OP_MAX              BlendOp = 4
)

var (
	reverseBlendOp map[BlendOp]string = map[BlendOp]string{
		VK_BLEND_OP_ADD:              "VK_BLEND_OP_ADD",
		VK_BLEND_OP_SUBTRACT:         "VK_BLEND_OP_SUBTRACT",
		VK_BLEND_OP_REVERSE_SUBTRACT: "VK_BLEND_OP_REVERSE_SUBTRACT",
		VK_BLEND_OP_MIN:              "VK_BLEND_OP_MIN",
		VK_BLEND_OP_MAX:              "VK_BLEND_OP_MAX",
	}
)

func (x BlendOp) String() string {
	if s, ok := reverseBlendOp[x]; ok {
		return s
	}
	return fmt.Sprintf("BlendOp=%d", x)
}

// QueryResultFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkQueryResultFlagBits.html
type QueryResultFlagBits uint32

const (
	VK_QUERY_RESULT_64_BIT                QueryResultFlagBits = (1 << 0)
	VK_QUERY_RESULT_WAIT_BIT              QueryResultFlagBits = (1 << 1)
	VK_QUERY_RESULT_WITH_AVAILABILITY_BIT QueryResultFlagBits = (1 << 2)
	VK_QUERY_RESULT_PARTIAL_BIT           QueryResultFlagBits = (1 << 3)
)

var (
	reverseQueryResultFlagBits map[QueryResultFlagBits]string = map[QueryResultFlagBits]string{
		VK_QUERY_RESULT_64_BIT:                "VK_QUERY_RESULT_64_BIT",
		VK_QUERY_RESULT_WAIT_BIT:              "VK_QUERY_RESULT_WAIT_BIT",
		VK_QUERY_RESULT_WITH_AVAILABILITY_BIT: "VK_QUERY_RESULT_WITH_AVAILABILITY_BIT",
		VK_QUERY_RESULT_PARTIAL_BIT:           "VK_QUERY_RESULT_PARTIAL_BIT",
	}
)

func (x QueryResultFlagBits) String() string {
	if s, ok := reverseQueryResultFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("QueryResultFlagBits=%d", x)
}

// DependencyFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDependencyFlagBits.html
type DependencyFlagBits uint32

const (
	VK_DEPENDENCY_BY_REGION_BIT    DependencyFlagBits = (1 << 0)
	VK_DEPENDENCY_DEVICE_GROUP_BIT DependencyFlagBits = (1 << 2)
	VK_DEPENDENCY_VIEW_LOCAL_BIT   DependencyFlagBits = (1 << 1)
)

var (
	reverseDependencyFlagBits map[DependencyFlagBits]string = map[DependencyFlagBits]string{
		VK_DEPENDENCY_BY_REGION_BIT:    "VK_DEPENDENCY_BY_REGION_BIT",
		VK_DEPENDENCY_DEVICE_GROUP_BIT: "VK_DEPENDENCY_DEVICE_GROUP_BIT",
		VK_DEPENDENCY_VIEW_LOCAL_BIT:   "VK_DEPENDENCY_VIEW_LOCAL_BIT",
	}
)

func (x DependencyFlagBits) String() string {
	if s, ok := reverseDependencyFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("DependencyFlagBits=%d", x)
}

// PrimitiveTopology is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPrimitiveTopology.html
type PrimitiveTopology uint32

const (
	VK_PRIMITIVE_TOPOLOGY_POINT_LIST                    PrimitiveTopology = 0
	VK_PRIMITIVE_TOPOLOGY_LINE_LIST                     PrimitiveTopology = 1
	VK_PRIMITIVE_TOPOLOGY_LINE_STRIP                    PrimitiveTopology = 2
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST                 PrimitiveTopology = 3
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP                PrimitiveTopology = 4
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN                  PrimitiveTopology = 5
	VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY      PrimitiveTopology = 6
	VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY     PrimitiveTopology = 7
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY  PrimitiveTopology = 8
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY PrimitiveTopology = 9
	VK_PRIMITIVE_TOPOLOGY_PATCH_LIST                    PrimitiveTopology = 10
)

var (
	reversePrimitiveTopology map[PrimitiveTopology]string = map[PrimitiveTopology]string{
		VK_PRIMITIVE_TOPOLOGY_POINT_LIST:                    "VK_PRIMITIVE_TOPOLOGY_POINT_LIST",
		VK_PRIMITIVE_TOPOLOGY_LINE_LIST:                     "VK_PRIMITIVE_TOPOLOGY_LINE_LIST",
		VK_PRIMITIVE_TOPOLOGY_LINE_STRIP:                    "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP",
		VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST:                 "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST",
		VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP:                "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP",
		VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN:                  "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN",
		VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY:      "VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY",
		VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY:     "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY",
		VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY:  "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY",
		VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY: "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY",
		VK_PRIMITIVE_TOPOLOGY_PATCH_LIST:                    "VK_PRIMITIVE_TOPOLOGY_PATCH_LIST",
	}
)

func (x PrimitiveTopology) String() string {
	if s, ok := reversePrimitiveTopology[x]; ok {
		return s
	}
	return fmt.Sprintf("PrimitiveTopology=%d", x)
}

// PhysicalDeviceType is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceType.html
type PhysicalDeviceType uint32

const (
	VK_PHYSICAL_DEVICE_TYPE_OTHER          PhysicalDeviceType = 0
	VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU PhysicalDeviceType = 1
	VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU   PhysicalDeviceType = 2
	VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU    PhysicalDeviceType = 3
	VK_PHYSICAL_DEVICE_TYPE_CPU            PhysicalDeviceType = 4
)

var (
	reversePhysicalDeviceType map[PhysicalDeviceType]string = map[PhysicalDeviceType]string{
		VK_PHYSICAL_DEVICE_TYPE_OTHER:          "VK_PHYSICAL_DEVICE_TYPE_OTHER",
		VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU: "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU",
		VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU:   "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU",
		VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU:    "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU",
		VK_PHYSICAL_DEVICE_TYPE_CPU:            "VK_PHYSICAL_DEVICE_TYPE_CPU",
	}
)

func (x PhysicalDeviceType) String() string {
	if s, ok := reversePhysicalDeviceType[x]; ok {
		return s
	}
	return fmt.Sprintf("PhysicalDeviceType=%d", x)
}

// CommandPoolResetFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCommandPoolResetFlagBits.html
type CommandPoolResetFlagBits uint32

const (
	VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT CommandPoolResetFlagBits = (1 << 0)
)

var (
	reverseCommandPoolResetFlagBits map[CommandPoolResetFlagBits]string = map[CommandPoolResetFlagBits]string{
		VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT: "VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT",
	}
)

func (x CommandPoolResetFlagBits) String() string {
	if s, ok := reverseCommandPoolResetFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("CommandPoolResetFlagBits=%d", x)
}

// QueueFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkQueueFlagBits.html
type QueueFlagBits uint32

const (
	VK_QUEUE_GRAPHICS_BIT       QueueFlagBits = (1 << 0)
	VK_QUEUE_COMPUTE_BIT        QueueFlagBits = (1 << 1)
	VK_QUEUE_TRANSFER_BIT       QueueFlagBits = (1 << 2)
	VK_QUEUE_SPARSE_BINDING_BIT QueueFlagBits = (1 << 3)
	VK_QUEUE_PROTECTED_BIT      QueueFlagBits = (1 << 4)
)

var (
	reverseQueueFlagBits map[QueueFlagBits]string = map[QueueFlagBits]string{
		VK_QUEUE_GRAPHICS_BIT:       "VK_QUEUE_GRAPHICS_BIT",
		VK_QUEUE_COMPUTE_BIT:        "VK_QUEUE_COMPUTE_BIT",
		VK_QUEUE_TRANSFER_BIT:       "VK_QUEUE_TRANSFER_BIT",
		VK_QUEUE_SPARSE_BINDING_BIT: "VK_QUEUE_SPARSE_BINDING_BIT",
		VK_QUEUE_PROTECTED_BIT:      "VK_QUEUE_PROTECTED_BIT",
	}
)

func (x QueueFlagBits) String() string {
	if s, ok := reverseQueueFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("QueueFlagBits=%d", x)
}

// ImageLayout is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageLayout.html
type ImageLayout uint32

const (
	VK_IMAGE_LAYOUT_UNDEFINED                                  ImageLayout = 0
	VK_IMAGE_LAYOUT_GENERAL                                    ImageLayout = 1
	VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL                   ImageLayout = 2
	VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL           ImageLayout = 3
	VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL            ImageLayout = 4
	VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL                   ImageLayout = 5
	VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL                       ImageLayout = 6
	VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL                       ImageLayout = 7
	VK_IMAGE_LAYOUT_PREINITIALIZED                             ImageLayout = 8
	VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL ImageLayout = 1000117000
	VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL ImageLayout = 1000117001
	VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL                   ImageLayout = 1000241000
	VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL                    ImageLayout = 1000241001
	VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL                 ImageLayout = 1000241002
	VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL                  ImageLayout = 1000241003
	VK_IMAGE_LAYOUT_PRESENT_SRC_KHR                            ImageLayout = 1000001002
)

var (
	reverseImageLayout map[ImageLayout]string = map[ImageLayout]string{
		VK_IMAGE_LAYOUT_UNDEFINED:                                  "VK_IMAGE_LAYOUT_UNDEFINED",
		VK_IMAGE_LAYOUT_GENERAL:                                    "VK_IMAGE_LAYOUT_GENERAL",
		VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL:                   "VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL",
		VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL:           "VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL",
		VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL:            "VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL",
		VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL:                   "VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL",
		VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL:                       "VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL",
		VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL:                       "VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL",
		VK_IMAGE_LAYOUT_PREINITIALIZED:                             "VK_IMAGE_LAYOUT_PREINITIALIZED",
		VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL: "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL",
		VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL: "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL",
		VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL:                   "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL",
		VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL:                    "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL",
		VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL:                 "VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL",
		VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL:                  "VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL",
		VK_IMAGE_LAYOUT_PRESENT_SRC_KHR:                            "VK_IMAGE_LAYOUT_PRESENT_SRC_KHR",
	}
)

func (x ImageLayout) String() string {
	if s, ok := reverseImageLayout[x]; ok {
		return s
	}
	return fmt.Sprintf("ImageLayout=%d", x)
}

// SampleCountFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSampleCountFlagBits.html
type SampleCountFlagBits uint32

const (
	VK_SAMPLE_COUNT_1_BIT  SampleCountFlagBits = (1 << 0)
	VK_SAMPLE_COUNT_2_BIT  SampleCountFlagBits = (1 << 1)
	VK_SAMPLE_COUNT_4_BIT  SampleCountFlagBits = (1 << 2)
	VK_SAMPLE_COUNT_8_BIT  SampleCountFlagBits = (1 << 3)
	VK_SAMPLE_COUNT_16_BIT SampleCountFlagBits = (1 << 4)
	VK_SAMPLE_COUNT_32_BIT SampleCountFlagBits = (1 << 5)
	VK_SAMPLE_COUNT_64_BIT SampleCountFlagBits = (1 << 6)
)

var (
	reverseSampleCountFlagBits map[SampleCountFlagBits]string = map[SampleCountFlagBits]string{
		VK_SAMPLE_COUNT_1_BIT:  "VK_SAMPLE_COUNT_1_BIT",
		VK_SAMPLE_COUNT_2_BIT:  "VK_SAMPLE_COUNT_2_BIT",
		VK_SAMPLE_COUNT_4_BIT:  "VK_SAMPLE_COUNT_4_BIT",
		VK_SAMPLE_COUNT_8_BIT:  "VK_SAMPLE_COUNT_8_BIT",
		VK_SAMPLE_COUNT_16_BIT: "VK_SAMPLE_COUNT_16_BIT",
		VK_SAMPLE_COUNT_32_BIT: "VK_SAMPLE_COUNT_32_BIT",
		VK_SAMPLE_COUNT_64_BIT: "VK_SAMPLE_COUNT_64_BIT",
	}
)

func (x SampleCountFlagBits) String() string {
	if s, ok := reverseSampleCountFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("SampleCountFlagBits=%d", x)
}

// DescriptorType is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorType.html
type DescriptorType uint32

const (
	VK_DESCRIPTOR_TYPE_SAMPLER                DescriptorType = 0
	VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER DescriptorType = 1
	VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE          DescriptorType = 2
	VK_DESCRIPTOR_TYPE_STORAGE_IMAGE          DescriptorType = 3
	VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER   DescriptorType = 4
	VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER   DescriptorType = 5
	VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER         DescriptorType = 6
	VK_DESCRIPTOR_TYPE_STORAGE_BUFFER         DescriptorType = 7
	VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC DescriptorType = 8
	VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC DescriptorType = 9
	VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT       DescriptorType = 10
)

var (
	reverseDescriptorType map[DescriptorType]string = map[DescriptorType]string{
		VK_DESCRIPTOR_TYPE_SAMPLER:                "VK_DESCRIPTOR_TYPE_SAMPLER",
		VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER: "VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER",
		VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE:          "VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE",
		VK_DESCRIPTOR_TYPE_STORAGE_IMAGE:          "VK_DESCRIPTOR_TYPE_STORAGE_IMAGE",
		VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER:   "VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER",
		VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER:   "VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER",
		VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER:         "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER",
		VK_DESCRIPTOR_TYPE_STORAGE_BUFFER:         "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER",
		VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC: "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC",
		VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC: "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC",
		VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:       "VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT",
	}
)

func (x DescriptorType) String() string {
	if s, ok := reverseDescriptorType[x]; ok {
		return s
	}
	return fmt.Sprintf("DescriptorType=%d", x)
}

// SystemAllocationScope is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSystemAllocationScope.html
type SystemAllocationScope uint32

const (
	VK_SYSTEM_ALLOCATION_SCOPE_COMMAND  SystemAllocationScope = 0
	VK_SYSTEM_ALLOCATION_SCOPE_OBJECT   SystemAllocationScope = 1
	VK_SYSTEM_ALLOCATION_SCOPE_CACHE    SystemAllocationScope = 2
	VK_SYSTEM_ALLOCATION_SCOPE_DEVICE   SystemAllocationScope = 3
	VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE SystemAllocationScope = 4
)

var (
	reverseSystemAllocationScope map[SystemAllocationScope]string = map[SystemAllocationScope]string{
		VK_SYSTEM_ALLOCATION_SCOPE_COMMAND:  "VK_SYSTEM_ALLOCATION_SCOPE_COMMAND",
		VK_SYSTEM_ALLOCATION_SCOPE_OBJECT:   "VK_SYSTEM_ALLOCATION_SCOPE_OBJECT",
		VK_SYSTEM_ALLOCATION_SCOPE_CACHE:    "VK_SYSTEM_ALLOCATION_SCOPE_CACHE",
		VK_SYSTEM_ALLOCATION_SCOPE_DEVICE:   "VK_SYSTEM_ALLOCATION_SCOPE_DEVICE",
		VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE: "VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE",
	}
)

func (x SystemAllocationScope) String() string {
	if s, ok := reverseSystemAllocationScope[x]; ok {
		return s
	}
	return fmt.Sprintf("SystemAllocationScope=%d", x)
}

// ShaderStageFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkShaderStageFlagBits.html
type ShaderStageFlagBits uint32

const (
	VK_SHADER_STAGE_VERTEX_BIT                  ShaderStageFlagBits = (1 << 0)
	VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT    ShaderStageFlagBits = (1 << 1)
	VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT ShaderStageFlagBits = (1 << 2)
	VK_SHADER_STAGE_GEOMETRY_BIT                ShaderStageFlagBits = (1 << 3)
	VK_SHADER_STAGE_FRAGMENT_BIT                ShaderStageFlagBits = (1 << 4)
	VK_SHADER_STAGE_COMPUTE_BIT                 ShaderStageFlagBits = (1 << 5)
	VK_SHADER_STAGE_ALL_GRAPHICS                ShaderStageFlagBits = 0x0000001F
	VK_SHADER_STAGE_ALL                         ShaderStageFlagBits = 0x7FFFFFFF
)

var (
	reverseShaderStageFlagBits map[ShaderStageFlagBits]string = map[ShaderStageFlagBits]string{
		VK_SHADER_STAGE_VERTEX_BIT:                  "VK_SHADER_STAGE_VERTEX_BIT",
		VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT:    "VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT",
		VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT: "VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT",
		VK_SHADER_STAGE_GEOMETRY_BIT:                "VK_SHADER_STAGE_GEOMETRY_BIT",
		VK_SHADER_STAGE_FRAGMENT_BIT:                "VK_SHADER_STAGE_FRAGMENT_BIT",
		VK_SHADER_STAGE_COMPUTE_BIT:                 "VK_SHADER_STAGE_COMPUTE_BIT",
		VK_SHADER_STAGE_ALL_GRAPHICS:                "VK_SHADER_STAGE_ALL_GRAPHICS",
		VK_SHADER_STAGE_ALL:                         "VK_SHADER_STAGE_ALL",
	}
)

func (x ShaderStageFlagBits) String() string {
	if s, ok := reverseShaderStageFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ShaderStageFlagBits=%d", x)
}

// DescriptorPoolCreateFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorPoolCreateFlagBits.html
type DescriptorPoolCreateFlagBits uint32

const (
	VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT DescriptorPoolCreateFlagBits = (1 << 0)
	VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT   DescriptorPoolCreateFlagBits = (1 << 1)
)

var (
	reverseDescriptorPoolCreateFlagBits map[DescriptorPoolCreateFlagBits]string = map[DescriptorPoolCreateFlagBits]string{
		VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT: "VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT",
		VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT:   "VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT",
	}
)

func (x DescriptorPoolCreateFlagBits) String() string {
	if s, ok := reverseDescriptorPoolCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("DescriptorPoolCreateFlagBits=%d", x)
}

// Result is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkResult.html
type Result int32

const (
	VK_SUCCESS                              Result = 0
	VK_NOT_READY                            Result = 1
	VK_TIMEOUT                              Result = 2
	VK_EVENT_SET                            Result = 3
	VK_EVENT_RESET                          Result = 4
	VK_INCOMPLETE                           Result = 5
	VK_ERROR_OUT_OF_HOST_MEMORY             Result = -1
	VK_ERROR_OUT_OF_DEVICE_MEMORY           Result = -2
	VK_ERROR_INITIALIZATION_FAILED          Result = -3
	VK_ERROR_DEVICE_LOST                    Result = -4
	VK_ERROR_MEMORY_MAP_FAILED              Result = -5
	VK_ERROR_LAYER_NOT_PRESENT              Result = -6
	VK_ERROR_EXTENSION_NOT_PRESENT          Result = -7
	VK_ERROR_FEATURE_NOT_PRESENT            Result = -8
	VK_ERROR_INCOMPATIBLE_DRIVER            Result = -9
	VK_ERROR_TOO_MANY_OBJECTS               Result = -10
	VK_ERROR_FORMAT_NOT_SUPPORTED           Result = -11
	VK_ERROR_FRAGMENTED_POOL                Result = -12
	VK_ERROR_UNKNOWN                        Result = -13
	VK_ERROR_OUT_OF_POOL_MEMORY             Result = 1000069000
	VK_ERROR_INVALID_EXTERNAL_HANDLE        Result = 1000072003
	VK_ERROR_FRAGMENTATION                  Result = 1000161000
	VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS Result = 1000257000
	VK_ERROR_SURFACE_LOST_KHR               Result = 1000000000
	VK_ERROR_NATIVE_WINDOW_IN_USE_KHR       Result = 1000000001
	VK_SUBOPTIMAL_KHR                       Result = 1000001003
	VK_ERROR_OUT_OF_DATE_KHR                Result = 1000001004
	VK_ERROR_INCOMPATIBLE_DISPLAY_KHR       Result = 1000003001
)

var (
	reverseResult map[Result]string = map[Result]string{
		VK_SUCCESS:                              "VK_SUCCESS",
		VK_NOT_READY:                            "VK_NOT_READY",
		VK_TIMEOUT:                              "VK_TIMEOUT",
		VK_EVENT_SET:                            "VK_EVENT_SET",
		VK_EVENT_RESET:                          "VK_EVENT_RESET",
		VK_INCOMPLETE:                           "VK_INCOMPLETE",
		VK_ERROR_OUT_OF_HOST_MEMORY:             "VK_ERROR_OUT_OF_HOST_MEMORY",
		VK_ERROR_OUT_OF_DEVICE_MEMORY:           "VK_ERROR_OUT_OF_DEVICE_MEMORY",
		VK_ERROR_INITIALIZATION_FAILED:          "VK_ERROR_INITIALIZATION_FAILED",
		VK_ERROR_DEVICE_LOST:                    "VK_ERROR_DEVICE_LOST",
		VK_ERROR_MEMORY_MAP_FAILED:              "VK_ERROR_MEMORY_MAP_FAILED",
		VK_ERROR_LAYER_NOT_PRESENT:              "VK_ERROR_LAYER_NOT_PRESENT",
		VK_ERROR_EXTENSION_NOT_PRESENT:          "VK_ERROR_EXTENSION_NOT_PRESENT",
		VK_ERROR_FEATURE_NOT_PRESENT:            "VK_ERROR_FEATURE_NOT_PRESENT",
		VK_ERROR_INCOMPATIBLE_DRIVER:            "VK_ERROR_INCOMPATIBLE_DRIVER",
		VK_ERROR_TOO_MANY_OBJECTS:               "VK_ERROR_TOO_MANY_OBJECTS",
		VK_ERROR_FORMAT_NOT_SUPPORTED:           "VK_ERROR_FORMAT_NOT_SUPPORTED",
		VK_ERROR_FRAGMENTED_POOL:                "VK_ERROR_FRAGMENTED_POOL",
		VK_ERROR_UNKNOWN:                        "VK_ERROR_UNKNOWN",
		VK_ERROR_OUT_OF_POOL_MEMORY:             "VK_ERROR_OUT_OF_POOL_MEMORY",
		VK_ERROR_INVALID_EXTERNAL_HANDLE:        "VK_ERROR_INVALID_EXTERNAL_HANDLE",
		VK_ERROR_FRAGMENTATION:                  "VK_ERROR_FRAGMENTATION",
		VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS: "VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS",
		VK_ERROR_SURFACE_LOST_KHR:               "VK_ERROR_SURFACE_LOST_KHR",
		VK_ERROR_NATIVE_WINDOW_IN_USE_KHR:       "VK_ERROR_NATIVE_WINDOW_IN_USE_KHR",
		VK_SUBOPTIMAL_KHR:                       "VK_SUBOPTIMAL_KHR",
		VK_ERROR_OUT_OF_DATE_KHR:                "VK_ERROR_OUT_OF_DATE_KHR",
		VK_ERROR_INCOMPATIBLE_DISPLAY_KHR:       "VK_ERROR_INCOMPATIBLE_DISPLAY_KHR",
	}
)

func (x Result) String() string {
	if s, ok := reverseResult[x]; ok {
		return s
	}
	return fmt.Sprintf("Result=%d", x)
}

// AttachmentStoreOp is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkAttachmentStoreOp.html
type AttachmentStoreOp uint32

const (
	VK_ATTACHMENT_STORE_OP_STORE     AttachmentStoreOp = 0
	VK_ATTACHMENT_STORE_OP_DONT_CARE AttachmentStoreOp = 1
)

var (
	reverseAttachmentStoreOp map[AttachmentStoreOp]string = map[AttachmentStoreOp]string{
		VK_ATTACHMENT_STORE_OP_STORE:     "VK_ATTACHMENT_STORE_OP_STORE",
		VK_ATTACHMENT_STORE_OP_DONT_CARE: "VK_ATTACHMENT_STORE_OP_DONT_CARE",
	}
)

func (x AttachmentStoreOp) String() string {
	if s, ok := reverseAttachmentStoreOp[x]; ok {
		return s
	}
	return fmt.Sprintf("AttachmentStoreOp=%d", x)
}

// StencilOp is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkStencilOp.html
type StencilOp uint32

const (
	VK_STENCIL_OP_KEEP                StencilOp = 0
	VK_STENCIL_OP_ZERO                StencilOp = 1
	VK_STENCIL_OP_REPLACE             StencilOp = 2
	VK_STENCIL_OP_INCREMENT_AND_CLAMP StencilOp = 3
	VK_STENCIL_OP_DECREMENT_AND_CLAMP StencilOp = 4
	VK_STENCIL_OP_INVERT              StencilOp = 5
	VK_STENCIL_OP_INCREMENT_AND_WRAP  StencilOp = 6
	VK_STENCIL_OP_DECREMENT_AND_WRAP  StencilOp = 7
)

var (
	reverseStencilOp map[StencilOp]string = map[StencilOp]string{
		VK_STENCIL_OP_KEEP:                "VK_STENCIL_OP_KEEP",
		VK_STENCIL_OP_ZERO:                "VK_STENCIL_OP_ZERO",
		VK_STENCIL_OP_REPLACE:             "VK_STENCIL_OP_REPLACE",
		VK_STENCIL_OP_INCREMENT_AND_CLAMP: "VK_STENCIL_OP_INCREMENT_AND_CLAMP",
		VK_STENCIL_OP_DECREMENT_AND_CLAMP: "VK_STENCIL_OP_DECREMENT_AND_CLAMP",
		VK_STENCIL_OP_INVERT:              "VK_STENCIL_OP_INVERT",
		VK_STENCIL_OP_INCREMENT_AND_WRAP:  "VK_STENCIL_OP_INCREMENT_AND_WRAP",
		VK_STENCIL_OP_DECREMENT_AND_WRAP:  "VK_STENCIL_OP_DECREMENT_AND_WRAP",
	}
)

func (x StencilOp) String() string {
	if s, ok := reverseStencilOp[x]; ok {
		return s
	}
	return fmt.Sprintf("StencilOp=%d", x)
}

// ComponentSwizzle is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkComponentSwizzle.html
type ComponentSwizzle uint32

const (
	VK_COMPONENT_SWIZZLE_IDENTITY ComponentSwizzle = 0
	VK_COMPONENT_SWIZZLE_ZERO     ComponentSwizzle = 1
	VK_COMPONENT_SWIZZLE_ONE      ComponentSwizzle = 2
	VK_COMPONENT_SWIZZLE_R        ComponentSwizzle = 3
	VK_COMPONENT_SWIZZLE_G        ComponentSwizzle = 4
	VK_COMPONENT_SWIZZLE_B        ComponentSwizzle = 5
	VK_COMPONENT_SWIZZLE_A        ComponentSwizzle = 6
)

var (
	reverseComponentSwizzle map[ComponentSwizzle]string = map[ComponentSwizzle]string{
		VK_COMPONENT_SWIZZLE_IDENTITY: "VK_COMPONENT_SWIZZLE_IDENTITY",
		VK_COMPONENT_SWIZZLE_ZERO:     "VK_COMPONENT_SWIZZLE_ZERO",
		VK_COMPONENT_SWIZZLE_ONE:      "VK_COMPONENT_SWIZZLE_ONE",
		VK_COMPONENT_SWIZZLE_R:        "VK_COMPONENT_SWIZZLE_R",
		VK_COMPONENT_SWIZZLE_G:        "VK_COMPONENT_SWIZZLE_G",
		VK_COMPONENT_SWIZZLE_B:        "VK_COMPONENT_SWIZZLE_B",
		VK_COMPONENT_SWIZZLE_A:        "VK_COMPONENT_SWIZZLE_A",
	}
)

func (x ComponentSwizzle) String() string {
	if s, ok := reverseComponentSwizzle[x]; ok {
		return s
	}
	return fmt.Sprintf("ComponentSwizzle=%d", x)
}

// DescriptorSetLayoutCreateFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorSetLayoutCreateFlagBits.html
type DescriptorSetLayoutCreateFlagBits uint32

const (
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT DescriptorSetLayoutCreateFlagBits = (1 << 1)
)

var (
	reverseDescriptorSetLayoutCreateFlagBits map[DescriptorSetLayoutCreateFlagBits]string = map[DescriptorSetLayoutCreateFlagBits]string{
		VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT: "VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT",
	}
)

func (x DescriptorSetLayoutCreateFlagBits) String() string {
	if s, ok := reverseDescriptorSetLayoutCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("DescriptorSetLayoutCreateFlagBits=%d", x)
}

// VertexInputRate is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVertexInputRate.html
type VertexInputRate uint32

const (
	VK_VERTEX_INPUT_RATE_VERTEX   VertexInputRate = 0
	VK_VERTEX_INPUT_RATE_INSTANCE VertexInputRate = 1
)

var (
	reverseVertexInputRate map[VertexInputRate]string = map[VertexInputRate]string{
		VK_VERTEX_INPUT_RATE_VERTEX:   "VK_VERTEX_INPUT_RATE_VERTEX",
		VK_VERTEX_INPUT_RATE_INSTANCE: "VK_VERTEX_INPUT_RATE_INSTANCE",
	}
)

func (x VertexInputRate) String() string {
	if s, ok := reverseVertexInputRate[x]; ok {
		return s
	}
	return fmt.Sprintf("VertexInputRate=%d", x)
}

// QueryPipelineStatisticFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkQueryPipelineStatisticFlagBits.html
type QueryPipelineStatisticFlagBits uint32

const (
	VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT                    QueryPipelineStatisticFlagBits = (1 << 0)
	VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT                  QueryPipelineStatisticFlagBits = (1 << 1)
	VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT                  QueryPipelineStatisticFlagBits = (1 << 2)
	VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT                QueryPipelineStatisticFlagBits = (1 << 3)
	VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT                 QueryPipelineStatisticFlagBits = (1 << 4)
	VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT                       QueryPipelineStatisticFlagBits = (1 << 5)
	VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT                        QueryPipelineStatisticFlagBits = (1 << 6)
	VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT                QueryPipelineStatisticFlagBits = (1 << 7)
	VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT        QueryPipelineStatisticFlagBits = (1 << 8)
	VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT QueryPipelineStatisticFlagBits = (1 << 9)
	VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT                 QueryPipelineStatisticFlagBits = (1 << 10)
)

var (
	reverseQueryPipelineStatisticFlagBits map[QueryPipelineStatisticFlagBits]string = map[QueryPipelineStatisticFlagBits]string{
		VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT:                    "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT",
		VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT:                  "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT",
		VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT:                  "VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT",
		VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT:                "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT",
		VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT:                 "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT",
		VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT:                       "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT",
		VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT:                        "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT",
		VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT:                "VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT",
		VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT:        "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT",
		VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT: "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT",
		VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT:                 "VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT",
	}
)

func (x QueryPipelineStatisticFlagBits) String() string {
	if s, ok := reverseQueryPipelineStatisticFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("QueryPipelineStatisticFlagBits=%d", x)
}

// ImageViewCreateFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageViewCreateFlagBits.html
type ImageViewCreateFlagBits uint32

// ImageViewType is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageViewType.html
type ImageViewType uint32

const (
	VK_IMAGE_VIEW_TYPE_1D         ImageViewType = 0
	VK_IMAGE_VIEW_TYPE_2D         ImageViewType = 1
	VK_IMAGE_VIEW_TYPE_3D         ImageViewType = 2
	VK_IMAGE_VIEW_TYPE_CUBE       ImageViewType = 3
	VK_IMAGE_VIEW_TYPE_1D_ARRAY   ImageViewType = 4
	VK_IMAGE_VIEW_TYPE_2D_ARRAY   ImageViewType = 5
	VK_IMAGE_VIEW_TYPE_CUBE_ARRAY ImageViewType = 6
)

var (
	reverseImageViewType map[ImageViewType]string = map[ImageViewType]string{
		VK_IMAGE_VIEW_TYPE_1D:         "VK_IMAGE_VIEW_TYPE_1D",
		VK_IMAGE_VIEW_TYPE_2D:         "VK_IMAGE_VIEW_TYPE_2D",
		VK_IMAGE_VIEW_TYPE_3D:         "VK_IMAGE_VIEW_TYPE_3D",
		VK_IMAGE_VIEW_TYPE_CUBE:       "VK_IMAGE_VIEW_TYPE_CUBE",
		VK_IMAGE_VIEW_TYPE_1D_ARRAY:   "VK_IMAGE_VIEW_TYPE_1D_ARRAY",
		VK_IMAGE_VIEW_TYPE_2D_ARRAY:   "VK_IMAGE_VIEW_TYPE_2D_ARRAY",
		VK_IMAGE_VIEW_TYPE_CUBE_ARRAY: "VK_IMAGE_VIEW_TYPE_CUBE_ARRAY",
	}
)

func (x ImageViewType) String() string {
	if s, ok := reverseImageViewType[x]; ok {
		return s
	}
	return fmt.Sprintf("ImageViewType=%d", x)
}

// SubpassContents is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSubpassContents.html
type SubpassContents uint32

const (
	VK_SUBPASS_CONTENTS_INLINE                    SubpassContents = 0
	VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS SubpassContents = 1
)

var (
	reverseSubpassContents map[SubpassContents]string = map[SubpassContents]string{
		VK_SUBPASS_CONTENTS_INLINE:                    "VK_SUBPASS_CONTENTS_INLINE",
		VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS: "VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS",
	}
)

func (x SubpassContents) String() string {
	if s, ok := reverseSubpassContents[x]; ok {
		return s
	}
	return fmt.Sprintf("SubpassContents=%d", x)
}

// QueryType is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkQueryType.html
type QueryType uint32

const (
	VK_QUERY_TYPE_OCCLUSION           QueryType = 0
	VK_QUERY_TYPE_PIPELINE_STATISTICS QueryType = 1
	VK_QUERY_TYPE_TIMESTAMP           QueryType = 2
)

var (
	reverseQueryType map[QueryType]string = map[QueryType]string{
		VK_QUERY_TYPE_OCCLUSION:           "VK_QUERY_TYPE_OCCLUSION",
		VK_QUERY_TYPE_PIPELINE_STATISTICS: "VK_QUERY_TYPE_PIPELINE_STATISTICS",
		VK_QUERY_TYPE_TIMESTAMP:           "VK_QUERY_TYPE_TIMESTAMP",
	}
)

func (x QueryType) String() string {
	if s, ok := reverseQueryType[x]; ok {
		return s
	}
	return fmt.Sprintf("QueryType=%d", x)
}

// CommandBufferLevel is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCommandBufferLevel.html
type CommandBufferLevel uint32

const (
	VK_COMMAND_BUFFER_LEVEL_PRIMARY   CommandBufferLevel = 0
	VK_COMMAND_BUFFER_LEVEL_SECONDARY CommandBufferLevel = 1
)

var (
	reverseCommandBufferLevel map[CommandBufferLevel]string = map[CommandBufferLevel]string{
		VK_COMMAND_BUFFER_LEVEL_PRIMARY:   "VK_COMMAND_BUFFER_LEVEL_PRIMARY",
		VK_COMMAND_BUFFER_LEVEL_SECONDARY: "VK_COMMAND_BUFFER_LEVEL_SECONDARY",
	}
)

func (x CommandBufferLevel) String() string {
	if s, ok := reverseCommandBufferLevel[x]; ok {
		return s
	}
	return fmt.Sprintf("CommandBufferLevel=%d", x)
}

// QueryControlFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkQueryControlFlagBits.html
type QueryControlFlagBits uint32

const (
	VK_QUERY_CONTROL_PRECISE_BIT QueryControlFlagBits = (1 << 0)
)

var (
	reverseQueryControlFlagBits map[QueryControlFlagBits]string = map[QueryControlFlagBits]string{
		VK_QUERY_CONTROL_PRECISE_BIT: "VK_QUERY_CONTROL_PRECISE_BIT",
	}
)

func (x QueryControlFlagBits) String() string {
	if s, ok := reverseQueryControlFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("QueryControlFlagBits=%d", x)
}

// CommandBufferResetFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCommandBufferResetFlagBits.html
type CommandBufferResetFlagBits uint32

const (
	VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT CommandBufferResetFlagBits = (1 << 0)
)

var (
	reverseCommandBufferResetFlagBits map[CommandBufferResetFlagBits]string = map[CommandBufferResetFlagBits]string{
		VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT: "VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT",
	}
)

func (x CommandBufferResetFlagBits) String() string {
	if s, ok := reverseCommandBufferResetFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("CommandBufferResetFlagBits=%d", x)
}

// CommandBufferUsageFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCommandBufferUsageFlagBits.html
type CommandBufferUsageFlagBits uint32

const (
	VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT      CommandBufferUsageFlagBits = (1 << 0)
	VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT CommandBufferUsageFlagBits = (1 << 1)
	VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT     CommandBufferUsageFlagBits = (1 << 2)
)

var (
	reverseCommandBufferUsageFlagBits map[CommandBufferUsageFlagBits]string = map[CommandBufferUsageFlagBits]string{
		VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT:      "VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT",
		VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT: "VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT",
		VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT:     "VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT",
	}
)

func (x CommandBufferUsageFlagBits) String() string {
	if s, ok := reverseCommandBufferUsageFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("CommandBufferUsageFlagBits=%d", x)
}

// SamplerCreateFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSamplerCreateFlagBits.html
type SamplerCreateFlagBits uint32

// BlendFactor is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBlendFactor.html
type BlendFactor uint32

const (
	VK_BLEND_FACTOR_ZERO                     BlendFactor = 0
	VK_BLEND_FACTOR_ONE                      BlendFactor = 1
	VK_BLEND_FACTOR_SRC_COLOR                BlendFactor = 2
	VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR      BlendFactor = 3
	VK_BLEND_FACTOR_DST_COLOR                BlendFactor = 4
	VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR      BlendFactor = 5
	VK_BLEND_FACTOR_SRC_ALPHA                BlendFactor = 6
	VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA      BlendFactor = 7
	VK_BLEND_FACTOR_DST_ALPHA                BlendFactor = 8
	VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA      BlendFactor = 9
	VK_BLEND_FACTOR_CONSTANT_COLOR           BlendFactor = 10
	VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR BlendFactor = 11
	VK_BLEND_FACTOR_CONSTANT_ALPHA           BlendFactor = 12
	VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA BlendFactor = 13
	VK_BLEND_FACTOR_SRC_ALPHA_SATURATE       BlendFactor = 14
	VK_BLEND_FACTOR_SRC1_COLOR               BlendFactor = 15
	VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR     BlendFactor = 16
	VK_BLEND_FACTOR_SRC1_ALPHA               BlendFactor = 17
	VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA     BlendFactor = 18
)

var (
	reverseBlendFactor map[BlendFactor]string = map[BlendFactor]string{
		VK_BLEND_FACTOR_ZERO:                     "VK_BLEND_FACTOR_ZERO",
		VK_BLEND_FACTOR_ONE:                      "VK_BLEND_FACTOR_ONE",
		VK_BLEND_FACTOR_SRC_COLOR:                "VK_BLEND_FACTOR_SRC_COLOR",
		VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR:      "VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR",
		VK_BLEND_FACTOR_DST_COLOR:                "VK_BLEND_FACTOR_DST_COLOR",
		VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR:      "VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR",
		VK_BLEND_FACTOR_SRC_ALPHA:                "VK_BLEND_FACTOR_SRC_ALPHA",
		VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA:      "VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA",
		VK_BLEND_FACTOR_DST_ALPHA:                "VK_BLEND_FACTOR_DST_ALPHA",
		VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA:      "VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA",
		VK_BLEND_FACTOR_CONSTANT_COLOR:           "VK_BLEND_FACTOR_CONSTANT_COLOR",
		VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR: "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR",
		VK_BLEND_FACTOR_CONSTANT_ALPHA:           "VK_BLEND_FACTOR_CONSTANT_ALPHA",
		VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA: "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA",
		VK_BLEND_FACTOR_SRC_ALPHA_SATURATE:       "VK_BLEND_FACTOR_SRC_ALPHA_SATURATE",
		VK_BLEND_FACTOR_SRC1_COLOR:               "VK_BLEND_FACTOR_SRC1_COLOR",
		VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR:     "VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR",
		VK_BLEND_FACTOR_SRC1_ALPHA:               "VK_BLEND_FACTOR_SRC1_ALPHA",
		VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA:     "VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA",
	}
)

func (x BlendFactor) String() string {
	if s, ok := reverseBlendFactor[x]; ok {
		return s
	}
	return fmt.Sprintf("BlendFactor=%d", x)
}

// SamplerAddressMode is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSamplerAddressMode.html
type SamplerAddressMode uint32

const (
	VK_SAMPLER_ADDRESS_MODE_REPEAT               SamplerAddressMode = 0
	VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT      SamplerAddressMode = 1
	VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE        SamplerAddressMode = 2
	VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER      SamplerAddressMode = 3
	VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE SamplerAddressMode = 4
)

var (
	reverseSamplerAddressMode map[SamplerAddressMode]string = map[SamplerAddressMode]string{
		VK_SAMPLER_ADDRESS_MODE_REPEAT:               "VK_SAMPLER_ADDRESS_MODE_REPEAT",
		VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT:      "VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT",
		VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE:        "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE",
		VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER:      "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER",
		VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE: "VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE",
	}
)

func (x SamplerAddressMode) String() string {
	if s, ok := reverseSamplerAddressMode[x]; ok {
		return s
	}
	return fmt.Sprintf("SamplerAddressMode=%d", x)
}

// PipelineStageFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineStageFlags.html
type PipelineStageFlags Flags

// CommandBufferResetFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCommandBufferResetFlags.html
type CommandBufferResetFlags Flags

// CommandBufferUsageFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCommandBufferUsageFlags.html
type CommandBufferUsageFlags Flags

// QueryControlFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkQueryControlFlags.html
type QueryControlFlags Flags

// DescriptorSetLayoutCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorSetLayoutCreateFlags.html
type DescriptorSetLayoutCreateFlags Flags

// ShaderModuleCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkShaderModuleCreateFlags.html
type ShaderModuleCreateFlags Flags

// DeviceQueueCreateFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDeviceQueueCreateFlagBits.html
type DeviceQueueCreateFlagBits uint32

const (
	VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT DeviceQueueCreateFlagBits = (1 << 0)
)

var (
	reverseDeviceQueueCreateFlagBits map[DeviceQueueCreateFlagBits]string = map[DeviceQueueCreateFlagBits]string{
		VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT: "VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT",
	}
)

func (x DeviceQueueCreateFlagBits) String() string {
	if s, ok := reverseDeviceQueueCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("DeviceQueueCreateFlagBits=%d", x)
}

// DeviceQueueCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDeviceQueueCreateFlags.html
type DeviceQueueCreateFlags Flags

// DeviceCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDeviceCreateFlags.html
type DeviceCreateFlags Flags

// SampleCountFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSampleCountFlags.html
type SampleCountFlags Flags

// QueueFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkQueueFlags.html
type QueueFlags Flags

// MemoryMapFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkMemoryMapFlags.html
type MemoryMapFlags Flags

// CommandPoolResetFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCommandPoolResetFlags.html
type CommandPoolResetFlags Flags

// PipelineCacheCreateFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineCacheCreateFlagBits.html
type PipelineCacheCreateFlagBits uint32

// PipelineCacheCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineCacheCreateFlags.html
type PipelineCacheCreateFlags Flags

// DescriptorPoolResetFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorPoolResetFlags.html
type DescriptorPoolResetFlags Flags

// CommandPoolCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCommandPoolCreateFlags.html
type CommandPoolCreateFlags Flags

// ColorComponentFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkColorComponentFlags.html
type ColorComponentFlags Flags

// MemoryPropertyFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkMemoryPropertyFlags.html
type MemoryPropertyFlags Flags

// MemoryHeapFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkMemoryHeapFlags.html
type MemoryHeapFlags Flags

// InstanceCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkInstanceCreateFlags.html
type InstanceCreateFlags Flags

// SubpassDescriptionFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSubpassDescriptionFlags.html
type SubpassDescriptionFlags Flags

// AccessFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkAccessFlags.html
type AccessFlags Flags

// ImageUsageFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageUsageFlags.html
type ImageUsageFlags Flags

// ImageAspectFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageAspectFlags.html
type ImageAspectFlags Flags

// BufferViewCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBufferViewCreateFlags.html
type BufferViewCreateFlags Flags

// CullModeFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCullModeFlags.html
type CullModeFlags Flags

// ImageCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageCreateFlags.html
type ImageCreateFlags Flags

// SparseImageFormatFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSparseImageFormatFlags.html
type SparseImageFormatFlags Flags

// FormatFeatureFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFormatFeatureFlags.html
type FormatFeatureFlags Flags

// AttachmentDescriptionFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkAttachmentDescriptionFlags.html
type AttachmentDescriptionFlags Flags

// QueryPipelineStatisticFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkQueryPipelineStatisticFlags.html
type QueryPipelineStatisticFlags Flags

// DescriptorPoolCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorPoolCreateFlags.html
type DescriptorPoolCreateFlags Flags

// ImageViewCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageViewCreateFlags.html
type ImageViewCreateFlags Flags

// ShaderStageFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkShaderStageFlags.html
type ShaderStageFlags Flags

// PipelineViewportStateCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineViewportStateCreateFlags.html
type PipelineViewportStateCreateFlags Flags

// SparseMemoryBindFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSparseMemoryBindFlags.html
type SparseMemoryBindFlags Flags

// DependencyFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDependencyFlags.html
type DependencyFlags Flags

// BufferCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBufferCreateFlags.html
type BufferCreateFlags Flags

// PipelineVertexInputStateCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineVertexInputStateCreateFlags.html
type PipelineVertexInputStateCreateFlags Flags

// PipelineColorBlendStateCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineColorBlendStateCreateFlags.html
type PipelineColorBlendStateCreateFlags Flags

// RenderPassCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkRenderPassCreateFlags.html
type RenderPassCreateFlags Flags

// PipelineCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineCreateFlags.html
type PipelineCreateFlags Flags

// PipelineDepthStencilStateCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineDepthStencilStateCreateFlags.html
type PipelineDepthStencilStateCreateFlags Flags

// FenceCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFenceCreateFlags.html
type FenceCreateFlags Flags

// PipelineDynamicStateCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineDynamicStateCreateFlags.html
type PipelineDynamicStateCreateFlags Flags

// PipelineInputAssemblyStateCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineInputAssemblyStateCreateFlags.html
type PipelineInputAssemblyStateCreateFlags Flags

// StencilFaceFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkStencilFaceFlags.html
type StencilFaceFlags Flags

// QueryPoolCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkQueryPoolCreateFlags.html
type QueryPoolCreateFlags Flags

// SemaphoreCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSemaphoreCreateFlags.html
type SemaphoreCreateFlags Flags

// SamplerCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSamplerCreateFlags.html
type SamplerCreateFlags Flags

// PipelineLayoutCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineLayoutCreateFlags.html
type PipelineLayoutCreateFlags Flags

// QueryResultFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkQueryResultFlags.html
type QueryResultFlags Flags

// FramebufferCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFramebufferCreateFlags.html
type FramebufferCreateFlags Flags

// PipelineMultisampleStateCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineMultisampleStateCreateFlags.html
type PipelineMultisampleStateCreateFlags Flags

// PipelineRasterizationStateCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineRasterizationStateCreateFlags.html
type PipelineRasterizationStateCreateFlags Flags

// PipelineShaderStageCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineShaderStageCreateFlags.html
type PipelineShaderStageCreateFlags Flags

// BufferUsageFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBufferUsageFlags.html
type BufferUsageFlags Flags

// PipelineTessellationStateCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineTessellationStateCreateFlags.html
type PipelineTessellationStateCreateFlags Flags

// EventCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkEventCreateFlags.html
type EventCreateFlags Flags

// PFN_vkFreeFunction is a function pointer from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/PFN_vkFreeFunction.html
type PFN_vkFreeFunction C.PFN_vkFreeFunction

// PFN_vkInternalAllocationNotification is a function pointer from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/PFN_vkInternalAllocationNotification.html
type PFN_vkInternalAllocationNotification C.PFN_vkInternalAllocationNotification

// PFN_vkInternalFreeNotification is a function pointer from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/PFN_vkInternalFreeNotification.html
type PFN_vkInternalFreeNotification C.PFN_vkInternalFreeNotification

// PFN_vkReallocationFunction is a function pointer from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/PFN_vkReallocationFunction.html
type PFN_vkReallocationFunction C.PFN_vkReallocationFunction

// PFN_vkVoidFunction is a function pointer from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/PFN_vkVoidFunction.html
type PFN_vkVoidFunction C.PFN_vkVoidFunction

// PFN_vkAllocationFunction is a function pointer from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/PFN_vkAllocationFunction.html
type PFN_vkAllocationFunction C.PFN_vkAllocationFunction

//LayerProperties provides a go interface for VkLayerProperties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkLayerProperties.html
type LayerProperties C.struct_VkLayerProperties

// SizeofLayerProperties is the memory size of a LayerProperties
var SizeofLayerProperties int = int(unsafe.Sizeof(LayerProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *LayerProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x LayerProperties) AsCPtr() *LayerProperties {
	clone := (*LayerProperties)(newCBlock(C.ulong(SizeofLayerProperties)))
	*clone = x
	return clone
}

// LayerPropertiesFreeCSlice releases the memory allocated by LayerPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func LayerPropertiesFreeCSlice(x []LayerProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// LayerPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. LayerPropertiesFreeCSlice must be called on the returned slice.
func LayerPropertiesMakeCSlice(x ...LayerProperties) []LayerProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofLayerProperties * len(x)
	dst := unsafe.Slice((*LayerProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// LayerName returns the value of layerName from VkLayerProperties
func (x LayerProperties) LayerName() []byte {
	ptr := func(x *[VK_MAX_EXTENSION_NAME_SIZE]C.char) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_EXTENSION_NAME_SIZE)
		return &slc
	}(&x.layerName)
	return *ptr
}

// SpecVersion returns the value of specVersion from VkLayerProperties
func (x LayerProperties) SpecVersion() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.specVersion)
	return *ptr
}

// ImplementationVersion returns the value of implementationVersion from VkLayerProperties
func (x LayerProperties) ImplementationVersion() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.implementationVersion)
	return *ptr
}

// Description returns the value of description from VkLayerProperties
func (x LayerProperties) Description() []byte {
	ptr := func(x *[VK_MAX_DESCRIPTION_SIZE]C.char) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_DESCRIPTION_SIZE)
		return &slc
	}(&x.description)
	return *ptr
}

//QueryPoolCreateInfo provides a go interface for VkQueryPoolCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkQueryPoolCreateInfo.html
type QueryPoolCreateInfo C.struct_VkQueryPoolCreateInfo

// SizeofQueryPoolCreateInfo is the memory size of a QueryPoolCreateInfo
var SizeofQueryPoolCreateInfo int = int(unsafe.Sizeof(QueryPoolCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *QueryPoolCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x QueryPoolCreateInfo) AsCPtr() *QueryPoolCreateInfo {
	clone := (*QueryPoolCreateInfo)(newCBlock(C.ulong(SizeofQueryPoolCreateInfo)))
	*clone = x
	return clone
}

// QueryPoolCreateInfoFreeCSlice releases the memory allocated by QueryPoolCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func QueryPoolCreateInfoFreeCSlice(x []QueryPoolCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// QueryPoolCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. QueryPoolCreateInfoFreeCSlice must be called on the returned slice.
func QueryPoolCreateInfoMakeCSlice(x ...QueryPoolCreateInfo) []QueryPoolCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofQueryPoolCreateInfo * len(x)
	dst := unsafe.Slice((*QueryPoolCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkQueryPoolCreateInfo
func (x QueryPoolCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x QueryPoolCreateInfo) WithDefaultSType() QueryPoolCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x QueryPoolCreateInfo) WithSType(y StructureType) QueryPoolCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkQueryPoolCreateInfo
func (x QueryPoolCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x QueryPoolCreateInfo) WithPNext(y unsafe.Pointer) QueryPoolCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkQueryPoolCreateInfo
func (x QueryPoolCreateInfo) Flags() QueryPoolCreateFlags {
	ptr := /* typedef */ (*QueryPoolCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x QueryPoolCreateInfo) WithFlags(y QueryPoolCreateFlags) QueryPoolCreateInfo {
	ptr := /* typedef */ (*C.VkQueryPoolCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// QueryType returns the value of queryType from VkQueryPoolCreateInfo
func (x QueryPoolCreateInfo) QueryType() QueryType {
	ptr := /* typedef */ (*QueryType)(&x.queryType)
	return *ptr
}

// WithQueryType sets the value for the QueryType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x QueryPoolCreateInfo) WithQueryType(y QueryType) QueryPoolCreateInfo {
	ptr := /* typedef */ (*C.VkQueryType)(&y)
	x.queryType = *ptr
	return x
}

// QueryCount returns the value of queryCount from VkQueryPoolCreateInfo
func (x QueryPoolCreateInfo) QueryCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.queryCount)
	return *ptr
}

// WithQueryCount sets the value for the QueryCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x QueryPoolCreateInfo) WithQueryCount(y uint32) QueryPoolCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.queryCount = *ptr
	return x
}

// PipelineStatistics returns the value of pipelineStatistics from VkQueryPoolCreateInfo
func (x QueryPoolCreateInfo) PipelineStatistics() QueryPipelineStatisticFlags {
	ptr := /* typedef */ (*QueryPipelineStatisticFlags)(&x.pipelineStatistics)
	return *ptr
}

// WithPipelineStatistics sets the value for the PipelineStatistics on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x QueryPoolCreateInfo) WithPipelineStatistics(y QueryPipelineStatisticFlags) QueryPoolCreateInfo {
	ptr := /* typedef */ (*C.VkQueryPipelineStatisticFlags)(&y)
	x.pipelineStatistics = *ptr
	return x
}

//EventCreateInfo provides a go interface for VkEventCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkEventCreateInfo.html
type EventCreateInfo C.struct_VkEventCreateInfo

// SizeofEventCreateInfo is the memory size of a EventCreateInfo
var SizeofEventCreateInfo int = int(unsafe.Sizeof(EventCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *EventCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x EventCreateInfo) AsCPtr() *EventCreateInfo {
	clone := (*EventCreateInfo)(newCBlock(C.ulong(SizeofEventCreateInfo)))
	*clone = x
	return clone
}

// EventCreateInfoFreeCSlice releases the memory allocated by EventCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func EventCreateInfoFreeCSlice(x []EventCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// EventCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. EventCreateInfoFreeCSlice must be called on the returned slice.
func EventCreateInfoMakeCSlice(x ...EventCreateInfo) []EventCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofEventCreateInfo * len(x)
	dst := unsafe.Slice((*EventCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkEventCreateInfo
func (x EventCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x EventCreateInfo) WithDefaultSType() EventCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_EVENT_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x EventCreateInfo) WithSType(y StructureType) EventCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkEventCreateInfo
func (x EventCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x EventCreateInfo) WithPNext(y unsafe.Pointer) EventCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkEventCreateInfo
func (x EventCreateInfo) Flags() EventCreateFlags {
	ptr := /* typedef */ (*EventCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x EventCreateInfo) WithFlags(y EventCreateFlags) EventCreateInfo {
	ptr := /* typedef */ (*C.VkEventCreateFlags)(&y)
	x.flags = *ptr
	return x
}

//FramebufferCreateInfo provides a go interface for VkFramebufferCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFramebufferCreateInfo.html
type FramebufferCreateInfo C.struct_VkFramebufferCreateInfo

// SizeofFramebufferCreateInfo is the memory size of a FramebufferCreateInfo
var SizeofFramebufferCreateInfo int = int(unsafe.Sizeof(FramebufferCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *FramebufferCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x FramebufferCreateInfo) AsCPtr() *FramebufferCreateInfo {
	clone := (*FramebufferCreateInfo)(newCBlock(C.ulong(SizeofFramebufferCreateInfo)))
	*clone = x
	return clone
}

// FramebufferCreateInfoFreeCSlice releases the memory allocated by FramebufferCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func FramebufferCreateInfoFreeCSlice(x []FramebufferCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// FramebufferCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. FramebufferCreateInfoFreeCSlice must be called on the returned slice.
func FramebufferCreateInfoMakeCSlice(x ...FramebufferCreateInfo) []FramebufferCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFramebufferCreateInfo * len(x)
	dst := unsafe.Slice((*FramebufferCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkFramebufferCreateInfo
func (x FramebufferCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x FramebufferCreateInfo) WithDefaultSType() FramebufferCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferCreateInfo) WithSType(y StructureType) FramebufferCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkFramebufferCreateInfo
func (x FramebufferCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferCreateInfo) WithPNext(y unsafe.Pointer) FramebufferCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkFramebufferCreateInfo
func (x FramebufferCreateInfo) Flags() FramebufferCreateFlags {
	ptr := /* typedef */ (*FramebufferCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferCreateInfo) WithFlags(y FramebufferCreateFlags) FramebufferCreateInfo {
	ptr := /* typedef */ (*C.VkFramebufferCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// RenderPass returns the value of renderPass from VkFramebufferCreateInfo
func (x FramebufferCreateInfo) RenderPass() RenderPass {
	ptr := /* handle */ (*RenderPass)(&x.renderPass)
	return *ptr
}

// WithRenderPass sets the value for the RenderPass on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferCreateInfo) WithRenderPass(y RenderPass) FramebufferCreateInfo {
	ptr := /* handle */ (*C.VkRenderPass)(&y)
	x.renderPass = *ptr
	return x
}

// AttachmentCount returns the value of attachmentCount from VkFramebufferCreateInfo
func (x FramebufferCreateInfo) AttachmentCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.attachmentCount)
	return *ptr
}

// WithAttachmentCount sets the value for the AttachmentCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferCreateInfo) WithAttachmentCount(y uint32) FramebufferCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.attachmentCount = *ptr
	return x
}

// PAttachments returns the value of pAttachments from VkFramebufferCreateInfo
func (x FramebufferCreateInfo) PAttachments() []ImageView {
	ptr := func(x **C.VkImageView) *[]ImageView { /* Slice */
		slc := unsafe.Slice((*ImageView)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pAttachments)
	return *ptr
}

// WithPAttachments sets the value for the PAttachments on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines AttachmentCount as the length of this field.
// AttachmentCount is updated with the length of the new value.
func (x FramebufferCreateInfo) WithPAttachments(y []ImageView) FramebufferCreateInfo {
	ptr := func(x *[]ImageView) **C.VkImageView { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkImageView)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkImageView)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pAttachments = *ptr
	return x.WithAttachmentCount(uint32(len(y)))
}

// Width returns the value of width from VkFramebufferCreateInfo
func (x FramebufferCreateInfo) Width() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.width)
	return *ptr
}

// WithWidth sets the value for the Width on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferCreateInfo) WithWidth(y uint32) FramebufferCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.width = *ptr
	return x
}

// Height returns the value of height from VkFramebufferCreateInfo
func (x FramebufferCreateInfo) Height() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.height)
	return *ptr
}

// WithHeight sets the value for the Height on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferCreateInfo) WithHeight(y uint32) FramebufferCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.height = *ptr
	return x
}

// Layers returns the value of layers from VkFramebufferCreateInfo
func (x FramebufferCreateInfo) Layers() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.layers)
	return *ptr
}

// WithLayers sets the value for the Layers on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferCreateInfo) WithLayers(y uint32) FramebufferCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.layers = *ptr
	return x
}

//SparseImageMemoryRequirements provides a go interface for VkSparseImageMemoryRequirements.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSparseImageMemoryRequirements.html
type SparseImageMemoryRequirements C.struct_VkSparseImageMemoryRequirements

// SizeofSparseImageMemoryRequirements is the memory size of a SparseImageMemoryRequirements
var SizeofSparseImageMemoryRequirements int = int(unsafe.Sizeof(SparseImageMemoryRequirements{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SparseImageMemoryRequirements) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SparseImageMemoryRequirements) AsCPtr() *SparseImageMemoryRequirements {
	clone := (*SparseImageMemoryRequirements)(newCBlock(C.ulong(SizeofSparseImageMemoryRequirements)))
	*clone = x
	return clone
}

// SparseImageMemoryRequirementsFreeCSlice releases the memory allocated by SparseImageMemoryRequirementsMakeCSlice.
// It does not free pointers stored inside the slice.
func SparseImageMemoryRequirementsFreeCSlice(x []SparseImageMemoryRequirements) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SparseImageMemoryRequirementsMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SparseImageMemoryRequirementsFreeCSlice must be called on the returned slice.
func SparseImageMemoryRequirementsMakeCSlice(x ...SparseImageMemoryRequirements) []SparseImageMemoryRequirements {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageMemoryRequirements * len(x)
	dst := unsafe.Slice((*SparseImageMemoryRequirements)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// FormatProperties returns the value of formatProperties from VkSparseImageMemoryRequirements
func (x SparseImageMemoryRequirements) FormatProperties() SparseImageFormatProperties {
	ptr := /* typedef */ (*SparseImageFormatProperties)(&x.formatProperties)
	return *ptr
}

// ImageMipTailFirstLod returns the value of imageMipTailFirstLod from VkSparseImageMemoryRequirements
func (x SparseImageMemoryRequirements) ImageMipTailFirstLod() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.imageMipTailFirstLod)
	return *ptr
}

// ImageMipTailSize returns the value of imageMipTailSize from VkSparseImageMemoryRequirements
func (x SparseImageMemoryRequirements) ImageMipTailSize() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.imageMipTailSize)
	return *ptr
}

// ImageMipTailOffset returns the value of imageMipTailOffset from VkSparseImageMemoryRequirements
func (x SparseImageMemoryRequirements) ImageMipTailOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.imageMipTailOffset)
	return *ptr
}

// ImageMipTailStride returns the value of imageMipTailStride from VkSparseImageMemoryRequirements
func (x SparseImageMemoryRequirements) ImageMipTailStride() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.imageMipTailStride)
	return *ptr
}

//AttachmentReference provides a go interface for VkAttachmentReference.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkAttachmentReference.html
type AttachmentReference C.struct_VkAttachmentReference

// SizeofAttachmentReference is the memory size of a AttachmentReference
var SizeofAttachmentReference int = int(unsafe.Sizeof(AttachmentReference{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *AttachmentReference) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x AttachmentReference) AsCPtr() *AttachmentReference {
	clone := (*AttachmentReference)(newCBlock(C.ulong(SizeofAttachmentReference)))
	*clone = x
	return clone
}

// AttachmentReferenceFreeCSlice releases the memory allocated by AttachmentReferenceMakeCSlice.
// It does not free pointers stored inside the slice.
func AttachmentReferenceFreeCSlice(x []AttachmentReference) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// AttachmentReferenceMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. AttachmentReferenceFreeCSlice must be called on the returned slice.
func AttachmentReferenceMakeCSlice(x ...AttachmentReference) []AttachmentReference {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAttachmentReference * len(x)
	dst := unsafe.Slice((*AttachmentReference)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Attachment returns the value of attachment from VkAttachmentReference
func (x AttachmentReference) Attachment() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.attachment)
	return *ptr
}

// WithAttachment sets the value for the Attachment on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReference) WithAttachment(y uint32) AttachmentReference {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.attachment = *ptr
	return x
}

// Layout returns the value of layout from VkAttachmentReference
func (x AttachmentReference) Layout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.layout)
	return *ptr
}

// WithLayout sets the value for the Layout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReference) WithLayout(y ImageLayout) AttachmentReference {
	ptr := /* typedef */ (*C.VkImageLayout)(&y)
	x.layout = *ptr
	return x
}

//SemaphoreCreateInfo provides a go interface for VkSemaphoreCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSemaphoreCreateInfo.html
type SemaphoreCreateInfo C.struct_VkSemaphoreCreateInfo

// SizeofSemaphoreCreateInfo is the memory size of a SemaphoreCreateInfo
var SizeofSemaphoreCreateInfo int = int(unsafe.Sizeof(SemaphoreCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SemaphoreCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SemaphoreCreateInfo) AsCPtr() *SemaphoreCreateInfo {
	clone := (*SemaphoreCreateInfo)(newCBlock(C.ulong(SizeofSemaphoreCreateInfo)))
	*clone = x
	return clone
}

// SemaphoreCreateInfoFreeCSlice releases the memory allocated by SemaphoreCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SemaphoreCreateInfoFreeCSlice(x []SemaphoreCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SemaphoreCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SemaphoreCreateInfoFreeCSlice must be called on the returned slice.
func SemaphoreCreateInfoMakeCSlice(x ...SemaphoreCreateInfo) []SemaphoreCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSemaphoreCreateInfo * len(x)
	dst := unsafe.Slice((*SemaphoreCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSemaphoreCreateInfo
func (x SemaphoreCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SemaphoreCreateInfo) WithDefaultSType() SemaphoreCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreCreateInfo) WithSType(y StructureType) SemaphoreCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkSemaphoreCreateInfo
func (x SemaphoreCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreCreateInfo) WithPNext(y unsafe.Pointer) SemaphoreCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkSemaphoreCreateInfo
func (x SemaphoreCreateInfo) Flags() SemaphoreCreateFlags {
	ptr := /* typedef */ (*SemaphoreCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreCreateInfo) WithFlags(y SemaphoreCreateFlags) SemaphoreCreateInfo {
	ptr := /* typedef */ (*C.VkSemaphoreCreateFlags)(&y)
	x.flags = *ptr
	return x
}

//RenderPassCreateInfo provides a go interface for VkRenderPassCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkRenderPassCreateInfo.html
type RenderPassCreateInfo C.struct_VkRenderPassCreateInfo

// SizeofRenderPassCreateInfo is the memory size of a RenderPassCreateInfo
var SizeofRenderPassCreateInfo int = int(unsafe.Sizeof(RenderPassCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *RenderPassCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x RenderPassCreateInfo) AsCPtr() *RenderPassCreateInfo {
	clone := (*RenderPassCreateInfo)(newCBlock(C.ulong(SizeofRenderPassCreateInfo)))
	*clone = x
	return clone
}

// RenderPassCreateInfoFreeCSlice releases the memory allocated by RenderPassCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func RenderPassCreateInfoFreeCSlice(x []RenderPassCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// RenderPassCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. RenderPassCreateInfoFreeCSlice must be called on the returned slice.
func RenderPassCreateInfoMakeCSlice(x ...RenderPassCreateInfo) []RenderPassCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderPassCreateInfo * len(x)
	dst := unsafe.Slice((*RenderPassCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkRenderPassCreateInfo
func (x RenderPassCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x RenderPassCreateInfo) WithDefaultSType() RenderPassCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo) WithSType(y StructureType) RenderPassCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkRenderPassCreateInfo
func (x RenderPassCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo) WithPNext(y unsafe.Pointer) RenderPassCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkRenderPassCreateInfo
func (x RenderPassCreateInfo) Flags() RenderPassCreateFlags {
	ptr := /* typedef */ (*RenderPassCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo) WithFlags(y RenderPassCreateFlags) RenderPassCreateInfo {
	ptr := /* typedef */ (*C.VkRenderPassCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// AttachmentCount returns the value of attachmentCount from VkRenderPassCreateInfo
func (x RenderPassCreateInfo) AttachmentCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.attachmentCount)
	return *ptr
}

// WithAttachmentCount sets the value for the AttachmentCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo) WithAttachmentCount(y uint32) RenderPassCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.attachmentCount = *ptr
	return x
}

// PAttachments returns the value of pAttachments from VkRenderPassCreateInfo
func (x RenderPassCreateInfo) PAttachments() []AttachmentDescription {
	ptr := func(x **C.struct_VkAttachmentDescription) *[]AttachmentDescription { /* Slice */
		slc := unsafe.Slice((*AttachmentDescription)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pAttachments)
	return *ptr
}

// WithPAttachments sets the value for the PAttachments on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines AttachmentCount as the length of this field.
// AttachmentCount is updated with the length of the new value.
func (x RenderPassCreateInfo) WithPAttachments(y []AttachmentDescription) RenderPassCreateInfo {
	ptr := func(x *[]AttachmentDescription) **C.struct_VkAttachmentDescription { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkAttachmentDescription)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkAttachmentDescription)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pAttachments = *ptr
	return x.WithAttachmentCount(uint32(len(y)))
}

// SubpassCount returns the value of subpassCount from VkRenderPassCreateInfo
func (x RenderPassCreateInfo) SubpassCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.subpassCount)
	return *ptr
}

// WithSubpassCount sets the value for the SubpassCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo) WithSubpassCount(y uint32) RenderPassCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.subpassCount = *ptr
	return x
}

// PSubpasses returns the value of pSubpasses from VkRenderPassCreateInfo
func (x RenderPassCreateInfo) PSubpasses() []SubpassDescription {
	ptr := func(x **C.struct_VkSubpassDescription) *[]SubpassDescription { /* Slice */
		slc := unsafe.Slice((*SubpassDescription)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pSubpasses)
	return *ptr
}

// WithPSubpasses sets the value for the PSubpasses on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SubpassCount as the length of this field.
// SubpassCount is updated with the length of the new value.
func (x RenderPassCreateInfo) WithPSubpasses(y []SubpassDescription) RenderPassCreateInfo {
	ptr := func(x *[]SubpassDescription) **C.struct_VkSubpassDescription { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSubpassDescription)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSubpassDescription)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pSubpasses = *ptr
	return x.WithSubpassCount(uint32(len(y)))
}

// DependencyCount returns the value of dependencyCount from VkRenderPassCreateInfo
func (x RenderPassCreateInfo) DependencyCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.dependencyCount)
	return *ptr
}

// WithDependencyCount sets the value for the DependencyCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo) WithDependencyCount(y uint32) RenderPassCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.dependencyCount = *ptr
	return x
}

// PDependencies returns the value of pDependencies from VkRenderPassCreateInfo
func (x RenderPassCreateInfo) PDependencies() []SubpassDependency {
	ptr := func(x **C.struct_VkSubpassDependency) *[]SubpassDependency { /* Slice */
		slc := unsafe.Slice((*SubpassDependency)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pDependencies)
	return *ptr
}

// WithPDependencies sets the value for the PDependencies on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DependencyCount as the length of this field.
// DependencyCount is updated with the length of the new value.
func (x RenderPassCreateInfo) WithPDependencies(y []SubpassDependency) RenderPassCreateInfo {
	ptr := func(x *[]SubpassDependency) **C.struct_VkSubpassDependency { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSubpassDependency)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSubpassDependency)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pDependencies = *ptr
	return x.WithDependencyCount(uint32(len(y)))
}

//SubpassDependency provides a go interface for VkSubpassDependency.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSubpassDependency.html
type SubpassDependency C.struct_VkSubpassDependency

// SizeofSubpassDependency is the memory size of a SubpassDependency
var SizeofSubpassDependency int = int(unsafe.Sizeof(SubpassDependency{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubpassDependency) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubpassDependency) AsCPtr() *SubpassDependency {
	clone := (*SubpassDependency)(newCBlock(C.ulong(SizeofSubpassDependency)))
	*clone = x
	return clone
}

// SubpassDependencyFreeCSlice releases the memory allocated by SubpassDependencyMakeCSlice.
// It does not free pointers stored inside the slice.
func SubpassDependencyFreeCSlice(x []SubpassDependency) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubpassDependencyMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubpassDependencyFreeCSlice must be called on the returned slice.
func SubpassDependencyMakeCSlice(x ...SubpassDependency) []SubpassDependency {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassDependency * len(x)
	dst := unsafe.Slice((*SubpassDependency)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SrcSubpass returns the value of srcSubpass from VkSubpassDependency
func (x SubpassDependency) SrcSubpass() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.srcSubpass)
	return *ptr
}

// WithSrcSubpass sets the value for the SrcSubpass on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency) WithSrcSubpass(y uint32) SubpassDependency {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.srcSubpass = *ptr
	return x
}

// DstSubpass returns the value of dstSubpass from VkSubpassDependency
func (x SubpassDependency) DstSubpass() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.dstSubpass)
	return *ptr
}

// WithDstSubpass sets the value for the DstSubpass on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency) WithDstSubpass(y uint32) SubpassDependency {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.dstSubpass = *ptr
	return x
}

// SrcStageMask returns the value of srcStageMask from VkSubpassDependency
func (x SubpassDependency) SrcStageMask() PipelineStageFlags {
	ptr := /* typedef */ (*PipelineStageFlags)(&x.srcStageMask)
	return *ptr
}

// WithSrcStageMask sets the value for the SrcStageMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency) WithSrcStageMask(y PipelineStageFlags) SubpassDependency {
	ptr := /* typedef */ (*C.VkPipelineStageFlags)(&y)
	x.srcStageMask = *ptr
	return x
}

// DstStageMask returns the value of dstStageMask from VkSubpassDependency
func (x SubpassDependency) DstStageMask() PipelineStageFlags {
	ptr := /* typedef */ (*PipelineStageFlags)(&x.dstStageMask)
	return *ptr
}

// WithDstStageMask sets the value for the DstStageMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency) WithDstStageMask(y PipelineStageFlags) SubpassDependency {
	ptr := /* typedef */ (*C.VkPipelineStageFlags)(&y)
	x.dstStageMask = *ptr
	return x
}

// SrcAccessMask returns the value of srcAccessMask from VkSubpassDependency
func (x SubpassDependency) SrcAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.srcAccessMask)
	return *ptr
}

// WithSrcAccessMask sets the value for the SrcAccessMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency) WithSrcAccessMask(y AccessFlags) SubpassDependency {
	ptr := /* typedef */ (*C.VkAccessFlags)(&y)
	x.srcAccessMask = *ptr
	return x
}

// DstAccessMask returns the value of dstAccessMask from VkSubpassDependency
func (x SubpassDependency) DstAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.dstAccessMask)
	return *ptr
}

// WithDstAccessMask sets the value for the DstAccessMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency) WithDstAccessMask(y AccessFlags) SubpassDependency {
	ptr := /* typedef */ (*C.VkAccessFlags)(&y)
	x.dstAccessMask = *ptr
	return x
}

// DependencyFlags returns the value of dependencyFlags from VkSubpassDependency
func (x SubpassDependency) DependencyFlags() DependencyFlags {
	ptr := /* typedef */ (*DependencyFlags)(&x.dependencyFlags)
	return *ptr
}

// WithDependencyFlags sets the value for the DependencyFlags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency) WithDependencyFlags(y DependencyFlags) SubpassDependency {
	ptr := /* typedef */ (*C.VkDependencyFlags)(&y)
	x.dependencyFlags = *ptr
	return x
}

//SubpassDescription provides a go interface for VkSubpassDescription.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSubpassDescription.html
type SubpassDescription C.struct_VkSubpassDescription

// SizeofSubpassDescription is the memory size of a SubpassDescription
var SizeofSubpassDescription int = int(unsafe.Sizeof(SubpassDescription{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubpassDescription) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubpassDescription) AsCPtr() *SubpassDescription {
	clone := (*SubpassDescription)(newCBlock(C.ulong(SizeofSubpassDescription)))
	*clone = x
	return clone
}

// SubpassDescriptionFreeCSlice releases the memory allocated by SubpassDescriptionMakeCSlice.
// It does not free pointers stored inside the slice.
func SubpassDescriptionFreeCSlice(x []SubpassDescription) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubpassDescriptionMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubpassDescriptionFreeCSlice must be called on the returned slice.
func SubpassDescriptionMakeCSlice(x ...SubpassDescription) []SubpassDescription {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassDescription * len(x)
	dst := unsafe.Slice((*SubpassDescription)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Flags returns the value of flags from VkSubpassDescription
func (x SubpassDescription) Flags() SubpassDescriptionFlags {
	ptr := /* typedef */ (*SubpassDescriptionFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription) WithFlags(y SubpassDescriptionFlags) SubpassDescription {
	ptr := /* typedef */ (*C.VkSubpassDescriptionFlags)(&y)
	x.flags = *ptr
	return x
}

// PipelineBindPoint returns the value of pipelineBindPoint from VkSubpassDescription
func (x SubpassDescription) PipelineBindPoint() PipelineBindPoint {
	ptr := /* typedef */ (*PipelineBindPoint)(&x.pipelineBindPoint)
	return *ptr
}

// WithPipelineBindPoint sets the value for the PipelineBindPoint on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription) WithPipelineBindPoint(y PipelineBindPoint) SubpassDescription {
	ptr := /* typedef */ (*C.VkPipelineBindPoint)(&y)
	x.pipelineBindPoint = *ptr
	return x
}

// InputAttachmentCount returns the value of inputAttachmentCount from VkSubpassDescription
func (x SubpassDescription) InputAttachmentCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.inputAttachmentCount)
	return *ptr
}

// WithInputAttachmentCount sets the value for the InputAttachmentCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription) WithInputAttachmentCount(y uint32) SubpassDescription {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.inputAttachmentCount = *ptr
	return x
}

// PInputAttachments returns the value of pInputAttachments from VkSubpassDescription
func (x SubpassDescription) PInputAttachments() []AttachmentReference {
	ptr := func(x **C.struct_VkAttachmentReference) *[]AttachmentReference { /* Slice */
		slc := unsafe.Slice((*AttachmentReference)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pInputAttachments)
	return *ptr
}

// WithPInputAttachments sets the value for the PInputAttachments on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines InputAttachmentCount as the length of this field.
// InputAttachmentCount is updated with the length of the new value.
func (x SubpassDescription) WithPInputAttachments(y []AttachmentReference) SubpassDescription {
	ptr := func(x *[]AttachmentReference) **C.struct_VkAttachmentReference { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkAttachmentReference)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkAttachmentReference)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pInputAttachments = *ptr
	return x.WithInputAttachmentCount(uint32(len(y)))
}

// ColorAttachmentCount returns the value of colorAttachmentCount from VkSubpassDescription
func (x SubpassDescription) ColorAttachmentCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.colorAttachmentCount)
	return *ptr
}

// WithColorAttachmentCount sets the value for the ColorAttachmentCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription) WithColorAttachmentCount(y uint32) SubpassDescription {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.colorAttachmentCount = *ptr
	return x
}

// PColorAttachments returns the value of pColorAttachments from VkSubpassDescription
func (x SubpassDescription) PColorAttachments() []AttachmentReference {
	ptr := func(x **C.struct_VkAttachmentReference) *[]AttachmentReference { /* Slice */
		slc := unsafe.Slice((*AttachmentReference)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pColorAttachments)
	return *ptr
}

// WithPColorAttachments sets the value for the PColorAttachments on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines ColorAttachmentCount as the length of this field.
// ColorAttachmentCount is updated with the length of the new value.
func (x SubpassDescription) WithPColorAttachments(y []AttachmentReference) SubpassDescription {
	ptr := func(x *[]AttachmentReference) **C.struct_VkAttachmentReference { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkAttachmentReference)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkAttachmentReference)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pColorAttachments = *ptr
	return x.WithColorAttachmentCount(uint32(len(y)))
}

// PResolveAttachments returns the value of pResolveAttachments from VkSubpassDescription
func (x SubpassDescription) PResolveAttachments() []AttachmentReference {
	ptr := func(x **C.struct_VkAttachmentReference) *[]AttachmentReference { /* Slice */
		slc := unsafe.Slice((*AttachmentReference)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pResolveAttachments)
	return *ptr
}

// WithPResolveAttachments sets the value for the PResolveAttachments on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines ColorAttachmentCount as the length of this field.
// ColorAttachmentCount is updated with the length of the new value.
func (x SubpassDescription) WithPResolveAttachments(y []AttachmentReference) SubpassDescription {
	ptr := func(x *[]AttachmentReference) **C.struct_VkAttachmentReference { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkAttachmentReference)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkAttachmentReference)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pResolveAttachments = *ptr
	return x.WithColorAttachmentCount(uint32(len(y)))
}

// PDepthStencilAttachment returns the value of pDepthStencilAttachment from VkSubpassDescription
func (x SubpassDescription) PDepthStencilAttachment() *AttachmentReference {
	ptr := func(x **C.struct_VkAttachmentReference) **AttachmentReference { /* Pointer */
		return (**AttachmentReference)(unsafe.Pointer(x))
	}(&x.pDepthStencilAttachment)
	return *ptr
}

// WithPDepthStencilAttachment sets the value for the PDepthStencilAttachment on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription) WithPDepthStencilAttachment(y *AttachmentReference) SubpassDescription {
	ptr := func(x **AttachmentReference) **C.struct_VkAttachmentReference { /* Pointer */
		return (**C.struct_VkAttachmentReference)(unsafe.Pointer(x))
	}(&y)
	x.pDepthStencilAttachment = *ptr
	return x
}

// PreserveAttachmentCount returns the value of preserveAttachmentCount from VkSubpassDescription
func (x SubpassDescription) PreserveAttachmentCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.preserveAttachmentCount)
	return *ptr
}

// WithPreserveAttachmentCount sets the value for the PreserveAttachmentCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription) WithPreserveAttachmentCount(y uint32) SubpassDescription {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.preserveAttachmentCount = *ptr
	return x
}

// PPreserveAttachments returns the value of pPreserveAttachments from VkSubpassDescription
func (x SubpassDescription) PPreserveAttachments() []uint32 {
	ptr := func(x **C.uint) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pPreserveAttachments)
	return *ptr
}

// WithPPreserveAttachments sets the value for the PPreserveAttachments on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines PreserveAttachmentCount as the length of this field.
// PreserveAttachmentCount is updated with the length of the new value.
func (x SubpassDescription) WithPPreserveAttachments(y []uint32) SubpassDescription {
	ptr := func(x *[]uint32) **C.uint { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pPreserveAttachments = *ptr
	return x.WithPreserveAttachmentCount(uint32(len(y)))
}

//BufferCreateInfo provides a go interface for VkBufferCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBufferCreateInfo.html
type BufferCreateInfo C.struct_VkBufferCreateInfo

// SizeofBufferCreateInfo is the memory size of a BufferCreateInfo
var SizeofBufferCreateInfo int = int(unsafe.Sizeof(BufferCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferCreateInfo) AsCPtr() *BufferCreateInfo {
	clone := (*BufferCreateInfo)(newCBlock(C.ulong(SizeofBufferCreateInfo)))
	*clone = x
	return clone
}

// BufferCreateInfoFreeCSlice releases the memory allocated by BufferCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BufferCreateInfoFreeCSlice(x []BufferCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferCreateInfoFreeCSlice must be called on the returned slice.
func BufferCreateInfoMakeCSlice(x ...BufferCreateInfo) []BufferCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferCreateInfo * len(x)
	dst := unsafe.Slice((*BufferCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBufferCreateInfo
func (x BufferCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BufferCreateInfo) WithDefaultSType() BufferCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCreateInfo) WithSType(y StructureType) BufferCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkBufferCreateInfo
func (x BufferCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCreateInfo) WithPNext(y unsafe.Pointer) BufferCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkBufferCreateInfo
func (x BufferCreateInfo) Flags() BufferCreateFlags {
	ptr := /* typedef */ (*BufferCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCreateInfo) WithFlags(y BufferCreateFlags) BufferCreateInfo {
	ptr := /* typedef */ (*C.VkBufferCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// Size returns the value of size from VkBufferCreateInfo
func (x BufferCreateInfo) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size)
	return *ptr
}

// WithSize sets the value for the Size on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCreateInfo) WithSize(y DeviceSize) BufferCreateInfo {
	ptr := /* typedef */ (*C.VkDeviceSize)(&y)
	x.size = *ptr
	return x
}

// Usage returns the value of usage from VkBufferCreateInfo
func (x BufferCreateInfo) Usage() BufferUsageFlags {
	ptr := /* typedef */ (*BufferUsageFlags)(&x.usage)
	return *ptr
}

// WithUsage sets the value for the Usage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCreateInfo) WithUsage(y BufferUsageFlags) BufferCreateInfo {
	ptr := /* typedef */ (*C.VkBufferUsageFlags)(&y)
	x.usage = *ptr
	return x
}

// SharingMode returns the value of sharingMode from VkBufferCreateInfo
func (x BufferCreateInfo) SharingMode() SharingMode {
	ptr := /* typedef */ (*SharingMode)(&x.sharingMode)
	return *ptr
}

// WithSharingMode sets the value for the SharingMode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCreateInfo) WithSharingMode(y SharingMode) BufferCreateInfo {
	ptr := /* typedef */ (*C.VkSharingMode)(&y)
	x.sharingMode = *ptr
	return x
}

// QueueFamilyIndexCount returns the value of queueFamilyIndexCount from VkBufferCreateInfo
func (x BufferCreateInfo) QueueFamilyIndexCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.queueFamilyIndexCount)
	return *ptr
}

// WithQueueFamilyIndexCount sets the value for the QueueFamilyIndexCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCreateInfo) WithQueueFamilyIndexCount(y uint32) BufferCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.queueFamilyIndexCount = *ptr
	return x
}

// PQueueFamilyIndices returns the value of pQueueFamilyIndices from VkBufferCreateInfo
func (x BufferCreateInfo) PQueueFamilyIndices() []uint32 {
	ptr := func(x **C.uint) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pQueueFamilyIndices)
	return *ptr
}

// WithPQueueFamilyIndices sets the value for the PQueueFamilyIndices on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines QueueFamilyIndexCount as the length of this field.
// QueueFamilyIndexCount is updated with the length of the new value.
func (x BufferCreateInfo) WithPQueueFamilyIndices(y []uint32) BufferCreateInfo {
	ptr := func(x *[]uint32) **C.uint { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pQueueFamilyIndices = *ptr
	return x.WithQueueFamilyIndexCount(uint32(len(y)))
}

//SparseMemoryBind provides a go interface for VkSparseMemoryBind.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSparseMemoryBind.html
type SparseMemoryBind C.struct_VkSparseMemoryBind

// SizeofSparseMemoryBind is the memory size of a SparseMemoryBind
var SizeofSparseMemoryBind int = int(unsafe.Sizeof(SparseMemoryBind{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SparseMemoryBind) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SparseMemoryBind) AsCPtr() *SparseMemoryBind {
	clone := (*SparseMemoryBind)(newCBlock(C.ulong(SizeofSparseMemoryBind)))
	*clone = x
	return clone
}

// SparseMemoryBindFreeCSlice releases the memory allocated by SparseMemoryBindMakeCSlice.
// It does not free pointers stored inside the slice.
func SparseMemoryBindFreeCSlice(x []SparseMemoryBind) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SparseMemoryBindMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SparseMemoryBindFreeCSlice must be called on the returned slice.
func SparseMemoryBindMakeCSlice(x ...SparseMemoryBind) []SparseMemoryBind {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseMemoryBind * len(x)
	dst := unsafe.Slice((*SparseMemoryBind)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// ResourceOffset returns the value of resourceOffset from VkSparseMemoryBind
func (x SparseMemoryBind) ResourceOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.resourceOffset)
	return *ptr
}

// WithResourceOffset sets the value for the ResourceOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseMemoryBind) WithResourceOffset(y DeviceSize) SparseMemoryBind {
	ptr := /* typedef */ (*C.VkDeviceSize)(&y)
	x.resourceOffset = *ptr
	return x
}

// Size returns the value of size from VkSparseMemoryBind
func (x SparseMemoryBind) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size)
	return *ptr
}

// WithSize sets the value for the Size on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseMemoryBind) WithSize(y DeviceSize) SparseMemoryBind {
	ptr := /* typedef */ (*C.VkDeviceSize)(&y)
	x.size = *ptr
	return x
}

// Memory returns the value of memory from VkSparseMemoryBind
func (x SparseMemoryBind) Memory() DeviceMemory {
	ptr := /* handle */ (*DeviceMemory)(&x.memory)
	return *ptr
}

// WithMemory sets the value for the Memory on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseMemoryBind) WithMemory(y DeviceMemory) SparseMemoryBind {
	ptr := /* handle */ (*C.VkDeviceMemory)(&y)
	x.memory = *ptr
	return x
}

// MemoryOffset returns the value of memoryOffset from VkSparseMemoryBind
func (x SparseMemoryBind) MemoryOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.memoryOffset)
	return *ptr
}

// WithMemoryOffset sets the value for the MemoryOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseMemoryBind) WithMemoryOffset(y DeviceSize) SparseMemoryBind {
	ptr := /* typedef */ (*C.VkDeviceSize)(&y)
	x.memoryOffset = *ptr
	return x
}

// Flags returns the value of flags from VkSparseMemoryBind
func (x SparseMemoryBind) Flags() SparseMemoryBindFlags {
	ptr := /* typedef */ (*SparseMemoryBindFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseMemoryBind) WithFlags(y SparseMemoryBindFlags) SparseMemoryBind {
	ptr := /* typedef */ (*C.VkSparseMemoryBindFlags)(&y)
	x.flags = *ptr
	return x
}

//SparseImageOpaqueMemoryBindInfo provides a go interface for VkSparseImageOpaqueMemoryBindInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSparseImageOpaqueMemoryBindInfo.html
type SparseImageOpaqueMemoryBindInfo C.struct_VkSparseImageOpaqueMemoryBindInfo

// SizeofSparseImageOpaqueMemoryBindInfo is the memory size of a SparseImageOpaqueMemoryBindInfo
var SizeofSparseImageOpaqueMemoryBindInfo int = int(unsafe.Sizeof(SparseImageOpaqueMemoryBindInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SparseImageOpaqueMemoryBindInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SparseImageOpaqueMemoryBindInfo) AsCPtr() *SparseImageOpaqueMemoryBindInfo {
	clone := (*SparseImageOpaqueMemoryBindInfo)(newCBlock(C.ulong(SizeofSparseImageOpaqueMemoryBindInfo)))
	*clone = x
	return clone
}

// SparseImageOpaqueMemoryBindInfoFreeCSlice releases the memory allocated by SparseImageOpaqueMemoryBindInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SparseImageOpaqueMemoryBindInfoFreeCSlice(x []SparseImageOpaqueMemoryBindInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SparseImageOpaqueMemoryBindInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SparseImageOpaqueMemoryBindInfoFreeCSlice must be called on the returned slice.
func SparseImageOpaqueMemoryBindInfoMakeCSlice(x ...SparseImageOpaqueMemoryBindInfo) []SparseImageOpaqueMemoryBindInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageOpaqueMemoryBindInfo * len(x)
	dst := unsafe.Slice((*SparseImageOpaqueMemoryBindInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Image returns the value of image from VkSparseImageOpaqueMemoryBindInfo
func (x SparseImageOpaqueMemoryBindInfo) Image() Image {
	ptr := /* handle */ (*Image)(&x.image)
	return *ptr
}

// WithImage sets the value for the Image on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageOpaqueMemoryBindInfo) WithImage(y Image) SparseImageOpaqueMemoryBindInfo {
	ptr := /* handle */ (*C.VkImage)(&y)
	x.image = *ptr
	return x
}

// BindCount returns the value of bindCount from VkSparseImageOpaqueMemoryBindInfo
func (x SparseImageOpaqueMemoryBindInfo) BindCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.bindCount)
	return *ptr
}

// WithBindCount sets the value for the BindCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageOpaqueMemoryBindInfo) WithBindCount(y uint32) SparseImageOpaqueMemoryBindInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.bindCount = *ptr
	return x
}

// PBinds returns the value of pBinds from VkSparseImageOpaqueMemoryBindInfo
func (x SparseImageOpaqueMemoryBindInfo) PBinds() []SparseMemoryBind {
	ptr := func(x **C.struct_VkSparseMemoryBind) *[]SparseMemoryBind { /* Slice */
		slc := unsafe.Slice((*SparseMemoryBind)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pBinds)
	return *ptr
}

// WithPBinds sets the value for the PBinds on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines BindCount as the length of this field.
// BindCount is updated with the length of the new value.
func (x SparseImageOpaqueMemoryBindInfo) WithPBinds(y []SparseMemoryBind) SparseImageOpaqueMemoryBindInfo {
	ptr := func(x *[]SparseMemoryBind) **C.struct_VkSparseMemoryBind { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSparseMemoryBind)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSparseMemoryBind)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pBinds = *ptr
	return x.WithBindCount(uint32(len(y)))
}

//SparseImageMemoryBindInfo provides a go interface for VkSparseImageMemoryBindInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSparseImageMemoryBindInfo.html
type SparseImageMemoryBindInfo C.struct_VkSparseImageMemoryBindInfo

// SizeofSparseImageMemoryBindInfo is the memory size of a SparseImageMemoryBindInfo
var SizeofSparseImageMemoryBindInfo int = int(unsafe.Sizeof(SparseImageMemoryBindInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SparseImageMemoryBindInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SparseImageMemoryBindInfo) AsCPtr() *SparseImageMemoryBindInfo {
	clone := (*SparseImageMemoryBindInfo)(newCBlock(C.ulong(SizeofSparseImageMemoryBindInfo)))
	*clone = x
	return clone
}

// SparseImageMemoryBindInfoFreeCSlice releases the memory allocated by SparseImageMemoryBindInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SparseImageMemoryBindInfoFreeCSlice(x []SparseImageMemoryBindInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SparseImageMemoryBindInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SparseImageMemoryBindInfoFreeCSlice must be called on the returned slice.
func SparseImageMemoryBindInfoMakeCSlice(x ...SparseImageMemoryBindInfo) []SparseImageMemoryBindInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageMemoryBindInfo * len(x)
	dst := unsafe.Slice((*SparseImageMemoryBindInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Image returns the value of image from VkSparseImageMemoryBindInfo
func (x SparseImageMemoryBindInfo) Image() Image {
	ptr := /* handle */ (*Image)(&x.image)
	return *ptr
}

// WithImage sets the value for the Image on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryBindInfo) WithImage(y Image) SparseImageMemoryBindInfo {
	ptr := /* handle */ (*C.VkImage)(&y)
	x.image = *ptr
	return x
}

// BindCount returns the value of bindCount from VkSparseImageMemoryBindInfo
func (x SparseImageMemoryBindInfo) BindCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.bindCount)
	return *ptr
}

// WithBindCount sets the value for the BindCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryBindInfo) WithBindCount(y uint32) SparseImageMemoryBindInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.bindCount = *ptr
	return x
}

// PBinds returns the value of pBinds from VkSparseImageMemoryBindInfo
func (x SparseImageMemoryBindInfo) PBinds() []SparseImageMemoryBind {
	ptr := func(x **C.struct_VkSparseImageMemoryBind) *[]SparseImageMemoryBind { /* Slice */
		slc := unsafe.Slice((*SparseImageMemoryBind)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pBinds)
	return *ptr
}

// WithPBinds sets the value for the PBinds on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines BindCount as the length of this field.
// BindCount is updated with the length of the new value.
func (x SparseImageMemoryBindInfo) WithPBinds(y []SparseImageMemoryBind) SparseImageMemoryBindInfo {
	ptr := func(x *[]SparseImageMemoryBind) **C.struct_VkSparseImageMemoryBind { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSparseImageMemoryBind)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSparseImageMemoryBind)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pBinds = *ptr
	return x.WithBindCount(uint32(len(y)))
}

//SparseImageMemoryBind provides a go interface for VkSparseImageMemoryBind.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSparseImageMemoryBind.html
type SparseImageMemoryBind C.struct_VkSparseImageMemoryBind

// SizeofSparseImageMemoryBind is the memory size of a SparseImageMemoryBind
var SizeofSparseImageMemoryBind int = int(unsafe.Sizeof(SparseImageMemoryBind{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SparseImageMemoryBind) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SparseImageMemoryBind) AsCPtr() *SparseImageMemoryBind {
	clone := (*SparseImageMemoryBind)(newCBlock(C.ulong(SizeofSparseImageMemoryBind)))
	*clone = x
	return clone
}

// SparseImageMemoryBindFreeCSlice releases the memory allocated by SparseImageMemoryBindMakeCSlice.
// It does not free pointers stored inside the slice.
func SparseImageMemoryBindFreeCSlice(x []SparseImageMemoryBind) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SparseImageMemoryBindMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SparseImageMemoryBindFreeCSlice must be called on the returned slice.
func SparseImageMemoryBindMakeCSlice(x ...SparseImageMemoryBind) []SparseImageMemoryBind {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageMemoryBind * len(x)
	dst := unsafe.Slice((*SparseImageMemoryBind)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Subresource returns the value of subresource from VkSparseImageMemoryBind
func (x SparseImageMemoryBind) Subresource() ImageSubresource {
	ptr := /* typedef */ (*ImageSubresource)(&x.subresource)
	return *ptr
}

// WithSubresource sets the value for the Subresource on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryBind) WithSubresource(y ImageSubresource) SparseImageMemoryBind {
	ptr := /* typedef */ (*C.struct_VkImageSubresource)(&y)
	x.subresource = *ptr
	return x
}

// Offset returns the value of offset from VkSparseImageMemoryBind
func (x SparseImageMemoryBind) Offset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.offset)
	return *ptr
}

// WithOffset sets the value for the Offset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryBind) WithOffset(y Offset3D) SparseImageMemoryBind {
	ptr := /* typedef */ (*C.struct_VkOffset3D)(&y)
	x.offset = *ptr
	return x
}

// Extent returns the value of extent from VkSparseImageMemoryBind
func (x SparseImageMemoryBind) Extent() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.extent)
	return *ptr
}

// WithExtent sets the value for the Extent on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryBind) WithExtent(y Extent3D) SparseImageMemoryBind {
	ptr := /* typedef */ (*C.struct_VkExtent3D)(&y)
	x.extent = *ptr
	return x
}

// Memory returns the value of memory from VkSparseImageMemoryBind
func (x SparseImageMemoryBind) Memory() DeviceMemory {
	ptr := /* handle */ (*DeviceMemory)(&x.memory)
	return *ptr
}

// WithMemory sets the value for the Memory on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryBind) WithMemory(y DeviceMemory) SparseImageMemoryBind {
	ptr := /* handle */ (*C.VkDeviceMemory)(&y)
	x.memory = *ptr
	return x
}

// MemoryOffset returns the value of memoryOffset from VkSparseImageMemoryBind
func (x SparseImageMemoryBind) MemoryOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.memoryOffset)
	return *ptr
}

// WithMemoryOffset sets the value for the MemoryOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryBind) WithMemoryOffset(y DeviceSize) SparseImageMemoryBind {
	ptr := /* typedef */ (*C.VkDeviceSize)(&y)
	x.memoryOffset = *ptr
	return x
}

// Flags returns the value of flags from VkSparseImageMemoryBind
func (x SparseImageMemoryBind) Flags() SparseMemoryBindFlags {
	ptr := /* typedef */ (*SparseMemoryBindFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryBind) WithFlags(y SparseMemoryBindFlags) SparseImageMemoryBind {
	ptr := /* typedef */ (*C.VkSparseMemoryBindFlags)(&y)
	x.flags = *ptr
	return x
}

//SparseImageFormatProperties provides a go interface for VkSparseImageFormatProperties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSparseImageFormatProperties.html
type SparseImageFormatProperties C.struct_VkSparseImageFormatProperties

// SizeofSparseImageFormatProperties is the memory size of a SparseImageFormatProperties
var SizeofSparseImageFormatProperties int = int(unsafe.Sizeof(SparseImageFormatProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SparseImageFormatProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SparseImageFormatProperties) AsCPtr() *SparseImageFormatProperties {
	clone := (*SparseImageFormatProperties)(newCBlock(C.ulong(SizeofSparseImageFormatProperties)))
	*clone = x
	return clone
}

// SparseImageFormatPropertiesFreeCSlice releases the memory allocated by SparseImageFormatPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func SparseImageFormatPropertiesFreeCSlice(x []SparseImageFormatProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SparseImageFormatPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SparseImageFormatPropertiesFreeCSlice must be called on the returned slice.
func SparseImageFormatPropertiesMakeCSlice(x ...SparseImageFormatProperties) []SparseImageFormatProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageFormatProperties * len(x)
	dst := unsafe.Slice((*SparseImageFormatProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// AspectMask returns the value of aspectMask from VkSparseImageFormatProperties
func (x SparseImageFormatProperties) AspectMask() ImageAspectFlags {
	ptr := /* typedef */ (*ImageAspectFlags)(&x.aspectMask)
	return *ptr
}

// ImageGranularity returns the value of imageGranularity from VkSparseImageFormatProperties
func (x SparseImageFormatProperties) ImageGranularity() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.imageGranularity)
	return *ptr
}

// Flags returns the value of flags from VkSparseImageFormatProperties
func (x SparseImageFormatProperties) Flags() SparseImageFormatFlags {
	ptr := /* typedef */ (*SparseImageFormatFlags)(&x.flags)
	return *ptr
}

//SparseBufferMemoryBindInfo provides a go interface for VkSparseBufferMemoryBindInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSparseBufferMemoryBindInfo.html
type SparseBufferMemoryBindInfo C.struct_VkSparseBufferMemoryBindInfo

// SizeofSparseBufferMemoryBindInfo is the memory size of a SparseBufferMemoryBindInfo
var SizeofSparseBufferMemoryBindInfo int = int(unsafe.Sizeof(SparseBufferMemoryBindInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SparseBufferMemoryBindInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SparseBufferMemoryBindInfo) AsCPtr() *SparseBufferMemoryBindInfo {
	clone := (*SparseBufferMemoryBindInfo)(newCBlock(C.ulong(SizeofSparseBufferMemoryBindInfo)))
	*clone = x
	return clone
}

// SparseBufferMemoryBindInfoFreeCSlice releases the memory allocated by SparseBufferMemoryBindInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SparseBufferMemoryBindInfoFreeCSlice(x []SparseBufferMemoryBindInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SparseBufferMemoryBindInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SparseBufferMemoryBindInfoFreeCSlice must be called on the returned slice.
func SparseBufferMemoryBindInfoMakeCSlice(x ...SparseBufferMemoryBindInfo) []SparseBufferMemoryBindInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseBufferMemoryBindInfo * len(x)
	dst := unsafe.Slice((*SparseBufferMemoryBindInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Buffer returns the value of buffer from VkSparseBufferMemoryBindInfo
func (x SparseBufferMemoryBindInfo) Buffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.buffer)
	return *ptr
}

// WithBuffer sets the value for the Buffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseBufferMemoryBindInfo) WithBuffer(y Buffer) SparseBufferMemoryBindInfo {
	ptr := /* handle */ (*C.VkBuffer)(&y)
	x.buffer = *ptr
	return x
}

// BindCount returns the value of bindCount from VkSparseBufferMemoryBindInfo
func (x SparseBufferMemoryBindInfo) BindCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.bindCount)
	return *ptr
}

// WithBindCount sets the value for the BindCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseBufferMemoryBindInfo) WithBindCount(y uint32) SparseBufferMemoryBindInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.bindCount = *ptr
	return x
}

// PBinds returns the value of pBinds from VkSparseBufferMemoryBindInfo
func (x SparseBufferMemoryBindInfo) PBinds() []SparseMemoryBind {
	ptr := func(x **C.struct_VkSparseMemoryBind) *[]SparseMemoryBind { /* Slice */
		slc := unsafe.Slice((*SparseMemoryBind)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pBinds)
	return *ptr
}

// WithPBinds sets the value for the PBinds on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines BindCount as the length of this field.
// BindCount is updated with the length of the new value.
func (x SparseBufferMemoryBindInfo) WithPBinds(y []SparseMemoryBind) SparseBufferMemoryBindInfo {
	ptr := func(x *[]SparseMemoryBind) **C.struct_VkSparseMemoryBind { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSparseMemoryBind)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSparseMemoryBind)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pBinds = *ptr
	return x.WithBindCount(uint32(len(y)))
}

//ImageSubresource provides a go interface for VkImageSubresource.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageSubresource.html
type ImageSubresource C.struct_VkImageSubresource

// SizeofImageSubresource is the memory size of a ImageSubresource
var SizeofImageSubresource int = int(unsafe.Sizeof(ImageSubresource{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageSubresource) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageSubresource) AsCPtr() *ImageSubresource {
	clone := (*ImageSubresource)(newCBlock(C.ulong(SizeofImageSubresource)))
	*clone = x
	return clone
}

// ImageSubresourceFreeCSlice releases the memory allocated by ImageSubresourceMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageSubresourceFreeCSlice(x []ImageSubresource) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageSubresourceMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageSubresourceFreeCSlice must be called on the returned slice.
func ImageSubresourceMakeCSlice(x ...ImageSubresource) []ImageSubresource {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageSubresource * len(x)
	dst := unsafe.Slice((*ImageSubresource)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// AspectMask returns the value of aspectMask from VkImageSubresource
func (x ImageSubresource) AspectMask() ImageAspectFlags {
	ptr := /* typedef */ (*ImageAspectFlags)(&x.aspectMask)
	return *ptr
}

// WithAspectMask sets the value for the AspectMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresource) WithAspectMask(y ImageAspectFlags) ImageSubresource {
	ptr := /* typedef */ (*C.VkImageAspectFlags)(&y)
	x.aspectMask = *ptr
	return x
}

// MipLevel returns the value of mipLevel from VkImageSubresource
func (x ImageSubresource) MipLevel() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.mipLevel)
	return *ptr
}

// WithMipLevel sets the value for the MipLevel on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresource) WithMipLevel(y uint32) ImageSubresource {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.mipLevel = *ptr
	return x
}

// ArrayLayer returns the value of arrayLayer from VkImageSubresource
func (x ImageSubresource) ArrayLayer() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.arrayLayer)
	return *ptr
}

// WithArrayLayer sets the value for the ArrayLayer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresource) WithArrayLayer(y uint32) ImageSubresource {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.arrayLayer = *ptr
	return x
}

//BufferViewCreateInfo provides a go interface for VkBufferViewCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBufferViewCreateInfo.html
type BufferViewCreateInfo C.struct_VkBufferViewCreateInfo

// SizeofBufferViewCreateInfo is the memory size of a BufferViewCreateInfo
var SizeofBufferViewCreateInfo int = int(unsafe.Sizeof(BufferViewCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferViewCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferViewCreateInfo) AsCPtr() *BufferViewCreateInfo {
	clone := (*BufferViewCreateInfo)(newCBlock(C.ulong(SizeofBufferViewCreateInfo)))
	*clone = x
	return clone
}

// BufferViewCreateInfoFreeCSlice releases the memory allocated by BufferViewCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BufferViewCreateInfoFreeCSlice(x []BufferViewCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferViewCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferViewCreateInfoFreeCSlice must be called on the returned slice.
func BufferViewCreateInfoMakeCSlice(x ...BufferViewCreateInfo) []BufferViewCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferViewCreateInfo * len(x)
	dst := unsafe.Slice((*BufferViewCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBufferViewCreateInfo
func (x BufferViewCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BufferViewCreateInfo) WithDefaultSType() BufferViewCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferViewCreateInfo) WithSType(y StructureType) BufferViewCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkBufferViewCreateInfo
func (x BufferViewCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferViewCreateInfo) WithPNext(y unsafe.Pointer) BufferViewCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkBufferViewCreateInfo
func (x BufferViewCreateInfo) Flags() BufferViewCreateFlags {
	ptr := /* typedef */ (*BufferViewCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferViewCreateInfo) WithFlags(y BufferViewCreateFlags) BufferViewCreateInfo {
	ptr := /* typedef */ (*C.VkBufferViewCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// Buffer returns the value of buffer from VkBufferViewCreateInfo
func (x BufferViewCreateInfo) Buffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.buffer)
	return *ptr
}

// WithBuffer sets the value for the Buffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferViewCreateInfo) WithBuffer(y Buffer) BufferViewCreateInfo {
	ptr := /* handle */ (*C.VkBuffer)(&y)
	x.buffer = *ptr
	return x
}

// Format returns the value of format from VkBufferViewCreateInfo
func (x BufferViewCreateInfo) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format)
	return *ptr
}

// WithFormat sets the value for the Format on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferViewCreateInfo) WithFormat(y Format) BufferViewCreateInfo {
	ptr := /* typedef */ (*C.VkFormat)(&y)
	x.format = *ptr
	return x
}

// Offset returns the value of offset from VkBufferViewCreateInfo
func (x BufferViewCreateInfo) Offset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.offset)
	return *ptr
}

// WithOffset sets the value for the Offset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferViewCreateInfo) WithOffset(y DeviceSize) BufferViewCreateInfo {
	ptr := /* typedef */ (*C.VkDeviceSize)(&y)
	x.offset = *ptr
	return x
}

// Range_ returns the value of range from VkBufferViewCreateInfo
func (x BufferViewCreateInfo) Range_() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x._range)
	return *ptr
}

// WithRange_ sets the value for the Range_ on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferViewCreateInfo) WithRange_(y DeviceSize) BufferViewCreateInfo {
	ptr := /* typedef */ (*C.VkDeviceSize)(&y)
	x._range = *ptr
	return x
}

//AttachmentDescription provides a go interface for VkAttachmentDescription.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkAttachmentDescription.html
type AttachmentDescription C.struct_VkAttachmentDescription

// SizeofAttachmentDescription is the memory size of a AttachmentDescription
var SizeofAttachmentDescription int = int(unsafe.Sizeof(AttachmentDescription{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *AttachmentDescription) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x AttachmentDescription) AsCPtr() *AttachmentDescription {
	clone := (*AttachmentDescription)(newCBlock(C.ulong(SizeofAttachmentDescription)))
	*clone = x
	return clone
}

// AttachmentDescriptionFreeCSlice releases the memory allocated by AttachmentDescriptionMakeCSlice.
// It does not free pointers stored inside the slice.
func AttachmentDescriptionFreeCSlice(x []AttachmentDescription) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// AttachmentDescriptionMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. AttachmentDescriptionFreeCSlice must be called on the returned slice.
func AttachmentDescriptionMakeCSlice(x ...AttachmentDescription) []AttachmentDescription {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAttachmentDescription * len(x)
	dst := unsafe.Slice((*AttachmentDescription)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Flags returns the value of flags from VkAttachmentDescription
func (x AttachmentDescription) Flags() AttachmentDescriptionFlags {
	ptr := /* typedef */ (*AttachmentDescriptionFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription) WithFlags(y AttachmentDescriptionFlags) AttachmentDescription {
	ptr := /* typedef */ (*C.VkAttachmentDescriptionFlags)(&y)
	x.flags = *ptr
	return x
}

// Format returns the value of format from VkAttachmentDescription
func (x AttachmentDescription) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format)
	return *ptr
}

// WithFormat sets the value for the Format on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription) WithFormat(y Format) AttachmentDescription {
	ptr := /* typedef */ (*C.VkFormat)(&y)
	x.format = *ptr
	return x
}

// Samples returns the value of samples from VkAttachmentDescription
func (x AttachmentDescription) Samples() SampleCountFlagBits {
	ptr := /* typedef */ (*SampleCountFlagBits)(&x.samples)
	return *ptr
}

// WithSamples sets the value for the Samples on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription) WithSamples(y SampleCountFlagBits) AttachmentDescription {
	ptr := /* typedef */ (*C.VkSampleCountFlagBits)(&y)
	x.samples = *ptr
	return x
}

// LoadOp returns the value of loadOp from VkAttachmentDescription
func (x AttachmentDescription) LoadOp() AttachmentLoadOp {
	ptr := /* typedef */ (*AttachmentLoadOp)(&x.loadOp)
	return *ptr
}

// WithLoadOp sets the value for the LoadOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription) WithLoadOp(y AttachmentLoadOp) AttachmentDescription {
	ptr := /* typedef */ (*C.VkAttachmentLoadOp)(&y)
	x.loadOp = *ptr
	return x
}

// StoreOp returns the value of storeOp from VkAttachmentDescription
func (x AttachmentDescription) StoreOp() AttachmentStoreOp {
	ptr := /* typedef */ (*AttachmentStoreOp)(&x.storeOp)
	return *ptr
}

// WithStoreOp sets the value for the StoreOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription) WithStoreOp(y AttachmentStoreOp) AttachmentDescription {
	ptr := /* typedef */ (*C.VkAttachmentStoreOp)(&y)
	x.storeOp = *ptr
	return x
}

// StencilLoadOp returns the value of stencilLoadOp from VkAttachmentDescription
func (x AttachmentDescription) StencilLoadOp() AttachmentLoadOp {
	ptr := /* typedef */ (*AttachmentLoadOp)(&x.stencilLoadOp)
	return *ptr
}

// WithStencilLoadOp sets the value for the StencilLoadOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription) WithStencilLoadOp(y AttachmentLoadOp) AttachmentDescription {
	ptr := /* typedef */ (*C.VkAttachmentLoadOp)(&y)
	x.stencilLoadOp = *ptr
	return x
}

// StencilStoreOp returns the value of stencilStoreOp from VkAttachmentDescription
func (x AttachmentDescription) StencilStoreOp() AttachmentStoreOp {
	ptr := /* typedef */ (*AttachmentStoreOp)(&x.stencilStoreOp)
	return *ptr
}

// WithStencilStoreOp sets the value for the StencilStoreOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription) WithStencilStoreOp(y AttachmentStoreOp) AttachmentDescription {
	ptr := /* typedef */ (*C.VkAttachmentStoreOp)(&y)
	x.stencilStoreOp = *ptr
	return x
}

// InitialLayout returns the value of initialLayout from VkAttachmentDescription
func (x AttachmentDescription) InitialLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.initialLayout)
	return *ptr
}

// WithInitialLayout sets the value for the InitialLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription) WithInitialLayout(y ImageLayout) AttachmentDescription {
	ptr := /* typedef */ (*C.VkImageLayout)(&y)
	x.initialLayout = *ptr
	return x
}

// FinalLayout returns the value of finalLayout from VkAttachmentDescription
func (x AttachmentDescription) FinalLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.finalLayout)
	return *ptr
}

// WithFinalLayout sets the value for the FinalLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription) WithFinalLayout(y ImageLayout) AttachmentDescription {
	ptr := /* typedef */ (*C.VkImageLayout)(&y)
	x.finalLayout = *ptr
	return x
}

//BindSparseInfo provides a go interface for VkBindSparseInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBindSparseInfo.html
type BindSparseInfo C.struct_VkBindSparseInfo

// SizeofBindSparseInfo is the memory size of a BindSparseInfo
var SizeofBindSparseInfo int = int(unsafe.Sizeof(BindSparseInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BindSparseInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BindSparseInfo) AsCPtr() *BindSparseInfo {
	clone := (*BindSparseInfo)(newCBlock(C.ulong(SizeofBindSparseInfo)))
	*clone = x
	return clone
}

// BindSparseInfoFreeCSlice releases the memory allocated by BindSparseInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BindSparseInfoFreeCSlice(x []BindSparseInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BindSparseInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BindSparseInfoFreeCSlice must be called on the returned slice.
func BindSparseInfoMakeCSlice(x ...BindSparseInfo) []BindSparseInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindSparseInfo * len(x)
	dst := unsafe.Slice((*BindSparseInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBindSparseInfo
func (x BindSparseInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BindSparseInfo) WithDefaultSType() BindSparseInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BIND_SPARSE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindSparseInfo) WithSType(y StructureType) BindSparseInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkBindSparseInfo
func (x BindSparseInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindSparseInfo) WithPNext(y unsafe.Pointer) BindSparseInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// WaitSemaphoreCount returns the value of waitSemaphoreCount from VkBindSparseInfo
func (x BindSparseInfo) WaitSemaphoreCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.waitSemaphoreCount)
	return *ptr
}

// WithWaitSemaphoreCount sets the value for the WaitSemaphoreCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindSparseInfo) WithWaitSemaphoreCount(y uint32) BindSparseInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.waitSemaphoreCount = *ptr
	return x
}

// PWaitSemaphores returns the value of pWaitSemaphores from VkBindSparseInfo
func (x BindSparseInfo) PWaitSemaphores() []Semaphore {
	ptr := func(x **C.VkSemaphore) *[]Semaphore { /* Slice */
		slc := unsafe.Slice((*Semaphore)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pWaitSemaphores)
	return *ptr
}

// WithPWaitSemaphores sets the value for the PWaitSemaphores on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines WaitSemaphoreCount as the length of this field.
// WaitSemaphoreCount is updated with the length of the new value.
func (x BindSparseInfo) WithPWaitSemaphores(y []Semaphore) BindSparseInfo {
	ptr := func(x *[]Semaphore) **C.VkSemaphore { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSemaphore)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSemaphore)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pWaitSemaphores = *ptr
	return x.WithWaitSemaphoreCount(uint32(len(y)))
}

// BufferBindCount returns the value of bufferBindCount from VkBindSparseInfo
func (x BindSparseInfo) BufferBindCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.bufferBindCount)
	return *ptr
}

// WithBufferBindCount sets the value for the BufferBindCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindSparseInfo) WithBufferBindCount(y uint32) BindSparseInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.bufferBindCount = *ptr
	return x
}

// PBufferBinds returns the value of pBufferBinds from VkBindSparseInfo
func (x BindSparseInfo) PBufferBinds() []SparseBufferMemoryBindInfo {
	ptr := func(x **C.struct_VkSparseBufferMemoryBindInfo) *[]SparseBufferMemoryBindInfo { /* Slice */
		slc := unsafe.Slice((*SparseBufferMemoryBindInfo)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pBufferBinds)
	return *ptr
}

// WithPBufferBinds sets the value for the PBufferBinds on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines BufferBindCount as the length of this field.
// BufferBindCount is updated with the length of the new value.
func (x BindSparseInfo) WithPBufferBinds(y []SparseBufferMemoryBindInfo) BindSparseInfo {
	ptr := func(x *[]SparseBufferMemoryBindInfo) **C.struct_VkSparseBufferMemoryBindInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSparseBufferMemoryBindInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSparseBufferMemoryBindInfo)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pBufferBinds = *ptr
	return x.WithBufferBindCount(uint32(len(y)))
}

// ImageOpaqueBindCount returns the value of imageOpaqueBindCount from VkBindSparseInfo
func (x BindSparseInfo) ImageOpaqueBindCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.imageOpaqueBindCount)
	return *ptr
}

// WithImageOpaqueBindCount sets the value for the ImageOpaqueBindCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindSparseInfo) WithImageOpaqueBindCount(y uint32) BindSparseInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.imageOpaqueBindCount = *ptr
	return x
}

// PImageOpaqueBinds returns the value of pImageOpaqueBinds from VkBindSparseInfo
func (x BindSparseInfo) PImageOpaqueBinds() []SparseImageOpaqueMemoryBindInfo {
	ptr := func(x **C.struct_VkSparseImageOpaqueMemoryBindInfo) *[]SparseImageOpaqueMemoryBindInfo { /* Slice */
		slc := unsafe.Slice((*SparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pImageOpaqueBinds)
	return *ptr
}

// WithPImageOpaqueBinds sets the value for the PImageOpaqueBinds on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines ImageOpaqueBindCount as the length of this field.
// ImageOpaqueBindCount is updated with the length of the new value.
func (x BindSparseInfo) WithPImageOpaqueBinds(y []SparseImageOpaqueMemoryBindInfo) BindSparseInfo {
	ptr := func(x *[]SparseImageOpaqueMemoryBindInfo) **C.struct_VkSparseImageOpaqueMemoryBindInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pImageOpaqueBinds = *ptr
	return x.WithImageOpaqueBindCount(uint32(len(y)))
}

// ImageBindCount returns the value of imageBindCount from VkBindSparseInfo
func (x BindSparseInfo) ImageBindCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.imageBindCount)
	return *ptr
}

// WithImageBindCount sets the value for the ImageBindCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindSparseInfo) WithImageBindCount(y uint32) BindSparseInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.imageBindCount = *ptr
	return x
}

// PImageBinds returns the value of pImageBinds from VkBindSparseInfo
func (x BindSparseInfo) PImageBinds() []SparseImageMemoryBindInfo {
	ptr := func(x **C.struct_VkSparseImageMemoryBindInfo) *[]SparseImageMemoryBindInfo { /* Slice */
		slc := unsafe.Slice((*SparseImageMemoryBindInfo)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pImageBinds)
	return *ptr
}

// WithPImageBinds sets the value for the PImageBinds on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines ImageBindCount as the length of this field.
// ImageBindCount is updated with the length of the new value.
func (x BindSparseInfo) WithPImageBinds(y []SparseImageMemoryBindInfo) BindSparseInfo {
	ptr := func(x *[]SparseImageMemoryBindInfo) **C.struct_VkSparseImageMemoryBindInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSparseImageMemoryBindInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSparseImageMemoryBindInfo)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pImageBinds = *ptr
	return x.WithImageBindCount(uint32(len(y)))
}

// SignalSemaphoreCount returns the value of signalSemaphoreCount from VkBindSparseInfo
func (x BindSparseInfo) SignalSemaphoreCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.signalSemaphoreCount)
	return *ptr
}

// WithSignalSemaphoreCount sets the value for the SignalSemaphoreCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindSparseInfo) WithSignalSemaphoreCount(y uint32) BindSparseInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.signalSemaphoreCount = *ptr
	return x
}

// PSignalSemaphores returns the value of pSignalSemaphores from VkBindSparseInfo
func (x BindSparseInfo) PSignalSemaphores() []Semaphore {
	ptr := func(x **C.VkSemaphore) *[]Semaphore { /* Slice */
		slc := unsafe.Slice((*Semaphore)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pSignalSemaphores)
	return *ptr
}

// WithPSignalSemaphores sets the value for the PSignalSemaphores on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SignalSemaphoreCount as the length of this field.
// SignalSemaphoreCount is updated with the length of the new value.
func (x BindSparseInfo) WithPSignalSemaphores(y []Semaphore) BindSparseInfo {
	ptr := func(x *[]Semaphore) **C.VkSemaphore { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSemaphore)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSemaphore)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pSignalSemaphores = *ptr
	return x.WithSignalSemaphoreCount(uint32(len(y)))
}

//MemoryRequirements provides a go interface for VkMemoryRequirements.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkMemoryRequirements.html
type MemoryRequirements C.struct_VkMemoryRequirements

// SizeofMemoryRequirements is the memory size of a MemoryRequirements
var SizeofMemoryRequirements int = int(unsafe.Sizeof(MemoryRequirements{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryRequirements) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryRequirements) AsCPtr() *MemoryRequirements {
	clone := (*MemoryRequirements)(newCBlock(C.ulong(SizeofMemoryRequirements)))
	*clone = x
	return clone
}

// MemoryRequirementsFreeCSlice releases the memory allocated by MemoryRequirementsMakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryRequirementsFreeCSlice(x []MemoryRequirements) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryRequirementsMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryRequirementsFreeCSlice must be called on the returned slice.
func MemoryRequirementsMakeCSlice(x ...MemoryRequirements) []MemoryRequirements {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryRequirements * len(x)
	dst := unsafe.Slice((*MemoryRequirements)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Size returns the value of size from VkMemoryRequirements
func (x MemoryRequirements) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size)
	return *ptr
}

// Alignment returns the value of alignment from VkMemoryRequirements
func (x MemoryRequirements) Alignment() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.alignment)
	return *ptr
}

// MemoryTypeBits returns the value of memoryTypeBits from VkMemoryRequirements
func (x MemoryRequirements) MemoryTypeBits() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.memoryTypeBits)
	return *ptr
}

//CommandPoolCreateInfo provides a go interface for VkCommandPoolCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCommandPoolCreateInfo.html
type CommandPoolCreateInfo C.struct_VkCommandPoolCreateInfo

// SizeofCommandPoolCreateInfo is the memory size of a CommandPoolCreateInfo
var SizeofCommandPoolCreateInfo int = int(unsafe.Sizeof(CommandPoolCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *CommandPoolCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x CommandPoolCreateInfo) AsCPtr() *CommandPoolCreateInfo {
	clone := (*CommandPoolCreateInfo)(newCBlock(C.ulong(SizeofCommandPoolCreateInfo)))
	*clone = x
	return clone
}

// CommandPoolCreateInfoFreeCSlice releases the memory allocated by CommandPoolCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func CommandPoolCreateInfoFreeCSlice(x []CommandPoolCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// CommandPoolCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. CommandPoolCreateInfoFreeCSlice must be called on the returned slice.
func CommandPoolCreateInfoMakeCSlice(x ...CommandPoolCreateInfo) []CommandPoolCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCommandPoolCreateInfo * len(x)
	dst := unsafe.Slice((*CommandPoolCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkCommandPoolCreateInfo
func (x CommandPoolCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x CommandPoolCreateInfo) WithDefaultSType() CommandPoolCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandPoolCreateInfo) WithSType(y StructureType) CommandPoolCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkCommandPoolCreateInfo
func (x CommandPoolCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandPoolCreateInfo) WithPNext(y unsafe.Pointer) CommandPoolCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkCommandPoolCreateInfo
func (x CommandPoolCreateInfo) Flags() CommandPoolCreateFlags {
	ptr := /* typedef */ (*CommandPoolCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandPoolCreateInfo) WithFlags(y CommandPoolCreateFlags) CommandPoolCreateInfo {
	ptr := /* typedef */ (*C.VkCommandPoolCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// QueueFamilyIndex returns the value of queueFamilyIndex from VkCommandPoolCreateInfo
func (x CommandPoolCreateInfo) QueueFamilyIndex() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.queueFamilyIndex)
	return *ptr
}

// WithQueueFamilyIndex sets the value for the QueueFamilyIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandPoolCreateInfo) WithQueueFamilyIndex(y uint32) CommandPoolCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.queueFamilyIndex = *ptr
	return x
}

//ImageCreateInfo provides a go interface for VkImageCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageCreateInfo.html
type ImageCreateInfo C.struct_VkImageCreateInfo

// SizeofImageCreateInfo is the memory size of a ImageCreateInfo
var SizeofImageCreateInfo int = int(unsafe.Sizeof(ImageCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageCreateInfo) AsCPtr() *ImageCreateInfo {
	clone := (*ImageCreateInfo)(newCBlock(C.ulong(SizeofImageCreateInfo)))
	*clone = x
	return clone
}

// ImageCreateInfoFreeCSlice releases the memory allocated by ImageCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageCreateInfoFreeCSlice(x []ImageCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageCreateInfoFreeCSlice must be called on the returned slice.
func ImageCreateInfoMakeCSlice(x ...ImageCreateInfo) []ImageCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageCreateInfo * len(x)
	dst := unsafe.Slice((*ImageCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageCreateInfo
func (x ImageCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ImageCreateInfo) WithDefaultSType() ImageCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithSType(y StructureType) ImageCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkImageCreateInfo
func (x ImageCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithPNext(y unsafe.Pointer) ImageCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkImageCreateInfo
func (x ImageCreateInfo) Flags() ImageCreateFlags {
	ptr := /* typedef */ (*ImageCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithFlags(y ImageCreateFlags) ImageCreateInfo {
	ptr := /* typedef */ (*C.VkImageCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// ImageType returns the value of imageType from VkImageCreateInfo
func (x ImageCreateInfo) ImageType() ImageType {
	ptr := /* typedef */ (*ImageType)(&x.imageType)
	return *ptr
}

// WithImageType sets the value for the ImageType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithImageType(y ImageType) ImageCreateInfo {
	ptr := /* typedef */ (*C.VkImageType)(&y)
	x.imageType = *ptr
	return x
}

// Format returns the value of format from VkImageCreateInfo
func (x ImageCreateInfo) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format)
	return *ptr
}

// WithFormat sets the value for the Format on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithFormat(y Format) ImageCreateInfo {
	ptr := /* typedef */ (*C.VkFormat)(&y)
	x.format = *ptr
	return x
}

// Extent returns the value of extent from VkImageCreateInfo
func (x ImageCreateInfo) Extent() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.extent)
	return *ptr
}

// WithExtent sets the value for the Extent on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithExtent(y Extent3D) ImageCreateInfo {
	ptr := /* typedef */ (*C.struct_VkExtent3D)(&y)
	x.extent = *ptr
	return x
}

// MipLevels returns the value of mipLevels from VkImageCreateInfo
func (x ImageCreateInfo) MipLevels() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.mipLevels)
	return *ptr
}

// WithMipLevels sets the value for the MipLevels on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithMipLevels(y uint32) ImageCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.mipLevels = *ptr
	return x
}

// ArrayLayers returns the value of arrayLayers from VkImageCreateInfo
func (x ImageCreateInfo) ArrayLayers() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.arrayLayers)
	return *ptr
}

// WithArrayLayers sets the value for the ArrayLayers on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithArrayLayers(y uint32) ImageCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.arrayLayers = *ptr
	return x
}

// Samples returns the value of samples from VkImageCreateInfo
func (x ImageCreateInfo) Samples() SampleCountFlagBits {
	ptr := /* typedef */ (*SampleCountFlagBits)(&x.samples)
	return *ptr
}

// WithSamples sets the value for the Samples on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithSamples(y SampleCountFlagBits) ImageCreateInfo {
	ptr := /* typedef */ (*C.VkSampleCountFlagBits)(&y)
	x.samples = *ptr
	return x
}

// Tiling returns the value of tiling from VkImageCreateInfo
func (x ImageCreateInfo) Tiling() ImageTiling {
	ptr := /* typedef */ (*ImageTiling)(&x.tiling)
	return *ptr
}

// WithTiling sets the value for the Tiling on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithTiling(y ImageTiling) ImageCreateInfo {
	ptr := /* typedef */ (*C.VkImageTiling)(&y)
	x.tiling = *ptr
	return x
}

// Usage returns the value of usage from VkImageCreateInfo
func (x ImageCreateInfo) Usage() ImageUsageFlags {
	ptr := /* typedef */ (*ImageUsageFlags)(&x.usage)
	return *ptr
}

// WithUsage sets the value for the Usage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithUsage(y ImageUsageFlags) ImageCreateInfo {
	ptr := /* typedef */ (*C.VkImageUsageFlags)(&y)
	x.usage = *ptr
	return x
}

// SharingMode returns the value of sharingMode from VkImageCreateInfo
func (x ImageCreateInfo) SharingMode() SharingMode {
	ptr := /* typedef */ (*SharingMode)(&x.sharingMode)
	return *ptr
}

// WithSharingMode sets the value for the SharingMode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithSharingMode(y SharingMode) ImageCreateInfo {
	ptr := /* typedef */ (*C.VkSharingMode)(&y)
	x.sharingMode = *ptr
	return x
}

// QueueFamilyIndexCount returns the value of queueFamilyIndexCount from VkImageCreateInfo
func (x ImageCreateInfo) QueueFamilyIndexCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.queueFamilyIndexCount)
	return *ptr
}

// WithQueueFamilyIndexCount sets the value for the QueueFamilyIndexCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithQueueFamilyIndexCount(y uint32) ImageCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.queueFamilyIndexCount = *ptr
	return x
}

// PQueueFamilyIndices returns the value of pQueueFamilyIndices from VkImageCreateInfo
func (x ImageCreateInfo) PQueueFamilyIndices() []uint32 {
	ptr := func(x **C.uint) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pQueueFamilyIndices)
	return *ptr
}

// WithPQueueFamilyIndices sets the value for the PQueueFamilyIndices on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines QueueFamilyIndexCount as the length of this field.
// QueueFamilyIndexCount is updated with the length of the new value.
func (x ImageCreateInfo) WithPQueueFamilyIndices(y []uint32) ImageCreateInfo {
	ptr := func(x *[]uint32) **C.uint { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pQueueFamilyIndices = *ptr
	return x.WithQueueFamilyIndexCount(uint32(len(y)))
}

// InitialLayout returns the value of initialLayout from VkImageCreateInfo
func (x ImageCreateInfo) InitialLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.initialLayout)
	return *ptr
}

// WithInitialLayout sets the value for the InitialLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithInitialLayout(y ImageLayout) ImageCreateInfo {
	ptr := /* typedef */ (*C.VkImageLayout)(&y)
	x.initialLayout = *ptr
	return x
}

//MemoryAllocateInfo provides a go interface for VkMemoryAllocateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkMemoryAllocateInfo.html
type MemoryAllocateInfo C.struct_VkMemoryAllocateInfo

// SizeofMemoryAllocateInfo is the memory size of a MemoryAllocateInfo
var SizeofMemoryAllocateInfo int = int(unsafe.Sizeof(MemoryAllocateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryAllocateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryAllocateInfo) AsCPtr() *MemoryAllocateInfo {
	clone := (*MemoryAllocateInfo)(newCBlock(C.ulong(SizeofMemoryAllocateInfo)))
	*clone = x
	return clone
}

// MemoryAllocateInfoFreeCSlice releases the memory allocated by MemoryAllocateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryAllocateInfoFreeCSlice(x []MemoryAllocateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryAllocateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryAllocateInfoFreeCSlice must be called on the returned slice.
func MemoryAllocateInfoMakeCSlice(x ...MemoryAllocateInfo) []MemoryAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryAllocateInfo * len(x)
	dst := unsafe.Slice((*MemoryAllocateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkMemoryAllocateInfo
func (x MemoryAllocateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x MemoryAllocateInfo) WithDefaultSType() MemoryAllocateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryAllocateInfo) WithSType(y StructureType) MemoryAllocateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkMemoryAllocateInfo
func (x MemoryAllocateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryAllocateInfo) WithPNext(y unsafe.Pointer) MemoryAllocateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// AllocationSize returns the value of allocationSize from VkMemoryAllocateInfo
func (x MemoryAllocateInfo) AllocationSize() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.allocationSize)
	return *ptr
}

// WithAllocationSize sets the value for the AllocationSize on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryAllocateInfo) WithAllocationSize(y DeviceSize) MemoryAllocateInfo {
	ptr := /* typedef */ (*C.VkDeviceSize)(&y)
	x.allocationSize = *ptr
	return x
}

// MemoryTypeIndex returns the value of memoryTypeIndex from VkMemoryAllocateInfo
func (x MemoryAllocateInfo) MemoryTypeIndex() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.memoryTypeIndex)
	return *ptr
}

// WithMemoryTypeIndex sets the value for the MemoryTypeIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryAllocateInfo) WithMemoryTypeIndex(y uint32) MemoryAllocateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.memoryTypeIndex = *ptr
	return x
}

//SubresourceLayout provides a go interface for VkSubresourceLayout.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSubresourceLayout.html
type SubresourceLayout C.struct_VkSubresourceLayout

// SizeofSubresourceLayout is the memory size of a SubresourceLayout
var SizeofSubresourceLayout int = int(unsafe.Sizeof(SubresourceLayout{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubresourceLayout) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubresourceLayout) AsCPtr() *SubresourceLayout {
	clone := (*SubresourceLayout)(newCBlock(C.ulong(SizeofSubresourceLayout)))
	*clone = x
	return clone
}

// SubresourceLayoutFreeCSlice releases the memory allocated by SubresourceLayoutMakeCSlice.
// It does not free pointers stored inside the slice.
func SubresourceLayoutFreeCSlice(x []SubresourceLayout) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubresourceLayoutMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubresourceLayoutFreeCSlice must be called on the returned slice.
func SubresourceLayoutMakeCSlice(x ...SubresourceLayout) []SubresourceLayout {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubresourceLayout * len(x)
	dst := unsafe.Slice((*SubresourceLayout)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Offset returns the value of offset from VkSubresourceLayout
func (x SubresourceLayout) Offset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.offset)
	return *ptr
}

// Size returns the value of size from VkSubresourceLayout
func (x SubresourceLayout) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size)
	return *ptr
}

// RowPitch returns the value of rowPitch from VkSubresourceLayout
func (x SubresourceLayout) RowPitch() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.rowPitch)
	return *ptr
}

// ArrayPitch returns the value of arrayPitch from VkSubresourceLayout
func (x SubresourceLayout) ArrayPitch() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.arrayPitch)
	return *ptr
}

// DepthPitch returns the value of depthPitch from VkSubresourceLayout
func (x SubresourceLayout) DepthPitch() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.depthPitch)
	return *ptr
}

//WriteDescriptorSet provides a go interface for VkWriteDescriptorSet.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkWriteDescriptorSet.html
type WriteDescriptorSet C.struct_VkWriteDescriptorSet

// SizeofWriteDescriptorSet is the memory size of a WriteDescriptorSet
var SizeofWriteDescriptorSet int = int(unsafe.Sizeof(WriteDescriptorSet{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *WriteDescriptorSet) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x WriteDescriptorSet) AsCPtr() *WriteDescriptorSet {
	clone := (*WriteDescriptorSet)(newCBlock(C.ulong(SizeofWriteDescriptorSet)))
	*clone = x
	return clone
}

// WriteDescriptorSetFreeCSlice releases the memory allocated by WriteDescriptorSetMakeCSlice.
// It does not free pointers stored inside the slice.
func WriteDescriptorSetFreeCSlice(x []WriteDescriptorSet) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// WriteDescriptorSetMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. WriteDescriptorSetFreeCSlice must be called on the returned slice.
func WriteDescriptorSetMakeCSlice(x ...WriteDescriptorSet) []WriteDescriptorSet {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofWriteDescriptorSet * len(x)
	dst := unsafe.Slice((*WriteDescriptorSet)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkWriteDescriptorSet
func (x WriteDescriptorSet) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x WriteDescriptorSet) WithDefaultSType() WriteDescriptorSet {
	return x.WithSType(VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSet) WithSType(y StructureType) WriteDescriptorSet {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkWriteDescriptorSet
func (x WriteDescriptorSet) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSet) WithPNext(y unsafe.Pointer) WriteDescriptorSet {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// DstSet returns the value of dstSet from VkWriteDescriptorSet
func (x WriteDescriptorSet) DstSet() DescriptorSet {
	ptr := /* handle */ (*DescriptorSet)(&x.dstSet)
	return *ptr
}

// WithDstSet sets the value for the DstSet on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSet) WithDstSet(y DescriptorSet) WriteDescriptorSet {
	ptr := /* handle */ (*C.VkDescriptorSet)(&y)
	x.dstSet = *ptr
	return x
}

// DstBinding returns the value of dstBinding from VkWriteDescriptorSet
func (x WriteDescriptorSet) DstBinding() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.dstBinding)
	return *ptr
}

// WithDstBinding sets the value for the DstBinding on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSet) WithDstBinding(y uint32) WriteDescriptorSet {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.dstBinding = *ptr
	return x
}

// DstArrayElement returns the value of dstArrayElement from VkWriteDescriptorSet
func (x WriteDescriptorSet) DstArrayElement() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.dstArrayElement)
	return *ptr
}

// WithDstArrayElement sets the value for the DstArrayElement on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSet) WithDstArrayElement(y uint32) WriteDescriptorSet {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.dstArrayElement = *ptr
	return x
}

// DescriptorCount returns the value of descriptorCount from VkWriteDescriptorSet
func (x WriteDescriptorSet) DescriptorCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.descriptorCount)
	return *ptr
}

// WithDescriptorCount sets the value for the DescriptorCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSet) WithDescriptorCount(y uint32) WriteDescriptorSet {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.descriptorCount = *ptr
	return x
}

// DescriptorType returns the value of descriptorType from VkWriteDescriptorSet
func (x WriteDescriptorSet) DescriptorType() DescriptorType {
	ptr := /* typedef */ (*DescriptorType)(&x.descriptorType)
	return *ptr
}

// WithDescriptorType sets the value for the DescriptorType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSet) WithDescriptorType(y DescriptorType) WriteDescriptorSet {
	ptr := /* typedef */ (*C.VkDescriptorType)(&y)
	x.descriptorType = *ptr
	return x
}

// PImageInfo returns the value of pImageInfo from VkWriteDescriptorSet
func (x WriteDescriptorSet) PImageInfo() []DescriptorImageInfo {
	ptr := func(x **C.struct_VkDescriptorImageInfo) *[]DescriptorImageInfo { /* Slice */
		slc := unsafe.Slice((*DescriptorImageInfo)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pImageInfo)
	return *ptr
}

// WithPImageInfo sets the value for the PImageInfo on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DescriptorCount as the length of this field.
// DescriptorCount is updated with the length of the new value.
func (x WriteDescriptorSet) WithPImageInfo(y []DescriptorImageInfo) WriteDescriptorSet {
	ptr := func(x *[]DescriptorImageInfo) **C.struct_VkDescriptorImageInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDescriptorImageInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDescriptorImageInfo)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pImageInfo = *ptr
	return x.WithDescriptorCount(uint32(len(y)))
}

// PBufferInfo returns the value of pBufferInfo from VkWriteDescriptorSet
func (x WriteDescriptorSet) PBufferInfo() []DescriptorBufferInfo {
	ptr := func(x **C.struct_VkDescriptorBufferInfo) *[]DescriptorBufferInfo { /* Slice */
		slc := unsafe.Slice((*DescriptorBufferInfo)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pBufferInfo)
	return *ptr
}

// WithPBufferInfo sets the value for the PBufferInfo on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DescriptorCount as the length of this field.
// DescriptorCount is updated with the length of the new value.
func (x WriteDescriptorSet) WithPBufferInfo(y []DescriptorBufferInfo) WriteDescriptorSet {
	ptr := func(x *[]DescriptorBufferInfo) **C.struct_VkDescriptorBufferInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDescriptorBufferInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDescriptorBufferInfo)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pBufferInfo = *ptr
	return x.WithDescriptorCount(uint32(len(y)))
}

// PTexelBufferView returns the value of pTexelBufferView from VkWriteDescriptorSet
func (x WriteDescriptorSet) PTexelBufferView() []BufferView {
	ptr := func(x **C.VkBufferView) *[]BufferView { /* Slice */
		slc := unsafe.Slice((*BufferView)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pTexelBufferView)
	return *ptr
}

// WithPTexelBufferView sets the value for the PTexelBufferView on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DescriptorCount as the length of this field.
// DescriptorCount is updated with the length of the new value.
func (x WriteDescriptorSet) WithPTexelBufferView(y []BufferView) WriteDescriptorSet {
	ptr := func(x *[]BufferView) **C.VkBufferView { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkBufferView)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkBufferView)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pTexelBufferView = *ptr
	return x.WithDescriptorCount(uint32(len(y)))
}

//MappedMemoryRange provides a go interface for VkMappedMemoryRange.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkMappedMemoryRange.html
type MappedMemoryRange C.struct_VkMappedMemoryRange

// SizeofMappedMemoryRange is the memory size of a MappedMemoryRange
var SizeofMappedMemoryRange int = int(unsafe.Sizeof(MappedMemoryRange{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MappedMemoryRange) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MappedMemoryRange) AsCPtr() *MappedMemoryRange {
	clone := (*MappedMemoryRange)(newCBlock(C.ulong(SizeofMappedMemoryRange)))
	*clone = x
	return clone
}

// MappedMemoryRangeFreeCSlice releases the memory allocated by MappedMemoryRangeMakeCSlice.
// It does not free pointers stored inside the slice.
func MappedMemoryRangeFreeCSlice(x []MappedMemoryRange) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MappedMemoryRangeMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MappedMemoryRangeFreeCSlice must be called on the returned slice.
func MappedMemoryRangeMakeCSlice(x ...MappedMemoryRange) []MappedMemoryRange {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMappedMemoryRange * len(x)
	dst := unsafe.Slice((*MappedMemoryRange)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkMappedMemoryRange
func (x MappedMemoryRange) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x MappedMemoryRange) WithDefaultSType() MappedMemoryRange {
	return x.WithSType(VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MappedMemoryRange) WithSType(y StructureType) MappedMemoryRange {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkMappedMemoryRange
func (x MappedMemoryRange) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MappedMemoryRange) WithPNext(y unsafe.Pointer) MappedMemoryRange {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Memory returns the value of memory from VkMappedMemoryRange
func (x MappedMemoryRange) Memory() DeviceMemory {
	ptr := /* handle */ (*DeviceMemory)(&x.memory)
	return *ptr
}

// WithMemory sets the value for the Memory on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MappedMemoryRange) WithMemory(y DeviceMemory) MappedMemoryRange {
	ptr := /* handle */ (*C.VkDeviceMemory)(&y)
	x.memory = *ptr
	return x
}

// Offset returns the value of offset from VkMappedMemoryRange
func (x MappedMemoryRange) Offset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.offset)
	return *ptr
}

// WithOffset sets the value for the Offset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MappedMemoryRange) WithOffset(y DeviceSize) MappedMemoryRange {
	ptr := /* typedef */ (*C.VkDeviceSize)(&y)
	x.offset = *ptr
	return x
}

// Size returns the value of size from VkMappedMemoryRange
func (x MappedMemoryRange) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size)
	return *ptr
}

// WithSize sets the value for the Size on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MappedMemoryRange) WithSize(y DeviceSize) MappedMemoryRange {
	ptr := /* typedef */ (*C.VkDeviceSize)(&y)
	x.size = *ptr
	return x
}

//ComponentMapping provides a go interface for VkComponentMapping.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkComponentMapping.html
type ComponentMapping C.struct_VkComponentMapping

// SizeofComponentMapping is the memory size of a ComponentMapping
var SizeofComponentMapping int = int(unsafe.Sizeof(ComponentMapping{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ComponentMapping) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ComponentMapping) AsCPtr() *ComponentMapping {
	clone := (*ComponentMapping)(newCBlock(C.ulong(SizeofComponentMapping)))
	*clone = x
	return clone
}

// ComponentMappingFreeCSlice releases the memory allocated by ComponentMappingMakeCSlice.
// It does not free pointers stored inside the slice.
func ComponentMappingFreeCSlice(x []ComponentMapping) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ComponentMappingMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ComponentMappingFreeCSlice must be called on the returned slice.
func ComponentMappingMakeCSlice(x ...ComponentMapping) []ComponentMapping {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofComponentMapping * len(x)
	dst := unsafe.Slice((*ComponentMapping)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// R returns the value of r from VkComponentMapping
func (x ComponentMapping) R() ComponentSwizzle {
	ptr := /* typedef */ (*ComponentSwizzle)(&x.r)
	return *ptr
}

// WithR sets the value for the R on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComponentMapping) WithR(y ComponentSwizzle) ComponentMapping {
	ptr := /* typedef */ (*C.VkComponentSwizzle)(&y)
	x.r = *ptr
	return x
}

// G returns the value of g from VkComponentMapping
func (x ComponentMapping) G() ComponentSwizzle {
	ptr := /* typedef */ (*ComponentSwizzle)(&x.g)
	return *ptr
}

// WithG sets the value for the G on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComponentMapping) WithG(y ComponentSwizzle) ComponentMapping {
	ptr := /* typedef */ (*C.VkComponentSwizzle)(&y)
	x.g = *ptr
	return x
}

// B returns the value of b from VkComponentMapping
func (x ComponentMapping) B() ComponentSwizzle {
	ptr := /* typedef */ (*ComponentSwizzle)(&x.b)
	return *ptr
}

// WithB sets the value for the B on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComponentMapping) WithB(y ComponentSwizzle) ComponentMapping {
	ptr := /* typedef */ (*C.VkComponentSwizzle)(&y)
	x.b = *ptr
	return x
}

// A returns the value of a from VkComponentMapping
func (x ComponentMapping) A() ComponentSwizzle {
	ptr := /* typedef */ (*ComponentSwizzle)(&x.a)
	return *ptr
}

// WithA sets the value for the A on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComponentMapping) WithA(y ComponentSwizzle) ComponentMapping {
	ptr := /* typedef */ (*C.VkComponentSwizzle)(&y)
	x.a = *ptr
	return x
}

//CommandBufferAllocateInfo provides a go interface for VkCommandBufferAllocateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCommandBufferAllocateInfo.html
type CommandBufferAllocateInfo C.struct_VkCommandBufferAllocateInfo

// SizeofCommandBufferAllocateInfo is the memory size of a CommandBufferAllocateInfo
var SizeofCommandBufferAllocateInfo int = int(unsafe.Sizeof(CommandBufferAllocateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *CommandBufferAllocateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x CommandBufferAllocateInfo) AsCPtr() *CommandBufferAllocateInfo {
	clone := (*CommandBufferAllocateInfo)(newCBlock(C.ulong(SizeofCommandBufferAllocateInfo)))
	*clone = x
	return clone
}

// CommandBufferAllocateInfoFreeCSlice releases the memory allocated by CommandBufferAllocateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func CommandBufferAllocateInfoFreeCSlice(x []CommandBufferAllocateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// CommandBufferAllocateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. CommandBufferAllocateInfoFreeCSlice must be called on the returned slice.
func CommandBufferAllocateInfoMakeCSlice(x ...CommandBufferAllocateInfo) []CommandBufferAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCommandBufferAllocateInfo * len(x)
	dst := unsafe.Slice((*CommandBufferAllocateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkCommandBufferAllocateInfo
func (x CommandBufferAllocateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x CommandBufferAllocateInfo) WithDefaultSType() CommandBufferAllocateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferAllocateInfo) WithSType(y StructureType) CommandBufferAllocateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkCommandBufferAllocateInfo
func (x CommandBufferAllocateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferAllocateInfo) WithPNext(y unsafe.Pointer) CommandBufferAllocateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// CommandPool returns the value of commandPool from VkCommandBufferAllocateInfo
func (x CommandBufferAllocateInfo) CommandPool() CommandPool {
	ptr := /* handle */ (*CommandPool)(&x.commandPool)
	return *ptr
}

// WithCommandPool sets the value for the CommandPool on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferAllocateInfo) WithCommandPool(y CommandPool) CommandBufferAllocateInfo {
	ptr := /* handle */ (*C.VkCommandPool)(&y)
	x.commandPool = *ptr
	return x
}

// Level returns the value of level from VkCommandBufferAllocateInfo
func (x CommandBufferAllocateInfo) Level() CommandBufferLevel {
	ptr := /* typedef */ (*CommandBufferLevel)(&x.level)
	return *ptr
}

// WithLevel sets the value for the Level on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferAllocateInfo) WithLevel(y CommandBufferLevel) CommandBufferAllocateInfo {
	ptr := /* typedef */ (*C.VkCommandBufferLevel)(&y)
	x.level = *ptr
	return x
}

// CommandBufferCount returns the value of commandBufferCount from VkCommandBufferAllocateInfo
func (x CommandBufferAllocateInfo) CommandBufferCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.commandBufferCount)
	return *ptr
}

// WithCommandBufferCount sets the value for the CommandBufferCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferAllocateInfo) WithCommandBufferCount(y uint32) CommandBufferAllocateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.commandBufferCount = *ptr
	return x
}

//ImageSubresourceRange provides a go interface for VkImageSubresourceRange.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageSubresourceRange.html
type ImageSubresourceRange C.struct_VkImageSubresourceRange

// SizeofImageSubresourceRange is the memory size of a ImageSubresourceRange
var SizeofImageSubresourceRange int = int(unsafe.Sizeof(ImageSubresourceRange{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageSubresourceRange) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageSubresourceRange) AsCPtr() *ImageSubresourceRange {
	clone := (*ImageSubresourceRange)(newCBlock(C.ulong(SizeofImageSubresourceRange)))
	*clone = x
	return clone
}

// ImageSubresourceRangeFreeCSlice releases the memory allocated by ImageSubresourceRangeMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageSubresourceRangeFreeCSlice(x []ImageSubresourceRange) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageSubresourceRangeMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageSubresourceRangeFreeCSlice must be called on the returned slice.
func ImageSubresourceRangeMakeCSlice(x ...ImageSubresourceRange) []ImageSubresourceRange {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageSubresourceRange * len(x)
	dst := unsafe.Slice((*ImageSubresourceRange)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// AspectMask returns the value of aspectMask from VkImageSubresourceRange
func (x ImageSubresourceRange) AspectMask() ImageAspectFlags {
	ptr := /* typedef */ (*ImageAspectFlags)(&x.aspectMask)
	return *ptr
}

// WithAspectMask sets the value for the AspectMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresourceRange) WithAspectMask(y ImageAspectFlags) ImageSubresourceRange {
	ptr := /* typedef */ (*C.VkImageAspectFlags)(&y)
	x.aspectMask = *ptr
	return x
}

// BaseMipLevel returns the value of baseMipLevel from VkImageSubresourceRange
func (x ImageSubresourceRange) BaseMipLevel() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.baseMipLevel)
	return *ptr
}

// WithBaseMipLevel sets the value for the BaseMipLevel on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresourceRange) WithBaseMipLevel(y uint32) ImageSubresourceRange {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.baseMipLevel = *ptr
	return x
}

// LevelCount returns the value of levelCount from VkImageSubresourceRange
func (x ImageSubresourceRange) LevelCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.levelCount)
	return *ptr
}

// WithLevelCount sets the value for the LevelCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresourceRange) WithLevelCount(y uint32) ImageSubresourceRange {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.levelCount = *ptr
	return x
}

// BaseArrayLayer returns the value of baseArrayLayer from VkImageSubresourceRange
func (x ImageSubresourceRange) BaseArrayLayer() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.baseArrayLayer)
	return *ptr
}

// WithBaseArrayLayer sets the value for the BaseArrayLayer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresourceRange) WithBaseArrayLayer(y uint32) ImageSubresourceRange {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.baseArrayLayer = *ptr
	return x
}

// LayerCount returns the value of layerCount from VkImageSubresourceRange
func (x ImageSubresourceRange) LayerCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.layerCount)
	return *ptr
}

// WithLayerCount sets the value for the LayerCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresourceRange) WithLayerCount(y uint32) ImageSubresourceRange {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.layerCount = *ptr
	return x
}

//CommandBufferBeginInfo provides a go interface for VkCommandBufferBeginInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCommandBufferBeginInfo.html
type CommandBufferBeginInfo C.struct_VkCommandBufferBeginInfo

// SizeofCommandBufferBeginInfo is the memory size of a CommandBufferBeginInfo
var SizeofCommandBufferBeginInfo int = int(unsafe.Sizeof(CommandBufferBeginInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *CommandBufferBeginInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x CommandBufferBeginInfo) AsCPtr() *CommandBufferBeginInfo {
	clone := (*CommandBufferBeginInfo)(newCBlock(C.ulong(SizeofCommandBufferBeginInfo)))
	*clone = x
	return clone
}

// CommandBufferBeginInfoFreeCSlice releases the memory allocated by CommandBufferBeginInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func CommandBufferBeginInfoFreeCSlice(x []CommandBufferBeginInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// CommandBufferBeginInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. CommandBufferBeginInfoFreeCSlice must be called on the returned slice.
func CommandBufferBeginInfoMakeCSlice(x ...CommandBufferBeginInfo) []CommandBufferBeginInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCommandBufferBeginInfo * len(x)
	dst := unsafe.Slice((*CommandBufferBeginInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkCommandBufferBeginInfo
func (x CommandBufferBeginInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x CommandBufferBeginInfo) WithDefaultSType() CommandBufferBeginInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferBeginInfo) WithSType(y StructureType) CommandBufferBeginInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkCommandBufferBeginInfo
func (x CommandBufferBeginInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferBeginInfo) WithPNext(y unsafe.Pointer) CommandBufferBeginInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkCommandBufferBeginInfo
func (x CommandBufferBeginInfo) Flags() CommandBufferUsageFlags {
	ptr := /* typedef */ (*CommandBufferUsageFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferBeginInfo) WithFlags(y CommandBufferUsageFlags) CommandBufferBeginInfo {
	ptr := /* typedef */ (*C.VkCommandBufferUsageFlags)(&y)
	x.flags = *ptr
	return x
}

// PInheritanceInfo returns the value of pInheritanceInfo from VkCommandBufferBeginInfo
func (x CommandBufferBeginInfo) PInheritanceInfo() *CommandBufferInheritanceInfo {
	ptr := func(x **C.struct_VkCommandBufferInheritanceInfo) **CommandBufferInheritanceInfo { /* Pointer */
		return (**CommandBufferInheritanceInfo)(unsafe.Pointer(x))
	}(&x.pInheritanceInfo)
	return *ptr
}

// WithPInheritanceInfo sets the value for the PInheritanceInfo on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferBeginInfo) WithPInheritanceInfo(y *CommandBufferInheritanceInfo) CommandBufferBeginInfo {
	ptr := func(x **CommandBufferInheritanceInfo) **C.struct_VkCommandBufferInheritanceInfo { /* Pointer */
		return (**C.struct_VkCommandBufferInheritanceInfo)(unsafe.Pointer(x))
	}(&y)
	x.pInheritanceInfo = *ptr
	return x
}

//CommandBufferInheritanceInfo provides a go interface for VkCommandBufferInheritanceInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCommandBufferInheritanceInfo.html
type CommandBufferInheritanceInfo C.struct_VkCommandBufferInheritanceInfo

// SizeofCommandBufferInheritanceInfo is the memory size of a CommandBufferInheritanceInfo
var SizeofCommandBufferInheritanceInfo int = int(unsafe.Sizeof(CommandBufferInheritanceInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *CommandBufferInheritanceInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x CommandBufferInheritanceInfo) AsCPtr() *CommandBufferInheritanceInfo {
	clone := (*CommandBufferInheritanceInfo)(newCBlock(C.ulong(SizeofCommandBufferInheritanceInfo)))
	*clone = x
	return clone
}

// CommandBufferInheritanceInfoFreeCSlice releases the memory allocated by CommandBufferInheritanceInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func CommandBufferInheritanceInfoFreeCSlice(x []CommandBufferInheritanceInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// CommandBufferInheritanceInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. CommandBufferInheritanceInfoFreeCSlice must be called on the returned slice.
func CommandBufferInheritanceInfoMakeCSlice(x ...CommandBufferInheritanceInfo) []CommandBufferInheritanceInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCommandBufferInheritanceInfo * len(x)
	dst := unsafe.Slice((*CommandBufferInheritanceInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkCommandBufferInheritanceInfo
func (x CommandBufferInheritanceInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x CommandBufferInheritanceInfo) WithDefaultSType() CommandBufferInheritanceInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceInfo) WithSType(y StructureType) CommandBufferInheritanceInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkCommandBufferInheritanceInfo
func (x CommandBufferInheritanceInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceInfo) WithPNext(y unsafe.Pointer) CommandBufferInheritanceInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// RenderPass returns the value of renderPass from VkCommandBufferInheritanceInfo
func (x CommandBufferInheritanceInfo) RenderPass() RenderPass {
	ptr := /* handle */ (*RenderPass)(&x.renderPass)
	return *ptr
}

// WithRenderPass sets the value for the RenderPass on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceInfo) WithRenderPass(y RenderPass) CommandBufferInheritanceInfo {
	ptr := /* handle */ (*C.VkRenderPass)(&y)
	x.renderPass = *ptr
	return x
}

// Subpass returns the value of subpass from VkCommandBufferInheritanceInfo
func (x CommandBufferInheritanceInfo) Subpass() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.subpass)
	return *ptr
}

// WithSubpass sets the value for the Subpass on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceInfo) WithSubpass(y uint32) CommandBufferInheritanceInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.subpass = *ptr
	return x
}

// Framebuffer returns the value of framebuffer from VkCommandBufferInheritanceInfo
func (x CommandBufferInheritanceInfo) Framebuffer() Framebuffer {
	ptr := /* handle */ (*Framebuffer)(&x.framebuffer)
	return *ptr
}

// WithFramebuffer sets the value for the Framebuffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceInfo) WithFramebuffer(y Framebuffer) CommandBufferInheritanceInfo {
	ptr := /* handle */ (*C.VkFramebuffer)(&y)
	x.framebuffer = *ptr
	return x
}

// OcclusionQueryEnable returns the value of occlusionQueryEnable from VkCommandBufferInheritanceInfo
func (x CommandBufferInheritanceInfo) OcclusionQueryEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.occlusionQueryEnable)
	return *ptr
}

// WithOcclusionQueryEnable sets the value for the OcclusionQueryEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceInfo) WithOcclusionQueryEnable(y Bool32) CommandBufferInheritanceInfo {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.occlusionQueryEnable = *ptr
	return x
}

// QueryFlags returns the value of queryFlags from VkCommandBufferInheritanceInfo
func (x CommandBufferInheritanceInfo) QueryFlags() QueryControlFlags {
	ptr := /* typedef */ (*QueryControlFlags)(&x.queryFlags)
	return *ptr
}

// WithQueryFlags sets the value for the QueryFlags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceInfo) WithQueryFlags(y QueryControlFlags) CommandBufferInheritanceInfo {
	ptr := /* typedef */ (*C.VkQueryControlFlags)(&y)
	x.queryFlags = *ptr
	return x
}

// PipelineStatistics returns the value of pipelineStatistics from VkCommandBufferInheritanceInfo
func (x CommandBufferInheritanceInfo) PipelineStatistics() QueryPipelineStatisticFlags {
	ptr := /* typedef */ (*QueryPipelineStatisticFlags)(&x.pipelineStatistics)
	return *ptr
}

// WithPipelineStatistics sets the value for the PipelineStatistics on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceInfo) WithPipelineStatistics(y QueryPipelineStatisticFlags) CommandBufferInheritanceInfo {
	ptr := /* typedef */ (*C.VkQueryPipelineStatisticFlags)(&y)
	x.pipelineStatistics = *ptr
	return x
}

//SubmitInfo provides a go interface for VkSubmitInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSubmitInfo.html
type SubmitInfo C.struct_VkSubmitInfo

// SizeofSubmitInfo is the memory size of a SubmitInfo
var SizeofSubmitInfo int = int(unsafe.Sizeof(SubmitInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubmitInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubmitInfo) AsCPtr() *SubmitInfo {
	clone := (*SubmitInfo)(newCBlock(C.ulong(SizeofSubmitInfo)))
	*clone = x
	return clone
}

// SubmitInfoFreeCSlice releases the memory allocated by SubmitInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SubmitInfoFreeCSlice(x []SubmitInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubmitInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubmitInfoFreeCSlice must be called on the returned slice.
func SubmitInfoMakeCSlice(x ...SubmitInfo) []SubmitInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubmitInfo * len(x)
	dst := unsafe.Slice((*SubmitInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSubmitInfo
func (x SubmitInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SubmitInfo) WithDefaultSType() SubmitInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SUBMIT_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubmitInfo) WithSType(y StructureType) SubmitInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkSubmitInfo
func (x SubmitInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubmitInfo) WithPNext(y unsafe.Pointer) SubmitInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// WaitSemaphoreCount returns the value of waitSemaphoreCount from VkSubmitInfo
func (x SubmitInfo) WaitSemaphoreCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.waitSemaphoreCount)
	return *ptr
}

// WithWaitSemaphoreCount sets the value for the WaitSemaphoreCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubmitInfo) WithWaitSemaphoreCount(y uint32) SubmitInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.waitSemaphoreCount = *ptr
	return x
}

// PWaitSemaphores returns the value of pWaitSemaphores from VkSubmitInfo
func (x SubmitInfo) PWaitSemaphores() []Semaphore {
	ptr := func(x **C.VkSemaphore) *[]Semaphore { /* Slice */
		slc := unsafe.Slice((*Semaphore)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pWaitSemaphores)
	return *ptr
}

// WithPWaitSemaphores sets the value for the PWaitSemaphores on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines WaitSemaphoreCount as the length of this field.
// WaitSemaphoreCount is updated with the length of the new value.
func (x SubmitInfo) WithPWaitSemaphores(y []Semaphore) SubmitInfo {
	ptr := func(x *[]Semaphore) **C.VkSemaphore { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSemaphore)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSemaphore)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pWaitSemaphores = *ptr
	return x.WithWaitSemaphoreCount(uint32(len(y)))
}

// PWaitDstStageMask returns the value of pWaitDstStageMask from VkSubmitInfo
func (x SubmitInfo) PWaitDstStageMask() []PipelineStageFlags {
	ptr := func(x **C.VkPipelineStageFlags) *[]PipelineStageFlags { /* Slice */
		slc := unsafe.Slice((*PipelineStageFlags)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pWaitDstStageMask)
	return *ptr
}

// WithPWaitDstStageMask sets the value for the PWaitDstStageMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines WaitSemaphoreCount as the length of this field.
// WaitSemaphoreCount is updated with the length of the new value.
func (x SubmitInfo) WithPWaitDstStageMask(y []PipelineStageFlags) SubmitInfo {
	ptr := func(x *[]PipelineStageFlags) **C.VkPipelineStageFlags { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkPipelineStageFlags)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkPipelineStageFlags)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pWaitDstStageMask = *ptr
	return x.WithWaitSemaphoreCount(uint32(len(y)))
}

// CommandBufferCount returns the value of commandBufferCount from VkSubmitInfo
func (x SubmitInfo) CommandBufferCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.commandBufferCount)
	return *ptr
}

// WithCommandBufferCount sets the value for the CommandBufferCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubmitInfo) WithCommandBufferCount(y uint32) SubmitInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.commandBufferCount = *ptr
	return x
}

// PCommandBuffers returns the value of pCommandBuffers from VkSubmitInfo
func (x SubmitInfo) PCommandBuffers() []CommandBuffer {
	ptr := func(x **C.VkCommandBuffer) *[]CommandBuffer { /* Slice */
		slc := unsafe.Slice((*CommandBuffer)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pCommandBuffers)
	return *ptr
}

// WithPCommandBuffers sets the value for the PCommandBuffers on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines CommandBufferCount as the length of this field.
// CommandBufferCount is updated with the length of the new value.
func (x SubmitInfo) WithPCommandBuffers(y []CommandBuffer) SubmitInfo {
	ptr := func(x *[]CommandBuffer) **C.VkCommandBuffer { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkCommandBuffer)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkCommandBuffer)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pCommandBuffers = *ptr
	return x.WithCommandBufferCount(uint32(len(y)))
}

// SignalSemaphoreCount returns the value of signalSemaphoreCount from VkSubmitInfo
func (x SubmitInfo) SignalSemaphoreCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.signalSemaphoreCount)
	return *ptr
}

// WithSignalSemaphoreCount sets the value for the SignalSemaphoreCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubmitInfo) WithSignalSemaphoreCount(y uint32) SubmitInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.signalSemaphoreCount = *ptr
	return x
}

// PSignalSemaphores returns the value of pSignalSemaphores from VkSubmitInfo
func (x SubmitInfo) PSignalSemaphores() []Semaphore {
	ptr := func(x **C.VkSemaphore) *[]Semaphore { /* Slice */
		slc := unsafe.Slice((*Semaphore)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pSignalSemaphores)
	return *ptr
}

// WithPSignalSemaphores sets the value for the PSignalSemaphores on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SignalSemaphoreCount as the length of this field.
// SignalSemaphoreCount is updated with the length of the new value.
func (x SubmitInfo) WithPSignalSemaphores(y []Semaphore) SubmitInfo {
	ptr := func(x *[]Semaphore) **C.VkSemaphore { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSemaphore)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSemaphore)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pSignalSemaphores = *ptr
	return x.WithSignalSemaphoreCount(uint32(len(y)))
}

//FenceCreateInfo provides a go interface for VkFenceCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFenceCreateInfo.html
type FenceCreateInfo C.struct_VkFenceCreateInfo

// SizeofFenceCreateInfo is the memory size of a FenceCreateInfo
var SizeofFenceCreateInfo int = int(unsafe.Sizeof(FenceCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *FenceCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x FenceCreateInfo) AsCPtr() *FenceCreateInfo {
	clone := (*FenceCreateInfo)(newCBlock(C.ulong(SizeofFenceCreateInfo)))
	*clone = x
	return clone
}

// FenceCreateInfoFreeCSlice releases the memory allocated by FenceCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func FenceCreateInfoFreeCSlice(x []FenceCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// FenceCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. FenceCreateInfoFreeCSlice must be called on the returned slice.
func FenceCreateInfoMakeCSlice(x ...FenceCreateInfo) []FenceCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFenceCreateInfo * len(x)
	dst := unsafe.Slice((*FenceCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkFenceCreateInfo
func (x FenceCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x FenceCreateInfo) WithDefaultSType() FenceCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_FENCE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FenceCreateInfo) WithSType(y StructureType) FenceCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkFenceCreateInfo
func (x FenceCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FenceCreateInfo) WithPNext(y unsafe.Pointer) FenceCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkFenceCreateInfo
func (x FenceCreateInfo) Flags() FenceCreateFlags {
	ptr := /* typedef */ (*FenceCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FenceCreateInfo) WithFlags(y FenceCreateFlags) FenceCreateInfo {
	ptr := /* typedef */ (*C.VkFenceCreateFlags)(&y)
	x.flags = *ptr
	return x
}

//BufferCopy provides a go interface for VkBufferCopy.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBufferCopy.html
type BufferCopy C.struct_VkBufferCopy

// SizeofBufferCopy is the memory size of a BufferCopy
var SizeofBufferCopy int = int(unsafe.Sizeof(BufferCopy{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferCopy) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferCopy) AsCPtr() *BufferCopy {
	clone := (*BufferCopy)(newCBlock(C.ulong(SizeofBufferCopy)))
	*clone = x
	return clone
}

// BufferCopyFreeCSlice releases the memory allocated by BufferCopyMakeCSlice.
// It does not free pointers stored inside the slice.
func BufferCopyFreeCSlice(x []BufferCopy) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferCopyMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferCopyFreeCSlice must be called on the returned slice.
func BufferCopyMakeCSlice(x ...BufferCopy) []BufferCopy {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferCopy * len(x)
	dst := unsafe.Slice((*BufferCopy)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SrcOffset returns the value of srcOffset from VkBufferCopy
func (x BufferCopy) SrcOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.srcOffset)
	return *ptr
}

// WithSrcOffset sets the value for the SrcOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCopy) WithSrcOffset(y DeviceSize) BufferCopy {
	ptr := /* typedef */ (*C.VkDeviceSize)(&y)
	x.srcOffset = *ptr
	return x
}

// DstOffset returns the value of dstOffset from VkBufferCopy
func (x BufferCopy) DstOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.dstOffset)
	return *ptr
}

// WithDstOffset sets the value for the DstOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCopy) WithDstOffset(y DeviceSize) BufferCopy {
	ptr := /* typedef */ (*C.VkDeviceSize)(&y)
	x.dstOffset = *ptr
	return x
}

// Size returns the value of size from VkBufferCopy
func (x BufferCopy) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size)
	return *ptr
}

// WithSize sets the value for the Size on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCopy) WithSize(y DeviceSize) BufferCopy {
	ptr := /* typedef */ (*C.VkDeviceSize)(&y)
	x.size = *ptr
	return x
}

//DescriptorSetLayoutCreateInfo provides a go interface for VkDescriptorSetLayoutCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorSetLayoutCreateInfo.html
type DescriptorSetLayoutCreateInfo C.struct_VkDescriptorSetLayoutCreateInfo

// SizeofDescriptorSetLayoutCreateInfo is the memory size of a DescriptorSetLayoutCreateInfo
var SizeofDescriptorSetLayoutCreateInfo int = int(unsafe.Sizeof(DescriptorSetLayoutCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorSetLayoutCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorSetLayoutCreateInfo) AsCPtr() *DescriptorSetLayoutCreateInfo {
	clone := (*DescriptorSetLayoutCreateInfo)(newCBlock(C.ulong(SizeofDescriptorSetLayoutCreateInfo)))
	*clone = x
	return clone
}

// DescriptorSetLayoutCreateInfoFreeCSlice releases the memory allocated by DescriptorSetLayoutCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorSetLayoutCreateInfoFreeCSlice(x []DescriptorSetLayoutCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorSetLayoutCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorSetLayoutCreateInfoFreeCSlice must be called on the returned slice.
func DescriptorSetLayoutCreateInfoMakeCSlice(x ...DescriptorSetLayoutCreateInfo) []DescriptorSetLayoutCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetLayoutCreateInfo * len(x)
	dst := unsafe.Slice((*DescriptorSetLayoutCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDescriptorSetLayoutCreateInfo
func (x DescriptorSetLayoutCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DescriptorSetLayoutCreateInfo) WithDefaultSType() DescriptorSetLayoutCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutCreateInfo) WithSType(y StructureType) DescriptorSetLayoutCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDescriptorSetLayoutCreateInfo
func (x DescriptorSetLayoutCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutCreateInfo) WithPNext(y unsafe.Pointer) DescriptorSetLayoutCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkDescriptorSetLayoutCreateInfo
func (x DescriptorSetLayoutCreateInfo) Flags() DescriptorSetLayoutCreateFlags {
	ptr := /* typedef */ (*DescriptorSetLayoutCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutCreateInfo) WithFlags(y DescriptorSetLayoutCreateFlags) DescriptorSetLayoutCreateInfo {
	ptr := /* typedef */ (*C.VkDescriptorSetLayoutCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// BindingCount returns the value of bindingCount from VkDescriptorSetLayoutCreateInfo
func (x DescriptorSetLayoutCreateInfo) BindingCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.bindingCount)
	return *ptr
}

// WithBindingCount sets the value for the BindingCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutCreateInfo) WithBindingCount(y uint32) DescriptorSetLayoutCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.bindingCount = *ptr
	return x
}

// PBindings returns the value of pBindings from VkDescriptorSetLayoutCreateInfo
func (x DescriptorSetLayoutCreateInfo) PBindings() []DescriptorSetLayoutBinding {
	ptr := func(x **C.struct_VkDescriptorSetLayoutBinding) *[]DescriptorSetLayoutBinding { /* Slice */
		slc := unsafe.Slice((*DescriptorSetLayoutBinding)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pBindings)
	return *ptr
}

// WithPBindings sets the value for the PBindings on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines BindingCount as the length of this field.
// BindingCount is updated with the length of the new value.
func (x DescriptorSetLayoutCreateInfo) WithPBindings(y []DescriptorSetLayoutBinding) DescriptorSetLayoutCreateInfo {
	ptr := func(x *[]DescriptorSetLayoutBinding) **C.struct_VkDescriptorSetLayoutBinding { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDescriptorSetLayoutBinding)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDescriptorSetLayoutBinding)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pBindings = *ptr
	return x.WithBindingCount(uint32(len(y)))
}

//ExtensionProperties provides a go interface for VkExtensionProperties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkExtensionProperties.html
type ExtensionProperties C.struct_VkExtensionProperties

// SizeofExtensionProperties is the memory size of a ExtensionProperties
var SizeofExtensionProperties int = int(unsafe.Sizeof(ExtensionProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExtensionProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExtensionProperties) AsCPtr() *ExtensionProperties {
	clone := (*ExtensionProperties)(newCBlock(C.ulong(SizeofExtensionProperties)))
	*clone = x
	return clone
}

// ExtensionPropertiesFreeCSlice releases the memory allocated by ExtensionPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func ExtensionPropertiesFreeCSlice(x []ExtensionProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExtensionPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExtensionPropertiesFreeCSlice must be called on the returned slice.
func ExtensionPropertiesMakeCSlice(x ...ExtensionProperties) []ExtensionProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExtensionProperties * len(x)
	dst := unsafe.Slice((*ExtensionProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// ExtensionName returns the value of extensionName from VkExtensionProperties
func (x ExtensionProperties) ExtensionName() []byte {
	ptr := func(x *[VK_MAX_EXTENSION_NAME_SIZE]C.char) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_EXTENSION_NAME_SIZE)
		return &slc
	}(&x.extensionName)
	return *ptr
}

// SpecVersion returns the value of specVersion from VkExtensionProperties
func (x ExtensionProperties) SpecVersion() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.specVersion)
	return *ptr
}

//BufferImageCopy provides a go interface for VkBufferImageCopy.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBufferImageCopy.html
type BufferImageCopy C.struct_VkBufferImageCopy

// SizeofBufferImageCopy is the memory size of a BufferImageCopy
var SizeofBufferImageCopy int = int(unsafe.Sizeof(BufferImageCopy{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferImageCopy) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferImageCopy) AsCPtr() *BufferImageCopy {
	clone := (*BufferImageCopy)(newCBlock(C.ulong(SizeofBufferImageCopy)))
	*clone = x
	return clone
}

// BufferImageCopyFreeCSlice releases the memory allocated by BufferImageCopyMakeCSlice.
// It does not free pointers stored inside the slice.
func BufferImageCopyFreeCSlice(x []BufferImageCopy) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferImageCopyMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferImageCopyFreeCSlice must be called on the returned slice.
func BufferImageCopyMakeCSlice(x ...BufferImageCopy) []BufferImageCopy {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferImageCopy * len(x)
	dst := unsafe.Slice((*BufferImageCopy)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// BufferOffset returns the value of bufferOffset from VkBufferImageCopy
func (x BufferImageCopy) BufferOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.bufferOffset)
	return *ptr
}

// WithBufferOffset sets the value for the BufferOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy) WithBufferOffset(y DeviceSize) BufferImageCopy {
	ptr := /* typedef */ (*C.VkDeviceSize)(&y)
	x.bufferOffset = *ptr
	return x
}

// BufferRowLength returns the value of bufferRowLength from VkBufferImageCopy
func (x BufferImageCopy) BufferRowLength() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.bufferRowLength)
	return *ptr
}

// WithBufferRowLength sets the value for the BufferRowLength on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy) WithBufferRowLength(y uint32) BufferImageCopy {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.bufferRowLength = *ptr
	return x
}

// BufferImageHeight returns the value of bufferImageHeight from VkBufferImageCopy
func (x BufferImageCopy) BufferImageHeight() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.bufferImageHeight)
	return *ptr
}

// WithBufferImageHeight sets the value for the BufferImageHeight on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy) WithBufferImageHeight(y uint32) BufferImageCopy {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.bufferImageHeight = *ptr
	return x
}

// ImageSubresource returns the value of imageSubresource from VkBufferImageCopy
func (x BufferImageCopy) ImageSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.imageSubresource)
	return *ptr
}

// WithImageSubresource sets the value for the ImageSubresource on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy) WithImageSubresource(y ImageSubresourceLayers) BufferImageCopy {
	ptr := /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y)
	x.imageSubresource = *ptr
	return x
}

// ImageOffset returns the value of imageOffset from VkBufferImageCopy
func (x BufferImageCopy) ImageOffset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.imageOffset)
	return *ptr
}

// WithImageOffset sets the value for the ImageOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy) WithImageOffset(y Offset3D) BufferImageCopy {
	ptr := /* typedef */ (*C.struct_VkOffset3D)(&y)
	x.imageOffset = *ptr
	return x
}

// ImageExtent returns the value of imageExtent from VkBufferImageCopy
func (x BufferImageCopy) ImageExtent() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.imageExtent)
	return *ptr
}

// WithImageExtent sets the value for the ImageExtent on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy) WithImageExtent(y Extent3D) BufferImageCopy {
	ptr := /* typedef */ (*C.struct_VkExtent3D)(&y)
	x.imageExtent = *ptr
	return x
}

//ClearAttachment provides a go interface for VkClearAttachment.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkClearAttachment.html
type ClearAttachment C.struct_VkClearAttachment

// SizeofClearAttachment is the memory size of a ClearAttachment
var SizeofClearAttachment int = int(unsafe.Sizeof(ClearAttachment{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ClearAttachment) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ClearAttachment) AsCPtr() *ClearAttachment {
	clone := (*ClearAttachment)(newCBlock(C.ulong(SizeofClearAttachment)))
	*clone = x
	return clone
}

// ClearAttachmentFreeCSlice releases the memory allocated by ClearAttachmentMakeCSlice.
// It does not free pointers stored inside the slice.
func ClearAttachmentFreeCSlice(x []ClearAttachment) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ClearAttachmentMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ClearAttachmentFreeCSlice must be called on the returned slice.
func ClearAttachmentMakeCSlice(x ...ClearAttachment) []ClearAttachment {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofClearAttachment * len(x)
	dst := unsafe.Slice((*ClearAttachment)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// AspectMask returns the value of aspectMask from VkClearAttachment
func (x ClearAttachment) AspectMask() ImageAspectFlags {
	ptr := /* typedef */ (*ImageAspectFlags)(&x.aspectMask)
	return *ptr
}

// WithAspectMask sets the value for the AspectMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ClearAttachment) WithAspectMask(y ImageAspectFlags) ClearAttachment {
	ptr := /* typedef */ (*C.VkImageAspectFlags)(&y)
	x.aspectMask = *ptr
	return x
}

// ColorAttachment returns the value of colorAttachment from VkClearAttachment
func (x ClearAttachment) ColorAttachment() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.colorAttachment)
	return *ptr
}

// WithColorAttachment sets the value for the ColorAttachment on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ClearAttachment) WithColorAttachment(y uint32) ClearAttachment {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.colorAttachment = *ptr
	return x
}

// ClearValue returns the value of clearValue from VkClearAttachment
func (x ClearAttachment) ClearValue() ClearValue {
	ptr := /* typedef */ (*ClearValue)(&x.clearValue)
	return *ptr
}

// WithClearValue sets the value for the ClearValue on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ClearAttachment) WithClearValue(y ClearValue) ClearAttachment {
	ptr := /* typedef */ (*C.VkClearValue)(&y)
	x.clearValue = *ptr
	return x
}

//ShaderModuleCreateInfo provides a go interface for VkShaderModuleCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkShaderModuleCreateInfo.html
type ShaderModuleCreateInfo C.struct_VkShaderModuleCreateInfo

// SizeofShaderModuleCreateInfo is the memory size of a ShaderModuleCreateInfo
var SizeofShaderModuleCreateInfo int = int(unsafe.Sizeof(ShaderModuleCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ShaderModuleCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ShaderModuleCreateInfo) AsCPtr() *ShaderModuleCreateInfo {
	clone := (*ShaderModuleCreateInfo)(newCBlock(C.ulong(SizeofShaderModuleCreateInfo)))
	*clone = x
	return clone
}

// ShaderModuleCreateInfoFreeCSlice releases the memory allocated by ShaderModuleCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ShaderModuleCreateInfoFreeCSlice(x []ShaderModuleCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ShaderModuleCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ShaderModuleCreateInfoFreeCSlice must be called on the returned slice.
func ShaderModuleCreateInfoMakeCSlice(x ...ShaderModuleCreateInfo) []ShaderModuleCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofShaderModuleCreateInfo * len(x)
	dst := unsafe.Slice((*ShaderModuleCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkShaderModuleCreateInfo
func (x ShaderModuleCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ShaderModuleCreateInfo) WithDefaultSType() ShaderModuleCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ShaderModuleCreateInfo) WithSType(y StructureType) ShaderModuleCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkShaderModuleCreateInfo
func (x ShaderModuleCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ShaderModuleCreateInfo) WithPNext(y unsafe.Pointer) ShaderModuleCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkShaderModuleCreateInfo
func (x ShaderModuleCreateInfo) Flags() ShaderModuleCreateFlags {
	ptr := /* typedef */ (*ShaderModuleCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ShaderModuleCreateInfo) WithFlags(y ShaderModuleCreateFlags) ShaderModuleCreateInfo {
	ptr := /* typedef */ (*C.VkShaderModuleCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// CodeSize returns the value of codeSize from VkShaderModuleCreateInfo
func (x ShaderModuleCreateInfo) CodeSize() uint64 {
	ptr := func(x *C.ulong) *uint64 { /* Scalar */ return (*uint64)(unsafe.Pointer(x)) }(&x.codeSize)
	return *ptr
}

// WithCodeSize sets the value for the CodeSize on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ShaderModuleCreateInfo) WithCodeSize(y uint64) ShaderModuleCreateInfo {
	ptr := func(x *uint64) *C.ulong { /* Scalar */ return (*C.ulong)(unsafe.Pointer(x)) }(&y)
	x.codeSize = *ptr
	return x
}

// PCode returns the value of pCode from VkShaderModuleCreateInfo
func (x ShaderModuleCreateInfo) PCode() []uint32 {
	ptr := func(x **C.uint) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pCode)
	return *ptr
}

// WithPCode sets the value for the PCode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ShaderModuleCreateInfo) WithPCode(y []uint32) ShaderModuleCreateInfo {
	ptr := func(x *[]uint32) **C.uint { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pCode = *ptr
	return x
}

//DeviceQueueCreateInfo provides a go interface for VkDeviceQueueCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDeviceQueueCreateInfo.html
type DeviceQueueCreateInfo C.struct_VkDeviceQueueCreateInfo

// SizeofDeviceQueueCreateInfo is the memory size of a DeviceQueueCreateInfo
var SizeofDeviceQueueCreateInfo int = int(unsafe.Sizeof(DeviceQueueCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceQueueCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceQueueCreateInfo) AsCPtr() *DeviceQueueCreateInfo {
	clone := (*DeviceQueueCreateInfo)(newCBlock(C.ulong(SizeofDeviceQueueCreateInfo)))
	*clone = x
	return clone
}

// DeviceQueueCreateInfoFreeCSlice releases the memory allocated by DeviceQueueCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceQueueCreateInfoFreeCSlice(x []DeviceQueueCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceQueueCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceQueueCreateInfoFreeCSlice must be called on the returned slice.
func DeviceQueueCreateInfoMakeCSlice(x ...DeviceQueueCreateInfo) []DeviceQueueCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceQueueCreateInfo * len(x)
	dst := unsafe.Slice((*DeviceQueueCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceQueueCreateInfo
func (x DeviceQueueCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DeviceQueueCreateInfo) WithDefaultSType() DeviceQueueCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueCreateInfo) WithSType(y StructureType) DeviceQueueCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDeviceQueueCreateInfo
func (x DeviceQueueCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueCreateInfo) WithPNext(y unsafe.Pointer) DeviceQueueCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkDeviceQueueCreateInfo
func (x DeviceQueueCreateInfo) Flags() DeviceQueueCreateFlags {
	ptr := /* typedef */ (*DeviceQueueCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueCreateInfo) WithFlags(y DeviceQueueCreateFlags) DeviceQueueCreateInfo {
	ptr := /* typedef */ (*C.VkDeviceQueueCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// QueueFamilyIndex returns the value of queueFamilyIndex from VkDeviceQueueCreateInfo
func (x DeviceQueueCreateInfo) QueueFamilyIndex() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.queueFamilyIndex)
	return *ptr
}

// WithQueueFamilyIndex sets the value for the QueueFamilyIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueCreateInfo) WithQueueFamilyIndex(y uint32) DeviceQueueCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.queueFamilyIndex = *ptr
	return x
}

// QueueCount returns the value of queueCount from VkDeviceQueueCreateInfo
func (x DeviceQueueCreateInfo) QueueCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.queueCount)
	return *ptr
}

// WithQueueCount sets the value for the QueueCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueCreateInfo) WithQueueCount(y uint32) DeviceQueueCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.queueCount = *ptr
	return x
}

// PQueuePriorities returns the value of pQueuePriorities from VkDeviceQueueCreateInfo
func (x DeviceQueueCreateInfo) PQueuePriorities() []float32 {
	ptr := func(x **C.float) *[]float32 { /* Slice */
		slc := unsafe.Slice((*float32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pQueuePriorities)
	return *ptr
}

// WithPQueuePriorities sets the value for the PQueuePriorities on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines QueueCount as the length of this field.
// QueueCount is updated with the length of the new value.
func (x DeviceQueueCreateInfo) WithPQueuePriorities(y []float32) DeviceQueueCreateInfo {
	ptr := func(x *[]float32) **C.float { /* Slice */
		if len(*x) > 0 {
			slc := (*C.float)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.float)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pQueuePriorities = *ptr
	return x.WithQueueCount(uint32(len(y)))
}

//DescriptorSetLayoutBinding provides a go interface for VkDescriptorSetLayoutBinding.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorSetLayoutBinding.html
type DescriptorSetLayoutBinding C.struct_VkDescriptorSetLayoutBinding

// SizeofDescriptorSetLayoutBinding is the memory size of a DescriptorSetLayoutBinding
var SizeofDescriptorSetLayoutBinding int = int(unsafe.Sizeof(DescriptorSetLayoutBinding{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorSetLayoutBinding) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorSetLayoutBinding) AsCPtr() *DescriptorSetLayoutBinding {
	clone := (*DescriptorSetLayoutBinding)(newCBlock(C.ulong(SizeofDescriptorSetLayoutBinding)))
	*clone = x
	return clone
}

// DescriptorSetLayoutBindingFreeCSlice releases the memory allocated by DescriptorSetLayoutBindingMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorSetLayoutBindingFreeCSlice(x []DescriptorSetLayoutBinding) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorSetLayoutBindingMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorSetLayoutBindingFreeCSlice must be called on the returned slice.
func DescriptorSetLayoutBindingMakeCSlice(x ...DescriptorSetLayoutBinding) []DescriptorSetLayoutBinding {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetLayoutBinding * len(x)
	dst := unsafe.Slice((*DescriptorSetLayoutBinding)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Binding returns the value of binding from VkDescriptorSetLayoutBinding
func (x DescriptorSetLayoutBinding) Binding() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.binding)
	return *ptr
}

// WithBinding sets the value for the Binding on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutBinding) WithBinding(y uint32) DescriptorSetLayoutBinding {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.binding = *ptr
	return x
}

// DescriptorType returns the value of descriptorType from VkDescriptorSetLayoutBinding
func (x DescriptorSetLayoutBinding) DescriptorType() DescriptorType {
	ptr := /* typedef */ (*DescriptorType)(&x.descriptorType)
	return *ptr
}

// WithDescriptorType sets the value for the DescriptorType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutBinding) WithDescriptorType(y DescriptorType) DescriptorSetLayoutBinding {
	ptr := /* typedef */ (*C.VkDescriptorType)(&y)
	x.descriptorType = *ptr
	return x
}

// DescriptorCount returns the value of descriptorCount from VkDescriptorSetLayoutBinding
func (x DescriptorSetLayoutBinding) DescriptorCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.descriptorCount)
	return *ptr
}

// WithDescriptorCount sets the value for the DescriptorCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutBinding) WithDescriptorCount(y uint32) DescriptorSetLayoutBinding {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.descriptorCount = *ptr
	return x
}

// StageFlags returns the value of stageFlags from VkDescriptorSetLayoutBinding
func (x DescriptorSetLayoutBinding) StageFlags() ShaderStageFlags {
	ptr := /* typedef */ (*ShaderStageFlags)(&x.stageFlags)
	return *ptr
}

// WithStageFlags sets the value for the StageFlags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutBinding) WithStageFlags(y ShaderStageFlags) DescriptorSetLayoutBinding {
	ptr := /* typedef */ (*C.VkShaderStageFlags)(&y)
	x.stageFlags = *ptr
	return x
}

// PImmutableSamplers returns the value of pImmutableSamplers from VkDescriptorSetLayoutBinding
func (x DescriptorSetLayoutBinding) PImmutableSamplers() []Sampler {
	ptr := func(x **C.VkSampler) *[]Sampler { /* Slice */
		slc := unsafe.Slice((*Sampler)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pImmutableSamplers)
	return *ptr
}

// WithPImmutableSamplers sets the value for the PImmutableSamplers on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DescriptorCount as the length of this field.
// DescriptorCount is updated with the length of the new value.
func (x DescriptorSetLayoutBinding) WithPImmutableSamplers(y []Sampler) DescriptorSetLayoutBinding {
	ptr := func(x *[]Sampler) **C.VkSampler { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSampler)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSampler)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pImmutableSamplers = *ptr
	return x.WithDescriptorCount(uint32(len(y)))
}

//DeviceCreateInfo provides a go interface for VkDeviceCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDeviceCreateInfo.html
type DeviceCreateInfo C.struct_VkDeviceCreateInfo

// SizeofDeviceCreateInfo is the memory size of a DeviceCreateInfo
var SizeofDeviceCreateInfo int = int(unsafe.Sizeof(DeviceCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceCreateInfo) AsCPtr() *DeviceCreateInfo {
	clone := (*DeviceCreateInfo)(newCBlock(C.ulong(SizeofDeviceCreateInfo)))
	*clone = x
	return clone
}

// DeviceCreateInfoFreeCSlice releases the memory allocated by DeviceCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceCreateInfoFreeCSlice(x []DeviceCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceCreateInfoFreeCSlice must be called on the returned slice.
func DeviceCreateInfoMakeCSlice(x ...DeviceCreateInfo) []DeviceCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceCreateInfo * len(x)
	dst := unsafe.Slice((*DeviceCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceCreateInfo
func (x DeviceCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DeviceCreateInfo) WithDefaultSType() DeviceCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceCreateInfo) WithSType(y StructureType) DeviceCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDeviceCreateInfo
func (x DeviceCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceCreateInfo) WithPNext(y unsafe.Pointer) DeviceCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkDeviceCreateInfo
func (x DeviceCreateInfo) Flags() DeviceCreateFlags {
	ptr := /* typedef */ (*DeviceCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceCreateInfo) WithFlags(y DeviceCreateFlags) DeviceCreateInfo {
	ptr := /* typedef */ (*C.VkDeviceCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// QueueCreateInfoCount returns the value of queueCreateInfoCount from VkDeviceCreateInfo
func (x DeviceCreateInfo) QueueCreateInfoCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.queueCreateInfoCount)
	return *ptr
}

// WithQueueCreateInfoCount sets the value for the QueueCreateInfoCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceCreateInfo) WithQueueCreateInfoCount(y uint32) DeviceCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.queueCreateInfoCount = *ptr
	return x
}

// PQueueCreateInfos returns the value of pQueueCreateInfos from VkDeviceCreateInfo
func (x DeviceCreateInfo) PQueueCreateInfos() []DeviceQueueCreateInfo {
	ptr := func(x **C.struct_VkDeviceQueueCreateInfo) *[]DeviceQueueCreateInfo { /* Slice */
		slc := unsafe.Slice((*DeviceQueueCreateInfo)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pQueueCreateInfos)
	return *ptr
}

// WithPQueueCreateInfos sets the value for the PQueueCreateInfos on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines QueueCreateInfoCount as the length of this field.
// QueueCreateInfoCount is updated with the length of the new value.
func (x DeviceCreateInfo) WithPQueueCreateInfos(y []DeviceQueueCreateInfo) DeviceCreateInfo {
	ptr := func(x *[]DeviceQueueCreateInfo) **C.struct_VkDeviceQueueCreateInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDeviceQueueCreateInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDeviceQueueCreateInfo)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pQueueCreateInfos = *ptr
	return x.WithQueueCreateInfoCount(uint32(len(y)))
}

// EnabledLayerCount returns the value of enabledLayerCount from VkDeviceCreateInfo
func (x DeviceCreateInfo) EnabledLayerCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.enabledLayerCount)
	return *ptr
}

// WithEnabledLayerCount sets the value for the EnabledLayerCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceCreateInfo) WithEnabledLayerCount(y uint32) DeviceCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.enabledLayerCount = *ptr
	return x
}

// PpEnabledLayerNames returns the value of ppEnabledLayerNames from VkDeviceCreateInfo
func (x DeviceCreateInfo) PpEnabledLayerNames() []*byte {
	ptr := func(x ***C.char) *[]*byte { /* Slice */
		slc := unsafe.Slice((**byte)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.ppEnabledLayerNames)
	return *ptr
}

// WithPpEnabledLayerNames sets the value for the PpEnabledLayerNames on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceCreateInfo) WithPpEnabledLayerNames(y []*byte) DeviceCreateInfo {
	ptr := func(x *[]*byte) ***C.char { /* Slice */
		if len(*x) > 0 {
			slc := (**C.char)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (***C.char)(unsafe.Pointer((&ptr)))
	}(&y)
	x.ppEnabledLayerNames = *ptr
	return x
}

// EnabledExtensionCount returns the value of enabledExtensionCount from VkDeviceCreateInfo
func (x DeviceCreateInfo) EnabledExtensionCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.enabledExtensionCount)
	return *ptr
}

// WithEnabledExtensionCount sets the value for the EnabledExtensionCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceCreateInfo) WithEnabledExtensionCount(y uint32) DeviceCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.enabledExtensionCount = *ptr
	return x
}

// PpEnabledExtensionNames returns the value of ppEnabledExtensionNames from VkDeviceCreateInfo
func (x DeviceCreateInfo) PpEnabledExtensionNames() []*byte {
	ptr := func(x ***C.char) *[]*byte { /* Slice */
		slc := unsafe.Slice((**byte)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.ppEnabledExtensionNames)
	return *ptr
}

// WithPpEnabledExtensionNames sets the value for the PpEnabledExtensionNames on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceCreateInfo) WithPpEnabledExtensionNames(y []*byte) DeviceCreateInfo {
	ptr := func(x *[]*byte) ***C.char { /* Slice */
		if len(*x) > 0 {
			slc := (**C.char)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (***C.char)(unsafe.Pointer((&ptr)))
	}(&y)
	x.ppEnabledExtensionNames = *ptr
	return x
}

// PEnabledFeatures returns the value of pEnabledFeatures from VkDeviceCreateInfo
func (x DeviceCreateInfo) PEnabledFeatures() *PhysicalDeviceFeatures {
	ptr := func(x **C.struct_VkPhysicalDeviceFeatures) **PhysicalDeviceFeatures { /* Pointer */
		return (**PhysicalDeviceFeatures)(unsafe.Pointer(x))
	}(&x.pEnabledFeatures)
	return *ptr
}

// WithPEnabledFeatures sets the value for the PEnabledFeatures on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceCreateInfo) WithPEnabledFeatures(y *PhysicalDeviceFeatures) DeviceCreateInfo {
	ptr := func(x **PhysicalDeviceFeatures) **C.struct_VkPhysicalDeviceFeatures { /* Pointer */
		return (**C.struct_VkPhysicalDeviceFeatures)(unsafe.Pointer(x))
	}(&y)
	x.pEnabledFeatures = *ptr
	return x
}

//DescriptorSetAllocateInfo provides a go interface for VkDescriptorSetAllocateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorSetAllocateInfo.html
type DescriptorSetAllocateInfo C.struct_VkDescriptorSetAllocateInfo

// SizeofDescriptorSetAllocateInfo is the memory size of a DescriptorSetAllocateInfo
var SizeofDescriptorSetAllocateInfo int = int(unsafe.Sizeof(DescriptorSetAllocateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorSetAllocateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorSetAllocateInfo) AsCPtr() *DescriptorSetAllocateInfo {
	clone := (*DescriptorSetAllocateInfo)(newCBlock(C.ulong(SizeofDescriptorSetAllocateInfo)))
	*clone = x
	return clone
}

// DescriptorSetAllocateInfoFreeCSlice releases the memory allocated by DescriptorSetAllocateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorSetAllocateInfoFreeCSlice(x []DescriptorSetAllocateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorSetAllocateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorSetAllocateInfoFreeCSlice must be called on the returned slice.
func DescriptorSetAllocateInfoMakeCSlice(x ...DescriptorSetAllocateInfo) []DescriptorSetAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetAllocateInfo * len(x)
	dst := unsafe.Slice((*DescriptorSetAllocateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDescriptorSetAllocateInfo
func (x DescriptorSetAllocateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DescriptorSetAllocateInfo) WithDefaultSType() DescriptorSetAllocateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetAllocateInfo) WithSType(y StructureType) DescriptorSetAllocateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDescriptorSetAllocateInfo
func (x DescriptorSetAllocateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetAllocateInfo) WithPNext(y unsafe.Pointer) DescriptorSetAllocateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// DescriptorPool returns the value of descriptorPool from VkDescriptorSetAllocateInfo
func (x DescriptorSetAllocateInfo) DescriptorPool() DescriptorPool {
	ptr := /* handle */ (*DescriptorPool)(&x.descriptorPool)
	return *ptr
}

// WithDescriptorPool sets the value for the DescriptorPool on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetAllocateInfo) WithDescriptorPool(y DescriptorPool) DescriptorSetAllocateInfo {
	ptr := /* handle */ (*C.VkDescriptorPool)(&y)
	x.descriptorPool = *ptr
	return x
}

// DescriptorSetCount returns the value of descriptorSetCount from VkDescriptorSetAllocateInfo
func (x DescriptorSetAllocateInfo) DescriptorSetCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.descriptorSetCount)
	return *ptr
}

// WithDescriptorSetCount sets the value for the DescriptorSetCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetAllocateInfo) WithDescriptorSetCount(y uint32) DescriptorSetAllocateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.descriptorSetCount = *ptr
	return x
}

// PSetLayouts returns the value of pSetLayouts from VkDescriptorSetAllocateInfo
func (x DescriptorSetAllocateInfo) PSetLayouts() []DescriptorSetLayout {
	ptr := func(x **C.VkDescriptorSetLayout) *[]DescriptorSetLayout { /* Slice */
		slc := unsafe.Slice((*DescriptorSetLayout)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pSetLayouts)
	return *ptr
}

// WithPSetLayouts sets the value for the PSetLayouts on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DescriptorSetCount as the length of this field.
// DescriptorSetCount is updated with the length of the new value.
func (x DescriptorSetAllocateInfo) WithPSetLayouts(y []DescriptorSetLayout) DescriptorSetAllocateInfo {
	ptr := func(x *[]DescriptorSetLayout) **C.VkDescriptorSetLayout { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkDescriptorSetLayout)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkDescriptorSetLayout)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pSetLayouts = *ptr
	return x.WithDescriptorSetCount(uint32(len(y)))
}

//ClearDepthStencilValue provides a go interface for VkClearDepthStencilValue.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkClearDepthStencilValue.html
type ClearDepthStencilValue C.struct_VkClearDepthStencilValue

// SizeofClearDepthStencilValue is the memory size of a ClearDepthStencilValue
var SizeofClearDepthStencilValue int = int(unsafe.Sizeof(ClearDepthStencilValue{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ClearDepthStencilValue) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ClearDepthStencilValue) AsCPtr() *ClearDepthStencilValue {
	clone := (*ClearDepthStencilValue)(newCBlock(C.ulong(SizeofClearDepthStencilValue)))
	*clone = x
	return clone
}

// ClearDepthStencilValueFreeCSlice releases the memory allocated by ClearDepthStencilValueMakeCSlice.
// It does not free pointers stored inside the slice.
func ClearDepthStencilValueFreeCSlice(x []ClearDepthStencilValue) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ClearDepthStencilValueMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ClearDepthStencilValueFreeCSlice must be called on the returned slice.
func ClearDepthStencilValueMakeCSlice(x ...ClearDepthStencilValue) []ClearDepthStencilValue {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofClearDepthStencilValue * len(x)
	dst := unsafe.Slice((*ClearDepthStencilValue)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Depth returns the value of depth from VkClearDepthStencilValue
func (x ClearDepthStencilValue) Depth() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ return (*float32)(unsafe.Pointer(x)) }(&x.depth)
	return *ptr
}

// WithDepth sets the value for the Depth on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ClearDepthStencilValue) WithDepth(y float32) ClearDepthStencilValue {
	ptr := func(x *float32) *C.float { /* Scalar */ return (*C.float)(unsafe.Pointer(x)) }(&y)
	x.depth = *ptr
	return x
}

// Stencil returns the value of stencil from VkClearDepthStencilValue
func (x ClearDepthStencilValue) Stencil() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.stencil)
	return *ptr
}

// WithStencil sets the value for the Stencil on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ClearDepthStencilValue) WithStencil(y uint32) ClearDepthStencilValue {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.stencil = *ptr
	return x
}

//QueueFamilyProperties provides a go interface for VkQueueFamilyProperties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkQueueFamilyProperties.html
type QueueFamilyProperties C.struct_VkQueueFamilyProperties

// SizeofQueueFamilyProperties is the memory size of a QueueFamilyProperties
var SizeofQueueFamilyProperties int = int(unsafe.Sizeof(QueueFamilyProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *QueueFamilyProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x QueueFamilyProperties) AsCPtr() *QueueFamilyProperties {
	clone := (*QueueFamilyProperties)(newCBlock(C.ulong(SizeofQueueFamilyProperties)))
	*clone = x
	return clone
}

// QueueFamilyPropertiesFreeCSlice releases the memory allocated by QueueFamilyPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func QueueFamilyPropertiesFreeCSlice(x []QueueFamilyProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// QueueFamilyPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. QueueFamilyPropertiesFreeCSlice must be called on the returned slice.
func QueueFamilyPropertiesMakeCSlice(x ...QueueFamilyProperties) []QueueFamilyProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofQueueFamilyProperties * len(x)
	dst := unsafe.Slice((*QueueFamilyProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// QueueFlags returns the value of queueFlags from VkQueueFamilyProperties
func (x QueueFamilyProperties) QueueFlags() QueueFlags {
	ptr := /* typedef */ (*QueueFlags)(&x.queueFlags)
	return *ptr
}

// QueueCount returns the value of queueCount from VkQueueFamilyProperties
func (x QueueFamilyProperties) QueueCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.queueCount)
	return *ptr
}

// TimestampValidBits returns the value of timestampValidBits from VkQueueFamilyProperties
func (x QueueFamilyProperties) TimestampValidBits() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.timestampValidBits)
	return *ptr
}

// MinImageTransferGranularity returns the value of minImageTransferGranularity from VkQueueFamilyProperties
func (x QueueFamilyProperties) MinImageTransferGranularity() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.minImageTransferGranularity)
	return *ptr
}

//PipelineCacheCreateInfo provides a go interface for VkPipelineCacheCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineCacheCreateInfo.html
type PipelineCacheCreateInfo C.struct_VkPipelineCacheCreateInfo

// SizeofPipelineCacheCreateInfo is the memory size of a PipelineCacheCreateInfo
var SizeofPipelineCacheCreateInfo int = int(unsafe.Sizeof(PipelineCacheCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineCacheCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineCacheCreateInfo) AsCPtr() *PipelineCacheCreateInfo {
	clone := (*PipelineCacheCreateInfo)(newCBlock(C.ulong(SizeofPipelineCacheCreateInfo)))
	*clone = x
	return clone
}

// PipelineCacheCreateInfoFreeCSlice releases the memory allocated by PipelineCacheCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineCacheCreateInfoFreeCSlice(x []PipelineCacheCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineCacheCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineCacheCreateInfoFreeCSlice must be called on the returned slice.
func PipelineCacheCreateInfoMakeCSlice(x ...PipelineCacheCreateInfo) []PipelineCacheCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineCacheCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineCacheCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineCacheCreateInfo
func (x PipelineCacheCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineCacheCreateInfo) WithDefaultSType() PipelineCacheCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheCreateInfo) WithSType(y StructureType) PipelineCacheCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPipelineCacheCreateInfo
func (x PipelineCacheCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheCreateInfo) WithPNext(y unsafe.Pointer) PipelineCacheCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkPipelineCacheCreateInfo
func (x PipelineCacheCreateInfo) Flags() PipelineCacheCreateFlags {
	ptr := /* typedef */ (*PipelineCacheCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheCreateInfo) WithFlags(y PipelineCacheCreateFlags) PipelineCacheCreateInfo {
	ptr := /* typedef */ (*C.VkPipelineCacheCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// InitialDataSize returns the value of initialDataSize from VkPipelineCacheCreateInfo
func (x PipelineCacheCreateInfo) InitialDataSize() uint64 {
	ptr := func(x *C.ulong) *uint64 { /* Scalar */ return (*uint64)(unsafe.Pointer(x)) }(&x.initialDataSize)
	return *ptr
}

// WithInitialDataSize sets the value for the InitialDataSize on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheCreateInfo) WithInitialDataSize(y uint64) PipelineCacheCreateInfo {
	ptr := func(x *uint64) *C.ulong { /* Scalar */ return (*C.ulong)(unsafe.Pointer(x)) }(&y)
	x.initialDataSize = *ptr
	return x
}

// PInitialData returns the value of pInitialData from VkPipelineCacheCreateInfo
func (x PipelineCacheCreateInfo) PInitialData() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pInitialData)
	return *ptr
}

// WithPInitialData sets the value for the PInitialData on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheCreateInfo) WithPInitialData(y unsafe.Pointer) PipelineCacheCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pInitialData = *ptr
	return x
}

//PhysicalDeviceSparseProperties provides a go interface for VkPhysicalDeviceSparseProperties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceSparseProperties.html
type PhysicalDeviceSparseProperties C.struct_VkPhysicalDeviceSparseProperties

// SizeofPhysicalDeviceSparseProperties is the memory size of a PhysicalDeviceSparseProperties
var SizeofPhysicalDeviceSparseProperties int = int(unsafe.Sizeof(PhysicalDeviceSparseProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceSparseProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceSparseProperties) AsCPtr() *PhysicalDeviceSparseProperties {
	clone := (*PhysicalDeviceSparseProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceSparseProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceSparsePropertiesFreeCSlice releases the memory allocated by PhysicalDeviceSparsePropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceSparsePropertiesFreeCSlice(x []PhysicalDeviceSparseProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceSparsePropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceSparsePropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceSparsePropertiesMakeCSlice(x ...PhysicalDeviceSparseProperties) []PhysicalDeviceSparseProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSparseProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceSparseProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// ResidencyStandard2DBlockShape returns the value of residencyStandard2DBlockShape from VkPhysicalDeviceSparseProperties
func (x PhysicalDeviceSparseProperties) ResidencyStandard2DBlockShape() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.residencyStandard2DBlockShape)
	return *ptr
}

// ResidencyStandard2DMultisampleBlockShape returns the value of residencyStandard2DMultisampleBlockShape from VkPhysicalDeviceSparseProperties
func (x PhysicalDeviceSparseProperties) ResidencyStandard2DMultisampleBlockShape() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.residencyStandard2DMultisampleBlockShape)
	return *ptr
}

// ResidencyStandard3DBlockShape returns the value of residencyStandard3DBlockShape from VkPhysicalDeviceSparseProperties
func (x PhysicalDeviceSparseProperties) ResidencyStandard3DBlockShape() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.residencyStandard3DBlockShape)
	return *ptr
}

// ResidencyAlignedMipSize returns the value of residencyAlignedMipSize from VkPhysicalDeviceSparseProperties
func (x PhysicalDeviceSparseProperties) ResidencyAlignedMipSize() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.residencyAlignedMipSize)
	return *ptr
}

// ResidencyNonResidentStrict returns the value of residencyNonResidentStrict from VkPhysicalDeviceSparseProperties
func (x PhysicalDeviceSparseProperties) ResidencyNonResidentStrict() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.residencyNonResidentStrict)
	return *ptr
}

//DescriptorPoolSize provides a go interface for VkDescriptorPoolSize.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorPoolSize.html
type DescriptorPoolSize C.struct_VkDescriptorPoolSize

// SizeofDescriptorPoolSize is the memory size of a DescriptorPoolSize
var SizeofDescriptorPoolSize int = int(unsafe.Sizeof(DescriptorPoolSize{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorPoolSize) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorPoolSize) AsCPtr() *DescriptorPoolSize {
	clone := (*DescriptorPoolSize)(newCBlock(C.ulong(SizeofDescriptorPoolSize)))
	*clone = x
	return clone
}

// DescriptorPoolSizeFreeCSlice releases the memory allocated by DescriptorPoolSizeMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorPoolSizeFreeCSlice(x []DescriptorPoolSize) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorPoolSizeMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorPoolSizeFreeCSlice must be called on the returned slice.
func DescriptorPoolSizeMakeCSlice(x ...DescriptorPoolSize) []DescriptorPoolSize {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorPoolSize * len(x)
	dst := unsafe.Slice((*DescriptorPoolSize)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Type_ returns the value of type from VkDescriptorPoolSize
func (x DescriptorPoolSize) Type_() DescriptorType {
	ptr := /* typedef */ (*DescriptorType)(&x._type)
	return *ptr
}

// WithType_ sets the value for the Type_ on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorPoolSize) WithType_(y DescriptorType) DescriptorPoolSize {
	ptr := /* typedef */ (*C.VkDescriptorType)(&y)
	x._type = *ptr
	return x
}

// DescriptorCount returns the value of descriptorCount from VkDescriptorPoolSize
func (x DescriptorPoolSize) DescriptorCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.descriptorCount)
	return *ptr
}

// WithDescriptorCount sets the value for the DescriptorCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorPoolSize) WithDescriptorCount(y uint32) DescriptorPoolSize {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.descriptorCount = *ptr
	return x
}

//PhysicalDeviceProperties provides a go interface for VkPhysicalDeviceProperties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceProperties.html
type PhysicalDeviceProperties C.struct_VkPhysicalDeviceProperties

// SizeofPhysicalDeviceProperties is the memory size of a PhysicalDeviceProperties
var SizeofPhysicalDeviceProperties int = int(unsafe.Sizeof(PhysicalDeviceProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceProperties) AsCPtr() *PhysicalDeviceProperties {
	clone := (*PhysicalDeviceProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceProperties)))
	*clone = x
	return clone
}

// PhysicalDevicePropertiesFreeCSlice releases the memory allocated by PhysicalDevicePropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDevicePropertiesFreeCSlice(x []PhysicalDeviceProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDevicePropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDevicePropertiesFreeCSlice must be called on the returned slice.
func PhysicalDevicePropertiesMakeCSlice(x ...PhysicalDeviceProperties) []PhysicalDeviceProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// ApiVersion returns the value of apiVersion from VkPhysicalDeviceProperties
func (x PhysicalDeviceProperties) ApiVersion() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.apiVersion)
	return *ptr
}

// DriverVersion returns the value of driverVersion from VkPhysicalDeviceProperties
func (x PhysicalDeviceProperties) DriverVersion() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.driverVersion)
	return *ptr
}

// VendorID returns the value of vendorID from VkPhysicalDeviceProperties
func (x PhysicalDeviceProperties) VendorID() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.vendorID)
	return *ptr
}

// DeviceID returns the value of deviceID from VkPhysicalDeviceProperties
func (x PhysicalDeviceProperties) DeviceID() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.deviceID)
	return *ptr
}

// DeviceType returns the value of deviceType from VkPhysicalDeviceProperties
func (x PhysicalDeviceProperties) DeviceType() PhysicalDeviceType {
	ptr := /* typedef */ (*PhysicalDeviceType)(&x.deviceType)
	return *ptr
}

// DeviceName returns the value of deviceName from VkPhysicalDeviceProperties
func (x PhysicalDeviceProperties) DeviceName() []byte {
	ptr := func(x *[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE]C.char) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_PHYSICAL_DEVICE_NAME_SIZE)
		return &slc
	}(&x.deviceName)
	return *ptr
}

// PipelineCacheUUID returns the value of pipelineCacheUUID from VkPhysicalDeviceProperties
func (x PhysicalDeviceProperties) PipelineCacheUUID() []byte {
	ptr := func(x *[VK_UUID_SIZE]C.uchar) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_UUID_SIZE)
		return &slc
	}(&x.pipelineCacheUUID)
	return *ptr
}

// Limits returns the value of limits from VkPhysicalDeviceProperties
func (x PhysicalDeviceProperties) Limits() PhysicalDeviceLimits {
	ptr := /* typedef */ (*PhysicalDeviceLimits)(&x.limits)
	return *ptr
}

// SparseProperties returns the value of sparseProperties from VkPhysicalDeviceProperties
func (x PhysicalDeviceProperties) SparseProperties() PhysicalDeviceSparseProperties {
	ptr := /* typedef */ (*PhysicalDeviceSparseProperties)(&x.sparseProperties)
	return *ptr
}

//PhysicalDeviceMemoryProperties provides a go interface for VkPhysicalDeviceMemoryProperties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceMemoryProperties.html
type PhysicalDeviceMemoryProperties C.struct_VkPhysicalDeviceMemoryProperties

// SizeofPhysicalDeviceMemoryProperties is the memory size of a PhysicalDeviceMemoryProperties
var SizeofPhysicalDeviceMemoryProperties int = int(unsafe.Sizeof(PhysicalDeviceMemoryProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceMemoryProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceMemoryProperties) AsCPtr() *PhysicalDeviceMemoryProperties {
	clone := (*PhysicalDeviceMemoryProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceMemoryProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceMemoryPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceMemoryPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceMemoryPropertiesFreeCSlice(x []PhysicalDeviceMemoryProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceMemoryPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceMemoryPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceMemoryPropertiesMakeCSlice(x ...PhysicalDeviceMemoryProperties) []PhysicalDeviceMemoryProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceMemoryProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceMemoryProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// MemoryTypeCount returns the value of memoryTypeCount from VkPhysicalDeviceMemoryProperties
func (x PhysicalDeviceMemoryProperties) MemoryTypeCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.memoryTypeCount)
	return *ptr
}

// MemoryTypes returns the value of memoryTypes from VkPhysicalDeviceMemoryProperties
func (x PhysicalDeviceMemoryProperties) MemoryTypes() []MemoryType {
	ptr := func(x *[VK_MAX_MEMORY_TYPES]C.struct_VkMemoryType) *[]MemoryType { /* Array */
		slc := unsafe.Slice((*MemoryType)(unsafe.Pointer(x)), VK_MAX_MEMORY_TYPES)
		return &slc
	}(&x.memoryTypes)
	return *ptr
}

// MemoryHeapCount returns the value of memoryHeapCount from VkPhysicalDeviceMemoryProperties
func (x PhysicalDeviceMemoryProperties) MemoryHeapCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.memoryHeapCount)
	return *ptr
}

// MemoryHeaps returns the value of memoryHeaps from VkPhysicalDeviceMemoryProperties
func (x PhysicalDeviceMemoryProperties) MemoryHeaps() []MemoryHeap {
	ptr := func(x *[VK_MAX_MEMORY_HEAPS]C.struct_VkMemoryHeap) *[]MemoryHeap { /* Array */
		slc := unsafe.Slice((*MemoryHeap)(unsafe.Pointer(x)), VK_MAX_MEMORY_HEAPS)
		return &slc
	}(&x.memoryHeaps)
	return *ptr
}

//PhysicalDeviceLimits provides a go interface for VkPhysicalDeviceLimits.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceLimits.html
type PhysicalDeviceLimits C.struct_VkPhysicalDeviceLimits

// SizeofPhysicalDeviceLimits is the memory size of a PhysicalDeviceLimits
var SizeofPhysicalDeviceLimits int = int(unsafe.Sizeof(PhysicalDeviceLimits{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceLimits) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceLimits) AsCPtr() *PhysicalDeviceLimits {
	clone := (*PhysicalDeviceLimits)(newCBlock(C.ulong(SizeofPhysicalDeviceLimits)))
	*clone = x
	return clone
}

// PhysicalDeviceLimitsFreeCSlice releases the memory allocated by PhysicalDeviceLimitsMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceLimitsFreeCSlice(x []PhysicalDeviceLimits) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceLimitsMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceLimitsFreeCSlice must be called on the returned slice.
func PhysicalDeviceLimitsMakeCSlice(x ...PhysicalDeviceLimits) []PhysicalDeviceLimits {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceLimits * len(x)
	dst := unsafe.Slice((*PhysicalDeviceLimits)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// MaxImageDimension1D returns the value of maxImageDimension1D from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxImageDimension1D() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxImageDimension1D)
	return *ptr
}

// MaxImageDimension2D returns the value of maxImageDimension2D from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxImageDimension2D() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxImageDimension2D)
	return *ptr
}

// MaxImageDimension3D returns the value of maxImageDimension3D from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxImageDimension3D() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxImageDimension3D)
	return *ptr
}

// MaxImageDimensionCube returns the value of maxImageDimensionCube from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxImageDimensionCube() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxImageDimensionCube)
	return *ptr
}

// MaxImageArrayLayers returns the value of maxImageArrayLayers from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxImageArrayLayers() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxImageArrayLayers)
	return *ptr
}

// MaxTexelBufferElements returns the value of maxTexelBufferElements from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTexelBufferElements() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxTexelBufferElements)
	return *ptr
}

// MaxUniformBufferRange returns the value of maxUniformBufferRange from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxUniformBufferRange() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxUniformBufferRange)
	return *ptr
}

// MaxStorageBufferRange returns the value of maxStorageBufferRange from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxStorageBufferRange() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxStorageBufferRange)
	return *ptr
}

// MaxPushConstantsSize returns the value of maxPushConstantsSize from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxPushConstantsSize() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxPushConstantsSize)
	return *ptr
}

// MaxMemoryAllocationCount returns the value of maxMemoryAllocationCount from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxMemoryAllocationCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxMemoryAllocationCount)
	return *ptr
}

// MaxSamplerAllocationCount returns the value of maxSamplerAllocationCount from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxSamplerAllocationCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxSamplerAllocationCount)
	return *ptr
}

// BufferImageGranularity returns the value of bufferImageGranularity from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) BufferImageGranularity() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.bufferImageGranularity)
	return *ptr
}

// SparseAddressSpaceSize returns the value of sparseAddressSpaceSize from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) SparseAddressSpaceSize() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.sparseAddressSpaceSize)
	return *ptr
}

// MaxBoundDescriptorSets returns the value of maxBoundDescriptorSets from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxBoundDescriptorSets() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxBoundDescriptorSets)
	return *ptr
}

// MaxPerStageDescriptorSamplers returns the value of maxPerStageDescriptorSamplers from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxPerStageDescriptorSamplers() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxPerStageDescriptorSamplers)
	return *ptr
}

// MaxPerStageDescriptorUniformBuffers returns the value of maxPerStageDescriptorUniformBuffers from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxPerStageDescriptorUniformBuffers() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxPerStageDescriptorUniformBuffers)
	return *ptr
}

// MaxPerStageDescriptorStorageBuffers returns the value of maxPerStageDescriptorStorageBuffers from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxPerStageDescriptorStorageBuffers() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxPerStageDescriptorStorageBuffers)
	return *ptr
}

// MaxPerStageDescriptorSampledImages returns the value of maxPerStageDescriptorSampledImages from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxPerStageDescriptorSampledImages() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxPerStageDescriptorSampledImages)
	return *ptr
}

// MaxPerStageDescriptorStorageImages returns the value of maxPerStageDescriptorStorageImages from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxPerStageDescriptorStorageImages() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxPerStageDescriptorStorageImages)
	return *ptr
}

// MaxPerStageDescriptorInputAttachments returns the value of maxPerStageDescriptorInputAttachments from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxPerStageDescriptorInputAttachments() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxPerStageDescriptorInputAttachments)
	return *ptr
}

// MaxPerStageResources returns the value of maxPerStageResources from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxPerStageResources() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxPerStageResources)
	return *ptr
}

// MaxDescriptorSetSamplers returns the value of maxDescriptorSetSamplers from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDescriptorSetSamplers() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxDescriptorSetSamplers)
	return *ptr
}

// MaxDescriptorSetUniformBuffers returns the value of maxDescriptorSetUniformBuffers from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDescriptorSetUniformBuffers() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxDescriptorSetUniformBuffers)
	return *ptr
}

// MaxDescriptorSetUniformBuffersDynamic returns the value of maxDescriptorSetUniformBuffersDynamic from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDescriptorSetUniformBuffersDynamic() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxDescriptorSetUniformBuffersDynamic)
	return *ptr
}

// MaxDescriptorSetStorageBuffers returns the value of maxDescriptorSetStorageBuffers from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDescriptorSetStorageBuffers() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxDescriptorSetStorageBuffers)
	return *ptr
}

// MaxDescriptorSetStorageBuffersDynamic returns the value of maxDescriptorSetStorageBuffersDynamic from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDescriptorSetStorageBuffersDynamic() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxDescriptorSetStorageBuffersDynamic)
	return *ptr
}

// MaxDescriptorSetSampledImages returns the value of maxDescriptorSetSampledImages from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDescriptorSetSampledImages() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxDescriptorSetSampledImages)
	return *ptr
}

// MaxDescriptorSetStorageImages returns the value of maxDescriptorSetStorageImages from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDescriptorSetStorageImages() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxDescriptorSetStorageImages)
	return *ptr
}

// MaxDescriptorSetInputAttachments returns the value of maxDescriptorSetInputAttachments from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDescriptorSetInputAttachments() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxDescriptorSetInputAttachments)
	return *ptr
}

// MaxVertexInputAttributes returns the value of maxVertexInputAttributes from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxVertexInputAttributes() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxVertexInputAttributes)
	return *ptr
}

// MaxVertexInputBindings returns the value of maxVertexInputBindings from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxVertexInputBindings() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxVertexInputBindings)
	return *ptr
}

// MaxVertexInputAttributeOffset returns the value of maxVertexInputAttributeOffset from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxVertexInputAttributeOffset() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxVertexInputAttributeOffset)
	return *ptr
}

// MaxVertexInputBindingStride returns the value of maxVertexInputBindingStride from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxVertexInputBindingStride() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxVertexInputBindingStride)
	return *ptr
}

// MaxVertexOutputComponents returns the value of maxVertexOutputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxVertexOutputComponents() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxVertexOutputComponents)
	return *ptr
}

// MaxTessellationGenerationLevel returns the value of maxTessellationGenerationLevel from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTessellationGenerationLevel() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxTessellationGenerationLevel)
	return *ptr
}

// MaxTessellationPatchSize returns the value of maxTessellationPatchSize from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTessellationPatchSize() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxTessellationPatchSize)
	return *ptr
}

// MaxTessellationControlPerVertexInputComponents returns the value of maxTessellationControlPerVertexInputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTessellationControlPerVertexInputComponents() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxTessellationControlPerVertexInputComponents)
	return *ptr
}

// MaxTessellationControlPerVertexOutputComponents returns the value of maxTessellationControlPerVertexOutputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTessellationControlPerVertexOutputComponents() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxTessellationControlPerVertexOutputComponents)
	return *ptr
}

// MaxTessellationControlPerPatchOutputComponents returns the value of maxTessellationControlPerPatchOutputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTessellationControlPerPatchOutputComponents() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxTessellationControlPerPatchOutputComponents)
	return *ptr
}

// MaxTessellationControlTotalOutputComponents returns the value of maxTessellationControlTotalOutputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTessellationControlTotalOutputComponents() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxTessellationControlTotalOutputComponents)
	return *ptr
}

// MaxTessellationEvaluationInputComponents returns the value of maxTessellationEvaluationInputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTessellationEvaluationInputComponents() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxTessellationEvaluationInputComponents)
	return *ptr
}

// MaxTessellationEvaluationOutputComponents returns the value of maxTessellationEvaluationOutputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTessellationEvaluationOutputComponents() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxTessellationEvaluationOutputComponents)
	return *ptr
}

// MaxGeometryShaderInvocations returns the value of maxGeometryShaderInvocations from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxGeometryShaderInvocations() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxGeometryShaderInvocations)
	return *ptr
}

// MaxGeometryInputComponents returns the value of maxGeometryInputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxGeometryInputComponents() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxGeometryInputComponents)
	return *ptr
}

// MaxGeometryOutputComponents returns the value of maxGeometryOutputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxGeometryOutputComponents() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxGeometryOutputComponents)
	return *ptr
}

// MaxGeometryOutputVertices returns the value of maxGeometryOutputVertices from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxGeometryOutputVertices() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxGeometryOutputVertices)
	return *ptr
}

// MaxGeometryTotalOutputComponents returns the value of maxGeometryTotalOutputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxGeometryTotalOutputComponents() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxGeometryTotalOutputComponents)
	return *ptr
}

// MaxFragmentInputComponents returns the value of maxFragmentInputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxFragmentInputComponents() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxFragmentInputComponents)
	return *ptr
}

// MaxFragmentOutputAttachments returns the value of maxFragmentOutputAttachments from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxFragmentOutputAttachments() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxFragmentOutputAttachments)
	return *ptr
}

// MaxFragmentDualSrcAttachments returns the value of maxFragmentDualSrcAttachments from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxFragmentDualSrcAttachments() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxFragmentDualSrcAttachments)
	return *ptr
}

// MaxFragmentCombinedOutputResources returns the value of maxFragmentCombinedOutputResources from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxFragmentCombinedOutputResources() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxFragmentCombinedOutputResources)
	return *ptr
}

// MaxComputeSharedMemorySize returns the value of maxComputeSharedMemorySize from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxComputeSharedMemorySize() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxComputeSharedMemorySize)
	return *ptr
}

// MaxComputeWorkGroupCount returns the value of maxComputeWorkGroupCount from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxComputeWorkGroupCount() []uint32 {
	ptr := func(x *[3]C.uint) *[]uint32 { /* Array */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), 3)
		return &slc
	}(&x.maxComputeWorkGroupCount)
	return *ptr
}

// MaxComputeWorkGroupInvocations returns the value of maxComputeWorkGroupInvocations from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxComputeWorkGroupInvocations() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxComputeWorkGroupInvocations)
	return *ptr
}

// MaxComputeWorkGroupSize returns the value of maxComputeWorkGroupSize from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxComputeWorkGroupSize() []uint32 {
	ptr := func(x *[3]C.uint) *[]uint32 { /* Array */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), 3)
		return &slc
	}(&x.maxComputeWorkGroupSize)
	return *ptr
}

// SubPixelPrecisionBits returns the value of subPixelPrecisionBits from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) SubPixelPrecisionBits() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.subPixelPrecisionBits)
	return *ptr
}

// SubTexelPrecisionBits returns the value of subTexelPrecisionBits from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) SubTexelPrecisionBits() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.subTexelPrecisionBits)
	return *ptr
}

// MipmapPrecisionBits returns the value of mipmapPrecisionBits from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MipmapPrecisionBits() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.mipmapPrecisionBits)
	return *ptr
}

// MaxDrawIndexedIndexValue returns the value of maxDrawIndexedIndexValue from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDrawIndexedIndexValue() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxDrawIndexedIndexValue)
	return *ptr
}

// MaxDrawIndirectCount returns the value of maxDrawIndirectCount from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDrawIndirectCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxDrawIndirectCount)
	return *ptr
}

// MaxSamplerLodBias returns the value of maxSamplerLodBias from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxSamplerLodBias() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ return (*float32)(unsafe.Pointer(x)) }(&x.maxSamplerLodBias)
	return *ptr
}

// MaxSamplerAnisotropy returns the value of maxSamplerAnisotropy from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxSamplerAnisotropy() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ return (*float32)(unsafe.Pointer(x)) }(&x.maxSamplerAnisotropy)
	return *ptr
}

// MaxViewports returns the value of maxViewports from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxViewports() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxViewports)
	return *ptr
}

// MaxViewportDimensions returns the value of maxViewportDimensions from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxViewportDimensions() []uint32 {
	ptr := func(x *[2]C.uint) *[]uint32 { /* Array */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), 2)
		return &slc
	}(&x.maxViewportDimensions)
	return *ptr
}

// ViewportBoundsRange returns the value of viewportBoundsRange from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) ViewportBoundsRange() []float32 {
	ptr := func(x *[2]C.float) *[]float32 { /* Array */
		slc := unsafe.Slice((*float32)(unsafe.Pointer(x)), 2)
		return &slc
	}(&x.viewportBoundsRange)
	return *ptr
}

// ViewportSubPixelBits returns the value of viewportSubPixelBits from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) ViewportSubPixelBits() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.viewportSubPixelBits)
	return *ptr
}

// MinMemoryMapAlignment returns the value of minMemoryMapAlignment from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MinMemoryMapAlignment() uint64 {
	ptr := func(x *C.ulong) *uint64 { /* Scalar */ return (*uint64)(unsafe.Pointer(x)) }(&x.minMemoryMapAlignment)
	return *ptr
}

// MinTexelBufferOffsetAlignment returns the value of minTexelBufferOffsetAlignment from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MinTexelBufferOffsetAlignment() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.minTexelBufferOffsetAlignment)
	return *ptr
}

// MinUniformBufferOffsetAlignment returns the value of minUniformBufferOffsetAlignment from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MinUniformBufferOffsetAlignment() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.minUniformBufferOffsetAlignment)
	return *ptr
}

// MinStorageBufferOffsetAlignment returns the value of minStorageBufferOffsetAlignment from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MinStorageBufferOffsetAlignment() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.minStorageBufferOffsetAlignment)
	return *ptr
}

// MinTexelOffset returns the value of minTexelOffset from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MinTexelOffset() int32 {
	ptr := func(x *C.int) *int32 { /* Scalar */ return (*int32)(unsafe.Pointer(x)) }(&x.minTexelOffset)
	return *ptr
}

// MaxTexelOffset returns the value of maxTexelOffset from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTexelOffset() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxTexelOffset)
	return *ptr
}

// MinTexelGatherOffset returns the value of minTexelGatherOffset from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MinTexelGatherOffset() int32 {
	ptr := func(x *C.int) *int32 { /* Scalar */ return (*int32)(unsafe.Pointer(x)) }(&x.minTexelGatherOffset)
	return *ptr
}

// MaxTexelGatherOffset returns the value of maxTexelGatherOffset from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTexelGatherOffset() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxTexelGatherOffset)
	return *ptr
}

// MinInterpolationOffset returns the value of minInterpolationOffset from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MinInterpolationOffset() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ return (*float32)(unsafe.Pointer(x)) }(&x.minInterpolationOffset)
	return *ptr
}

// MaxInterpolationOffset returns the value of maxInterpolationOffset from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxInterpolationOffset() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ return (*float32)(unsafe.Pointer(x)) }(&x.maxInterpolationOffset)
	return *ptr
}

// SubPixelInterpolationOffsetBits returns the value of subPixelInterpolationOffsetBits from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) SubPixelInterpolationOffsetBits() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.subPixelInterpolationOffsetBits)
	return *ptr
}

// MaxFramebufferWidth returns the value of maxFramebufferWidth from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxFramebufferWidth() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxFramebufferWidth)
	return *ptr
}

// MaxFramebufferHeight returns the value of maxFramebufferHeight from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxFramebufferHeight() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxFramebufferHeight)
	return *ptr
}

// MaxFramebufferLayers returns the value of maxFramebufferLayers from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxFramebufferLayers() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxFramebufferLayers)
	return *ptr
}

// FramebufferColorSampleCounts returns the value of framebufferColorSampleCounts from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) FramebufferColorSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.framebufferColorSampleCounts)
	return *ptr
}

// FramebufferDepthSampleCounts returns the value of framebufferDepthSampleCounts from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) FramebufferDepthSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.framebufferDepthSampleCounts)
	return *ptr
}

// FramebufferStencilSampleCounts returns the value of framebufferStencilSampleCounts from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) FramebufferStencilSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.framebufferStencilSampleCounts)
	return *ptr
}

// FramebufferNoAttachmentsSampleCounts returns the value of framebufferNoAttachmentsSampleCounts from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) FramebufferNoAttachmentsSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.framebufferNoAttachmentsSampleCounts)
	return *ptr
}

// MaxColorAttachments returns the value of maxColorAttachments from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxColorAttachments() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxColorAttachments)
	return *ptr
}

// SampledImageColorSampleCounts returns the value of sampledImageColorSampleCounts from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) SampledImageColorSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.sampledImageColorSampleCounts)
	return *ptr
}

// SampledImageIntegerSampleCounts returns the value of sampledImageIntegerSampleCounts from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) SampledImageIntegerSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.sampledImageIntegerSampleCounts)
	return *ptr
}

// SampledImageDepthSampleCounts returns the value of sampledImageDepthSampleCounts from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) SampledImageDepthSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.sampledImageDepthSampleCounts)
	return *ptr
}

// SampledImageStencilSampleCounts returns the value of sampledImageStencilSampleCounts from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) SampledImageStencilSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.sampledImageStencilSampleCounts)
	return *ptr
}

// StorageImageSampleCounts returns the value of storageImageSampleCounts from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) StorageImageSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.storageImageSampleCounts)
	return *ptr
}

// MaxSampleMaskWords returns the value of maxSampleMaskWords from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxSampleMaskWords() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxSampleMaskWords)
	return *ptr
}

// TimestampComputeAndGraphics returns the value of timestampComputeAndGraphics from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) TimestampComputeAndGraphics() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.timestampComputeAndGraphics)
	return *ptr
}

// TimestampPeriod returns the value of timestampPeriod from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) TimestampPeriod() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ return (*float32)(unsafe.Pointer(x)) }(&x.timestampPeriod)
	return *ptr
}

// MaxClipDistances returns the value of maxClipDistances from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxClipDistances() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxClipDistances)
	return *ptr
}

// MaxCullDistances returns the value of maxCullDistances from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxCullDistances() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxCullDistances)
	return *ptr
}

// MaxCombinedClipAndCullDistances returns the value of maxCombinedClipAndCullDistances from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxCombinedClipAndCullDistances() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxCombinedClipAndCullDistances)
	return *ptr
}

// DiscreteQueuePriorities returns the value of discreteQueuePriorities from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) DiscreteQueuePriorities() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.discreteQueuePriorities)
	return *ptr
}

// PointSizeRange returns the value of pointSizeRange from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) PointSizeRange() []float32 {
	ptr := func(x *[2]C.float) *[]float32 { /* Array */
		slc := unsafe.Slice((*float32)(unsafe.Pointer(x)), 2)
		return &slc
	}(&x.pointSizeRange)
	return *ptr
}

// LineWidthRange returns the value of lineWidthRange from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) LineWidthRange() []float32 {
	ptr := func(x *[2]C.float) *[]float32 { /* Array */
		slc := unsafe.Slice((*float32)(unsafe.Pointer(x)), 2)
		return &slc
	}(&x.lineWidthRange)
	return *ptr
}

// PointSizeGranularity returns the value of pointSizeGranularity from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) PointSizeGranularity() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ return (*float32)(unsafe.Pointer(x)) }(&x.pointSizeGranularity)
	return *ptr
}

// LineWidthGranularity returns the value of lineWidthGranularity from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) LineWidthGranularity() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ return (*float32)(unsafe.Pointer(x)) }(&x.lineWidthGranularity)
	return *ptr
}

// StrictLines returns the value of strictLines from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) StrictLines() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.strictLines)
	return *ptr
}

// StandardSampleLocations returns the value of standardSampleLocations from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) StandardSampleLocations() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.standardSampleLocations)
	return *ptr
}

// OptimalBufferCopyOffsetAlignment returns the value of optimalBufferCopyOffsetAlignment from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) OptimalBufferCopyOffsetAlignment() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.optimalBufferCopyOffsetAlignment)
	return *ptr
}

// OptimalBufferCopyRowPitchAlignment returns the value of optimalBufferCopyRowPitchAlignment from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) OptimalBufferCopyRowPitchAlignment() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.optimalBufferCopyRowPitchAlignment)
	return *ptr
}

// NonCoherentAtomSize returns the value of nonCoherentAtomSize from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) NonCoherentAtomSize() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.nonCoherentAtomSize)
	return *ptr
}

//PhysicalDeviceFeatures provides a go interface for VkPhysicalDeviceFeatures.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html
type PhysicalDeviceFeatures C.struct_VkPhysicalDeviceFeatures

// SizeofPhysicalDeviceFeatures is the memory size of a PhysicalDeviceFeatures
var SizeofPhysicalDeviceFeatures int = int(unsafe.Sizeof(PhysicalDeviceFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceFeatures) AsCPtr() *PhysicalDeviceFeatures {
	clone := (*PhysicalDeviceFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceFeaturesFreeCSlice(x []PhysicalDeviceFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceFeaturesMakeCSlice(x ...PhysicalDeviceFeatures) []PhysicalDeviceFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// RobustBufferAccess returns the value of robustBufferAccess from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) RobustBufferAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.robustBufferAccess)
	return *ptr
}

// WithRobustBufferAccess sets the value for the RobustBufferAccess on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithRobustBufferAccess(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.robustBufferAccess = *ptr
	return x
}

// FullDrawIndexUint32 returns the value of fullDrawIndexUint32 from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) FullDrawIndexUint32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.fullDrawIndexUint32)
	return *ptr
}

// WithFullDrawIndexUint32 sets the value for the FullDrawIndexUint32 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithFullDrawIndexUint32(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.fullDrawIndexUint32 = *ptr
	return x
}

// ImageCubeArray returns the value of imageCubeArray from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ImageCubeArray() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.imageCubeArray)
	return *ptr
}

// WithImageCubeArray sets the value for the ImageCubeArray on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithImageCubeArray(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.imageCubeArray = *ptr
	return x
}

// IndependentBlend returns the value of independentBlend from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) IndependentBlend() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.independentBlend)
	return *ptr
}

// WithIndependentBlend sets the value for the IndependentBlend on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithIndependentBlend(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.independentBlend = *ptr
	return x
}

// GeometryShader returns the value of geometryShader from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) GeometryShader() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.geometryShader)
	return *ptr
}

// WithGeometryShader sets the value for the GeometryShader on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithGeometryShader(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.geometryShader = *ptr
	return x
}

// TessellationShader returns the value of tessellationShader from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) TessellationShader() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.tessellationShader)
	return *ptr
}

// WithTessellationShader sets the value for the TessellationShader on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithTessellationShader(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.tessellationShader = *ptr
	return x
}

// SampleRateShading returns the value of sampleRateShading from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SampleRateShading() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sampleRateShading)
	return *ptr
}

// WithSampleRateShading sets the value for the SampleRateShading on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSampleRateShading(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.sampleRateShading = *ptr
	return x
}

// DualSrcBlend returns the value of dualSrcBlend from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) DualSrcBlend() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.dualSrcBlend)
	return *ptr
}

// WithDualSrcBlend sets the value for the DualSrcBlend on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithDualSrcBlend(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.dualSrcBlend = *ptr
	return x
}

// LogicOp returns the value of logicOp from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) LogicOp() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.logicOp)
	return *ptr
}

// WithLogicOp sets the value for the LogicOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithLogicOp(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.logicOp = *ptr
	return x
}

// MultiDrawIndirect returns the value of multiDrawIndirect from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) MultiDrawIndirect() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.multiDrawIndirect)
	return *ptr
}

// WithMultiDrawIndirect sets the value for the MultiDrawIndirect on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithMultiDrawIndirect(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.multiDrawIndirect = *ptr
	return x
}

// DrawIndirectFirstInstance returns the value of drawIndirectFirstInstance from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) DrawIndirectFirstInstance() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.drawIndirectFirstInstance)
	return *ptr
}

// WithDrawIndirectFirstInstance sets the value for the DrawIndirectFirstInstance on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithDrawIndirectFirstInstance(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.drawIndirectFirstInstance = *ptr
	return x
}

// DepthClamp returns the value of depthClamp from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) DepthClamp() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.depthClamp)
	return *ptr
}

// WithDepthClamp sets the value for the DepthClamp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithDepthClamp(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.depthClamp = *ptr
	return x
}

// DepthBiasClamp returns the value of depthBiasClamp from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) DepthBiasClamp() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.depthBiasClamp)
	return *ptr
}

// WithDepthBiasClamp sets the value for the DepthBiasClamp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithDepthBiasClamp(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.depthBiasClamp = *ptr
	return x
}

// FillModeNonSolid returns the value of fillModeNonSolid from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) FillModeNonSolid() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.fillModeNonSolid)
	return *ptr
}

// WithFillModeNonSolid sets the value for the FillModeNonSolid on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithFillModeNonSolid(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.fillModeNonSolid = *ptr
	return x
}

// DepthBounds returns the value of depthBounds from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) DepthBounds() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.depthBounds)
	return *ptr
}

// WithDepthBounds sets the value for the DepthBounds on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithDepthBounds(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.depthBounds = *ptr
	return x
}

// WideLines returns the value of wideLines from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) WideLines() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.wideLines)
	return *ptr
}

// WithWideLines sets the value for the WideLines on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithWideLines(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.wideLines = *ptr
	return x
}

// LargePoints returns the value of largePoints from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) LargePoints() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.largePoints)
	return *ptr
}

// WithLargePoints sets the value for the LargePoints on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithLargePoints(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.largePoints = *ptr
	return x
}

// AlphaToOne returns the value of alphaToOne from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) AlphaToOne() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.alphaToOne)
	return *ptr
}

// WithAlphaToOne sets the value for the AlphaToOne on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithAlphaToOne(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.alphaToOne = *ptr
	return x
}

// MultiViewport returns the value of multiViewport from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) MultiViewport() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.multiViewport)
	return *ptr
}

// WithMultiViewport sets the value for the MultiViewport on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithMultiViewport(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.multiViewport = *ptr
	return x
}

// SamplerAnisotropy returns the value of samplerAnisotropy from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SamplerAnisotropy() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.samplerAnisotropy)
	return *ptr
}

// WithSamplerAnisotropy sets the value for the SamplerAnisotropy on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSamplerAnisotropy(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.samplerAnisotropy = *ptr
	return x
}

// TextureCompressionETC2 returns the value of textureCompressionETC2 from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) TextureCompressionETC2() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.textureCompressionETC2)
	return *ptr
}

// WithTextureCompressionETC2 sets the value for the TextureCompressionETC2 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithTextureCompressionETC2(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.textureCompressionETC2 = *ptr
	return x
}

// TextureCompressionASTC_LDR returns the value of textureCompressionASTC_LDR from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) TextureCompressionASTC_LDR() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.textureCompressionASTC_LDR)
	return *ptr
}

// WithTextureCompressionASTC_LDR sets the value for the TextureCompressionASTC_LDR on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithTextureCompressionASTC_LDR(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.textureCompressionASTC_LDR = *ptr
	return x
}

// TextureCompressionBC returns the value of textureCompressionBC from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) TextureCompressionBC() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.textureCompressionBC)
	return *ptr
}

// WithTextureCompressionBC sets the value for the TextureCompressionBC on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithTextureCompressionBC(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.textureCompressionBC = *ptr
	return x
}

// OcclusionQueryPrecise returns the value of occlusionQueryPrecise from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) OcclusionQueryPrecise() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.occlusionQueryPrecise)
	return *ptr
}

// WithOcclusionQueryPrecise sets the value for the OcclusionQueryPrecise on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithOcclusionQueryPrecise(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.occlusionQueryPrecise = *ptr
	return x
}

// PipelineStatisticsQuery returns the value of pipelineStatisticsQuery from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) PipelineStatisticsQuery() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.pipelineStatisticsQuery)
	return *ptr
}

// WithPipelineStatisticsQuery sets the value for the PipelineStatisticsQuery on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithPipelineStatisticsQuery(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.pipelineStatisticsQuery = *ptr
	return x
}

// VertexPipelineStoresAndAtomics returns the value of vertexPipelineStoresAndAtomics from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) VertexPipelineStoresAndAtomics() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.vertexPipelineStoresAndAtomics)
	return *ptr
}

// WithVertexPipelineStoresAndAtomics sets the value for the VertexPipelineStoresAndAtomics on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithVertexPipelineStoresAndAtomics(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.vertexPipelineStoresAndAtomics = *ptr
	return x
}

// FragmentStoresAndAtomics returns the value of fragmentStoresAndAtomics from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) FragmentStoresAndAtomics() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.fragmentStoresAndAtomics)
	return *ptr
}

// WithFragmentStoresAndAtomics sets the value for the FragmentStoresAndAtomics on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithFragmentStoresAndAtomics(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.fragmentStoresAndAtomics = *ptr
	return x
}

// ShaderTessellationAndGeometryPointSize returns the value of shaderTessellationAndGeometryPointSize from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderTessellationAndGeometryPointSize() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderTessellationAndGeometryPointSize)
	return *ptr
}

// WithShaderTessellationAndGeometryPointSize sets the value for the ShaderTessellationAndGeometryPointSize on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderTessellationAndGeometryPointSize(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderTessellationAndGeometryPointSize = *ptr
	return x
}

// ShaderImageGatherExtended returns the value of shaderImageGatherExtended from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderImageGatherExtended() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderImageGatherExtended)
	return *ptr
}

// WithShaderImageGatherExtended sets the value for the ShaderImageGatherExtended on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderImageGatherExtended(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderImageGatherExtended = *ptr
	return x
}

// ShaderStorageImageExtendedFormats returns the value of shaderStorageImageExtendedFormats from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderStorageImageExtendedFormats() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageImageExtendedFormats)
	return *ptr
}

// WithShaderStorageImageExtendedFormats sets the value for the ShaderStorageImageExtendedFormats on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderStorageImageExtendedFormats(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderStorageImageExtendedFormats = *ptr
	return x
}

// ShaderStorageImageMultisample returns the value of shaderStorageImageMultisample from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderStorageImageMultisample() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageImageMultisample)
	return *ptr
}

// WithShaderStorageImageMultisample sets the value for the ShaderStorageImageMultisample on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderStorageImageMultisample(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderStorageImageMultisample = *ptr
	return x
}

// ShaderStorageImageReadWithoutFormat returns the value of shaderStorageImageReadWithoutFormat from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderStorageImageReadWithoutFormat() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageImageReadWithoutFormat)
	return *ptr
}

// WithShaderStorageImageReadWithoutFormat sets the value for the ShaderStorageImageReadWithoutFormat on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderStorageImageReadWithoutFormat(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderStorageImageReadWithoutFormat = *ptr
	return x
}

// ShaderStorageImageWriteWithoutFormat returns the value of shaderStorageImageWriteWithoutFormat from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderStorageImageWriteWithoutFormat() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageImageWriteWithoutFormat)
	return *ptr
}

// WithShaderStorageImageWriteWithoutFormat sets the value for the ShaderStorageImageWriteWithoutFormat on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderStorageImageWriteWithoutFormat(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderStorageImageWriteWithoutFormat = *ptr
	return x
}

// ShaderUniformBufferArrayDynamicIndexing returns the value of shaderUniformBufferArrayDynamicIndexing from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderUniformBufferArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderUniformBufferArrayDynamicIndexing)
	return *ptr
}

// WithShaderUniformBufferArrayDynamicIndexing sets the value for the ShaderUniformBufferArrayDynamicIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderUniformBufferArrayDynamicIndexing(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderUniformBufferArrayDynamicIndexing = *ptr
	return x
}

// ShaderSampledImageArrayDynamicIndexing returns the value of shaderSampledImageArrayDynamicIndexing from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderSampledImageArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSampledImageArrayDynamicIndexing)
	return *ptr
}

// WithShaderSampledImageArrayDynamicIndexing sets the value for the ShaderSampledImageArrayDynamicIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderSampledImageArrayDynamicIndexing(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderSampledImageArrayDynamicIndexing = *ptr
	return x
}

// ShaderStorageBufferArrayDynamicIndexing returns the value of shaderStorageBufferArrayDynamicIndexing from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderStorageBufferArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageBufferArrayDynamicIndexing)
	return *ptr
}

// WithShaderStorageBufferArrayDynamicIndexing sets the value for the ShaderStorageBufferArrayDynamicIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderStorageBufferArrayDynamicIndexing(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderStorageBufferArrayDynamicIndexing = *ptr
	return x
}

// ShaderStorageImageArrayDynamicIndexing returns the value of shaderStorageImageArrayDynamicIndexing from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderStorageImageArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageImageArrayDynamicIndexing)
	return *ptr
}

// WithShaderStorageImageArrayDynamicIndexing sets the value for the ShaderStorageImageArrayDynamicIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderStorageImageArrayDynamicIndexing(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderStorageImageArrayDynamicIndexing = *ptr
	return x
}

// ShaderClipDistance returns the value of shaderClipDistance from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderClipDistance() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderClipDistance)
	return *ptr
}

// WithShaderClipDistance sets the value for the ShaderClipDistance on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderClipDistance(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderClipDistance = *ptr
	return x
}

// ShaderCullDistance returns the value of shaderCullDistance from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderCullDistance() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderCullDistance)
	return *ptr
}

// WithShaderCullDistance sets the value for the ShaderCullDistance on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderCullDistance(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderCullDistance = *ptr
	return x
}

// ShaderFloat64 returns the value of shaderFloat64 from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderFloat64)
	return *ptr
}

// WithShaderFloat64 sets the value for the ShaderFloat64 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderFloat64(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderFloat64 = *ptr
	return x
}

// ShaderInt64 returns the value of shaderInt64 from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderInt64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInt64)
	return *ptr
}

// WithShaderInt64 sets the value for the ShaderInt64 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderInt64(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderInt64 = *ptr
	return x
}

// ShaderInt16 returns the value of shaderInt16 from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderInt16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInt16)
	return *ptr
}

// WithShaderInt16 sets the value for the ShaderInt16 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderInt16(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderInt16 = *ptr
	return x
}

// ShaderResourceResidency returns the value of shaderResourceResidency from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderResourceResidency() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderResourceResidency)
	return *ptr
}

// WithShaderResourceResidency sets the value for the ShaderResourceResidency on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderResourceResidency(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderResourceResidency = *ptr
	return x
}

// ShaderResourceMinLod returns the value of shaderResourceMinLod from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderResourceMinLod() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderResourceMinLod)
	return *ptr
}

// WithShaderResourceMinLod sets the value for the ShaderResourceMinLod on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderResourceMinLod(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderResourceMinLod = *ptr
	return x
}

// SparseBinding returns the value of sparseBinding from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SparseBinding() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sparseBinding)
	return *ptr
}

// WithSparseBinding sets the value for the SparseBinding on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSparseBinding(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.sparseBinding = *ptr
	return x
}

// SparseResidencyBuffer returns the value of sparseResidencyBuffer from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SparseResidencyBuffer() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sparseResidencyBuffer)
	return *ptr
}

// WithSparseResidencyBuffer sets the value for the SparseResidencyBuffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSparseResidencyBuffer(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.sparseResidencyBuffer = *ptr
	return x
}

// SparseResidencyImage2D returns the value of sparseResidencyImage2D from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SparseResidencyImage2D() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sparseResidencyImage2D)
	return *ptr
}

// WithSparseResidencyImage2D sets the value for the SparseResidencyImage2D on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSparseResidencyImage2D(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.sparseResidencyImage2D = *ptr
	return x
}

// SparseResidencyImage3D returns the value of sparseResidencyImage3D from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SparseResidencyImage3D() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sparseResidencyImage3D)
	return *ptr
}

// WithSparseResidencyImage3D sets the value for the SparseResidencyImage3D on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSparseResidencyImage3D(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.sparseResidencyImage3D = *ptr
	return x
}

// SparseResidency2Samples returns the value of sparseResidency2Samples from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SparseResidency2Samples() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sparseResidency2Samples)
	return *ptr
}

// WithSparseResidency2Samples sets the value for the SparseResidency2Samples on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSparseResidency2Samples(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.sparseResidency2Samples = *ptr
	return x
}

// SparseResidency4Samples returns the value of sparseResidency4Samples from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SparseResidency4Samples() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sparseResidency4Samples)
	return *ptr
}

// WithSparseResidency4Samples sets the value for the SparseResidency4Samples on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSparseResidency4Samples(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.sparseResidency4Samples = *ptr
	return x
}

// SparseResidency8Samples returns the value of sparseResidency8Samples from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SparseResidency8Samples() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sparseResidency8Samples)
	return *ptr
}

// WithSparseResidency8Samples sets the value for the SparseResidency8Samples on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSparseResidency8Samples(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.sparseResidency8Samples = *ptr
	return x
}

// SparseResidency16Samples returns the value of sparseResidency16Samples from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SparseResidency16Samples() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sparseResidency16Samples)
	return *ptr
}

// WithSparseResidency16Samples sets the value for the SparseResidency16Samples on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSparseResidency16Samples(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.sparseResidency16Samples = *ptr
	return x
}

// SparseResidencyAliased returns the value of sparseResidencyAliased from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SparseResidencyAliased() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sparseResidencyAliased)
	return *ptr
}

// WithSparseResidencyAliased sets the value for the SparseResidencyAliased on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSparseResidencyAliased(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.sparseResidencyAliased = *ptr
	return x
}

// VariableMultisampleRate returns the value of variableMultisampleRate from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) VariableMultisampleRate() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.variableMultisampleRate)
	return *ptr
}

// WithVariableMultisampleRate sets the value for the VariableMultisampleRate on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithVariableMultisampleRate(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.variableMultisampleRate = *ptr
	return x
}

// InheritedQueries returns the value of inheritedQueries from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) InheritedQueries() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.inheritedQueries)
	return *ptr
}

// WithInheritedQueries sets the value for the InheritedQueries on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithInheritedQueries(y Bool32) PhysicalDeviceFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.inheritedQueries = *ptr
	return x
}

//MemoryType provides a go interface for VkMemoryType.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkMemoryType.html
type MemoryType C.struct_VkMemoryType

// SizeofMemoryType is the memory size of a MemoryType
var SizeofMemoryType int = int(unsafe.Sizeof(MemoryType{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryType) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryType) AsCPtr() *MemoryType {
	clone := (*MemoryType)(newCBlock(C.ulong(SizeofMemoryType)))
	*clone = x
	return clone
}

// MemoryTypeFreeCSlice releases the memory allocated by MemoryTypeMakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryTypeFreeCSlice(x []MemoryType) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryTypeMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryTypeFreeCSlice must be called on the returned slice.
func MemoryTypeMakeCSlice(x ...MemoryType) []MemoryType {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryType * len(x)
	dst := unsafe.Slice((*MemoryType)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// PropertyFlags returns the value of propertyFlags from VkMemoryType
func (x MemoryType) PropertyFlags() MemoryPropertyFlags {
	ptr := /* typedef */ (*MemoryPropertyFlags)(&x.propertyFlags)
	return *ptr
}

// HeapIndex returns the value of heapIndex from VkMemoryType
func (x MemoryType) HeapIndex() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.heapIndex)
	return *ptr
}

//MemoryHeap provides a go interface for VkMemoryHeap.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkMemoryHeap.html
type MemoryHeap C.struct_VkMemoryHeap

// SizeofMemoryHeap is the memory size of a MemoryHeap
var SizeofMemoryHeap int = int(unsafe.Sizeof(MemoryHeap{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryHeap) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryHeap) AsCPtr() *MemoryHeap {
	clone := (*MemoryHeap)(newCBlock(C.ulong(SizeofMemoryHeap)))
	*clone = x
	return clone
}

// MemoryHeapFreeCSlice releases the memory allocated by MemoryHeapMakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryHeapFreeCSlice(x []MemoryHeap) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryHeapMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryHeapFreeCSlice must be called on the returned slice.
func MemoryHeapMakeCSlice(x ...MemoryHeap) []MemoryHeap {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryHeap * len(x)
	dst := unsafe.Slice((*MemoryHeap)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Size returns the value of size from VkMemoryHeap
func (x MemoryHeap) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size)
	return *ptr
}

// Flags returns the value of flags from VkMemoryHeap
func (x MemoryHeap) Flags() MemoryHeapFlags {
	ptr := /* typedef */ (*MemoryHeapFlags)(&x.flags)
	return *ptr
}

//ComputePipelineCreateInfo provides a go interface for VkComputePipelineCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkComputePipelineCreateInfo.html
type ComputePipelineCreateInfo C.struct_VkComputePipelineCreateInfo

// SizeofComputePipelineCreateInfo is the memory size of a ComputePipelineCreateInfo
var SizeofComputePipelineCreateInfo int = int(unsafe.Sizeof(ComputePipelineCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ComputePipelineCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ComputePipelineCreateInfo) AsCPtr() *ComputePipelineCreateInfo {
	clone := (*ComputePipelineCreateInfo)(newCBlock(C.ulong(SizeofComputePipelineCreateInfo)))
	*clone = x
	return clone
}

// ComputePipelineCreateInfoFreeCSlice releases the memory allocated by ComputePipelineCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ComputePipelineCreateInfoFreeCSlice(x []ComputePipelineCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ComputePipelineCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ComputePipelineCreateInfoFreeCSlice must be called on the returned slice.
func ComputePipelineCreateInfoMakeCSlice(x ...ComputePipelineCreateInfo) []ComputePipelineCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofComputePipelineCreateInfo * len(x)
	dst := unsafe.Slice((*ComputePipelineCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkComputePipelineCreateInfo
func (x ComputePipelineCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ComputePipelineCreateInfo) WithDefaultSType() ComputePipelineCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComputePipelineCreateInfo) WithSType(y StructureType) ComputePipelineCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkComputePipelineCreateInfo
func (x ComputePipelineCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComputePipelineCreateInfo) WithPNext(y unsafe.Pointer) ComputePipelineCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkComputePipelineCreateInfo
func (x ComputePipelineCreateInfo) Flags() PipelineCreateFlags {
	ptr := /* typedef */ (*PipelineCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComputePipelineCreateInfo) WithFlags(y PipelineCreateFlags) ComputePipelineCreateInfo {
	ptr := /* typedef */ (*C.VkPipelineCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// Stage returns the value of stage from VkComputePipelineCreateInfo
func (x ComputePipelineCreateInfo) Stage() PipelineShaderStageCreateInfo {
	ptr := /* typedef */ (*PipelineShaderStageCreateInfo)(&x.stage)
	return *ptr
}

// WithStage sets the value for the Stage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComputePipelineCreateInfo) WithStage(y PipelineShaderStageCreateInfo) ComputePipelineCreateInfo {
	ptr := /* typedef */ (*C.struct_VkPipelineShaderStageCreateInfo)(&y)
	x.stage = *ptr
	return x
}

// Layout returns the value of layout from VkComputePipelineCreateInfo
func (x ComputePipelineCreateInfo) Layout() PipelineLayout {
	ptr := /* handle */ (*PipelineLayout)(&x.layout)
	return *ptr
}

// WithLayout sets the value for the Layout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComputePipelineCreateInfo) WithLayout(y PipelineLayout) ComputePipelineCreateInfo {
	ptr := /* handle */ (*C.VkPipelineLayout)(&y)
	x.layout = *ptr
	return x
}

// BasePipelineHandle returns the value of basePipelineHandle from VkComputePipelineCreateInfo
func (x ComputePipelineCreateInfo) BasePipelineHandle() Pipeline {
	ptr := /* handle */ (*Pipeline)(&x.basePipelineHandle)
	return *ptr
}

// WithBasePipelineHandle sets the value for the BasePipelineHandle on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComputePipelineCreateInfo) WithBasePipelineHandle(y Pipeline) ComputePipelineCreateInfo {
	ptr := /* handle */ (*C.VkPipeline)(&y)
	x.basePipelineHandle = *ptr
	return x
}

// BasePipelineIndex returns the value of basePipelineIndex from VkComputePipelineCreateInfo
func (x ComputePipelineCreateInfo) BasePipelineIndex() int32 {
	ptr := func(x *C.int) *int32 { /* Scalar */ return (*int32)(unsafe.Pointer(x)) }(&x.basePipelineIndex)
	return *ptr
}

// WithBasePipelineIndex sets the value for the BasePipelineIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComputePipelineCreateInfo) WithBasePipelineIndex(y int32) ComputePipelineCreateInfo {
	ptr := func(x *int32) *C.int { /* Scalar */ return (*C.int)(unsafe.Pointer(x)) }(&y)
	x.basePipelineIndex = *ptr
	return x
}

//InstanceCreateInfo provides a go interface for VkInstanceCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkInstanceCreateInfo.html
type InstanceCreateInfo C.struct_VkInstanceCreateInfo

// SizeofInstanceCreateInfo is the memory size of a InstanceCreateInfo
var SizeofInstanceCreateInfo int = int(unsafe.Sizeof(InstanceCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *InstanceCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x InstanceCreateInfo) AsCPtr() *InstanceCreateInfo {
	clone := (*InstanceCreateInfo)(newCBlock(C.ulong(SizeofInstanceCreateInfo)))
	*clone = x
	return clone
}

// InstanceCreateInfoFreeCSlice releases the memory allocated by InstanceCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func InstanceCreateInfoFreeCSlice(x []InstanceCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// InstanceCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. InstanceCreateInfoFreeCSlice must be called on the returned slice.
func InstanceCreateInfoMakeCSlice(x ...InstanceCreateInfo) []InstanceCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofInstanceCreateInfo * len(x)
	dst := unsafe.Slice((*InstanceCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkInstanceCreateInfo
func (x InstanceCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x InstanceCreateInfo) WithDefaultSType() InstanceCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InstanceCreateInfo) WithSType(y StructureType) InstanceCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkInstanceCreateInfo
func (x InstanceCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InstanceCreateInfo) WithPNext(y unsafe.Pointer) InstanceCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkInstanceCreateInfo
func (x InstanceCreateInfo) Flags() InstanceCreateFlags {
	ptr := /* typedef */ (*InstanceCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InstanceCreateInfo) WithFlags(y InstanceCreateFlags) InstanceCreateInfo {
	ptr := /* typedef */ (*C.VkInstanceCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// PApplicationInfo returns the value of pApplicationInfo from VkInstanceCreateInfo
func (x InstanceCreateInfo) PApplicationInfo() *ApplicationInfo {
	ptr := func(x **C.struct_VkApplicationInfo) **ApplicationInfo { /* Pointer */
		return (**ApplicationInfo)(unsafe.Pointer(x))
	}(&x.pApplicationInfo)
	return *ptr
}

// WithPApplicationInfo sets the value for the PApplicationInfo on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InstanceCreateInfo) WithPApplicationInfo(y *ApplicationInfo) InstanceCreateInfo {
	ptr := func(x **ApplicationInfo) **C.struct_VkApplicationInfo { /* Pointer */
		return (**C.struct_VkApplicationInfo)(unsafe.Pointer(x))
	}(&y)
	x.pApplicationInfo = *ptr
	return x
}

// EnabledLayerCount returns the value of enabledLayerCount from VkInstanceCreateInfo
func (x InstanceCreateInfo) EnabledLayerCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.enabledLayerCount)
	return *ptr
}

// WithEnabledLayerCount sets the value for the EnabledLayerCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InstanceCreateInfo) WithEnabledLayerCount(y uint32) InstanceCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.enabledLayerCount = *ptr
	return x
}

// PpEnabledLayerNames returns the value of ppEnabledLayerNames from VkInstanceCreateInfo
func (x InstanceCreateInfo) PpEnabledLayerNames() []*byte {
	ptr := func(x ***C.char) *[]*byte { /* Slice */
		slc := unsafe.Slice((**byte)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.ppEnabledLayerNames)
	return *ptr
}

// WithPpEnabledLayerNames sets the value for the PpEnabledLayerNames on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InstanceCreateInfo) WithPpEnabledLayerNames(y []*byte) InstanceCreateInfo {
	ptr := func(x *[]*byte) ***C.char { /* Slice */
		if len(*x) > 0 {
			slc := (**C.char)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (***C.char)(unsafe.Pointer((&ptr)))
	}(&y)
	x.ppEnabledLayerNames = *ptr
	return x
}

// EnabledExtensionCount returns the value of enabledExtensionCount from VkInstanceCreateInfo
func (x InstanceCreateInfo) EnabledExtensionCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.enabledExtensionCount)
	return *ptr
}

// WithEnabledExtensionCount sets the value for the EnabledExtensionCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InstanceCreateInfo) WithEnabledExtensionCount(y uint32) InstanceCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.enabledExtensionCount = *ptr
	return x
}

// PpEnabledExtensionNames returns the value of ppEnabledExtensionNames from VkInstanceCreateInfo
func (x InstanceCreateInfo) PpEnabledExtensionNames() []*byte {
	ptr := func(x ***C.char) *[]*byte { /* Slice */
		slc := unsafe.Slice((**byte)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.ppEnabledExtensionNames)
	return *ptr
}

// WithPpEnabledExtensionNames sets the value for the PpEnabledExtensionNames on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InstanceCreateInfo) WithPpEnabledExtensionNames(y []*byte) InstanceCreateInfo {
	ptr := func(x *[]*byte) ***C.char { /* Slice */
		if len(*x) > 0 {
			slc := (**C.char)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (***C.char)(unsafe.Pointer((&ptr)))
	}(&y)
	x.ppEnabledExtensionNames = *ptr
	return x
}

//CopyDescriptorSet provides a go interface for VkCopyDescriptorSet.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCopyDescriptorSet.html
type CopyDescriptorSet C.struct_VkCopyDescriptorSet

// SizeofCopyDescriptorSet is the memory size of a CopyDescriptorSet
var SizeofCopyDescriptorSet int = int(unsafe.Sizeof(CopyDescriptorSet{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *CopyDescriptorSet) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x CopyDescriptorSet) AsCPtr() *CopyDescriptorSet {
	clone := (*CopyDescriptorSet)(newCBlock(C.ulong(SizeofCopyDescriptorSet)))
	*clone = x
	return clone
}

// CopyDescriptorSetFreeCSlice releases the memory allocated by CopyDescriptorSetMakeCSlice.
// It does not free pointers stored inside the slice.
func CopyDescriptorSetFreeCSlice(x []CopyDescriptorSet) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// CopyDescriptorSetMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. CopyDescriptorSetFreeCSlice must be called on the returned slice.
func CopyDescriptorSetMakeCSlice(x ...CopyDescriptorSet) []CopyDescriptorSet {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCopyDescriptorSet * len(x)
	dst := unsafe.Slice((*CopyDescriptorSet)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkCopyDescriptorSet
func (x CopyDescriptorSet) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x CopyDescriptorSet) WithDefaultSType() CopyDescriptorSet {
	return x.WithSType(VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyDescriptorSet) WithSType(y StructureType) CopyDescriptorSet {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkCopyDescriptorSet
func (x CopyDescriptorSet) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyDescriptorSet) WithPNext(y unsafe.Pointer) CopyDescriptorSet {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// SrcSet returns the value of srcSet from VkCopyDescriptorSet
func (x CopyDescriptorSet) SrcSet() DescriptorSet {
	ptr := /* handle */ (*DescriptorSet)(&x.srcSet)
	return *ptr
}

// WithSrcSet sets the value for the SrcSet on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyDescriptorSet) WithSrcSet(y DescriptorSet) CopyDescriptorSet {
	ptr := /* handle */ (*C.VkDescriptorSet)(&y)
	x.srcSet = *ptr
	return x
}

// SrcBinding returns the value of srcBinding from VkCopyDescriptorSet
func (x CopyDescriptorSet) SrcBinding() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.srcBinding)
	return *ptr
}

// WithSrcBinding sets the value for the SrcBinding on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyDescriptorSet) WithSrcBinding(y uint32) CopyDescriptorSet {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.srcBinding = *ptr
	return x
}

// SrcArrayElement returns the value of srcArrayElement from VkCopyDescriptorSet
func (x CopyDescriptorSet) SrcArrayElement() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.srcArrayElement)
	return *ptr
}

// WithSrcArrayElement sets the value for the SrcArrayElement on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyDescriptorSet) WithSrcArrayElement(y uint32) CopyDescriptorSet {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.srcArrayElement = *ptr
	return x
}

// DstSet returns the value of dstSet from VkCopyDescriptorSet
func (x CopyDescriptorSet) DstSet() DescriptorSet {
	ptr := /* handle */ (*DescriptorSet)(&x.dstSet)
	return *ptr
}

// WithDstSet sets the value for the DstSet on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyDescriptorSet) WithDstSet(y DescriptorSet) CopyDescriptorSet {
	ptr := /* handle */ (*C.VkDescriptorSet)(&y)
	x.dstSet = *ptr
	return x
}

// DstBinding returns the value of dstBinding from VkCopyDescriptorSet
func (x CopyDescriptorSet) DstBinding() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.dstBinding)
	return *ptr
}

// WithDstBinding sets the value for the DstBinding on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyDescriptorSet) WithDstBinding(y uint32) CopyDescriptorSet {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.dstBinding = *ptr
	return x
}

// DstArrayElement returns the value of dstArrayElement from VkCopyDescriptorSet
func (x CopyDescriptorSet) DstArrayElement() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.dstArrayElement)
	return *ptr
}

// WithDstArrayElement sets the value for the DstArrayElement on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyDescriptorSet) WithDstArrayElement(y uint32) CopyDescriptorSet {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.dstArrayElement = *ptr
	return x
}

// DescriptorCount returns the value of descriptorCount from VkCopyDescriptorSet
func (x CopyDescriptorSet) DescriptorCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.descriptorCount)
	return *ptr
}

// WithDescriptorCount sets the value for the DescriptorCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyDescriptorSet) WithDescriptorCount(y uint32) CopyDescriptorSet {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.descriptorCount = *ptr
	return x
}

//ImageFormatProperties provides a go interface for VkImageFormatProperties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageFormatProperties.html
type ImageFormatProperties C.struct_VkImageFormatProperties

// SizeofImageFormatProperties is the memory size of a ImageFormatProperties
var SizeofImageFormatProperties int = int(unsafe.Sizeof(ImageFormatProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageFormatProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageFormatProperties) AsCPtr() *ImageFormatProperties {
	clone := (*ImageFormatProperties)(newCBlock(C.ulong(SizeofImageFormatProperties)))
	*clone = x
	return clone
}

// ImageFormatPropertiesFreeCSlice releases the memory allocated by ImageFormatPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageFormatPropertiesFreeCSlice(x []ImageFormatProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageFormatPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageFormatPropertiesFreeCSlice must be called on the returned slice.
func ImageFormatPropertiesMakeCSlice(x ...ImageFormatProperties) []ImageFormatProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageFormatProperties * len(x)
	dst := unsafe.Slice((*ImageFormatProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// MaxExtent returns the value of maxExtent from VkImageFormatProperties
func (x ImageFormatProperties) MaxExtent() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.maxExtent)
	return *ptr
}

// MaxMipLevels returns the value of maxMipLevels from VkImageFormatProperties
func (x ImageFormatProperties) MaxMipLevels() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxMipLevels)
	return *ptr
}

// MaxArrayLayers returns the value of maxArrayLayers from VkImageFormatProperties
func (x ImageFormatProperties) MaxArrayLayers() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxArrayLayers)
	return *ptr
}

// SampleCounts returns the value of sampleCounts from VkImageFormatProperties
func (x ImageFormatProperties) SampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.sampleCounts)
	return *ptr
}

// MaxResourceSize returns the value of maxResourceSize from VkImageFormatProperties
func (x ImageFormatProperties) MaxResourceSize() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.maxResourceSize)
	return *ptr
}

//FormatProperties provides a go interface for VkFormatProperties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFormatProperties.html
type FormatProperties C.struct_VkFormatProperties

// SizeofFormatProperties is the memory size of a FormatProperties
var SizeofFormatProperties int = int(unsafe.Sizeof(FormatProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *FormatProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x FormatProperties) AsCPtr() *FormatProperties {
	clone := (*FormatProperties)(newCBlock(C.ulong(SizeofFormatProperties)))
	*clone = x
	return clone
}

// FormatPropertiesFreeCSlice releases the memory allocated by FormatPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func FormatPropertiesFreeCSlice(x []FormatProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// FormatPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. FormatPropertiesFreeCSlice must be called on the returned slice.
func FormatPropertiesMakeCSlice(x ...FormatProperties) []FormatProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFormatProperties * len(x)
	dst := unsafe.Slice((*FormatProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// LinearTilingFeatures returns the value of linearTilingFeatures from VkFormatProperties
func (x FormatProperties) LinearTilingFeatures() FormatFeatureFlags {
	ptr := /* typedef */ (*FormatFeatureFlags)(&x.linearTilingFeatures)
	return *ptr
}

// OptimalTilingFeatures returns the value of optimalTilingFeatures from VkFormatProperties
func (x FormatProperties) OptimalTilingFeatures() FormatFeatureFlags {
	ptr := /* typedef */ (*FormatFeatureFlags)(&x.optimalTilingFeatures)
	return *ptr
}

// BufferFeatures returns the value of bufferFeatures from VkFormatProperties
func (x FormatProperties) BufferFeatures() FormatFeatureFlags {
	ptr := /* typedef */ (*FormatFeatureFlags)(&x.bufferFeatures)
	return *ptr
}

//GraphicsPipelineCreateInfo provides a go interface for VkGraphicsPipelineCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkGraphicsPipelineCreateInfo.html
type GraphicsPipelineCreateInfo C.struct_VkGraphicsPipelineCreateInfo

// SizeofGraphicsPipelineCreateInfo is the memory size of a GraphicsPipelineCreateInfo
var SizeofGraphicsPipelineCreateInfo int = int(unsafe.Sizeof(GraphicsPipelineCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *GraphicsPipelineCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x GraphicsPipelineCreateInfo) AsCPtr() *GraphicsPipelineCreateInfo {
	clone := (*GraphicsPipelineCreateInfo)(newCBlock(C.ulong(SizeofGraphicsPipelineCreateInfo)))
	*clone = x
	return clone
}

// GraphicsPipelineCreateInfoFreeCSlice releases the memory allocated by GraphicsPipelineCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func GraphicsPipelineCreateInfoFreeCSlice(x []GraphicsPipelineCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// GraphicsPipelineCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. GraphicsPipelineCreateInfoFreeCSlice must be called on the returned slice.
func GraphicsPipelineCreateInfoMakeCSlice(x ...GraphicsPipelineCreateInfo) []GraphicsPipelineCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofGraphicsPipelineCreateInfo * len(x)
	dst := unsafe.Slice((*GraphicsPipelineCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x GraphicsPipelineCreateInfo) WithDefaultSType() GraphicsPipelineCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithSType(y StructureType) GraphicsPipelineCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPNext(y unsafe.Pointer) GraphicsPipelineCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) Flags() PipelineCreateFlags {
	ptr := /* typedef */ (*PipelineCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithFlags(y PipelineCreateFlags) GraphicsPipelineCreateInfo {
	ptr := /* typedef */ (*C.VkPipelineCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// StageCount returns the value of stageCount from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) StageCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.stageCount)
	return *ptr
}

// WithStageCount sets the value for the StageCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithStageCount(y uint32) GraphicsPipelineCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.stageCount = *ptr
	return x
}

// PStages returns the value of pStages from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PStages() []PipelineShaderStageCreateInfo {
	ptr := func(x **C.struct_VkPipelineShaderStageCreateInfo) *[]PipelineShaderStageCreateInfo { /* Slice */
		slc := unsafe.Slice((*PipelineShaderStageCreateInfo)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pStages)
	return *ptr
}

// WithPStages sets the value for the PStages on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines StageCount as the length of this field.
// StageCount is updated with the length of the new value.
func (x GraphicsPipelineCreateInfo) WithPStages(y []PipelineShaderStageCreateInfo) GraphicsPipelineCreateInfo {
	ptr := func(x *[]PipelineShaderStageCreateInfo) **C.struct_VkPipelineShaderStageCreateInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkPipelineShaderStageCreateInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkPipelineShaderStageCreateInfo)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pStages = *ptr
	return x.WithStageCount(uint32(len(y)))
}

// PVertexInputState returns the value of pVertexInputState from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PVertexInputState() *PipelineVertexInputStateCreateInfo {
	ptr := func(x **C.struct_VkPipelineVertexInputStateCreateInfo) **PipelineVertexInputStateCreateInfo { /* Pointer */
		return (**PipelineVertexInputStateCreateInfo)(unsafe.Pointer(x))
	}(&x.pVertexInputState)
	return *ptr
}

// WithPVertexInputState sets the value for the PVertexInputState on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPVertexInputState(y *PipelineVertexInputStateCreateInfo) GraphicsPipelineCreateInfo {
	ptr := func(x **PipelineVertexInputStateCreateInfo) **C.struct_VkPipelineVertexInputStateCreateInfo { /* Pointer */
		return (**C.struct_VkPipelineVertexInputStateCreateInfo)(unsafe.Pointer(x))
	}(&y)
	x.pVertexInputState = *ptr
	return x
}

// PInputAssemblyState returns the value of pInputAssemblyState from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PInputAssemblyState() *PipelineInputAssemblyStateCreateInfo {
	ptr := func(x **C.struct_VkPipelineInputAssemblyStateCreateInfo) **PipelineInputAssemblyStateCreateInfo { /* Pointer */
		return (**PipelineInputAssemblyStateCreateInfo)(unsafe.Pointer(x))
	}(&x.pInputAssemblyState)
	return *ptr
}

// WithPInputAssemblyState sets the value for the PInputAssemblyState on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPInputAssemblyState(y *PipelineInputAssemblyStateCreateInfo) GraphicsPipelineCreateInfo {
	ptr := func(x **PipelineInputAssemblyStateCreateInfo) **C.struct_VkPipelineInputAssemblyStateCreateInfo { /* Pointer */
		return (**C.struct_VkPipelineInputAssemblyStateCreateInfo)(unsafe.Pointer(x))
	}(&y)
	x.pInputAssemblyState = *ptr
	return x
}

// PTessellationState returns the value of pTessellationState from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PTessellationState() *PipelineTessellationStateCreateInfo {
	ptr := func(x **C.struct_VkPipelineTessellationStateCreateInfo) **PipelineTessellationStateCreateInfo { /* Pointer */
		return (**PipelineTessellationStateCreateInfo)(unsafe.Pointer(x))
	}(&x.pTessellationState)
	return *ptr
}

// WithPTessellationState sets the value for the PTessellationState on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPTessellationState(y *PipelineTessellationStateCreateInfo) GraphicsPipelineCreateInfo {
	ptr := func(x **PipelineTessellationStateCreateInfo) **C.struct_VkPipelineTessellationStateCreateInfo { /* Pointer */
		return (**C.struct_VkPipelineTessellationStateCreateInfo)(unsafe.Pointer(x))
	}(&y)
	x.pTessellationState = *ptr
	return x
}

// PViewportState returns the value of pViewportState from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PViewportState() *PipelineViewportStateCreateInfo {
	ptr := func(x **C.struct_VkPipelineViewportStateCreateInfo) **PipelineViewportStateCreateInfo { /* Pointer */
		return (**PipelineViewportStateCreateInfo)(unsafe.Pointer(x))
	}(&x.pViewportState)
	return *ptr
}

// WithPViewportState sets the value for the PViewportState on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPViewportState(y *PipelineViewportStateCreateInfo) GraphicsPipelineCreateInfo {
	ptr := func(x **PipelineViewportStateCreateInfo) **C.struct_VkPipelineViewportStateCreateInfo { /* Pointer */
		return (**C.struct_VkPipelineViewportStateCreateInfo)(unsafe.Pointer(x))
	}(&y)
	x.pViewportState = *ptr
	return x
}

// PRasterizationState returns the value of pRasterizationState from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PRasterizationState() *PipelineRasterizationStateCreateInfo {
	ptr := func(x **C.struct_VkPipelineRasterizationStateCreateInfo) **PipelineRasterizationStateCreateInfo { /* Pointer */
		return (**PipelineRasterizationStateCreateInfo)(unsafe.Pointer(x))
	}(&x.pRasterizationState)
	return *ptr
}

// WithPRasterizationState sets the value for the PRasterizationState on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPRasterizationState(y *PipelineRasterizationStateCreateInfo) GraphicsPipelineCreateInfo {
	ptr := func(x **PipelineRasterizationStateCreateInfo) **C.struct_VkPipelineRasterizationStateCreateInfo { /* Pointer */
		return (**C.struct_VkPipelineRasterizationStateCreateInfo)(unsafe.Pointer(x))
	}(&y)
	x.pRasterizationState = *ptr
	return x
}

// PMultisampleState returns the value of pMultisampleState from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PMultisampleState() *PipelineMultisampleStateCreateInfo {
	ptr := func(x **C.struct_VkPipelineMultisampleStateCreateInfo) **PipelineMultisampleStateCreateInfo { /* Pointer */
		return (**PipelineMultisampleStateCreateInfo)(unsafe.Pointer(x))
	}(&x.pMultisampleState)
	return *ptr
}

// WithPMultisampleState sets the value for the PMultisampleState on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPMultisampleState(y *PipelineMultisampleStateCreateInfo) GraphicsPipelineCreateInfo {
	ptr := func(x **PipelineMultisampleStateCreateInfo) **C.struct_VkPipelineMultisampleStateCreateInfo { /* Pointer */
		return (**C.struct_VkPipelineMultisampleStateCreateInfo)(unsafe.Pointer(x))
	}(&y)
	x.pMultisampleState = *ptr
	return x
}

// PDepthStencilState returns the value of pDepthStencilState from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PDepthStencilState() *PipelineDepthStencilStateCreateInfo {
	ptr := func(x **C.struct_VkPipelineDepthStencilStateCreateInfo) **PipelineDepthStencilStateCreateInfo { /* Pointer */
		return (**PipelineDepthStencilStateCreateInfo)(unsafe.Pointer(x))
	}(&x.pDepthStencilState)
	return *ptr
}

// WithPDepthStencilState sets the value for the PDepthStencilState on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPDepthStencilState(y *PipelineDepthStencilStateCreateInfo) GraphicsPipelineCreateInfo {
	ptr := func(x **PipelineDepthStencilStateCreateInfo) **C.struct_VkPipelineDepthStencilStateCreateInfo { /* Pointer */
		return (**C.struct_VkPipelineDepthStencilStateCreateInfo)(unsafe.Pointer(x))
	}(&y)
	x.pDepthStencilState = *ptr
	return x
}

// PColorBlendState returns the value of pColorBlendState from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PColorBlendState() *PipelineColorBlendStateCreateInfo {
	ptr := func(x **C.struct_VkPipelineColorBlendStateCreateInfo) **PipelineColorBlendStateCreateInfo { /* Pointer */
		return (**PipelineColorBlendStateCreateInfo)(unsafe.Pointer(x))
	}(&x.pColorBlendState)
	return *ptr
}

// WithPColorBlendState sets the value for the PColorBlendState on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPColorBlendState(y *PipelineColorBlendStateCreateInfo) GraphicsPipelineCreateInfo {
	ptr := func(x **PipelineColorBlendStateCreateInfo) **C.struct_VkPipelineColorBlendStateCreateInfo { /* Pointer */
		return (**C.struct_VkPipelineColorBlendStateCreateInfo)(unsafe.Pointer(x))
	}(&y)
	x.pColorBlendState = *ptr
	return x
}

// PDynamicState returns the value of pDynamicState from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PDynamicState() *PipelineDynamicStateCreateInfo {
	ptr := func(x **C.struct_VkPipelineDynamicStateCreateInfo) **PipelineDynamicStateCreateInfo { /* Pointer */
		return (**PipelineDynamicStateCreateInfo)(unsafe.Pointer(x))
	}(&x.pDynamicState)
	return *ptr
}

// WithPDynamicState sets the value for the PDynamicState on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPDynamicState(y *PipelineDynamicStateCreateInfo) GraphicsPipelineCreateInfo {
	ptr := func(x **PipelineDynamicStateCreateInfo) **C.struct_VkPipelineDynamicStateCreateInfo { /* Pointer */
		return (**C.struct_VkPipelineDynamicStateCreateInfo)(unsafe.Pointer(x))
	}(&y)
	x.pDynamicState = *ptr
	return x
}

// Layout returns the value of layout from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) Layout() PipelineLayout {
	ptr := /* handle */ (*PipelineLayout)(&x.layout)
	return *ptr
}

// WithLayout sets the value for the Layout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithLayout(y PipelineLayout) GraphicsPipelineCreateInfo {
	ptr := /* handle */ (*C.VkPipelineLayout)(&y)
	x.layout = *ptr
	return x
}

// RenderPass returns the value of renderPass from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) RenderPass() RenderPass {
	ptr := /* handle */ (*RenderPass)(&x.renderPass)
	return *ptr
}

// WithRenderPass sets the value for the RenderPass on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithRenderPass(y RenderPass) GraphicsPipelineCreateInfo {
	ptr := /* handle */ (*C.VkRenderPass)(&y)
	x.renderPass = *ptr
	return x
}

// Subpass returns the value of subpass from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) Subpass() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.subpass)
	return *ptr
}

// WithSubpass sets the value for the Subpass on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithSubpass(y uint32) GraphicsPipelineCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.subpass = *ptr
	return x
}

// BasePipelineHandle returns the value of basePipelineHandle from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) BasePipelineHandle() Pipeline {
	ptr := /* handle */ (*Pipeline)(&x.basePipelineHandle)
	return *ptr
}

// WithBasePipelineHandle sets the value for the BasePipelineHandle on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithBasePipelineHandle(y Pipeline) GraphicsPipelineCreateInfo {
	ptr := /* handle */ (*C.VkPipeline)(&y)
	x.basePipelineHandle = *ptr
	return x
}

// BasePipelineIndex returns the value of basePipelineIndex from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) BasePipelineIndex() int32 {
	ptr := func(x *C.int) *int32 { /* Scalar */ return (*int32)(unsafe.Pointer(x)) }(&x.basePipelineIndex)
	return *ptr
}

// WithBasePipelineIndex sets the value for the BasePipelineIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithBasePipelineIndex(y int32) GraphicsPipelineCreateInfo {
	ptr := func(x *int32) *C.int { /* Scalar */ return (*C.int)(unsafe.Pointer(x)) }(&y)
	x.basePipelineIndex = *ptr
	return x
}

//ApplicationInfo provides a go interface for VkApplicationInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkApplicationInfo.html
type ApplicationInfo C.struct_VkApplicationInfo

// SizeofApplicationInfo is the memory size of a ApplicationInfo
var SizeofApplicationInfo int = int(unsafe.Sizeof(ApplicationInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ApplicationInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ApplicationInfo) AsCPtr() *ApplicationInfo {
	clone := (*ApplicationInfo)(newCBlock(C.ulong(SizeofApplicationInfo)))
	*clone = x
	return clone
}

// ApplicationInfoFreeCSlice releases the memory allocated by ApplicationInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ApplicationInfoFreeCSlice(x []ApplicationInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ApplicationInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ApplicationInfoFreeCSlice must be called on the returned slice.
func ApplicationInfoMakeCSlice(x ...ApplicationInfo) []ApplicationInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofApplicationInfo * len(x)
	dst := unsafe.Slice((*ApplicationInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkApplicationInfo
func (x ApplicationInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ApplicationInfo) WithDefaultSType() ApplicationInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_APPLICATION_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ApplicationInfo) WithSType(y StructureType) ApplicationInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkApplicationInfo
func (x ApplicationInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ApplicationInfo) WithPNext(y unsafe.Pointer) ApplicationInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// PApplicationName returns the value of pApplicationName from VkApplicationInfo
func (x ApplicationInfo) PApplicationName() *byte {
	ptr := func(x **C.char) **byte { /* Pointer */ return (**byte)(unsafe.Pointer(x)) }(&x.pApplicationName)
	return *ptr
}

// WithPApplicationName sets the value for the PApplicationName on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ApplicationInfo) WithPApplicationName(y *byte) ApplicationInfo {
	ptr := func(x **byte) **C.char { /* Pointer */ return (**C.char)(unsafe.Pointer(x)) }(&y)
	x.pApplicationName = *ptr
	return x
}

// ApplicationVersion returns the value of applicationVersion from VkApplicationInfo
func (x ApplicationInfo) ApplicationVersion() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.applicationVersion)
	return *ptr
}

// WithApplicationVersion sets the value for the ApplicationVersion on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ApplicationInfo) WithApplicationVersion(y uint32) ApplicationInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.applicationVersion = *ptr
	return x
}

// PEngineName returns the value of pEngineName from VkApplicationInfo
func (x ApplicationInfo) PEngineName() *byte {
	ptr := func(x **C.char) **byte { /* Pointer */ return (**byte)(unsafe.Pointer(x)) }(&x.pEngineName)
	return *ptr
}

// WithPEngineName sets the value for the PEngineName on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ApplicationInfo) WithPEngineName(y *byte) ApplicationInfo {
	ptr := func(x **byte) **C.char { /* Pointer */ return (**C.char)(unsafe.Pointer(x)) }(&y)
	x.pEngineName = *ptr
	return x
}

// EngineVersion returns the value of engineVersion from VkApplicationInfo
func (x ApplicationInfo) EngineVersion() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.engineVersion)
	return *ptr
}

// WithEngineVersion sets the value for the EngineVersion on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ApplicationInfo) WithEngineVersion(y uint32) ApplicationInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.engineVersion = *ptr
	return x
}

// ApiVersion returns the value of apiVersion from VkApplicationInfo
func (x ApplicationInfo) ApiVersion() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.apiVersion)
	return *ptr
}

// WithApiVersion sets the value for the ApiVersion on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ApplicationInfo) WithApiVersion(y uint32) ApplicationInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.apiVersion = *ptr
	return x
}

//AllocationCallbacks provides a go interface for VkAllocationCallbacks.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkAllocationCallbacks.html
type AllocationCallbacks C.struct_VkAllocationCallbacks

// SizeofAllocationCallbacks is the memory size of a AllocationCallbacks
var SizeofAllocationCallbacks int = int(unsafe.Sizeof(AllocationCallbacks{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *AllocationCallbacks) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x AllocationCallbacks) AsCPtr() *AllocationCallbacks {
	clone := (*AllocationCallbacks)(newCBlock(C.ulong(SizeofAllocationCallbacks)))
	*clone = x
	return clone
}

// AllocationCallbacksFreeCSlice releases the memory allocated by AllocationCallbacksMakeCSlice.
// It does not free pointers stored inside the slice.
func AllocationCallbacksFreeCSlice(x []AllocationCallbacks) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// AllocationCallbacksMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. AllocationCallbacksFreeCSlice must be called on the returned slice.
func AllocationCallbacksMakeCSlice(x ...AllocationCallbacks) []AllocationCallbacks {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAllocationCallbacks * len(x)
	dst := unsafe.Slice((*AllocationCallbacks)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// PUserData returns the value of pUserData from VkAllocationCallbacks
func (x AllocationCallbacks) PUserData() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pUserData)
	return *ptr
}

// WithPUserData sets the value for the PUserData on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AllocationCallbacks) WithPUserData(y unsafe.Pointer) AllocationCallbacks {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pUserData = *ptr
	return x
}

// PfnAllocation returns the value of pfnAllocation from VkAllocationCallbacks
func (x AllocationCallbacks) PfnAllocation() PFN_vkAllocationFunction {
	ptr := /* typedef */ (*PFN_vkAllocationFunction)(&x.pfnAllocation)
	return *ptr
}

// WithPfnAllocation sets the value for the PfnAllocation on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AllocationCallbacks) WithPfnAllocation(y PFN_vkAllocationFunction) AllocationCallbacks {
	ptr := /* typedef */ (*C.PFN_vkAllocationFunction)(&y)
	x.pfnAllocation = *ptr
	return x
}

// PfnReallocation returns the value of pfnReallocation from VkAllocationCallbacks
func (x AllocationCallbacks) PfnReallocation() PFN_vkReallocationFunction {
	ptr := /* typedef */ (*PFN_vkReallocationFunction)(&x.pfnReallocation)
	return *ptr
}

// WithPfnReallocation sets the value for the PfnReallocation on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AllocationCallbacks) WithPfnReallocation(y PFN_vkReallocationFunction) AllocationCallbacks {
	ptr := /* typedef */ (*C.PFN_vkReallocationFunction)(&y)
	x.pfnReallocation = *ptr
	return x
}

// PfnFree returns the value of pfnFree from VkAllocationCallbacks
func (x AllocationCallbacks) PfnFree() PFN_vkFreeFunction {
	ptr := /* typedef */ (*PFN_vkFreeFunction)(&x.pfnFree)
	return *ptr
}

// WithPfnFree sets the value for the PfnFree on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AllocationCallbacks) WithPfnFree(y PFN_vkFreeFunction) AllocationCallbacks {
	ptr := /* typedef */ (*C.PFN_vkFreeFunction)(&y)
	x.pfnFree = *ptr
	return x
}

// PfnInternalAllocation returns the value of pfnInternalAllocation from VkAllocationCallbacks
func (x AllocationCallbacks) PfnInternalAllocation() PFN_vkInternalAllocationNotification {
	ptr := /* typedef */ (*PFN_vkInternalAllocationNotification)(&x.pfnInternalAllocation)
	return *ptr
}

// WithPfnInternalAllocation sets the value for the PfnInternalAllocation on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AllocationCallbacks) WithPfnInternalAllocation(y PFN_vkInternalAllocationNotification) AllocationCallbacks {
	ptr := /* typedef */ (*C.PFN_vkInternalAllocationNotification)(&y)
	x.pfnInternalAllocation = *ptr
	return x
}

// PfnInternalFree returns the value of pfnInternalFree from VkAllocationCallbacks
func (x AllocationCallbacks) PfnInternalFree() PFN_vkInternalFreeNotification {
	ptr := /* typedef */ (*PFN_vkInternalFreeNotification)(&x.pfnInternalFree)
	return *ptr
}

// WithPfnInternalFree sets the value for the PfnInternalFree on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AllocationCallbacks) WithPfnInternalFree(y PFN_vkInternalFreeNotification) AllocationCallbacks {
	ptr := /* typedef */ (*C.PFN_vkInternalFreeNotification)(&y)
	x.pfnInternalFree = *ptr
	return x
}

//PipelineColorBlendAttachmentState provides a go interface for VkPipelineColorBlendAttachmentState.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineColorBlendAttachmentState.html
type PipelineColorBlendAttachmentState C.struct_VkPipelineColorBlendAttachmentState

// SizeofPipelineColorBlendAttachmentState is the memory size of a PipelineColorBlendAttachmentState
var SizeofPipelineColorBlendAttachmentState int = int(unsafe.Sizeof(PipelineColorBlendAttachmentState{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineColorBlendAttachmentState) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineColorBlendAttachmentState) AsCPtr() *PipelineColorBlendAttachmentState {
	clone := (*PipelineColorBlendAttachmentState)(newCBlock(C.ulong(SizeofPipelineColorBlendAttachmentState)))
	*clone = x
	return clone
}

// PipelineColorBlendAttachmentStateFreeCSlice releases the memory allocated by PipelineColorBlendAttachmentStateMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineColorBlendAttachmentStateFreeCSlice(x []PipelineColorBlendAttachmentState) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineColorBlendAttachmentStateMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineColorBlendAttachmentStateFreeCSlice must be called on the returned slice.
func PipelineColorBlendAttachmentStateMakeCSlice(x ...PipelineColorBlendAttachmentState) []PipelineColorBlendAttachmentState {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineColorBlendAttachmentState * len(x)
	dst := unsafe.Slice((*PipelineColorBlendAttachmentState)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// BlendEnable returns the value of blendEnable from VkPipelineColorBlendAttachmentState
func (x PipelineColorBlendAttachmentState) BlendEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.blendEnable)
	return *ptr
}

// WithBlendEnable sets the value for the BlendEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendAttachmentState) WithBlendEnable(y Bool32) PipelineColorBlendAttachmentState {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.blendEnable = *ptr
	return x
}

// SrcColorBlendFactor returns the value of srcColorBlendFactor from VkPipelineColorBlendAttachmentState
func (x PipelineColorBlendAttachmentState) SrcColorBlendFactor() BlendFactor {
	ptr := /* typedef */ (*BlendFactor)(&x.srcColorBlendFactor)
	return *ptr
}

// WithSrcColorBlendFactor sets the value for the SrcColorBlendFactor on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendAttachmentState) WithSrcColorBlendFactor(y BlendFactor) PipelineColorBlendAttachmentState {
	ptr := /* typedef */ (*C.VkBlendFactor)(&y)
	x.srcColorBlendFactor = *ptr
	return x
}

// DstColorBlendFactor returns the value of dstColorBlendFactor from VkPipelineColorBlendAttachmentState
func (x PipelineColorBlendAttachmentState) DstColorBlendFactor() BlendFactor {
	ptr := /* typedef */ (*BlendFactor)(&x.dstColorBlendFactor)
	return *ptr
}

// WithDstColorBlendFactor sets the value for the DstColorBlendFactor on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendAttachmentState) WithDstColorBlendFactor(y BlendFactor) PipelineColorBlendAttachmentState {
	ptr := /* typedef */ (*C.VkBlendFactor)(&y)
	x.dstColorBlendFactor = *ptr
	return x
}

// ColorBlendOp returns the value of colorBlendOp from VkPipelineColorBlendAttachmentState
func (x PipelineColorBlendAttachmentState) ColorBlendOp() BlendOp {
	ptr := /* typedef */ (*BlendOp)(&x.colorBlendOp)
	return *ptr
}

// WithColorBlendOp sets the value for the ColorBlendOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendAttachmentState) WithColorBlendOp(y BlendOp) PipelineColorBlendAttachmentState {
	ptr := /* typedef */ (*C.VkBlendOp)(&y)
	x.colorBlendOp = *ptr
	return x
}

// SrcAlphaBlendFactor returns the value of srcAlphaBlendFactor from VkPipelineColorBlendAttachmentState
func (x PipelineColorBlendAttachmentState) SrcAlphaBlendFactor() BlendFactor {
	ptr := /* typedef */ (*BlendFactor)(&x.srcAlphaBlendFactor)
	return *ptr
}

// WithSrcAlphaBlendFactor sets the value for the SrcAlphaBlendFactor on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendAttachmentState) WithSrcAlphaBlendFactor(y BlendFactor) PipelineColorBlendAttachmentState {
	ptr := /* typedef */ (*C.VkBlendFactor)(&y)
	x.srcAlphaBlendFactor = *ptr
	return x
}

// DstAlphaBlendFactor returns the value of dstAlphaBlendFactor from VkPipelineColorBlendAttachmentState
func (x PipelineColorBlendAttachmentState) DstAlphaBlendFactor() BlendFactor {
	ptr := /* typedef */ (*BlendFactor)(&x.dstAlphaBlendFactor)
	return *ptr
}

// WithDstAlphaBlendFactor sets the value for the DstAlphaBlendFactor on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendAttachmentState) WithDstAlphaBlendFactor(y BlendFactor) PipelineColorBlendAttachmentState {
	ptr := /* typedef */ (*C.VkBlendFactor)(&y)
	x.dstAlphaBlendFactor = *ptr
	return x
}

// AlphaBlendOp returns the value of alphaBlendOp from VkPipelineColorBlendAttachmentState
func (x PipelineColorBlendAttachmentState) AlphaBlendOp() BlendOp {
	ptr := /* typedef */ (*BlendOp)(&x.alphaBlendOp)
	return *ptr
}

// WithAlphaBlendOp sets the value for the AlphaBlendOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendAttachmentState) WithAlphaBlendOp(y BlendOp) PipelineColorBlendAttachmentState {
	ptr := /* typedef */ (*C.VkBlendOp)(&y)
	x.alphaBlendOp = *ptr
	return x
}

// ColorWriteMask returns the value of colorWriteMask from VkPipelineColorBlendAttachmentState
func (x PipelineColorBlendAttachmentState) ColorWriteMask() ColorComponentFlags {
	ptr := /* typedef */ (*ColorComponentFlags)(&x.colorWriteMask)
	return *ptr
}

// WithColorWriteMask sets the value for the ColorWriteMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendAttachmentState) WithColorWriteMask(y ColorComponentFlags) PipelineColorBlendAttachmentState {
	ptr := /* typedef */ (*C.VkColorComponentFlags)(&y)
	x.colorWriteMask = *ptr
	return x
}

//ClearRect provides a go interface for VkClearRect.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkClearRect.html
type ClearRect C.struct_VkClearRect

// SizeofClearRect is the memory size of a ClearRect
var SizeofClearRect int = int(unsafe.Sizeof(ClearRect{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ClearRect) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ClearRect) AsCPtr() *ClearRect {
	clone := (*ClearRect)(newCBlock(C.ulong(SizeofClearRect)))
	*clone = x
	return clone
}

// ClearRectFreeCSlice releases the memory allocated by ClearRectMakeCSlice.
// It does not free pointers stored inside the slice.
func ClearRectFreeCSlice(x []ClearRect) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ClearRectMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ClearRectFreeCSlice must be called on the returned slice.
func ClearRectMakeCSlice(x ...ClearRect) []ClearRect {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofClearRect * len(x)
	dst := unsafe.Slice((*ClearRect)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Rect returns the value of rect from VkClearRect
func (x ClearRect) Rect() Rect2D {
	ptr := /* typedef */ (*Rect2D)(&x.rect)
	return *ptr
}

// WithRect sets the value for the Rect on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ClearRect) WithRect(y Rect2D) ClearRect {
	ptr := /* typedef */ (*C.struct_VkRect2D)(&y)
	x.rect = *ptr
	return x
}

// BaseArrayLayer returns the value of baseArrayLayer from VkClearRect
func (x ClearRect) BaseArrayLayer() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.baseArrayLayer)
	return *ptr
}

// WithBaseArrayLayer sets the value for the BaseArrayLayer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ClearRect) WithBaseArrayLayer(y uint32) ClearRect {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.baseArrayLayer = *ptr
	return x
}

// LayerCount returns the value of layerCount from VkClearRect
func (x ClearRect) LayerCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.layerCount)
	return *ptr
}

// WithLayerCount sets the value for the LayerCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ClearRect) WithLayerCount(y uint32) ClearRect {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.layerCount = *ptr
	return x
}

//PipelineColorBlendStateCreateInfo provides a go interface for VkPipelineColorBlendStateCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineColorBlendStateCreateInfo.html
type PipelineColorBlendStateCreateInfo C.struct_VkPipelineColorBlendStateCreateInfo

// SizeofPipelineColorBlendStateCreateInfo is the memory size of a PipelineColorBlendStateCreateInfo
var SizeofPipelineColorBlendStateCreateInfo int = int(unsafe.Sizeof(PipelineColorBlendStateCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineColorBlendStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineColorBlendStateCreateInfo) AsCPtr() *PipelineColorBlendStateCreateInfo {
	clone := (*PipelineColorBlendStateCreateInfo)(newCBlock(C.ulong(SizeofPipelineColorBlendStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineColorBlendStateCreateInfoFreeCSlice releases the memory allocated by PipelineColorBlendStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineColorBlendStateCreateInfoFreeCSlice(x []PipelineColorBlendStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineColorBlendStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineColorBlendStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineColorBlendStateCreateInfoMakeCSlice(x ...PipelineColorBlendStateCreateInfo) []PipelineColorBlendStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineColorBlendStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineColorBlendStateCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineColorBlendStateCreateInfo
func (x PipelineColorBlendStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineColorBlendStateCreateInfo) WithDefaultSType() PipelineColorBlendStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendStateCreateInfo) WithSType(y StructureType) PipelineColorBlendStateCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPipelineColorBlendStateCreateInfo
func (x PipelineColorBlendStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineColorBlendStateCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkPipelineColorBlendStateCreateInfo
func (x PipelineColorBlendStateCreateInfo) Flags() PipelineColorBlendStateCreateFlags {
	ptr := /* typedef */ (*PipelineColorBlendStateCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendStateCreateInfo) WithFlags(y PipelineColorBlendStateCreateFlags) PipelineColorBlendStateCreateInfo {
	ptr := /* typedef */ (*C.VkPipelineColorBlendStateCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// LogicOpEnable returns the value of logicOpEnable from VkPipelineColorBlendStateCreateInfo
func (x PipelineColorBlendStateCreateInfo) LogicOpEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.logicOpEnable)
	return *ptr
}

// WithLogicOpEnable sets the value for the LogicOpEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendStateCreateInfo) WithLogicOpEnable(y Bool32) PipelineColorBlendStateCreateInfo {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.logicOpEnable = *ptr
	return x
}

// LogicOp returns the value of logicOp from VkPipelineColorBlendStateCreateInfo
func (x PipelineColorBlendStateCreateInfo) LogicOp() LogicOp {
	ptr := /* typedef */ (*LogicOp)(&x.logicOp)
	return *ptr
}

// WithLogicOp sets the value for the LogicOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendStateCreateInfo) WithLogicOp(y LogicOp) PipelineColorBlendStateCreateInfo {
	ptr := /* typedef */ (*C.VkLogicOp)(&y)
	x.logicOp = *ptr
	return x
}

// AttachmentCount returns the value of attachmentCount from VkPipelineColorBlendStateCreateInfo
func (x PipelineColorBlendStateCreateInfo) AttachmentCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.attachmentCount)
	return *ptr
}

// WithAttachmentCount sets the value for the AttachmentCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendStateCreateInfo) WithAttachmentCount(y uint32) PipelineColorBlendStateCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.attachmentCount = *ptr
	return x
}

// PAttachments returns the value of pAttachments from VkPipelineColorBlendStateCreateInfo
func (x PipelineColorBlendStateCreateInfo) PAttachments() []PipelineColorBlendAttachmentState {
	ptr := func(x **C.struct_VkPipelineColorBlendAttachmentState) *[]PipelineColorBlendAttachmentState { /* Slice */
		slc := unsafe.Slice((*PipelineColorBlendAttachmentState)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pAttachments)
	return *ptr
}

// WithPAttachments sets the value for the PAttachments on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines AttachmentCount as the length of this field.
// AttachmentCount is updated with the length of the new value.
func (x PipelineColorBlendStateCreateInfo) WithPAttachments(y []PipelineColorBlendAttachmentState) PipelineColorBlendStateCreateInfo {
	ptr := func(x *[]PipelineColorBlendAttachmentState) **C.struct_VkPipelineColorBlendAttachmentState { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkPipelineColorBlendAttachmentState)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkPipelineColorBlendAttachmentState)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pAttachments = *ptr
	return x.WithAttachmentCount(uint32(len(y)))
}

// BlendConstants returns the value of blendConstants from VkPipelineColorBlendStateCreateInfo
func (x PipelineColorBlendStateCreateInfo) BlendConstants() []float32 {
	ptr := func(x *[4]C.float) *[]float32 { /* Array */
		slc := unsafe.Slice((*float32)(unsafe.Pointer(x)), 4)
		return &slc
	}(&x.blendConstants)
	return *ptr
}

// WithBlendConstants sets the value for the BlendConstants on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendStateCreateInfo) WithBlendConstants(y []float32) PipelineColorBlendStateCreateInfo {
	ptr := func(x *[]float32) **C.float { /* Array */
		if len(*x) > 0 {
			slc := (*C.float)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.float)(unsafe.Pointer((&ptr)))
	}(&y)
	copy(x.blendConstants[:], unsafe.Slice(*ptr, len(y)))
	return x
}

//ImageBlit provides a go interface for VkImageBlit.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageBlit.html
type ImageBlit C.struct_VkImageBlit

// SizeofImageBlit is the memory size of a ImageBlit
var SizeofImageBlit int = int(unsafe.Sizeof(ImageBlit{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageBlit) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageBlit) AsCPtr() *ImageBlit {
	clone := (*ImageBlit)(newCBlock(C.ulong(SizeofImageBlit)))
	*clone = x
	return clone
}

// ImageBlitFreeCSlice releases the memory allocated by ImageBlitMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageBlitFreeCSlice(x []ImageBlit) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageBlitMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageBlitFreeCSlice must be called on the returned slice.
func ImageBlitMakeCSlice(x ...ImageBlit) []ImageBlit {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageBlit * len(x)
	dst := unsafe.Slice((*ImageBlit)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SrcSubresource returns the value of srcSubresource from VkImageBlit
func (x ImageBlit) SrcSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.srcSubresource)
	return *ptr
}

// WithSrcSubresource sets the value for the SrcSubresource on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageBlit) WithSrcSubresource(y ImageSubresourceLayers) ImageBlit {
	ptr := /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y)
	x.srcSubresource = *ptr
	return x
}

// SrcOffsets returns the value of srcOffsets from VkImageBlit
func (x ImageBlit) SrcOffsets() []Offset3D {
	ptr := func(x *[2]C.struct_VkOffset3D) *[]Offset3D { /* Array */
		slc := unsafe.Slice((*Offset3D)(unsafe.Pointer(x)), 2)
		return &slc
	}(&x.srcOffsets)
	return *ptr
}

// WithSrcOffsets sets the value for the SrcOffsets on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageBlit) WithSrcOffsets(y []Offset3D) ImageBlit {
	ptr := func(x *[]Offset3D) **C.struct_VkOffset3D { /* Array */
		if len(*x) > 0 {
			slc := (*C.struct_VkOffset3D)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkOffset3D)(unsafe.Pointer((&ptr)))
	}(&y)
	copy(x.srcOffsets[:], unsafe.Slice(*ptr, len(y)))
	return x
}

// DstSubresource returns the value of dstSubresource from VkImageBlit
func (x ImageBlit) DstSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.dstSubresource)
	return *ptr
}

// WithDstSubresource sets the value for the DstSubresource on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageBlit) WithDstSubresource(y ImageSubresourceLayers) ImageBlit {
	ptr := /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y)
	x.dstSubresource = *ptr
	return x
}

// DstOffsets returns the value of dstOffsets from VkImageBlit
func (x ImageBlit) DstOffsets() []Offset3D {
	ptr := func(x *[2]C.struct_VkOffset3D) *[]Offset3D { /* Array */
		slc := unsafe.Slice((*Offset3D)(unsafe.Pointer(x)), 2)
		return &slc
	}(&x.dstOffsets)
	return *ptr
}

// WithDstOffsets sets the value for the DstOffsets on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageBlit) WithDstOffsets(y []Offset3D) ImageBlit {
	ptr := func(x *[]Offset3D) **C.struct_VkOffset3D { /* Array */
		if len(*x) > 0 {
			slc := (*C.struct_VkOffset3D)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkOffset3D)(unsafe.Pointer((&ptr)))
	}(&y)
	copy(x.dstOffsets[:], unsafe.Slice(*ptr, len(y)))
	return x
}

//ImageCopy provides a go interface for VkImageCopy.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageCopy.html
type ImageCopy C.struct_VkImageCopy

// SizeofImageCopy is the memory size of a ImageCopy
var SizeofImageCopy int = int(unsafe.Sizeof(ImageCopy{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageCopy) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageCopy) AsCPtr() *ImageCopy {
	clone := (*ImageCopy)(newCBlock(C.ulong(SizeofImageCopy)))
	*clone = x
	return clone
}

// ImageCopyFreeCSlice releases the memory allocated by ImageCopyMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageCopyFreeCSlice(x []ImageCopy) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageCopyMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageCopyFreeCSlice must be called on the returned slice.
func ImageCopyMakeCSlice(x ...ImageCopy) []ImageCopy {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageCopy * len(x)
	dst := unsafe.Slice((*ImageCopy)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SrcSubresource returns the value of srcSubresource from VkImageCopy
func (x ImageCopy) SrcSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.srcSubresource)
	return *ptr
}

// WithSrcSubresource sets the value for the SrcSubresource on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy) WithSrcSubresource(y ImageSubresourceLayers) ImageCopy {
	ptr := /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y)
	x.srcSubresource = *ptr
	return x
}

// SrcOffset returns the value of srcOffset from VkImageCopy
func (x ImageCopy) SrcOffset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.srcOffset)
	return *ptr
}

// WithSrcOffset sets the value for the SrcOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy) WithSrcOffset(y Offset3D) ImageCopy {
	ptr := /* typedef */ (*C.struct_VkOffset3D)(&y)
	x.srcOffset = *ptr
	return x
}

// DstSubresource returns the value of dstSubresource from VkImageCopy
func (x ImageCopy) DstSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.dstSubresource)
	return *ptr
}

// WithDstSubresource sets the value for the DstSubresource on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy) WithDstSubresource(y ImageSubresourceLayers) ImageCopy {
	ptr := /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y)
	x.dstSubresource = *ptr
	return x
}

// DstOffset returns the value of dstOffset from VkImageCopy
func (x ImageCopy) DstOffset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.dstOffset)
	return *ptr
}

// WithDstOffset sets the value for the DstOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy) WithDstOffset(y Offset3D) ImageCopy {
	ptr := /* typedef */ (*C.struct_VkOffset3D)(&y)
	x.dstOffset = *ptr
	return x
}

// Extent returns the value of extent from VkImageCopy
func (x ImageCopy) Extent() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.extent)
	return *ptr
}

// WithExtent sets the value for the Extent on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy) WithExtent(y Extent3D) ImageCopy {
	ptr := /* typedef */ (*C.struct_VkExtent3D)(&y)
	x.extent = *ptr
	return x
}

//ImageResolve provides a go interface for VkImageResolve.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageResolve.html
type ImageResolve C.struct_VkImageResolve

// SizeofImageResolve is the memory size of a ImageResolve
var SizeofImageResolve int = int(unsafe.Sizeof(ImageResolve{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageResolve) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageResolve) AsCPtr() *ImageResolve {
	clone := (*ImageResolve)(newCBlock(C.ulong(SizeofImageResolve)))
	*clone = x
	return clone
}

// ImageResolveFreeCSlice releases the memory allocated by ImageResolveMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageResolveFreeCSlice(x []ImageResolve) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageResolveMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageResolveFreeCSlice must be called on the returned slice.
func ImageResolveMakeCSlice(x ...ImageResolve) []ImageResolve {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageResolve * len(x)
	dst := unsafe.Slice((*ImageResolve)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SrcSubresource returns the value of srcSubresource from VkImageResolve
func (x ImageResolve) SrcSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.srcSubresource)
	return *ptr
}

// WithSrcSubresource sets the value for the SrcSubresource on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve) WithSrcSubresource(y ImageSubresourceLayers) ImageResolve {
	ptr := /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y)
	x.srcSubresource = *ptr
	return x
}

// SrcOffset returns the value of srcOffset from VkImageResolve
func (x ImageResolve) SrcOffset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.srcOffset)
	return *ptr
}

// WithSrcOffset sets the value for the SrcOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve) WithSrcOffset(y Offset3D) ImageResolve {
	ptr := /* typedef */ (*C.struct_VkOffset3D)(&y)
	x.srcOffset = *ptr
	return x
}

// DstSubresource returns the value of dstSubresource from VkImageResolve
func (x ImageResolve) DstSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.dstSubresource)
	return *ptr
}

// WithDstSubresource sets the value for the DstSubresource on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve) WithDstSubresource(y ImageSubresourceLayers) ImageResolve {
	ptr := /* typedef */ (*C.struct_VkImageSubresourceLayers)(&y)
	x.dstSubresource = *ptr
	return x
}

// DstOffset returns the value of dstOffset from VkImageResolve
func (x ImageResolve) DstOffset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.dstOffset)
	return *ptr
}

// WithDstOffset sets the value for the DstOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve) WithDstOffset(y Offset3D) ImageResolve {
	ptr := /* typedef */ (*C.struct_VkOffset3D)(&y)
	x.dstOffset = *ptr
	return x
}

// Extent returns the value of extent from VkImageResolve
func (x ImageResolve) Extent() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.extent)
	return *ptr
}

// WithExtent sets the value for the Extent on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve) WithExtent(y Extent3D) ImageResolve {
	ptr := /* typedef */ (*C.struct_VkExtent3D)(&y)
	x.extent = *ptr
	return x
}

//PipelineDepthStencilStateCreateInfo provides a go interface for VkPipelineDepthStencilStateCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineDepthStencilStateCreateInfo.html
type PipelineDepthStencilStateCreateInfo C.struct_VkPipelineDepthStencilStateCreateInfo

// SizeofPipelineDepthStencilStateCreateInfo is the memory size of a PipelineDepthStencilStateCreateInfo
var SizeofPipelineDepthStencilStateCreateInfo int = int(unsafe.Sizeof(PipelineDepthStencilStateCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineDepthStencilStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineDepthStencilStateCreateInfo) AsCPtr() *PipelineDepthStencilStateCreateInfo {
	clone := (*PipelineDepthStencilStateCreateInfo)(newCBlock(C.ulong(SizeofPipelineDepthStencilStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineDepthStencilStateCreateInfoFreeCSlice releases the memory allocated by PipelineDepthStencilStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineDepthStencilStateCreateInfoFreeCSlice(x []PipelineDepthStencilStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineDepthStencilStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineDepthStencilStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineDepthStencilStateCreateInfoMakeCSlice(x ...PipelineDepthStencilStateCreateInfo) []PipelineDepthStencilStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineDepthStencilStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineDepthStencilStateCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineDepthStencilStateCreateInfo) WithDefaultSType() PipelineDepthStencilStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithSType(y StructureType) PipelineDepthStencilStateCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineDepthStencilStateCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) Flags() PipelineDepthStencilStateCreateFlags {
	ptr := /* typedef */ (*PipelineDepthStencilStateCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithFlags(y PipelineDepthStencilStateCreateFlags) PipelineDepthStencilStateCreateInfo {
	ptr := /* typedef */ (*C.VkPipelineDepthStencilStateCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// DepthTestEnable returns the value of depthTestEnable from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) DepthTestEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.depthTestEnable)
	return *ptr
}

// WithDepthTestEnable sets the value for the DepthTestEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithDepthTestEnable(y Bool32) PipelineDepthStencilStateCreateInfo {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.depthTestEnable = *ptr
	return x
}

// DepthWriteEnable returns the value of depthWriteEnable from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) DepthWriteEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.depthWriteEnable)
	return *ptr
}

// WithDepthWriteEnable sets the value for the DepthWriteEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithDepthWriteEnable(y Bool32) PipelineDepthStencilStateCreateInfo {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.depthWriteEnable = *ptr
	return x
}

// DepthCompareOp returns the value of depthCompareOp from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) DepthCompareOp() CompareOp {
	ptr := /* typedef */ (*CompareOp)(&x.depthCompareOp)
	return *ptr
}

// WithDepthCompareOp sets the value for the DepthCompareOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithDepthCompareOp(y CompareOp) PipelineDepthStencilStateCreateInfo {
	ptr := /* typedef */ (*C.VkCompareOp)(&y)
	x.depthCompareOp = *ptr
	return x
}

// DepthBoundsTestEnable returns the value of depthBoundsTestEnable from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) DepthBoundsTestEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.depthBoundsTestEnable)
	return *ptr
}

// WithDepthBoundsTestEnable sets the value for the DepthBoundsTestEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithDepthBoundsTestEnable(y Bool32) PipelineDepthStencilStateCreateInfo {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.depthBoundsTestEnable = *ptr
	return x
}

// StencilTestEnable returns the value of stencilTestEnable from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) StencilTestEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.stencilTestEnable)
	return *ptr
}

// WithStencilTestEnable sets the value for the StencilTestEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithStencilTestEnable(y Bool32) PipelineDepthStencilStateCreateInfo {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.stencilTestEnable = *ptr
	return x
}

// Front returns the value of front from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) Front() StencilOpState {
	ptr := /* typedef */ (*StencilOpState)(&x.front)
	return *ptr
}

// WithFront sets the value for the Front on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithFront(y StencilOpState) PipelineDepthStencilStateCreateInfo {
	ptr := /* typedef */ (*C.struct_VkStencilOpState)(&y)
	x.front = *ptr
	return x
}

// Back returns the value of back from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) Back() StencilOpState {
	ptr := /* typedef */ (*StencilOpState)(&x.back)
	return *ptr
}

// WithBack sets the value for the Back on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithBack(y StencilOpState) PipelineDepthStencilStateCreateInfo {
	ptr := /* typedef */ (*C.struct_VkStencilOpState)(&y)
	x.back = *ptr
	return x
}

// MinDepthBounds returns the value of minDepthBounds from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) MinDepthBounds() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ return (*float32)(unsafe.Pointer(x)) }(&x.minDepthBounds)
	return *ptr
}

// WithMinDepthBounds sets the value for the MinDepthBounds on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithMinDepthBounds(y float32) PipelineDepthStencilStateCreateInfo {
	ptr := func(x *float32) *C.float { /* Scalar */ return (*C.float)(unsafe.Pointer(x)) }(&y)
	x.minDepthBounds = *ptr
	return x
}

// MaxDepthBounds returns the value of maxDepthBounds from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) MaxDepthBounds() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ return (*float32)(unsafe.Pointer(x)) }(&x.maxDepthBounds)
	return *ptr
}

// WithMaxDepthBounds sets the value for the MaxDepthBounds on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithMaxDepthBounds(y float32) PipelineDepthStencilStateCreateInfo {
	ptr := func(x *float32) *C.float { /* Scalar */ return (*C.float)(unsafe.Pointer(x)) }(&y)
	x.maxDepthBounds = *ptr
	return x
}

//ImageSubresourceLayers provides a go interface for VkImageSubresourceLayers.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageSubresourceLayers.html
type ImageSubresourceLayers C.struct_VkImageSubresourceLayers

// SizeofImageSubresourceLayers is the memory size of a ImageSubresourceLayers
var SizeofImageSubresourceLayers int = int(unsafe.Sizeof(ImageSubresourceLayers{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageSubresourceLayers) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageSubresourceLayers) AsCPtr() *ImageSubresourceLayers {
	clone := (*ImageSubresourceLayers)(newCBlock(C.ulong(SizeofImageSubresourceLayers)))
	*clone = x
	return clone
}

// ImageSubresourceLayersFreeCSlice releases the memory allocated by ImageSubresourceLayersMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageSubresourceLayersFreeCSlice(x []ImageSubresourceLayers) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageSubresourceLayersMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageSubresourceLayersFreeCSlice must be called on the returned slice.
func ImageSubresourceLayersMakeCSlice(x ...ImageSubresourceLayers) []ImageSubresourceLayers {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageSubresourceLayers * len(x)
	dst := unsafe.Slice((*ImageSubresourceLayers)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// AspectMask returns the value of aspectMask from VkImageSubresourceLayers
func (x ImageSubresourceLayers) AspectMask() ImageAspectFlags {
	ptr := /* typedef */ (*ImageAspectFlags)(&x.aspectMask)
	return *ptr
}

// WithAspectMask sets the value for the AspectMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresourceLayers) WithAspectMask(y ImageAspectFlags) ImageSubresourceLayers {
	ptr := /* typedef */ (*C.VkImageAspectFlags)(&y)
	x.aspectMask = *ptr
	return x
}

// MipLevel returns the value of mipLevel from VkImageSubresourceLayers
func (x ImageSubresourceLayers) MipLevel() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.mipLevel)
	return *ptr
}

// WithMipLevel sets the value for the MipLevel on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresourceLayers) WithMipLevel(y uint32) ImageSubresourceLayers {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.mipLevel = *ptr
	return x
}

// BaseArrayLayer returns the value of baseArrayLayer from VkImageSubresourceLayers
func (x ImageSubresourceLayers) BaseArrayLayer() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.baseArrayLayer)
	return *ptr
}

// WithBaseArrayLayer sets the value for the BaseArrayLayer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresourceLayers) WithBaseArrayLayer(y uint32) ImageSubresourceLayers {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.baseArrayLayer = *ptr
	return x
}

// LayerCount returns the value of layerCount from VkImageSubresourceLayers
func (x ImageSubresourceLayers) LayerCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.layerCount)
	return *ptr
}

// WithLayerCount sets the value for the LayerCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresourceLayers) WithLayerCount(y uint32) ImageSubresourceLayers {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.layerCount = *ptr
	return x
}

//PipelineDynamicStateCreateInfo provides a go interface for VkPipelineDynamicStateCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineDynamicStateCreateInfo.html
type PipelineDynamicStateCreateInfo C.struct_VkPipelineDynamicStateCreateInfo

// SizeofPipelineDynamicStateCreateInfo is the memory size of a PipelineDynamicStateCreateInfo
var SizeofPipelineDynamicStateCreateInfo int = int(unsafe.Sizeof(PipelineDynamicStateCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineDynamicStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineDynamicStateCreateInfo) AsCPtr() *PipelineDynamicStateCreateInfo {
	clone := (*PipelineDynamicStateCreateInfo)(newCBlock(C.ulong(SizeofPipelineDynamicStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineDynamicStateCreateInfoFreeCSlice releases the memory allocated by PipelineDynamicStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineDynamicStateCreateInfoFreeCSlice(x []PipelineDynamicStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineDynamicStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineDynamicStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineDynamicStateCreateInfoMakeCSlice(x ...PipelineDynamicStateCreateInfo) []PipelineDynamicStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineDynamicStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineDynamicStateCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineDynamicStateCreateInfo
func (x PipelineDynamicStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineDynamicStateCreateInfo) WithDefaultSType() PipelineDynamicStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDynamicStateCreateInfo) WithSType(y StructureType) PipelineDynamicStateCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPipelineDynamicStateCreateInfo
func (x PipelineDynamicStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDynamicStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineDynamicStateCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkPipelineDynamicStateCreateInfo
func (x PipelineDynamicStateCreateInfo) Flags() PipelineDynamicStateCreateFlags {
	ptr := /* typedef */ (*PipelineDynamicStateCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDynamicStateCreateInfo) WithFlags(y PipelineDynamicStateCreateFlags) PipelineDynamicStateCreateInfo {
	ptr := /* typedef */ (*C.VkPipelineDynamicStateCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// DynamicStateCount returns the value of dynamicStateCount from VkPipelineDynamicStateCreateInfo
func (x PipelineDynamicStateCreateInfo) DynamicStateCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.dynamicStateCount)
	return *ptr
}

// WithDynamicStateCount sets the value for the DynamicStateCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDynamicStateCreateInfo) WithDynamicStateCount(y uint32) PipelineDynamicStateCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.dynamicStateCount = *ptr
	return x
}

// PDynamicStates returns the value of pDynamicStates from VkPipelineDynamicStateCreateInfo
func (x PipelineDynamicStateCreateInfo) PDynamicStates() []DynamicState {
	ptr := func(x **C.VkDynamicState) *[]DynamicState { /* Slice */
		slc := unsafe.Slice((*DynamicState)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pDynamicStates)
	return *ptr
}

// WithPDynamicStates sets the value for the PDynamicStates on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DynamicStateCount as the length of this field.
// DynamicStateCount is updated with the length of the new value.
func (x PipelineDynamicStateCreateInfo) WithPDynamicStates(y []DynamicState) PipelineDynamicStateCreateInfo {
	ptr := func(x *[]DynamicState) **C.VkDynamicState { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkDynamicState)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkDynamicState)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pDynamicStates = *ptr
	return x.WithDynamicStateCount(uint32(len(y)))
}

//RenderPassBeginInfo provides a go interface for VkRenderPassBeginInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkRenderPassBeginInfo.html
type RenderPassBeginInfo C.struct_VkRenderPassBeginInfo

// SizeofRenderPassBeginInfo is the memory size of a RenderPassBeginInfo
var SizeofRenderPassBeginInfo int = int(unsafe.Sizeof(RenderPassBeginInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *RenderPassBeginInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x RenderPassBeginInfo) AsCPtr() *RenderPassBeginInfo {
	clone := (*RenderPassBeginInfo)(newCBlock(C.ulong(SizeofRenderPassBeginInfo)))
	*clone = x
	return clone
}

// RenderPassBeginInfoFreeCSlice releases the memory allocated by RenderPassBeginInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func RenderPassBeginInfoFreeCSlice(x []RenderPassBeginInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// RenderPassBeginInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. RenderPassBeginInfoFreeCSlice must be called on the returned slice.
func RenderPassBeginInfoMakeCSlice(x ...RenderPassBeginInfo) []RenderPassBeginInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderPassBeginInfo * len(x)
	dst := unsafe.Slice((*RenderPassBeginInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkRenderPassBeginInfo
func (x RenderPassBeginInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x RenderPassBeginInfo) WithDefaultSType() RenderPassBeginInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassBeginInfo) WithSType(y StructureType) RenderPassBeginInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkRenderPassBeginInfo
func (x RenderPassBeginInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassBeginInfo) WithPNext(y unsafe.Pointer) RenderPassBeginInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// RenderPass returns the value of renderPass from VkRenderPassBeginInfo
func (x RenderPassBeginInfo) RenderPass() RenderPass {
	ptr := /* handle */ (*RenderPass)(&x.renderPass)
	return *ptr
}

// WithRenderPass sets the value for the RenderPass on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassBeginInfo) WithRenderPass(y RenderPass) RenderPassBeginInfo {
	ptr := /* handle */ (*C.VkRenderPass)(&y)
	x.renderPass = *ptr
	return x
}

// Framebuffer returns the value of framebuffer from VkRenderPassBeginInfo
func (x RenderPassBeginInfo) Framebuffer() Framebuffer {
	ptr := /* handle */ (*Framebuffer)(&x.framebuffer)
	return *ptr
}

// WithFramebuffer sets the value for the Framebuffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassBeginInfo) WithFramebuffer(y Framebuffer) RenderPassBeginInfo {
	ptr := /* handle */ (*C.VkFramebuffer)(&y)
	x.framebuffer = *ptr
	return x
}

// RenderArea returns the value of renderArea from VkRenderPassBeginInfo
func (x RenderPassBeginInfo) RenderArea() Rect2D {
	ptr := /* typedef */ (*Rect2D)(&x.renderArea)
	return *ptr
}

// WithRenderArea sets the value for the RenderArea on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassBeginInfo) WithRenderArea(y Rect2D) RenderPassBeginInfo {
	ptr := /* typedef */ (*C.struct_VkRect2D)(&y)
	x.renderArea = *ptr
	return x
}

// ClearValueCount returns the value of clearValueCount from VkRenderPassBeginInfo
func (x RenderPassBeginInfo) ClearValueCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.clearValueCount)
	return *ptr
}

// WithClearValueCount sets the value for the ClearValueCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassBeginInfo) WithClearValueCount(y uint32) RenderPassBeginInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.clearValueCount = *ptr
	return x
}

// PClearValues returns the value of pClearValues from VkRenderPassBeginInfo
func (x RenderPassBeginInfo) PClearValues() []ClearValue {
	ptr := func(x **C.VkClearValue) *[]ClearValue { /* Slice */
		slc := unsafe.Slice((*ClearValue)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pClearValues)
	return *ptr
}

// WithPClearValues sets the value for the PClearValues on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines ClearValueCount as the length of this field.
// ClearValueCount is updated with the length of the new value.
func (x RenderPassBeginInfo) WithPClearValues(y []ClearValue) RenderPassBeginInfo {
	ptr := func(x *[]ClearValue) **C.VkClearValue { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkClearValue)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkClearValue)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pClearValues = *ptr
	return x.WithClearValueCount(uint32(len(y)))
}

//PipelineInputAssemblyStateCreateInfo provides a go interface for VkPipelineInputAssemblyStateCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineInputAssemblyStateCreateInfo.html
type PipelineInputAssemblyStateCreateInfo C.struct_VkPipelineInputAssemblyStateCreateInfo

// SizeofPipelineInputAssemblyStateCreateInfo is the memory size of a PipelineInputAssemblyStateCreateInfo
var SizeofPipelineInputAssemblyStateCreateInfo int = int(unsafe.Sizeof(PipelineInputAssemblyStateCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineInputAssemblyStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineInputAssemblyStateCreateInfo) AsCPtr() *PipelineInputAssemblyStateCreateInfo {
	clone := (*PipelineInputAssemblyStateCreateInfo)(newCBlock(C.ulong(SizeofPipelineInputAssemblyStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineInputAssemblyStateCreateInfoFreeCSlice releases the memory allocated by PipelineInputAssemblyStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineInputAssemblyStateCreateInfoFreeCSlice(x []PipelineInputAssemblyStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineInputAssemblyStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineInputAssemblyStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineInputAssemblyStateCreateInfoMakeCSlice(x ...PipelineInputAssemblyStateCreateInfo) []PipelineInputAssemblyStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineInputAssemblyStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineInputAssemblyStateCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineInputAssemblyStateCreateInfo
func (x PipelineInputAssemblyStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineInputAssemblyStateCreateInfo) WithDefaultSType() PipelineInputAssemblyStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineInputAssemblyStateCreateInfo) WithSType(y StructureType) PipelineInputAssemblyStateCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPipelineInputAssemblyStateCreateInfo
func (x PipelineInputAssemblyStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineInputAssemblyStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineInputAssemblyStateCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkPipelineInputAssemblyStateCreateInfo
func (x PipelineInputAssemblyStateCreateInfo) Flags() PipelineInputAssemblyStateCreateFlags {
	ptr := /* typedef */ (*PipelineInputAssemblyStateCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineInputAssemblyStateCreateInfo) WithFlags(y PipelineInputAssemblyStateCreateFlags) PipelineInputAssemblyStateCreateInfo {
	ptr := /* typedef */ (*C.VkPipelineInputAssemblyStateCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// Topology returns the value of topology from VkPipelineInputAssemblyStateCreateInfo
func (x PipelineInputAssemblyStateCreateInfo) Topology() PrimitiveTopology {
	ptr := /* typedef */ (*PrimitiveTopology)(&x.topology)
	return *ptr
}

// WithTopology sets the value for the Topology on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineInputAssemblyStateCreateInfo) WithTopology(y PrimitiveTopology) PipelineInputAssemblyStateCreateInfo {
	ptr := /* typedef */ (*C.VkPrimitiveTopology)(&y)
	x.topology = *ptr
	return x
}

// PrimitiveRestartEnable returns the value of primitiveRestartEnable from VkPipelineInputAssemblyStateCreateInfo
func (x PipelineInputAssemblyStateCreateInfo) PrimitiveRestartEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.primitiveRestartEnable)
	return *ptr
}

// WithPrimitiveRestartEnable sets the value for the PrimitiveRestartEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineInputAssemblyStateCreateInfo) WithPrimitiveRestartEnable(y Bool32) PipelineInputAssemblyStateCreateInfo {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.primitiveRestartEnable = *ptr
	return x
}

//SamplerCreateInfo provides a go interface for VkSamplerCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSamplerCreateInfo.html
type SamplerCreateInfo C.struct_VkSamplerCreateInfo

// SizeofSamplerCreateInfo is the memory size of a SamplerCreateInfo
var SizeofSamplerCreateInfo int = int(unsafe.Sizeof(SamplerCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SamplerCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SamplerCreateInfo) AsCPtr() *SamplerCreateInfo {
	clone := (*SamplerCreateInfo)(newCBlock(C.ulong(SizeofSamplerCreateInfo)))
	*clone = x
	return clone
}

// SamplerCreateInfoFreeCSlice releases the memory allocated by SamplerCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SamplerCreateInfoFreeCSlice(x []SamplerCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SamplerCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SamplerCreateInfoFreeCSlice must be called on the returned slice.
func SamplerCreateInfoMakeCSlice(x ...SamplerCreateInfo) []SamplerCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSamplerCreateInfo * len(x)
	dst := unsafe.Slice((*SamplerCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSamplerCreateInfo
func (x SamplerCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SamplerCreateInfo) WithDefaultSType() SamplerCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithSType(y StructureType) SamplerCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkSamplerCreateInfo
func (x SamplerCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithPNext(y unsafe.Pointer) SamplerCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkSamplerCreateInfo
func (x SamplerCreateInfo) Flags() SamplerCreateFlags {
	ptr := /* typedef */ (*SamplerCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithFlags(y SamplerCreateFlags) SamplerCreateInfo {
	ptr := /* typedef */ (*C.VkSamplerCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// MagFilter returns the value of magFilter from VkSamplerCreateInfo
func (x SamplerCreateInfo) MagFilter() Filter {
	ptr := /* typedef */ (*Filter)(&x.magFilter)
	return *ptr
}

// WithMagFilter sets the value for the MagFilter on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithMagFilter(y Filter) SamplerCreateInfo {
	ptr := /* typedef */ (*C.VkFilter)(&y)
	x.magFilter = *ptr
	return x
}

// MinFilter returns the value of minFilter from VkSamplerCreateInfo
func (x SamplerCreateInfo) MinFilter() Filter {
	ptr := /* typedef */ (*Filter)(&x.minFilter)
	return *ptr
}

// WithMinFilter sets the value for the MinFilter on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithMinFilter(y Filter) SamplerCreateInfo {
	ptr := /* typedef */ (*C.VkFilter)(&y)
	x.minFilter = *ptr
	return x
}

// MipmapMode returns the value of mipmapMode from VkSamplerCreateInfo
func (x SamplerCreateInfo) MipmapMode() SamplerMipmapMode {
	ptr := /* typedef */ (*SamplerMipmapMode)(&x.mipmapMode)
	return *ptr
}

// WithMipmapMode sets the value for the MipmapMode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithMipmapMode(y SamplerMipmapMode) SamplerCreateInfo {
	ptr := /* typedef */ (*C.VkSamplerMipmapMode)(&y)
	x.mipmapMode = *ptr
	return x
}

// AddressModeU returns the value of addressModeU from VkSamplerCreateInfo
func (x SamplerCreateInfo) AddressModeU() SamplerAddressMode {
	ptr := /* typedef */ (*SamplerAddressMode)(&x.addressModeU)
	return *ptr
}

// WithAddressModeU sets the value for the AddressModeU on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithAddressModeU(y SamplerAddressMode) SamplerCreateInfo {
	ptr := /* typedef */ (*C.VkSamplerAddressMode)(&y)
	x.addressModeU = *ptr
	return x
}

// AddressModeV returns the value of addressModeV from VkSamplerCreateInfo
func (x SamplerCreateInfo) AddressModeV() SamplerAddressMode {
	ptr := /* typedef */ (*SamplerAddressMode)(&x.addressModeV)
	return *ptr
}

// WithAddressModeV sets the value for the AddressModeV on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithAddressModeV(y SamplerAddressMode) SamplerCreateInfo {
	ptr := /* typedef */ (*C.VkSamplerAddressMode)(&y)
	x.addressModeV = *ptr
	return x
}

// AddressModeW returns the value of addressModeW from VkSamplerCreateInfo
func (x SamplerCreateInfo) AddressModeW() SamplerAddressMode {
	ptr := /* typedef */ (*SamplerAddressMode)(&x.addressModeW)
	return *ptr
}

// WithAddressModeW sets the value for the AddressModeW on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithAddressModeW(y SamplerAddressMode) SamplerCreateInfo {
	ptr := /* typedef */ (*C.VkSamplerAddressMode)(&y)
	x.addressModeW = *ptr
	return x
}

// MipLodBias returns the value of mipLodBias from VkSamplerCreateInfo
func (x SamplerCreateInfo) MipLodBias() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ return (*float32)(unsafe.Pointer(x)) }(&x.mipLodBias)
	return *ptr
}

// WithMipLodBias sets the value for the MipLodBias on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithMipLodBias(y float32) SamplerCreateInfo {
	ptr := func(x *float32) *C.float { /* Scalar */ return (*C.float)(unsafe.Pointer(x)) }(&y)
	x.mipLodBias = *ptr
	return x
}

// AnisotropyEnable returns the value of anisotropyEnable from VkSamplerCreateInfo
func (x SamplerCreateInfo) AnisotropyEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.anisotropyEnable)
	return *ptr
}

// WithAnisotropyEnable sets the value for the AnisotropyEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithAnisotropyEnable(y Bool32) SamplerCreateInfo {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.anisotropyEnable = *ptr
	return x
}

// MaxAnisotropy returns the value of maxAnisotropy from VkSamplerCreateInfo
func (x SamplerCreateInfo) MaxAnisotropy() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ return (*float32)(unsafe.Pointer(x)) }(&x.maxAnisotropy)
	return *ptr
}

// WithMaxAnisotropy sets the value for the MaxAnisotropy on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithMaxAnisotropy(y float32) SamplerCreateInfo {
	ptr := func(x *float32) *C.float { /* Scalar */ return (*C.float)(unsafe.Pointer(x)) }(&y)
	x.maxAnisotropy = *ptr
	return x
}

// CompareEnable returns the value of compareEnable from VkSamplerCreateInfo
func (x SamplerCreateInfo) CompareEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.compareEnable)
	return *ptr
}

// WithCompareEnable sets the value for the CompareEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithCompareEnable(y Bool32) SamplerCreateInfo {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.compareEnable = *ptr
	return x
}

// CompareOp returns the value of compareOp from VkSamplerCreateInfo
func (x SamplerCreateInfo) CompareOp() CompareOp {
	ptr := /* typedef */ (*CompareOp)(&x.compareOp)
	return *ptr
}

// WithCompareOp sets the value for the CompareOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithCompareOp(y CompareOp) SamplerCreateInfo {
	ptr := /* typedef */ (*C.VkCompareOp)(&y)
	x.compareOp = *ptr
	return x
}

// MinLod returns the value of minLod from VkSamplerCreateInfo
func (x SamplerCreateInfo) MinLod() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ return (*float32)(unsafe.Pointer(x)) }(&x.minLod)
	return *ptr
}

// WithMinLod sets the value for the MinLod on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithMinLod(y float32) SamplerCreateInfo {
	ptr := func(x *float32) *C.float { /* Scalar */ return (*C.float)(unsafe.Pointer(x)) }(&y)
	x.minLod = *ptr
	return x
}

// MaxLod returns the value of maxLod from VkSamplerCreateInfo
func (x SamplerCreateInfo) MaxLod() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ return (*float32)(unsafe.Pointer(x)) }(&x.maxLod)
	return *ptr
}

// WithMaxLod sets the value for the MaxLod on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithMaxLod(y float32) SamplerCreateInfo {
	ptr := func(x *float32) *C.float { /* Scalar */ return (*C.float)(unsafe.Pointer(x)) }(&y)
	x.maxLod = *ptr
	return x
}

// BorderColor returns the value of borderColor from VkSamplerCreateInfo
func (x SamplerCreateInfo) BorderColor() BorderColor {
	ptr := /* typedef */ (*BorderColor)(&x.borderColor)
	return *ptr
}

// WithBorderColor sets the value for the BorderColor on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithBorderColor(y BorderColor) SamplerCreateInfo {
	ptr := /* typedef */ (*C.VkBorderColor)(&y)
	x.borderColor = *ptr
	return x
}

// UnnormalizedCoordinates returns the value of unnormalizedCoordinates from VkSamplerCreateInfo
func (x SamplerCreateInfo) UnnormalizedCoordinates() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.unnormalizedCoordinates)
	return *ptr
}

// WithUnnormalizedCoordinates sets the value for the UnnormalizedCoordinates on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithUnnormalizedCoordinates(y Bool32) SamplerCreateInfo {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.unnormalizedCoordinates = *ptr
	return x
}

//DescriptorImageInfo provides a go interface for VkDescriptorImageInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorImageInfo.html
type DescriptorImageInfo C.struct_VkDescriptorImageInfo

// SizeofDescriptorImageInfo is the memory size of a DescriptorImageInfo
var SizeofDescriptorImageInfo int = int(unsafe.Sizeof(DescriptorImageInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorImageInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorImageInfo) AsCPtr() *DescriptorImageInfo {
	clone := (*DescriptorImageInfo)(newCBlock(C.ulong(SizeofDescriptorImageInfo)))
	*clone = x
	return clone
}

// DescriptorImageInfoFreeCSlice releases the memory allocated by DescriptorImageInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorImageInfoFreeCSlice(x []DescriptorImageInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorImageInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorImageInfoFreeCSlice must be called on the returned slice.
func DescriptorImageInfoMakeCSlice(x ...DescriptorImageInfo) []DescriptorImageInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorImageInfo * len(x)
	dst := unsafe.Slice((*DescriptorImageInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Sampler returns the value of sampler from VkDescriptorImageInfo
func (x DescriptorImageInfo) Sampler() Sampler {
	ptr := /* handle */ (*Sampler)(&x.sampler)
	return *ptr
}

// WithSampler sets the value for the Sampler on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorImageInfo) WithSampler(y Sampler) DescriptorImageInfo {
	ptr := /* handle */ (*C.VkSampler)(&y)
	x.sampler = *ptr
	return x
}

// ImageView returns the value of imageView from VkDescriptorImageInfo
func (x DescriptorImageInfo) ImageView() ImageView {
	ptr := /* handle */ (*ImageView)(&x.imageView)
	return *ptr
}

// WithImageView sets the value for the ImageView on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorImageInfo) WithImageView(y ImageView) DescriptorImageInfo {
	ptr := /* handle */ (*C.VkImageView)(&y)
	x.imageView = *ptr
	return x
}

// ImageLayout returns the value of imageLayout from VkDescriptorImageInfo
func (x DescriptorImageInfo) ImageLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.imageLayout)
	return *ptr
}

// WithImageLayout sets the value for the ImageLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorImageInfo) WithImageLayout(y ImageLayout) DescriptorImageInfo {
	ptr := /* typedef */ (*C.VkImageLayout)(&y)
	x.imageLayout = *ptr
	return x
}

//PipelineMultisampleStateCreateInfo provides a go interface for VkPipelineMultisampleStateCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineMultisampleStateCreateInfo.html
type PipelineMultisampleStateCreateInfo C.struct_VkPipelineMultisampleStateCreateInfo

// SizeofPipelineMultisampleStateCreateInfo is the memory size of a PipelineMultisampleStateCreateInfo
var SizeofPipelineMultisampleStateCreateInfo int = int(unsafe.Sizeof(PipelineMultisampleStateCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineMultisampleStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineMultisampleStateCreateInfo) AsCPtr() *PipelineMultisampleStateCreateInfo {
	clone := (*PipelineMultisampleStateCreateInfo)(newCBlock(C.ulong(SizeofPipelineMultisampleStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineMultisampleStateCreateInfoFreeCSlice releases the memory allocated by PipelineMultisampleStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineMultisampleStateCreateInfoFreeCSlice(x []PipelineMultisampleStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineMultisampleStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineMultisampleStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineMultisampleStateCreateInfoMakeCSlice(x ...PipelineMultisampleStateCreateInfo) []PipelineMultisampleStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineMultisampleStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineMultisampleStateCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineMultisampleStateCreateInfo
func (x PipelineMultisampleStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineMultisampleStateCreateInfo) WithDefaultSType() PipelineMultisampleStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineMultisampleStateCreateInfo) WithSType(y StructureType) PipelineMultisampleStateCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPipelineMultisampleStateCreateInfo
func (x PipelineMultisampleStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineMultisampleStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineMultisampleStateCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkPipelineMultisampleStateCreateInfo
func (x PipelineMultisampleStateCreateInfo) Flags() PipelineMultisampleStateCreateFlags {
	ptr := /* typedef */ (*PipelineMultisampleStateCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineMultisampleStateCreateInfo) WithFlags(y PipelineMultisampleStateCreateFlags) PipelineMultisampleStateCreateInfo {
	ptr := /* typedef */ (*C.VkPipelineMultisampleStateCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// RasterizationSamples returns the value of rasterizationSamples from VkPipelineMultisampleStateCreateInfo
func (x PipelineMultisampleStateCreateInfo) RasterizationSamples() SampleCountFlagBits {
	ptr := /* typedef */ (*SampleCountFlagBits)(&x.rasterizationSamples)
	return *ptr
}

// WithRasterizationSamples sets the value for the RasterizationSamples on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineMultisampleStateCreateInfo) WithRasterizationSamples(y SampleCountFlagBits) PipelineMultisampleStateCreateInfo {
	ptr := /* typedef */ (*C.VkSampleCountFlagBits)(&y)
	x.rasterizationSamples = *ptr
	return x
}

// SampleShadingEnable returns the value of sampleShadingEnable from VkPipelineMultisampleStateCreateInfo
func (x PipelineMultisampleStateCreateInfo) SampleShadingEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sampleShadingEnable)
	return *ptr
}

// WithSampleShadingEnable sets the value for the SampleShadingEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineMultisampleStateCreateInfo) WithSampleShadingEnable(y Bool32) PipelineMultisampleStateCreateInfo {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.sampleShadingEnable = *ptr
	return x
}

// MinSampleShading returns the value of minSampleShading from VkPipelineMultisampleStateCreateInfo
func (x PipelineMultisampleStateCreateInfo) MinSampleShading() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ return (*float32)(unsafe.Pointer(x)) }(&x.minSampleShading)
	return *ptr
}

// WithMinSampleShading sets the value for the MinSampleShading on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineMultisampleStateCreateInfo) WithMinSampleShading(y float32) PipelineMultisampleStateCreateInfo {
	ptr := func(x *float32) *C.float { /* Scalar */ return (*C.float)(unsafe.Pointer(x)) }(&y)
	x.minSampleShading = *ptr
	return x
}

// PSampleMask returns the value of pSampleMask from VkPipelineMultisampleStateCreateInfo
func (x PipelineMultisampleStateCreateInfo) PSampleMask() []SampleMask {
	ptr := func(x **C.VkSampleMask) *[]SampleMask { /* Slice */
		slc := unsafe.Slice((*SampleMask)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pSampleMask)
	return *ptr
}

// WithPSampleMask sets the value for the PSampleMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineMultisampleStateCreateInfo) WithPSampleMask(y []SampleMask) PipelineMultisampleStateCreateInfo {
	ptr := func(x *[]SampleMask) **C.VkSampleMask { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSampleMask)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSampleMask)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pSampleMask = *ptr
	return x
}

// AlphaToCoverageEnable returns the value of alphaToCoverageEnable from VkPipelineMultisampleStateCreateInfo
func (x PipelineMultisampleStateCreateInfo) AlphaToCoverageEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.alphaToCoverageEnable)
	return *ptr
}

// WithAlphaToCoverageEnable sets the value for the AlphaToCoverageEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineMultisampleStateCreateInfo) WithAlphaToCoverageEnable(y Bool32) PipelineMultisampleStateCreateInfo {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.alphaToCoverageEnable = *ptr
	return x
}

// AlphaToOneEnable returns the value of alphaToOneEnable from VkPipelineMultisampleStateCreateInfo
func (x PipelineMultisampleStateCreateInfo) AlphaToOneEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.alphaToOneEnable)
	return *ptr
}

// WithAlphaToOneEnable sets the value for the AlphaToOneEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineMultisampleStateCreateInfo) WithAlphaToOneEnable(y Bool32) PipelineMultisampleStateCreateInfo {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.alphaToOneEnable = *ptr
	return x
}

//PipelineCacheHeaderVersionOne provides a go interface for VkPipelineCacheHeaderVersionOne.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineCacheHeaderVersionOne.html
type PipelineCacheHeaderVersionOne C.struct_VkPipelineCacheHeaderVersionOne

// SizeofPipelineCacheHeaderVersionOne is the memory size of a PipelineCacheHeaderVersionOne
var SizeofPipelineCacheHeaderVersionOne int = int(unsafe.Sizeof(PipelineCacheHeaderVersionOne{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineCacheHeaderVersionOne) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineCacheHeaderVersionOne) AsCPtr() *PipelineCacheHeaderVersionOne {
	clone := (*PipelineCacheHeaderVersionOne)(newCBlock(C.ulong(SizeofPipelineCacheHeaderVersionOne)))
	*clone = x
	return clone
}

// PipelineCacheHeaderVersionOneFreeCSlice releases the memory allocated by PipelineCacheHeaderVersionOneMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineCacheHeaderVersionOneFreeCSlice(x []PipelineCacheHeaderVersionOne) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineCacheHeaderVersionOneMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineCacheHeaderVersionOneFreeCSlice must be called on the returned slice.
func PipelineCacheHeaderVersionOneMakeCSlice(x ...PipelineCacheHeaderVersionOne) []PipelineCacheHeaderVersionOne {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineCacheHeaderVersionOne * len(x)
	dst := unsafe.Slice((*PipelineCacheHeaderVersionOne)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// HeaderSize returns the value of headerSize from VkPipelineCacheHeaderVersionOne
func (x PipelineCacheHeaderVersionOne) HeaderSize() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.headerSize)
	return *ptr
}

// WithHeaderSize sets the value for the HeaderSize on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheHeaderVersionOne) WithHeaderSize(y uint32) PipelineCacheHeaderVersionOne {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.headerSize = *ptr
	return x
}

// HeaderVersion returns the value of headerVersion from VkPipelineCacheHeaderVersionOne
func (x PipelineCacheHeaderVersionOne) HeaderVersion() PipelineCacheHeaderVersion {
	ptr := /* typedef */ (*PipelineCacheHeaderVersion)(&x.headerVersion)
	return *ptr
}

// WithHeaderVersion sets the value for the HeaderVersion on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheHeaderVersionOne) WithHeaderVersion(y PipelineCacheHeaderVersion) PipelineCacheHeaderVersionOne {
	ptr := /* typedef */ (*C.VkPipelineCacheHeaderVersion)(&y)
	x.headerVersion = *ptr
	return x
}

// VendorID returns the value of vendorID from VkPipelineCacheHeaderVersionOne
func (x PipelineCacheHeaderVersionOne) VendorID() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.vendorID)
	return *ptr
}

// WithVendorID sets the value for the VendorID on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheHeaderVersionOne) WithVendorID(y uint32) PipelineCacheHeaderVersionOne {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.vendorID = *ptr
	return x
}

// DeviceID returns the value of deviceID from VkPipelineCacheHeaderVersionOne
func (x PipelineCacheHeaderVersionOne) DeviceID() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.deviceID)
	return *ptr
}

// WithDeviceID sets the value for the DeviceID on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheHeaderVersionOne) WithDeviceID(y uint32) PipelineCacheHeaderVersionOne {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.deviceID = *ptr
	return x
}

// PipelineCacheUUID returns the value of pipelineCacheUUID from VkPipelineCacheHeaderVersionOne
func (x PipelineCacheHeaderVersionOne) PipelineCacheUUID() []byte {
	ptr := func(x *[VK_UUID_SIZE]C.uchar) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_UUID_SIZE)
		return &slc
	}(&x.pipelineCacheUUID)
	return *ptr
}

// WithPipelineCacheUUID sets the value for the PipelineCacheUUID on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheHeaderVersionOne) WithPipelineCacheUUID(y []byte) PipelineCacheHeaderVersionOne {
	ptr := func(x *[]byte) **C.uchar { /* Array */
		if len(*x) > 0 {
			slc := (*C.uchar)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uchar)(unsafe.Pointer((&ptr)))
	}(&y)
	copy(x.pipelineCacheUUID[:], unsafe.Slice(*ptr, len(y)))
	return x
}

//PipelineRasterizationStateCreateInfo provides a go interface for VkPipelineRasterizationStateCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineRasterizationStateCreateInfo.html
type PipelineRasterizationStateCreateInfo C.struct_VkPipelineRasterizationStateCreateInfo

// SizeofPipelineRasterizationStateCreateInfo is the memory size of a PipelineRasterizationStateCreateInfo
var SizeofPipelineRasterizationStateCreateInfo int = int(unsafe.Sizeof(PipelineRasterizationStateCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineRasterizationStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineRasterizationStateCreateInfo) AsCPtr() *PipelineRasterizationStateCreateInfo {
	clone := (*PipelineRasterizationStateCreateInfo)(newCBlock(C.ulong(SizeofPipelineRasterizationStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineRasterizationStateCreateInfoFreeCSlice releases the memory allocated by PipelineRasterizationStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineRasterizationStateCreateInfoFreeCSlice(x []PipelineRasterizationStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineRasterizationStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineRasterizationStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineRasterizationStateCreateInfoMakeCSlice(x ...PipelineRasterizationStateCreateInfo) []PipelineRasterizationStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineRasterizationStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineRasterizationStateCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineRasterizationStateCreateInfo) WithDefaultSType() PipelineRasterizationStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithSType(y StructureType) PipelineRasterizationStateCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineRasterizationStateCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) Flags() PipelineRasterizationStateCreateFlags {
	ptr := /* typedef */ (*PipelineRasterizationStateCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithFlags(y PipelineRasterizationStateCreateFlags) PipelineRasterizationStateCreateInfo {
	ptr := /* typedef */ (*C.VkPipelineRasterizationStateCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// DepthClampEnable returns the value of depthClampEnable from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) DepthClampEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.depthClampEnable)
	return *ptr
}

// WithDepthClampEnable sets the value for the DepthClampEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithDepthClampEnable(y Bool32) PipelineRasterizationStateCreateInfo {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.depthClampEnable = *ptr
	return x
}

// RasterizerDiscardEnable returns the value of rasterizerDiscardEnable from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) RasterizerDiscardEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.rasterizerDiscardEnable)
	return *ptr
}

// WithRasterizerDiscardEnable sets the value for the RasterizerDiscardEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithRasterizerDiscardEnable(y Bool32) PipelineRasterizationStateCreateInfo {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.rasterizerDiscardEnable = *ptr
	return x
}

// PolygonMode returns the value of polygonMode from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) PolygonMode() PolygonMode {
	ptr := /* typedef */ (*PolygonMode)(&x.polygonMode)
	return *ptr
}

// WithPolygonMode sets the value for the PolygonMode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithPolygonMode(y PolygonMode) PipelineRasterizationStateCreateInfo {
	ptr := /* typedef */ (*C.VkPolygonMode)(&y)
	x.polygonMode = *ptr
	return x
}

// CullMode returns the value of cullMode from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) CullMode() CullModeFlags {
	ptr := /* typedef */ (*CullModeFlags)(&x.cullMode)
	return *ptr
}

// WithCullMode sets the value for the CullMode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithCullMode(y CullModeFlags) PipelineRasterizationStateCreateInfo {
	ptr := /* typedef */ (*C.VkCullModeFlags)(&y)
	x.cullMode = *ptr
	return x
}

// FrontFace returns the value of frontFace from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) FrontFace() FrontFace {
	ptr := /* typedef */ (*FrontFace)(&x.frontFace)
	return *ptr
}

// WithFrontFace sets the value for the FrontFace on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithFrontFace(y FrontFace) PipelineRasterizationStateCreateInfo {
	ptr := /* typedef */ (*C.VkFrontFace)(&y)
	x.frontFace = *ptr
	return x
}

// DepthBiasEnable returns the value of depthBiasEnable from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) DepthBiasEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.depthBiasEnable)
	return *ptr
}

// WithDepthBiasEnable sets the value for the DepthBiasEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithDepthBiasEnable(y Bool32) PipelineRasterizationStateCreateInfo {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.depthBiasEnable = *ptr
	return x
}

// DepthBiasConstantFactor returns the value of depthBiasConstantFactor from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) DepthBiasConstantFactor() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ return (*float32)(unsafe.Pointer(x)) }(&x.depthBiasConstantFactor)
	return *ptr
}

// WithDepthBiasConstantFactor sets the value for the DepthBiasConstantFactor on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithDepthBiasConstantFactor(y float32) PipelineRasterizationStateCreateInfo {
	ptr := func(x *float32) *C.float { /* Scalar */ return (*C.float)(unsafe.Pointer(x)) }(&y)
	x.depthBiasConstantFactor = *ptr
	return x
}

// DepthBiasClamp returns the value of depthBiasClamp from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) DepthBiasClamp() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ return (*float32)(unsafe.Pointer(x)) }(&x.depthBiasClamp)
	return *ptr
}

// WithDepthBiasClamp sets the value for the DepthBiasClamp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithDepthBiasClamp(y float32) PipelineRasterizationStateCreateInfo {
	ptr := func(x *float32) *C.float { /* Scalar */ return (*C.float)(unsafe.Pointer(x)) }(&y)
	x.depthBiasClamp = *ptr
	return x
}

// DepthBiasSlopeFactor returns the value of depthBiasSlopeFactor from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) DepthBiasSlopeFactor() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ return (*float32)(unsafe.Pointer(x)) }(&x.depthBiasSlopeFactor)
	return *ptr
}

// WithDepthBiasSlopeFactor sets the value for the DepthBiasSlopeFactor on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithDepthBiasSlopeFactor(y float32) PipelineRasterizationStateCreateInfo {
	ptr := func(x *float32) *C.float { /* Scalar */ return (*C.float)(unsafe.Pointer(x)) }(&y)
	x.depthBiasSlopeFactor = *ptr
	return x
}

// LineWidth returns the value of lineWidth from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) LineWidth() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ return (*float32)(unsafe.Pointer(x)) }(&x.lineWidth)
	return *ptr
}

// WithLineWidth sets the value for the LineWidth on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithLineWidth(y float32) PipelineRasterizationStateCreateInfo {
	ptr := func(x *float32) *C.float { /* Scalar */ return (*C.float)(unsafe.Pointer(x)) }(&y)
	x.lineWidth = *ptr
	return x
}

//MemoryBarrier provides a go interface for VkMemoryBarrier.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkMemoryBarrier.html
type MemoryBarrier C.struct_VkMemoryBarrier

// SizeofMemoryBarrier is the memory size of a MemoryBarrier
var SizeofMemoryBarrier int = int(unsafe.Sizeof(MemoryBarrier{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryBarrier) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryBarrier) AsCPtr() *MemoryBarrier {
	clone := (*MemoryBarrier)(newCBlock(C.ulong(SizeofMemoryBarrier)))
	*clone = x
	return clone
}

// MemoryBarrierFreeCSlice releases the memory allocated by MemoryBarrierMakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryBarrierFreeCSlice(x []MemoryBarrier) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryBarrierMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryBarrierFreeCSlice must be called on the returned slice.
func MemoryBarrierMakeCSlice(x ...MemoryBarrier) []MemoryBarrier {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryBarrier * len(x)
	dst := unsafe.Slice((*MemoryBarrier)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkMemoryBarrier
func (x MemoryBarrier) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x MemoryBarrier) WithDefaultSType() MemoryBarrier {
	return x.WithSType(VK_STRUCTURE_TYPE_MEMORY_BARRIER)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryBarrier) WithSType(y StructureType) MemoryBarrier {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkMemoryBarrier
func (x MemoryBarrier) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryBarrier) WithPNext(y unsafe.Pointer) MemoryBarrier {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// SrcAccessMask returns the value of srcAccessMask from VkMemoryBarrier
func (x MemoryBarrier) SrcAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.srcAccessMask)
	return *ptr
}

// WithSrcAccessMask sets the value for the SrcAccessMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryBarrier) WithSrcAccessMask(y AccessFlags) MemoryBarrier {
	ptr := /* typedef */ (*C.VkAccessFlags)(&y)
	x.srcAccessMask = *ptr
	return x
}

// DstAccessMask returns the value of dstAccessMask from VkMemoryBarrier
func (x MemoryBarrier) DstAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.dstAccessMask)
	return *ptr
}

// WithDstAccessMask sets the value for the DstAccessMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryBarrier) WithDstAccessMask(y AccessFlags) MemoryBarrier {
	ptr := /* typedef */ (*C.VkAccessFlags)(&y)
	x.dstAccessMask = *ptr
	return x
}

//ImageMemoryBarrier provides a go interface for VkImageMemoryBarrier.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageMemoryBarrier.html
type ImageMemoryBarrier C.struct_VkImageMemoryBarrier

// SizeofImageMemoryBarrier is the memory size of a ImageMemoryBarrier
var SizeofImageMemoryBarrier int = int(unsafe.Sizeof(ImageMemoryBarrier{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageMemoryBarrier) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageMemoryBarrier) AsCPtr() *ImageMemoryBarrier {
	clone := (*ImageMemoryBarrier)(newCBlock(C.ulong(SizeofImageMemoryBarrier)))
	*clone = x
	return clone
}

// ImageMemoryBarrierFreeCSlice releases the memory allocated by ImageMemoryBarrierMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageMemoryBarrierFreeCSlice(x []ImageMemoryBarrier) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageMemoryBarrierMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageMemoryBarrierFreeCSlice must be called on the returned slice.
func ImageMemoryBarrierMakeCSlice(x ...ImageMemoryBarrier) []ImageMemoryBarrier {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageMemoryBarrier * len(x)
	dst := unsafe.Slice((*ImageMemoryBarrier)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageMemoryBarrier
func (x ImageMemoryBarrier) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ImageMemoryBarrier) WithDefaultSType() ImageMemoryBarrier {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithSType(y StructureType) ImageMemoryBarrier {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkImageMemoryBarrier
func (x ImageMemoryBarrier) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithPNext(y unsafe.Pointer) ImageMemoryBarrier {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// SrcAccessMask returns the value of srcAccessMask from VkImageMemoryBarrier
func (x ImageMemoryBarrier) SrcAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.srcAccessMask)
	return *ptr
}

// WithSrcAccessMask sets the value for the SrcAccessMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithSrcAccessMask(y AccessFlags) ImageMemoryBarrier {
	ptr := /* typedef */ (*C.VkAccessFlags)(&y)
	x.srcAccessMask = *ptr
	return x
}

// DstAccessMask returns the value of dstAccessMask from VkImageMemoryBarrier
func (x ImageMemoryBarrier) DstAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.dstAccessMask)
	return *ptr
}

// WithDstAccessMask sets the value for the DstAccessMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithDstAccessMask(y AccessFlags) ImageMemoryBarrier {
	ptr := /* typedef */ (*C.VkAccessFlags)(&y)
	x.dstAccessMask = *ptr
	return x
}

// OldLayout returns the value of oldLayout from VkImageMemoryBarrier
func (x ImageMemoryBarrier) OldLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.oldLayout)
	return *ptr
}

// WithOldLayout sets the value for the OldLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithOldLayout(y ImageLayout) ImageMemoryBarrier {
	ptr := /* typedef */ (*C.VkImageLayout)(&y)
	x.oldLayout = *ptr
	return x
}

// NewLayout returns the value of newLayout from VkImageMemoryBarrier
func (x ImageMemoryBarrier) NewLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.newLayout)
	return *ptr
}

// WithNewLayout sets the value for the NewLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithNewLayout(y ImageLayout) ImageMemoryBarrier {
	ptr := /* typedef */ (*C.VkImageLayout)(&y)
	x.newLayout = *ptr
	return x
}

// SrcQueueFamilyIndex returns the value of srcQueueFamilyIndex from VkImageMemoryBarrier
func (x ImageMemoryBarrier) SrcQueueFamilyIndex() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.srcQueueFamilyIndex)
	return *ptr
}

// WithSrcQueueFamilyIndex sets the value for the SrcQueueFamilyIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithSrcQueueFamilyIndex(y uint32) ImageMemoryBarrier {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.srcQueueFamilyIndex = *ptr
	return x
}

// DstQueueFamilyIndex returns the value of dstQueueFamilyIndex from VkImageMemoryBarrier
func (x ImageMemoryBarrier) DstQueueFamilyIndex() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.dstQueueFamilyIndex)
	return *ptr
}

// WithDstQueueFamilyIndex sets the value for the DstQueueFamilyIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithDstQueueFamilyIndex(y uint32) ImageMemoryBarrier {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.dstQueueFamilyIndex = *ptr
	return x
}

// Image returns the value of image from VkImageMemoryBarrier
func (x ImageMemoryBarrier) Image() Image {
	ptr := /* handle */ (*Image)(&x.image)
	return *ptr
}

// WithImage sets the value for the Image on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithImage(y Image) ImageMemoryBarrier {
	ptr := /* handle */ (*C.VkImage)(&y)
	x.image = *ptr
	return x
}

// SubresourceRange returns the value of subresourceRange from VkImageMemoryBarrier
func (x ImageMemoryBarrier) SubresourceRange() ImageSubresourceRange {
	ptr := /* typedef */ (*ImageSubresourceRange)(&x.subresourceRange)
	return *ptr
}

// WithSubresourceRange sets the value for the SubresourceRange on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithSubresourceRange(y ImageSubresourceRange) ImageMemoryBarrier {
	ptr := /* typedef */ (*C.struct_VkImageSubresourceRange)(&y)
	x.subresourceRange = *ptr
	return x
}

//PipelineShaderStageCreateInfo provides a go interface for VkPipelineShaderStageCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineShaderStageCreateInfo.html
type PipelineShaderStageCreateInfo C.struct_VkPipelineShaderStageCreateInfo

// SizeofPipelineShaderStageCreateInfo is the memory size of a PipelineShaderStageCreateInfo
var SizeofPipelineShaderStageCreateInfo int = int(unsafe.Sizeof(PipelineShaderStageCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineShaderStageCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineShaderStageCreateInfo) AsCPtr() *PipelineShaderStageCreateInfo {
	clone := (*PipelineShaderStageCreateInfo)(newCBlock(C.ulong(SizeofPipelineShaderStageCreateInfo)))
	*clone = x
	return clone
}

// PipelineShaderStageCreateInfoFreeCSlice releases the memory allocated by PipelineShaderStageCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineShaderStageCreateInfoFreeCSlice(x []PipelineShaderStageCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineShaderStageCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineShaderStageCreateInfoFreeCSlice must be called on the returned slice.
func PipelineShaderStageCreateInfoMakeCSlice(x ...PipelineShaderStageCreateInfo) []PipelineShaderStageCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineShaderStageCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineShaderStageCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineShaderStageCreateInfo
func (x PipelineShaderStageCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineShaderStageCreateInfo) WithDefaultSType() PipelineShaderStageCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineShaderStageCreateInfo) WithSType(y StructureType) PipelineShaderStageCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPipelineShaderStageCreateInfo
func (x PipelineShaderStageCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineShaderStageCreateInfo) WithPNext(y unsafe.Pointer) PipelineShaderStageCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkPipelineShaderStageCreateInfo
func (x PipelineShaderStageCreateInfo) Flags() PipelineShaderStageCreateFlags {
	ptr := /* typedef */ (*PipelineShaderStageCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineShaderStageCreateInfo) WithFlags(y PipelineShaderStageCreateFlags) PipelineShaderStageCreateInfo {
	ptr := /* typedef */ (*C.VkPipelineShaderStageCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// Stage returns the value of stage from VkPipelineShaderStageCreateInfo
func (x PipelineShaderStageCreateInfo) Stage() ShaderStageFlagBits {
	ptr := /* typedef */ (*ShaderStageFlagBits)(&x.stage)
	return *ptr
}

// WithStage sets the value for the Stage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineShaderStageCreateInfo) WithStage(y ShaderStageFlagBits) PipelineShaderStageCreateInfo {
	ptr := /* typedef */ (*C.VkShaderStageFlagBits)(&y)
	x.stage = *ptr
	return x
}

// Module returns the value of module from VkPipelineShaderStageCreateInfo
func (x PipelineShaderStageCreateInfo) Module() ShaderModule {
	ptr := /* handle */ (*ShaderModule)(&x.module)
	return *ptr
}

// WithModule sets the value for the Module on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineShaderStageCreateInfo) WithModule(y ShaderModule) PipelineShaderStageCreateInfo {
	ptr := /* handle */ (*C.VkShaderModule)(&y)
	x.module = *ptr
	return x
}

// PName returns the value of pName from VkPipelineShaderStageCreateInfo
func (x PipelineShaderStageCreateInfo) PName() *byte {
	ptr := func(x **C.char) **byte { /* Pointer */ return (**byte)(unsafe.Pointer(x)) }(&x.pName)
	return *ptr
}

// WithPName sets the value for the PName on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineShaderStageCreateInfo) WithPName(y *byte) PipelineShaderStageCreateInfo {
	ptr := func(x **byte) **C.char { /* Pointer */ return (**C.char)(unsafe.Pointer(x)) }(&y)
	x.pName = *ptr
	return x
}

// PSpecializationInfo returns the value of pSpecializationInfo from VkPipelineShaderStageCreateInfo
func (x PipelineShaderStageCreateInfo) PSpecializationInfo() *SpecializationInfo {
	ptr := func(x **C.struct_VkSpecializationInfo) **SpecializationInfo { /* Pointer */
		return (**SpecializationInfo)(unsafe.Pointer(x))
	}(&x.pSpecializationInfo)
	return *ptr
}

// WithPSpecializationInfo sets the value for the PSpecializationInfo on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineShaderStageCreateInfo) WithPSpecializationInfo(y *SpecializationInfo) PipelineShaderStageCreateInfo {
	ptr := func(x **SpecializationInfo) **C.struct_VkSpecializationInfo { /* Pointer */
		return (**C.struct_VkSpecializationInfo)(unsafe.Pointer(x))
	}(&y)
	x.pSpecializationInfo = *ptr
	return x
}

//DrawIndirectCommand provides a go interface for VkDrawIndirectCommand.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDrawIndirectCommand.html
type DrawIndirectCommand C.struct_VkDrawIndirectCommand

// SizeofDrawIndirectCommand is the memory size of a DrawIndirectCommand
var SizeofDrawIndirectCommand int = int(unsafe.Sizeof(DrawIndirectCommand{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DrawIndirectCommand) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DrawIndirectCommand) AsCPtr() *DrawIndirectCommand {
	clone := (*DrawIndirectCommand)(newCBlock(C.ulong(SizeofDrawIndirectCommand)))
	*clone = x
	return clone
}

// DrawIndirectCommandFreeCSlice releases the memory allocated by DrawIndirectCommandMakeCSlice.
// It does not free pointers stored inside the slice.
func DrawIndirectCommandFreeCSlice(x []DrawIndirectCommand) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DrawIndirectCommandMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DrawIndirectCommandFreeCSlice must be called on the returned slice.
func DrawIndirectCommandMakeCSlice(x ...DrawIndirectCommand) []DrawIndirectCommand {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDrawIndirectCommand * len(x)
	dst := unsafe.Slice((*DrawIndirectCommand)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// VertexCount returns the value of vertexCount from VkDrawIndirectCommand
func (x DrawIndirectCommand) VertexCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.vertexCount)
	return *ptr
}

// WithVertexCount sets the value for the VertexCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DrawIndirectCommand) WithVertexCount(y uint32) DrawIndirectCommand {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.vertexCount = *ptr
	return x
}

// InstanceCount returns the value of instanceCount from VkDrawIndirectCommand
func (x DrawIndirectCommand) InstanceCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.instanceCount)
	return *ptr
}

// WithInstanceCount sets the value for the InstanceCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DrawIndirectCommand) WithInstanceCount(y uint32) DrawIndirectCommand {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.instanceCount = *ptr
	return x
}

// FirstVertex returns the value of firstVertex from VkDrawIndirectCommand
func (x DrawIndirectCommand) FirstVertex() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.firstVertex)
	return *ptr
}

// WithFirstVertex sets the value for the FirstVertex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DrawIndirectCommand) WithFirstVertex(y uint32) DrawIndirectCommand {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.firstVertex = *ptr
	return x
}

// FirstInstance returns the value of firstInstance from VkDrawIndirectCommand
func (x DrawIndirectCommand) FirstInstance() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.firstInstance)
	return *ptr
}

// WithFirstInstance sets the value for the FirstInstance on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DrawIndirectCommand) WithFirstInstance(y uint32) DrawIndirectCommand {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.firstInstance = *ptr
	return x
}

//PipelineTessellationStateCreateInfo provides a go interface for VkPipelineTessellationStateCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineTessellationStateCreateInfo.html
type PipelineTessellationStateCreateInfo C.struct_VkPipelineTessellationStateCreateInfo

// SizeofPipelineTessellationStateCreateInfo is the memory size of a PipelineTessellationStateCreateInfo
var SizeofPipelineTessellationStateCreateInfo int = int(unsafe.Sizeof(PipelineTessellationStateCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineTessellationStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineTessellationStateCreateInfo) AsCPtr() *PipelineTessellationStateCreateInfo {
	clone := (*PipelineTessellationStateCreateInfo)(newCBlock(C.ulong(SizeofPipelineTessellationStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineTessellationStateCreateInfoFreeCSlice releases the memory allocated by PipelineTessellationStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineTessellationStateCreateInfoFreeCSlice(x []PipelineTessellationStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineTessellationStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineTessellationStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineTessellationStateCreateInfoMakeCSlice(x ...PipelineTessellationStateCreateInfo) []PipelineTessellationStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineTessellationStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineTessellationStateCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineTessellationStateCreateInfo
func (x PipelineTessellationStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineTessellationStateCreateInfo) WithDefaultSType() PipelineTessellationStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineTessellationStateCreateInfo) WithSType(y StructureType) PipelineTessellationStateCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPipelineTessellationStateCreateInfo
func (x PipelineTessellationStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineTessellationStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineTessellationStateCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkPipelineTessellationStateCreateInfo
func (x PipelineTessellationStateCreateInfo) Flags() PipelineTessellationStateCreateFlags {
	ptr := /* typedef */ (*PipelineTessellationStateCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineTessellationStateCreateInfo) WithFlags(y PipelineTessellationStateCreateFlags) PipelineTessellationStateCreateInfo {
	ptr := /* typedef */ (*C.VkPipelineTessellationStateCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// PatchControlPoints returns the value of patchControlPoints from VkPipelineTessellationStateCreateInfo
func (x PipelineTessellationStateCreateInfo) PatchControlPoints() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.patchControlPoints)
	return *ptr
}

// WithPatchControlPoints sets the value for the PatchControlPoints on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineTessellationStateCreateInfo) WithPatchControlPoints(y uint32) PipelineTessellationStateCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.patchControlPoints = *ptr
	return x
}

//DrawIndexedIndirectCommand provides a go interface for VkDrawIndexedIndirectCommand.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDrawIndexedIndirectCommand.html
type DrawIndexedIndirectCommand C.struct_VkDrawIndexedIndirectCommand

// SizeofDrawIndexedIndirectCommand is the memory size of a DrawIndexedIndirectCommand
var SizeofDrawIndexedIndirectCommand int = int(unsafe.Sizeof(DrawIndexedIndirectCommand{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DrawIndexedIndirectCommand) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DrawIndexedIndirectCommand) AsCPtr() *DrawIndexedIndirectCommand {
	clone := (*DrawIndexedIndirectCommand)(newCBlock(C.ulong(SizeofDrawIndexedIndirectCommand)))
	*clone = x
	return clone
}

// DrawIndexedIndirectCommandFreeCSlice releases the memory allocated by DrawIndexedIndirectCommandMakeCSlice.
// It does not free pointers stored inside the slice.
func DrawIndexedIndirectCommandFreeCSlice(x []DrawIndexedIndirectCommand) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DrawIndexedIndirectCommandMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DrawIndexedIndirectCommandFreeCSlice must be called on the returned slice.
func DrawIndexedIndirectCommandMakeCSlice(x ...DrawIndexedIndirectCommand) []DrawIndexedIndirectCommand {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDrawIndexedIndirectCommand * len(x)
	dst := unsafe.Slice((*DrawIndexedIndirectCommand)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// IndexCount returns the value of indexCount from VkDrawIndexedIndirectCommand
func (x DrawIndexedIndirectCommand) IndexCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.indexCount)
	return *ptr
}

// WithIndexCount sets the value for the IndexCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DrawIndexedIndirectCommand) WithIndexCount(y uint32) DrawIndexedIndirectCommand {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.indexCount = *ptr
	return x
}

// InstanceCount returns the value of instanceCount from VkDrawIndexedIndirectCommand
func (x DrawIndexedIndirectCommand) InstanceCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.instanceCount)
	return *ptr
}

// WithInstanceCount sets the value for the InstanceCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DrawIndexedIndirectCommand) WithInstanceCount(y uint32) DrawIndexedIndirectCommand {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.instanceCount = *ptr
	return x
}

// FirstIndex returns the value of firstIndex from VkDrawIndexedIndirectCommand
func (x DrawIndexedIndirectCommand) FirstIndex() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.firstIndex)
	return *ptr
}

// WithFirstIndex sets the value for the FirstIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DrawIndexedIndirectCommand) WithFirstIndex(y uint32) DrawIndexedIndirectCommand {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.firstIndex = *ptr
	return x
}

// VertexOffset returns the value of vertexOffset from VkDrawIndexedIndirectCommand
func (x DrawIndexedIndirectCommand) VertexOffset() int32 {
	ptr := func(x *C.int) *int32 { /* Scalar */ return (*int32)(unsafe.Pointer(x)) }(&x.vertexOffset)
	return *ptr
}

// WithVertexOffset sets the value for the VertexOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DrawIndexedIndirectCommand) WithVertexOffset(y int32) DrawIndexedIndirectCommand {
	ptr := func(x *int32) *C.int { /* Scalar */ return (*C.int)(unsafe.Pointer(x)) }(&y)
	x.vertexOffset = *ptr
	return x
}

// FirstInstance returns the value of firstInstance from VkDrawIndexedIndirectCommand
func (x DrawIndexedIndirectCommand) FirstInstance() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.firstInstance)
	return *ptr
}

// WithFirstInstance sets the value for the FirstInstance on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DrawIndexedIndirectCommand) WithFirstInstance(y uint32) DrawIndexedIndirectCommand {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.firstInstance = *ptr
	return x
}

//PipelineVertexInputStateCreateInfo provides a go interface for VkPipelineVertexInputStateCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineVertexInputStateCreateInfo.html
type PipelineVertexInputStateCreateInfo C.struct_VkPipelineVertexInputStateCreateInfo

// SizeofPipelineVertexInputStateCreateInfo is the memory size of a PipelineVertexInputStateCreateInfo
var SizeofPipelineVertexInputStateCreateInfo int = int(unsafe.Sizeof(PipelineVertexInputStateCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineVertexInputStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineVertexInputStateCreateInfo) AsCPtr() *PipelineVertexInputStateCreateInfo {
	clone := (*PipelineVertexInputStateCreateInfo)(newCBlock(C.ulong(SizeofPipelineVertexInputStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineVertexInputStateCreateInfoFreeCSlice releases the memory allocated by PipelineVertexInputStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineVertexInputStateCreateInfoFreeCSlice(x []PipelineVertexInputStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineVertexInputStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineVertexInputStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineVertexInputStateCreateInfoMakeCSlice(x ...PipelineVertexInputStateCreateInfo) []PipelineVertexInputStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineVertexInputStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineVertexInputStateCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineVertexInputStateCreateInfo
func (x PipelineVertexInputStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineVertexInputStateCreateInfo) WithDefaultSType() PipelineVertexInputStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineVertexInputStateCreateInfo) WithSType(y StructureType) PipelineVertexInputStateCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPipelineVertexInputStateCreateInfo
func (x PipelineVertexInputStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineVertexInputStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineVertexInputStateCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkPipelineVertexInputStateCreateInfo
func (x PipelineVertexInputStateCreateInfo) Flags() PipelineVertexInputStateCreateFlags {
	ptr := /* typedef */ (*PipelineVertexInputStateCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineVertexInputStateCreateInfo) WithFlags(y PipelineVertexInputStateCreateFlags) PipelineVertexInputStateCreateInfo {
	ptr := /* typedef */ (*C.VkPipelineVertexInputStateCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// VertexBindingDescriptionCount returns the value of vertexBindingDescriptionCount from VkPipelineVertexInputStateCreateInfo
func (x PipelineVertexInputStateCreateInfo) VertexBindingDescriptionCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.vertexBindingDescriptionCount)
	return *ptr
}

// WithVertexBindingDescriptionCount sets the value for the VertexBindingDescriptionCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineVertexInputStateCreateInfo) WithVertexBindingDescriptionCount(y uint32) PipelineVertexInputStateCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.vertexBindingDescriptionCount = *ptr
	return x
}

// PVertexBindingDescriptions returns the value of pVertexBindingDescriptions from VkPipelineVertexInputStateCreateInfo
func (x PipelineVertexInputStateCreateInfo) PVertexBindingDescriptions() []VertexInputBindingDescription {
	ptr := func(x **C.struct_VkVertexInputBindingDescription) *[]VertexInputBindingDescription { /* Slice */
		slc := unsafe.Slice((*VertexInputBindingDescription)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pVertexBindingDescriptions)
	return *ptr
}

// WithPVertexBindingDescriptions sets the value for the PVertexBindingDescriptions on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines VertexBindingDescriptionCount as the length of this field.
// VertexBindingDescriptionCount is updated with the length of the new value.
func (x PipelineVertexInputStateCreateInfo) WithPVertexBindingDescriptions(y []VertexInputBindingDescription) PipelineVertexInputStateCreateInfo {
	ptr := func(x *[]VertexInputBindingDescription) **C.struct_VkVertexInputBindingDescription { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkVertexInputBindingDescription)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkVertexInputBindingDescription)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pVertexBindingDescriptions = *ptr
	return x.WithVertexBindingDescriptionCount(uint32(len(y)))
}

// VertexAttributeDescriptionCount returns the value of vertexAttributeDescriptionCount from VkPipelineVertexInputStateCreateInfo
func (x PipelineVertexInputStateCreateInfo) VertexAttributeDescriptionCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.vertexAttributeDescriptionCount)
	return *ptr
}

// WithVertexAttributeDescriptionCount sets the value for the VertexAttributeDescriptionCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineVertexInputStateCreateInfo) WithVertexAttributeDescriptionCount(y uint32) PipelineVertexInputStateCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.vertexAttributeDescriptionCount = *ptr
	return x
}

// PVertexAttributeDescriptions returns the value of pVertexAttributeDescriptions from VkPipelineVertexInputStateCreateInfo
func (x PipelineVertexInputStateCreateInfo) PVertexAttributeDescriptions() []VertexInputAttributeDescription {
	ptr := func(x **C.struct_VkVertexInputAttributeDescription) *[]VertexInputAttributeDescription { /* Slice */
		slc := unsafe.Slice((*VertexInputAttributeDescription)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pVertexAttributeDescriptions)
	return *ptr
}

// WithPVertexAttributeDescriptions sets the value for the PVertexAttributeDescriptions on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines VertexAttributeDescriptionCount as the length of this field.
// VertexAttributeDescriptionCount is updated with the length of the new value.
func (x PipelineVertexInputStateCreateInfo) WithPVertexAttributeDescriptions(y []VertexInputAttributeDescription) PipelineVertexInputStateCreateInfo {
	ptr := func(x *[]VertexInputAttributeDescription) **C.struct_VkVertexInputAttributeDescription { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkVertexInputAttributeDescription)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkVertexInputAttributeDescription)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pVertexAttributeDescriptions = *ptr
	return x.WithVertexAttributeDescriptionCount(uint32(len(y)))
}

//DispatchIndirectCommand provides a go interface for VkDispatchIndirectCommand.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDispatchIndirectCommand.html
type DispatchIndirectCommand C.struct_VkDispatchIndirectCommand

// SizeofDispatchIndirectCommand is the memory size of a DispatchIndirectCommand
var SizeofDispatchIndirectCommand int = int(unsafe.Sizeof(DispatchIndirectCommand{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DispatchIndirectCommand) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DispatchIndirectCommand) AsCPtr() *DispatchIndirectCommand {
	clone := (*DispatchIndirectCommand)(newCBlock(C.ulong(SizeofDispatchIndirectCommand)))
	*clone = x
	return clone
}

// DispatchIndirectCommandFreeCSlice releases the memory allocated by DispatchIndirectCommandMakeCSlice.
// It does not free pointers stored inside the slice.
func DispatchIndirectCommandFreeCSlice(x []DispatchIndirectCommand) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DispatchIndirectCommandMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DispatchIndirectCommandFreeCSlice must be called on the returned slice.
func DispatchIndirectCommandMakeCSlice(x ...DispatchIndirectCommand) []DispatchIndirectCommand {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDispatchIndirectCommand * len(x)
	dst := unsafe.Slice((*DispatchIndirectCommand)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// X returns the value of x from VkDispatchIndirectCommand
func (x DispatchIndirectCommand) X() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.x)
	return *ptr
}

// WithX sets the value for the X on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DispatchIndirectCommand) WithX(y uint32) DispatchIndirectCommand {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.x = *ptr
	return x
}

// Y returns the value of y from VkDispatchIndirectCommand
func (x DispatchIndirectCommand) Y() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.y)
	return *ptr
}

// WithY sets the value for the Y on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DispatchIndirectCommand) WithY(y uint32) DispatchIndirectCommand {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.y = *ptr
	return x
}

// Z returns the value of z from VkDispatchIndirectCommand
func (x DispatchIndirectCommand) Z() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.z)
	return *ptr
}

// WithZ sets the value for the Z on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DispatchIndirectCommand) WithZ(y uint32) DispatchIndirectCommand {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.z = *ptr
	return x
}

//PipelineViewportStateCreateInfo provides a go interface for VkPipelineViewportStateCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineViewportStateCreateInfo.html
type PipelineViewportStateCreateInfo C.struct_VkPipelineViewportStateCreateInfo

// SizeofPipelineViewportStateCreateInfo is the memory size of a PipelineViewportStateCreateInfo
var SizeofPipelineViewportStateCreateInfo int = int(unsafe.Sizeof(PipelineViewportStateCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineViewportStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineViewportStateCreateInfo) AsCPtr() *PipelineViewportStateCreateInfo {
	clone := (*PipelineViewportStateCreateInfo)(newCBlock(C.ulong(SizeofPipelineViewportStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineViewportStateCreateInfoFreeCSlice releases the memory allocated by PipelineViewportStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineViewportStateCreateInfoFreeCSlice(x []PipelineViewportStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineViewportStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineViewportStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineViewportStateCreateInfoMakeCSlice(x ...PipelineViewportStateCreateInfo) []PipelineViewportStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineViewportStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineViewportStateCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineViewportStateCreateInfo
func (x PipelineViewportStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineViewportStateCreateInfo) WithDefaultSType() PipelineViewportStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineViewportStateCreateInfo) WithSType(y StructureType) PipelineViewportStateCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPipelineViewportStateCreateInfo
func (x PipelineViewportStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineViewportStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineViewportStateCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkPipelineViewportStateCreateInfo
func (x PipelineViewportStateCreateInfo) Flags() PipelineViewportStateCreateFlags {
	ptr := /* typedef */ (*PipelineViewportStateCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineViewportStateCreateInfo) WithFlags(y PipelineViewportStateCreateFlags) PipelineViewportStateCreateInfo {
	ptr := /* typedef */ (*C.VkPipelineViewportStateCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// ViewportCount returns the value of viewportCount from VkPipelineViewportStateCreateInfo
func (x PipelineViewportStateCreateInfo) ViewportCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.viewportCount)
	return *ptr
}

// WithViewportCount sets the value for the ViewportCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineViewportStateCreateInfo) WithViewportCount(y uint32) PipelineViewportStateCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.viewportCount = *ptr
	return x
}

// PViewports returns the value of pViewports from VkPipelineViewportStateCreateInfo
func (x PipelineViewportStateCreateInfo) PViewports() []Viewport {
	ptr := func(x **C.struct_VkViewport) *[]Viewport { /* Slice */
		slc := unsafe.Slice((*Viewport)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pViewports)
	return *ptr
}

// WithPViewports sets the value for the PViewports on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines ViewportCount as the length of this field.
// ViewportCount is updated with the length of the new value.
func (x PipelineViewportStateCreateInfo) WithPViewports(y []Viewport) PipelineViewportStateCreateInfo {
	ptr := func(x *[]Viewport) **C.struct_VkViewport { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkViewport)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkViewport)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pViewports = *ptr
	return x.WithViewportCount(uint32(len(y)))
}

// ScissorCount returns the value of scissorCount from VkPipelineViewportStateCreateInfo
func (x PipelineViewportStateCreateInfo) ScissorCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.scissorCount)
	return *ptr
}

// WithScissorCount sets the value for the ScissorCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineViewportStateCreateInfo) WithScissorCount(y uint32) PipelineViewportStateCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.scissorCount = *ptr
	return x
}

// PScissors returns the value of pScissors from VkPipelineViewportStateCreateInfo
func (x PipelineViewportStateCreateInfo) PScissors() []Rect2D {
	ptr := func(x **C.struct_VkRect2D) *[]Rect2D { /* Slice */
		slc := unsafe.Slice((*Rect2D)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pScissors)
	return *ptr
}

// WithPScissors sets the value for the PScissors on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines ScissorCount as the length of this field.
// ScissorCount is updated with the length of the new value.
func (x PipelineViewportStateCreateInfo) WithPScissors(y []Rect2D) PipelineViewportStateCreateInfo {
	ptr := func(x *[]Rect2D) **C.struct_VkRect2D { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkRect2D)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkRect2D)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pScissors = *ptr
	return x.WithScissorCount(uint32(len(y)))
}

//ImageViewCreateInfo provides a go interface for VkImageViewCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageViewCreateInfo.html
type ImageViewCreateInfo C.struct_VkImageViewCreateInfo

// SizeofImageViewCreateInfo is the memory size of a ImageViewCreateInfo
var SizeofImageViewCreateInfo int = int(unsafe.Sizeof(ImageViewCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageViewCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageViewCreateInfo) AsCPtr() *ImageViewCreateInfo {
	clone := (*ImageViewCreateInfo)(newCBlock(C.ulong(SizeofImageViewCreateInfo)))
	*clone = x
	return clone
}

// ImageViewCreateInfoFreeCSlice releases the memory allocated by ImageViewCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageViewCreateInfoFreeCSlice(x []ImageViewCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageViewCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageViewCreateInfoFreeCSlice must be called on the returned slice.
func ImageViewCreateInfoMakeCSlice(x ...ImageViewCreateInfo) []ImageViewCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageViewCreateInfo * len(x)
	dst := unsafe.Slice((*ImageViewCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageViewCreateInfo
func (x ImageViewCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ImageViewCreateInfo) WithDefaultSType() ImageViewCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewCreateInfo) WithSType(y StructureType) ImageViewCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkImageViewCreateInfo
func (x ImageViewCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewCreateInfo) WithPNext(y unsafe.Pointer) ImageViewCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkImageViewCreateInfo
func (x ImageViewCreateInfo) Flags() ImageViewCreateFlags {
	ptr := /* typedef */ (*ImageViewCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewCreateInfo) WithFlags(y ImageViewCreateFlags) ImageViewCreateInfo {
	ptr := /* typedef */ (*C.VkImageViewCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// Image returns the value of image from VkImageViewCreateInfo
func (x ImageViewCreateInfo) Image() Image {
	ptr := /* handle */ (*Image)(&x.image)
	return *ptr
}

// WithImage sets the value for the Image on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewCreateInfo) WithImage(y Image) ImageViewCreateInfo {
	ptr := /* handle */ (*C.VkImage)(&y)
	x.image = *ptr
	return x
}

// ViewType returns the value of viewType from VkImageViewCreateInfo
func (x ImageViewCreateInfo) ViewType() ImageViewType {
	ptr := /* typedef */ (*ImageViewType)(&x.viewType)
	return *ptr
}

// WithViewType sets the value for the ViewType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewCreateInfo) WithViewType(y ImageViewType) ImageViewCreateInfo {
	ptr := /* typedef */ (*C.VkImageViewType)(&y)
	x.viewType = *ptr
	return x
}

// Format returns the value of format from VkImageViewCreateInfo
func (x ImageViewCreateInfo) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format)
	return *ptr
}

// WithFormat sets the value for the Format on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewCreateInfo) WithFormat(y Format) ImageViewCreateInfo {
	ptr := /* typedef */ (*C.VkFormat)(&y)
	x.format = *ptr
	return x
}

// Components returns the value of components from VkImageViewCreateInfo
func (x ImageViewCreateInfo) Components() ComponentMapping {
	ptr := /* typedef */ (*ComponentMapping)(&x.components)
	return *ptr
}

// WithComponents sets the value for the Components on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewCreateInfo) WithComponents(y ComponentMapping) ImageViewCreateInfo {
	ptr := /* typedef */ (*C.struct_VkComponentMapping)(&y)
	x.components = *ptr
	return x
}

// SubresourceRange returns the value of subresourceRange from VkImageViewCreateInfo
func (x ImageViewCreateInfo) SubresourceRange() ImageSubresourceRange {
	ptr := /* typedef */ (*ImageSubresourceRange)(&x.subresourceRange)
	return *ptr
}

// WithSubresourceRange sets the value for the SubresourceRange on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewCreateInfo) WithSubresourceRange(y ImageSubresourceRange) ImageViewCreateInfo {
	ptr := /* typedef */ (*C.struct_VkImageSubresourceRange)(&y)
	x.subresourceRange = *ptr
	return x
}

//BufferMemoryBarrier provides a go interface for VkBufferMemoryBarrier.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBufferMemoryBarrier.html
type BufferMemoryBarrier C.struct_VkBufferMemoryBarrier

// SizeofBufferMemoryBarrier is the memory size of a BufferMemoryBarrier
var SizeofBufferMemoryBarrier int = int(unsafe.Sizeof(BufferMemoryBarrier{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferMemoryBarrier) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferMemoryBarrier) AsCPtr() *BufferMemoryBarrier {
	clone := (*BufferMemoryBarrier)(newCBlock(C.ulong(SizeofBufferMemoryBarrier)))
	*clone = x
	return clone
}

// BufferMemoryBarrierFreeCSlice releases the memory allocated by BufferMemoryBarrierMakeCSlice.
// It does not free pointers stored inside the slice.
func BufferMemoryBarrierFreeCSlice(x []BufferMemoryBarrier) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferMemoryBarrierMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferMemoryBarrierFreeCSlice must be called on the returned slice.
func BufferMemoryBarrierMakeCSlice(x ...BufferMemoryBarrier) []BufferMemoryBarrier {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferMemoryBarrier * len(x)
	dst := unsafe.Slice((*BufferMemoryBarrier)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBufferMemoryBarrier
func (x BufferMemoryBarrier) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BufferMemoryBarrier) WithDefaultSType() BufferMemoryBarrier {
	return x.WithSType(VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier) WithSType(y StructureType) BufferMemoryBarrier {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkBufferMemoryBarrier
func (x BufferMemoryBarrier) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier) WithPNext(y unsafe.Pointer) BufferMemoryBarrier {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// SrcAccessMask returns the value of srcAccessMask from VkBufferMemoryBarrier
func (x BufferMemoryBarrier) SrcAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.srcAccessMask)
	return *ptr
}

// WithSrcAccessMask sets the value for the SrcAccessMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier) WithSrcAccessMask(y AccessFlags) BufferMemoryBarrier {
	ptr := /* typedef */ (*C.VkAccessFlags)(&y)
	x.srcAccessMask = *ptr
	return x
}

// DstAccessMask returns the value of dstAccessMask from VkBufferMemoryBarrier
func (x BufferMemoryBarrier) DstAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.dstAccessMask)
	return *ptr
}

// WithDstAccessMask sets the value for the DstAccessMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier) WithDstAccessMask(y AccessFlags) BufferMemoryBarrier {
	ptr := /* typedef */ (*C.VkAccessFlags)(&y)
	x.dstAccessMask = *ptr
	return x
}

// SrcQueueFamilyIndex returns the value of srcQueueFamilyIndex from VkBufferMemoryBarrier
func (x BufferMemoryBarrier) SrcQueueFamilyIndex() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.srcQueueFamilyIndex)
	return *ptr
}

// WithSrcQueueFamilyIndex sets the value for the SrcQueueFamilyIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier) WithSrcQueueFamilyIndex(y uint32) BufferMemoryBarrier {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.srcQueueFamilyIndex = *ptr
	return x
}

// DstQueueFamilyIndex returns the value of dstQueueFamilyIndex from VkBufferMemoryBarrier
func (x BufferMemoryBarrier) DstQueueFamilyIndex() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.dstQueueFamilyIndex)
	return *ptr
}

// WithDstQueueFamilyIndex sets the value for the DstQueueFamilyIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier) WithDstQueueFamilyIndex(y uint32) BufferMemoryBarrier {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.dstQueueFamilyIndex = *ptr
	return x
}

// Buffer returns the value of buffer from VkBufferMemoryBarrier
func (x BufferMemoryBarrier) Buffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.buffer)
	return *ptr
}

// WithBuffer sets the value for the Buffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier) WithBuffer(y Buffer) BufferMemoryBarrier {
	ptr := /* handle */ (*C.VkBuffer)(&y)
	x.buffer = *ptr
	return x
}

// Offset returns the value of offset from VkBufferMemoryBarrier
func (x BufferMemoryBarrier) Offset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.offset)
	return *ptr
}

// WithOffset sets the value for the Offset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier) WithOffset(y DeviceSize) BufferMemoryBarrier {
	ptr := /* typedef */ (*C.VkDeviceSize)(&y)
	x.offset = *ptr
	return x
}

// Size returns the value of size from VkBufferMemoryBarrier
func (x BufferMemoryBarrier) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size)
	return *ptr
}

// WithSize sets the value for the Size on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier) WithSize(y DeviceSize) BufferMemoryBarrier {
	ptr := /* typedef */ (*C.VkDeviceSize)(&y)
	x.size = *ptr
	return x
}

//BaseOutStructure provides a go interface for VkBaseOutStructure.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBaseOutStructure.html
type BaseOutStructure C.struct_VkBaseOutStructure

// SizeofBaseOutStructure is the memory size of a BaseOutStructure
var SizeofBaseOutStructure int = int(unsafe.Sizeof(BaseOutStructure{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BaseOutStructure) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BaseOutStructure) AsCPtr() *BaseOutStructure {
	clone := (*BaseOutStructure)(newCBlock(C.ulong(SizeofBaseOutStructure)))
	*clone = x
	return clone
}

// BaseOutStructureFreeCSlice releases the memory allocated by BaseOutStructureMakeCSlice.
// It does not free pointers stored inside the slice.
func BaseOutStructureFreeCSlice(x []BaseOutStructure) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BaseOutStructureMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BaseOutStructureFreeCSlice must be called on the returned slice.
func BaseOutStructureMakeCSlice(x ...BaseOutStructure) []BaseOutStructure {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBaseOutStructure * len(x)
	dst := unsafe.Slice((*BaseOutStructure)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBaseOutStructure
func (x BaseOutStructure) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BaseOutStructure) WithSType(y StructureType) BaseOutStructure {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkBaseOutStructure
func (x BaseOutStructure) PNext() *BaseOutStructure {
	ptr := func(x **C.struct_VkBaseOutStructure) **BaseOutStructure { /* Pointer */
		return (**BaseOutStructure)(unsafe.Pointer(x))
	}(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BaseOutStructure) WithPNext(y *BaseOutStructure) BaseOutStructure {
	ptr := func(x **BaseOutStructure) **C.struct_VkBaseOutStructure { /* Pointer */
		return (**C.struct_VkBaseOutStructure)(unsafe.Pointer(x))
	}(&y)
	x.pNext = *ptr
	return x
}

//BaseInStructure provides a go interface for VkBaseInStructure.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBaseInStructure.html
type BaseInStructure C.struct_VkBaseInStructure

// SizeofBaseInStructure is the memory size of a BaseInStructure
var SizeofBaseInStructure int = int(unsafe.Sizeof(BaseInStructure{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BaseInStructure) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BaseInStructure) AsCPtr() *BaseInStructure {
	clone := (*BaseInStructure)(newCBlock(C.ulong(SizeofBaseInStructure)))
	*clone = x
	return clone
}

// BaseInStructureFreeCSlice releases the memory allocated by BaseInStructureMakeCSlice.
// It does not free pointers stored inside the slice.
func BaseInStructureFreeCSlice(x []BaseInStructure) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BaseInStructureMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BaseInStructureFreeCSlice must be called on the returned slice.
func BaseInStructureMakeCSlice(x ...BaseInStructure) []BaseInStructure {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBaseInStructure * len(x)
	dst := unsafe.Slice((*BaseInStructure)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBaseInStructure
func (x BaseInStructure) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BaseInStructure) WithSType(y StructureType) BaseInStructure {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkBaseInStructure
func (x BaseInStructure) PNext() *BaseInStructure {
	ptr := func(x **C.struct_VkBaseInStructure) **BaseInStructure { /* Pointer */
		return (**BaseInStructure)(unsafe.Pointer(x))
	}(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BaseInStructure) WithPNext(y *BaseInStructure) BaseInStructure {
	ptr := func(x **BaseInStructure) **C.struct_VkBaseInStructure { /* Pointer */
		return (**C.struct_VkBaseInStructure)(unsafe.Pointer(x))
	}(&y)
	x.pNext = *ptr
	return x
}

//Rect2D provides a go interface for VkRect2D.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkRect2D.html
type Rect2D C.struct_VkRect2D

// SizeofRect2D is the memory size of a Rect2D
var SizeofRect2D int = int(unsafe.Sizeof(Rect2D{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *Rect2D) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x Rect2D) AsCPtr() *Rect2D {
	clone := (*Rect2D)(newCBlock(C.ulong(SizeofRect2D)))
	*clone = x
	return clone
}

// Rect2DFreeCSlice releases the memory allocated by Rect2DMakeCSlice.
// It does not free pointers stored inside the slice.
func Rect2DFreeCSlice(x []Rect2D) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// Rect2DMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. Rect2DFreeCSlice must be called on the returned slice.
func Rect2DMakeCSlice(x ...Rect2D) []Rect2D {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRect2D * len(x)
	dst := unsafe.Slice((*Rect2D)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Offset returns the value of offset from VkRect2D
func (x Rect2D) Offset() Offset2D {
	ptr := /* typedef */ (*Offset2D)(&x.offset)
	return *ptr
}

// WithOffset sets the value for the Offset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Rect2D) WithOffset(y Offset2D) Rect2D {
	ptr := /* typedef */ (*C.struct_VkOffset2D)(&y)
	x.offset = *ptr
	return x
}

// Extent returns the value of extent from VkRect2D
func (x Rect2D) Extent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.extent)
	return *ptr
}

// WithExtent sets the value for the Extent on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Rect2D) WithExtent(y Extent2D) Rect2D {
	ptr := /* typedef */ (*C.struct_VkExtent2D)(&y)
	x.extent = *ptr
	return x
}

//SpecializationInfo provides a go interface for VkSpecializationInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSpecializationInfo.html
type SpecializationInfo C.struct_VkSpecializationInfo

// SizeofSpecializationInfo is the memory size of a SpecializationInfo
var SizeofSpecializationInfo int = int(unsafe.Sizeof(SpecializationInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SpecializationInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SpecializationInfo) AsCPtr() *SpecializationInfo {
	clone := (*SpecializationInfo)(newCBlock(C.ulong(SizeofSpecializationInfo)))
	*clone = x
	return clone
}

// SpecializationInfoFreeCSlice releases the memory allocated by SpecializationInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SpecializationInfoFreeCSlice(x []SpecializationInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SpecializationInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SpecializationInfoFreeCSlice must be called on the returned slice.
func SpecializationInfoMakeCSlice(x ...SpecializationInfo) []SpecializationInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSpecializationInfo * len(x)
	dst := unsafe.Slice((*SpecializationInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// MapEntryCount returns the value of mapEntryCount from VkSpecializationInfo
func (x SpecializationInfo) MapEntryCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.mapEntryCount)
	return *ptr
}

// WithMapEntryCount sets the value for the MapEntryCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SpecializationInfo) WithMapEntryCount(y uint32) SpecializationInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.mapEntryCount = *ptr
	return x
}

// PMapEntries returns the value of pMapEntries from VkSpecializationInfo
func (x SpecializationInfo) PMapEntries() []SpecializationMapEntry {
	ptr := func(x **C.struct_VkSpecializationMapEntry) *[]SpecializationMapEntry { /* Slice */
		slc := unsafe.Slice((*SpecializationMapEntry)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pMapEntries)
	return *ptr
}

// WithPMapEntries sets the value for the PMapEntries on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines MapEntryCount as the length of this field.
// MapEntryCount is updated with the length of the new value.
func (x SpecializationInfo) WithPMapEntries(y []SpecializationMapEntry) SpecializationInfo {
	ptr := func(x *[]SpecializationMapEntry) **C.struct_VkSpecializationMapEntry { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSpecializationMapEntry)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSpecializationMapEntry)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pMapEntries = *ptr
	return x.WithMapEntryCount(uint32(len(y)))
}

// DataSize returns the value of dataSize from VkSpecializationInfo
func (x SpecializationInfo) DataSize() uint64 {
	ptr := func(x *C.ulong) *uint64 { /* Scalar */ return (*uint64)(unsafe.Pointer(x)) }(&x.dataSize)
	return *ptr
}

// WithDataSize sets the value for the DataSize on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SpecializationInfo) WithDataSize(y uint64) SpecializationInfo {
	ptr := func(x *uint64) *C.ulong { /* Scalar */ return (*C.ulong)(unsafe.Pointer(x)) }(&y)
	x.dataSize = *ptr
	return x
}

// PData returns the value of pData from VkSpecializationInfo
func (x SpecializationInfo) PData() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pData)
	return *ptr
}

// WithPData sets the value for the PData on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SpecializationInfo) WithPData(y unsafe.Pointer) SpecializationInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pData = *ptr
	return x
}

//SpecializationMapEntry provides a go interface for VkSpecializationMapEntry.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSpecializationMapEntry.html
type SpecializationMapEntry C.struct_VkSpecializationMapEntry

// SizeofSpecializationMapEntry is the memory size of a SpecializationMapEntry
var SizeofSpecializationMapEntry int = int(unsafe.Sizeof(SpecializationMapEntry{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SpecializationMapEntry) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SpecializationMapEntry) AsCPtr() *SpecializationMapEntry {
	clone := (*SpecializationMapEntry)(newCBlock(C.ulong(SizeofSpecializationMapEntry)))
	*clone = x
	return clone
}

// SpecializationMapEntryFreeCSlice releases the memory allocated by SpecializationMapEntryMakeCSlice.
// It does not free pointers stored inside the slice.
func SpecializationMapEntryFreeCSlice(x []SpecializationMapEntry) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SpecializationMapEntryMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SpecializationMapEntryFreeCSlice must be called on the returned slice.
func SpecializationMapEntryMakeCSlice(x ...SpecializationMapEntry) []SpecializationMapEntry {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSpecializationMapEntry * len(x)
	dst := unsafe.Slice((*SpecializationMapEntry)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// ConstantID returns the value of constantID from VkSpecializationMapEntry
func (x SpecializationMapEntry) ConstantID() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.constantID)
	return *ptr
}

// WithConstantID sets the value for the ConstantID on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SpecializationMapEntry) WithConstantID(y uint32) SpecializationMapEntry {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.constantID = *ptr
	return x
}

// Offset returns the value of offset from VkSpecializationMapEntry
func (x SpecializationMapEntry) Offset() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.offset)
	return *ptr
}

// WithOffset sets the value for the Offset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SpecializationMapEntry) WithOffset(y uint32) SpecializationMapEntry {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.offset = *ptr
	return x
}

// Size returns the value of size from VkSpecializationMapEntry
func (x SpecializationMapEntry) Size() uint64 {
	ptr := func(x *C.ulong) *uint64 { /* Scalar */ return (*uint64)(unsafe.Pointer(x)) }(&x.size)
	return *ptr
}

// WithSize sets the value for the Size on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SpecializationMapEntry) WithSize(y uint64) SpecializationMapEntry {
	ptr := func(x *uint64) *C.ulong { /* Scalar */ return (*C.ulong)(unsafe.Pointer(x)) }(&y)
	x.size = *ptr
	return x
}

//Offset3D provides a go interface for VkOffset3D.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkOffset3D.html
type Offset3D C.struct_VkOffset3D

// SizeofOffset3D is the memory size of a Offset3D
var SizeofOffset3D int = int(unsafe.Sizeof(Offset3D{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *Offset3D) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x Offset3D) AsCPtr() *Offset3D {
	clone := (*Offset3D)(newCBlock(C.ulong(SizeofOffset3D)))
	*clone = x
	return clone
}

// Offset3DFreeCSlice releases the memory allocated by Offset3DMakeCSlice.
// It does not free pointers stored inside the slice.
func Offset3DFreeCSlice(x []Offset3D) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// Offset3DMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. Offset3DFreeCSlice must be called on the returned slice.
func Offset3DMakeCSlice(x ...Offset3D) []Offset3D {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofOffset3D * len(x)
	dst := unsafe.Slice((*Offset3D)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// X returns the value of x from VkOffset3D
func (x Offset3D) X() int32 {
	ptr := func(x *C.int) *int32 { /* Scalar */ return (*int32)(unsafe.Pointer(x)) }(&x.x)
	return *ptr
}

// WithX sets the value for the X on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Offset3D) WithX(y int32) Offset3D {
	ptr := func(x *int32) *C.int { /* Scalar */ return (*C.int)(unsafe.Pointer(x)) }(&y)
	x.x = *ptr
	return x
}

// Y returns the value of y from VkOffset3D
func (x Offset3D) Y() int32 {
	ptr := func(x *C.int) *int32 { /* Scalar */ return (*int32)(unsafe.Pointer(x)) }(&x.y)
	return *ptr
}

// WithY sets the value for the Y on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Offset3D) WithY(y int32) Offset3D {
	ptr := func(x *int32) *C.int { /* Scalar */ return (*C.int)(unsafe.Pointer(x)) }(&y)
	x.y = *ptr
	return x
}

// Z returns the value of z from VkOffset3D
func (x Offset3D) Z() int32 {
	ptr := func(x *C.int) *int32 { /* Scalar */ return (*int32)(unsafe.Pointer(x)) }(&x.z)
	return *ptr
}

// WithZ sets the value for the Z on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Offset3D) WithZ(y int32) Offset3D {
	ptr := func(x *int32) *C.int { /* Scalar */ return (*C.int)(unsafe.Pointer(x)) }(&y)
	x.z = *ptr
	return x
}

//StencilOpState provides a go interface for VkStencilOpState.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkStencilOpState.html
type StencilOpState C.struct_VkStencilOpState

// SizeofStencilOpState is the memory size of a StencilOpState
var SizeofStencilOpState int = int(unsafe.Sizeof(StencilOpState{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *StencilOpState) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x StencilOpState) AsCPtr() *StencilOpState {
	clone := (*StencilOpState)(newCBlock(C.ulong(SizeofStencilOpState)))
	*clone = x
	return clone
}

// StencilOpStateFreeCSlice releases the memory allocated by StencilOpStateMakeCSlice.
// It does not free pointers stored inside the slice.
func StencilOpStateFreeCSlice(x []StencilOpState) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// StencilOpStateMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. StencilOpStateFreeCSlice must be called on the returned slice.
func StencilOpStateMakeCSlice(x ...StencilOpState) []StencilOpState {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofStencilOpState * len(x)
	dst := unsafe.Slice((*StencilOpState)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// FailOp returns the value of failOp from VkStencilOpState
func (x StencilOpState) FailOp() StencilOp {
	ptr := /* typedef */ (*StencilOp)(&x.failOp)
	return *ptr
}

// WithFailOp sets the value for the FailOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x StencilOpState) WithFailOp(y StencilOp) StencilOpState {
	ptr := /* typedef */ (*C.VkStencilOp)(&y)
	x.failOp = *ptr
	return x
}

// PassOp returns the value of passOp from VkStencilOpState
func (x StencilOpState) PassOp() StencilOp {
	ptr := /* typedef */ (*StencilOp)(&x.passOp)
	return *ptr
}

// WithPassOp sets the value for the PassOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x StencilOpState) WithPassOp(y StencilOp) StencilOpState {
	ptr := /* typedef */ (*C.VkStencilOp)(&y)
	x.passOp = *ptr
	return x
}

// DepthFailOp returns the value of depthFailOp from VkStencilOpState
func (x StencilOpState) DepthFailOp() StencilOp {
	ptr := /* typedef */ (*StencilOp)(&x.depthFailOp)
	return *ptr
}

// WithDepthFailOp sets the value for the DepthFailOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x StencilOpState) WithDepthFailOp(y StencilOp) StencilOpState {
	ptr := /* typedef */ (*C.VkStencilOp)(&y)
	x.depthFailOp = *ptr
	return x
}

// CompareOp returns the value of compareOp from VkStencilOpState
func (x StencilOpState) CompareOp() CompareOp {
	ptr := /* typedef */ (*CompareOp)(&x.compareOp)
	return *ptr
}

// WithCompareOp sets the value for the CompareOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x StencilOpState) WithCompareOp(y CompareOp) StencilOpState {
	ptr := /* typedef */ (*C.VkCompareOp)(&y)
	x.compareOp = *ptr
	return x
}

// CompareMask returns the value of compareMask from VkStencilOpState
func (x StencilOpState) CompareMask() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.compareMask)
	return *ptr
}

// WithCompareMask sets the value for the CompareMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x StencilOpState) WithCompareMask(y uint32) StencilOpState {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.compareMask = *ptr
	return x
}

// WriteMask returns the value of writeMask from VkStencilOpState
func (x StencilOpState) WriteMask() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.writeMask)
	return *ptr
}

// WithWriteMask sets the value for the WriteMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x StencilOpState) WithWriteMask(y uint32) StencilOpState {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.writeMask = *ptr
	return x
}

// Reference returns the value of reference from VkStencilOpState
func (x StencilOpState) Reference() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.reference)
	return *ptr
}

// WithReference sets the value for the Reference on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x StencilOpState) WithReference(y uint32) StencilOpState {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.reference = *ptr
	return x
}

//VertexInputAttributeDescription provides a go interface for VkVertexInputAttributeDescription.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVertexInputAttributeDescription.html
type VertexInputAttributeDescription C.struct_VkVertexInputAttributeDescription

// SizeofVertexInputAttributeDescription is the memory size of a VertexInputAttributeDescription
var SizeofVertexInputAttributeDescription int = int(unsafe.Sizeof(VertexInputAttributeDescription{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *VertexInputAttributeDescription) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x VertexInputAttributeDescription) AsCPtr() *VertexInputAttributeDescription {
	clone := (*VertexInputAttributeDescription)(newCBlock(C.ulong(SizeofVertexInputAttributeDescription)))
	*clone = x
	return clone
}

// VertexInputAttributeDescriptionFreeCSlice releases the memory allocated by VertexInputAttributeDescriptionMakeCSlice.
// It does not free pointers stored inside the slice.
func VertexInputAttributeDescriptionFreeCSlice(x []VertexInputAttributeDescription) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// VertexInputAttributeDescriptionMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. VertexInputAttributeDescriptionFreeCSlice must be called on the returned slice.
func VertexInputAttributeDescriptionMakeCSlice(x ...VertexInputAttributeDescription) []VertexInputAttributeDescription {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofVertexInputAttributeDescription * len(x)
	dst := unsafe.Slice((*VertexInputAttributeDescription)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Location returns the value of location from VkVertexInputAttributeDescription
func (x VertexInputAttributeDescription) Location() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.location)
	return *ptr
}

// WithLocation sets the value for the Location on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x VertexInputAttributeDescription) WithLocation(y uint32) VertexInputAttributeDescription {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.location = *ptr
	return x
}

// Binding returns the value of binding from VkVertexInputAttributeDescription
func (x VertexInputAttributeDescription) Binding() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.binding)
	return *ptr
}

// WithBinding sets the value for the Binding on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x VertexInputAttributeDescription) WithBinding(y uint32) VertexInputAttributeDescription {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.binding = *ptr
	return x
}

// Format returns the value of format from VkVertexInputAttributeDescription
func (x VertexInputAttributeDescription) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format)
	return *ptr
}

// WithFormat sets the value for the Format on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x VertexInputAttributeDescription) WithFormat(y Format) VertexInputAttributeDescription {
	ptr := /* typedef */ (*C.VkFormat)(&y)
	x.format = *ptr
	return x
}

// Offset returns the value of offset from VkVertexInputAttributeDescription
func (x VertexInputAttributeDescription) Offset() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.offset)
	return *ptr
}

// WithOffset sets the value for the Offset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x VertexInputAttributeDescription) WithOffset(y uint32) VertexInputAttributeDescription {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.offset = *ptr
	return x
}

//VertexInputBindingDescription provides a go interface for VkVertexInputBindingDescription.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVertexInputBindingDescription.html
type VertexInputBindingDescription C.struct_VkVertexInputBindingDescription

// SizeofVertexInputBindingDescription is the memory size of a VertexInputBindingDescription
var SizeofVertexInputBindingDescription int = int(unsafe.Sizeof(VertexInputBindingDescription{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *VertexInputBindingDescription) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x VertexInputBindingDescription) AsCPtr() *VertexInputBindingDescription {
	clone := (*VertexInputBindingDescription)(newCBlock(C.ulong(SizeofVertexInputBindingDescription)))
	*clone = x
	return clone
}

// VertexInputBindingDescriptionFreeCSlice releases the memory allocated by VertexInputBindingDescriptionMakeCSlice.
// It does not free pointers stored inside the slice.
func VertexInputBindingDescriptionFreeCSlice(x []VertexInputBindingDescription) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// VertexInputBindingDescriptionMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. VertexInputBindingDescriptionFreeCSlice must be called on the returned slice.
func VertexInputBindingDescriptionMakeCSlice(x ...VertexInputBindingDescription) []VertexInputBindingDescription {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofVertexInputBindingDescription * len(x)
	dst := unsafe.Slice((*VertexInputBindingDescription)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Binding returns the value of binding from VkVertexInputBindingDescription
func (x VertexInputBindingDescription) Binding() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.binding)
	return *ptr
}

// WithBinding sets the value for the Binding on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x VertexInputBindingDescription) WithBinding(y uint32) VertexInputBindingDescription {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.binding = *ptr
	return x
}

// Stride returns the value of stride from VkVertexInputBindingDescription
func (x VertexInputBindingDescription) Stride() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.stride)
	return *ptr
}

// WithStride sets the value for the Stride on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x VertexInputBindingDescription) WithStride(y uint32) VertexInputBindingDescription {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.stride = *ptr
	return x
}

// InputRate returns the value of inputRate from VkVertexInputBindingDescription
func (x VertexInputBindingDescription) InputRate() VertexInputRate {
	ptr := /* typedef */ (*VertexInputRate)(&x.inputRate)
	return *ptr
}

// WithInputRate sets the value for the InputRate on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x VertexInputBindingDescription) WithInputRate(y VertexInputRate) VertexInputBindingDescription {
	ptr := /* typedef */ (*C.VkVertexInputRate)(&y)
	x.inputRate = *ptr
	return x
}

//Offset2D provides a go interface for VkOffset2D.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkOffset2D.html
type Offset2D C.struct_VkOffset2D

// SizeofOffset2D is the memory size of a Offset2D
var SizeofOffset2D int = int(unsafe.Sizeof(Offset2D{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *Offset2D) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x Offset2D) AsCPtr() *Offset2D {
	clone := (*Offset2D)(newCBlock(C.ulong(SizeofOffset2D)))
	*clone = x
	return clone
}

// Offset2DFreeCSlice releases the memory allocated by Offset2DMakeCSlice.
// It does not free pointers stored inside the slice.
func Offset2DFreeCSlice(x []Offset2D) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// Offset2DMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. Offset2DFreeCSlice must be called on the returned slice.
func Offset2DMakeCSlice(x ...Offset2D) []Offset2D {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofOffset2D * len(x)
	dst := unsafe.Slice((*Offset2D)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// X returns the value of x from VkOffset2D
func (x Offset2D) X() int32 {
	ptr := func(x *C.int) *int32 { /* Scalar */ return (*int32)(unsafe.Pointer(x)) }(&x.x)
	return *ptr
}

// WithX sets the value for the X on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Offset2D) WithX(y int32) Offset2D {
	ptr := func(x *int32) *C.int { /* Scalar */ return (*C.int)(unsafe.Pointer(x)) }(&y)
	x.x = *ptr
	return x
}

// Y returns the value of y from VkOffset2D
func (x Offset2D) Y() int32 {
	ptr := func(x *C.int) *int32 { /* Scalar */ return (*int32)(unsafe.Pointer(x)) }(&x.y)
	return *ptr
}

// WithY sets the value for the Y on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Offset2D) WithY(y int32) Offset2D {
	ptr := func(x *int32) *C.int { /* Scalar */ return (*C.int)(unsafe.Pointer(x)) }(&y)
	x.y = *ptr
	return x
}

//Viewport provides a go interface for VkViewport.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkViewport.html
type Viewport C.struct_VkViewport

// SizeofViewport is the memory size of a Viewport
var SizeofViewport int = int(unsafe.Sizeof(Viewport{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *Viewport) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x Viewport) AsCPtr() *Viewport {
	clone := (*Viewport)(newCBlock(C.ulong(SizeofViewport)))
	*clone = x
	return clone
}

// ViewportFreeCSlice releases the memory allocated by ViewportMakeCSlice.
// It does not free pointers stored inside the slice.
func ViewportFreeCSlice(x []Viewport) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ViewportMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ViewportFreeCSlice must be called on the returned slice.
func ViewportMakeCSlice(x ...Viewport) []Viewport {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofViewport * len(x)
	dst := unsafe.Slice((*Viewport)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// X returns the value of x from VkViewport
func (x Viewport) X() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ return (*float32)(unsafe.Pointer(x)) }(&x.x)
	return *ptr
}

// WithX sets the value for the X on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Viewport) WithX(y float32) Viewport {
	ptr := func(x *float32) *C.float { /* Scalar */ return (*C.float)(unsafe.Pointer(x)) }(&y)
	x.x = *ptr
	return x
}

// Y returns the value of y from VkViewport
func (x Viewport) Y() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ return (*float32)(unsafe.Pointer(x)) }(&x.y)
	return *ptr
}

// WithY sets the value for the Y on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Viewport) WithY(y float32) Viewport {
	ptr := func(x *float32) *C.float { /* Scalar */ return (*C.float)(unsafe.Pointer(x)) }(&y)
	x.y = *ptr
	return x
}

// Width returns the value of width from VkViewport
func (x Viewport) Width() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ return (*float32)(unsafe.Pointer(x)) }(&x.width)
	return *ptr
}

// WithWidth sets the value for the Width on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Viewport) WithWidth(y float32) Viewport {
	ptr := func(x *float32) *C.float { /* Scalar */ return (*C.float)(unsafe.Pointer(x)) }(&y)
	x.width = *ptr
	return x
}

// Height returns the value of height from VkViewport
func (x Viewport) Height() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ return (*float32)(unsafe.Pointer(x)) }(&x.height)
	return *ptr
}

// WithHeight sets the value for the Height on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Viewport) WithHeight(y float32) Viewport {
	ptr := func(x *float32) *C.float { /* Scalar */ return (*C.float)(unsafe.Pointer(x)) }(&y)
	x.height = *ptr
	return x
}

// MinDepth returns the value of minDepth from VkViewport
func (x Viewport) MinDepth() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ return (*float32)(unsafe.Pointer(x)) }(&x.minDepth)
	return *ptr
}

// WithMinDepth sets the value for the MinDepth on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Viewport) WithMinDepth(y float32) Viewport {
	ptr := func(x *float32) *C.float { /* Scalar */ return (*C.float)(unsafe.Pointer(x)) }(&y)
	x.minDepth = *ptr
	return x
}

// MaxDepth returns the value of maxDepth from VkViewport
func (x Viewport) MaxDepth() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ return (*float32)(unsafe.Pointer(x)) }(&x.maxDepth)
	return *ptr
}

// WithMaxDepth sets the value for the MaxDepth on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Viewport) WithMaxDepth(y float32) Viewport {
	ptr := func(x *float32) *C.float { /* Scalar */ return (*C.float)(unsafe.Pointer(x)) }(&y)
	x.maxDepth = *ptr
	return x
}

//DescriptorPoolCreateInfo provides a go interface for VkDescriptorPoolCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorPoolCreateInfo.html
type DescriptorPoolCreateInfo C.struct_VkDescriptorPoolCreateInfo

// SizeofDescriptorPoolCreateInfo is the memory size of a DescriptorPoolCreateInfo
var SizeofDescriptorPoolCreateInfo int = int(unsafe.Sizeof(DescriptorPoolCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorPoolCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorPoolCreateInfo) AsCPtr() *DescriptorPoolCreateInfo {
	clone := (*DescriptorPoolCreateInfo)(newCBlock(C.ulong(SizeofDescriptorPoolCreateInfo)))
	*clone = x
	return clone
}

// DescriptorPoolCreateInfoFreeCSlice releases the memory allocated by DescriptorPoolCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorPoolCreateInfoFreeCSlice(x []DescriptorPoolCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorPoolCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorPoolCreateInfoFreeCSlice must be called on the returned slice.
func DescriptorPoolCreateInfoMakeCSlice(x ...DescriptorPoolCreateInfo) []DescriptorPoolCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorPoolCreateInfo * len(x)
	dst := unsafe.Slice((*DescriptorPoolCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDescriptorPoolCreateInfo
func (x DescriptorPoolCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DescriptorPoolCreateInfo) WithDefaultSType() DescriptorPoolCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorPoolCreateInfo) WithSType(y StructureType) DescriptorPoolCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDescriptorPoolCreateInfo
func (x DescriptorPoolCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorPoolCreateInfo) WithPNext(y unsafe.Pointer) DescriptorPoolCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkDescriptorPoolCreateInfo
func (x DescriptorPoolCreateInfo) Flags() DescriptorPoolCreateFlags {
	ptr := /* typedef */ (*DescriptorPoolCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorPoolCreateInfo) WithFlags(y DescriptorPoolCreateFlags) DescriptorPoolCreateInfo {
	ptr := /* typedef */ (*C.VkDescriptorPoolCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// MaxSets returns the value of maxSets from VkDescriptorPoolCreateInfo
func (x DescriptorPoolCreateInfo) MaxSets() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxSets)
	return *ptr
}

// WithMaxSets sets the value for the MaxSets on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorPoolCreateInfo) WithMaxSets(y uint32) DescriptorPoolCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.maxSets = *ptr
	return x
}

// PoolSizeCount returns the value of poolSizeCount from VkDescriptorPoolCreateInfo
func (x DescriptorPoolCreateInfo) PoolSizeCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.poolSizeCount)
	return *ptr
}

// WithPoolSizeCount sets the value for the PoolSizeCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorPoolCreateInfo) WithPoolSizeCount(y uint32) DescriptorPoolCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.poolSizeCount = *ptr
	return x
}

// PPoolSizes returns the value of pPoolSizes from VkDescriptorPoolCreateInfo
func (x DescriptorPoolCreateInfo) PPoolSizes() []DescriptorPoolSize {
	ptr := func(x **C.struct_VkDescriptorPoolSize) *[]DescriptorPoolSize { /* Slice */
		slc := unsafe.Slice((*DescriptorPoolSize)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pPoolSizes)
	return *ptr
}

// WithPPoolSizes sets the value for the PPoolSizes on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines PoolSizeCount as the length of this field.
// PoolSizeCount is updated with the length of the new value.
func (x DescriptorPoolCreateInfo) WithPPoolSizes(y []DescriptorPoolSize) DescriptorPoolCreateInfo {
	ptr := func(x *[]DescriptorPoolSize) **C.struct_VkDescriptorPoolSize { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDescriptorPoolSize)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDescriptorPoolSize)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pPoolSizes = *ptr
	return x.WithPoolSizeCount(uint32(len(y)))
}

//Extent3D provides a go interface for VkExtent3D.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkExtent3D.html
type Extent3D C.struct_VkExtent3D

// SizeofExtent3D is the memory size of a Extent3D
var SizeofExtent3D int = int(unsafe.Sizeof(Extent3D{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *Extent3D) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x Extent3D) AsCPtr() *Extent3D {
	clone := (*Extent3D)(newCBlock(C.ulong(SizeofExtent3D)))
	*clone = x
	return clone
}

// Extent3DFreeCSlice releases the memory allocated by Extent3DMakeCSlice.
// It does not free pointers stored inside the slice.
func Extent3DFreeCSlice(x []Extent3D) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// Extent3DMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. Extent3DFreeCSlice must be called on the returned slice.
func Extent3DMakeCSlice(x ...Extent3D) []Extent3D {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExtent3D * len(x)
	dst := unsafe.Slice((*Extent3D)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Width returns the value of width from VkExtent3D
func (x Extent3D) Width() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.width)
	return *ptr
}

// WithWidth sets the value for the Width on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Extent3D) WithWidth(y uint32) Extent3D {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.width = *ptr
	return x
}

// Height returns the value of height from VkExtent3D
func (x Extent3D) Height() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.height)
	return *ptr
}

// WithHeight sets the value for the Height on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Extent3D) WithHeight(y uint32) Extent3D {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.height = *ptr
	return x
}

// Depth returns the value of depth from VkExtent3D
func (x Extent3D) Depth() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.depth)
	return *ptr
}

// WithDepth sets the value for the Depth on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Extent3D) WithDepth(y uint32) Extent3D {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.depth = *ptr
	return x
}

//Extent2D provides a go interface for VkExtent2D.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkExtent2D.html
type Extent2D C.struct_VkExtent2D

// SizeofExtent2D is the memory size of a Extent2D
var SizeofExtent2D int = int(unsafe.Sizeof(Extent2D{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *Extent2D) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x Extent2D) AsCPtr() *Extent2D {
	clone := (*Extent2D)(newCBlock(C.ulong(SizeofExtent2D)))
	*clone = x
	return clone
}

// Extent2DFreeCSlice releases the memory allocated by Extent2DMakeCSlice.
// It does not free pointers stored inside the slice.
func Extent2DFreeCSlice(x []Extent2D) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// Extent2DMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. Extent2DFreeCSlice must be called on the returned slice.
func Extent2DMakeCSlice(x ...Extent2D) []Extent2D {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExtent2D * len(x)
	dst := unsafe.Slice((*Extent2D)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Width returns the value of width from VkExtent2D
func (x Extent2D) Width() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.width)
	return *ptr
}

// WithWidth sets the value for the Width on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Extent2D) WithWidth(y uint32) Extent2D {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.width = *ptr
	return x
}

// Height returns the value of height from VkExtent2D
func (x Extent2D) Height() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.height)
	return *ptr
}

// WithHeight sets the value for the Height on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Extent2D) WithHeight(y uint32) Extent2D {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.height = *ptr
	return x
}

//PipelineLayoutCreateInfo provides a go interface for VkPipelineLayoutCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineLayoutCreateInfo.html
type PipelineLayoutCreateInfo C.struct_VkPipelineLayoutCreateInfo

// SizeofPipelineLayoutCreateInfo is the memory size of a PipelineLayoutCreateInfo
var SizeofPipelineLayoutCreateInfo int = int(unsafe.Sizeof(PipelineLayoutCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineLayoutCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineLayoutCreateInfo) AsCPtr() *PipelineLayoutCreateInfo {
	clone := (*PipelineLayoutCreateInfo)(newCBlock(C.ulong(SizeofPipelineLayoutCreateInfo)))
	*clone = x
	return clone
}

// PipelineLayoutCreateInfoFreeCSlice releases the memory allocated by PipelineLayoutCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineLayoutCreateInfoFreeCSlice(x []PipelineLayoutCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineLayoutCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineLayoutCreateInfoFreeCSlice must be called on the returned slice.
func PipelineLayoutCreateInfoMakeCSlice(x ...PipelineLayoutCreateInfo) []PipelineLayoutCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineLayoutCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineLayoutCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineLayoutCreateInfo
func (x PipelineLayoutCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineLayoutCreateInfo) WithDefaultSType() PipelineLayoutCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineLayoutCreateInfo) WithSType(y StructureType) PipelineLayoutCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPipelineLayoutCreateInfo
func (x PipelineLayoutCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineLayoutCreateInfo) WithPNext(y unsafe.Pointer) PipelineLayoutCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkPipelineLayoutCreateInfo
func (x PipelineLayoutCreateInfo) Flags() PipelineLayoutCreateFlags {
	ptr := /* typedef */ (*PipelineLayoutCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineLayoutCreateInfo) WithFlags(y PipelineLayoutCreateFlags) PipelineLayoutCreateInfo {
	ptr := /* typedef */ (*C.VkPipelineLayoutCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// SetLayoutCount returns the value of setLayoutCount from VkPipelineLayoutCreateInfo
func (x PipelineLayoutCreateInfo) SetLayoutCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.setLayoutCount)
	return *ptr
}

// WithSetLayoutCount sets the value for the SetLayoutCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineLayoutCreateInfo) WithSetLayoutCount(y uint32) PipelineLayoutCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.setLayoutCount = *ptr
	return x
}

// PSetLayouts returns the value of pSetLayouts from VkPipelineLayoutCreateInfo
func (x PipelineLayoutCreateInfo) PSetLayouts() []DescriptorSetLayout {
	ptr := func(x **C.VkDescriptorSetLayout) *[]DescriptorSetLayout { /* Slice */
		slc := unsafe.Slice((*DescriptorSetLayout)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pSetLayouts)
	return *ptr
}

// WithPSetLayouts sets the value for the PSetLayouts on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SetLayoutCount as the length of this field.
// SetLayoutCount is updated with the length of the new value.
func (x PipelineLayoutCreateInfo) WithPSetLayouts(y []DescriptorSetLayout) PipelineLayoutCreateInfo {
	ptr := func(x *[]DescriptorSetLayout) **C.VkDescriptorSetLayout { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkDescriptorSetLayout)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkDescriptorSetLayout)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pSetLayouts = *ptr
	return x.WithSetLayoutCount(uint32(len(y)))
}

// PushConstantRangeCount returns the value of pushConstantRangeCount from VkPipelineLayoutCreateInfo
func (x PipelineLayoutCreateInfo) PushConstantRangeCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.pushConstantRangeCount)
	return *ptr
}

// WithPushConstantRangeCount sets the value for the PushConstantRangeCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineLayoutCreateInfo) WithPushConstantRangeCount(y uint32) PipelineLayoutCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.pushConstantRangeCount = *ptr
	return x
}

// PPushConstantRanges returns the value of pPushConstantRanges from VkPipelineLayoutCreateInfo
func (x PipelineLayoutCreateInfo) PPushConstantRanges() []PushConstantRange {
	ptr := func(x **C.struct_VkPushConstantRange) *[]PushConstantRange { /* Slice */
		slc := unsafe.Slice((*PushConstantRange)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pPushConstantRanges)
	return *ptr
}

// WithPPushConstantRanges sets the value for the PPushConstantRanges on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines PushConstantRangeCount as the length of this field.
// PushConstantRangeCount is updated with the length of the new value.
func (x PipelineLayoutCreateInfo) WithPPushConstantRanges(y []PushConstantRange) PipelineLayoutCreateInfo {
	ptr := func(x *[]PushConstantRange) **C.struct_VkPushConstantRange { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkPushConstantRange)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkPushConstantRange)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pPushConstantRanges = *ptr
	return x.WithPushConstantRangeCount(uint32(len(y)))
}

//PushConstantRange provides a go interface for VkPushConstantRange.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPushConstantRange.html
type PushConstantRange C.struct_VkPushConstantRange

// SizeofPushConstantRange is the memory size of a PushConstantRange
var SizeofPushConstantRange int = int(unsafe.Sizeof(PushConstantRange{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PushConstantRange) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PushConstantRange) AsCPtr() *PushConstantRange {
	clone := (*PushConstantRange)(newCBlock(C.ulong(SizeofPushConstantRange)))
	*clone = x
	return clone
}

// PushConstantRangeFreeCSlice releases the memory allocated by PushConstantRangeMakeCSlice.
// It does not free pointers stored inside the slice.
func PushConstantRangeFreeCSlice(x []PushConstantRange) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PushConstantRangeMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PushConstantRangeFreeCSlice must be called on the returned slice.
func PushConstantRangeMakeCSlice(x ...PushConstantRange) []PushConstantRange {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPushConstantRange * len(x)
	dst := unsafe.Slice((*PushConstantRange)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// StageFlags returns the value of stageFlags from VkPushConstantRange
func (x PushConstantRange) StageFlags() ShaderStageFlags {
	ptr := /* typedef */ (*ShaderStageFlags)(&x.stageFlags)
	return *ptr
}

// WithStageFlags sets the value for the StageFlags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PushConstantRange) WithStageFlags(y ShaderStageFlags) PushConstantRange {
	ptr := /* typedef */ (*C.VkShaderStageFlags)(&y)
	x.stageFlags = *ptr
	return x
}

// Offset returns the value of offset from VkPushConstantRange
func (x PushConstantRange) Offset() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.offset)
	return *ptr
}

// WithOffset sets the value for the Offset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PushConstantRange) WithOffset(y uint32) PushConstantRange {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.offset = *ptr
	return x
}

// Size returns the value of size from VkPushConstantRange
func (x PushConstantRange) Size() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.size)
	return *ptr
}

// WithSize sets the value for the Size on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PushConstantRange) WithSize(y uint32) PushConstantRange {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.size = *ptr
	return x
}

//DescriptorBufferInfo provides a go interface for VkDescriptorBufferInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorBufferInfo.html
type DescriptorBufferInfo C.struct_VkDescriptorBufferInfo

// SizeofDescriptorBufferInfo is the memory size of a DescriptorBufferInfo
var SizeofDescriptorBufferInfo int = int(unsafe.Sizeof(DescriptorBufferInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorBufferInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorBufferInfo) AsCPtr() *DescriptorBufferInfo {
	clone := (*DescriptorBufferInfo)(newCBlock(C.ulong(SizeofDescriptorBufferInfo)))
	*clone = x
	return clone
}

// DescriptorBufferInfoFreeCSlice releases the memory allocated by DescriptorBufferInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorBufferInfoFreeCSlice(x []DescriptorBufferInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorBufferInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorBufferInfoFreeCSlice must be called on the returned slice.
func DescriptorBufferInfoMakeCSlice(x ...DescriptorBufferInfo) []DescriptorBufferInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorBufferInfo * len(x)
	dst := unsafe.Slice((*DescriptorBufferInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Buffer returns the value of buffer from VkDescriptorBufferInfo
func (x DescriptorBufferInfo) Buffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.buffer)
	return *ptr
}

// WithBuffer sets the value for the Buffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorBufferInfo) WithBuffer(y Buffer) DescriptorBufferInfo {
	ptr := /* handle */ (*C.VkBuffer)(&y)
	x.buffer = *ptr
	return x
}

// Offset returns the value of offset from VkDescriptorBufferInfo
func (x DescriptorBufferInfo) Offset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.offset)
	return *ptr
}

// WithOffset sets the value for the Offset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorBufferInfo) WithOffset(y DeviceSize) DescriptorBufferInfo {
	ptr := /* typedef */ (*C.VkDeviceSize)(&y)
	x.offset = *ptr
	return x
}

// Range_ returns the value of range from VkDescriptorBufferInfo
func (x DescriptorBufferInfo) Range_() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x._range)
	return *ptr
}

// WithRange_ sets the value for the Range_ on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorBufferInfo) WithRange_(y DeviceSize) DescriptorBufferInfo {
	ptr := /* typedef */ (*C.VkDeviceSize)(&y)
	x._range = *ptr
	return x
}

// ClearValue is a union from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkClearValue.html
type ClearValue C.VkClearValue

// Copy the provided byte slice into the structure.
//
// Unions are represented as byte arrays in go. Use this method to copy from a source
// byte slice into the union byte array.
func (x ClearValue) copy(y []byte) ClearValue {
	copy(x[:], y)
	return x
}

// ClearColorValue is a union from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkClearColorValue.html
type ClearColorValue C.VkClearColorValue

// Copy the provided byte slice into the structure.
//
// Unions are represented as byte arrays in go. Use this method to copy from a source
// byte slice into the union byte array.
func (x ClearColorValue) copy(y []byte) ClearColorValue {
	copy(x[:], y)
	return x
}

func (x PhysicalDeviceFacade) GetPhysicalDeviceImageFormatProperties(format Format, type_ ImageType, tiling ImageTiling, usage ImageUsageFlags, flags ImageCreateFlags, pImageFormatProperties *ImageFormatProperties) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* typedef */ (*C.VkFormat)(&format)
	p2 := /* typedef */ (*C.VkImageType)(&type_)
	p3 := /* typedef */ (*C.VkImageTiling)(&tiling)
	p4 := /* typedef */ (*C.VkImageUsageFlags)(&usage)
	p5 := /* typedef */ (*C.VkImageCreateFlags)(&flags)
	p6 := func(x **ImageFormatProperties) **C.struct_VkImageFormatProperties { /* Pointer */
		return (**C.struct_VkImageFormatProperties)(unsafe.Pointer(x))
	}(&pImageFormatProperties)
	ret := C.vkGetPhysicalDeviceImageFormatProperties(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) DestroyDescriptorPool(descriptorPool DescriptorPool, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDescriptorPool)(&descriptorPool)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	C.vkDestroyDescriptorPool(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) ResetDescriptorPool(descriptorPool DescriptorPool, flags DescriptorPoolResetFlags) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDescriptorPool)(&descriptorPool)
	p2 := /* typedef */ (*C.VkDescriptorPoolResetFlags)(&flags)
	ret := C.vkResetDescriptorPool(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) AllocateDescriptorSets(pAllocateInfo *DescriptorSetAllocateInfo, pDescriptorSets []DescriptorSet) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DescriptorSetAllocateInfo) **C.struct_VkDescriptorSetAllocateInfo { /* Pointer */
		return (**C.struct_VkDescriptorSetAllocateInfo)(unsafe.Pointer(x))
	}(&pAllocateInfo)
	p2 := func(x *[]DescriptorSet) **C.VkDescriptorSet { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkDescriptorSet)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkDescriptorSet)(unsafe.Pointer((&ptr)))
	}(&pDescriptorSets)
	ret := C.vkAllocateDescriptorSets(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) FreeDescriptorSets(descriptorPool DescriptorPool, descriptorSetCount uint32, pDescriptorSets []DescriptorSet) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDescriptorPool)(&descriptorPool)
	p2 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&descriptorSetCount)
	p3 := func(x *[]DescriptorSet) **C.VkDescriptorSet { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkDescriptorSet)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkDescriptorSet)(unsafe.Pointer((&ptr)))
	}(&pDescriptorSets)
	ret := C.vkFreeDescriptorSets(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) UpdateDescriptorSets(descriptorWriteCount uint32, pDescriptorWrites []WriteDescriptorSet, descriptorCopyCount uint32, pDescriptorCopies []CopyDescriptorSet) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&descriptorWriteCount)
	p2 := func(x *[]WriteDescriptorSet) **C.struct_VkWriteDescriptorSet { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkWriteDescriptorSet)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkWriteDescriptorSet)(unsafe.Pointer((&ptr)))
	}(&pDescriptorWrites)
	p3 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&descriptorCopyCount)
	p4 := func(x *[]CopyDescriptorSet) **C.struct_VkCopyDescriptorSet { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkCopyDescriptorSet)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkCopyDescriptorSet)(unsafe.Pointer((&ptr)))
	}(&pDescriptorCopies)
	C.vkUpdateDescriptorSets(addrs, *p0, *p1, *p2, *p3, *p4)
}

func (x DeviceFacade) CreateDescriptorPool(pCreateInfo *DescriptorPoolCreateInfo, pAllocator *AllocationCallbacks, pDescriptorPool *DescriptorPool) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DescriptorPoolCreateInfo) **C.struct_VkDescriptorPoolCreateInfo { /* Pointer */
		return (**C.struct_VkDescriptorPoolCreateInfo)(unsafe.Pointer(x))
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p3 := func(x **DescriptorPool) **C.VkDescriptorPool { /* Pointer */
		return (**C.VkDescriptorPool)(unsafe.Pointer(x))
	}(&pDescriptorPool)
	ret := C.vkCreateDescriptorPool(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) DestroyDescriptorSetLayout(descriptorSetLayout DescriptorSetLayout, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDescriptorSetLayout)(&descriptorSetLayout)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	C.vkDestroyDescriptorSetLayout(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) CreateDescriptorSetLayout(pCreateInfo *DescriptorSetLayoutCreateInfo, pAllocator *AllocationCallbacks, pSetLayout *DescriptorSetLayout) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DescriptorSetLayoutCreateInfo) **C.struct_VkDescriptorSetLayoutCreateInfo { /* Pointer */
		return (**C.struct_VkDescriptorSetLayoutCreateInfo)(unsafe.Pointer(x))
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p3 := func(x **DescriptorSetLayout) **C.VkDescriptorSetLayout { /* Pointer */
		return (**C.VkDescriptorSetLayout)(unsafe.Pointer(x))
	}(&pSetLayout)
	ret := C.vkCreateDescriptorSetLayout(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) DestroySampler(sampler Sampler, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkSampler)(&sampler)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	C.vkDestroySampler(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) CreateSampler(pCreateInfo *SamplerCreateInfo, pAllocator *AllocationCallbacks, pSampler *Sampler) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **SamplerCreateInfo) **C.struct_VkSamplerCreateInfo { /* Pointer */
		return (**C.struct_VkSamplerCreateInfo)(unsafe.Pointer(x))
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p3 := func(x **Sampler) **C.VkSampler { /* Pointer */ return (**C.VkSampler)(unsafe.Pointer(x)) }(&pSampler)
	ret := C.vkCreateSampler(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) DestroyPipelineLayout(pipelineLayout PipelineLayout, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkPipelineLayout)(&pipelineLayout)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	C.vkDestroyPipelineLayout(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) CreatePipelineLayout(pCreateInfo *PipelineLayoutCreateInfo, pAllocator *AllocationCallbacks, pPipelineLayout *PipelineLayout) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **PipelineLayoutCreateInfo) **C.struct_VkPipelineLayoutCreateInfo { /* Pointer */
		return (**C.struct_VkPipelineLayoutCreateInfo)(unsafe.Pointer(x))
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p3 := func(x **PipelineLayout) **C.VkPipelineLayout { /* Pointer */
		return (**C.VkPipelineLayout)(unsafe.Pointer(x))
	}(&pPipelineLayout)
	ret := C.vkCreatePipelineLayout(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) DestroyPipeline(pipeline Pipeline, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkPipeline)(&pipeline)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	C.vkDestroyPipeline(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) CreateComputePipelines(pipelineCache PipelineCache, createInfoCount uint32, pCreateInfos []ComputePipelineCreateInfo, pAllocator *AllocationCallbacks, pPipelines []Pipeline) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkPipelineCache)(&pipelineCache)
	p2 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&createInfoCount)
	p3 := func(x *[]ComputePipelineCreateInfo) **C.struct_VkComputePipelineCreateInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkComputePipelineCreateInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkComputePipelineCreateInfo)(unsafe.Pointer((&ptr)))
	}(&pCreateInfos)
	p4 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p5 := func(x *[]Pipeline) **C.VkPipeline { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkPipeline)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkPipeline)(unsafe.Pointer((&ptr)))
	}(&pPipelines)
	ret := C.vkCreateComputePipelines(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) CreateGraphicsPipelines(pipelineCache PipelineCache, createInfoCount uint32, pCreateInfos []GraphicsPipelineCreateInfo, pAllocator *AllocationCallbacks, pPipelines []Pipeline) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkPipelineCache)(&pipelineCache)
	p2 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&createInfoCount)
	p3 := func(x *[]GraphicsPipelineCreateInfo) **C.struct_VkGraphicsPipelineCreateInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkGraphicsPipelineCreateInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkGraphicsPipelineCreateInfo)(unsafe.Pointer((&ptr)))
	}(&pCreateInfos)
	p4 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p5 := func(x *[]Pipeline) **C.VkPipeline { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkPipeline)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkPipeline)(unsafe.Pointer((&ptr)))
	}(&pPipelines)
	ret := C.vkCreateGraphicsPipelines(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) MergePipelineCaches(dstCache PipelineCache, srcCacheCount uint32, pSrcCaches []PipelineCache) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkPipelineCache)(&dstCache)
	p2 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&srcCacheCount)
	p3 := func(x *[]PipelineCache) **C.VkPipelineCache { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkPipelineCache)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkPipelineCache)(unsafe.Pointer((&ptr)))
	}(&pSrcCaches)
	ret := C.vkMergePipelineCaches(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) GetPipelineCacheData(pipelineCache PipelineCache, pDataSize *uint64, pData unsafe.Pointer) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkPipelineCache)(&pipelineCache)
	p2 := func(x **uint64) **C.ulong { /* Pointer */ return (**C.ulong)(unsafe.Pointer(x)) }(&pDataSize)
	p3 := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&pData)
	ret := C.vkGetPipelineCacheData(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) DestroyPipelineCache(pipelineCache PipelineCache, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkPipelineCache)(&pipelineCache)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	C.vkDestroyPipelineCache(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) CreatePipelineCache(pCreateInfo *PipelineCacheCreateInfo, pAllocator *AllocationCallbacks, pPipelineCache *PipelineCache) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **PipelineCacheCreateInfo) **C.struct_VkPipelineCacheCreateInfo { /* Pointer */
		return (**C.struct_VkPipelineCacheCreateInfo)(unsafe.Pointer(x))
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p3 := func(x **PipelineCache) **C.VkPipelineCache { /* Pointer */
		return (**C.VkPipelineCache)(unsafe.Pointer(x))
	}(&pPipelineCache)
	ret := C.vkCreatePipelineCache(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) DestroyShaderModule(shaderModule ShaderModule, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkShaderModule)(&shaderModule)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	C.vkDestroyShaderModule(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) CreateShaderModule(pCreateInfo *ShaderModuleCreateInfo, pAllocator *AllocationCallbacks, pShaderModule *ShaderModule) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **ShaderModuleCreateInfo) **C.struct_VkShaderModuleCreateInfo { /* Pointer */
		return (**C.struct_VkShaderModuleCreateInfo)(unsafe.Pointer(x))
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p3 := func(x **ShaderModule) **C.VkShaderModule { /* Pointer */ return (**C.VkShaderModule)(unsafe.Pointer(x)) }(&pShaderModule)
	ret := C.vkCreateShaderModule(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) DestroyImageView(imageView ImageView, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkImageView)(&imageView)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	C.vkDestroyImageView(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) CreateImageView(pCreateInfo *ImageViewCreateInfo, pAllocator *AllocationCallbacks, pView *ImageView) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **ImageViewCreateInfo) **C.struct_VkImageViewCreateInfo { /* Pointer */
		return (**C.struct_VkImageViewCreateInfo)(unsafe.Pointer(x))
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p3 := func(x **ImageView) **C.VkImageView { /* Pointer */ return (**C.VkImageView)(unsafe.Pointer(x)) }(&pView)
	ret := C.vkCreateImageView(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) CreateFramebuffer(pCreateInfo *FramebufferCreateInfo, pAllocator *AllocationCallbacks, pFramebuffer *Framebuffer) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **FramebufferCreateInfo) **C.struct_VkFramebufferCreateInfo { /* Pointer */
		return (**C.struct_VkFramebufferCreateInfo)(unsafe.Pointer(x))
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p3 := func(x **Framebuffer) **C.VkFramebuffer { /* Pointer */ return (**C.VkFramebuffer)(unsafe.Pointer(x)) }(&pFramebuffer)
	ret := C.vkCreateFramebuffer(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) DestroyFramebuffer(framebuffer Framebuffer, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkFramebuffer)(&framebuffer)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	C.vkDestroyFramebuffer(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) CreateRenderPass(pCreateInfo *RenderPassCreateInfo, pAllocator *AllocationCallbacks, pRenderPass *RenderPass) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **RenderPassCreateInfo) **C.struct_VkRenderPassCreateInfo { /* Pointer */
		return (**C.struct_VkRenderPassCreateInfo)(unsafe.Pointer(x))
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p3 := func(x **RenderPass) **C.VkRenderPass { /* Pointer */ return (**C.VkRenderPass)(unsafe.Pointer(x)) }(&pRenderPass)
	ret := C.vkCreateRenderPass(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) DestroyRenderPass(renderPass RenderPass, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkRenderPass)(&renderPass)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	C.vkDestroyRenderPass(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) GetRenderAreaGranularity(renderPass RenderPass, pGranularity *Extent2D) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkRenderPass)(&renderPass)
	p2 := func(x **Extent2D) **C.struct_VkExtent2D { /* Pointer */
		return (**C.struct_VkExtent2D)(unsafe.Pointer(x))
	}(&pGranularity)
	C.vkGetRenderAreaGranularity(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) GetImageSubresourceLayout(image Image, pSubresource *ImageSubresource, pLayout *SubresourceLayout) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&image)
	p2 := func(x **ImageSubresource) **C.struct_VkImageSubresource { /* Pointer */
		return (**C.struct_VkImageSubresource)(unsafe.Pointer(x))
	}(&pSubresource)
	p3 := func(x **SubresourceLayout) **C.struct_VkSubresourceLayout { /* Pointer */
		return (**C.struct_VkSubresourceLayout)(unsafe.Pointer(x))
	}(&pLayout)
	C.vkGetImageSubresourceLayout(addrs, *p0, *p1, *p2, *p3)
}

func (x DeviceFacade) DestroyImage(image Image, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&image)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	C.vkDestroyImage(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) CreateImage(pCreateInfo *ImageCreateInfo, pAllocator *AllocationCallbacks, pImage *Image) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **ImageCreateInfo) **C.struct_VkImageCreateInfo { /* Pointer */
		return (**C.struct_VkImageCreateInfo)(unsafe.Pointer(x))
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p3 := func(x **Image) **C.VkImage { /* Pointer */ return (**C.VkImage)(unsafe.Pointer(x)) }(&pImage)
	ret := C.vkCreateImage(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) DestroyBufferView(bufferView BufferView, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkBufferView)(&bufferView)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	C.vkDestroyBufferView(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) CreateBufferView(pCreateInfo *BufferViewCreateInfo, pAllocator *AllocationCallbacks, pView *BufferView) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **BufferViewCreateInfo) **C.struct_VkBufferViewCreateInfo { /* Pointer */
		return (**C.struct_VkBufferViewCreateInfo)(unsafe.Pointer(x))
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p3 := func(x **BufferView) **C.VkBufferView { /* Pointer */ return (**C.VkBufferView)(unsafe.Pointer(x)) }(&pView)
	ret := C.vkCreateBufferView(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) DestroyBuffer(buffer Buffer, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&buffer)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	C.vkDestroyBuffer(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) CreateBuffer(pCreateInfo *BufferCreateInfo, pAllocator *AllocationCallbacks, pBuffer *Buffer) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **BufferCreateInfo) **C.struct_VkBufferCreateInfo { /* Pointer */
		return (**C.struct_VkBufferCreateInfo)(unsafe.Pointer(x))
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p3 := func(x **Buffer) **C.VkBuffer { /* Pointer */ return (**C.VkBuffer)(unsafe.Pointer(x)) }(&pBuffer)
	ret := C.vkCreateBuffer(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) GetQueryPoolResults(queryPool QueryPool, firstQuery uint32, queryCount uint32, dataSize uint64, pData unsafe.Pointer, stride DeviceSize, flags QueryResultFlags) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkQueryPool)(&queryPool)
	p2 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&firstQuery)
	p3 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&queryCount)
	p4 := func(x *uint64) *C.ulong { /* Scalar */ return (*C.ulong)(unsafe.Pointer(x)) }(&dataSize)
	p5 := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&pData)
	p6 := /* typedef */ (*C.VkDeviceSize)(&stride)
	p7 := /* typedef */ (*C.VkQueryResultFlags)(&flags)
	ret := C.vkGetQueryPoolResults(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) DestroyQueryPool(queryPool QueryPool, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkQueryPool)(&queryPool)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	C.vkDestroyQueryPool(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) CreateQueryPool(pCreateInfo *QueryPoolCreateInfo, pAllocator *AllocationCallbacks, pQueryPool *QueryPool) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **QueryPoolCreateInfo) **C.struct_VkQueryPoolCreateInfo { /* Pointer */
		return (**C.struct_VkQueryPoolCreateInfo)(unsafe.Pointer(x))
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p3 := func(x **QueryPool) **C.VkQueryPool { /* Pointer */ return (**C.VkQueryPool)(unsafe.Pointer(x)) }(&pQueryPool)
	ret := C.vkCreateQueryPool(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) ResetEvent(event Event) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkEvent)(&event)
	ret := C.vkResetEvent(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) SetEvent(event Event) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkEvent)(&event)
	ret := C.vkSetEvent(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) GetEventStatus(event Event) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkEvent)(&event)
	ret := C.vkGetEventStatus(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) DestroyEvent(event Event, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkEvent)(&event)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	C.vkDestroyEvent(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) CreateEvent(pCreateInfo *EventCreateInfo, pAllocator *AllocationCallbacks, pEvent *Event) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **EventCreateInfo) **C.struct_VkEventCreateInfo { /* Pointer */
		return (**C.struct_VkEventCreateInfo)(unsafe.Pointer(x))
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p3 := func(x **Event) **C.VkEvent { /* Pointer */ return (**C.VkEvent)(unsafe.Pointer(x)) }(&pEvent)
	ret := C.vkCreateEvent(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) DestroySemaphore(semaphore Semaphore, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkSemaphore)(&semaphore)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	C.vkDestroySemaphore(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) CreateSemaphore(pCreateInfo *SemaphoreCreateInfo, pAllocator *AllocationCallbacks, pSemaphore *Semaphore) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **SemaphoreCreateInfo) **C.struct_VkSemaphoreCreateInfo { /* Pointer */
		return (**C.struct_VkSemaphoreCreateInfo)(unsafe.Pointer(x))
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p3 := func(x **Semaphore) **C.VkSemaphore { /* Pointer */ return (**C.VkSemaphore)(unsafe.Pointer(x)) }(&pSemaphore)
	ret := C.vkCreateSemaphore(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) WaitForFences(fenceCount uint32, pFences []Fence, waitAll Bool32, timeout uint64) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&fenceCount)
	p2 := func(x *[]Fence) **C.VkFence { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkFence)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkFence)(unsafe.Pointer((&ptr)))
	}(&pFences)
	p3 := /* typedef */ (*C.VkBool32)(&waitAll)
	p4 := func(x *uint64) *C.ulonglong { /* Scalar */ return (*C.ulonglong)(unsafe.Pointer(x)) }(&timeout)
	ret := C.vkWaitForFences(addrs, *p0, *p1, *p2, *p3, *p4)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) GetFenceStatus(fence Fence) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkFence)(&fence)
	ret := C.vkGetFenceStatus(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) ResetFences(fenceCount uint32, pFences []Fence) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&fenceCount)
	p2 := func(x *[]Fence) **C.VkFence { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkFence)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkFence)(unsafe.Pointer((&ptr)))
	}(&pFences)
	ret := C.vkResetFences(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) DestroyFence(fence Fence, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkFence)(&fence)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	C.vkDestroyFence(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) CreateFence(pCreateInfo *FenceCreateInfo, pAllocator *AllocationCallbacks, pFence *Fence) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **FenceCreateInfo) **C.struct_VkFenceCreateInfo { /* Pointer */
		return (**C.struct_VkFenceCreateInfo)(unsafe.Pointer(x))
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p3 := func(x **Fence) **C.VkFence { /* Pointer */ return (**C.VkFence)(unsafe.Pointer(x)) }(&pFence)
	ret := C.vkCreateFence(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x QueueFacade) QueueBindSparse(bindInfoCount uint32, pBindInfo []BindSparseInfo, fence Fence) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkQueue)(&x.H)
	p1 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&bindInfoCount)
	p2 := func(x *[]BindSparseInfo) **C.struct_VkBindSparseInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkBindSparseInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkBindSparseInfo)(unsafe.Pointer((&ptr)))
	}(&pBindInfo)
	p3 := /* handle */ (*C.VkFence)(&fence)
	ret := C.vkQueueBindSparse(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) CreateCommandPool(pCreateInfo *CommandPoolCreateInfo, pAllocator *AllocationCallbacks, pCommandPool *CommandPool) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **CommandPoolCreateInfo) **C.struct_VkCommandPoolCreateInfo { /* Pointer */
		return (**C.struct_VkCommandPoolCreateInfo)(unsafe.Pointer(x))
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p3 := func(x **CommandPool) **C.VkCommandPool { /* Pointer */ return (**C.VkCommandPool)(unsafe.Pointer(x)) }(&pCommandPool)
	ret := C.vkCreateCommandPool(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) DestroyCommandPool(commandPool CommandPool, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkCommandPool)(&commandPool)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	C.vkDestroyCommandPool(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) ResetCommandPool(commandPool CommandPool, flags CommandPoolResetFlags) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkCommandPool)(&commandPool)
	p2 := /* typedef */ (*C.VkCommandPoolResetFlags)(&flags)
	ret := C.vkResetCommandPool(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x PhysicalDeviceFacade) GetPhysicalDeviceSparseImageFormatProperties(format Format, type_ ImageType, samples SampleCountFlagBits, usage ImageUsageFlags, tiling ImageTiling, pPropertyCount *uint32, pProperties []SparseImageFormatProperties) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* typedef */ (*C.VkFormat)(&format)
	p2 := /* typedef */ (*C.VkImageType)(&type_)
	p3 := /* typedef */ (*C.VkSampleCountFlagBits)(&samples)
	p4 := /* typedef */ (*C.VkImageUsageFlags)(&usage)
	p5 := /* typedef */ (*C.VkImageTiling)(&tiling)
	p6 := func(x **uint32) **C.uint { /* Pointer */ return (**C.uint)(unsafe.Pointer(x)) }(&pPropertyCount)
	p7 := func(x *[]SparseImageFormatProperties) **C.struct_VkSparseImageFormatProperties { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSparseImageFormatProperties)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSparseImageFormatProperties)(unsafe.Pointer((&ptr)))
	}(&pProperties)
	C.vkGetPhysicalDeviceSparseImageFormatProperties(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7)
}

func (x DeviceFacade) GetImageSparseMemoryRequirements(image Image, pSparseMemoryRequirementCount *uint32, pSparseMemoryRequirements []SparseImageMemoryRequirements) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&image)
	p2 := func(x **uint32) **C.uint { /* Pointer */ return (**C.uint)(unsafe.Pointer(x)) }(&pSparseMemoryRequirementCount)
	p3 := func(x *[]SparseImageMemoryRequirements) **C.struct_VkSparseImageMemoryRequirements { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSparseImageMemoryRequirements)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSparseImageMemoryRequirements)(unsafe.Pointer((&ptr)))
	}(&pSparseMemoryRequirements)
	C.vkGetImageSparseMemoryRequirements(addrs, *p0, *p1, *p2, *p3)
}

func (x DeviceFacade) GetImageMemoryRequirements(image Image, pMemoryRequirements *MemoryRequirements) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&image)
	p2 := func(x **MemoryRequirements) **C.struct_VkMemoryRequirements { /* Pointer */
		return (**C.struct_VkMemoryRequirements)(unsafe.Pointer(x))
	}(&pMemoryRequirements)
	C.vkGetImageMemoryRequirements(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) GetBufferMemoryRequirements(buffer Buffer, pMemoryRequirements *MemoryRequirements) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&buffer)
	p2 := func(x **MemoryRequirements) **C.struct_VkMemoryRequirements { /* Pointer */
		return (**C.struct_VkMemoryRequirements)(unsafe.Pointer(x))
	}(&pMemoryRequirements)
	C.vkGetBufferMemoryRequirements(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) BindImageMemory(image Image, memory DeviceMemory, memoryOffset DeviceSize) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&image)
	p2 := /* handle */ (*C.VkDeviceMemory)(&memory)
	p3 := /* typedef */ (*C.VkDeviceSize)(&memoryOffset)
	ret := C.vkBindImageMemory(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) BindBufferMemory(buffer Buffer, memory DeviceMemory, memoryOffset DeviceSize) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&buffer)
	p2 := /* handle */ (*C.VkDeviceMemory)(&memory)
	p3 := /* typedef */ (*C.VkDeviceSize)(&memoryOffset)
	ret := C.vkBindBufferMemory(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) AllocateCommandBuffers(pAllocateInfo *CommandBufferAllocateInfo, pCommandBuffers []CommandBuffer) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **CommandBufferAllocateInfo) **C.struct_VkCommandBufferAllocateInfo { /* Pointer */
		return (**C.struct_VkCommandBufferAllocateInfo)(unsafe.Pointer(x))
	}(&pAllocateInfo)
	p2 := func(x *[]CommandBuffer) **C.VkCommandBuffer { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkCommandBuffer)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkCommandBuffer)(unsafe.Pointer((&ptr)))
	}(&pCommandBuffers)
	ret := C.vkAllocateCommandBuffers(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) FreeCommandBuffers(commandPool CommandPool, commandBufferCount uint32, pCommandBuffers []CommandBuffer) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkCommandPool)(&commandPool)
	p2 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&commandBufferCount)
	p3 := func(x *[]CommandBuffer) **C.VkCommandBuffer { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkCommandBuffer)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkCommandBuffer)(unsafe.Pointer((&ptr)))
	}(&pCommandBuffers)
	C.vkFreeCommandBuffers(addrs, *p0, *p1, *p2, *p3)
}

func (x CommandBufferFacade) BeginCommandBuffer(pBeginInfo *CommandBufferBeginInfo) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **CommandBufferBeginInfo) **C.struct_VkCommandBufferBeginInfo { /* Pointer */
		return (**C.struct_VkCommandBufferBeginInfo)(unsafe.Pointer(x))
	}(&pBeginInfo)
	ret := C.vkBeginCommandBuffer(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x CommandBufferFacade) EndCommandBuffer() Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	ret := C.vkEndCommandBuffer(addrs, *p0)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x CommandBufferFacade) ResetCommandBuffer(flags CommandBufferResetFlags) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkCommandBufferResetFlags)(&flags)
	ret := C.vkResetCommandBuffer(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) GetDeviceMemoryCommitment(memory DeviceMemory, pCommittedMemoryInBytes *DeviceSize) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDeviceMemory)(&memory)
	p2 := func(x **DeviceSize) **C.VkDeviceSize { /* Pointer */ return (**C.VkDeviceSize)(unsafe.Pointer(x)) }(&pCommittedMemoryInBytes)
	C.vkGetDeviceMemoryCommitment(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) InvalidateMappedMemoryRanges(memoryRangeCount uint32, pMemoryRanges []MappedMemoryRange) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&memoryRangeCount)
	p2 := func(x *[]MappedMemoryRange) **C.struct_VkMappedMemoryRange { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkMappedMemoryRange)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkMappedMemoryRange)(unsafe.Pointer((&ptr)))
	}(&pMemoryRanges)
	ret := C.vkInvalidateMappedMemoryRanges(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) FlushMappedMemoryRanges(memoryRangeCount uint32, pMemoryRanges []MappedMemoryRange) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&memoryRangeCount)
	p2 := func(x *[]MappedMemoryRange) **C.struct_VkMappedMemoryRange { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkMappedMemoryRange)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkMappedMemoryRange)(unsafe.Pointer((&ptr)))
	}(&pMemoryRanges)
	ret := C.vkFlushMappedMemoryRanges(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) UnmapMemory(memory DeviceMemory) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDeviceMemory)(&memory)
	C.vkUnmapMemory(addrs, *p0, *p1)
}

func (x DeviceFacade) MapMemory(memory DeviceMemory, offset DeviceSize, size DeviceSize, flags MemoryMapFlags, ppData *unsafe.Pointer) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDeviceMemory)(&memory)
	p2 := /* typedef */ (*C.VkDeviceSize)(&offset)
	p3 := /* typedef */ (*C.VkDeviceSize)(&size)
	p4 := /* typedef */ (*C.VkMemoryMapFlags)(&flags)
	p5 := func(x **unsafe.Pointer) **unsafe.Pointer { /* Pointer */ return (**unsafe.Pointer)(unsafe.Pointer(x)) }(&ppData)
	ret := C.vkMapMemory(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) FreeMemory(memory DeviceMemory, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDeviceMemory)(&memory)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	C.vkFreeMemory(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) AllocateMemory(pAllocateInfo *MemoryAllocateInfo, pAllocator *AllocationCallbacks, pMemory *DeviceMemory) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **MemoryAllocateInfo) **C.struct_VkMemoryAllocateInfo { /* Pointer */
		return (**C.struct_VkMemoryAllocateInfo)(unsafe.Pointer(x))
	}(&pAllocateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p3 := func(x **DeviceMemory) **C.VkDeviceMemory { /* Pointer */ return (**C.VkDeviceMemory)(unsafe.Pointer(x)) }(&pMemory)
	ret := C.vkAllocateMemory(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) DeviceWaitIdle() Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	ret := C.vkDeviceWaitIdle(addrs, *p0)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x QueueFacade) QueueWaitIdle() Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkQueue)(&x.H)
	ret := C.vkQueueWaitIdle(addrs, *p0)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x QueueFacade) QueueSubmit(submitCount uint32, pSubmits []SubmitInfo, fence Fence) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkQueue)(&x.H)
	p1 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&submitCount)
	p2 := func(x *[]SubmitInfo) **C.struct_VkSubmitInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSubmitInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSubmitInfo)(unsafe.Pointer((&ptr)))
	}(&pSubmits)
	p3 := /* handle */ (*C.VkFence)(&fence)
	ret := C.vkQueueSubmit(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) GetDeviceQueue(queueFamilyIndex uint32, queueIndex uint32, pQueue *Queue) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&queueFamilyIndex)
	p2 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&queueIndex)
	p3 := func(x **Queue) **C.VkQueue { /* Pointer */ return (**C.VkQueue)(unsafe.Pointer(x)) }(&pQueue)
	C.vkGetDeviceQueue(addrs, *p0, *p1, *p2, *p3)
}

func (x CommandBufferFacade) CmdBindPipeline(pipelineBindPoint PipelineBindPoint, pipeline Pipeline) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkPipelineBindPoint)(&pipelineBindPoint)
	p2 := /* handle */ (*C.VkPipeline)(&pipeline)
	C.vkCmdBindPipeline(addrs, *p0, *p1, *p2)
}

func (x CommandBufferFacade) CmdSetViewport(firstViewport uint32, viewportCount uint32, pViewports []Viewport) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&firstViewport)
	p2 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&viewportCount)
	p3 := func(x *[]Viewport) **C.struct_VkViewport { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkViewport)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkViewport)(unsafe.Pointer((&ptr)))
	}(&pViewports)
	C.vkCmdSetViewport(addrs, *p0, *p1, *p2, *p3)
}

func (x CommandBufferFacade) CmdSetScissor(firstScissor uint32, scissorCount uint32, pScissors []Rect2D) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&firstScissor)
	p2 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&scissorCount)
	p3 := func(x *[]Rect2D) **C.struct_VkRect2D { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkRect2D)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkRect2D)(unsafe.Pointer((&ptr)))
	}(&pScissors)
	C.vkCmdSetScissor(addrs, *p0, *p1, *p2, *p3)
}

func (x CommandBufferFacade) CmdSetLineWidth(lineWidth float32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *float32) *C.float { /* Scalar */ return (*C.float)(unsafe.Pointer(x)) }(&lineWidth)
	C.vkCmdSetLineWidth(addrs, *p0, *p1)
}

func (x PhysicalDeviceFacade) EnumerateDeviceLayerProperties(pPropertyCount *uint32, pProperties []LayerProperties) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **uint32) **C.uint { /* Pointer */ return (**C.uint)(unsafe.Pointer(x)) }(&pPropertyCount)
	p2 := func(x *[]LayerProperties) **C.struct_VkLayerProperties { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkLayerProperties)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkLayerProperties)(unsafe.Pointer((&ptr)))
	}(&pProperties)
	ret := C.vkEnumerateDeviceLayerProperties(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x CommandBufferFacade) CmdSetBlendConstants(blendConstants []float32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *[]float32) **C.float { /* Array */
		if len(*x) > 0 {
			slc := (*C.float)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.float)(unsafe.Pointer((&ptr)))
	}(&blendConstants)
	C.vkCmdSetBlendConstants(addrs, *p0, *p1)
}

func (x CommandBufferFacade) CmdSetDepthBounds(minDepthBounds float32, maxDepthBounds float32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *float32) *C.float { /* Scalar */ return (*C.float)(unsafe.Pointer(x)) }(&minDepthBounds)
	p2 := func(x *float32) *C.float { /* Scalar */ return (*C.float)(unsafe.Pointer(x)) }(&maxDepthBounds)
	C.vkCmdSetDepthBounds(addrs, *p0, *p1, *p2)
}

func (x CommandBufferFacade) CmdSetStencilCompareMask(faceMask StencilFaceFlags, compareMask uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkStencilFaceFlags)(&faceMask)
	p2 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&compareMask)
	C.vkCmdSetStencilCompareMask(addrs, *p0, *p1, *p2)
}

func (x CommandBufferFacade) CmdSetStencilWriteMask(faceMask StencilFaceFlags, writeMask uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkStencilFaceFlags)(&faceMask)
	p2 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&writeMask)
	C.vkCmdSetStencilWriteMask(addrs, *p0, *p1, *p2)
}

func (x CommandBufferFacade) CmdSetStencilReference(faceMask StencilFaceFlags, reference uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkStencilFaceFlags)(&faceMask)
	p2 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&reference)
	C.vkCmdSetStencilReference(addrs, *p0, *p1, *p2)
}

func (x CommandBufferFacade) CmdBindDescriptorSets(pipelineBindPoint PipelineBindPoint, layout PipelineLayout, firstSet uint32, descriptorSetCount uint32, pDescriptorSets []DescriptorSet, dynamicOffsetCount uint32, pDynamicOffsets []uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkPipelineBindPoint)(&pipelineBindPoint)
	p2 := /* handle */ (*C.VkPipelineLayout)(&layout)
	p3 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&firstSet)
	p4 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&descriptorSetCount)
	p5 := func(x *[]DescriptorSet) **C.VkDescriptorSet { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkDescriptorSet)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkDescriptorSet)(unsafe.Pointer((&ptr)))
	}(&pDescriptorSets)
	p6 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&dynamicOffsetCount)
	p7 := func(x *[]uint32) **C.uint { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint)(unsafe.Pointer((&ptr)))
	}(&pDynamicOffsets)
	C.vkCmdBindDescriptorSets(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7)
}

func (x CommandBufferFacade) CmdBindIndexBuffer(buffer Buffer, offset DeviceSize, indexType IndexType) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&buffer)
	p2 := /* typedef */ (*C.VkDeviceSize)(&offset)
	p3 := /* typedef */ (*C.VkIndexType)(&indexType)
	C.vkCmdBindIndexBuffer(addrs, *p0, *p1, *p2, *p3)
}

func (x CommandBufferFacade) CmdBindVertexBuffers(firstBinding uint32, bindingCount uint32, pBuffers []Buffer, pOffsets []DeviceSize) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&firstBinding)
	p2 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&bindingCount)
	p3 := func(x *[]Buffer) **C.VkBuffer { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkBuffer)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkBuffer)(unsafe.Pointer((&ptr)))
	}(&pBuffers)
	p4 := func(x *[]DeviceSize) **C.VkDeviceSize { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkDeviceSize)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkDeviceSize)(unsafe.Pointer((&ptr)))
	}(&pOffsets)
	C.vkCmdBindVertexBuffers(addrs, *p0, *p1, *p2, *p3, *p4)
}

func (x CommandBufferFacade) CmdDraw(vertexCount uint32, instanceCount uint32, firstVertex uint32, firstInstance uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&vertexCount)
	p2 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&instanceCount)
	p3 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&firstVertex)
	p4 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&firstInstance)
	C.vkCmdDraw(addrs, *p0, *p1, *p2, *p3, *p4)
}

func (x CommandBufferFacade) CmdDrawIndexed(indexCount uint32, instanceCount uint32, firstIndex uint32, vertexOffset int32, firstInstance uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&indexCount)
	p2 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&instanceCount)
	p3 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&firstIndex)
	p4 := func(x *int32) *C.int { /* Scalar */ return (*C.int)(unsafe.Pointer(x)) }(&vertexOffset)
	p5 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&firstInstance)
	C.vkCmdDrawIndexed(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
}

func (x CommandBufferFacade) CmdDrawIndirect(buffer Buffer, offset DeviceSize, drawCount uint32, stride uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&buffer)
	p2 := /* typedef */ (*C.VkDeviceSize)(&offset)
	p3 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&drawCount)
	p4 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&stride)
	C.vkCmdDrawIndirect(addrs, *p0, *p1, *p2, *p3, *p4)
}

func (x CommandBufferFacade) CmdDrawIndexedIndirect(buffer Buffer, offset DeviceSize, drawCount uint32, stride uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&buffer)
	p2 := /* typedef */ (*C.VkDeviceSize)(&offset)
	p3 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&drawCount)
	p4 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&stride)
	C.vkCmdDrawIndexedIndirect(addrs, *p0, *p1, *p2, *p3, *p4)
}

func (x CommandBufferFacade) CmdDispatch(groupCountX uint32, groupCountY uint32, groupCountZ uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&groupCountX)
	p2 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&groupCountY)
	p3 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&groupCountZ)
	C.vkCmdDispatch(addrs, *p0, *p1, *p2, *p3)
}

func (x CommandBufferFacade) CmdDispatchIndirect(buffer Buffer, offset DeviceSize) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&buffer)
	p2 := /* typedef */ (*C.VkDeviceSize)(&offset)
	C.vkCmdDispatchIndirect(addrs, *p0, *p1, *p2)
}

func (x CommandBufferFacade) CmdCopyBuffer(srcBuffer Buffer, dstBuffer Buffer, regionCount uint32, pRegions []BufferCopy) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&srcBuffer)
	p2 := /* handle */ (*C.VkBuffer)(&dstBuffer)
	p3 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&regionCount)
	p4 := func(x *[]BufferCopy) **C.struct_VkBufferCopy { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkBufferCopy)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkBufferCopy)(unsafe.Pointer((&ptr)))
	}(&pRegions)
	C.vkCmdCopyBuffer(addrs, *p0, *p1, *p2, *p3, *p4)
}

func (x CommandBufferFacade) CmdCopyImage(srcImage Image, srcImageLayout ImageLayout, dstImage Image, dstImageLayout ImageLayout, regionCount uint32, pRegions []ImageCopy) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&srcImage)
	p2 := /* typedef */ (*C.VkImageLayout)(&srcImageLayout)
	p3 := /* handle */ (*C.VkImage)(&dstImage)
	p4 := /* typedef */ (*C.VkImageLayout)(&dstImageLayout)
	p5 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&regionCount)
	p6 := func(x *[]ImageCopy) **C.struct_VkImageCopy { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkImageCopy)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkImageCopy)(unsafe.Pointer((&ptr)))
	}(&pRegions)
	C.vkCmdCopyImage(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6)
}

func (x CommandBufferFacade) CmdBlitImage(srcImage Image, srcImageLayout ImageLayout, dstImage Image, dstImageLayout ImageLayout, regionCount uint32, pRegions []ImageBlit, filter Filter) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&srcImage)
	p2 := /* typedef */ (*C.VkImageLayout)(&srcImageLayout)
	p3 := /* handle */ (*C.VkImage)(&dstImage)
	p4 := /* typedef */ (*C.VkImageLayout)(&dstImageLayout)
	p5 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&regionCount)
	p6 := func(x *[]ImageBlit) **C.struct_VkImageBlit { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkImageBlit)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkImageBlit)(unsafe.Pointer((&ptr)))
	}(&pRegions)
	p7 := /* typedef */ (*C.VkFilter)(&filter)
	C.vkCmdBlitImage(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7)
}

func (x CommandBufferFacade) CmdCopyBufferToImage(srcBuffer Buffer, dstImage Image, dstImageLayout ImageLayout, regionCount uint32, pRegions []BufferImageCopy) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&srcBuffer)
	p2 := /* handle */ (*C.VkImage)(&dstImage)
	p3 := /* typedef */ (*C.VkImageLayout)(&dstImageLayout)
	p4 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&regionCount)
	p5 := func(x *[]BufferImageCopy) **C.struct_VkBufferImageCopy { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkBufferImageCopy)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkBufferImageCopy)(unsafe.Pointer((&ptr)))
	}(&pRegions)
	C.vkCmdCopyBufferToImage(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
}

func (x CommandBufferFacade) CmdCopyImageToBuffer(srcImage Image, srcImageLayout ImageLayout, dstBuffer Buffer, regionCount uint32, pRegions []BufferImageCopy) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&srcImage)
	p2 := /* typedef */ (*C.VkImageLayout)(&srcImageLayout)
	p3 := /* handle */ (*C.VkBuffer)(&dstBuffer)
	p4 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&regionCount)
	p5 := func(x *[]BufferImageCopy) **C.struct_VkBufferImageCopy { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkBufferImageCopy)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkBufferImageCopy)(unsafe.Pointer((&ptr)))
	}(&pRegions)
	C.vkCmdCopyImageToBuffer(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
}

func (x CommandBufferFacade) CmdUpdateBuffer(dstBuffer Buffer, dstOffset DeviceSize, dataSize DeviceSize, pData unsafe.Pointer) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&dstBuffer)
	p2 := /* typedef */ (*C.VkDeviceSize)(&dstOffset)
	p3 := /* typedef */ (*C.VkDeviceSize)(&dataSize)
	p4 := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&pData)
	C.vkCmdUpdateBuffer(addrs, *p0, *p1, *p2, *p3, *p4)
}

func (x CommandBufferFacade) CmdFillBuffer(dstBuffer Buffer, dstOffset DeviceSize, size DeviceSize, data uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&dstBuffer)
	p2 := /* typedef */ (*C.VkDeviceSize)(&dstOffset)
	p3 := /* typedef */ (*C.VkDeviceSize)(&size)
	p4 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&data)
	C.vkCmdFillBuffer(addrs, *p0, *p1, *p2, *p3, *p4)
}

func (x CommandBufferFacade) CmdClearColorImage(image Image, imageLayout ImageLayout, pColor *ClearColorValue, rangeCount uint32, pRanges []ImageSubresourceRange) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&image)
	p2 := /* typedef */ (*C.VkImageLayout)(&imageLayout)
	p3 := func(x **ClearColorValue) **C.VkClearColorValue { /* Pointer */
		return (**C.VkClearColorValue)(unsafe.Pointer(x))
	}(&pColor)
	p4 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&rangeCount)
	p5 := func(x *[]ImageSubresourceRange) **C.struct_VkImageSubresourceRange { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkImageSubresourceRange)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkImageSubresourceRange)(unsafe.Pointer((&ptr)))
	}(&pRanges)
	C.vkCmdClearColorImage(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
}

func (x CommandBufferFacade) CmdClearDepthStencilImage(image Image, imageLayout ImageLayout, pDepthStencil *ClearDepthStencilValue, rangeCount uint32, pRanges []ImageSubresourceRange) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&image)
	p2 := /* typedef */ (*C.VkImageLayout)(&imageLayout)
	p3 := func(x **ClearDepthStencilValue) **C.struct_VkClearDepthStencilValue { /* Pointer */
		return (**C.struct_VkClearDepthStencilValue)(unsafe.Pointer(x))
	}(&pDepthStencil)
	p4 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&rangeCount)
	p5 := func(x *[]ImageSubresourceRange) **C.struct_VkImageSubresourceRange { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkImageSubresourceRange)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkImageSubresourceRange)(unsafe.Pointer((&ptr)))
	}(&pRanges)
	C.vkCmdClearDepthStencilImage(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
}

func (x CommandBufferFacade) CmdClearAttachments(attachmentCount uint32, pAttachments []ClearAttachment, rectCount uint32, pRects []ClearRect) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&attachmentCount)
	p2 := func(x *[]ClearAttachment) **C.struct_VkClearAttachment { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkClearAttachment)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkClearAttachment)(unsafe.Pointer((&ptr)))
	}(&pAttachments)
	p3 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&rectCount)
	p4 := func(x *[]ClearRect) **C.struct_VkClearRect { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkClearRect)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkClearRect)(unsafe.Pointer((&ptr)))
	}(&pRects)
	C.vkCmdClearAttachments(addrs, *p0, *p1, *p2, *p3, *p4)
}

func (x CommandBufferFacade) CmdResolveImage(srcImage Image, srcImageLayout ImageLayout, dstImage Image, dstImageLayout ImageLayout, regionCount uint32, pRegions []ImageResolve) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&srcImage)
	p2 := /* typedef */ (*C.VkImageLayout)(&srcImageLayout)
	p3 := /* handle */ (*C.VkImage)(&dstImage)
	p4 := /* typedef */ (*C.VkImageLayout)(&dstImageLayout)
	p5 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&regionCount)
	p6 := func(x *[]ImageResolve) **C.struct_VkImageResolve { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkImageResolve)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkImageResolve)(unsafe.Pointer((&ptr)))
	}(&pRegions)
	C.vkCmdResolveImage(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6)
}

func (x CommandBufferFacade) CmdSetEvent(event Event, stageMask PipelineStageFlags) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkEvent)(&event)
	p2 := /* typedef */ (*C.VkPipelineStageFlags)(&stageMask)
	C.vkCmdSetEvent(addrs, *p0, *p1, *p2)
}

func (x CommandBufferFacade) CmdResetEvent(event Event, stageMask PipelineStageFlags) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkEvent)(&event)
	p2 := /* typedef */ (*C.VkPipelineStageFlags)(&stageMask)
	C.vkCmdResetEvent(addrs, *p0, *p1, *p2)
}

func (x CommandBufferFacade) CmdWaitEvents(eventCount uint32, pEvents []Event, srcStageMask PipelineStageFlags, dstStageMask PipelineStageFlags, memoryBarrierCount uint32, pMemoryBarriers []MemoryBarrier, bufferMemoryBarrierCount uint32, pBufferMemoryBarriers []BufferMemoryBarrier, imageMemoryBarrierCount uint32, pImageMemoryBarriers []ImageMemoryBarrier) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&eventCount)
	p2 := func(x *[]Event) **C.VkEvent { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkEvent)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkEvent)(unsafe.Pointer((&ptr)))
	}(&pEvents)
	p3 := /* typedef */ (*C.VkPipelineStageFlags)(&srcStageMask)
	p4 := /* typedef */ (*C.VkPipelineStageFlags)(&dstStageMask)
	p5 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&memoryBarrierCount)
	p6 := func(x *[]MemoryBarrier) **C.struct_VkMemoryBarrier { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkMemoryBarrier)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkMemoryBarrier)(unsafe.Pointer((&ptr)))
	}(&pMemoryBarriers)
	p7 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&bufferMemoryBarrierCount)
	p8 := func(x *[]BufferMemoryBarrier) **C.struct_VkBufferMemoryBarrier { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkBufferMemoryBarrier)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkBufferMemoryBarrier)(unsafe.Pointer((&ptr)))
	}(&pBufferMemoryBarriers)
	p9 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&imageMemoryBarrierCount)
	p10 := func(x *[]ImageMemoryBarrier) **C.struct_VkImageMemoryBarrier { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkImageMemoryBarrier)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkImageMemoryBarrier)(unsafe.Pointer((&ptr)))
	}(&pImageMemoryBarriers)
	C.vkCmdWaitEvents(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7, *p8, *p9, *p10)
}

func (x CommandBufferFacade) CmdPipelineBarrier(srcStageMask PipelineStageFlags, dstStageMask PipelineStageFlags, dependencyFlags DependencyFlags, memoryBarrierCount uint32, pMemoryBarriers []MemoryBarrier, bufferMemoryBarrierCount uint32, pBufferMemoryBarriers []BufferMemoryBarrier, imageMemoryBarrierCount uint32, pImageMemoryBarriers []ImageMemoryBarrier) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkPipelineStageFlags)(&srcStageMask)
	p2 := /* typedef */ (*C.VkPipelineStageFlags)(&dstStageMask)
	p3 := /* typedef */ (*C.VkDependencyFlags)(&dependencyFlags)
	p4 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&memoryBarrierCount)
	p5 := func(x *[]MemoryBarrier) **C.struct_VkMemoryBarrier { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkMemoryBarrier)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkMemoryBarrier)(unsafe.Pointer((&ptr)))
	}(&pMemoryBarriers)
	p6 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&bufferMemoryBarrierCount)
	p7 := func(x *[]BufferMemoryBarrier) **C.struct_VkBufferMemoryBarrier { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkBufferMemoryBarrier)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkBufferMemoryBarrier)(unsafe.Pointer((&ptr)))
	}(&pBufferMemoryBarriers)
	p8 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&imageMemoryBarrierCount)
	p9 := func(x *[]ImageMemoryBarrier) **C.struct_VkImageMemoryBarrier { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkImageMemoryBarrier)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkImageMemoryBarrier)(unsafe.Pointer((&ptr)))
	}(&pImageMemoryBarriers)
	C.vkCmdPipelineBarrier(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7, *p8, *p9)
}

func (x CommandBufferFacade) CmdBeginQuery(queryPool QueryPool, query uint32, flags QueryControlFlags) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkQueryPool)(&queryPool)
	p2 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&query)
	p3 := /* typedef */ (*C.VkQueryControlFlags)(&flags)
	C.vkCmdBeginQuery(addrs, *p0, *p1, *p2, *p3)
}

func (x CommandBufferFacade) CmdEndQuery(queryPool QueryPool, query uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkQueryPool)(&queryPool)
	p2 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&query)
	C.vkCmdEndQuery(addrs, *p0, *p1, *p2)
}

func (x CommandBufferFacade) CmdResetQueryPool(queryPool QueryPool, firstQuery uint32, queryCount uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkQueryPool)(&queryPool)
	p2 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&firstQuery)
	p3 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&queryCount)
	C.vkCmdResetQueryPool(addrs, *p0, *p1, *p2, *p3)
}

func (x CommandBufferFacade) CmdWriteTimestamp(pipelineStage PipelineStageFlagBits, queryPool QueryPool, query uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkPipelineStageFlagBits)(&pipelineStage)
	p2 := /* handle */ (*C.VkQueryPool)(&queryPool)
	p3 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&query)
	C.vkCmdWriteTimestamp(addrs, *p0, *p1, *p2, *p3)
}

func (x CommandBufferFacade) CmdCopyQueryPoolResults(queryPool QueryPool, firstQuery uint32, queryCount uint32, dstBuffer Buffer, dstOffset DeviceSize, stride DeviceSize, flags QueryResultFlags) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkQueryPool)(&queryPool)
	p2 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&firstQuery)
	p3 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&queryCount)
	p4 := /* handle */ (*C.VkBuffer)(&dstBuffer)
	p5 := /* typedef */ (*C.VkDeviceSize)(&dstOffset)
	p6 := /* typedef */ (*C.VkDeviceSize)(&stride)
	p7 := /* typedef */ (*C.VkQueryResultFlags)(&flags)
	C.vkCmdCopyQueryPoolResults(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7)
}

func (x CommandBufferFacade) CmdPushConstants(layout PipelineLayout, stageFlags ShaderStageFlags, offset uint32, size uint32, pValues unsafe.Pointer) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkPipelineLayout)(&layout)
	p2 := /* typedef */ (*C.VkShaderStageFlags)(&stageFlags)
	p3 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&offset)
	p4 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&size)
	p5 := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&pValues)
	C.vkCmdPushConstants(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
}

func (x CommandBufferFacade) CmdBeginRenderPass(pRenderPassBegin *RenderPassBeginInfo, contents SubpassContents) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **RenderPassBeginInfo) **C.struct_VkRenderPassBeginInfo { /* Pointer */
		return (**C.struct_VkRenderPassBeginInfo)(unsafe.Pointer(x))
	}(&pRenderPassBegin)
	p2 := /* typedef */ (*C.VkSubpassContents)(&contents)
	C.vkCmdBeginRenderPass(addrs, *p0, *p1, *p2)
}

func (x CommandBufferFacade) CmdNextSubpass(contents SubpassContents) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkSubpassContents)(&contents)
	C.vkCmdNextSubpass(addrs, *p0, *p1)
}

func (x CommandBufferFacade) CmdEndRenderPass() {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	C.vkCmdEndRenderPass(addrs, *p0)
}

func (x CommandBufferFacade) CmdExecuteCommands(commandBufferCount uint32, pCommandBuffers []CommandBuffer) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&commandBufferCount)
	p2 := func(x *[]CommandBuffer) **C.VkCommandBuffer { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkCommandBuffer)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkCommandBuffer)(unsafe.Pointer((&ptr)))
	}(&pCommandBuffers)
	C.vkCmdExecuteCommands(addrs, *p0, *p1, *p2)
}

func EnumerateInstanceLayerProperties(pPropertyCount *uint32, pProperties []LayerProperties) Result {
	addrs := &C.vksProcAddresses
	p0 := func(x **uint32) **C.uint { /* Pointer */ return (**C.uint)(unsafe.Pointer(x)) }(&pPropertyCount)
	p1 := func(x *[]LayerProperties) **C.struct_VkLayerProperties { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkLayerProperties)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkLayerProperties)(unsafe.Pointer((&ptr)))
	}(&pProperties)
	ret := C.vkEnumerateInstanceLayerProperties(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x PhysicalDeviceFacade) EnumerateDeviceExtensionProperties(pLayerName *byte, pPropertyCount *uint32, pProperties []ExtensionProperties) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **byte) **C.char { /* Pointer */ return (**C.char)(unsafe.Pointer(x)) }(&pLayerName)
	p2 := func(x **uint32) **C.uint { /* Pointer */ return (**C.uint)(unsafe.Pointer(x)) }(&pPropertyCount)
	p3 := func(x *[]ExtensionProperties) **C.struct_VkExtensionProperties { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkExtensionProperties)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkExtensionProperties)(unsafe.Pointer((&ptr)))
	}(&pProperties)
	ret := C.vkEnumerateDeviceExtensionProperties(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func EnumerateInstanceExtensionProperties(pLayerName *byte, pPropertyCount *uint32, pProperties []ExtensionProperties) Result {
	addrs := &C.vksProcAddresses
	p0 := func(x **byte) **C.char { /* Pointer */ return (**C.char)(unsafe.Pointer(x)) }(&pLayerName)
	p1 := func(x **uint32) **C.uint { /* Pointer */ return (**C.uint)(unsafe.Pointer(x)) }(&pPropertyCount)
	p2 := func(x *[]ExtensionProperties) **C.struct_VkExtensionProperties { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkExtensionProperties)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkExtensionProperties)(unsafe.Pointer((&ptr)))
	}(&pProperties)
	ret := C.vkEnumerateInstanceExtensionProperties(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) DestroyDevice(pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	C.vkDestroyDevice(addrs, *p0, *p1)
}

func (x PhysicalDeviceFacade) CreateDevice(pCreateInfo *DeviceCreateInfo, pAllocator *AllocationCallbacks, pDevice *Device) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **DeviceCreateInfo) **C.struct_VkDeviceCreateInfo { /* Pointer */
		return (**C.struct_VkDeviceCreateInfo)(unsafe.Pointer(x))
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p3 := func(x **Device) **C.VkDevice { /* Pointer */ return (**C.VkDevice)(unsafe.Pointer(x)) }(&pDevice)
	ret := C.vkCreateDevice(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) GetDeviceProcAddr(pName *byte) PFN_vkVoidFunction {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **byte) **C.char { /* Pointer */ return (**C.char)(unsafe.Pointer(x)) }(&pName)
	ret := C.vkGetDeviceProcAddr(addrs, *p0, *p1)
	retPtr := /* typedef */ (*PFN_vkVoidFunction)(&ret)
	return *retPtr
}

func GetInstanceProcAddr(instance Instance, pName *byte) PFN_vkVoidFunction {
	addrs := &C.vksProcAddresses
	p0 := /* handle */ (*C.VkInstance)(&instance)
	p1 := func(x **byte) **C.char { /* Pointer */ return (**C.char)(unsafe.Pointer(x)) }(&pName)
	ret := C.vkGetInstanceProcAddr(addrs, *p0, *p1)
	retPtr := /* typedef */ (*PFN_vkVoidFunction)(&ret)
	return *retPtr
}

func (x PhysicalDeviceFacade) GetPhysicalDeviceMemoryProperties(pMemoryProperties *PhysicalDeviceMemoryProperties) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceMemoryProperties) **C.struct_VkPhysicalDeviceMemoryProperties { /* Pointer */
		return (**C.struct_VkPhysicalDeviceMemoryProperties)(unsafe.Pointer(x))
	}(&pMemoryProperties)
	C.vkGetPhysicalDeviceMemoryProperties(addrs, *p0, *p1)
}

func (x PhysicalDeviceFacade) GetPhysicalDeviceQueueFamilyProperties(pQueueFamilyPropertyCount *uint32, pQueueFamilyProperties []QueueFamilyProperties) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **uint32) **C.uint { /* Pointer */ return (**C.uint)(unsafe.Pointer(x)) }(&pQueueFamilyPropertyCount)
	p2 := func(x *[]QueueFamilyProperties) **C.struct_VkQueueFamilyProperties { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkQueueFamilyProperties)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkQueueFamilyProperties)(unsafe.Pointer((&ptr)))
	}(&pQueueFamilyProperties)
	C.vkGetPhysicalDeviceQueueFamilyProperties(addrs, *p0, *p1, *p2)
}

func (x PhysicalDeviceFacade) GetPhysicalDeviceProperties(pProperties *PhysicalDeviceProperties) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceProperties) **C.struct_VkPhysicalDeviceProperties { /* Pointer */
		return (**C.struct_VkPhysicalDeviceProperties)(unsafe.Pointer(x))
	}(&pProperties)
	C.vkGetPhysicalDeviceProperties(addrs, *p0, *p1)
}

func (x PhysicalDeviceFacade) GetPhysicalDeviceFormatProperties(format Format, pFormatProperties *FormatProperties) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* typedef */ (*C.VkFormat)(&format)
	p2 := func(x **FormatProperties) **C.struct_VkFormatProperties { /* Pointer */
		return (**C.struct_VkFormatProperties)(unsafe.Pointer(x))
	}(&pFormatProperties)
	C.vkGetPhysicalDeviceFormatProperties(addrs, *p0, *p1, *p2)
}

func (x PhysicalDeviceFacade) GetPhysicalDeviceFeatures(pFeatures *PhysicalDeviceFeatures) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceFeatures) **C.struct_VkPhysicalDeviceFeatures { /* Pointer */
		return (**C.struct_VkPhysicalDeviceFeatures)(unsafe.Pointer(x))
	}(&pFeatures)
	C.vkGetPhysicalDeviceFeatures(addrs, *p0, *p1)
}

func (x InstanceFacade) EnumeratePhysicalDevices(pPhysicalDeviceCount *uint32, pPhysicalDevices []PhysicalDevice) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkInstance)(&x.H)
	p1 := func(x **uint32) **C.uint { /* Pointer */ return (**C.uint)(unsafe.Pointer(x)) }(&pPhysicalDeviceCount)
	p2 := func(x *[]PhysicalDevice) **C.VkPhysicalDevice { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkPhysicalDevice)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkPhysicalDevice)(unsafe.Pointer((&ptr)))
	}(&pPhysicalDevices)
	ret := C.vkEnumeratePhysicalDevices(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x InstanceFacade) DestroyInstance(pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkInstance)(&x.H)
	p1 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	C.vkDestroyInstance(addrs, *p0, *p1)
}

func CreateInstance(pCreateInfo *InstanceCreateInfo, pAllocator *AllocationCallbacks, pInstance *Instance) Result {
	addrs := &C.vksProcAddresses
	p0 := func(x **InstanceCreateInfo) **C.struct_VkInstanceCreateInfo { /* Pointer */
		return (**C.struct_VkInstanceCreateInfo)(unsafe.Pointer(x))
	}(&pCreateInfo)
	p1 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p2 := func(x **Instance) **C.VkInstance { /* Pointer */ return (**C.VkInstance)(unsafe.Pointer(x)) }(&pInstance)
	ret := C.vkCreateInstance(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x CommandBufferFacade) CmdSetDepthBias(depthBiasConstantFactor float32, depthBiasClamp float32, depthBiasSlopeFactor float32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *float32) *C.float { /* Scalar */ return (*C.float)(unsafe.Pointer(x)) }(&depthBiasConstantFactor)
	p2 := func(x *float32) *C.float { /* Scalar */ return (*C.float)(unsafe.Pointer(x)) }(&depthBiasClamp)
	p3 := func(x *float32) *C.float { /* Scalar */ return (*C.float)(unsafe.Pointer(x)) }(&depthBiasSlopeFactor)
	C.vkCmdSetDepthBias(addrs, *p0, *p1, *p2, *p3)
}

// DescriptorUpdateTemplate is a Handle to a vulkan resource.
// DescriptorUpdateTemplate is a child of Device.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorUpdateTemplate.html
type DescriptorUpdateTemplate C.VkDescriptorUpdateTemplate

// NullDescriptorUpdateTemplate is a typed Null value for the DescriptorUpdateTemplate type.
var NullDescriptorUpdateTemplate DescriptorUpdateTemplate

// MakeDescriptorUpdateTemplateFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DeviceFacade) MakeDescriptorUpdateTemplateFacade(x DescriptorUpdateTemplate) DescriptorUpdateTemplateFacade {
	return DescriptorUpdateTemplateFacade{
		H:     x,
		procs: parent.procs,
	}
}

// DescriptorUpdateTemplateFacade is a DescriptorUpdateTemplate handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type DescriptorUpdateTemplateFacade struct {
	H     DescriptorUpdateTemplate // The vulkan Handle
	procs *C.vksProcAddr           // The addresses for commands.
}

// SamplerYcbcrConversion is a Handle to a vulkan resource.
// SamplerYcbcrConversion is a child of Device.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSamplerYcbcrConversion.html
type SamplerYcbcrConversion C.VkSamplerYcbcrConversion

// NullSamplerYcbcrConversion is a typed Null value for the SamplerYcbcrConversion type.
var NullSamplerYcbcrConversion SamplerYcbcrConversion

// MakeSamplerYcbcrConversionFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DeviceFacade) MakeSamplerYcbcrConversionFacade(x SamplerYcbcrConversion) SamplerYcbcrConversionFacade {
	return SamplerYcbcrConversionFacade{
		H:     x,
		procs: parent.procs,
	}
}

// SamplerYcbcrConversionFacade is a SamplerYcbcrConversion handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type SamplerYcbcrConversionFacade struct {
	H     SamplerYcbcrConversion // The vulkan Handle
	procs *C.vksProcAddr         // The addresses for commands.
}

// ExternalFenceHandleTypeFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkExternalFenceHandleTypeFlagBits.html
type ExternalFenceHandleTypeFlagBits uint32

const (
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT        ExternalFenceHandleTypeFlagBits = (1 << 0)
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT     ExternalFenceHandleTypeFlagBits = (1 << 1)
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT ExternalFenceHandleTypeFlagBits = (1 << 2)
	VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT          ExternalFenceHandleTypeFlagBits = (1 << 3)
)

var (
	reverseExternalFenceHandleTypeFlagBits map[ExternalFenceHandleTypeFlagBits]string = map[ExternalFenceHandleTypeFlagBits]string{
		VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT:        "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT",
		VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT:     "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT",
		VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT",
		VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT:          "VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT",
	}
)

func (x ExternalFenceHandleTypeFlagBits) String() string {
	if s, ok := reverseExternalFenceHandleTypeFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ExternalFenceHandleTypeFlagBits=%d", x)
}

// SubgroupFeatureFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSubgroupFeatureFlagBits.html
type SubgroupFeatureFlagBits uint32

const (
	VK_SUBGROUP_FEATURE_BASIC_BIT            SubgroupFeatureFlagBits = (1 << 0)
	VK_SUBGROUP_FEATURE_VOTE_BIT             SubgroupFeatureFlagBits = (1 << 1)
	VK_SUBGROUP_FEATURE_ARITHMETIC_BIT       SubgroupFeatureFlagBits = (1 << 2)
	VK_SUBGROUP_FEATURE_BALLOT_BIT           SubgroupFeatureFlagBits = (1 << 3)
	VK_SUBGROUP_FEATURE_SHUFFLE_BIT          SubgroupFeatureFlagBits = (1 << 4)
	VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT SubgroupFeatureFlagBits = (1 << 5)
	VK_SUBGROUP_FEATURE_CLUSTERED_BIT        SubgroupFeatureFlagBits = (1 << 6)
	VK_SUBGROUP_FEATURE_QUAD_BIT             SubgroupFeatureFlagBits = (1 << 7)
)

var (
	reverseSubgroupFeatureFlagBits map[SubgroupFeatureFlagBits]string = map[SubgroupFeatureFlagBits]string{
		VK_SUBGROUP_FEATURE_BASIC_BIT:            "VK_SUBGROUP_FEATURE_BASIC_BIT",
		VK_SUBGROUP_FEATURE_VOTE_BIT:             "VK_SUBGROUP_FEATURE_VOTE_BIT",
		VK_SUBGROUP_FEATURE_ARITHMETIC_BIT:       "VK_SUBGROUP_FEATURE_ARITHMETIC_BIT",
		VK_SUBGROUP_FEATURE_BALLOT_BIT:           "VK_SUBGROUP_FEATURE_BALLOT_BIT",
		VK_SUBGROUP_FEATURE_SHUFFLE_BIT:          "VK_SUBGROUP_FEATURE_SHUFFLE_BIT",
		VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT: "VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT",
		VK_SUBGROUP_FEATURE_CLUSTERED_BIT:        "VK_SUBGROUP_FEATURE_CLUSTERED_BIT",
		VK_SUBGROUP_FEATURE_QUAD_BIT:             "VK_SUBGROUP_FEATURE_QUAD_BIT",
	}
)

func (x SubgroupFeatureFlagBits) String() string {
	if s, ok := reverseSubgroupFeatureFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("SubgroupFeatureFlagBits=%d", x)
}

// ExternalMemoryHandleTypeFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkExternalMemoryHandleTypeFlagBits.html
type ExternalMemoryHandleTypeFlagBits uint32

const (
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT         ExternalMemoryHandleTypeFlagBits = (1 << 0)
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT      ExternalMemoryHandleTypeFlagBits = (1 << 1)
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT  ExternalMemoryHandleTypeFlagBits = (1 << 2)
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT     ExternalMemoryHandleTypeFlagBits = (1 << 3)
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT ExternalMemoryHandleTypeFlagBits = (1 << 4)
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT        ExternalMemoryHandleTypeFlagBits = (1 << 5)
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT    ExternalMemoryHandleTypeFlagBits = (1 << 6)
)

var (
	reverseExternalMemoryHandleTypeFlagBits map[ExternalMemoryHandleTypeFlagBits]string = map[ExternalMemoryHandleTypeFlagBits]string{
		VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT:         "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT",
		VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:      "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT",
		VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:  "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT",
		VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT:     "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT",
		VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT: "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT",
		VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT:        "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT",
		VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT:    "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT",
	}
)

func (x ExternalMemoryHandleTypeFlagBits) String() string {
	if s, ok := reverseExternalMemoryHandleTypeFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ExternalMemoryHandleTypeFlagBits=%d", x)
}

// ExternalFenceFeatureFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkExternalFenceFeatureFlagBits.html
type ExternalFenceFeatureFlagBits uint32

const (
	VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT ExternalFenceFeatureFlagBits = (1 << 0)
	VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT ExternalFenceFeatureFlagBits = (1 << 1)
)

var (
	reverseExternalFenceFeatureFlagBits map[ExternalFenceFeatureFlagBits]string = map[ExternalFenceFeatureFlagBits]string{
		VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT: "VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT",
		VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT: "VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT",
	}
)

func (x ExternalFenceFeatureFlagBits) String() string {
	if s, ok := reverseExternalFenceFeatureFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ExternalFenceFeatureFlagBits=%d", x)
}

// DescriptorUpdateTemplateType is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorUpdateTemplateType.html
type DescriptorUpdateTemplateType uint32

const (
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET DescriptorUpdateTemplateType = 0
)

var (
	reverseDescriptorUpdateTemplateType map[DescriptorUpdateTemplateType]string = map[DescriptorUpdateTemplateType]string{
		VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET: "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET",
	}
)

func (x DescriptorUpdateTemplateType) String() string {
	if s, ok := reverseDescriptorUpdateTemplateType[x]; ok {
		return s
	}
	return fmt.Sprintf("DescriptorUpdateTemplateType=%d", x)
}

// SamplerYcbcrRange is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSamplerYcbcrRange.html
type SamplerYcbcrRange uint32

const (
	VK_SAMPLER_YCBCR_RANGE_ITU_FULL   SamplerYcbcrRange = 0
	VK_SAMPLER_YCBCR_RANGE_ITU_NARROW SamplerYcbcrRange = 1
)

var (
	reverseSamplerYcbcrRange map[SamplerYcbcrRange]string = map[SamplerYcbcrRange]string{
		VK_SAMPLER_YCBCR_RANGE_ITU_FULL:   "VK_SAMPLER_YCBCR_RANGE_ITU_FULL",
		VK_SAMPLER_YCBCR_RANGE_ITU_NARROW: "VK_SAMPLER_YCBCR_RANGE_ITU_NARROW",
	}
)

func (x SamplerYcbcrRange) String() string {
	if s, ok := reverseSamplerYcbcrRange[x]; ok {
		return s
	}
	return fmt.Sprintf("SamplerYcbcrRange=%d", x)
}

// ExternalSemaphoreHandleTypeFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkExternalSemaphoreHandleTypeFlagBits.html
type ExternalSemaphoreHandleTypeFlagBits uint32

const (
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT        ExternalSemaphoreHandleTypeFlagBits = (1 << 0)
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT     ExternalSemaphoreHandleTypeFlagBits = (1 << 1)
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT ExternalSemaphoreHandleTypeFlagBits = (1 << 2)
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT      ExternalSemaphoreHandleTypeFlagBits = (1 << 3)
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT      ExternalSemaphoreHandleTypeFlagBits = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT          ExternalSemaphoreHandleTypeFlagBits = (1 << 4)
)

var (
	reverseExternalSemaphoreHandleTypeFlagBits map[ExternalSemaphoreHandleTypeFlagBits]string = map[ExternalSemaphoreHandleTypeFlagBits]string{
		VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT:        "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT",
		VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT:     "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT",
		VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT",
		VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT:      "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT",
		VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT:          "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT",
	}
)

func (x ExternalSemaphoreHandleTypeFlagBits) String() string {
	if s, ok := reverseExternalSemaphoreHandleTypeFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ExternalSemaphoreHandleTypeFlagBits=%d", x)
}

// ChromaLocation is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkChromaLocation.html
type ChromaLocation uint32

const (
	VK_CHROMA_LOCATION_COSITED_EVEN ChromaLocation = 0
	VK_CHROMA_LOCATION_MIDPOINT     ChromaLocation = 1
)

var (
	reverseChromaLocation map[ChromaLocation]string = map[ChromaLocation]string{
		VK_CHROMA_LOCATION_COSITED_EVEN: "VK_CHROMA_LOCATION_COSITED_EVEN",
		VK_CHROMA_LOCATION_MIDPOINT:     "VK_CHROMA_LOCATION_MIDPOINT",
	}
)

func (x ChromaLocation) String() string {
	if s, ok := reverseChromaLocation[x]; ok {
		return s
	}
	return fmt.Sprintf("ChromaLocation=%d", x)
}

// SamplerYcbcrModelConversion is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSamplerYcbcrModelConversion.html
type SamplerYcbcrModelConversion uint32

const (
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY   SamplerYcbcrModelConversion = 0
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY SamplerYcbcrModelConversion = 1
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709      SamplerYcbcrModelConversion = 2
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601      SamplerYcbcrModelConversion = 3
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020     SamplerYcbcrModelConversion = 4
)

var (
	reverseSamplerYcbcrModelConversion map[SamplerYcbcrModelConversion]string = map[SamplerYcbcrModelConversion]string{
		VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY:   "VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY",
		VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY: "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY",
		VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709:      "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709",
		VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601:      "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601",
		VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020:     "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020",
	}
)

func (x SamplerYcbcrModelConversion) String() string {
	if s, ok := reverseSamplerYcbcrModelConversion[x]; ok {
		return s
	}
	return fmt.Sprintf("SamplerYcbcrModelConversion=%d", x)
}

// FenceImportFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFenceImportFlagBits.html
type FenceImportFlagBits uint32

const (
	VK_FENCE_IMPORT_TEMPORARY_BIT FenceImportFlagBits = (1 << 0)
)

var (
	reverseFenceImportFlagBits map[FenceImportFlagBits]string = map[FenceImportFlagBits]string{
		VK_FENCE_IMPORT_TEMPORARY_BIT: "VK_FENCE_IMPORT_TEMPORARY_BIT",
	}
)

func (x FenceImportFlagBits) String() string {
	if s, ok := reverseFenceImportFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("FenceImportFlagBits=%d", x)
}

// PointClippingBehavior is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPointClippingBehavior.html
type PointClippingBehavior uint32

const (
	VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES       PointClippingBehavior = 0
	VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY PointClippingBehavior = 1
)

var (
	reversePointClippingBehavior map[PointClippingBehavior]string = map[PointClippingBehavior]string{
		VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES:       "VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES",
		VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY: "VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY",
	}
)

func (x PointClippingBehavior) String() string {
	if s, ok := reversePointClippingBehavior[x]; ok {
		return s
	}
	return fmt.Sprintf("PointClippingBehavior=%d", x)
}

// ExternalSemaphoreFeatureFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkExternalSemaphoreFeatureFlagBits.html
type ExternalSemaphoreFeatureFlagBits uint32

const (
	VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT ExternalSemaphoreFeatureFlagBits = (1 << 0)
	VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT ExternalSemaphoreFeatureFlagBits = (1 << 1)
)

var (
	reverseExternalSemaphoreFeatureFlagBits map[ExternalSemaphoreFeatureFlagBits]string = map[ExternalSemaphoreFeatureFlagBits]string{
		VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT: "VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT",
		VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT: "VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT",
	}
)

func (x ExternalSemaphoreFeatureFlagBits) String() string {
	if s, ok := reverseExternalSemaphoreFeatureFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ExternalSemaphoreFeatureFlagBits=%d", x)
}

// TessellationDomainOrigin is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkTessellationDomainOrigin.html
type TessellationDomainOrigin uint32

const (
	VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT TessellationDomainOrigin = 0
	VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT TessellationDomainOrigin = 1
)

var (
	reverseTessellationDomainOrigin map[TessellationDomainOrigin]string = map[TessellationDomainOrigin]string{
		VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT: "VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT",
		VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT: "VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT",
	}
)

func (x TessellationDomainOrigin) String() string {
	if s, ok := reverseTessellationDomainOrigin[x]; ok {
		return s
	}
	return fmt.Sprintf("TessellationDomainOrigin=%d", x)
}

// ExternalMemoryFeatureFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkExternalMemoryFeatureFlagBits.html
type ExternalMemoryFeatureFlagBits uint32

const (
	VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT ExternalMemoryFeatureFlagBits = (1 << 0)
	VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT     ExternalMemoryFeatureFlagBits = (1 << 1)
	VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT     ExternalMemoryFeatureFlagBits = (1 << 2)
)

var (
	reverseExternalMemoryFeatureFlagBits map[ExternalMemoryFeatureFlagBits]string = map[ExternalMemoryFeatureFlagBits]string{
		VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT: "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT",
		VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT:     "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT",
		VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT:     "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT",
	}
)

func (x ExternalMemoryFeatureFlagBits) String() string {
	if s, ok := reverseExternalMemoryFeatureFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ExternalMemoryFeatureFlagBits=%d", x)
}

// PeerMemoryFeatureFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPeerMemoryFeatureFlagBits.html
type PeerMemoryFeatureFlagBits uint32

const (
	VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT    PeerMemoryFeatureFlagBits = (1 << 0)
	VK_PEER_MEMORY_FEATURE_COPY_DST_BIT    PeerMemoryFeatureFlagBits = (1 << 1)
	VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT PeerMemoryFeatureFlagBits = (1 << 2)
	VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT PeerMemoryFeatureFlagBits = (1 << 3)
)

var (
	reversePeerMemoryFeatureFlagBits map[PeerMemoryFeatureFlagBits]string = map[PeerMemoryFeatureFlagBits]string{
		VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT:    "VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT",
		VK_PEER_MEMORY_FEATURE_COPY_DST_BIT:    "VK_PEER_MEMORY_FEATURE_COPY_DST_BIT",
		VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT: "VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT",
		VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT: "VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT",
	}
)

func (x PeerMemoryFeatureFlagBits) String() string {
	if s, ok := reversePeerMemoryFeatureFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("PeerMemoryFeatureFlagBits=%d", x)
}

// MemoryAllocateFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkMemoryAllocateFlagBits.html
type MemoryAllocateFlagBits uint32

const (
	VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT                   MemoryAllocateFlagBits = (1 << 0)
	VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT                MemoryAllocateFlagBits = (1 << 1)
	VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT MemoryAllocateFlagBits = (1 << 2)
)

var (
	reverseMemoryAllocateFlagBits map[MemoryAllocateFlagBits]string = map[MemoryAllocateFlagBits]string{
		VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT:                   "VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT",
		VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT:                "VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT",
		VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT: "VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT",
	}
)

func (x MemoryAllocateFlagBits) String() string {
	if s, ok := reverseMemoryAllocateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("MemoryAllocateFlagBits=%d", x)
}

// SemaphoreImportFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSemaphoreImportFlagBits.html
type SemaphoreImportFlagBits uint32

const (
	VK_SEMAPHORE_IMPORT_TEMPORARY_BIT SemaphoreImportFlagBits = (1 << 0)
)

var (
	reverseSemaphoreImportFlagBits map[SemaphoreImportFlagBits]string = map[SemaphoreImportFlagBits]string{
		VK_SEMAPHORE_IMPORT_TEMPORARY_BIT: "VK_SEMAPHORE_IMPORT_TEMPORARY_BIT",
	}
)

func (x SemaphoreImportFlagBits) String() string {
	if s, ok := reverseSemaphoreImportFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("SemaphoreImportFlagBits=%d", x)
}

// MemoryAllocateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkMemoryAllocateFlags.html
type MemoryAllocateFlags Flags

// PeerMemoryFeatureFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPeerMemoryFeatureFlags.html
type PeerMemoryFeatureFlags Flags

// ExternalFenceHandleTypeFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkExternalFenceHandleTypeFlags.html
type ExternalFenceHandleTypeFlags Flags

// CommandPoolTrimFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCommandPoolTrimFlags.html
type CommandPoolTrimFlags Flags

// ExternalFenceFeatureFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkExternalFenceFeatureFlags.html
type ExternalFenceFeatureFlags Flags

// DescriptorUpdateTemplateCreateFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorUpdateTemplateCreateFlags.html
type DescriptorUpdateTemplateCreateFlags Flags

// ExternalSemaphoreFeatureFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkExternalSemaphoreFeatureFlags.html
type ExternalSemaphoreFeatureFlags Flags

// ExternalMemoryHandleTypeFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkExternalMemoryHandleTypeFlags.html
type ExternalMemoryHandleTypeFlags Flags

// FenceImportFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFenceImportFlags.html
type FenceImportFlags Flags

// SubgroupFeatureFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSubgroupFeatureFlags.html
type SubgroupFeatureFlags Flags

// ExternalSemaphoreHandleTypeFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkExternalSemaphoreHandleTypeFlags.html
type ExternalSemaphoreHandleTypeFlags Flags

// ExternalMemoryFeatureFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkExternalMemoryFeatureFlags.html
type ExternalMemoryFeatureFlags Flags

// SemaphoreImportFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSemaphoreImportFlags.html
type SemaphoreImportFlags Flags

//PhysicalDeviceMemoryProperties2 provides a go interface for VkPhysicalDeviceMemoryProperties2.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceMemoryProperties2.html
type PhysicalDeviceMemoryProperties2 C.struct_VkPhysicalDeviceMemoryProperties2

// SizeofPhysicalDeviceMemoryProperties2 is the memory size of a PhysicalDeviceMemoryProperties2
var SizeofPhysicalDeviceMemoryProperties2 int = int(unsafe.Sizeof(PhysicalDeviceMemoryProperties2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceMemoryProperties2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceMemoryProperties2) AsCPtr() *PhysicalDeviceMemoryProperties2 {
	clone := (*PhysicalDeviceMemoryProperties2)(newCBlock(C.ulong(SizeofPhysicalDeviceMemoryProperties2)))
	*clone = x
	return clone
}

// PhysicalDeviceMemoryProperties2FreeCSlice releases the memory allocated by PhysicalDeviceMemoryProperties2MakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceMemoryProperties2FreeCSlice(x []PhysicalDeviceMemoryProperties2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceMemoryProperties2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceMemoryProperties2FreeCSlice must be called on the returned slice.
func PhysicalDeviceMemoryProperties2MakeCSlice(x ...PhysicalDeviceMemoryProperties2) []PhysicalDeviceMemoryProperties2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceMemoryProperties2 * len(x)
	dst := unsafe.Slice((*PhysicalDeviceMemoryProperties2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceMemoryProperties2
func (x PhysicalDeviceMemoryProperties2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceMemoryProperties2) WithDefaultSType() PhysicalDeviceMemoryProperties2 {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMemoryProperties2) WithSType(y StructureType) PhysicalDeviceMemoryProperties2 {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceMemoryProperties2
func (x PhysicalDeviceMemoryProperties2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMemoryProperties2) WithPNext(y unsafe.Pointer) PhysicalDeviceMemoryProperties2 {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// MemoryProperties returns the value of memoryProperties from VkPhysicalDeviceMemoryProperties2
func (x PhysicalDeviceMemoryProperties2) MemoryProperties() PhysicalDeviceMemoryProperties {
	ptr := /* typedef */ (*PhysicalDeviceMemoryProperties)(&x.memoryProperties)
	return *ptr
}

//ImageMemoryRequirementsInfo2 provides a go interface for VkImageMemoryRequirementsInfo2.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageMemoryRequirementsInfo2.html
type ImageMemoryRequirementsInfo2 C.struct_VkImageMemoryRequirementsInfo2

// SizeofImageMemoryRequirementsInfo2 is the memory size of a ImageMemoryRequirementsInfo2
var SizeofImageMemoryRequirementsInfo2 int = int(unsafe.Sizeof(ImageMemoryRequirementsInfo2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageMemoryRequirementsInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageMemoryRequirementsInfo2) AsCPtr() *ImageMemoryRequirementsInfo2 {
	clone := (*ImageMemoryRequirementsInfo2)(newCBlock(C.ulong(SizeofImageMemoryRequirementsInfo2)))
	*clone = x
	return clone
}

// ImageMemoryRequirementsInfo2FreeCSlice releases the memory allocated by ImageMemoryRequirementsInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func ImageMemoryRequirementsInfo2FreeCSlice(x []ImageMemoryRequirementsInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageMemoryRequirementsInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageMemoryRequirementsInfo2FreeCSlice must be called on the returned slice.
func ImageMemoryRequirementsInfo2MakeCSlice(x ...ImageMemoryRequirementsInfo2) []ImageMemoryRequirementsInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageMemoryRequirementsInfo2 * len(x)
	dst := unsafe.Slice((*ImageMemoryRequirementsInfo2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageMemoryRequirementsInfo2
func (x ImageMemoryRequirementsInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ImageMemoryRequirementsInfo2) WithDefaultSType() ImageMemoryRequirementsInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryRequirementsInfo2) WithSType(y StructureType) ImageMemoryRequirementsInfo2 {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkImageMemoryRequirementsInfo2
func (x ImageMemoryRequirementsInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryRequirementsInfo2) WithPNext(y unsafe.Pointer) ImageMemoryRequirementsInfo2 {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Image returns the value of image from VkImageMemoryRequirementsInfo2
func (x ImageMemoryRequirementsInfo2) Image() Image {
	ptr := /* handle */ (*Image)(&x.image)
	return *ptr
}

// WithImage sets the value for the Image on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryRequirementsInfo2) WithImage(y Image) ImageMemoryRequirementsInfo2 {
	ptr := /* handle */ (*C.VkImage)(&y)
	x.image = *ptr
	return x
}

//ImageSparseMemoryRequirementsInfo2 provides a go interface for VkImageSparseMemoryRequirementsInfo2.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageSparseMemoryRequirementsInfo2.html
type ImageSparseMemoryRequirementsInfo2 C.struct_VkImageSparseMemoryRequirementsInfo2

// SizeofImageSparseMemoryRequirementsInfo2 is the memory size of a ImageSparseMemoryRequirementsInfo2
var SizeofImageSparseMemoryRequirementsInfo2 int = int(unsafe.Sizeof(ImageSparseMemoryRequirementsInfo2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageSparseMemoryRequirementsInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageSparseMemoryRequirementsInfo2) AsCPtr() *ImageSparseMemoryRequirementsInfo2 {
	clone := (*ImageSparseMemoryRequirementsInfo2)(newCBlock(C.ulong(SizeofImageSparseMemoryRequirementsInfo2)))
	*clone = x
	return clone
}

// ImageSparseMemoryRequirementsInfo2FreeCSlice releases the memory allocated by ImageSparseMemoryRequirementsInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func ImageSparseMemoryRequirementsInfo2FreeCSlice(x []ImageSparseMemoryRequirementsInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageSparseMemoryRequirementsInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageSparseMemoryRequirementsInfo2FreeCSlice must be called on the returned slice.
func ImageSparseMemoryRequirementsInfo2MakeCSlice(x ...ImageSparseMemoryRequirementsInfo2) []ImageSparseMemoryRequirementsInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageSparseMemoryRequirementsInfo2 * len(x)
	dst := unsafe.Slice((*ImageSparseMemoryRequirementsInfo2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageSparseMemoryRequirementsInfo2
func (x ImageSparseMemoryRequirementsInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ImageSparseMemoryRequirementsInfo2) WithDefaultSType() ImageSparseMemoryRequirementsInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSparseMemoryRequirementsInfo2) WithSType(y StructureType) ImageSparseMemoryRequirementsInfo2 {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkImageSparseMemoryRequirementsInfo2
func (x ImageSparseMemoryRequirementsInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSparseMemoryRequirementsInfo2) WithPNext(y unsafe.Pointer) ImageSparseMemoryRequirementsInfo2 {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Image returns the value of image from VkImageSparseMemoryRequirementsInfo2
func (x ImageSparseMemoryRequirementsInfo2) Image() Image {
	ptr := /* handle */ (*Image)(&x.image)
	return *ptr
}

// WithImage sets the value for the Image on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSparseMemoryRequirementsInfo2) WithImage(y Image) ImageSparseMemoryRequirementsInfo2 {
	ptr := /* handle */ (*C.VkImage)(&y)
	x.image = *ptr
	return x
}

//MemoryRequirements2 provides a go interface for VkMemoryRequirements2.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkMemoryRequirements2.html
type MemoryRequirements2 C.struct_VkMemoryRequirements2

// SizeofMemoryRequirements2 is the memory size of a MemoryRequirements2
var SizeofMemoryRequirements2 int = int(unsafe.Sizeof(MemoryRequirements2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryRequirements2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryRequirements2) AsCPtr() *MemoryRequirements2 {
	clone := (*MemoryRequirements2)(newCBlock(C.ulong(SizeofMemoryRequirements2)))
	*clone = x
	return clone
}

// MemoryRequirements2FreeCSlice releases the memory allocated by MemoryRequirements2MakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryRequirements2FreeCSlice(x []MemoryRequirements2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryRequirements2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryRequirements2FreeCSlice must be called on the returned slice.
func MemoryRequirements2MakeCSlice(x ...MemoryRequirements2) []MemoryRequirements2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryRequirements2 * len(x)
	dst := unsafe.Slice((*MemoryRequirements2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkMemoryRequirements2
func (x MemoryRequirements2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x MemoryRequirements2) WithDefaultSType() MemoryRequirements2 {
	return x.WithSType(VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryRequirements2) WithSType(y StructureType) MemoryRequirements2 {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkMemoryRequirements2
func (x MemoryRequirements2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryRequirements2) WithPNext(y unsafe.Pointer) MemoryRequirements2 {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// MemoryRequirements returns the value of memoryRequirements from VkMemoryRequirements2
func (x MemoryRequirements2) MemoryRequirements() MemoryRequirements {
	ptr := /* typedef */ (*MemoryRequirements)(&x.memoryRequirements)
	return *ptr
}

//SparseImageMemoryRequirements2 provides a go interface for VkSparseImageMemoryRequirements2.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSparseImageMemoryRequirements2.html
type SparseImageMemoryRequirements2 C.struct_VkSparseImageMemoryRequirements2

// SizeofSparseImageMemoryRequirements2 is the memory size of a SparseImageMemoryRequirements2
var SizeofSparseImageMemoryRequirements2 int = int(unsafe.Sizeof(SparseImageMemoryRequirements2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SparseImageMemoryRequirements2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SparseImageMemoryRequirements2) AsCPtr() *SparseImageMemoryRequirements2 {
	clone := (*SparseImageMemoryRequirements2)(newCBlock(C.ulong(SizeofSparseImageMemoryRequirements2)))
	*clone = x
	return clone
}

// SparseImageMemoryRequirements2FreeCSlice releases the memory allocated by SparseImageMemoryRequirements2MakeCSlice.
// It does not free pointers stored inside the slice.
func SparseImageMemoryRequirements2FreeCSlice(x []SparseImageMemoryRequirements2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SparseImageMemoryRequirements2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SparseImageMemoryRequirements2FreeCSlice must be called on the returned slice.
func SparseImageMemoryRequirements2MakeCSlice(x ...SparseImageMemoryRequirements2) []SparseImageMemoryRequirements2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageMemoryRequirements2 * len(x)
	dst := unsafe.Slice((*SparseImageMemoryRequirements2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSparseImageMemoryRequirements2
func (x SparseImageMemoryRequirements2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SparseImageMemoryRequirements2) WithDefaultSType() SparseImageMemoryRequirements2 {
	return x.WithSType(VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryRequirements2) WithSType(y StructureType) SparseImageMemoryRequirements2 {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkSparseImageMemoryRequirements2
func (x SparseImageMemoryRequirements2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryRequirements2) WithPNext(y unsafe.Pointer) SparseImageMemoryRequirements2 {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// MemoryRequirements returns the value of memoryRequirements from VkSparseImageMemoryRequirements2
func (x SparseImageMemoryRequirements2) MemoryRequirements() SparseImageMemoryRequirements {
	ptr := /* typedef */ (*SparseImageMemoryRequirements)(&x.memoryRequirements)
	return *ptr
}

//BufferMemoryRequirementsInfo2 provides a go interface for VkBufferMemoryRequirementsInfo2.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBufferMemoryRequirementsInfo2.html
type BufferMemoryRequirementsInfo2 C.struct_VkBufferMemoryRequirementsInfo2

// SizeofBufferMemoryRequirementsInfo2 is the memory size of a BufferMemoryRequirementsInfo2
var SizeofBufferMemoryRequirementsInfo2 int = int(unsafe.Sizeof(BufferMemoryRequirementsInfo2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferMemoryRequirementsInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferMemoryRequirementsInfo2) AsCPtr() *BufferMemoryRequirementsInfo2 {
	clone := (*BufferMemoryRequirementsInfo2)(newCBlock(C.ulong(SizeofBufferMemoryRequirementsInfo2)))
	*clone = x
	return clone
}

// BufferMemoryRequirementsInfo2FreeCSlice releases the memory allocated by BufferMemoryRequirementsInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func BufferMemoryRequirementsInfo2FreeCSlice(x []BufferMemoryRequirementsInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferMemoryRequirementsInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferMemoryRequirementsInfo2FreeCSlice must be called on the returned slice.
func BufferMemoryRequirementsInfo2MakeCSlice(x ...BufferMemoryRequirementsInfo2) []BufferMemoryRequirementsInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferMemoryRequirementsInfo2 * len(x)
	dst := unsafe.Slice((*BufferMemoryRequirementsInfo2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBufferMemoryRequirementsInfo2
func (x BufferMemoryRequirementsInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BufferMemoryRequirementsInfo2) WithDefaultSType() BufferMemoryRequirementsInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryRequirementsInfo2) WithSType(y StructureType) BufferMemoryRequirementsInfo2 {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkBufferMemoryRequirementsInfo2
func (x BufferMemoryRequirementsInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryRequirementsInfo2) WithPNext(y unsafe.Pointer) BufferMemoryRequirementsInfo2 {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Buffer returns the value of buffer from VkBufferMemoryRequirementsInfo2
func (x BufferMemoryRequirementsInfo2) Buffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.buffer)
	return *ptr
}

// WithBuffer sets the value for the Buffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryRequirementsInfo2) WithBuffer(y Buffer) BufferMemoryRequirementsInfo2 {
	ptr := /* handle */ (*C.VkBuffer)(&y)
	x.buffer = *ptr
	return x
}

//ExportFenceCreateInfo provides a go interface for VkExportFenceCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkExportFenceCreateInfo.html
type ExportFenceCreateInfo C.struct_VkExportFenceCreateInfo

// SizeofExportFenceCreateInfo is the memory size of a ExportFenceCreateInfo
var SizeofExportFenceCreateInfo int = int(unsafe.Sizeof(ExportFenceCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExportFenceCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExportFenceCreateInfo) AsCPtr() *ExportFenceCreateInfo {
	clone := (*ExportFenceCreateInfo)(newCBlock(C.ulong(SizeofExportFenceCreateInfo)))
	*clone = x
	return clone
}

// ExportFenceCreateInfoFreeCSlice releases the memory allocated by ExportFenceCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ExportFenceCreateInfoFreeCSlice(x []ExportFenceCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExportFenceCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExportFenceCreateInfoFreeCSlice must be called on the returned slice.
func ExportFenceCreateInfoMakeCSlice(x ...ExportFenceCreateInfo) []ExportFenceCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExportFenceCreateInfo * len(x)
	dst := unsafe.Slice((*ExportFenceCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkExportFenceCreateInfo
func (x ExportFenceCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ExportFenceCreateInfo) WithDefaultSType() ExportFenceCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExportFenceCreateInfo) WithSType(y StructureType) ExportFenceCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkExportFenceCreateInfo
func (x ExportFenceCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExportFenceCreateInfo) WithPNext(y unsafe.Pointer) ExportFenceCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// HandleTypes returns the value of handleTypes from VkExportFenceCreateInfo
func (x ExportFenceCreateInfo) HandleTypes() ExternalFenceHandleTypeFlags {
	ptr := /* typedef */ (*ExternalFenceHandleTypeFlags)(&x.handleTypes)
	return *ptr
}

// WithHandleTypes sets the value for the HandleTypes on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExportFenceCreateInfo) WithHandleTypes(y ExternalFenceHandleTypeFlags) ExportFenceCreateInfo {
	ptr := /* typedef */ (*C.VkExternalFenceHandleTypeFlags)(&y)
	x.handleTypes = *ptr
	return x
}

//ExportSemaphoreCreateInfo provides a go interface for VkExportSemaphoreCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkExportSemaphoreCreateInfo.html
type ExportSemaphoreCreateInfo C.struct_VkExportSemaphoreCreateInfo

// SizeofExportSemaphoreCreateInfo is the memory size of a ExportSemaphoreCreateInfo
var SizeofExportSemaphoreCreateInfo int = int(unsafe.Sizeof(ExportSemaphoreCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExportSemaphoreCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExportSemaphoreCreateInfo) AsCPtr() *ExportSemaphoreCreateInfo {
	clone := (*ExportSemaphoreCreateInfo)(newCBlock(C.ulong(SizeofExportSemaphoreCreateInfo)))
	*clone = x
	return clone
}

// ExportSemaphoreCreateInfoFreeCSlice releases the memory allocated by ExportSemaphoreCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ExportSemaphoreCreateInfoFreeCSlice(x []ExportSemaphoreCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExportSemaphoreCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExportSemaphoreCreateInfoFreeCSlice must be called on the returned slice.
func ExportSemaphoreCreateInfoMakeCSlice(x ...ExportSemaphoreCreateInfo) []ExportSemaphoreCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExportSemaphoreCreateInfo * len(x)
	dst := unsafe.Slice((*ExportSemaphoreCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkExportSemaphoreCreateInfo
func (x ExportSemaphoreCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ExportSemaphoreCreateInfo) WithDefaultSType() ExportSemaphoreCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExportSemaphoreCreateInfo) WithSType(y StructureType) ExportSemaphoreCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkExportSemaphoreCreateInfo
func (x ExportSemaphoreCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExportSemaphoreCreateInfo) WithPNext(y unsafe.Pointer) ExportSemaphoreCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// HandleTypes returns the value of handleTypes from VkExportSemaphoreCreateInfo
func (x ExportSemaphoreCreateInfo) HandleTypes() ExternalSemaphoreHandleTypeFlags {
	ptr := /* typedef */ (*ExternalSemaphoreHandleTypeFlags)(&x.handleTypes)
	return *ptr
}

// WithHandleTypes sets the value for the HandleTypes on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExportSemaphoreCreateInfo) WithHandleTypes(y ExternalSemaphoreHandleTypeFlags) ExportSemaphoreCreateInfo {
	ptr := /* typedef */ (*C.VkExternalSemaphoreHandleTypeFlags)(&y)
	x.handleTypes = *ptr
	return x
}

//DeviceGroupDeviceCreateInfo provides a go interface for VkDeviceGroupDeviceCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDeviceGroupDeviceCreateInfo.html
type DeviceGroupDeviceCreateInfo C.struct_VkDeviceGroupDeviceCreateInfo

// SizeofDeviceGroupDeviceCreateInfo is the memory size of a DeviceGroupDeviceCreateInfo
var SizeofDeviceGroupDeviceCreateInfo int = int(unsafe.Sizeof(DeviceGroupDeviceCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceGroupDeviceCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceGroupDeviceCreateInfo) AsCPtr() *DeviceGroupDeviceCreateInfo {
	clone := (*DeviceGroupDeviceCreateInfo)(newCBlock(C.ulong(SizeofDeviceGroupDeviceCreateInfo)))
	*clone = x
	return clone
}

// DeviceGroupDeviceCreateInfoFreeCSlice releases the memory allocated by DeviceGroupDeviceCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceGroupDeviceCreateInfoFreeCSlice(x []DeviceGroupDeviceCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceGroupDeviceCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceGroupDeviceCreateInfoFreeCSlice must be called on the returned slice.
func DeviceGroupDeviceCreateInfoMakeCSlice(x ...DeviceGroupDeviceCreateInfo) []DeviceGroupDeviceCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupDeviceCreateInfo * len(x)
	dst := unsafe.Slice((*DeviceGroupDeviceCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceGroupDeviceCreateInfo
func (x DeviceGroupDeviceCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DeviceGroupDeviceCreateInfo) WithDefaultSType() DeviceGroupDeviceCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupDeviceCreateInfo) WithSType(y StructureType) DeviceGroupDeviceCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDeviceGroupDeviceCreateInfo
func (x DeviceGroupDeviceCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupDeviceCreateInfo) WithPNext(y unsafe.Pointer) DeviceGroupDeviceCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// PhysicalDeviceCount returns the value of physicalDeviceCount from VkDeviceGroupDeviceCreateInfo
func (x DeviceGroupDeviceCreateInfo) PhysicalDeviceCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.physicalDeviceCount)
	return *ptr
}

// WithPhysicalDeviceCount sets the value for the PhysicalDeviceCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupDeviceCreateInfo) WithPhysicalDeviceCount(y uint32) DeviceGroupDeviceCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.physicalDeviceCount = *ptr
	return x
}

// PPhysicalDevices returns the value of pPhysicalDevices from VkDeviceGroupDeviceCreateInfo
func (x DeviceGroupDeviceCreateInfo) PPhysicalDevices() []PhysicalDevice {
	ptr := func(x **C.VkPhysicalDevice) *[]PhysicalDevice { /* Slice */
		slc := unsafe.Slice((*PhysicalDevice)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pPhysicalDevices)
	return *ptr
}

// WithPPhysicalDevices sets the value for the PPhysicalDevices on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines PhysicalDeviceCount as the length of this field.
// PhysicalDeviceCount is updated with the length of the new value.
func (x DeviceGroupDeviceCreateInfo) WithPPhysicalDevices(y []PhysicalDevice) DeviceGroupDeviceCreateInfo {
	ptr := func(x *[]PhysicalDevice) **C.VkPhysicalDevice { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkPhysicalDevice)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkPhysicalDevice)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pPhysicalDevices = *ptr
	return x.WithPhysicalDeviceCount(uint32(len(y)))
}

//ExternalFenceProperties provides a go interface for VkExternalFenceProperties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkExternalFenceProperties.html
type ExternalFenceProperties C.struct_VkExternalFenceProperties

// SizeofExternalFenceProperties is the memory size of a ExternalFenceProperties
var SizeofExternalFenceProperties int = int(unsafe.Sizeof(ExternalFenceProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExternalFenceProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExternalFenceProperties) AsCPtr() *ExternalFenceProperties {
	clone := (*ExternalFenceProperties)(newCBlock(C.ulong(SizeofExternalFenceProperties)))
	*clone = x
	return clone
}

// ExternalFencePropertiesFreeCSlice releases the memory allocated by ExternalFencePropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func ExternalFencePropertiesFreeCSlice(x []ExternalFenceProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExternalFencePropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExternalFencePropertiesFreeCSlice must be called on the returned slice.
func ExternalFencePropertiesMakeCSlice(x ...ExternalFenceProperties) []ExternalFenceProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalFenceProperties * len(x)
	dst := unsafe.Slice((*ExternalFenceProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkExternalFenceProperties
func (x ExternalFenceProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ExternalFenceProperties) WithDefaultSType() ExternalFenceProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalFenceProperties) WithSType(y StructureType) ExternalFenceProperties {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkExternalFenceProperties
func (x ExternalFenceProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalFenceProperties) WithPNext(y unsafe.Pointer) ExternalFenceProperties {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// ExportFromImportedHandleTypes returns the value of exportFromImportedHandleTypes from VkExternalFenceProperties
func (x ExternalFenceProperties) ExportFromImportedHandleTypes() ExternalFenceHandleTypeFlags {
	ptr := /* typedef */ (*ExternalFenceHandleTypeFlags)(&x.exportFromImportedHandleTypes)
	return *ptr
}

// CompatibleHandleTypes returns the value of compatibleHandleTypes from VkExternalFenceProperties
func (x ExternalFenceProperties) CompatibleHandleTypes() ExternalFenceHandleTypeFlags {
	ptr := /* typedef */ (*ExternalFenceHandleTypeFlags)(&x.compatibleHandleTypes)
	return *ptr
}

// ExternalFenceFeatures returns the value of externalFenceFeatures from VkExternalFenceProperties
func (x ExternalFenceProperties) ExternalFenceFeatures() ExternalFenceFeatureFlags {
	ptr := /* typedef */ (*ExternalFenceFeatureFlags)(&x.externalFenceFeatures)
	return *ptr
}

//PhysicalDeviceExternalFenceInfo provides a go interface for VkPhysicalDeviceExternalFenceInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceExternalFenceInfo.html
type PhysicalDeviceExternalFenceInfo C.struct_VkPhysicalDeviceExternalFenceInfo

// SizeofPhysicalDeviceExternalFenceInfo is the memory size of a PhysicalDeviceExternalFenceInfo
var SizeofPhysicalDeviceExternalFenceInfo int = int(unsafe.Sizeof(PhysicalDeviceExternalFenceInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceExternalFenceInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceExternalFenceInfo) AsCPtr() *PhysicalDeviceExternalFenceInfo {
	clone := (*PhysicalDeviceExternalFenceInfo)(newCBlock(C.ulong(SizeofPhysicalDeviceExternalFenceInfo)))
	*clone = x
	return clone
}

// PhysicalDeviceExternalFenceInfoFreeCSlice releases the memory allocated by PhysicalDeviceExternalFenceInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceExternalFenceInfoFreeCSlice(x []PhysicalDeviceExternalFenceInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceExternalFenceInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceExternalFenceInfoFreeCSlice must be called on the returned slice.
func PhysicalDeviceExternalFenceInfoMakeCSlice(x ...PhysicalDeviceExternalFenceInfo) []PhysicalDeviceExternalFenceInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceExternalFenceInfo * len(x)
	dst := unsafe.Slice((*PhysicalDeviceExternalFenceInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceExternalFenceInfo
func (x PhysicalDeviceExternalFenceInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceExternalFenceInfo) WithDefaultSType() PhysicalDeviceExternalFenceInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalFenceInfo) WithSType(y StructureType) PhysicalDeviceExternalFenceInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceExternalFenceInfo
func (x PhysicalDeviceExternalFenceInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalFenceInfo) WithPNext(y unsafe.Pointer) PhysicalDeviceExternalFenceInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// HandleType returns the value of handleType from VkPhysicalDeviceExternalFenceInfo
func (x PhysicalDeviceExternalFenceInfo) HandleType() ExternalFenceHandleTypeFlagBits {
	ptr := /* typedef */ (*ExternalFenceHandleTypeFlagBits)(&x.handleType)
	return *ptr
}

// WithHandleType sets the value for the HandleType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalFenceInfo) WithHandleType(y ExternalFenceHandleTypeFlagBits) PhysicalDeviceExternalFenceInfo {
	ptr := /* typedef */ (*C.VkExternalFenceHandleTypeFlagBits)(&y)
	x.handleType = *ptr
	return x
}

//PhysicalDeviceGroupProperties provides a go interface for VkPhysicalDeviceGroupProperties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceGroupProperties.html
type PhysicalDeviceGroupProperties C.struct_VkPhysicalDeviceGroupProperties

// SizeofPhysicalDeviceGroupProperties is the memory size of a PhysicalDeviceGroupProperties
var SizeofPhysicalDeviceGroupProperties int = int(unsafe.Sizeof(PhysicalDeviceGroupProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceGroupProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceGroupProperties) AsCPtr() *PhysicalDeviceGroupProperties {
	clone := (*PhysicalDeviceGroupProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceGroupProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceGroupPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceGroupPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceGroupPropertiesFreeCSlice(x []PhysicalDeviceGroupProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceGroupPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceGroupPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceGroupPropertiesMakeCSlice(x ...PhysicalDeviceGroupProperties) []PhysicalDeviceGroupProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceGroupProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceGroupProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceGroupProperties
func (x PhysicalDeviceGroupProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceGroupProperties) WithDefaultSType() PhysicalDeviceGroupProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceGroupProperties) WithSType(y StructureType) PhysicalDeviceGroupProperties {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceGroupProperties
func (x PhysicalDeviceGroupProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceGroupProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceGroupProperties {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// PhysicalDeviceCount returns the value of physicalDeviceCount from VkPhysicalDeviceGroupProperties
func (x PhysicalDeviceGroupProperties) PhysicalDeviceCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.physicalDeviceCount)
	return *ptr
}

// PhysicalDevices returns the value of physicalDevices from VkPhysicalDeviceGroupProperties
func (x PhysicalDeviceGroupProperties) PhysicalDevices() []PhysicalDevice {
	ptr := func(x *[VK_MAX_DEVICE_GROUP_SIZE]C.VkPhysicalDevice) *[]PhysicalDevice { /* Array */
		slc := unsafe.Slice((*PhysicalDevice)(unsafe.Pointer(x)), VK_MAX_DEVICE_GROUP_SIZE)
		return &slc
	}(&x.physicalDevices)
	return *ptr
}

// SubsetAllocation returns the value of subsetAllocation from VkPhysicalDeviceGroupProperties
func (x PhysicalDeviceGroupProperties) SubsetAllocation() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.subsetAllocation)
	return *ptr
}

//PhysicalDeviceFeatures2 provides a go interface for VkPhysicalDeviceFeatures2.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures2.html
type PhysicalDeviceFeatures2 C.struct_VkPhysicalDeviceFeatures2

// SizeofPhysicalDeviceFeatures2 is the memory size of a PhysicalDeviceFeatures2
var SizeofPhysicalDeviceFeatures2 int = int(unsafe.Sizeof(PhysicalDeviceFeatures2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceFeatures2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceFeatures2) AsCPtr() *PhysicalDeviceFeatures2 {
	clone := (*PhysicalDeviceFeatures2)(newCBlock(C.ulong(SizeofPhysicalDeviceFeatures2)))
	*clone = x
	return clone
}

// PhysicalDeviceFeatures2FreeCSlice releases the memory allocated by PhysicalDeviceFeatures2MakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceFeatures2FreeCSlice(x []PhysicalDeviceFeatures2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceFeatures2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceFeatures2FreeCSlice must be called on the returned slice.
func PhysicalDeviceFeatures2MakeCSlice(x ...PhysicalDeviceFeatures2) []PhysicalDeviceFeatures2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceFeatures2 * len(x)
	dst := unsafe.Slice((*PhysicalDeviceFeatures2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceFeatures2
func (x PhysicalDeviceFeatures2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceFeatures2) WithDefaultSType() PhysicalDeviceFeatures2 {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures2) WithSType(y StructureType) PhysicalDeviceFeatures2 {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceFeatures2
func (x PhysicalDeviceFeatures2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures2) WithPNext(y unsafe.Pointer) PhysicalDeviceFeatures2 {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Features returns the value of features from VkPhysicalDeviceFeatures2
func (x PhysicalDeviceFeatures2) Features() PhysicalDeviceFeatures {
	ptr := /* typedef */ (*PhysicalDeviceFeatures)(&x.features)
	return *ptr
}

// WithFeatures sets the value for the Features on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures2) WithFeatures(y PhysicalDeviceFeatures) PhysicalDeviceFeatures2 {
	ptr := /* typedef */ (*C.struct_VkPhysicalDeviceFeatures)(&y)
	x.features = *ptr
	return x
}

//PhysicalDeviceProperties2 provides a go interface for VkPhysicalDeviceProperties2.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceProperties2.html
type PhysicalDeviceProperties2 C.struct_VkPhysicalDeviceProperties2

// SizeofPhysicalDeviceProperties2 is the memory size of a PhysicalDeviceProperties2
var SizeofPhysicalDeviceProperties2 int = int(unsafe.Sizeof(PhysicalDeviceProperties2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceProperties2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceProperties2) AsCPtr() *PhysicalDeviceProperties2 {
	clone := (*PhysicalDeviceProperties2)(newCBlock(C.ulong(SizeofPhysicalDeviceProperties2)))
	*clone = x
	return clone
}

// PhysicalDeviceProperties2FreeCSlice releases the memory allocated by PhysicalDeviceProperties2MakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceProperties2FreeCSlice(x []PhysicalDeviceProperties2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceProperties2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceProperties2FreeCSlice must be called on the returned slice.
func PhysicalDeviceProperties2MakeCSlice(x ...PhysicalDeviceProperties2) []PhysicalDeviceProperties2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceProperties2 * len(x)
	dst := unsafe.Slice((*PhysicalDeviceProperties2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceProperties2
func (x PhysicalDeviceProperties2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceProperties2) WithDefaultSType() PhysicalDeviceProperties2 {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceProperties2) WithSType(y StructureType) PhysicalDeviceProperties2 {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceProperties2
func (x PhysicalDeviceProperties2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceProperties2) WithPNext(y unsafe.Pointer) PhysicalDeviceProperties2 {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Properties returns the value of properties from VkPhysicalDeviceProperties2
func (x PhysicalDeviceProperties2) Properties() PhysicalDeviceProperties {
	ptr := /* typedef */ (*PhysicalDeviceProperties)(&x.properties)
	return *ptr
}

//FormatProperties2 provides a go interface for VkFormatProperties2.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFormatProperties2.html
type FormatProperties2 C.struct_VkFormatProperties2

// SizeofFormatProperties2 is the memory size of a FormatProperties2
var SizeofFormatProperties2 int = int(unsafe.Sizeof(FormatProperties2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *FormatProperties2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x FormatProperties2) AsCPtr() *FormatProperties2 {
	clone := (*FormatProperties2)(newCBlock(C.ulong(SizeofFormatProperties2)))
	*clone = x
	return clone
}

// FormatProperties2FreeCSlice releases the memory allocated by FormatProperties2MakeCSlice.
// It does not free pointers stored inside the slice.
func FormatProperties2FreeCSlice(x []FormatProperties2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// FormatProperties2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. FormatProperties2FreeCSlice must be called on the returned slice.
func FormatProperties2MakeCSlice(x ...FormatProperties2) []FormatProperties2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFormatProperties2 * len(x)
	dst := unsafe.Slice((*FormatProperties2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkFormatProperties2
func (x FormatProperties2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x FormatProperties2) WithDefaultSType() FormatProperties2 {
	return x.WithSType(VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FormatProperties2) WithSType(y StructureType) FormatProperties2 {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkFormatProperties2
func (x FormatProperties2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FormatProperties2) WithPNext(y unsafe.Pointer) FormatProperties2 {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// FormatProperties returns the value of formatProperties from VkFormatProperties2
func (x FormatProperties2) FormatProperties() FormatProperties {
	ptr := /* typedef */ (*FormatProperties)(&x.formatProperties)
	return *ptr
}

//ImageFormatProperties2 provides a go interface for VkImageFormatProperties2.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageFormatProperties2.html
type ImageFormatProperties2 C.struct_VkImageFormatProperties2

// SizeofImageFormatProperties2 is the memory size of a ImageFormatProperties2
var SizeofImageFormatProperties2 int = int(unsafe.Sizeof(ImageFormatProperties2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageFormatProperties2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageFormatProperties2) AsCPtr() *ImageFormatProperties2 {
	clone := (*ImageFormatProperties2)(newCBlock(C.ulong(SizeofImageFormatProperties2)))
	*clone = x
	return clone
}

// ImageFormatProperties2FreeCSlice releases the memory allocated by ImageFormatProperties2MakeCSlice.
// It does not free pointers stored inside the slice.
func ImageFormatProperties2FreeCSlice(x []ImageFormatProperties2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageFormatProperties2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageFormatProperties2FreeCSlice must be called on the returned slice.
func ImageFormatProperties2MakeCSlice(x ...ImageFormatProperties2) []ImageFormatProperties2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageFormatProperties2 * len(x)
	dst := unsafe.Slice((*ImageFormatProperties2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageFormatProperties2
func (x ImageFormatProperties2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ImageFormatProperties2) WithDefaultSType() ImageFormatProperties2 {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageFormatProperties2) WithSType(y StructureType) ImageFormatProperties2 {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkImageFormatProperties2
func (x ImageFormatProperties2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageFormatProperties2) WithPNext(y unsafe.Pointer) ImageFormatProperties2 {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// ImageFormatProperties returns the value of imageFormatProperties from VkImageFormatProperties2
func (x ImageFormatProperties2) ImageFormatProperties() ImageFormatProperties {
	ptr := /* typedef */ (*ImageFormatProperties)(&x.imageFormatProperties)
	return *ptr
}

//PhysicalDeviceImageFormatInfo2 provides a go interface for VkPhysicalDeviceImageFormatInfo2.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceImageFormatInfo2.html
type PhysicalDeviceImageFormatInfo2 C.struct_VkPhysicalDeviceImageFormatInfo2

// SizeofPhysicalDeviceImageFormatInfo2 is the memory size of a PhysicalDeviceImageFormatInfo2
var SizeofPhysicalDeviceImageFormatInfo2 int = int(unsafe.Sizeof(PhysicalDeviceImageFormatInfo2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceImageFormatInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceImageFormatInfo2) AsCPtr() *PhysicalDeviceImageFormatInfo2 {
	clone := (*PhysicalDeviceImageFormatInfo2)(newCBlock(C.ulong(SizeofPhysicalDeviceImageFormatInfo2)))
	*clone = x
	return clone
}

// PhysicalDeviceImageFormatInfo2FreeCSlice releases the memory allocated by PhysicalDeviceImageFormatInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceImageFormatInfo2FreeCSlice(x []PhysicalDeviceImageFormatInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceImageFormatInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceImageFormatInfo2FreeCSlice must be called on the returned slice.
func PhysicalDeviceImageFormatInfo2MakeCSlice(x ...PhysicalDeviceImageFormatInfo2) []PhysicalDeviceImageFormatInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceImageFormatInfo2 * len(x)
	dst := unsafe.Slice((*PhysicalDeviceImageFormatInfo2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceImageFormatInfo2
func (x PhysicalDeviceImageFormatInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceImageFormatInfo2) WithDefaultSType() PhysicalDeviceImageFormatInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImageFormatInfo2) WithSType(y StructureType) PhysicalDeviceImageFormatInfo2 {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceImageFormatInfo2
func (x PhysicalDeviceImageFormatInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImageFormatInfo2) WithPNext(y unsafe.Pointer) PhysicalDeviceImageFormatInfo2 {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Format returns the value of format from VkPhysicalDeviceImageFormatInfo2
func (x PhysicalDeviceImageFormatInfo2) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format)
	return *ptr
}

// WithFormat sets the value for the Format on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImageFormatInfo2) WithFormat(y Format) PhysicalDeviceImageFormatInfo2 {
	ptr := /* typedef */ (*C.VkFormat)(&y)
	x.format = *ptr
	return x
}

// Type_ returns the value of type from VkPhysicalDeviceImageFormatInfo2
func (x PhysicalDeviceImageFormatInfo2) Type_() ImageType {
	ptr := /* typedef */ (*ImageType)(&x._type)
	return *ptr
}

// WithType_ sets the value for the Type_ on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImageFormatInfo2) WithType_(y ImageType) PhysicalDeviceImageFormatInfo2 {
	ptr := /* typedef */ (*C.VkImageType)(&y)
	x._type = *ptr
	return x
}

// Tiling returns the value of tiling from VkPhysicalDeviceImageFormatInfo2
func (x PhysicalDeviceImageFormatInfo2) Tiling() ImageTiling {
	ptr := /* typedef */ (*ImageTiling)(&x.tiling)
	return *ptr
}

// WithTiling sets the value for the Tiling on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImageFormatInfo2) WithTiling(y ImageTiling) PhysicalDeviceImageFormatInfo2 {
	ptr := /* typedef */ (*C.VkImageTiling)(&y)
	x.tiling = *ptr
	return x
}

// Usage returns the value of usage from VkPhysicalDeviceImageFormatInfo2
func (x PhysicalDeviceImageFormatInfo2) Usage() ImageUsageFlags {
	ptr := /* typedef */ (*ImageUsageFlags)(&x.usage)
	return *ptr
}

// WithUsage sets the value for the Usage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImageFormatInfo2) WithUsage(y ImageUsageFlags) PhysicalDeviceImageFormatInfo2 {
	ptr := /* typedef */ (*C.VkImageUsageFlags)(&y)
	x.usage = *ptr
	return x
}

// Flags returns the value of flags from VkPhysicalDeviceImageFormatInfo2
func (x PhysicalDeviceImageFormatInfo2) Flags() ImageCreateFlags {
	ptr := /* typedef */ (*ImageCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImageFormatInfo2) WithFlags(y ImageCreateFlags) PhysicalDeviceImageFormatInfo2 {
	ptr := /* typedef */ (*C.VkImageCreateFlags)(&y)
	x.flags = *ptr
	return x
}

//QueueFamilyProperties2 provides a go interface for VkQueueFamilyProperties2.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkQueueFamilyProperties2.html
type QueueFamilyProperties2 C.struct_VkQueueFamilyProperties2

// SizeofQueueFamilyProperties2 is the memory size of a QueueFamilyProperties2
var SizeofQueueFamilyProperties2 int = int(unsafe.Sizeof(QueueFamilyProperties2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *QueueFamilyProperties2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x QueueFamilyProperties2) AsCPtr() *QueueFamilyProperties2 {
	clone := (*QueueFamilyProperties2)(newCBlock(C.ulong(SizeofQueueFamilyProperties2)))
	*clone = x
	return clone
}

// QueueFamilyProperties2FreeCSlice releases the memory allocated by QueueFamilyProperties2MakeCSlice.
// It does not free pointers stored inside the slice.
func QueueFamilyProperties2FreeCSlice(x []QueueFamilyProperties2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// QueueFamilyProperties2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. QueueFamilyProperties2FreeCSlice must be called on the returned slice.
func QueueFamilyProperties2MakeCSlice(x ...QueueFamilyProperties2) []QueueFamilyProperties2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofQueueFamilyProperties2 * len(x)
	dst := unsafe.Slice((*QueueFamilyProperties2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkQueueFamilyProperties2
func (x QueueFamilyProperties2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x QueueFamilyProperties2) WithDefaultSType() QueueFamilyProperties2 {
	return x.WithSType(VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x QueueFamilyProperties2) WithSType(y StructureType) QueueFamilyProperties2 {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkQueueFamilyProperties2
func (x QueueFamilyProperties2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x QueueFamilyProperties2) WithPNext(y unsafe.Pointer) QueueFamilyProperties2 {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// QueueFamilyProperties returns the value of queueFamilyProperties from VkQueueFamilyProperties2
func (x QueueFamilyProperties2) QueueFamilyProperties() QueueFamilyProperties {
	ptr := /* typedef */ (*QueueFamilyProperties)(&x.queueFamilyProperties)
	return *ptr
}

//BindImageMemoryDeviceGroupInfo provides a go interface for VkBindImageMemoryDeviceGroupInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBindImageMemoryDeviceGroupInfo.html
type BindImageMemoryDeviceGroupInfo C.struct_VkBindImageMemoryDeviceGroupInfo

// SizeofBindImageMemoryDeviceGroupInfo is the memory size of a BindImageMemoryDeviceGroupInfo
var SizeofBindImageMemoryDeviceGroupInfo int = int(unsafe.Sizeof(BindImageMemoryDeviceGroupInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BindImageMemoryDeviceGroupInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BindImageMemoryDeviceGroupInfo) AsCPtr() *BindImageMemoryDeviceGroupInfo {
	clone := (*BindImageMemoryDeviceGroupInfo)(newCBlock(C.ulong(SizeofBindImageMemoryDeviceGroupInfo)))
	*clone = x
	return clone
}

// BindImageMemoryDeviceGroupInfoFreeCSlice releases the memory allocated by BindImageMemoryDeviceGroupInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BindImageMemoryDeviceGroupInfoFreeCSlice(x []BindImageMemoryDeviceGroupInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BindImageMemoryDeviceGroupInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BindImageMemoryDeviceGroupInfoFreeCSlice must be called on the returned slice.
func BindImageMemoryDeviceGroupInfoMakeCSlice(x ...BindImageMemoryDeviceGroupInfo) []BindImageMemoryDeviceGroupInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindImageMemoryDeviceGroupInfo * len(x)
	dst := unsafe.Slice((*BindImageMemoryDeviceGroupInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBindImageMemoryDeviceGroupInfo
func (x BindImageMemoryDeviceGroupInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BindImageMemoryDeviceGroupInfo) WithDefaultSType() BindImageMemoryDeviceGroupInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemoryDeviceGroupInfo) WithSType(y StructureType) BindImageMemoryDeviceGroupInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkBindImageMemoryDeviceGroupInfo
func (x BindImageMemoryDeviceGroupInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemoryDeviceGroupInfo) WithPNext(y unsafe.Pointer) BindImageMemoryDeviceGroupInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// DeviceIndexCount returns the value of deviceIndexCount from VkBindImageMemoryDeviceGroupInfo
func (x BindImageMemoryDeviceGroupInfo) DeviceIndexCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.deviceIndexCount)
	return *ptr
}

// WithDeviceIndexCount sets the value for the DeviceIndexCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemoryDeviceGroupInfo) WithDeviceIndexCount(y uint32) BindImageMemoryDeviceGroupInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.deviceIndexCount = *ptr
	return x
}

// PDeviceIndices returns the value of pDeviceIndices from VkBindImageMemoryDeviceGroupInfo
func (x BindImageMemoryDeviceGroupInfo) PDeviceIndices() []uint32 {
	ptr := func(x **C.uint) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pDeviceIndices)
	return *ptr
}

// WithPDeviceIndices sets the value for the PDeviceIndices on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DeviceIndexCount as the length of this field.
// DeviceIndexCount is updated with the length of the new value.
func (x BindImageMemoryDeviceGroupInfo) WithPDeviceIndices(y []uint32) BindImageMemoryDeviceGroupInfo {
	ptr := func(x *[]uint32) **C.uint { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pDeviceIndices = *ptr
	return x.WithDeviceIndexCount(uint32(len(y)))
}

// SplitInstanceBindRegionCount returns the value of splitInstanceBindRegionCount from VkBindImageMemoryDeviceGroupInfo
func (x BindImageMemoryDeviceGroupInfo) SplitInstanceBindRegionCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.splitInstanceBindRegionCount)
	return *ptr
}

// WithSplitInstanceBindRegionCount sets the value for the SplitInstanceBindRegionCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemoryDeviceGroupInfo) WithSplitInstanceBindRegionCount(y uint32) BindImageMemoryDeviceGroupInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.splitInstanceBindRegionCount = *ptr
	return x
}

// PSplitInstanceBindRegions returns the value of pSplitInstanceBindRegions from VkBindImageMemoryDeviceGroupInfo
func (x BindImageMemoryDeviceGroupInfo) PSplitInstanceBindRegions() []Rect2D {
	ptr := func(x **C.struct_VkRect2D) *[]Rect2D { /* Slice */
		slc := unsafe.Slice((*Rect2D)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pSplitInstanceBindRegions)
	return *ptr
}

// WithPSplitInstanceBindRegions sets the value for the PSplitInstanceBindRegions on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SplitInstanceBindRegionCount as the length of this field.
// SplitInstanceBindRegionCount is updated with the length of the new value.
func (x BindImageMemoryDeviceGroupInfo) WithPSplitInstanceBindRegions(y []Rect2D) BindImageMemoryDeviceGroupInfo {
	ptr := func(x *[]Rect2D) **C.struct_VkRect2D { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkRect2D)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkRect2D)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pSplitInstanceBindRegions = *ptr
	return x.WithSplitInstanceBindRegionCount(uint32(len(y)))
}

//SparseImageFormatProperties2 provides a go interface for VkSparseImageFormatProperties2.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSparseImageFormatProperties2.html
type SparseImageFormatProperties2 C.struct_VkSparseImageFormatProperties2

// SizeofSparseImageFormatProperties2 is the memory size of a SparseImageFormatProperties2
var SizeofSparseImageFormatProperties2 int = int(unsafe.Sizeof(SparseImageFormatProperties2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SparseImageFormatProperties2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SparseImageFormatProperties2) AsCPtr() *SparseImageFormatProperties2 {
	clone := (*SparseImageFormatProperties2)(newCBlock(C.ulong(SizeofSparseImageFormatProperties2)))
	*clone = x
	return clone
}

// SparseImageFormatProperties2FreeCSlice releases the memory allocated by SparseImageFormatProperties2MakeCSlice.
// It does not free pointers stored inside the slice.
func SparseImageFormatProperties2FreeCSlice(x []SparseImageFormatProperties2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SparseImageFormatProperties2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SparseImageFormatProperties2FreeCSlice must be called on the returned slice.
func SparseImageFormatProperties2MakeCSlice(x ...SparseImageFormatProperties2) []SparseImageFormatProperties2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageFormatProperties2 * len(x)
	dst := unsafe.Slice((*SparseImageFormatProperties2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSparseImageFormatProperties2
func (x SparseImageFormatProperties2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SparseImageFormatProperties2) WithDefaultSType() SparseImageFormatProperties2 {
	return x.WithSType(VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageFormatProperties2) WithSType(y StructureType) SparseImageFormatProperties2 {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkSparseImageFormatProperties2
func (x SparseImageFormatProperties2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageFormatProperties2) WithPNext(y unsafe.Pointer) SparseImageFormatProperties2 {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Properties returns the value of properties from VkSparseImageFormatProperties2
func (x SparseImageFormatProperties2) Properties() SparseImageFormatProperties {
	ptr := /* typedef */ (*SparseImageFormatProperties)(&x.properties)
	return *ptr
}

//PhysicalDeviceSparseImageFormatInfo2 provides a go interface for VkPhysicalDeviceSparseImageFormatInfo2.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceSparseImageFormatInfo2.html
type PhysicalDeviceSparseImageFormatInfo2 C.struct_VkPhysicalDeviceSparseImageFormatInfo2

// SizeofPhysicalDeviceSparseImageFormatInfo2 is the memory size of a PhysicalDeviceSparseImageFormatInfo2
var SizeofPhysicalDeviceSparseImageFormatInfo2 int = int(unsafe.Sizeof(PhysicalDeviceSparseImageFormatInfo2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceSparseImageFormatInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceSparseImageFormatInfo2) AsCPtr() *PhysicalDeviceSparseImageFormatInfo2 {
	clone := (*PhysicalDeviceSparseImageFormatInfo2)(newCBlock(C.ulong(SizeofPhysicalDeviceSparseImageFormatInfo2)))
	*clone = x
	return clone
}

// PhysicalDeviceSparseImageFormatInfo2FreeCSlice releases the memory allocated by PhysicalDeviceSparseImageFormatInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceSparseImageFormatInfo2FreeCSlice(x []PhysicalDeviceSparseImageFormatInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceSparseImageFormatInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceSparseImageFormatInfo2FreeCSlice must be called on the returned slice.
func PhysicalDeviceSparseImageFormatInfo2MakeCSlice(x ...PhysicalDeviceSparseImageFormatInfo2) []PhysicalDeviceSparseImageFormatInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSparseImageFormatInfo2 * len(x)
	dst := unsafe.Slice((*PhysicalDeviceSparseImageFormatInfo2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceSparseImageFormatInfo2
func (x PhysicalDeviceSparseImageFormatInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceSparseImageFormatInfo2) WithDefaultSType() PhysicalDeviceSparseImageFormatInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSparseImageFormatInfo2) WithSType(y StructureType) PhysicalDeviceSparseImageFormatInfo2 {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceSparseImageFormatInfo2
func (x PhysicalDeviceSparseImageFormatInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSparseImageFormatInfo2) WithPNext(y unsafe.Pointer) PhysicalDeviceSparseImageFormatInfo2 {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Format returns the value of format from VkPhysicalDeviceSparseImageFormatInfo2
func (x PhysicalDeviceSparseImageFormatInfo2) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format)
	return *ptr
}

// WithFormat sets the value for the Format on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSparseImageFormatInfo2) WithFormat(y Format) PhysicalDeviceSparseImageFormatInfo2 {
	ptr := /* typedef */ (*C.VkFormat)(&y)
	x.format = *ptr
	return x
}

// Type_ returns the value of type from VkPhysicalDeviceSparseImageFormatInfo2
func (x PhysicalDeviceSparseImageFormatInfo2) Type_() ImageType {
	ptr := /* typedef */ (*ImageType)(&x._type)
	return *ptr
}

// WithType_ sets the value for the Type_ on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSparseImageFormatInfo2) WithType_(y ImageType) PhysicalDeviceSparseImageFormatInfo2 {
	ptr := /* typedef */ (*C.VkImageType)(&y)
	x._type = *ptr
	return x
}

// Samples returns the value of samples from VkPhysicalDeviceSparseImageFormatInfo2
func (x PhysicalDeviceSparseImageFormatInfo2) Samples() SampleCountFlagBits {
	ptr := /* typedef */ (*SampleCountFlagBits)(&x.samples)
	return *ptr
}

// WithSamples sets the value for the Samples on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSparseImageFormatInfo2) WithSamples(y SampleCountFlagBits) PhysicalDeviceSparseImageFormatInfo2 {
	ptr := /* typedef */ (*C.VkSampleCountFlagBits)(&y)
	x.samples = *ptr
	return x
}

// Usage returns the value of usage from VkPhysicalDeviceSparseImageFormatInfo2
func (x PhysicalDeviceSparseImageFormatInfo2) Usage() ImageUsageFlags {
	ptr := /* typedef */ (*ImageUsageFlags)(&x.usage)
	return *ptr
}

// WithUsage sets the value for the Usage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSparseImageFormatInfo2) WithUsage(y ImageUsageFlags) PhysicalDeviceSparseImageFormatInfo2 {
	ptr := /* typedef */ (*C.VkImageUsageFlags)(&y)
	x.usage = *ptr
	return x
}

// Tiling returns the value of tiling from VkPhysicalDeviceSparseImageFormatInfo2
func (x PhysicalDeviceSparseImageFormatInfo2) Tiling() ImageTiling {
	ptr := /* typedef */ (*ImageTiling)(&x.tiling)
	return *ptr
}

// WithTiling sets the value for the Tiling on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSparseImageFormatInfo2) WithTiling(y ImageTiling) PhysicalDeviceSparseImageFormatInfo2 {
	ptr := /* typedef */ (*C.VkImageTiling)(&y)
	x.tiling = *ptr
	return x
}

//BindBufferMemoryDeviceGroupInfo provides a go interface for VkBindBufferMemoryDeviceGroupInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBindBufferMemoryDeviceGroupInfo.html
type BindBufferMemoryDeviceGroupInfo C.struct_VkBindBufferMemoryDeviceGroupInfo

// SizeofBindBufferMemoryDeviceGroupInfo is the memory size of a BindBufferMemoryDeviceGroupInfo
var SizeofBindBufferMemoryDeviceGroupInfo int = int(unsafe.Sizeof(BindBufferMemoryDeviceGroupInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BindBufferMemoryDeviceGroupInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BindBufferMemoryDeviceGroupInfo) AsCPtr() *BindBufferMemoryDeviceGroupInfo {
	clone := (*BindBufferMemoryDeviceGroupInfo)(newCBlock(C.ulong(SizeofBindBufferMemoryDeviceGroupInfo)))
	*clone = x
	return clone
}

// BindBufferMemoryDeviceGroupInfoFreeCSlice releases the memory allocated by BindBufferMemoryDeviceGroupInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BindBufferMemoryDeviceGroupInfoFreeCSlice(x []BindBufferMemoryDeviceGroupInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BindBufferMemoryDeviceGroupInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BindBufferMemoryDeviceGroupInfoFreeCSlice must be called on the returned slice.
func BindBufferMemoryDeviceGroupInfoMakeCSlice(x ...BindBufferMemoryDeviceGroupInfo) []BindBufferMemoryDeviceGroupInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindBufferMemoryDeviceGroupInfo * len(x)
	dst := unsafe.Slice((*BindBufferMemoryDeviceGroupInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBindBufferMemoryDeviceGroupInfo
func (x BindBufferMemoryDeviceGroupInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BindBufferMemoryDeviceGroupInfo) WithDefaultSType() BindBufferMemoryDeviceGroupInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindBufferMemoryDeviceGroupInfo) WithSType(y StructureType) BindBufferMemoryDeviceGroupInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkBindBufferMemoryDeviceGroupInfo
func (x BindBufferMemoryDeviceGroupInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindBufferMemoryDeviceGroupInfo) WithPNext(y unsafe.Pointer) BindBufferMemoryDeviceGroupInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// DeviceIndexCount returns the value of deviceIndexCount from VkBindBufferMemoryDeviceGroupInfo
func (x BindBufferMemoryDeviceGroupInfo) DeviceIndexCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.deviceIndexCount)
	return *ptr
}

// WithDeviceIndexCount sets the value for the DeviceIndexCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindBufferMemoryDeviceGroupInfo) WithDeviceIndexCount(y uint32) BindBufferMemoryDeviceGroupInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.deviceIndexCount = *ptr
	return x
}

// PDeviceIndices returns the value of pDeviceIndices from VkBindBufferMemoryDeviceGroupInfo
func (x BindBufferMemoryDeviceGroupInfo) PDeviceIndices() []uint32 {
	ptr := func(x **C.uint) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pDeviceIndices)
	return *ptr
}

// WithPDeviceIndices sets the value for the PDeviceIndices on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DeviceIndexCount as the length of this field.
// DeviceIndexCount is updated with the length of the new value.
func (x BindBufferMemoryDeviceGroupInfo) WithPDeviceIndices(y []uint32) BindBufferMemoryDeviceGroupInfo {
	ptr := func(x *[]uint32) **C.uint { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pDeviceIndices = *ptr
	return x.WithDeviceIndexCount(uint32(len(y)))
}

//DeviceGroupBindSparseInfo provides a go interface for VkDeviceGroupBindSparseInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDeviceGroupBindSparseInfo.html
type DeviceGroupBindSparseInfo C.struct_VkDeviceGroupBindSparseInfo

// SizeofDeviceGroupBindSparseInfo is the memory size of a DeviceGroupBindSparseInfo
var SizeofDeviceGroupBindSparseInfo int = int(unsafe.Sizeof(DeviceGroupBindSparseInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceGroupBindSparseInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceGroupBindSparseInfo) AsCPtr() *DeviceGroupBindSparseInfo {
	clone := (*DeviceGroupBindSparseInfo)(newCBlock(C.ulong(SizeofDeviceGroupBindSparseInfo)))
	*clone = x
	return clone
}

// DeviceGroupBindSparseInfoFreeCSlice releases the memory allocated by DeviceGroupBindSparseInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceGroupBindSparseInfoFreeCSlice(x []DeviceGroupBindSparseInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceGroupBindSparseInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceGroupBindSparseInfoFreeCSlice must be called on the returned slice.
func DeviceGroupBindSparseInfoMakeCSlice(x ...DeviceGroupBindSparseInfo) []DeviceGroupBindSparseInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupBindSparseInfo * len(x)
	dst := unsafe.Slice((*DeviceGroupBindSparseInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceGroupBindSparseInfo
func (x DeviceGroupBindSparseInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DeviceGroupBindSparseInfo) WithDefaultSType() DeviceGroupBindSparseInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupBindSparseInfo) WithSType(y StructureType) DeviceGroupBindSparseInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDeviceGroupBindSparseInfo
func (x DeviceGroupBindSparseInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupBindSparseInfo) WithPNext(y unsafe.Pointer) DeviceGroupBindSparseInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// ResourceDeviceIndex returns the value of resourceDeviceIndex from VkDeviceGroupBindSparseInfo
func (x DeviceGroupBindSparseInfo) ResourceDeviceIndex() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.resourceDeviceIndex)
	return *ptr
}

// WithResourceDeviceIndex sets the value for the ResourceDeviceIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupBindSparseInfo) WithResourceDeviceIndex(y uint32) DeviceGroupBindSparseInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.resourceDeviceIndex = *ptr
	return x
}

// MemoryDeviceIndex returns the value of memoryDeviceIndex from VkDeviceGroupBindSparseInfo
func (x DeviceGroupBindSparseInfo) MemoryDeviceIndex() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.memoryDeviceIndex)
	return *ptr
}

// WithMemoryDeviceIndex sets the value for the MemoryDeviceIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupBindSparseInfo) WithMemoryDeviceIndex(y uint32) DeviceGroupBindSparseInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.memoryDeviceIndex = *ptr
	return x
}

//PhysicalDevicePointClippingProperties provides a go interface for VkPhysicalDevicePointClippingProperties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePointClippingProperties.html
type PhysicalDevicePointClippingProperties C.struct_VkPhysicalDevicePointClippingProperties

// SizeofPhysicalDevicePointClippingProperties is the memory size of a PhysicalDevicePointClippingProperties
var SizeofPhysicalDevicePointClippingProperties int = int(unsafe.Sizeof(PhysicalDevicePointClippingProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDevicePointClippingProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDevicePointClippingProperties) AsCPtr() *PhysicalDevicePointClippingProperties {
	clone := (*PhysicalDevicePointClippingProperties)(newCBlock(C.ulong(SizeofPhysicalDevicePointClippingProperties)))
	*clone = x
	return clone
}

// PhysicalDevicePointClippingPropertiesFreeCSlice releases the memory allocated by PhysicalDevicePointClippingPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDevicePointClippingPropertiesFreeCSlice(x []PhysicalDevicePointClippingProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDevicePointClippingPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDevicePointClippingPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDevicePointClippingPropertiesMakeCSlice(x ...PhysicalDevicePointClippingProperties) []PhysicalDevicePointClippingProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDevicePointClippingProperties * len(x)
	dst := unsafe.Slice((*PhysicalDevicePointClippingProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDevicePointClippingProperties
func (x PhysicalDevicePointClippingProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDevicePointClippingProperties) WithDefaultSType() PhysicalDevicePointClippingProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePointClippingProperties) WithSType(y StructureType) PhysicalDevicePointClippingProperties {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDevicePointClippingProperties
func (x PhysicalDevicePointClippingProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePointClippingProperties) WithPNext(y unsafe.Pointer) PhysicalDevicePointClippingProperties {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// PointClippingBehavior returns the value of pointClippingBehavior from VkPhysicalDevicePointClippingProperties
func (x PhysicalDevicePointClippingProperties) PointClippingBehavior() PointClippingBehavior {
	ptr := /* typedef */ (*PointClippingBehavior)(&x.pointClippingBehavior)
	return *ptr
}

//DeviceGroupSubmitInfo provides a go interface for VkDeviceGroupSubmitInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDeviceGroupSubmitInfo.html
type DeviceGroupSubmitInfo C.struct_VkDeviceGroupSubmitInfo

// SizeofDeviceGroupSubmitInfo is the memory size of a DeviceGroupSubmitInfo
var SizeofDeviceGroupSubmitInfo int = int(unsafe.Sizeof(DeviceGroupSubmitInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceGroupSubmitInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceGroupSubmitInfo) AsCPtr() *DeviceGroupSubmitInfo {
	clone := (*DeviceGroupSubmitInfo)(newCBlock(C.ulong(SizeofDeviceGroupSubmitInfo)))
	*clone = x
	return clone
}

// DeviceGroupSubmitInfoFreeCSlice releases the memory allocated by DeviceGroupSubmitInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceGroupSubmitInfoFreeCSlice(x []DeviceGroupSubmitInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceGroupSubmitInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceGroupSubmitInfoFreeCSlice must be called on the returned slice.
func DeviceGroupSubmitInfoMakeCSlice(x ...DeviceGroupSubmitInfo) []DeviceGroupSubmitInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupSubmitInfo * len(x)
	dst := unsafe.Slice((*DeviceGroupSubmitInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceGroupSubmitInfo
func (x DeviceGroupSubmitInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DeviceGroupSubmitInfo) WithDefaultSType() DeviceGroupSubmitInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupSubmitInfo) WithSType(y StructureType) DeviceGroupSubmitInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDeviceGroupSubmitInfo
func (x DeviceGroupSubmitInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupSubmitInfo) WithPNext(y unsafe.Pointer) DeviceGroupSubmitInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// WaitSemaphoreCount returns the value of waitSemaphoreCount from VkDeviceGroupSubmitInfo
func (x DeviceGroupSubmitInfo) WaitSemaphoreCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.waitSemaphoreCount)
	return *ptr
}

// WithWaitSemaphoreCount sets the value for the WaitSemaphoreCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupSubmitInfo) WithWaitSemaphoreCount(y uint32) DeviceGroupSubmitInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.waitSemaphoreCount = *ptr
	return x
}

// PWaitSemaphoreDeviceIndices returns the value of pWaitSemaphoreDeviceIndices from VkDeviceGroupSubmitInfo
func (x DeviceGroupSubmitInfo) PWaitSemaphoreDeviceIndices() []uint32 {
	ptr := func(x **C.uint) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pWaitSemaphoreDeviceIndices)
	return *ptr
}

// WithPWaitSemaphoreDeviceIndices sets the value for the PWaitSemaphoreDeviceIndices on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines WaitSemaphoreCount as the length of this field.
// WaitSemaphoreCount is updated with the length of the new value.
func (x DeviceGroupSubmitInfo) WithPWaitSemaphoreDeviceIndices(y []uint32) DeviceGroupSubmitInfo {
	ptr := func(x *[]uint32) **C.uint { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pWaitSemaphoreDeviceIndices = *ptr
	return x.WithWaitSemaphoreCount(uint32(len(y)))
}

// CommandBufferCount returns the value of commandBufferCount from VkDeviceGroupSubmitInfo
func (x DeviceGroupSubmitInfo) CommandBufferCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.commandBufferCount)
	return *ptr
}

// WithCommandBufferCount sets the value for the CommandBufferCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupSubmitInfo) WithCommandBufferCount(y uint32) DeviceGroupSubmitInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.commandBufferCount = *ptr
	return x
}

// PCommandBufferDeviceMasks returns the value of pCommandBufferDeviceMasks from VkDeviceGroupSubmitInfo
func (x DeviceGroupSubmitInfo) PCommandBufferDeviceMasks() []uint32 {
	ptr := func(x **C.uint) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pCommandBufferDeviceMasks)
	return *ptr
}

// WithPCommandBufferDeviceMasks sets the value for the PCommandBufferDeviceMasks on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines CommandBufferCount as the length of this field.
// CommandBufferCount is updated with the length of the new value.
func (x DeviceGroupSubmitInfo) WithPCommandBufferDeviceMasks(y []uint32) DeviceGroupSubmitInfo {
	ptr := func(x *[]uint32) **C.uint { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pCommandBufferDeviceMasks = *ptr
	return x.WithCommandBufferCount(uint32(len(y)))
}

// SignalSemaphoreCount returns the value of signalSemaphoreCount from VkDeviceGroupSubmitInfo
func (x DeviceGroupSubmitInfo) SignalSemaphoreCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.signalSemaphoreCount)
	return *ptr
}

// WithSignalSemaphoreCount sets the value for the SignalSemaphoreCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupSubmitInfo) WithSignalSemaphoreCount(y uint32) DeviceGroupSubmitInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.signalSemaphoreCount = *ptr
	return x
}

// PSignalSemaphoreDeviceIndices returns the value of pSignalSemaphoreDeviceIndices from VkDeviceGroupSubmitInfo
func (x DeviceGroupSubmitInfo) PSignalSemaphoreDeviceIndices() []uint32 {
	ptr := func(x **C.uint) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pSignalSemaphoreDeviceIndices)
	return *ptr
}

// WithPSignalSemaphoreDeviceIndices sets the value for the PSignalSemaphoreDeviceIndices on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SignalSemaphoreCount as the length of this field.
// SignalSemaphoreCount is updated with the length of the new value.
func (x DeviceGroupSubmitInfo) WithPSignalSemaphoreDeviceIndices(y []uint32) DeviceGroupSubmitInfo {
	ptr := func(x *[]uint32) **C.uint { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pSignalSemaphoreDeviceIndices = *ptr
	return x.WithSignalSemaphoreCount(uint32(len(y)))
}

//RenderPassInputAttachmentAspectCreateInfo provides a go interface for VkRenderPassInputAttachmentAspectCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkRenderPassInputAttachmentAspectCreateInfo.html
type RenderPassInputAttachmentAspectCreateInfo C.struct_VkRenderPassInputAttachmentAspectCreateInfo

// SizeofRenderPassInputAttachmentAspectCreateInfo is the memory size of a RenderPassInputAttachmentAspectCreateInfo
var SizeofRenderPassInputAttachmentAspectCreateInfo int = int(unsafe.Sizeof(RenderPassInputAttachmentAspectCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *RenderPassInputAttachmentAspectCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x RenderPassInputAttachmentAspectCreateInfo) AsCPtr() *RenderPassInputAttachmentAspectCreateInfo {
	clone := (*RenderPassInputAttachmentAspectCreateInfo)(newCBlock(C.ulong(SizeofRenderPassInputAttachmentAspectCreateInfo)))
	*clone = x
	return clone
}

// RenderPassInputAttachmentAspectCreateInfoFreeCSlice releases the memory allocated by RenderPassInputAttachmentAspectCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func RenderPassInputAttachmentAspectCreateInfoFreeCSlice(x []RenderPassInputAttachmentAspectCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// RenderPassInputAttachmentAspectCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. RenderPassInputAttachmentAspectCreateInfoFreeCSlice must be called on the returned slice.
func RenderPassInputAttachmentAspectCreateInfoMakeCSlice(x ...RenderPassInputAttachmentAspectCreateInfo) []RenderPassInputAttachmentAspectCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderPassInputAttachmentAspectCreateInfo * len(x)
	dst := unsafe.Slice((*RenderPassInputAttachmentAspectCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkRenderPassInputAttachmentAspectCreateInfo
func (x RenderPassInputAttachmentAspectCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x RenderPassInputAttachmentAspectCreateInfo) WithDefaultSType() RenderPassInputAttachmentAspectCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassInputAttachmentAspectCreateInfo) WithSType(y StructureType) RenderPassInputAttachmentAspectCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkRenderPassInputAttachmentAspectCreateInfo
func (x RenderPassInputAttachmentAspectCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassInputAttachmentAspectCreateInfo) WithPNext(y unsafe.Pointer) RenderPassInputAttachmentAspectCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// AspectReferenceCount returns the value of aspectReferenceCount from VkRenderPassInputAttachmentAspectCreateInfo
func (x RenderPassInputAttachmentAspectCreateInfo) AspectReferenceCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.aspectReferenceCount)
	return *ptr
}

// WithAspectReferenceCount sets the value for the AspectReferenceCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassInputAttachmentAspectCreateInfo) WithAspectReferenceCount(y uint32) RenderPassInputAttachmentAspectCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.aspectReferenceCount = *ptr
	return x
}

// PAspectReferences returns the value of pAspectReferences from VkRenderPassInputAttachmentAspectCreateInfo
func (x RenderPassInputAttachmentAspectCreateInfo) PAspectReferences() []InputAttachmentAspectReference {
	ptr := func(x **C.struct_VkInputAttachmentAspectReference) *[]InputAttachmentAspectReference { /* Slice */
		slc := unsafe.Slice((*InputAttachmentAspectReference)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pAspectReferences)
	return *ptr
}

// WithPAspectReferences sets the value for the PAspectReferences on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines AspectReferenceCount as the length of this field.
// AspectReferenceCount is updated with the length of the new value.
func (x RenderPassInputAttachmentAspectCreateInfo) WithPAspectReferences(y []InputAttachmentAspectReference) RenderPassInputAttachmentAspectCreateInfo {
	ptr := func(x *[]InputAttachmentAspectReference) **C.struct_VkInputAttachmentAspectReference { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkInputAttachmentAspectReference)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkInputAttachmentAspectReference)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pAspectReferences = *ptr
	return x.WithAspectReferenceCount(uint32(len(y)))
}

//InputAttachmentAspectReference provides a go interface for VkInputAttachmentAspectReference.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkInputAttachmentAspectReference.html
type InputAttachmentAspectReference C.struct_VkInputAttachmentAspectReference

// SizeofInputAttachmentAspectReference is the memory size of a InputAttachmentAspectReference
var SizeofInputAttachmentAspectReference int = int(unsafe.Sizeof(InputAttachmentAspectReference{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *InputAttachmentAspectReference) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x InputAttachmentAspectReference) AsCPtr() *InputAttachmentAspectReference {
	clone := (*InputAttachmentAspectReference)(newCBlock(C.ulong(SizeofInputAttachmentAspectReference)))
	*clone = x
	return clone
}

// InputAttachmentAspectReferenceFreeCSlice releases the memory allocated by InputAttachmentAspectReferenceMakeCSlice.
// It does not free pointers stored inside the slice.
func InputAttachmentAspectReferenceFreeCSlice(x []InputAttachmentAspectReference) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// InputAttachmentAspectReferenceMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. InputAttachmentAspectReferenceFreeCSlice must be called on the returned slice.
func InputAttachmentAspectReferenceMakeCSlice(x ...InputAttachmentAspectReference) []InputAttachmentAspectReference {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofInputAttachmentAspectReference * len(x)
	dst := unsafe.Slice((*InputAttachmentAspectReference)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Subpass returns the value of subpass from VkInputAttachmentAspectReference
func (x InputAttachmentAspectReference) Subpass() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.subpass)
	return *ptr
}

// WithSubpass sets the value for the Subpass on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InputAttachmentAspectReference) WithSubpass(y uint32) InputAttachmentAspectReference {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.subpass = *ptr
	return x
}

// InputAttachmentIndex returns the value of inputAttachmentIndex from VkInputAttachmentAspectReference
func (x InputAttachmentAspectReference) InputAttachmentIndex() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.inputAttachmentIndex)
	return *ptr
}

// WithInputAttachmentIndex sets the value for the InputAttachmentIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InputAttachmentAspectReference) WithInputAttachmentIndex(y uint32) InputAttachmentAspectReference {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.inputAttachmentIndex = *ptr
	return x
}

// AspectMask returns the value of aspectMask from VkInputAttachmentAspectReference
func (x InputAttachmentAspectReference) AspectMask() ImageAspectFlags {
	ptr := /* typedef */ (*ImageAspectFlags)(&x.aspectMask)
	return *ptr
}

// WithAspectMask sets the value for the AspectMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InputAttachmentAspectReference) WithAspectMask(y ImageAspectFlags) InputAttachmentAspectReference {
	ptr := /* typedef */ (*C.VkImageAspectFlags)(&y)
	x.aspectMask = *ptr
	return x
}

//ImageViewUsageCreateInfo provides a go interface for VkImageViewUsageCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageViewUsageCreateInfo.html
type ImageViewUsageCreateInfo C.struct_VkImageViewUsageCreateInfo

// SizeofImageViewUsageCreateInfo is the memory size of a ImageViewUsageCreateInfo
var SizeofImageViewUsageCreateInfo int = int(unsafe.Sizeof(ImageViewUsageCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageViewUsageCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageViewUsageCreateInfo) AsCPtr() *ImageViewUsageCreateInfo {
	clone := (*ImageViewUsageCreateInfo)(newCBlock(C.ulong(SizeofImageViewUsageCreateInfo)))
	*clone = x
	return clone
}

// ImageViewUsageCreateInfoFreeCSlice releases the memory allocated by ImageViewUsageCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageViewUsageCreateInfoFreeCSlice(x []ImageViewUsageCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageViewUsageCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageViewUsageCreateInfoFreeCSlice must be called on the returned slice.
func ImageViewUsageCreateInfoMakeCSlice(x ...ImageViewUsageCreateInfo) []ImageViewUsageCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageViewUsageCreateInfo * len(x)
	dst := unsafe.Slice((*ImageViewUsageCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageViewUsageCreateInfo
func (x ImageViewUsageCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ImageViewUsageCreateInfo) WithDefaultSType() ImageViewUsageCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewUsageCreateInfo) WithSType(y StructureType) ImageViewUsageCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkImageViewUsageCreateInfo
func (x ImageViewUsageCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewUsageCreateInfo) WithPNext(y unsafe.Pointer) ImageViewUsageCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Usage returns the value of usage from VkImageViewUsageCreateInfo
func (x ImageViewUsageCreateInfo) Usage() ImageUsageFlags {
	ptr := /* typedef */ (*ImageUsageFlags)(&x.usage)
	return *ptr
}

// WithUsage sets the value for the Usage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewUsageCreateInfo) WithUsage(y ImageUsageFlags) ImageViewUsageCreateInfo {
	ptr := /* typedef */ (*C.VkImageUsageFlags)(&y)
	x.usage = *ptr
	return x
}

//DeviceGroupCommandBufferBeginInfo provides a go interface for VkDeviceGroupCommandBufferBeginInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDeviceGroupCommandBufferBeginInfo.html
type DeviceGroupCommandBufferBeginInfo C.struct_VkDeviceGroupCommandBufferBeginInfo

// SizeofDeviceGroupCommandBufferBeginInfo is the memory size of a DeviceGroupCommandBufferBeginInfo
var SizeofDeviceGroupCommandBufferBeginInfo int = int(unsafe.Sizeof(DeviceGroupCommandBufferBeginInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceGroupCommandBufferBeginInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceGroupCommandBufferBeginInfo) AsCPtr() *DeviceGroupCommandBufferBeginInfo {
	clone := (*DeviceGroupCommandBufferBeginInfo)(newCBlock(C.ulong(SizeofDeviceGroupCommandBufferBeginInfo)))
	*clone = x
	return clone
}

// DeviceGroupCommandBufferBeginInfoFreeCSlice releases the memory allocated by DeviceGroupCommandBufferBeginInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceGroupCommandBufferBeginInfoFreeCSlice(x []DeviceGroupCommandBufferBeginInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceGroupCommandBufferBeginInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceGroupCommandBufferBeginInfoFreeCSlice must be called on the returned slice.
func DeviceGroupCommandBufferBeginInfoMakeCSlice(x ...DeviceGroupCommandBufferBeginInfo) []DeviceGroupCommandBufferBeginInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupCommandBufferBeginInfo * len(x)
	dst := unsafe.Slice((*DeviceGroupCommandBufferBeginInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceGroupCommandBufferBeginInfo
func (x DeviceGroupCommandBufferBeginInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DeviceGroupCommandBufferBeginInfo) WithDefaultSType() DeviceGroupCommandBufferBeginInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupCommandBufferBeginInfo) WithSType(y StructureType) DeviceGroupCommandBufferBeginInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDeviceGroupCommandBufferBeginInfo
func (x DeviceGroupCommandBufferBeginInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupCommandBufferBeginInfo) WithPNext(y unsafe.Pointer) DeviceGroupCommandBufferBeginInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// DeviceMask returns the value of deviceMask from VkDeviceGroupCommandBufferBeginInfo
func (x DeviceGroupCommandBufferBeginInfo) DeviceMask() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.deviceMask)
	return *ptr
}

// WithDeviceMask sets the value for the DeviceMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupCommandBufferBeginInfo) WithDeviceMask(y uint32) DeviceGroupCommandBufferBeginInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.deviceMask = *ptr
	return x
}

//PipelineTessellationDomainOriginStateCreateInfo provides a go interface for VkPipelineTessellationDomainOriginStateCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineTessellationDomainOriginStateCreateInfo.html
type PipelineTessellationDomainOriginStateCreateInfo C.struct_VkPipelineTessellationDomainOriginStateCreateInfo

// SizeofPipelineTessellationDomainOriginStateCreateInfo is the memory size of a PipelineTessellationDomainOriginStateCreateInfo
var SizeofPipelineTessellationDomainOriginStateCreateInfo int = int(unsafe.Sizeof(PipelineTessellationDomainOriginStateCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineTessellationDomainOriginStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineTessellationDomainOriginStateCreateInfo) AsCPtr() *PipelineTessellationDomainOriginStateCreateInfo {
	clone := (*PipelineTessellationDomainOriginStateCreateInfo)(newCBlock(C.ulong(SizeofPipelineTessellationDomainOriginStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineTessellationDomainOriginStateCreateInfoFreeCSlice releases the memory allocated by PipelineTessellationDomainOriginStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineTessellationDomainOriginStateCreateInfoFreeCSlice(x []PipelineTessellationDomainOriginStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineTessellationDomainOriginStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineTessellationDomainOriginStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineTessellationDomainOriginStateCreateInfoMakeCSlice(x ...PipelineTessellationDomainOriginStateCreateInfo) []PipelineTessellationDomainOriginStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineTessellationDomainOriginStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineTessellationDomainOriginStateCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineTessellationDomainOriginStateCreateInfo
func (x PipelineTessellationDomainOriginStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineTessellationDomainOriginStateCreateInfo) WithDefaultSType() PipelineTessellationDomainOriginStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineTessellationDomainOriginStateCreateInfo) WithSType(y StructureType) PipelineTessellationDomainOriginStateCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPipelineTessellationDomainOriginStateCreateInfo
func (x PipelineTessellationDomainOriginStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineTessellationDomainOriginStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineTessellationDomainOriginStateCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// DomainOrigin returns the value of domainOrigin from VkPipelineTessellationDomainOriginStateCreateInfo
func (x PipelineTessellationDomainOriginStateCreateInfo) DomainOrigin() TessellationDomainOrigin {
	ptr := /* typedef */ (*TessellationDomainOrigin)(&x.domainOrigin)
	return *ptr
}

// WithDomainOrigin sets the value for the DomainOrigin on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineTessellationDomainOriginStateCreateInfo) WithDomainOrigin(y TessellationDomainOrigin) PipelineTessellationDomainOriginStateCreateInfo {
	ptr := /* typedef */ (*C.VkTessellationDomainOrigin)(&y)
	x.domainOrigin = *ptr
	return x
}

//RenderPassMultiviewCreateInfo provides a go interface for VkRenderPassMultiviewCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkRenderPassMultiviewCreateInfo.html
type RenderPassMultiviewCreateInfo C.struct_VkRenderPassMultiviewCreateInfo

// SizeofRenderPassMultiviewCreateInfo is the memory size of a RenderPassMultiviewCreateInfo
var SizeofRenderPassMultiviewCreateInfo int = int(unsafe.Sizeof(RenderPassMultiviewCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *RenderPassMultiviewCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x RenderPassMultiviewCreateInfo) AsCPtr() *RenderPassMultiviewCreateInfo {
	clone := (*RenderPassMultiviewCreateInfo)(newCBlock(C.ulong(SizeofRenderPassMultiviewCreateInfo)))
	*clone = x
	return clone
}

// RenderPassMultiviewCreateInfoFreeCSlice releases the memory allocated by RenderPassMultiviewCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func RenderPassMultiviewCreateInfoFreeCSlice(x []RenderPassMultiviewCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// RenderPassMultiviewCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. RenderPassMultiviewCreateInfoFreeCSlice must be called on the returned slice.
func RenderPassMultiviewCreateInfoMakeCSlice(x ...RenderPassMultiviewCreateInfo) []RenderPassMultiviewCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderPassMultiviewCreateInfo * len(x)
	dst := unsafe.Slice((*RenderPassMultiviewCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkRenderPassMultiviewCreateInfo
func (x RenderPassMultiviewCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x RenderPassMultiviewCreateInfo) WithDefaultSType() RenderPassMultiviewCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassMultiviewCreateInfo) WithSType(y StructureType) RenderPassMultiviewCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkRenderPassMultiviewCreateInfo
func (x RenderPassMultiviewCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassMultiviewCreateInfo) WithPNext(y unsafe.Pointer) RenderPassMultiviewCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// SubpassCount returns the value of subpassCount from VkRenderPassMultiviewCreateInfo
func (x RenderPassMultiviewCreateInfo) SubpassCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.subpassCount)
	return *ptr
}

// WithSubpassCount sets the value for the SubpassCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassMultiviewCreateInfo) WithSubpassCount(y uint32) RenderPassMultiviewCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.subpassCount = *ptr
	return x
}

// PViewMasks returns the value of pViewMasks from VkRenderPassMultiviewCreateInfo
func (x RenderPassMultiviewCreateInfo) PViewMasks() []uint32 {
	ptr := func(x **C.uint) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pViewMasks)
	return *ptr
}

// WithPViewMasks sets the value for the PViewMasks on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SubpassCount as the length of this field.
// SubpassCount is updated with the length of the new value.
func (x RenderPassMultiviewCreateInfo) WithPViewMasks(y []uint32) RenderPassMultiviewCreateInfo {
	ptr := func(x *[]uint32) **C.uint { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pViewMasks = *ptr
	return x.WithSubpassCount(uint32(len(y)))
}

// DependencyCount returns the value of dependencyCount from VkRenderPassMultiviewCreateInfo
func (x RenderPassMultiviewCreateInfo) DependencyCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.dependencyCount)
	return *ptr
}

// WithDependencyCount sets the value for the DependencyCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassMultiviewCreateInfo) WithDependencyCount(y uint32) RenderPassMultiviewCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.dependencyCount = *ptr
	return x
}

// PViewOffsets returns the value of pViewOffsets from VkRenderPassMultiviewCreateInfo
func (x RenderPassMultiviewCreateInfo) PViewOffsets() []int32 {
	ptr := func(x **C.int) *[]int32 { /* Slice */
		slc := unsafe.Slice((*int32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pViewOffsets)
	return *ptr
}

// WithPViewOffsets sets the value for the PViewOffsets on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DependencyCount as the length of this field.
// DependencyCount is updated with the length of the new value.
func (x RenderPassMultiviewCreateInfo) WithPViewOffsets(y []int32) RenderPassMultiviewCreateInfo {
	ptr := func(x *[]int32) **C.int { /* Slice */
		if len(*x) > 0 {
			slc := (*C.int)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.int)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pViewOffsets = *ptr
	return x.WithDependencyCount(uint32(len(y)))
}

// CorrelationMaskCount returns the value of correlationMaskCount from VkRenderPassMultiviewCreateInfo
func (x RenderPassMultiviewCreateInfo) CorrelationMaskCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.correlationMaskCount)
	return *ptr
}

// WithCorrelationMaskCount sets the value for the CorrelationMaskCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassMultiviewCreateInfo) WithCorrelationMaskCount(y uint32) RenderPassMultiviewCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.correlationMaskCount = *ptr
	return x
}

// PCorrelationMasks returns the value of pCorrelationMasks from VkRenderPassMultiviewCreateInfo
func (x RenderPassMultiviewCreateInfo) PCorrelationMasks() []uint32 {
	ptr := func(x **C.uint) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pCorrelationMasks)
	return *ptr
}

// WithPCorrelationMasks sets the value for the PCorrelationMasks on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines CorrelationMaskCount as the length of this field.
// CorrelationMaskCount is updated with the length of the new value.
func (x RenderPassMultiviewCreateInfo) WithPCorrelationMasks(y []uint32) RenderPassMultiviewCreateInfo {
	ptr := func(x *[]uint32) **C.uint { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pCorrelationMasks = *ptr
	return x.WithCorrelationMaskCount(uint32(len(y)))
}

//PhysicalDeviceMultiviewFeatures provides a go interface for VkPhysicalDeviceMultiviewFeatures.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceMultiviewFeatures.html
type PhysicalDeviceMultiviewFeatures C.struct_VkPhysicalDeviceMultiviewFeatures

// SizeofPhysicalDeviceMultiviewFeatures is the memory size of a PhysicalDeviceMultiviewFeatures
var SizeofPhysicalDeviceMultiviewFeatures int = int(unsafe.Sizeof(PhysicalDeviceMultiviewFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceMultiviewFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceMultiviewFeatures) AsCPtr() *PhysicalDeviceMultiviewFeatures {
	clone := (*PhysicalDeviceMultiviewFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceMultiviewFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceMultiviewFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceMultiviewFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceMultiviewFeaturesFreeCSlice(x []PhysicalDeviceMultiviewFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceMultiviewFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceMultiviewFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceMultiviewFeaturesMakeCSlice(x ...PhysicalDeviceMultiviewFeatures) []PhysicalDeviceMultiviewFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceMultiviewFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceMultiviewFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceMultiviewFeatures
func (x PhysicalDeviceMultiviewFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceMultiviewFeatures) WithDefaultSType() PhysicalDeviceMultiviewFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMultiviewFeatures) WithSType(y StructureType) PhysicalDeviceMultiviewFeatures {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceMultiviewFeatures
func (x PhysicalDeviceMultiviewFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMultiviewFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceMultiviewFeatures {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Multiview returns the value of multiview from VkPhysicalDeviceMultiviewFeatures
func (x PhysicalDeviceMultiviewFeatures) Multiview() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.multiview)
	return *ptr
}

// WithMultiview sets the value for the Multiview on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMultiviewFeatures) WithMultiview(y Bool32) PhysicalDeviceMultiviewFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.multiview = *ptr
	return x
}

// MultiviewGeometryShader returns the value of multiviewGeometryShader from VkPhysicalDeviceMultiviewFeatures
func (x PhysicalDeviceMultiviewFeatures) MultiviewGeometryShader() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.multiviewGeometryShader)
	return *ptr
}

// WithMultiviewGeometryShader sets the value for the MultiviewGeometryShader on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMultiviewFeatures) WithMultiviewGeometryShader(y Bool32) PhysicalDeviceMultiviewFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.multiviewGeometryShader = *ptr
	return x
}

// MultiviewTessellationShader returns the value of multiviewTessellationShader from VkPhysicalDeviceMultiviewFeatures
func (x PhysicalDeviceMultiviewFeatures) MultiviewTessellationShader() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.multiviewTessellationShader)
	return *ptr
}

// WithMultiviewTessellationShader sets the value for the MultiviewTessellationShader on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMultiviewFeatures) WithMultiviewTessellationShader(y Bool32) PhysicalDeviceMultiviewFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.multiviewTessellationShader = *ptr
	return x
}

//PhysicalDeviceMultiviewProperties provides a go interface for VkPhysicalDeviceMultiviewProperties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceMultiviewProperties.html
type PhysicalDeviceMultiviewProperties C.struct_VkPhysicalDeviceMultiviewProperties

// SizeofPhysicalDeviceMultiviewProperties is the memory size of a PhysicalDeviceMultiviewProperties
var SizeofPhysicalDeviceMultiviewProperties int = int(unsafe.Sizeof(PhysicalDeviceMultiviewProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceMultiviewProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceMultiviewProperties) AsCPtr() *PhysicalDeviceMultiviewProperties {
	clone := (*PhysicalDeviceMultiviewProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceMultiviewProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceMultiviewPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceMultiviewPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceMultiviewPropertiesFreeCSlice(x []PhysicalDeviceMultiviewProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceMultiviewPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceMultiviewPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceMultiviewPropertiesMakeCSlice(x ...PhysicalDeviceMultiviewProperties) []PhysicalDeviceMultiviewProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceMultiviewProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceMultiviewProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceMultiviewProperties
func (x PhysicalDeviceMultiviewProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceMultiviewProperties) WithDefaultSType() PhysicalDeviceMultiviewProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMultiviewProperties) WithSType(y StructureType) PhysicalDeviceMultiviewProperties {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceMultiviewProperties
func (x PhysicalDeviceMultiviewProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMultiviewProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceMultiviewProperties {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// MaxMultiviewViewCount returns the value of maxMultiviewViewCount from VkPhysicalDeviceMultiviewProperties
func (x PhysicalDeviceMultiviewProperties) MaxMultiviewViewCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxMultiviewViewCount)
	return *ptr
}

// MaxMultiviewInstanceIndex returns the value of maxMultiviewInstanceIndex from VkPhysicalDeviceMultiviewProperties
func (x PhysicalDeviceMultiviewProperties) MaxMultiviewInstanceIndex() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxMultiviewInstanceIndex)
	return *ptr
}

//PhysicalDeviceVariablePointerFeatures is an alias to PhysicalDeviceVariablePointersFeatures.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVariablePointerFeatures.html
//
// Deprecated: Most Aliases in the Vulkan spec are for compatibility purposes as extensions get
// promoted to features. If possible, update code to use the promoted name: PhysicalDeviceVariablePointersFeatures.
type PhysicalDeviceVariablePointerFeatures = PhysicalDeviceVariablePointersFeatures

//DeviceGroupRenderPassBeginInfo provides a go interface for VkDeviceGroupRenderPassBeginInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDeviceGroupRenderPassBeginInfo.html
type DeviceGroupRenderPassBeginInfo C.struct_VkDeviceGroupRenderPassBeginInfo

// SizeofDeviceGroupRenderPassBeginInfo is the memory size of a DeviceGroupRenderPassBeginInfo
var SizeofDeviceGroupRenderPassBeginInfo int = int(unsafe.Sizeof(DeviceGroupRenderPassBeginInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceGroupRenderPassBeginInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceGroupRenderPassBeginInfo) AsCPtr() *DeviceGroupRenderPassBeginInfo {
	clone := (*DeviceGroupRenderPassBeginInfo)(newCBlock(C.ulong(SizeofDeviceGroupRenderPassBeginInfo)))
	*clone = x
	return clone
}

// DeviceGroupRenderPassBeginInfoFreeCSlice releases the memory allocated by DeviceGroupRenderPassBeginInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceGroupRenderPassBeginInfoFreeCSlice(x []DeviceGroupRenderPassBeginInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceGroupRenderPassBeginInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceGroupRenderPassBeginInfoFreeCSlice must be called on the returned slice.
func DeviceGroupRenderPassBeginInfoMakeCSlice(x ...DeviceGroupRenderPassBeginInfo) []DeviceGroupRenderPassBeginInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupRenderPassBeginInfo * len(x)
	dst := unsafe.Slice((*DeviceGroupRenderPassBeginInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceGroupRenderPassBeginInfo
func (x DeviceGroupRenderPassBeginInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DeviceGroupRenderPassBeginInfo) WithDefaultSType() DeviceGroupRenderPassBeginInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupRenderPassBeginInfo) WithSType(y StructureType) DeviceGroupRenderPassBeginInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDeviceGroupRenderPassBeginInfo
func (x DeviceGroupRenderPassBeginInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupRenderPassBeginInfo) WithPNext(y unsafe.Pointer) DeviceGroupRenderPassBeginInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// DeviceMask returns the value of deviceMask from VkDeviceGroupRenderPassBeginInfo
func (x DeviceGroupRenderPassBeginInfo) DeviceMask() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.deviceMask)
	return *ptr
}

// WithDeviceMask sets the value for the DeviceMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupRenderPassBeginInfo) WithDeviceMask(y uint32) DeviceGroupRenderPassBeginInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.deviceMask = *ptr
	return x
}

// DeviceRenderAreaCount returns the value of deviceRenderAreaCount from VkDeviceGroupRenderPassBeginInfo
func (x DeviceGroupRenderPassBeginInfo) DeviceRenderAreaCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.deviceRenderAreaCount)
	return *ptr
}

// WithDeviceRenderAreaCount sets the value for the DeviceRenderAreaCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupRenderPassBeginInfo) WithDeviceRenderAreaCount(y uint32) DeviceGroupRenderPassBeginInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.deviceRenderAreaCount = *ptr
	return x
}

// PDeviceRenderAreas returns the value of pDeviceRenderAreas from VkDeviceGroupRenderPassBeginInfo
func (x DeviceGroupRenderPassBeginInfo) PDeviceRenderAreas() []Rect2D {
	ptr := func(x **C.struct_VkRect2D) *[]Rect2D { /* Slice */
		slc := unsafe.Slice((*Rect2D)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pDeviceRenderAreas)
	return *ptr
}

// WithPDeviceRenderAreas sets the value for the PDeviceRenderAreas on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DeviceRenderAreaCount as the length of this field.
// DeviceRenderAreaCount is updated with the length of the new value.
func (x DeviceGroupRenderPassBeginInfo) WithPDeviceRenderAreas(y []Rect2D) DeviceGroupRenderPassBeginInfo {
	ptr := func(x *[]Rect2D) **C.struct_VkRect2D { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkRect2D)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkRect2D)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pDeviceRenderAreas = *ptr
	return x.WithDeviceRenderAreaCount(uint32(len(y)))
}

//MemoryAllocateFlagsInfo provides a go interface for VkMemoryAllocateFlagsInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkMemoryAllocateFlagsInfo.html
type MemoryAllocateFlagsInfo C.struct_VkMemoryAllocateFlagsInfo

// SizeofMemoryAllocateFlagsInfo is the memory size of a MemoryAllocateFlagsInfo
var SizeofMemoryAllocateFlagsInfo int = int(unsafe.Sizeof(MemoryAllocateFlagsInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryAllocateFlagsInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryAllocateFlagsInfo) AsCPtr() *MemoryAllocateFlagsInfo {
	clone := (*MemoryAllocateFlagsInfo)(newCBlock(C.ulong(SizeofMemoryAllocateFlagsInfo)))
	*clone = x
	return clone
}

// MemoryAllocateFlagsInfoFreeCSlice releases the memory allocated by MemoryAllocateFlagsInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryAllocateFlagsInfoFreeCSlice(x []MemoryAllocateFlagsInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryAllocateFlagsInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryAllocateFlagsInfoFreeCSlice must be called on the returned slice.
func MemoryAllocateFlagsInfoMakeCSlice(x ...MemoryAllocateFlagsInfo) []MemoryAllocateFlagsInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryAllocateFlagsInfo * len(x)
	dst := unsafe.Slice((*MemoryAllocateFlagsInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkMemoryAllocateFlagsInfo
func (x MemoryAllocateFlagsInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x MemoryAllocateFlagsInfo) WithDefaultSType() MemoryAllocateFlagsInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryAllocateFlagsInfo) WithSType(y StructureType) MemoryAllocateFlagsInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkMemoryAllocateFlagsInfo
func (x MemoryAllocateFlagsInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryAllocateFlagsInfo) WithPNext(y unsafe.Pointer) MemoryAllocateFlagsInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkMemoryAllocateFlagsInfo
func (x MemoryAllocateFlagsInfo) Flags() MemoryAllocateFlags {
	ptr := /* typedef */ (*MemoryAllocateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryAllocateFlagsInfo) WithFlags(y MemoryAllocateFlags) MemoryAllocateFlagsInfo {
	ptr := /* typedef */ (*C.VkMemoryAllocateFlags)(&y)
	x.flags = *ptr
	return x
}

// DeviceMask returns the value of deviceMask from VkMemoryAllocateFlagsInfo
func (x MemoryAllocateFlagsInfo) DeviceMask() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.deviceMask)
	return *ptr
}

// WithDeviceMask sets the value for the DeviceMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryAllocateFlagsInfo) WithDeviceMask(y uint32) MemoryAllocateFlagsInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.deviceMask = *ptr
	return x
}

//PhysicalDeviceProtectedMemoryFeatures provides a go interface for VkPhysicalDeviceProtectedMemoryFeatures.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceProtectedMemoryFeatures.html
type PhysicalDeviceProtectedMemoryFeatures C.struct_VkPhysicalDeviceProtectedMemoryFeatures

// SizeofPhysicalDeviceProtectedMemoryFeatures is the memory size of a PhysicalDeviceProtectedMemoryFeatures
var SizeofPhysicalDeviceProtectedMemoryFeatures int = int(unsafe.Sizeof(PhysicalDeviceProtectedMemoryFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceProtectedMemoryFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceProtectedMemoryFeatures) AsCPtr() *PhysicalDeviceProtectedMemoryFeatures {
	clone := (*PhysicalDeviceProtectedMemoryFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceProtectedMemoryFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceProtectedMemoryFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceProtectedMemoryFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceProtectedMemoryFeaturesFreeCSlice(x []PhysicalDeviceProtectedMemoryFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceProtectedMemoryFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceProtectedMemoryFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceProtectedMemoryFeaturesMakeCSlice(x ...PhysicalDeviceProtectedMemoryFeatures) []PhysicalDeviceProtectedMemoryFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceProtectedMemoryFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceProtectedMemoryFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceProtectedMemoryFeatures
func (x PhysicalDeviceProtectedMemoryFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceProtectedMemoryFeatures) WithDefaultSType() PhysicalDeviceProtectedMemoryFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceProtectedMemoryFeatures) WithSType(y StructureType) PhysicalDeviceProtectedMemoryFeatures {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceProtectedMemoryFeatures
func (x PhysicalDeviceProtectedMemoryFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceProtectedMemoryFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceProtectedMemoryFeatures {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// ProtectedMemory returns the value of protectedMemory from VkPhysicalDeviceProtectedMemoryFeatures
func (x PhysicalDeviceProtectedMemoryFeatures) ProtectedMemory() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.protectedMemory)
	return *ptr
}

// WithProtectedMemory sets the value for the ProtectedMemory on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceProtectedMemoryFeatures) WithProtectedMemory(y Bool32) PhysicalDeviceProtectedMemoryFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.protectedMemory = *ptr
	return x
}

//PhysicalDeviceProtectedMemoryProperties provides a go interface for VkPhysicalDeviceProtectedMemoryProperties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceProtectedMemoryProperties.html
type PhysicalDeviceProtectedMemoryProperties C.struct_VkPhysicalDeviceProtectedMemoryProperties

// SizeofPhysicalDeviceProtectedMemoryProperties is the memory size of a PhysicalDeviceProtectedMemoryProperties
var SizeofPhysicalDeviceProtectedMemoryProperties int = int(unsafe.Sizeof(PhysicalDeviceProtectedMemoryProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceProtectedMemoryProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceProtectedMemoryProperties) AsCPtr() *PhysicalDeviceProtectedMemoryProperties {
	clone := (*PhysicalDeviceProtectedMemoryProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceProtectedMemoryProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceProtectedMemoryPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceProtectedMemoryPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceProtectedMemoryPropertiesFreeCSlice(x []PhysicalDeviceProtectedMemoryProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceProtectedMemoryPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceProtectedMemoryPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceProtectedMemoryPropertiesMakeCSlice(x ...PhysicalDeviceProtectedMemoryProperties) []PhysicalDeviceProtectedMemoryProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceProtectedMemoryProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceProtectedMemoryProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceProtectedMemoryProperties
func (x PhysicalDeviceProtectedMemoryProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceProtectedMemoryProperties) WithDefaultSType() PhysicalDeviceProtectedMemoryProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceProtectedMemoryProperties) WithSType(y StructureType) PhysicalDeviceProtectedMemoryProperties {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceProtectedMemoryProperties
func (x PhysicalDeviceProtectedMemoryProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceProtectedMemoryProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceProtectedMemoryProperties {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// ProtectedNoFault returns the value of protectedNoFault from VkPhysicalDeviceProtectedMemoryProperties
func (x PhysicalDeviceProtectedMemoryProperties) ProtectedNoFault() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.protectedNoFault)
	return *ptr
}

//DeviceQueueInfo2 provides a go interface for VkDeviceQueueInfo2.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDeviceQueueInfo2.html
type DeviceQueueInfo2 C.struct_VkDeviceQueueInfo2

// SizeofDeviceQueueInfo2 is the memory size of a DeviceQueueInfo2
var SizeofDeviceQueueInfo2 int = int(unsafe.Sizeof(DeviceQueueInfo2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceQueueInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceQueueInfo2) AsCPtr() *DeviceQueueInfo2 {
	clone := (*DeviceQueueInfo2)(newCBlock(C.ulong(SizeofDeviceQueueInfo2)))
	*clone = x
	return clone
}

// DeviceQueueInfo2FreeCSlice releases the memory allocated by DeviceQueueInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceQueueInfo2FreeCSlice(x []DeviceQueueInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceQueueInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceQueueInfo2FreeCSlice must be called on the returned slice.
func DeviceQueueInfo2MakeCSlice(x ...DeviceQueueInfo2) []DeviceQueueInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceQueueInfo2 * len(x)
	dst := unsafe.Slice((*DeviceQueueInfo2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceQueueInfo2
func (x DeviceQueueInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DeviceQueueInfo2) WithDefaultSType() DeviceQueueInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueInfo2) WithSType(y StructureType) DeviceQueueInfo2 {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDeviceQueueInfo2
func (x DeviceQueueInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueInfo2) WithPNext(y unsafe.Pointer) DeviceQueueInfo2 {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkDeviceQueueInfo2
func (x DeviceQueueInfo2) Flags() DeviceQueueCreateFlags {
	ptr := /* typedef */ (*DeviceQueueCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueInfo2) WithFlags(y DeviceQueueCreateFlags) DeviceQueueInfo2 {
	ptr := /* typedef */ (*C.VkDeviceQueueCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// QueueFamilyIndex returns the value of queueFamilyIndex from VkDeviceQueueInfo2
func (x DeviceQueueInfo2) QueueFamilyIndex() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.queueFamilyIndex)
	return *ptr
}

// WithQueueFamilyIndex sets the value for the QueueFamilyIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueInfo2) WithQueueFamilyIndex(y uint32) DeviceQueueInfo2 {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.queueFamilyIndex = *ptr
	return x
}

// QueueIndex returns the value of queueIndex from VkDeviceQueueInfo2
func (x DeviceQueueInfo2) QueueIndex() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.queueIndex)
	return *ptr
}

// WithQueueIndex sets the value for the QueueIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueInfo2) WithQueueIndex(y uint32) DeviceQueueInfo2 {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.queueIndex = *ptr
	return x
}

//ProtectedSubmitInfo provides a go interface for VkProtectedSubmitInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkProtectedSubmitInfo.html
type ProtectedSubmitInfo C.struct_VkProtectedSubmitInfo

// SizeofProtectedSubmitInfo is the memory size of a ProtectedSubmitInfo
var SizeofProtectedSubmitInfo int = int(unsafe.Sizeof(ProtectedSubmitInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ProtectedSubmitInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ProtectedSubmitInfo) AsCPtr() *ProtectedSubmitInfo {
	clone := (*ProtectedSubmitInfo)(newCBlock(C.ulong(SizeofProtectedSubmitInfo)))
	*clone = x
	return clone
}

// ProtectedSubmitInfoFreeCSlice releases the memory allocated by ProtectedSubmitInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ProtectedSubmitInfoFreeCSlice(x []ProtectedSubmitInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ProtectedSubmitInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ProtectedSubmitInfoFreeCSlice must be called on the returned slice.
func ProtectedSubmitInfoMakeCSlice(x ...ProtectedSubmitInfo) []ProtectedSubmitInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofProtectedSubmitInfo * len(x)
	dst := unsafe.Slice((*ProtectedSubmitInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkProtectedSubmitInfo
func (x ProtectedSubmitInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ProtectedSubmitInfo) WithDefaultSType() ProtectedSubmitInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ProtectedSubmitInfo) WithSType(y StructureType) ProtectedSubmitInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkProtectedSubmitInfo
func (x ProtectedSubmitInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ProtectedSubmitInfo) WithPNext(y unsafe.Pointer) ProtectedSubmitInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// ProtectedSubmit returns the value of protectedSubmit from VkProtectedSubmitInfo
func (x ProtectedSubmitInfo) ProtectedSubmit() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.protectedSubmit)
	return *ptr
}

// WithProtectedSubmit sets the value for the ProtectedSubmit on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ProtectedSubmitInfo) WithProtectedSubmit(y Bool32) ProtectedSubmitInfo {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.protectedSubmit = *ptr
	return x
}

//PhysicalDeviceExternalSemaphoreInfo provides a go interface for VkPhysicalDeviceExternalSemaphoreInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceExternalSemaphoreInfo.html
type PhysicalDeviceExternalSemaphoreInfo C.struct_VkPhysicalDeviceExternalSemaphoreInfo

// SizeofPhysicalDeviceExternalSemaphoreInfo is the memory size of a PhysicalDeviceExternalSemaphoreInfo
var SizeofPhysicalDeviceExternalSemaphoreInfo int = int(unsafe.Sizeof(PhysicalDeviceExternalSemaphoreInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceExternalSemaphoreInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceExternalSemaphoreInfo) AsCPtr() *PhysicalDeviceExternalSemaphoreInfo {
	clone := (*PhysicalDeviceExternalSemaphoreInfo)(newCBlock(C.ulong(SizeofPhysicalDeviceExternalSemaphoreInfo)))
	*clone = x
	return clone
}

// PhysicalDeviceExternalSemaphoreInfoFreeCSlice releases the memory allocated by PhysicalDeviceExternalSemaphoreInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceExternalSemaphoreInfoFreeCSlice(x []PhysicalDeviceExternalSemaphoreInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceExternalSemaphoreInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceExternalSemaphoreInfoFreeCSlice must be called on the returned slice.
func PhysicalDeviceExternalSemaphoreInfoMakeCSlice(x ...PhysicalDeviceExternalSemaphoreInfo) []PhysicalDeviceExternalSemaphoreInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceExternalSemaphoreInfo * len(x)
	dst := unsafe.Slice((*PhysicalDeviceExternalSemaphoreInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceExternalSemaphoreInfo
func (x PhysicalDeviceExternalSemaphoreInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceExternalSemaphoreInfo) WithDefaultSType() PhysicalDeviceExternalSemaphoreInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalSemaphoreInfo) WithSType(y StructureType) PhysicalDeviceExternalSemaphoreInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceExternalSemaphoreInfo
func (x PhysicalDeviceExternalSemaphoreInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalSemaphoreInfo) WithPNext(y unsafe.Pointer) PhysicalDeviceExternalSemaphoreInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// HandleType returns the value of handleType from VkPhysicalDeviceExternalSemaphoreInfo
func (x PhysicalDeviceExternalSemaphoreInfo) HandleType() ExternalSemaphoreHandleTypeFlagBits {
	ptr := /* typedef */ (*ExternalSemaphoreHandleTypeFlagBits)(&x.handleType)
	return *ptr
}

// WithHandleType sets the value for the HandleType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalSemaphoreInfo) WithHandleType(y ExternalSemaphoreHandleTypeFlagBits) PhysicalDeviceExternalSemaphoreInfo {
	ptr := /* typedef */ (*C.VkExternalSemaphoreHandleTypeFlagBits)(&y)
	x.handleType = *ptr
	return x
}

//ExportMemoryAllocateInfo provides a go interface for VkExportMemoryAllocateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkExportMemoryAllocateInfo.html
type ExportMemoryAllocateInfo C.struct_VkExportMemoryAllocateInfo

// SizeofExportMemoryAllocateInfo is the memory size of a ExportMemoryAllocateInfo
var SizeofExportMemoryAllocateInfo int = int(unsafe.Sizeof(ExportMemoryAllocateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExportMemoryAllocateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExportMemoryAllocateInfo) AsCPtr() *ExportMemoryAllocateInfo {
	clone := (*ExportMemoryAllocateInfo)(newCBlock(C.ulong(SizeofExportMemoryAllocateInfo)))
	*clone = x
	return clone
}

// ExportMemoryAllocateInfoFreeCSlice releases the memory allocated by ExportMemoryAllocateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ExportMemoryAllocateInfoFreeCSlice(x []ExportMemoryAllocateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExportMemoryAllocateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExportMemoryAllocateInfoFreeCSlice must be called on the returned slice.
func ExportMemoryAllocateInfoMakeCSlice(x ...ExportMemoryAllocateInfo) []ExportMemoryAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExportMemoryAllocateInfo * len(x)
	dst := unsafe.Slice((*ExportMemoryAllocateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkExportMemoryAllocateInfo
func (x ExportMemoryAllocateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ExportMemoryAllocateInfo) WithDefaultSType() ExportMemoryAllocateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExportMemoryAllocateInfo) WithSType(y StructureType) ExportMemoryAllocateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkExportMemoryAllocateInfo
func (x ExportMemoryAllocateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExportMemoryAllocateInfo) WithPNext(y unsafe.Pointer) ExportMemoryAllocateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// HandleTypes returns the value of handleTypes from VkExportMemoryAllocateInfo
func (x ExportMemoryAllocateInfo) HandleTypes() ExternalMemoryHandleTypeFlags {
	ptr := /* typedef */ (*ExternalMemoryHandleTypeFlags)(&x.handleTypes)
	return *ptr
}

// WithHandleTypes sets the value for the HandleTypes on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExportMemoryAllocateInfo) WithHandleTypes(y ExternalMemoryHandleTypeFlags) ExportMemoryAllocateInfo {
	ptr := /* typedef */ (*C.VkExternalMemoryHandleTypeFlags)(&y)
	x.handleTypes = *ptr
	return x
}

//SamplerYcbcrConversionCreateInfo provides a go interface for VkSamplerYcbcrConversionCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSamplerYcbcrConversionCreateInfo.html
type SamplerYcbcrConversionCreateInfo C.struct_VkSamplerYcbcrConversionCreateInfo

// SizeofSamplerYcbcrConversionCreateInfo is the memory size of a SamplerYcbcrConversionCreateInfo
var SizeofSamplerYcbcrConversionCreateInfo int = int(unsafe.Sizeof(SamplerYcbcrConversionCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SamplerYcbcrConversionCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SamplerYcbcrConversionCreateInfo) AsCPtr() *SamplerYcbcrConversionCreateInfo {
	clone := (*SamplerYcbcrConversionCreateInfo)(newCBlock(C.ulong(SizeofSamplerYcbcrConversionCreateInfo)))
	*clone = x
	return clone
}

// SamplerYcbcrConversionCreateInfoFreeCSlice releases the memory allocated by SamplerYcbcrConversionCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SamplerYcbcrConversionCreateInfoFreeCSlice(x []SamplerYcbcrConversionCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SamplerYcbcrConversionCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SamplerYcbcrConversionCreateInfoFreeCSlice must be called on the returned slice.
func SamplerYcbcrConversionCreateInfoMakeCSlice(x ...SamplerYcbcrConversionCreateInfo) []SamplerYcbcrConversionCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSamplerYcbcrConversionCreateInfo * len(x)
	dst := unsafe.Slice((*SamplerYcbcrConversionCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SamplerYcbcrConversionCreateInfo) WithDefaultSType() SamplerYcbcrConversionCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithSType(y StructureType) SamplerYcbcrConversionCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithPNext(y unsafe.Pointer) SamplerYcbcrConversionCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Format returns the value of format from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format)
	return *ptr
}

// WithFormat sets the value for the Format on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithFormat(y Format) SamplerYcbcrConversionCreateInfo {
	ptr := /* typedef */ (*C.VkFormat)(&y)
	x.format = *ptr
	return x
}

// YcbcrModel returns the value of ycbcrModel from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) YcbcrModel() SamplerYcbcrModelConversion {
	ptr := /* typedef */ (*SamplerYcbcrModelConversion)(&x.ycbcrModel)
	return *ptr
}

// WithYcbcrModel sets the value for the YcbcrModel on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithYcbcrModel(y SamplerYcbcrModelConversion) SamplerYcbcrConversionCreateInfo {
	ptr := /* typedef */ (*C.VkSamplerYcbcrModelConversion)(&y)
	x.ycbcrModel = *ptr
	return x
}

// YcbcrRange returns the value of ycbcrRange from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) YcbcrRange() SamplerYcbcrRange {
	ptr := /* typedef */ (*SamplerYcbcrRange)(&x.ycbcrRange)
	return *ptr
}

// WithYcbcrRange sets the value for the YcbcrRange on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithYcbcrRange(y SamplerYcbcrRange) SamplerYcbcrConversionCreateInfo {
	ptr := /* typedef */ (*C.VkSamplerYcbcrRange)(&y)
	x.ycbcrRange = *ptr
	return x
}

// Components returns the value of components from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) Components() ComponentMapping {
	ptr := /* typedef */ (*ComponentMapping)(&x.components)
	return *ptr
}

// WithComponents sets the value for the Components on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithComponents(y ComponentMapping) SamplerYcbcrConversionCreateInfo {
	ptr := /* typedef */ (*C.struct_VkComponentMapping)(&y)
	x.components = *ptr
	return x
}

// XChromaOffset returns the value of xChromaOffset from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) XChromaOffset() ChromaLocation {
	ptr := /* typedef */ (*ChromaLocation)(&x.xChromaOffset)
	return *ptr
}

// WithXChromaOffset sets the value for the XChromaOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithXChromaOffset(y ChromaLocation) SamplerYcbcrConversionCreateInfo {
	ptr := /* typedef */ (*C.VkChromaLocation)(&y)
	x.xChromaOffset = *ptr
	return x
}

// YChromaOffset returns the value of yChromaOffset from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) YChromaOffset() ChromaLocation {
	ptr := /* typedef */ (*ChromaLocation)(&x.yChromaOffset)
	return *ptr
}

// WithYChromaOffset sets the value for the YChromaOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithYChromaOffset(y ChromaLocation) SamplerYcbcrConversionCreateInfo {
	ptr := /* typedef */ (*C.VkChromaLocation)(&y)
	x.yChromaOffset = *ptr
	return x
}

// ChromaFilter returns the value of chromaFilter from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) ChromaFilter() Filter {
	ptr := /* typedef */ (*Filter)(&x.chromaFilter)
	return *ptr
}

// WithChromaFilter sets the value for the ChromaFilter on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithChromaFilter(y Filter) SamplerYcbcrConversionCreateInfo {
	ptr := /* typedef */ (*C.VkFilter)(&y)
	x.chromaFilter = *ptr
	return x
}

// ForceExplicitReconstruction returns the value of forceExplicitReconstruction from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) ForceExplicitReconstruction() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.forceExplicitReconstruction)
	return *ptr
}

// WithForceExplicitReconstruction sets the value for the ForceExplicitReconstruction on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithForceExplicitReconstruction(y Bool32) SamplerYcbcrConversionCreateInfo {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.forceExplicitReconstruction = *ptr
	return x
}

//SamplerYcbcrConversionInfo provides a go interface for VkSamplerYcbcrConversionInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSamplerYcbcrConversionInfo.html
type SamplerYcbcrConversionInfo C.struct_VkSamplerYcbcrConversionInfo

// SizeofSamplerYcbcrConversionInfo is the memory size of a SamplerYcbcrConversionInfo
var SizeofSamplerYcbcrConversionInfo int = int(unsafe.Sizeof(SamplerYcbcrConversionInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SamplerYcbcrConversionInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SamplerYcbcrConversionInfo) AsCPtr() *SamplerYcbcrConversionInfo {
	clone := (*SamplerYcbcrConversionInfo)(newCBlock(C.ulong(SizeofSamplerYcbcrConversionInfo)))
	*clone = x
	return clone
}

// SamplerYcbcrConversionInfoFreeCSlice releases the memory allocated by SamplerYcbcrConversionInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SamplerYcbcrConversionInfoFreeCSlice(x []SamplerYcbcrConversionInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SamplerYcbcrConversionInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SamplerYcbcrConversionInfoFreeCSlice must be called on the returned slice.
func SamplerYcbcrConversionInfoMakeCSlice(x ...SamplerYcbcrConversionInfo) []SamplerYcbcrConversionInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSamplerYcbcrConversionInfo * len(x)
	dst := unsafe.Slice((*SamplerYcbcrConversionInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSamplerYcbcrConversionInfo
func (x SamplerYcbcrConversionInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SamplerYcbcrConversionInfo) WithDefaultSType() SamplerYcbcrConversionInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionInfo) WithSType(y StructureType) SamplerYcbcrConversionInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkSamplerYcbcrConversionInfo
func (x SamplerYcbcrConversionInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionInfo) WithPNext(y unsafe.Pointer) SamplerYcbcrConversionInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Conversion returns the value of conversion from VkSamplerYcbcrConversionInfo
func (x SamplerYcbcrConversionInfo) Conversion() SamplerYcbcrConversion {
	ptr := /* handle */ (*SamplerYcbcrConversion)(&x.conversion)
	return *ptr
}

// WithConversion sets the value for the Conversion on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionInfo) WithConversion(y SamplerYcbcrConversion) SamplerYcbcrConversionInfo {
	ptr := /* handle */ (*C.VkSamplerYcbcrConversion)(&y)
	x.conversion = *ptr
	return x
}

//BindImagePlaneMemoryInfo provides a go interface for VkBindImagePlaneMemoryInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBindImagePlaneMemoryInfo.html
type BindImagePlaneMemoryInfo C.struct_VkBindImagePlaneMemoryInfo

// SizeofBindImagePlaneMemoryInfo is the memory size of a BindImagePlaneMemoryInfo
var SizeofBindImagePlaneMemoryInfo int = int(unsafe.Sizeof(BindImagePlaneMemoryInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BindImagePlaneMemoryInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BindImagePlaneMemoryInfo) AsCPtr() *BindImagePlaneMemoryInfo {
	clone := (*BindImagePlaneMemoryInfo)(newCBlock(C.ulong(SizeofBindImagePlaneMemoryInfo)))
	*clone = x
	return clone
}

// BindImagePlaneMemoryInfoFreeCSlice releases the memory allocated by BindImagePlaneMemoryInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BindImagePlaneMemoryInfoFreeCSlice(x []BindImagePlaneMemoryInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BindImagePlaneMemoryInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BindImagePlaneMemoryInfoFreeCSlice must be called on the returned slice.
func BindImagePlaneMemoryInfoMakeCSlice(x ...BindImagePlaneMemoryInfo) []BindImagePlaneMemoryInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindImagePlaneMemoryInfo * len(x)
	dst := unsafe.Slice((*BindImagePlaneMemoryInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBindImagePlaneMemoryInfo
func (x BindImagePlaneMemoryInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BindImagePlaneMemoryInfo) WithDefaultSType() BindImagePlaneMemoryInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImagePlaneMemoryInfo) WithSType(y StructureType) BindImagePlaneMemoryInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkBindImagePlaneMemoryInfo
func (x BindImagePlaneMemoryInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImagePlaneMemoryInfo) WithPNext(y unsafe.Pointer) BindImagePlaneMemoryInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// PlaneAspect returns the value of planeAspect from VkBindImagePlaneMemoryInfo
func (x BindImagePlaneMemoryInfo) PlaneAspect() ImageAspectFlagBits {
	ptr := /* typedef */ (*ImageAspectFlagBits)(&x.planeAspect)
	return *ptr
}

// WithPlaneAspect sets the value for the PlaneAspect on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImagePlaneMemoryInfo) WithPlaneAspect(y ImageAspectFlagBits) BindImagePlaneMemoryInfo {
	ptr := /* typedef */ (*C.VkImageAspectFlagBits)(&y)
	x.planeAspect = *ptr
	return x
}

//ImagePlaneMemoryRequirementsInfo provides a go interface for VkImagePlaneMemoryRequirementsInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImagePlaneMemoryRequirementsInfo.html
type ImagePlaneMemoryRequirementsInfo C.struct_VkImagePlaneMemoryRequirementsInfo

// SizeofImagePlaneMemoryRequirementsInfo is the memory size of a ImagePlaneMemoryRequirementsInfo
var SizeofImagePlaneMemoryRequirementsInfo int = int(unsafe.Sizeof(ImagePlaneMemoryRequirementsInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImagePlaneMemoryRequirementsInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImagePlaneMemoryRequirementsInfo) AsCPtr() *ImagePlaneMemoryRequirementsInfo {
	clone := (*ImagePlaneMemoryRequirementsInfo)(newCBlock(C.ulong(SizeofImagePlaneMemoryRequirementsInfo)))
	*clone = x
	return clone
}

// ImagePlaneMemoryRequirementsInfoFreeCSlice releases the memory allocated by ImagePlaneMemoryRequirementsInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ImagePlaneMemoryRequirementsInfoFreeCSlice(x []ImagePlaneMemoryRequirementsInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImagePlaneMemoryRequirementsInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImagePlaneMemoryRequirementsInfoFreeCSlice must be called on the returned slice.
func ImagePlaneMemoryRequirementsInfoMakeCSlice(x ...ImagePlaneMemoryRequirementsInfo) []ImagePlaneMemoryRequirementsInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImagePlaneMemoryRequirementsInfo * len(x)
	dst := unsafe.Slice((*ImagePlaneMemoryRequirementsInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImagePlaneMemoryRequirementsInfo
func (x ImagePlaneMemoryRequirementsInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ImagePlaneMemoryRequirementsInfo) WithDefaultSType() ImagePlaneMemoryRequirementsInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImagePlaneMemoryRequirementsInfo) WithSType(y StructureType) ImagePlaneMemoryRequirementsInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkImagePlaneMemoryRequirementsInfo
func (x ImagePlaneMemoryRequirementsInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImagePlaneMemoryRequirementsInfo) WithPNext(y unsafe.Pointer) ImagePlaneMemoryRequirementsInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// PlaneAspect returns the value of planeAspect from VkImagePlaneMemoryRequirementsInfo
func (x ImagePlaneMemoryRequirementsInfo) PlaneAspect() ImageAspectFlagBits {
	ptr := /* typedef */ (*ImageAspectFlagBits)(&x.planeAspect)
	return *ptr
}

// WithPlaneAspect sets the value for the PlaneAspect on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImagePlaneMemoryRequirementsInfo) WithPlaneAspect(y ImageAspectFlagBits) ImagePlaneMemoryRequirementsInfo {
	ptr := /* typedef */ (*C.VkImageAspectFlagBits)(&y)
	x.planeAspect = *ptr
	return x
}

//PhysicalDeviceSamplerYcbcrConversionFeatures provides a go interface for VkPhysicalDeviceSamplerYcbcrConversionFeatures.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceSamplerYcbcrConversionFeatures.html
type PhysicalDeviceSamplerYcbcrConversionFeatures C.struct_VkPhysicalDeviceSamplerYcbcrConversionFeatures

// SizeofPhysicalDeviceSamplerYcbcrConversionFeatures is the memory size of a PhysicalDeviceSamplerYcbcrConversionFeatures
var SizeofPhysicalDeviceSamplerYcbcrConversionFeatures int = int(unsafe.Sizeof(PhysicalDeviceSamplerYcbcrConversionFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceSamplerYcbcrConversionFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) AsCPtr() *PhysicalDeviceSamplerYcbcrConversionFeatures {
	clone := (*PhysicalDeviceSamplerYcbcrConversionFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceSamplerYcbcrConversionFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceSamplerYcbcrConversionFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceSamplerYcbcrConversionFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceSamplerYcbcrConversionFeaturesFreeCSlice(x []PhysicalDeviceSamplerYcbcrConversionFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceSamplerYcbcrConversionFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceSamplerYcbcrConversionFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceSamplerYcbcrConversionFeaturesMakeCSlice(x ...PhysicalDeviceSamplerYcbcrConversionFeatures) []PhysicalDeviceSamplerYcbcrConversionFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSamplerYcbcrConversionFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceSamplerYcbcrConversionFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceSamplerYcbcrConversionFeatures
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) WithDefaultSType() PhysicalDeviceSamplerYcbcrConversionFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) WithSType(y StructureType) PhysicalDeviceSamplerYcbcrConversionFeatures {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceSamplerYcbcrConversionFeatures
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceSamplerYcbcrConversionFeatures {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// SamplerYcbcrConversion returns the value of samplerYcbcrConversion from VkPhysicalDeviceSamplerYcbcrConversionFeatures
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) SamplerYcbcrConversion() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.samplerYcbcrConversion)
	return *ptr
}

// WithSamplerYcbcrConversion sets the value for the SamplerYcbcrConversion on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) WithSamplerYcbcrConversion(y Bool32) PhysicalDeviceSamplerYcbcrConversionFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.samplerYcbcrConversion = *ptr
	return x
}

//SamplerYcbcrConversionImageFormatProperties provides a go interface for VkSamplerYcbcrConversionImageFormatProperties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSamplerYcbcrConversionImageFormatProperties.html
type SamplerYcbcrConversionImageFormatProperties C.struct_VkSamplerYcbcrConversionImageFormatProperties

// SizeofSamplerYcbcrConversionImageFormatProperties is the memory size of a SamplerYcbcrConversionImageFormatProperties
var SizeofSamplerYcbcrConversionImageFormatProperties int = int(unsafe.Sizeof(SamplerYcbcrConversionImageFormatProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SamplerYcbcrConversionImageFormatProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SamplerYcbcrConversionImageFormatProperties) AsCPtr() *SamplerYcbcrConversionImageFormatProperties {
	clone := (*SamplerYcbcrConversionImageFormatProperties)(newCBlock(C.ulong(SizeofSamplerYcbcrConversionImageFormatProperties)))
	*clone = x
	return clone
}

// SamplerYcbcrConversionImageFormatPropertiesFreeCSlice releases the memory allocated by SamplerYcbcrConversionImageFormatPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func SamplerYcbcrConversionImageFormatPropertiesFreeCSlice(x []SamplerYcbcrConversionImageFormatProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SamplerYcbcrConversionImageFormatPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SamplerYcbcrConversionImageFormatPropertiesFreeCSlice must be called on the returned slice.
func SamplerYcbcrConversionImageFormatPropertiesMakeCSlice(x ...SamplerYcbcrConversionImageFormatProperties) []SamplerYcbcrConversionImageFormatProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSamplerYcbcrConversionImageFormatProperties * len(x)
	dst := unsafe.Slice((*SamplerYcbcrConversionImageFormatProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSamplerYcbcrConversionImageFormatProperties
func (x SamplerYcbcrConversionImageFormatProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SamplerYcbcrConversionImageFormatProperties) WithDefaultSType() SamplerYcbcrConversionImageFormatProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionImageFormatProperties) WithSType(y StructureType) SamplerYcbcrConversionImageFormatProperties {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkSamplerYcbcrConversionImageFormatProperties
func (x SamplerYcbcrConversionImageFormatProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionImageFormatProperties) WithPNext(y unsafe.Pointer) SamplerYcbcrConversionImageFormatProperties {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// CombinedImageSamplerDescriptorCount returns the value of combinedImageSamplerDescriptorCount from VkSamplerYcbcrConversionImageFormatProperties
func (x SamplerYcbcrConversionImageFormatProperties) CombinedImageSamplerDescriptorCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.combinedImageSamplerDescriptorCount)
	return *ptr
}

//ExternalSemaphoreProperties provides a go interface for VkExternalSemaphoreProperties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkExternalSemaphoreProperties.html
type ExternalSemaphoreProperties C.struct_VkExternalSemaphoreProperties

// SizeofExternalSemaphoreProperties is the memory size of a ExternalSemaphoreProperties
var SizeofExternalSemaphoreProperties int = int(unsafe.Sizeof(ExternalSemaphoreProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExternalSemaphoreProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExternalSemaphoreProperties) AsCPtr() *ExternalSemaphoreProperties {
	clone := (*ExternalSemaphoreProperties)(newCBlock(C.ulong(SizeofExternalSemaphoreProperties)))
	*clone = x
	return clone
}

// ExternalSemaphorePropertiesFreeCSlice releases the memory allocated by ExternalSemaphorePropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func ExternalSemaphorePropertiesFreeCSlice(x []ExternalSemaphoreProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExternalSemaphorePropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExternalSemaphorePropertiesFreeCSlice must be called on the returned slice.
func ExternalSemaphorePropertiesMakeCSlice(x ...ExternalSemaphoreProperties) []ExternalSemaphoreProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalSemaphoreProperties * len(x)
	dst := unsafe.Slice((*ExternalSemaphoreProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkExternalSemaphoreProperties
func (x ExternalSemaphoreProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ExternalSemaphoreProperties) WithDefaultSType() ExternalSemaphoreProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalSemaphoreProperties) WithSType(y StructureType) ExternalSemaphoreProperties {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkExternalSemaphoreProperties
func (x ExternalSemaphoreProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalSemaphoreProperties) WithPNext(y unsafe.Pointer) ExternalSemaphoreProperties {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// ExportFromImportedHandleTypes returns the value of exportFromImportedHandleTypes from VkExternalSemaphoreProperties
func (x ExternalSemaphoreProperties) ExportFromImportedHandleTypes() ExternalSemaphoreHandleTypeFlags {
	ptr := /* typedef */ (*ExternalSemaphoreHandleTypeFlags)(&x.exportFromImportedHandleTypes)
	return *ptr
}

// CompatibleHandleTypes returns the value of compatibleHandleTypes from VkExternalSemaphoreProperties
func (x ExternalSemaphoreProperties) CompatibleHandleTypes() ExternalSemaphoreHandleTypeFlags {
	ptr := /* typedef */ (*ExternalSemaphoreHandleTypeFlags)(&x.compatibleHandleTypes)
	return *ptr
}

// ExternalSemaphoreFeatures returns the value of externalSemaphoreFeatures from VkExternalSemaphoreProperties
func (x ExternalSemaphoreProperties) ExternalSemaphoreFeatures() ExternalSemaphoreFeatureFlags {
	ptr := /* typedef */ (*ExternalSemaphoreFeatureFlags)(&x.externalSemaphoreFeatures)
	return *ptr
}

//MemoryDedicatedAllocateInfo provides a go interface for VkMemoryDedicatedAllocateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkMemoryDedicatedAllocateInfo.html
type MemoryDedicatedAllocateInfo C.struct_VkMemoryDedicatedAllocateInfo

// SizeofMemoryDedicatedAllocateInfo is the memory size of a MemoryDedicatedAllocateInfo
var SizeofMemoryDedicatedAllocateInfo int = int(unsafe.Sizeof(MemoryDedicatedAllocateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryDedicatedAllocateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryDedicatedAllocateInfo) AsCPtr() *MemoryDedicatedAllocateInfo {
	clone := (*MemoryDedicatedAllocateInfo)(newCBlock(C.ulong(SizeofMemoryDedicatedAllocateInfo)))
	*clone = x
	return clone
}

// MemoryDedicatedAllocateInfoFreeCSlice releases the memory allocated by MemoryDedicatedAllocateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryDedicatedAllocateInfoFreeCSlice(x []MemoryDedicatedAllocateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryDedicatedAllocateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryDedicatedAllocateInfoFreeCSlice must be called on the returned slice.
func MemoryDedicatedAllocateInfoMakeCSlice(x ...MemoryDedicatedAllocateInfo) []MemoryDedicatedAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryDedicatedAllocateInfo * len(x)
	dst := unsafe.Slice((*MemoryDedicatedAllocateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkMemoryDedicatedAllocateInfo
func (x MemoryDedicatedAllocateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x MemoryDedicatedAllocateInfo) WithDefaultSType() MemoryDedicatedAllocateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryDedicatedAllocateInfo) WithSType(y StructureType) MemoryDedicatedAllocateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkMemoryDedicatedAllocateInfo
func (x MemoryDedicatedAllocateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryDedicatedAllocateInfo) WithPNext(y unsafe.Pointer) MemoryDedicatedAllocateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Image returns the value of image from VkMemoryDedicatedAllocateInfo
func (x MemoryDedicatedAllocateInfo) Image() Image {
	ptr := /* handle */ (*Image)(&x.image)
	return *ptr
}

// WithImage sets the value for the Image on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryDedicatedAllocateInfo) WithImage(y Image) MemoryDedicatedAllocateInfo {
	ptr := /* handle */ (*C.VkImage)(&y)
	x.image = *ptr
	return x
}

// Buffer returns the value of buffer from VkMemoryDedicatedAllocateInfo
func (x MemoryDedicatedAllocateInfo) Buffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.buffer)
	return *ptr
}

// WithBuffer sets the value for the Buffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryDedicatedAllocateInfo) WithBuffer(y Buffer) MemoryDedicatedAllocateInfo {
	ptr := /* handle */ (*C.VkBuffer)(&y)
	x.buffer = *ptr
	return x
}

//PhysicalDeviceVariablePointersFeatures provides a go interface for VkPhysicalDeviceVariablePointersFeatures.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVariablePointersFeatures.html
type PhysicalDeviceVariablePointersFeatures C.struct_VkPhysicalDeviceVariablePointersFeatures

// SizeofPhysicalDeviceVariablePointersFeatures is the memory size of a PhysicalDeviceVariablePointersFeatures
var SizeofPhysicalDeviceVariablePointersFeatures int = int(unsafe.Sizeof(PhysicalDeviceVariablePointersFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceVariablePointersFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceVariablePointersFeatures) AsCPtr() *PhysicalDeviceVariablePointersFeatures {
	clone := (*PhysicalDeviceVariablePointersFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceVariablePointersFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceVariablePointersFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceVariablePointersFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceVariablePointersFeaturesFreeCSlice(x []PhysicalDeviceVariablePointersFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceVariablePointersFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceVariablePointersFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceVariablePointersFeaturesMakeCSlice(x ...PhysicalDeviceVariablePointersFeatures) []PhysicalDeviceVariablePointersFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVariablePointersFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceVariablePointersFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceVariablePointersFeatures
func (x PhysicalDeviceVariablePointersFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceVariablePointersFeatures) WithDefaultSType() PhysicalDeviceVariablePointersFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVariablePointersFeatures) WithSType(y StructureType) PhysicalDeviceVariablePointersFeatures {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceVariablePointersFeatures
func (x PhysicalDeviceVariablePointersFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVariablePointersFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceVariablePointersFeatures {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// VariablePointersStorageBuffer returns the value of variablePointersStorageBuffer from VkPhysicalDeviceVariablePointersFeatures
func (x PhysicalDeviceVariablePointersFeatures) VariablePointersStorageBuffer() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.variablePointersStorageBuffer)
	return *ptr
}

// WithVariablePointersStorageBuffer sets the value for the VariablePointersStorageBuffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVariablePointersFeatures) WithVariablePointersStorageBuffer(y Bool32) PhysicalDeviceVariablePointersFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.variablePointersStorageBuffer = *ptr
	return x
}

// VariablePointers returns the value of variablePointers from VkPhysicalDeviceVariablePointersFeatures
func (x PhysicalDeviceVariablePointersFeatures) VariablePointers() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.variablePointers)
	return *ptr
}

// WithVariablePointers sets the value for the VariablePointers on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVariablePointersFeatures) WithVariablePointers(y Bool32) PhysicalDeviceVariablePointersFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.variablePointers = *ptr
	return x
}

//MemoryDedicatedRequirements provides a go interface for VkMemoryDedicatedRequirements.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkMemoryDedicatedRequirements.html
type MemoryDedicatedRequirements C.struct_VkMemoryDedicatedRequirements

// SizeofMemoryDedicatedRequirements is the memory size of a MemoryDedicatedRequirements
var SizeofMemoryDedicatedRequirements int = int(unsafe.Sizeof(MemoryDedicatedRequirements{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryDedicatedRequirements) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryDedicatedRequirements) AsCPtr() *MemoryDedicatedRequirements {
	clone := (*MemoryDedicatedRequirements)(newCBlock(C.ulong(SizeofMemoryDedicatedRequirements)))
	*clone = x
	return clone
}

// MemoryDedicatedRequirementsFreeCSlice releases the memory allocated by MemoryDedicatedRequirementsMakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryDedicatedRequirementsFreeCSlice(x []MemoryDedicatedRequirements) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryDedicatedRequirementsMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryDedicatedRequirementsFreeCSlice must be called on the returned slice.
func MemoryDedicatedRequirementsMakeCSlice(x ...MemoryDedicatedRequirements) []MemoryDedicatedRequirements {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryDedicatedRequirements * len(x)
	dst := unsafe.Slice((*MemoryDedicatedRequirements)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkMemoryDedicatedRequirements
func (x MemoryDedicatedRequirements) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x MemoryDedicatedRequirements) WithDefaultSType() MemoryDedicatedRequirements {
	return x.WithSType(VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryDedicatedRequirements) WithSType(y StructureType) MemoryDedicatedRequirements {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkMemoryDedicatedRequirements
func (x MemoryDedicatedRequirements) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryDedicatedRequirements) WithPNext(y unsafe.Pointer) MemoryDedicatedRequirements {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// PrefersDedicatedAllocation returns the value of prefersDedicatedAllocation from VkMemoryDedicatedRequirements
func (x MemoryDedicatedRequirements) PrefersDedicatedAllocation() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.prefersDedicatedAllocation)
	return *ptr
}

// RequiresDedicatedAllocation returns the value of requiresDedicatedAllocation from VkMemoryDedicatedRequirements
func (x MemoryDedicatedRequirements) RequiresDedicatedAllocation() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.requiresDedicatedAllocation)
	return *ptr
}

//ExternalMemoryBufferCreateInfo provides a go interface for VkExternalMemoryBufferCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkExternalMemoryBufferCreateInfo.html
type ExternalMemoryBufferCreateInfo C.struct_VkExternalMemoryBufferCreateInfo

// SizeofExternalMemoryBufferCreateInfo is the memory size of a ExternalMemoryBufferCreateInfo
var SizeofExternalMemoryBufferCreateInfo int = int(unsafe.Sizeof(ExternalMemoryBufferCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExternalMemoryBufferCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExternalMemoryBufferCreateInfo) AsCPtr() *ExternalMemoryBufferCreateInfo {
	clone := (*ExternalMemoryBufferCreateInfo)(newCBlock(C.ulong(SizeofExternalMemoryBufferCreateInfo)))
	*clone = x
	return clone
}

// ExternalMemoryBufferCreateInfoFreeCSlice releases the memory allocated by ExternalMemoryBufferCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ExternalMemoryBufferCreateInfoFreeCSlice(x []ExternalMemoryBufferCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExternalMemoryBufferCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExternalMemoryBufferCreateInfoFreeCSlice must be called on the returned slice.
func ExternalMemoryBufferCreateInfoMakeCSlice(x ...ExternalMemoryBufferCreateInfo) []ExternalMemoryBufferCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalMemoryBufferCreateInfo * len(x)
	dst := unsafe.Slice((*ExternalMemoryBufferCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkExternalMemoryBufferCreateInfo
func (x ExternalMemoryBufferCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ExternalMemoryBufferCreateInfo) WithDefaultSType() ExternalMemoryBufferCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalMemoryBufferCreateInfo) WithSType(y StructureType) ExternalMemoryBufferCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkExternalMemoryBufferCreateInfo
func (x ExternalMemoryBufferCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalMemoryBufferCreateInfo) WithPNext(y unsafe.Pointer) ExternalMemoryBufferCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// HandleTypes returns the value of handleTypes from VkExternalMemoryBufferCreateInfo
func (x ExternalMemoryBufferCreateInfo) HandleTypes() ExternalMemoryHandleTypeFlags {
	ptr := /* typedef */ (*ExternalMemoryHandleTypeFlags)(&x.handleTypes)
	return *ptr
}

// WithHandleTypes sets the value for the HandleTypes on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalMemoryBufferCreateInfo) WithHandleTypes(y ExternalMemoryHandleTypeFlags) ExternalMemoryBufferCreateInfo {
	ptr := /* typedef */ (*C.VkExternalMemoryHandleTypeFlags)(&y)
	x.handleTypes = *ptr
	return x
}

//ExternalMemoryImageCreateInfo provides a go interface for VkExternalMemoryImageCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkExternalMemoryImageCreateInfo.html
type ExternalMemoryImageCreateInfo C.struct_VkExternalMemoryImageCreateInfo

// SizeofExternalMemoryImageCreateInfo is the memory size of a ExternalMemoryImageCreateInfo
var SizeofExternalMemoryImageCreateInfo int = int(unsafe.Sizeof(ExternalMemoryImageCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExternalMemoryImageCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExternalMemoryImageCreateInfo) AsCPtr() *ExternalMemoryImageCreateInfo {
	clone := (*ExternalMemoryImageCreateInfo)(newCBlock(C.ulong(SizeofExternalMemoryImageCreateInfo)))
	*clone = x
	return clone
}

// ExternalMemoryImageCreateInfoFreeCSlice releases the memory allocated by ExternalMemoryImageCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ExternalMemoryImageCreateInfoFreeCSlice(x []ExternalMemoryImageCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExternalMemoryImageCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExternalMemoryImageCreateInfoFreeCSlice must be called on the returned slice.
func ExternalMemoryImageCreateInfoMakeCSlice(x ...ExternalMemoryImageCreateInfo) []ExternalMemoryImageCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalMemoryImageCreateInfo * len(x)
	dst := unsafe.Slice((*ExternalMemoryImageCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkExternalMemoryImageCreateInfo
func (x ExternalMemoryImageCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ExternalMemoryImageCreateInfo) WithDefaultSType() ExternalMemoryImageCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalMemoryImageCreateInfo) WithSType(y StructureType) ExternalMemoryImageCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkExternalMemoryImageCreateInfo
func (x ExternalMemoryImageCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalMemoryImageCreateInfo) WithPNext(y unsafe.Pointer) ExternalMemoryImageCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// HandleTypes returns the value of handleTypes from VkExternalMemoryImageCreateInfo
func (x ExternalMemoryImageCreateInfo) HandleTypes() ExternalMemoryHandleTypeFlags {
	ptr := /* typedef */ (*ExternalMemoryHandleTypeFlags)(&x.handleTypes)
	return *ptr
}

// WithHandleTypes sets the value for the HandleTypes on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalMemoryImageCreateInfo) WithHandleTypes(y ExternalMemoryHandleTypeFlags) ExternalMemoryImageCreateInfo {
	ptr := /* typedef */ (*C.VkExternalMemoryHandleTypeFlags)(&y)
	x.handleTypes = *ptr
	return x
}

//PhysicalDeviceIDProperties provides a go interface for VkPhysicalDeviceIDProperties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceIDProperties.html
type PhysicalDeviceIDProperties C.struct_VkPhysicalDeviceIDProperties

// SizeofPhysicalDeviceIDProperties is the memory size of a PhysicalDeviceIDProperties
var SizeofPhysicalDeviceIDProperties int = int(unsafe.Sizeof(PhysicalDeviceIDProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceIDProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceIDProperties) AsCPtr() *PhysicalDeviceIDProperties {
	clone := (*PhysicalDeviceIDProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceIDProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceIDPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceIDPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceIDPropertiesFreeCSlice(x []PhysicalDeviceIDProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceIDPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceIDPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceIDPropertiesMakeCSlice(x ...PhysicalDeviceIDProperties) []PhysicalDeviceIDProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceIDProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceIDProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceIDProperties
func (x PhysicalDeviceIDProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceIDProperties) WithDefaultSType() PhysicalDeviceIDProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceIDProperties) WithSType(y StructureType) PhysicalDeviceIDProperties {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceIDProperties
func (x PhysicalDeviceIDProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceIDProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceIDProperties {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// DeviceUUID returns the value of deviceUUID from VkPhysicalDeviceIDProperties
func (x PhysicalDeviceIDProperties) DeviceUUID() []byte {
	ptr := func(x *[VK_UUID_SIZE]C.uchar) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_UUID_SIZE)
		return &slc
	}(&x.deviceUUID)
	return *ptr
}

// DriverUUID returns the value of driverUUID from VkPhysicalDeviceIDProperties
func (x PhysicalDeviceIDProperties) DriverUUID() []byte {
	ptr := func(x *[VK_UUID_SIZE]C.uchar) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_UUID_SIZE)
		return &slc
	}(&x.driverUUID)
	return *ptr
}

// DeviceLUID returns the value of deviceLUID from VkPhysicalDeviceIDProperties
func (x PhysicalDeviceIDProperties) DeviceLUID() []byte {
	ptr := func(x *[VK_LUID_SIZE]C.uchar) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_LUID_SIZE)
		return &slc
	}(&x.deviceLUID)
	return *ptr
}

// DeviceNodeMask returns the value of deviceNodeMask from VkPhysicalDeviceIDProperties
func (x PhysicalDeviceIDProperties) DeviceNodeMask() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.deviceNodeMask)
	return *ptr
}

// DeviceLUIDValid returns the value of deviceLUIDValid from VkPhysicalDeviceIDProperties
func (x PhysicalDeviceIDProperties) DeviceLUIDValid() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.deviceLUIDValid)
	return *ptr
}

//PhysicalDevice16BitStorageFeatures provides a go interface for VkPhysicalDevice16BitStorageFeatures.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevice16BitStorageFeatures.html
type PhysicalDevice16BitStorageFeatures C.struct_VkPhysicalDevice16BitStorageFeatures

// SizeofPhysicalDevice16BitStorageFeatures is the memory size of a PhysicalDevice16BitStorageFeatures
var SizeofPhysicalDevice16BitStorageFeatures int = int(unsafe.Sizeof(PhysicalDevice16BitStorageFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDevice16BitStorageFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDevice16BitStorageFeatures) AsCPtr() *PhysicalDevice16BitStorageFeatures {
	clone := (*PhysicalDevice16BitStorageFeatures)(newCBlock(C.ulong(SizeofPhysicalDevice16BitStorageFeatures)))
	*clone = x
	return clone
}

// PhysicalDevice16BitStorageFeaturesFreeCSlice releases the memory allocated by PhysicalDevice16BitStorageFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDevice16BitStorageFeaturesFreeCSlice(x []PhysicalDevice16BitStorageFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDevice16BitStorageFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDevice16BitStorageFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDevice16BitStorageFeaturesMakeCSlice(x ...PhysicalDevice16BitStorageFeatures) []PhysicalDevice16BitStorageFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDevice16BitStorageFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDevice16BitStorageFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDevice16BitStorageFeatures
func (x PhysicalDevice16BitStorageFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDevice16BitStorageFeatures) WithDefaultSType() PhysicalDevice16BitStorageFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice16BitStorageFeatures) WithSType(y StructureType) PhysicalDevice16BitStorageFeatures {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDevice16BitStorageFeatures
func (x PhysicalDevice16BitStorageFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice16BitStorageFeatures) WithPNext(y unsafe.Pointer) PhysicalDevice16BitStorageFeatures {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// StorageBuffer16BitAccess returns the value of storageBuffer16BitAccess from VkPhysicalDevice16BitStorageFeatures
func (x PhysicalDevice16BitStorageFeatures) StorageBuffer16BitAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storageBuffer16BitAccess)
	return *ptr
}

// WithStorageBuffer16BitAccess sets the value for the StorageBuffer16BitAccess on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice16BitStorageFeatures) WithStorageBuffer16BitAccess(y Bool32) PhysicalDevice16BitStorageFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.storageBuffer16BitAccess = *ptr
	return x
}

// UniformAndStorageBuffer16BitAccess returns the value of uniformAndStorageBuffer16BitAccess from VkPhysicalDevice16BitStorageFeatures
func (x PhysicalDevice16BitStorageFeatures) UniformAndStorageBuffer16BitAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.uniformAndStorageBuffer16BitAccess)
	return *ptr
}

// WithUniformAndStorageBuffer16BitAccess sets the value for the UniformAndStorageBuffer16BitAccess on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice16BitStorageFeatures) WithUniformAndStorageBuffer16BitAccess(y Bool32) PhysicalDevice16BitStorageFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.uniformAndStorageBuffer16BitAccess = *ptr
	return x
}

// StoragePushConstant16 returns the value of storagePushConstant16 from VkPhysicalDevice16BitStorageFeatures
func (x PhysicalDevice16BitStorageFeatures) StoragePushConstant16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storagePushConstant16)
	return *ptr
}

// WithStoragePushConstant16 sets the value for the StoragePushConstant16 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice16BitStorageFeatures) WithStoragePushConstant16(y Bool32) PhysicalDevice16BitStorageFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.storagePushConstant16 = *ptr
	return x
}

// StorageInputOutput16 returns the value of storageInputOutput16 from VkPhysicalDevice16BitStorageFeatures
func (x PhysicalDevice16BitStorageFeatures) StorageInputOutput16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storageInputOutput16)
	return *ptr
}

// WithStorageInputOutput16 sets the value for the StorageInputOutput16 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice16BitStorageFeatures) WithStorageInputOutput16(y Bool32) PhysicalDevice16BitStorageFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.storageInputOutput16 = *ptr
	return x
}

//BindImageMemoryInfo provides a go interface for VkBindImageMemoryInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBindImageMemoryInfo.html
type BindImageMemoryInfo C.struct_VkBindImageMemoryInfo

// SizeofBindImageMemoryInfo is the memory size of a BindImageMemoryInfo
var SizeofBindImageMemoryInfo int = int(unsafe.Sizeof(BindImageMemoryInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BindImageMemoryInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BindImageMemoryInfo) AsCPtr() *BindImageMemoryInfo {
	clone := (*BindImageMemoryInfo)(newCBlock(C.ulong(SizeofBindImageMemoryInfo)))
	*clone = x
	return clone
}

// BindImageMemoryInfoFreeCSlice releases the memory allocated by BindImageMemoryInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BindImageMemoryInfoFreeCSlice(x []BindImageMemoryInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BindImageMemoryInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BindImageMemoryInfoFreeCSlice must be called on the returned slice.
func BindImageMemoryInfoMakeCSlice(x ...BindImageMemoryInfo) []BindImageMemoryInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindImageMemoryInfo * len(x)
	dst := unsafe.Slice((*BindImageMemoryInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBindImageMemoryInfo
func (x BindImageMemoryInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BindImageMemoryInfo) WithDefaultSType() BindImageMemoryInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemoryInfo) WithSType(y StructureType) BindImageMemoryInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkBindImageMemoryInfo
func (x BindImageMemoryInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemoryInfo) WithPNext(y unsafe.Pointer) BindImageMemoryInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Image returns the value of image from VkBindImageMemoryInfo
func (x BindImageMemoryInfo) Image() Image {
	ptr := /* handle */ (*Image)(&x.image)
	return *ptr
}

// WithImage sets the value for the Image on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemoryInfo) WithImage(y Image) BindImageMemoryInfo {
	ptr := /* handle */ (*C.VkImage)(&y)
	x.image = *ptr
	return x
}

// Memory returns the value of memory from VkBindImageMemoryInfo
func (x BindImageMemoryInfo) Memory() DeviceMemory {
	ptr := /* handle */ (*DeviceMemory)(&x.memory)
	return *ptr
}

// WithMemory sets the value for the Memory on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemoryInfo) WithMemory(y DeviceMemory) BindImageMemoryInfo {
	ptr := /* handle */ (*C.VkDeviceMemory)(&y)
	x.memory = *ptr
	return x
}

// MemoryOffset returns the value of memoryOffset from VkBindImageMemoryInfo
func (x BindImageMemoryInfo) MemoryOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.memoryOffset)
	return *ptr
}

// WithMemoryOffset sets the value for the MemoryOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemoryInfo) WithMemoryOffset(y DeviceSize) BindImageMemoryInfo {
	ptr := /* typedef */ (*C.VkDeviceSize)(&y)
	x.memoryOffset = *ptr
	return x
}

//BindBufferMemoryInfo provides a go interface for VkBindBufferMemoryInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBindBufferMemoryInfo.html
type BindBufferMemoryInfo C.struct_VkBindBufferMemoryInfo

// SizeofBindBufferMemoryInfo is the memory size of a BindBufferMemoryInfo
var SizeofBindBufferMemoryInfo int = int(unsafe.Sizeof(BindBufferMemoryInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BindBufferMemoryInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BindBufferMemoryInfo) AsCPtr() *BindBufferMemoryInfo {
	clone := (*BindBufferMemoryInfo)(newCBlock(C.ulong(SizeofBindBufferMemoryInfo)))
	*clone = x
	return clone
}

// BindBufferMemoryInfoFreeCSlice releases the memory allocated by BindBufferMemoryInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BindBufferMemoryInfoFreeCSlice(x []BindBufferMemoryInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BindBufferMemoryInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BindBufferMemoryInfoFreeCSlice must be called on the returned slice.
func BindBufferMemoryInfoMakeCSlice(x ...BindBufferMemoryInfo) []BindBufferMemoryInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindBufferMemoryInfo * len(x)
	dst := unsafe.Slice((*BindBufferMemoryInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBindBufferMemoryInfo
func (x BindBufferMemoryInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BindBufferMemoryInfo) WithDefaultSType() BindBufferMemoryInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindBufferMemoryInfo) WithSType(y StructureType) BindBufferMemoryInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkBindBufferMemoryInfo
func (x BindBufferMemoryInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindBufferMemoryInfo) WithPNext(y unsafe.Pointer) BindBufferMemoryInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Buffer returns the value of buffer from VkBindBufferMemoryInfo
func (x BindBufferMemoryInfo) Buffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.buffer)
	return *ptr
}

// WithBuffer sets the value for the Buffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindBufferMemoryInfo) WithBuffer(y Buffer) BindBufferMemoryInfo {
	ptr := /* handle */ (*C.VkBuffer)(&y)
	x.buffer = *ptr
	return x
}

// Memory returns the value of memory from VkBindBufferMemoryInfo
func (x BindBufferMemoryInfo) Memory() DeviceMemory {
	ptr := /* handle */ (*DeviceMemory)(&x.memory)
	return *ptr
}

// WithMemory sets the value for the Memory on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindBufferMemoryInfo) WithMemory(y DeviceMemory) BindBufferMemoryInfo {
	ptr := /* handle */ (*C.VkDeviceMemory)(&y)
	x.memory = *ptr
	return x
}

// MemoryOffset returns the value of memoryOffset from VkBindBufferMemoryInfo
func (x BindBufferMemoryInfo) MemoryOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.memoryOffset)
	return *ptr
}

// WithMemoryOffset sets the value for the MemoryOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindBufferMemoryInfo) WithMemoryOffset(y DeviceSize) BindBufferMemoryInfo {
	ptr := /* typedef */ (*C.VkDeviceSize)(&y)
	x.memoryOffset = *ptr
	return x
}

//DescriptorUpdateTemplateEntry provides a go interface for VkDescriptorUpdateTemplateEntry.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorUpdateTemplateEntry.html
type DescriptorUpdateTemplateEntry C.struct_VkDescriptorUpdateTemplateEntry

// SizeofDescriptorUpdateTemplateEntry is the memory size of a DescriptorUpdateTemplateEntry
var SizeofDescriptorUpdateTemplateEntry int = int(unsafe.Sizeof(DescriptorUpdateTemplateEntry{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorUpdateTemplateEntry) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorUpdateTemplateEntry) AsCPtr() *DescriptorUpdateTemplateEntry {
	clone := (*DescriptorUpdateTemplateEntry)(newCBlock(C.ulong(SizeofDescriptorUpdateTemplateEntry)))
	*clone = x
	return clone
}

// DescriptorUpdateTemplateEntryFreeCSlice releases the memory allocated by DescriptorUpdateTemplateEntryMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorUpdateTemplateEntryFreeCSlice(x []DescriptorUpdateTemplateEntry) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorUpdateTemplateEntryMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorUpdateTemplateEntryFreeCSlice must be called on the returned slice.
func DescriptorUpdateTemplateEntryMakeCSlice(x ...DescriptorUpdateTemplateEntry) []DescriptorUpdateTemplateEntry {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorUpdateTemplateEntry * len(x)
	dst := unsafe.Slice((*DescriptorUpdateTemplateEntry)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// DstBinding returns the value of dstBinding from VkDescriptorUpdateTemplateEntry
func (x DescriptorUpdateTemplateEntry) DstBinding() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.dstBinding)
	return *ptr
}

// WithDstBinding sets the value for the DstBinding on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateEntry) WithDstBinding(y uint32) DescriptorUpdateTemplateEntry {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.dstBinding = *ptr
	return x
}

// DstArrayElement returns the value of dstArrayElement from VkDescriptorUpdateTemplateEntry
func (x DescriptorUpdateTemplateEntry) DstArrayElement() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.dstArrayElement)
	return *ptr
}

// WithDstArrayElement sets the value for the DstArrayElement on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateEntry) WithDstArrayElement(y uint32) DescriptorUpdateTemplateEntry {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.dstArrayElement = *ptr
	return x
}

// DescriptorCount returns the value of descriptorCount from VkDescriptorUpdateTemplateEntry
func (x DescriptorUpdateTemplateEntry) DescriptorCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.descriptorCount)
	return *ptr
}

// WithDescriptorCount sets the value for the DescriptorCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateEntry) WithDescriptorCount(y uint32) DescriptorUpdateTemplateEntry {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.descriptorCount = *ptr
	return x
}

// DescriptorType returns the value of descriptorType from VkDescriptorUpdateTemplateEntry
func (x DescriptorUpdateTemplateEntry) DescriptorType() DescriptorType {
	ptr := /* typedef */ (*DescriptorType)(&x.descriptorType)
	return *ptr
}

// WithDescriptorType sets the value for the DescriptorType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateEntry) WithDescriptorType(y DescriptorType) DescriptorUpdateTemplateEntry {
	ptr := /* typedef */ (*C.VkDescriptorType)(&y)
	x.descriptorType = *ptr
	return x
}

// Offset returns the value of offset from VkDescriptorUpdateTemplateEntry
func (x DescriptorUpdateTemplateEntry) Offset() uint64 {
	ptr := func(x *C.ulong) *uint64 { /* Scalar */ return (*uint64)(unsafe.Pointer(x)) }(&x.offset)
	return *ptr
}

// WithOffset sets the value for the Offset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateEntry) WithOffset(y uint64) DescriptorUpdateTemplateEntry {
	ptr := func(x *uint64) *C.ulong { /* Scalar */ return (*C.ulong)(unsafe.Pointer(x)) }(&y)
	x.offset = *ptr
	return x
}

// Stride returns the value of stride from VkDescriptorUpdateTemplateEntry
func (x DescriptorUpdateTemplateEntry) Stride() uint64 {
	ptr := func(x *C.ulong) *uint64 { /* Scalar */ return (*uint64)(unsafe.Pointer(x)) }(&x.stride)
	return *ptr
}

// WithStride sets the value for the Stride on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateEntry) WithStride(y uint64) DescriptorUpdateTemplateEntry {
	ptr := func(x *uint64) *C.ulong { /* Scalar */ return (*C.ulong)(unsafe.Pointer(x)) }(&y)
	x.stride = *ptr
	return x
}

//DescriptorUpdateTemplateCreateInfo provides a go interface for VkDescriptorUpdateTemplateCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorUpdateTemplateCreateInfo.html
type DescriptorUpdateTemplateCreateInfo C.struct_VkDescriptorUpdateTemplateCreateInfo

// SizeofDescriptorUpdateTemplateCreateInfo is the memory size of a DescriptorUpdateTemplateCreateInfo
var SizeofDescriptorUpdateTemplateCreateInfo int = int(unsafe.Sizeof(DescriptorUpdateTemplateCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorUpdateTemplateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorUpdateTemplateCreateInfo) AsCPtr() *DescriptorUpdateTemplateCreateInfo {
	clone := (*DescriptorUpdateTemplateCreateInfo)(newCBlock(C.ulong(SizeofDescriptorUpdateTemplateCreateInfo)))
	*clone = x
	return clone
}

// DescriptorUpdateTemplateCreateInfoFreeCSlice releases the memory allocated by DescriptorUpdateTemplateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorUpdateTemplateCreateInfoFreeCSlice(x []DescriptorUpdateTemplateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorUpdateTemplateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorUpdateTemplateCreateInfoFreeCSlice must be called on the returned slice.
func DescriptorUpdateTemplateCreateInfoMakeCSlice(x ...DescriptorUpdateTemplateCreateInfo) []DescriptorUpdateTemplateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorUpdateTemplateCreateInfo * len(x)
	dst := unsafe.Slice((*DescriptorUpdateTemplateCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DescriptorUpdateTemplateCreateInfo) WithDefaultSType() DescriptorUpdateTemplateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateCreateInfo) WithSType(y StructureType) DescriptorUpdateTemplateCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateCreateInfo) WithPNext(y unsafe.Pointer) DescriptorUpdateTemplateCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) Flags() DescriptorUpdateTemplateCreateFlags {
	ptr := /* typedef */ (*DescriptorUpdateTemplateCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateCreateInfo) WithFlags(y DescriptorUpdateTemplateCreateFlags) DescriptorUpdateTemplateCreateInfo {
	ptr := /* typedef */ (*C.VkDescriptorUpdateTemplateCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// DescriptorUpdateEntryCount returns the value of descriptorUpdateEntryCount from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) DescriptorUpdateEntryCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.descriptorUpdateEntryCount)
	return *ptr
}

// WithDescriptorUpdateEntryCount sets the value for the DescriptorUpdateEntryCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateCreateInfo) WithDescriptorUpdateEntryCount(y uint32) DescriptorUpdateTemplateCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.descriptorUpdateEntryCount = *ptr
	return x
}

// PDescriptorUpdateEntries returns the value of pDescriptorUpdateEntries from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) PDescriptorUpdateEntries() []DescriptorUpdateTemplateEntry {
	ptr := func(x **C.struct_VkDescriptorUpdateTemplateEntry) *[]DescriptorUpdateTemplateEntry { /* Slice */
		slc := unsafe.Slice((*DescriptorUpdateTemplateEntry)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pDescriptorUpdateEntries)
	return *ptr
}

// WithPDescriptorUpdateEntries sets the value for the PDescriptorUpdateEntries on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DescriptorUpdateEntryCount as the length of this field.
// DescriptorUpdateEntryCount is updated with the length of the new value.
func (x DescriptorUpdateTemplateCreateInfo) WithPDescriptorUpdateEntries(y []DescriptorUpdateTemplateEntry) DescriptorUpdateTemplateCreateInfo {
	ptr := func(x *[]DescriptorUpdateTemplateEntry) **C.struct_VkDescriptorUpdateTemplateEntry { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDescriptorUpdateTemplateEntry)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDescriptorUpdateTemplateEntry)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pDescriptorUpdateEntries = *ptr
	return x.WithDescriptorUpdateEntryCount(uint32(len(y)))
}

// TemplateType returns the value of templateType from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) TemplateType() DescriptorUpdateTemplateType {
	ptr := /* typedef */ (*DescriptorUpdateTemplateType)(&x.templateType)
	return *ptr
}

// WithTemplateType sets the value for the TemplateType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateCreateInfo) WithTemplateType(y DescriptorUpdateTemplateType) DescriptorUpdateTemplateCreateInfo {
	ptr := /* typedef */ (*C.VkDescriptorUpdateTemplateType)(&y)
	x.templateType = *ptr
	return x
}

// DescriptorSetLayout returns the value of descriptorSetLayout from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) DescriptorSetLayout() DescriptorSetLayout {
	ptr := /* handle */ (*DescriptorSetLayout)(&x.descriptorSetLayout)
	return *ptr
}

// WithDescriptorSetLayout sets the value for the DescriptorSetLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateCreateInfo) WithDescriptorSetLayout(y DescriptorSetLayout) DescriptorUpdateTemplateCreateInfo {
	ptr := /* handle */ (*C.VkDescriptorSetLayout)(&y)
	x.descriptorSetLayout = *ptr
	return x
}

// PipelineBindPoint returns the value of pipelineBindPoint from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) PipelineBindPoint() PipelineBindPoint {
	ptr := /* typedef */ (*PipelineBindPoint)(&x.pipelineBindPoint)
	return *ptr
}

// WithPipelineBindPoint sets the value for the PipelineBindPoint on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateCreateInfo) WithPipelineBindPoint(y PipelineBindPoint) DescriptorUpdateTemplateCreateInfo {
	ptr := /* typedef */ (*C.VkPipelineBindPoint)(&y)
	x.pipelineBindPoint = *ptr
	return x
}

// PipelineLayout returns the value of pipelineLayout from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) PipelineLayout() PipelineLayout {
	ptr := /* handle */ (*PipelineLayout)(&x.pipelineLayout)
	return *ptr
}

// WithPipelineLayout sets the value for the PipelineLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateCreateInfo) WithPipelineLayout(y PipelineLayout) DescriptorUpdateTemplateCreateInfo {
	ptr := /* handle */ (*C.VkPipelineLayout)(&y)
	x.pipelineLayout = *ptr
	return x
}

// Set returns the value of set from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) Set() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.set)
	return *ptr
}

// WithSet sets the value for the Set on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateCreateInfo) WithSet(y uint32) DescriptorUpdateTemplateCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.set = *ptr
	return x
}

//ExternalBufferProperties provides a go interface for VkExternalBufferProperties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkExternalBufferProperties.html
type ExternalBufferProperties C.struct_VkExternalBufferProperties

// SizeofExternalBufferProperties is the memory size of a ExternalBufferProperties
var SizeofExternalBufferProperties int = int(unsafe.Sizeof(ExternalBufferProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExternalBufferProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExternalBufferProperties) AsCPtr() *ExternalBufferProperties {
	clone := (*ExternalBufferProperties)(newCBlock(C.ulong(SizeofExternalBufferProperties)))
	*clone = x
	return clone
}

// ExternalBufferPropertiesFreeCSlice releases the memory allocated by ExternalBufferPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func ExternalBufferPropertiesFreeCSlice(x []ExternalBufferProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExternalBufferPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExternalBufferPropertiesFreeCSlice must be called on the returned slice.
func ExternalBufferPropertiesMakeCSlice(x ...ExternalBufferProperties) []ExternalBufferProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalBufferProperties * len(x)
	dst := unsafe.Slice((*ExternalBufferProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkExternalBufferProperties
func (x ExternalBufferProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ExternalBufferProperties) WithDefaultSType() ExternalBufferProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalBufferProperties) WithSType(y StructureType) ExternalBufferProperties {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkExternalBufferProperties
func (x ExternalBufferProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalBufferProperties) WithPNext(y unsafe.Pointer) ExternalBufferProperties {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// ExternalMemoryProperties returns the value of externalMemoryProperties from VkExternalBufferProperties
func (x ExternalBufferProperties) ExternalMemoryProperties() ExternalMemoryProperties {
	ptr := /* typedef */ (*ExternalMemoryProperties)(&x.externalMemoryProperties)
	return *ptr
}

//PhysicalDeviceMaintenance3Properties provides a go interface for VkPhysicalDeviceMaintenance3Properties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceMaintenance3Properties.html
type PhysicalDeviceMaintenance3Properties C.struct_VkPhysicalDeviceMaintenance3Properties

// SizeofPhysicalDeviceMaintenance3Properties is the memory size of a PhysicalDeviceMaintenance3Properties
var SizeofPhysicalDeviceMaintenance3Properties int = int(unsafe.Sizeof(PhysicalDeviceMaintenance3Properties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceMaintenance3Properties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceMaintenance3Properties) AsCPtr() *PhysicalDeviceMaintenance3Properties {
	clone := (*PhysicalDeviceMaintenance3Properties)(newCBlock(C.ulong(SizeofPhysicalDeviceMaintenance3Properties)))
	*clone = x
	return clone
}

// PhysicalDeviceMaintenance3PropertiesFreeCSlice releases the memory allocated by PhysicalDeviceMaintenance3PropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceMaintenance3PropertiesFreeCSlice(x []PhysicalDeviceMaintenance3Properties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceMaintenance3PropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceMaintenance3PropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceMaintenance3PropertiesMakeCSlice(x ...PhysicalDeviceMaintenance3Properties) []PhysicalDeviceMaintenance3Properties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceMaintenance3Properties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceMaintenance3Properties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceMaintenance3Properties
func (x PhysicalDeviceMaintenance3Properties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceMaintenance3Properties) WithDefaultSType() PhysicalDeviceMaintenance3Properties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMaintenance3Properties) WithSType(y StructureType) PhysicalDeviceMaintenance3Properties {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceMaintenance3Properties
func (x PhysicalDeviceMaintenance3Properties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMaintenance3Properties) WithPNext(y unsafe.Pointer) PhysicalDeviceMaintenance3Properties {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// MaxPerSetDescriptors returns the value of maxPerSetDescriptors from VkPhysicalDeviceMaintenance3Properties
func (x PhysicalDeviceMaintenance3Properties) MaxPerSetDescriptors() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxPerSetDescriptors)
	return *ptr
}

// MaxMemoryAllocationSize returns the value of maxMemoryAllocationSize from VkPhysicalDeviceMaintenance3Properties
func (x PhysicalDeviceMaintenance3Properties) MaxMemoryAllocationSize() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.maxMemoryAllocationSize)
	return *ptr
}

//DescriptorSetLayoutSupport provides a go interface for VkDescriptorSetLayoutSupport.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorSetLayoutSupport.html
type DescriptorSetLayoutSupport C.struct_VkDescriptorSetLayoutSupport

// SizeofDescriptorSetLayoutSupport is the memory size of a DescriptorSetLayoutSupport
var SizeofDescriptorSetLayoutSupport int = int(unsafe.Sizeof(DescriptorSetLayoutSupport{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorSetLayoutSupport) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorSetLayoutSupport) AsCPtr() *DescriptorSetLayoutSupport {
	clone := (*DescriptorSetLayoutSupport)(newCBlock(C.ulong(SizeofDescriptorSetLayoutSupport)))
	*clone = x
	return clone
}

// DescriptorSetLayoutSupportFreeCSlice releases the memory allocated by DescriptorSetLayoutSupportMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorSetLayoutSupportFreeCSlice(x []DescriptorSetLayoutSupport) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorSetLayoutSupportMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorSetLayoutSupportFreeCSlice must be called on the returned slice.
func DescriptorSetLayoutSupportMakeCSlice(x ...DescriptorSetLayoutSupport) []DescriptorSetLayoutSupport {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetLayoutSupport * len(x)
	dst := unsafe.Slice((*DescriptorSetLayoutSupport)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDescriptorSetLayoutSupport
func (x DescriptorSetLayoutSupport) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DescriptorSetLayoutSupport) WithDefaultSType() DescriptorSetLayoutSupport {
	return x.WithSType(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutSupport) WithSType(y StructureType) DescriptorSetLayoutSupport {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDescriptorSetLayoutSupport
func (x DescriptorSetLayoutSupport) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutSupport) WithPNext(y unsafe.Pointer) DescriptorSetLayoutSupport {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Supported returns the value of supported from VkDescriptorSetLayoutSupport
func (x DescriptorSetLayoutSupport) Supported() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.supported)
	return *ptr
}

//PhysicalDeviceSubgroupProperties provides a go interface for VkPhysicalDeviceSubgroupProperties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceSubgroupProperties.html
type PhysicalDeviceSubgroupProperties C.struct_VkPhysicalDeviceSubgroupProperties

// SizeofPhysicalDeviceSubgroupProperties is the memory size of a PhysicalDeviceSubgroupProperties
var SizeofPhysicalDeviceSubgroupProperties int = int(unsafe.Sizeof(PhysicalDeviceSubgroupProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceSubgroupProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceSubgroupProperties) AsCPtr() *PhysicalDeviceSubgroupProperties {
	clone := (*PhysicalDeviceSubgroupProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceSubgroupProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceSubgroupPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceSubgroupPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceSubgroupPropertiesFreeCSlice(x []PhysicalDeviceSubgroupProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceSubgroupPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceSubgroupPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceSubgroupPropertiesMakeCSlice(x ...PhysicalDeviceSubgroupProperties) []PhysicalDeviceSubgroupProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSubgroupProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceSubgroupProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceSubgroupProperties
func (x PhysicalDeviceSubgroupProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceSubgroupProperties) WithDefaultSType() PhysicalDeviceSubgroupProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSubgroupProperties) WithSType(y StructureType) PhysicalDeviceSubgroupProperties {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceSubgroupProperties
func (x PhysicalDeviceSubgroupProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSubgroupProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceSubgroupProperties {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// SubgroupSize returns the value of subgroupSize from VkPhysicalDeviceSubgroupProperties
func (x PhysicalDeviceSubgroupProperties) SubgroupSize() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.subgroupSize)
	return *ptr
}

// SupportedStages returns the value of supportedStages from VkPhysicalDeviceSubgroupProperties
func (x PhysicalDeviceSubgroupProperties) SupportedStages() ShaderStageFlags {
	ptr := /* typedef */ (*ShaderStageFlags)(&x.supportedStages)
	return *ptr
}

// SupportedOperations returns the value of supportedOperations from VkPhysicalDeviceSubgroupProperties
func (x PhysicalDeviceSubgroupProperties) SupportedOperations() SubgroupFeatureFlags {
	ptr := /* typedef */ (*SubgroupFeatureFlags)(&x.supportedOperations)
	return *ptr
}

// QuadOperationsInAllStages returns the value of quadOperationsInAllStages from VkPhysicalDeviceSubgroupProperties
func (x PhysicalDeviceSubgroupProperties) QuadOperationsInAllStages() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.quadOperationsInAllStages)
	return *ptr
}

//PhysicalDeviceShaderDrawParameterFeatures is an alias to PhysicalDeviceShaderDrawParametersFeatures.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderDrawParameterFeatures.html
//
// Deprecated: Most Aliases in the Vulkan spec are for compatibility purposes as extensions get
// promoted to features. If possible, update code to use the promoted name: PhysicalDeviceShaderDrawParametersFeatures.
type PhysicalDeviceShaderDrawParameterFeatures = PhysicalDeviceShaderDrawParametersFeatures

//ExternalMemoryProperties provides a go interface for VkExternalMemoryProperties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkExternalMemoryProperties.html
type ExternalMemoryProperties C.struct_VkExternalMemoryProperties

// SizeofExternalMemoryProperties is the memory size of a ExternalMemoryProperties
var SizeofExternalMemoryProperties int = int(unsafe.Sizeof(ExternalMemoryProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExternalMemoryProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExternalMemoryProperties) AsCPtr() *ExternalMemoryProperties {
	clone := (*ExternalMemoryProperties)(newCBlock(C.ulong(SizeofExternalMemoryProperties)))
	*clone = x
	return clone
}

// ExternalMemoryPropertiesFreeCSlice releases the memory allocated by ExternalMemoryPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func ExternalMemoryPropertiesFreeCSlice(x []ExternalMemoryProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExternalMemoryPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExternalMemoryPropertiesFreeCSlice must be called on the returned slice.
func ExternalMemoryPropertiesMakeCSlice(x ...ExternalMemoryProperties) []ExternalMemoryProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalMemoryProperties * len(x)
	dst := unsafe.Slice((*ExternalMemoryProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// ExternalMemoryFeatures returns the value of externalMemoryFeatures from VkExternalMemoryProperties
func (x ExternalMemoryProperties) ExternalMemoryFeatures() ExternalMemoryFeatureFlags {
	ptr := /* typedef */ (*ExternalMemoryFeatureFlags)(&x.externalMemoryFeatures)
	return *ptr
}

// ExportFromImportedHandleTypes returns the value of exportFromImportedHandleTypes from VkExternalMemoryProperties
func (x ExternalMemoryProperties) ExportFromImportedHandleTypes() ExternalMemoryHandleTypeFlags {
	ptr := /* typedef */ (*ExternalMemoryHandleTypeFlags)(&x.exportFromImportedHandleTypes)
	return *ptr
}

// CompatibleHandleTypes returns the value of compatibleHandleTypes from VkExternalMemoryProperties
func (x ExternalMemoryProperties) CompatibleHandleTypes() ExternalMemoryHandleTypeFlags {
	ptr := /* typedef */ (*ExternalMemoryHandleTypeFlags)(&x.compatibleHandleTypes)
	return *ptr
}

//PhysicalDeviceExternalImageFormatInfo provides a go interface for VkPhysicalDeviceExternalImageFormatInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceExternalImageFormatInfo.html
type PhysicalDeviceExternalImageFormatInfo C.struct_VkPhysicalDeviceExternalImageFormatInfo

// SizeofPhysicalDeviceExternalImageFormatInfo is the memory size of a PhysicalDeviceExternalImageFormatInfo
var SizeofPhysicalDeviceExternalImageFormatInfo int = int(unsafe.Sizeof(PhysicalDeviceExternalImageFormatInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceExternalImageFormatInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceExternalImageFormatInfo) AsCPtr() *PhysicalDeviceExternalImageFormatInfo {
	clone := (*PhysicalDeviceExternalImageFormatInfo)(newCBlock(C.ulong(SizeofPhysicalDeviceExternalImageFormatInfo)))
	*clone = x
	return clone
}

// PhysicalDeviceExternalImageFormatInfoFreeCSlice releases the memory allocated by PhysicalDeviceExternalImageFormatInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceExternalImageFormatInfoFreeCSlice(x []PhysicalDeviceExternalImageFormatInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceExternalImageFormatInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceExternalImageFormatInfoFreeCSlice must be called on the returned slice.
func PhysicalDeviceExternalImageFormatInfoMakeCSlice(x ...PhysicalDeviceExternalImageFormatInfo) []PhysicalDeviceExternalImageFormatInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceExternalImageFormatInfo * len(x)
	dst := unsafe.Slice((*PhysicalDeviceExternalImageFormatInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceExternalImageFormatInfo
func (x PhysicalDeviceExternalImageFormatInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceExternalImageFormatInfo) WithDefaultSType() PhysicalDeviceExternalImageFormatInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalImageFormatInfo) WithSType(y StructureType) PhysicalDeviceExternalImageFormatInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceExternalImageFormatInfo
func (x PhysicalDeviceExternalImageFormatInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalImageFormatInfo) WithPNext(y unsafe.Pointer) PhysicalDeviceExternalImageFormatInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// HandleType returns the value of handleType from VkPhysicalDeviceExternalImageFormatInfo
func (x PhysicalDeviceExternalImageFormatInfo) HandleType() ExternalMemoryHandleTypeFlagBits {
	ptr := /* typedef */ (*ExternalMemoryHandleTypeFlagBits)(&x.handleType)
	return *ptr
}

// WithHandleType sets the value for the HandleType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalImageFormatInfo) WithHandleType(y ExternalMemoryHandleTypeFlagBits) PhysicalDeviceExternalImageFormatInfo {
	ptr := /* typedef */ (*C.VkExternalMemoryHandleTypeFlagBits)(&y)
	x.handleType = *ptr
	return x
}

//ExternalImageFormatProperties provides a go interface for VkExternalImageFormatProperties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkExternalImageFormatProperties.html
type ExternalImageFormatProperties C.struct_VkExternalImageFormatProperties

// SizeofExternalImageFormatProperties is the memory size of a ExternalImageFormatProperties
var SizeofExternalImageFormatProperties int = int(unsafe.Sizeof(ExternalImageFormatProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExternalImageFormatProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExternalImageFormatProperties) AsCPtr() *ExternalImageFormatProperties {
	clone := (*ExternalImageFormatProperties)(newCBlock(C.ulong(SizeofExternalImageFormatProperties)))
	*clone = x
	return clone
}

// ExternalImageFormatPropertiesFreeCSlice releases the memory allocated by ExternalImageFormatPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func ExternalImageFormatPropertiesFreeCSlice(x []ExternalImageFormatProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExternalImageFormatPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExternalImageFormatPropertiesFreeCSlice must be called on the returned slice.
func ExternalImageFormatPropertiesMakeCSlice(x ...ExternalImageFormatProperties) []ExternalImageFormatProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalImageFormatProperties * len(x)
	dst := unsafe.Slice((*ExternalImageFormatProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkExternalImageFormatProperties
func (x ExternalImageFormatProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ExternalImageFormatProperties) WithDefaultSType() ExternalImageFormatProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalImageFormatProperties) WithSType(y StructureType) ExternalImageFormatProperties {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkExternalImageFormatProperties
func (x ExternalImageFormatProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalImageFormatProperties) WithPNext(y unsafe.Pointer) ExternalImageFormatProperties {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// ExternalMemoryProperties returns the value of externalMemoryProperties from VkExternalImageFormatProperties
func (x ExternalImageFormatProperties) ExternalMemoryProperties() ExternalMemoryProperties {
	ptr := /* typedef */ (*ExternalMemoryProperties)(&x.externalMemoryProperties)
	return *ptr
}

//PhysicalDeviceExternalBufferInfo provides a go interface for VkPhysicalDeviceExternalBufferInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceExternalBufferInfo.html
type PhysicalDeviceExternalBufferInfo C.struct_VkPhysicalDeviceExternalBufferInfo

// SizeofPhysicalDeviceExternalBufferInfo is the memory size of a PhysicalDeviceExternalBufferInfo
var SizeofPhysicalDeviceExternalBufferInfo int = int(unsafe.Sizeof(PhysicalDeviceExternalBufferInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceExternalBufferInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceExternalBufferInfo) AsCPtr() *PhysicalDeviceExternalBufferInfo {
	clone := (*PhysicalDeviceExternalBufferInfo)(newCBlock(C.ulong(SizeofPhysicalDeviceExternalBufferInfo)))
	*clone = x
	return clone
}

// PhysicalDeviceExternalBufferInfoFreeCSlice releases the memory allocated by PhysicalDeviceExternalBufferInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceExternalBufferInfoFreeCSlice(x []PhysicalDeviceExternalBufferInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceExternalBufferInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceExternalBufferInfoFreeCSlice must be called on the returned slice.
func PhysicalDeviceExternalBufferInfoMakeCSlice(x ...PhysicalDeviceExternalBufferInfo) []PhysicalDeviceExternalBufferInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceExternalBufferInfo * len(x)
	dst := unsafe.Slice((*PhysicalDeviceExternalBufferInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceExternalBufferInfo
func (x PhysicalDeviceExternalBufferInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceExternalBufferInfo) WithDefaultSType() PhysicalDeviceExternalBufferInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalBufferInfo) WithSType(y StructureType) PhysicalDeviceExternalBufferInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceExternalBufferInfo
func (x PhysicalDeviceExternalBufferInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalBufferInfo) WithPNext(y unsafe.Pointer) PhysicalDeviceExternalBufferInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkPhysicalDeviceExternalBufferInfo
func (x PhysicalDeviceExternalBufferInfo) Flags() BufferCreateFlags {
	ptr := /* typedef */ (*BufferCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalBufferInfo) WithFlags(y BufferCreateFlags) PhysicalDeviceExternalBufferInfo {
	ptr := /* typedef */ (*C.VkBufferCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// Usage returns the value of usage from VkPhysicalDeviceExternalBufferInfo
func (x PhysicalDeviceExternalBufferInfo) Usage() BufferUsageFlags {
	ptr := /* typedef */ (*BufferUsageFlags)(&x.usage)
	return *ptr
}

// WithUsage sets the value for the Usage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalBufferInfo) WithUsage(y BufferUsageFlags) PhysicalDeviceExternalBufferInfo {
	ptr := /* typedef */ (*C.VkBufferUsageFlags)(&y)
	x.usage = *ptr
	return x
}

// HandleType returns the value of handleType from VkPhysicalDeviceExternalBufferInfo
func (x PhysicalDeviceExternalBufferInfo) HandleType() ExternalMemoryHandleTypeFlagBits {
	ptr := /* typedef */ (*ExternalMemoryHandleTypeFlagBits)(&x.handleType)
	return *ptr
}

// WithHandleType sets the value for the HandleType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalBufferInfo) WithHandleType(y ExternalMemoryHandleTypeFlagBits) PhysicalDeviceExternalBufferInfo {
	ptr := /* typedef */ (*C.VkExternalMemoryHandleTypeFlagBits)(&y)
	x.handleType = *ptr
	return x
}

//PhysicalDeviceShaderDrawParametersFeatures provides a go interface for VkPhysicalDeviceShaderDrawParametersFeatures.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderDrawParametersFeatures.html
type PhysicalDeviceShaderDrawParametersFeatures C.struct_VkPhysicalDeviceShaderDrawParametersFeatures

// SizeofPhysicalDeviceShaderDrawParametersFeatures is the memory size of a PhysicalDeviceShaderDrawParametersFeatures
var SizeofPhysicalDeviceShaderDrawParametersFeatures int = int(unsafe.Sizeof(PhysicalDeviceShaderDrawParametersFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceShaderDrawParametersFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceShaderDrawParametersFeatures) AsCPtr() *PhysicalDeviceShaderDrawParametersFeatures {
	clone := (*PhysicalDeviceShaderDrawParametersFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceShaderDrawParametersFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceShaderDrawParametersFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceShaderDrawParametersFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceShaderDrawParametersFeaturesFreeCSlice(x []PhysicalDeviceShaderDrawParametersFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceShaderDrawParametersFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceShaderDrawParametersFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceShaderDrawParametersFeaturesMakeCSlice(x ...PhysicalDeviceShaderDrawParametersFeatures) []PhysicalDeviceShaderDrawParametersFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderDrawParametersFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceShaderDrawParametersFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceShaderDrawParametersFeatures
func (x PhysicalDeviceShaderDrawParametersFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceShaderDrawParametersFeatures) WithDefaultSType() PhysicalDeviceShaderDrawParametersFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderDrawParametersFeatures) WithSType(y StructureType) PhysicalDeviceShaderDrawParametersFeatures {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceShaderDrawParametersFeatures
func (x PhysicalDeviceShaderDrawParametersFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderDrawParametersFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceShaderDrawParametersFeatures {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// ShaderDrawParameters returns the value of shaderDrawParameters from VkPhysicalDeviceShaderDrawParametersFeatures
func (x PhysicalDeviceShaderDrawParametersFeatures) ShaderDrawParameters() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDrawParameters)
	return *ptr
}

// WithShaderDrawParameters sets the value for the ShaderDrawParameters on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderDrawParametersFeatures) WithShaderDrawParameters(y Bool32) PhysicalDeviceShaderDrawParametersFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderDrawParameters = *ptr
	return x
}

func (x DeviceFacade) UpdateDescriptorSetWithTemplate(descriptorSet DescriptorSet, descriptorUpdateTemplate DescriptorUpdateTemplate, pData unsafe.Pointer) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDescriptorSet)(&descriptorSet)
	p2 := /* handle */ (*C.VkDescriptorUpdateTemplate)(&descriptorUpdateTemplate)
	p3 := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&pData)
	C.vkUpdateDescriptorSetWithTemplate(addrs, *p0, *p1, *p2, *p3)
}

func (x DeviceFacade) DestroySamplerYcbcrConversion(ycbcrConversion SamplerYcbcrConversion, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkSamplerYcbcrConversion)(&ycbcrConversion)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	C.vkDestroySamplerYcbcrConversion(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) CreateDescriptorUpdateTemplate(pCreateInfo *DescriptorUpdateTemplateCreateInfo, pAllocator *AllocationCallbacks, pDescriptorUpdateTemplate *DescriptorUpdateTemplate) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DescriptorUpdateTemplateCreateInfo) **C.struct_VkDescriptorUpdateTemplateCreateInfo { /* Pointer */
		return (**C.struct_VkDescriptorUpdateTemplateCreateInfo)(unsafe.Pointer(x))
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p3 := func(x **DescriptorUpdateTemplate) **C.VkDescriptorUpdateTemplate { /* Pointer */
		return (**C.VkDescriptorUpdateTemplate)(unsafe.Pointer(x))
	}(&pDescriptorUpdateTemplate)
	ret := C.vkCreateDescriptorUpdateTemplate(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x PhysicalDeviceFacade) GetPhysicalDeviceExternalFenceProperties(pExternalFenceInfo *PhysicalDeviceExternalFenceInfo, pExternalFenceProperties *ExternalFenceProperties) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceExternalFenceInfo) **C.struct_VkPhysicalDeviceExternalFenceInfo { /* Pointer */
		return (**C.struct_VkPhysicalDeviceExternalFenceInfo)(unsafe.Pointer(x))
	}(&pExternalFenceInfo)
	p2 := func(x **ExternalFenceProperties) **C.struct_VkExternalFenceProperties { /* Pointer */
		return (**C.struct_VkExternalFenceProperties)(unsafe.Pointer(x))
	}(&pExternalFenceProperties)
	C.vkGetPhysicalDeviceExternalFenceProperties(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) CreateSamplerYcbcrConversion(pCreateInfo *SamplerYcbcrConversionCreateInfo, pAllocator *AllocationCallbacks, pYcbcrConversion *SamplerYcbcrConversion) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **SamplerYcbcrConversionCreateInfo) **C.struct_VkSamplerYcbcrConversionCreateInfo { /* Pointer */
		return (**C.struct_VkSamplerYcbcrConversionCreateInfo)(unsafe.Pointer(x))
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p3 := func(x **SamplerYcbcrConversion) **C.VkSamplerYcbcrConversion { /* Pointer */
		return (**C.VkSamplerYcbcrConversion)(unsafe.Pointer(x))
	}(&pYcbcrConversion)
	ret := C.vkCreateSamplerYcbcrConversion(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) GetDeviceQueue2(pQueueInfo *DeviceQueueInfo2, pQueue *Queue) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DeviceQueueInfo2) **C.struct_VkDeviceQueueInfo2 { /* Pointer */
		return (**C.struct_VkDeviceQueueInfo2)(unsafe.Pointer(x))
	}(&pQueueInfo)
	p2 := func(x **Queue) **C.VkQueue { /* Pointer */ return (**C.VkQueue)(unsafe.Pointer(x)) }(&pQueue)
	C.vkGetDeviceQueue2(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) TrimCommandPool(commandPool CommandPool, flags CommandPoolTrimFlags) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkCommandPool)(&commandPool)
	p2 := /* typedef */ (*C.VkCommandPoolTrimFlags)(&flags)
	C.vkTrimCommandPool(addrs, *p0, *p1, *p2)
}

func (x PhysicalDeviceFacade) GetPhysicalDeviceSparseImageFormatProperties2(pFormatInfo *PhysicalDeviceSparseImageFormatInfo2, pPropertyCount *uint32, pProperties []SparseImageFormatProperties2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceSparseImageFormatInfo2) **C.struct_VkPhysicalDeviceSparseImageFormatInfo2 { /* Pointer */
		return (**C.struct_VkPhysicalDeviceSparseImageFormatInfo2)(unsafe.Pointer(x))
	}(&pFormatInfo)
	p2 := func(x **uint32) **C.uint { /* Pointer */ return (**C.uint)(unsafe.Pointer(x)) }(&pPropertyCount)
	p3 := func(x *[]SparseImageFormatProperties2) **C.struct_VkSparseImageFormatProperties2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSparseImageFormatProperties2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSparseImageFormatProperties2)(unsafe.Pointer((&ptr)))
	}(&pProperties)
	C.vkGetPhysicalDeviceSparseImageFormatProperties2(addrs, *p0, *p1, *p2, *p3)
}

func (x PhysicalDeviceFacade) GetPhysicalDeviceMemoryProperties2(pMemoryProperties *PhysicalDeviceMemoryProperties2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceMemoryProperties2) **C.struct_VkPhysicalDeviceMemoryProperties2 { /* Pointer */
		return (**C.struct_VkPhysicalDeviceMemoryProperties2)(unsafe.Pointer(x))
	}(&pMemoryProperties)
	C.vkGetPhysicalDeviceMemoryProperties2(addrs, *p0, *p1)
}

func (x PhysicalDeviceFacade) GetPhysicalDeviceQueueFamilyProperties2(pQueueFamilyPropertyCount *uint32, pQueueFamilyProperties []QueueFamilyProperties2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **uint32) **C.uint { /* Pointer */ return (**C.uint)(unsafe.Pointer(x)) }(&pQueueFamilyPropertyCount)
	p2 := func(x *[]QueueFamilyProperties2) **C.struct_VkQueueFamilyProperties2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkQueueFamilyProperties2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkQueueFamilyProperties2)(unsafe.Pointer((&ptr)))
	}(&pQueueFamilyProperties)
	C.vkGetPhysicalDeviceQueueFamilyProperties2(addrs, *p0, *p1, *p2)
}

func (x PhysicalDeviceFacade) GetPhysicalDeviceImageFormatProperties2(pImageFormatInfo *PhysicalDeviceImageFormatInfo2, pImageFormatProperties *ImageFormatProperties2) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceImageFormatInfo2) **C.struct_VkPhysicalDeviceImageFormatInfo2 { /* Pointer */
		return (**C.struct_VkPhysicalDeviceImageFormatInfo2)(unsafe.Pointer(x))
	}(&pImageFormatInfo)
	p2 := func(x **ImageFormatProperties2) **C.struct_VkImageFormatProperties2 { /* Pointer */
		return (**C.struct_VkImageFormatProperties2)(unsafe.Pointer(x))
	}(&pImageFormatProperties)
	ret := C.vkGetPhysicalDeviceImageFormatProperties2(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x PhysicalDeviceFacade) GetPhysicalDeviceFormatProperties2(format Format, pFormatProperties *FormatProperties2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* typedef */ (*C.VkFormat)(&format)
	p2 := func(x **FormatProperties2) **C.struct_VkFormatProperties2 { /* Pointer */
		return (**C.struct_VkFormatProperties2)(unsafe.Pointer(x))
	}(&pFormatProperties)
	C.vkGetPhysicalDeviceFormatProperties2(addrs, *p0, *p1, *p2)
}

func (x PhysicalDeviceFacade) GetPhysicalDeviceProperties2(pProperties *PhysicalDeviceProperties2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceProperties2) **C.struct_VkPhysicalDeviceProperties2 { /* Pointer */
		return (**C.struct_VkPhysicalDeviceProperties2)(unsafe.Pointer(x))
	}(&pProperties)
	C.vkGetPhysicalDeviceProperties2(addrs, *p0, *p1)
}

func (x PhysicalDeviceFacade) GetPhysicalDeviceFeatures2(pFeatures *PhysicalDeviceFeatures2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceFeatures2) **C.struct_VkPhysicalDeviceFeatures2 { /* Pointer */
		return (**C.struct_VkPhysicalDeviceFeatures2)(unsafe.Pointer(x))
	}(&pFeatures)
	C.vkGetPhysicalDeviceFeatures2(addrs, *p0, *p1)
}

func (x DeviceFacade) GetImageSparseMemoryRequirements2(pInfo *ImageSparseMemoryRequirementsInfo2, pSparseMemoryRequirementCount *uint32, pSparseMemoryRequirements []SparseImageMemoryRequirements2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **ImageSparseMemoryRequirementsInfo2) **C.struct_VkImageSparseMemoryRequirementsInfo2 { /* Pointer */
		return (**C.struct_VkImageSparseMemoryRequirementsInfo2)(unsafe.Pointer(x))
	}(&pInfo)
	p2 := func(x **uint32) **C.uint { /* Pointer */ return (**C.uint)(unsafe.Pointer(x)) }(&pSparseMemoryRequirementCount)
	p3 := func(x *[]SparseImageMemoryRequirements2) **C.struct_VkSparseImageMemoryRequirements2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSparseImageMemoryRequirements2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSparseImageMemoryRequirements2)(unsafe.Pointer((&ptr)))
	}(&pSparseMemoryRequirements)
	C.vkGetImageSparseMemoryRequirements2(addrs, *p0, *p1, *p2, *p3)
}

func (x DeviceFacade) GetBufferMemoryRequirements2(pInfo *BufferMemoryRequirementsInfo2, pMemoryRequirements *MemoryRequirements2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **BufferMemoryRequirementsInfo2) **C.struct_VkBufferMemoryRequirementsInfo2 { /* Pointer */
		return (**C.struct_VkBufferMemoryRequirementsInfo2)(unsafe.Pointer(x))
	}(&pInfo)
	p2 := func(x **MemoryRequirements2) **C.struct_VkMemoryRequirements2 { /* Pointer */
		return (**C.struct_VkMemoryRequirements2)(unsafe.Pointer(x))
	}(&pMemoryRequirements)
	C.vkGetBufferMemoryRequirements2(addrs, *p0, *p1, *p2)
}

func (x PhysicalDeviceFacade) GetPhysicalDeviceExternalSemaphoreProperties(pExternalSemaphoreInfo *PhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties *ExternalSemaphoreProperties) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceExternalSemaphoreInfo) **C.struct_VkPhysicalDeviceExternalSemaphoreInfo { /* Pointer */
		return (**C.struct_VkPhysicalDeviceExternalSemaphoreInfo)(unsafe.Pointer(x))
	}(&pExternalSemaphoreInfo)
	p2 := func(x **ExternalSemaphoreProperties) **C.struct_VkExternalSemaphoreProperties { /* Pointer */
		return (**C.struct_VkExternalSemaphoreProperties)(unsafe.Pointer(x))
	}(&pExternalSemaphoreProperties)
	C.vkGetPhysicalDeviceExternalSemaphoreProperties(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) GetImageMemoryRequirements2(pInfo *ImageMemoryRequirementsInfo2, pMemoryRequirements *MemoryRequirements2) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **ImageMemoryRequirementsInfo2) **C.struct_VkImageMemoryRequirementsInfo2 { /* Pointer */
		return (**C.struct_VkImageMemoryRequirementsInfo2)(unsafe.Pointer(x))
	}(&pInfo)
	p2 := func(x **MemoryRequirements2) **C.struct_VkMemoryRequirements2 { /* Pointer */
		return (**C.struct_VkMemoryRequirements2)(unsafe.Pointer(x))
	}(&pMemoryRequirements)
	C.vkGetImageMemoryRequirements2(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) DestroyDescriptorUpdateTemplate(descriptorUpdateTemplate DescriptorUpdateTemplate, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDescriptorUpdateTemplate)(&descriptorUpdateTemplate)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	C.vkDestroyDescriptorUpdateTemplate(addrs, *p0, *p1, *p2)
}

func (x InstanceFacade) EnumeratePhysicalDeviceGroups(pPhysicalDeviceGroupCount *uint32, pPhysicalDeviceGroupProperties []PhysicalDeviceGroupProperties) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkInstance)(&x.H)
	p1 := func(x **uint32) **C.uint { /* Pointer */ return (**C.uint)(unsafe.Pointer(x)) }(&pPhysicalDeviceGroupCount)
	p2 := func(x *[]PhysicalDeviceGroupProperties) **C.struct_VkPhysicalDeviceGroupProperties { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkPhysicalDeviceGroupProperties)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkPhysicalDeviceGroupProperties)(unsafe.Pointer((&ptr)))
	}(&pPhysicalDeviceGroupProperties)
	ret := C.vkEnumeratePhysicalDeviceGroups(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x CommandBufferFacade) CmdDispatchBase(baseGroupX uint32, baseGroupY uint32, baseGroupZ uint32, groupCountX uint32, groupCountY uint32, groupCountZ uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&baseGroupX)
	p2 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&baseGroupY)
	p3 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&baseGroupZ)
	p4 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&groupCountX)
	p5 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&groupCountY)
	p6 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&groupCountZ)
	C.vkCmdDispatchBase(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6)
}

func (x CommandBufferFacade) CmdSetDeviceMask(deviceMask uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&deviceMask)
	C.vkCmdSetDeviceMask(addrs, *p0, *p1)
}

func (x DeviceFacade) GetDeviceGroupPeerMemoryFeatures(heapIndex uint32, localDeviceIndex uint32, remoteDeviceIndex uint32, pPeerMemoryFeatures *PeerMemoryFeatureFlags) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&heapIndex)
	p2 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&localDeviceIndex)
	p3 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&remoteDeviceIndex)
	p4 := func(x **PeerMemoryFeatureFlags) **C.VkPeerMemoryFeatureFlags { /* Pointer */
		return (**C.VkPeerMemoryFeatureFlags)(unsafe.Pointer(x))
	}(&pPeerMemoryFeatures)
	C.vkGetDeviceGroupPeerMemoryFeatures(addrs, *p0, *p1, *p2, *p3, *p4)
}

func (x DeviceFacade) GetDescriptorSetLayoutSupport(pCreateInfo *DescriptorSetLayoutCreateInfo, pSupport *DescriptorSetLayoutSupport) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DescriptorSetLayoutCreateInfo) **C.struct_VkDescriptorSetLayoutCreateInfo { /* Pointer */
		return (**C.struct_VkDescriptorSetLayoutCreateInfo)(unsafe.Pointer(x))
	}(&pCreateInfo)
	p2 := func(x **DescriptorSetLayoutSupport) **C.struct_VkDescriptorSetLayoutSupport { /* Pointer */
		return (**C.struct_VkDescriptorSetLayoutSupport)(unsafe.Pointer(x))
	}(&pSupport)
	C.vkGetDescriptorSetLayoutSupport(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) BindImageMemory2(bindInfoCount uint32, pBindInfos []BindImageMemoryInfo) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&bindInfoCount)
	p2 := func(x *[]BindImageMemoryInfo) **C.struct_VkBindImageMemoryInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkBindImageMemoryInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkBindImageMemoryInfo)(unsafe.Pointer((&ptr)))
	}(&pBindInfos)
	ret := C.vkBindImageMemory2(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) BindBufferMemory2(bindInfoCount uint32, pBindInfos []BindBufferMemoryInfo) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&bindInfoCount)
	p2 := func(x *[]BindBufferMemoryInfo) **C.struct_VkBindBufferMemoryInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkBindBufferMemoryInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkBindBufferMemoryInfo)(unsafe.Pointer((&ptr)))
	}(&pBindInfos)
	ret := C.vkBindBufferMemory2(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func EnumerateInstanceVersion(pApiVersion *uint32) Result {
	addrs := &C.vksProcAddresses
	p0 := func(x **uint32) **C.uint { /* Pointer */ return (**C.uint)(unsafe.Pointer(x)) }(&pApiVersion)
	ret := C.vkEnumerateInstanceVersion(addrs, *p0)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x PhysicalDeviceFacade) GetPhysicalDeviceExternalBufferProperties(pExternalBufferInfo *PhysicalDeviceExternalBufferInfo, pExternalBufferProperties *ExternalBufferProperties) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceExternalBufferInfo) **C.struct_VkPhysicalDeviceExternalBufferInfo { /* Pointer */
		return (**C.struct_VkPhysicalDeviceExternalBufferInfo)(unsafe.Pointer(x))
	}(&pExternalBufferInfo)
	p2 := func(x **ExternalBufferProperties) **C.struct_VkExternalBufferProperties { /* Pointer */
		return (**C.struct_VkExternalBufferProperties)(unsafe.Pointer(x))
	}(&pExternalBufferProperties)
	C.vkGetPhysicalDeviceExternalBufferProperties(addrs, *p0, *p1, *p2)
}

// DriverId is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDriverId.html
type DriverId uint32

const (
	VK_DRIVER_ID_AMD_PROPRIETARY           DriverId = 1
	VK_DRIVER_ID_AMD_OPEN_SOURCE           DriverId = 2
	VK_DRIVER_ID_MESA_RADV                 DriverId = 3
	VK_DRIVER_ID_NVIDIA_PROPRIETARY        DriverId = 4
	VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS DriverId = 5
	VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA    DriverId = 6
	VK_DRIVER_ID_IMAGINATION_PROPRIETARY   DriverId = 7
	VK_DRIVER_ID_QUALCOMM_PROPRIETARY      DriverId = 8
	VK_DRIVER_ID_ARM_PROPRIETARY           DriverId = 9
	VK_DRIVER_ID_GOOGLE_SWIFTSHADER        DriverId = 10
	VK_DRIVER_ID_GGP_PROPRIETARY           DriverId = 11
	VK_DRIVER_ID_BROADCOM_PROPRIETARY      DriverId = 12
	VK_DRIVER_ID_MESA_LLVMPIPE             DriverId = 13
	VK_DRIVER_ID_MOLTENVK                  DriverId = 14
	VK_DRIVER_ID_COREAVI_PROPRIETARY       DriverId = 15
	VK_DRIVER_ID_JUICE_PROPRIETARY         DriverId = 16
	VK_DRIVER_ID_VERISILICON_PROPRIETARY   DriverId = 17
	VK_DRIVER_ID_MESA_TURNIP               DriverId = 18
	VK_DRIVER_ID_MESA_V3DV                 DriverId = 19
	VK_DRIVER_ID_MESA_PANVK                DriverId = 20
)

var (
	reverseDriverId map[DriverId]string = map[DriverId]string{
		VK_DRIVER_ID_AMD_PROPRIETARY:           "VK_DRIVER_ID_AMD_PROPRIETARY",
		VK_DRIVER_ID_AMD_OPEN_SOURCE:           "VK_DRIVER_ID_AMD_OPEN_SOURCE",
		VK_DRIVER_ID_MESA_RADV:                 "VK_DRIVER_ID_MESA_RADV",
		VK_DRIVER_ID_NVIDIA_PROPRIETARY:        "VK_DRIVER_ID_NVIDIA_PROPRIETARY",
		VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS: "VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS",
		VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA:    "VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA",
		VK_DRIVER_ID_IMAGINATION_PROPRIETARY:   "VK_DRIVER_ID_IMAGINATION_PROPRIETARY",
		VK_DRIVER_ID_QUALCOMM_PROPRIETARY:      "VK_DRIVER_ID_QUALCOMM_PROPRIETARY",
		VK_DRIVER_ID_ARM_PROPRIETARY:           "VK_DRIVER_ID_ARM_PROPRIETARY",
		VK_DRIVER_ID_GOOGLE_SWIFTSHADER:        "VK_DRIVER_ID_GOOGLE_SWIFTSHADER",
		VK_DRIVER_ID_GGP_PROPRIETARY:           "VK_DRIVER_ID_GGP_PROPRIETARY",
		VK_DRIVER_ID_BROADCOM_PROPRIETARY:      "VK_DRIVER_ID_BROADCOM_PROPRIETARY",
		VK_DRIVER_ID_MESA_LLVMPIPE:             "VK_DRIVER_ID_MESA_LLVMPIPE",
		VK_DRIVER_ID_MOLTENVK:                  "VK_DRIVER_ID_MOLTENVK",
		VK_DRIVER_ID_COREAVI_PROPRIETARY:       "VK_DRIVER_ID_COREAVI_PROPRIETARY",
		VK_DRIVER_ID_JUICE_PROPRIETARY:         "VK_DRIVER_ID_JUICE_PROPRIETARY",
		VK_DRIVER_ID_VERISILICON_PROPRIETARY:   "VK_DRIVER_ID_VERISILICON_PROPRIETARY",
		VK_DRIVER_ID_MESA_TURNIP:               "VK_DRIVER_ID_MESA_TURNIP",
		VK_DRIVER_ID_MESA_V3DV:                 "VK_DRIVER_ID_MESA_V3DV",
		VK_DRIVER_ID_MESA_PANVK:                "VK_DRIVER_ID_MESA_PANVK",
	}
)

func (x DriverId) String() string {
	if s, ok := reverseDriverId[x]; ok {
		return s
	}
	return fmt.Sprintf("DriverId=%d", x)
}

// SamplerReductionMode is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSamplerReductionMode.html
type SamplerReductionMode uint32

const (
	VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE SamplerReductionMode = 0
	VK_SAMPLER_REDUCTION_MODE_MIN              SamplerReductionMode = 1
	VK_SAMPLER_REDUCTION_MODE_MAX              SamplerReductionMode = 2
)

var (
	reverseSamplerReductionMode map[SamplerReductionMode]string = map[SamplerReductionMode]string{
		VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE: "VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE",
		VK_SAMPLER_REDUCTION_MODE_MIN:              "VK_SAMPLER_REDUCTION_MODE_MIN",
		VK_SAMPLER_REDUCTION_MODE_MAX:              "VK_SAMPLER_REDUCTION_MODE_MAX",
	}
)

func (x SamplerReductionMode) String() string {
	if s, ok := reverseSamplerReductionMode[x]; ok {
		return s
	}
	return fmt.Sprintf("SamplerReductionMode=%d", x)
}

// SemaphoreWaitFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSemaphoreWaitFlagBits.html
type SemaphoreWaitFlagBits uint32

const (
	VK_SEMAPHORE_WAIT_ANY_BIT SemaphoreWaitFlagBits = (1 << 0)
)

var (
	reverseSemaphoreWaitFlagBits map[SemaphoreWaitFlagBits]string = map[SemaphoreWaitFlagBits]string{
		VK_SEMAPHORE_WAIT_ANY_BIT: "VK_SEMAPHORE_WAIT_ANY_BIT",
	}
)

func (x SemaphoreWaitFlagBits) String() string {
	if s, ok := reverseSemaphoreWaitFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("SemaphoreWaitFlagBits=%d", x)
}

// DescriptorBindingFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorBindingFlagBits.html
type DescriptorBindingFlagBits uint32

const (
	VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT           DescriptorBindingFlagBits = (1 << 0)
	VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT DescriptorBindingFlagBits = (1 << 1)
	VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT             DescriptorBindingFlagBits = (1 << 2)
	VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT   DescriptorBindingFlagBits = (1 << 3)
)

var (
	reverseDescriptorBindingFlagBits map[DescriptorBindingFlagBits]string = map[DescriptorBindingFlagBits]string{
		VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT:           "VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT",
		VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT: "VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT",
		VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT:             "VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT",
		VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT:   "VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT",
	}
)

func (x DescriptorBindingFlagBits) String() string {
	if s, ok := reverseDescriptorBindingFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("DescriptorBindingFlagBits=%d", x)
}

// ResolveModeFlagBits is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkResolveModeFlagBits.html
type ResolveModeFlagBits uint32

const (
	VK_RESOLVE_MODE_NONE            ResolveModeFlagBits = 0
	VK_RESOLVE_MODE_SAMPLE_ZERO_BIT ResolveModeFlagBits = (1 << 0)
	VK_RESOLVE_MODE_AVERAGE_BIT     ResolveModeFlagBits = (1 << 1)
	VK_RESOLVE_MODE_MIN_BIT         ResolveModeFlagBits = (1 << 2)
	VK_RESOLVE_MODE_MAX_BIT         ResolveModeFlagBits = (1 << 3)
)

var (
	reverseResolveModeFlagBits map[ResolveModeFlagBits]string = map[ResolveModeFlagBits]string{
		VK_RESOLVE_MODE_NONE:            "VK_RESOLVE_MODE_NONE",
		VK_RESOLVE_MODE_SAMPLE_ZERO_BIT: "VK_RESOLVE_MODE_SAMPLE_ZERO_BIT",
		VK_RESOLVE_MODE_AVERAGE_BIT:     "VK_RESOLVE_MODE_AVERAGE_BIT",
		VK_RESOLVE_MODE_MIN_BIT:         "VK_RESOLVE_MODE_MIN_BIT",
		VK_RESOLVE_MODE_MAX_BIT:         "VK_RESOLVE_MODE_MAX_BIT",
	}
)

func (x ResolveModeFlagBits) String() string {
	if s, ok := reverseResolveModeFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ResolveModeFlagBits=%d", x)
}

// ShaderFloatControlsIndependence is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkShaderFloatControlsIndependence.html
type ShaderFloatControlsIndependence uint32

const (
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY ShaderFloatControlsIndependence = 0
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL         ShaderFloatControlsIndependence = 1
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE        ShaderFloatControlsIndependence = 2
)

var (
	reverseShaderFloatControlsIndependence map[ShaderFloatControlsIndependence]string = map[ShaderFloatControlsIndependence]string{
		VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY: "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY",
		VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL:         "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL",
		VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE:        "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE",
	}
)

func (x ShaderFloatControlsIndependence) String() string {
	if s, ok := reverseShaderFloatControlsIndependence[x]; ok {
		return s
	}
	return fmt.Sprintf("ShaderFloatControlsIndependence=%d", x)
}

// SemaphoreType is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSemaphoreType.html
type SemaphoreType uint32

const (
	VK_SEMAPHORE_TYPE_BINARY   SemaphoreType = 0
	VK_SEMAPHORE_TYPE_TIMELINE SemaphoreType = 1
)

var (
	reverseSemaphoreType map[SemaphoreType]string = map[SemaphoreType]string{
		VK_SEMAPHORE_TYPE_BINARY:   "VK_SEMAPHORE_TYPE_BINARY",
		VK_SEMAPHORE_TYPE_TIMELINE: "VK_SEMAPHORE_TYPE_TIMELINE",
	}
)

func (x SemaphoreType) String() string {
	if s, ok := reverseSemaphoreType[x]; ok {
		return s
	}
	return fmt.Sprintf("SemaphoreType=%d", x)
}

// DescriptorBindingFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorBindingFlags.html
type DescriptorBindingFlags Flags

// ResolveModeFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkResolveModeFlags.html
type ResolveModeFlags Flags

// SemaphoreWaitFlags is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSemaphoreWaitFlags.html
type SemaphoreWaitFlags Flags

//SubpassEndInfo provides a go interface for VkSubpassEndInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSubpassEndInfo.html
type SubpassEndInfo C.struct_VkSubpassEndInfo

// SizeofSubpassEndInfo is the memory size of a SubpassEndInfo
var SizeofSubpassEndInfo int = int(unsafe.Sizeof(SubpassEndInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubpassEndInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubpassEndInfo) AsCPtr() *SubpassEndInfo {
	clone := (*SubpassEndInfo)(newCBlock(C.ulong(SizeofSubpassEndInfo)))
	*clone = x
	return clone
}

// SubpassEndInfoFreeCSlice releases the memory allocated by SubpassEndInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SubpassEndInfoFreeCSlice(x []SubpassEndInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubpassEndInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubpassEndInfoFreeCSlice must be called on the returned slice.
func SubpassEndInfoMakeCSlice(x ...SubpassEndInfo) []SubpassEndInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassEndInfo * len(x)
	dst := unsafe.Slice((*SubpassEndInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSubpassEndInfo
func (x SubpassEndInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SubpassEndInfo) WithDefaultSType() SubpassEndInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SUBPASS_END_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassEndInfo) WithSType(y StructureType) SubpassEndInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkSubpassEndInfo
func (x SubpassEndInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassEndInfo) WithPNext(y unsafe.Pointer) SubpassEndInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

//RenderPassCreateInfo2 provides a go interface for VkRenderPassCreateInfo2.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkRenderPassCreateInfo2.html
type RenderPassCreateInfo2 C.struct_VkRenderPassCreateInfo2

// SizeofRenderPassCreateInfo2 is the memory size of a RenderPassCreateInfo2
var SizeofRenderPassCreateInfo2 int = int(unsafe.Sizeof(RenderPassCreateInfo2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *RenderPassCreateInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x RenderPassCreateInfo2) AsCPtr() *RenderPassCreateInfo2 {
	clone := (*RenderPassCreateInfo2)(newCBlock(C.ulong(SizeofRenderPassCreateInfo2)))
	*clone = x
	return clone
}

// RenderPassCreateInfo2FreeCSlice releases the memory allocated by RenderPassCreateInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func RenderPassCreateInfo2FreeCSlice(x []RenderPassCreateInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// RenderPassCreateInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. RenderPassCreateInfo2FreeCSlice must be called on the returned slice.
func RenderPassCreateInfo2MakeCSlice(x ...RenderPassCreateInfo2) []RenderPassCreateInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderPassCreateInfo2 * len(x)
	dst := unsafe.Slice((*RenderPassCreateInfo2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x RenderPassCreateInfo2) WithDefaultSType() RenderPassCreateInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo2) WithSType(y StructureType) RenderPassCreateInfo2 {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo2) WithPNext(y unsafe.Pointer) RenderPassCreateInfo2 {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) Flags() RenderPassCreateFlags {
	ptr := /* typedef */ (*RenderPassCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo2) WithFlags(y RenderPassCreateFlags) RenderPassCreateInfo2 {
	ptr := /* typedef */ (*C.VkRenderPassCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// AttachmentCount returns the value of attachmentCount from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) AttachmentCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.attachmentCount)
	return *ptr
}

// WithAttachmentCount sets the value for the AttachmentCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo2) WithAttachmentCount(y uint32) RenderPassCreateInfo2 {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.attachmentCount = *ptr
	return x
}

// PAttachments returns the value of pAttachments from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) PAttachments() []AttachmentDescription2 {
	ptr := func(x **C.struct_VkAttachmentDescription2) *[]AttachmentDescription2 { /* Slice */
		slc := unsafe.Slice((*AttachmentDescription2)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pAttachments)
	return *ptr
}

// WithPAttachments sets the value for the PAttachments on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines AttachmentCount as the length of this field.
// AttachmentCount is updated with the length of the new value.
func (x RenderPassCreateInfo2) WithPAttachments(y []AttachmentDescription2) RenderPassCreateInfo2 {
	ptr := func(x *[]AttachmentDescription2) **C.struct_VkAttachmentDescription2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkAttachmentDescription2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkAttachmentDescription2)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pAttachments = *ptr
	return x.WithAttachmentCount(uint32(len(y)))
}

// SubpassCount returns the value of subpassCount from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) SubpassCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.subpassCount)
	return *ptr
}

// WithSubpassCount sets the value for the SubpassCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo2) WithSubpassCount(y uint32) RenderPassCreateInfo2 {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.subpassCount = *ptr
	return x
}

// PSubpasses returns the value of pSubpasses from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) PSubpasses() []SubpassDescription2 {
	ptr := func(x **C.struct_VkSubpassDescription2) *[]SubpassDescription2 { /* Slice */
		slc := unsafe.Slice((*SubpassDescription2)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pSubpasses)
	return *ptr
}

// WithPSubpasses sets the value for the PSubpasses on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SubpassCount as the length of this field.
// SubpassCount is updated with the length of the new value.
func (x RenderPassCreateInfo2) WithPSubpasses(y []SubpassDescription2) RenderPassCreateInfo2 {
	ptr := func(x *[]SubpassDescription2) **C.struct_VkSubpassDescription2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSubpassDescription2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSubpassDescription2)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pSubpasses = *ptr
	return x.WithSubpassCount(uint32(len(y)))
}

// DependencyCount returns the value of dependencyCount from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) DependencyCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.dependencyCount)
	return *ptr
}

// WithDependencyCount sets the value for the DependencyCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo2) WithDependencyCount(y uint32) RenderPassCreateInfo2 {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.dependencyCount = *ptr
	return x
}

// PDependencies returns the value of pDependencies from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) PDependencies() []SubpassDependency2 {
	ptr := func(x **C.struct_VkSubpassDependency2) *[]SubpassDependency2 { /* Slice */
		slc := unsafe.Slice((*SubpassDependency2)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pDependencies)
	return *ptr
}

// WithPDependencies sets the value for the PDependencies on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DependencyCount as the length of this field.
// DependencyCount is updated with the length of the new value.
func (x RenderPassCreateInfo2) WithPDependencies(y []SubpassDependency2) RenderPassCreateInfo2 {
	ptr := func(x *[]SubpassDependency2) **C.struct_VkSubpassDependency2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSubpassDependency2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSubpassDependency2)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pDependencies = *ptr
	return x.WithDependencyCount(uint32(len(y)))
}

// CorrelatedViewMaskCount returns the value of correlatedViewMaskCount from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) CorrelatedViewMaskCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.correlatedViewMaskCount)
	return *ptr
}

// WithCorrelatedViewMaskCount sets the value for the CorrelatedViewMaskCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo2) WithCorrelatedViewMaskCount(y uint32) RenderPassCreateInfo2 {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.correlatedViewMaskCount = *ptr
	return x
}

// PCorrelatedViewMasks returns the value of pCorrelatedViewMasks from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) PCorrelatedViewMasks() []uint32 {
	ptr := func(x **C.uint) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pCorrelatedViewMasks)
	return *ptr
}

// WithPCorrelatedViewMasks sets the value for the PCorrelatedViewMasks on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines CorrelatedViewMaskCount as the length of this field.
// CorrelatedViewMaskCount is updated with the length of the new value.
func (x RenderPassCreateInfo2) WithPCorrelatedViewMasks(y []uint32) RenderPassCreateInfo2 {
	ptr := func(x *[]uint32) **C.uint { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pCorrelatedViewMasks = *ptr
	return x.WithCorrelatedViewMaskCount(uint32(len(y)))
}

//AttachmentDescription2 provides a go interface for VkAttachmentDescription2.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkAttachmentDescription2.html
type AttachmentDescription2 C.struct_VkAttachmentDescription2

// SizeofAttachmentDescription2 is the memory size of a AttachmentDescription2
var SizeofAttachmentDescription2 int = int(unsafe.Sizeof(AttachmentDescription2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *AttachmentDescription2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x AttachmentDescription2) AsCPtr() *AttachmentDescription2 {
	clone := (*AttachmentDescription2)(newCBlock(C.ulong(SizeofAttachmentDescription2)))
	*clone = x
	return clone
}

// AttachmentDescription2FreeCSlice releases the memory allocated by AttachmentDescription2MakeCSlice.
// It does not free pointers stored inside the slice.
func AttachmentDescription2FreeCSlice(x []AttachmentDescription2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// AttachmentDescription2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. AttachmentDescription2FreeCSlice must be called on the returned slice.
func AttachmentDescription2MakeCSlice(x ...AttachmentDescription2) []AttachmentDescription2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAttachmentDescription2 * len(x)
	dst := unsafe.Slice((*AttachmentDescription2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkAttachmentDescription2
func (x AttachmentDescription2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x AttachmentDescription2) WithDefaultSType() AttachmentDescription2 {
	return x.WithSType(VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithSType(y StructureType) AttachmentDescription2 {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkAttachmentDescription2
func (x AttachmentDescription2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithPNext(y unsafe.Pointer) AttachmentDescription2 {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkAttachmentDescription2
func (x AttachmentDescription2) Flags() AttachmentDescriptionFlags {
	ptr := /* typedef */ (*AttachmentDescriptionFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithFlags(y AttachmentDescriptionFlags) AttachmentDescription2 {
	ptr := /* typedef */ (*C.VkAttachmentDescriptionFlags)(&y)
	x.flags = *ptr
	return x
}

// Format returns the value of format from VkAttachmentDescription2
func (x AttachmentDescription2) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format)
	return *ptr
}

// WithFormat sets the value for the Format on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithFormat(y Format) AttachmentDescription2 {
	ptr := /* typedef */ (*C.VkFormat)(&y)
	x.format = *ptr
	return x
}

// Samples returns the value of samples from VkAttachmentDescription2
func (x AttachmentDescription2) Samples() SampleCountFlagBits {
	ptr := /* typedef */ (*SampleCountFlagBits)(&x.samples)
	return *ptr
}

// WithSamples sets the value for the Samples on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithSamples(y SampleCountFlagBits) AttachmentDescription2 {
	ptr := /* typedef */ (*C.VkSampleCountFlagBits)(&y)
	x.samples = *ptr
	return x
}

// LoadOp returns the value of loadOp from VkAttachmentDescription2
func (x AttachmentDescription2) LoadOp() AttachmentLoadOp {
	ptr := /* typedef */ (*AttachmentLoadOp)(&x.loadOp)
	return *ptr
}

// WithLoadOp sets the value for the LoadOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithLoadOp(y AttachmentLoadOp) AttachmentDescription2 {
	ptr := /* typedef */ (*C.VkAttachmentLoadOp)(&y)
	x.loadOp = *ptr
	return x
}

// StoreOp returns the value of storeOp from VkAttachmentDescription2
func (x AttachmentDescription2) StoreOp() AttachmentStoreOp {
	ptr := /* typedef */ (*AttachmentStoreOp)(&x.storeOp)
	return *ptr
}

// WithStoreOp sets the value for the StoreOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithStoreOp(y AttachmentStoreOp) AttachmentDescription2 {
	ptr := /* typedef */ (*C.VkAttachmentStoreOp)(&y)
	x.storeOp = *ptr
	return x
}

// StencilLoadOp returns the value of stencilLoadOp from VkAttachmentDescription2
func (x AttachmentDescription2) StencilLoadOp() AttachmentLoadOp {
	ptr := /* typedef */ (*AttachmentLoadOp)(&x.stencilLoadOp)
	return *ptr
}

// WithStencilLoadOp sets the value for the StencilLoadOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithStencilLoadOp(y AttachmentLoadOp) AttachmentDescription2 {
	ptr := /* typedef */ (*C.VkAttachmentLoadOp)(&y)
	x.stencilLoadOp = *ptr
	return x
}

// StencilStoreOp returns the value of stencilStoreOp from VkAttachmentDescription2
func (x AttachmentDescription2) StencilStoreOp() AttachmentStoreOp {
	ptr := /* typedef */ (*AttachmentStoreOp)(&x.stencilStoreOp)
	return *ptr
}

// WithStencilStoreOp sets the value for the StencilStoreOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithStencilStoreOp(y AttachmentStoreOp) AttachmentDescription2 {
	ptr := /* typedef */ (*C.VkAttachmentStoreOp)(&y)
	x.stencilStoreOp = *ptr
	return x
}

// InitialLayout returns the value of initialLayout from VkAttachmentDescription2
func (x AttachmentDescription2) InitialLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.initialLayout)
	return *ptr
}

// WithInitialLayout sets the value for the InitialLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithInitialLayout(y ImageLayout) AttachmentDescription2 {
	ptr := /* typedef */ (*C.VkImageLayout)(&y)
	x.initialLayout = *ptr
	return x
}

// FinalLayout returns the value of finalLayout from VkAttachmentDescription2
func (x AttachmentDescription2) FinalLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.finalLayout)
	return *ptr
}

// WithFinalLayout sets the value for the FinalLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithFinalLayout(y ImageLayout) AttachmentDescription2 {
	ptr := /* typedef */ (*C.VkImageLayout)(&y)
	x.finalLayout = *ptr
	return x
}

//AttachmentReference2 provides a go interface for VkAttachmentReference2.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkAttachmentReference2.html
type AttachmentReference2 C.struct_VkAttachmentReference2

// SizeofAttachmentReference2 is the memory size of a AttachmentReference2
var SizeofAttachmentReference2 int = int(unsafe.Sizeof(AttachmentReference2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *AttachmentReference2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x AttachmentReference2) AsCPtr() *AttachmentReference2 {
	clone := (*AttachmentReference2)(newCBlock(C.ulong(SizeofAttachmentReference2)))
	*clone = x
	return clone
}

// AttachmentReference2FreeCSlice releases the memory allocated by AttachmentReference2MakeCSlice.
// It does not free pointers stored inside the slice.
func AttachmentReference2FreeCSlice(x []AttachmentReference2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// AttachmentReference2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. AttachmentReference2FreeCSlice must be called on the returned slice.
func AttachmentReference2MakeCSlice(x ...AttachmentReference2) []AttachmentReference2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAttachmentReference2 * len(x)
	dst := unsafe.Slice((*AttachmentReference2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkAttachmentReference2
func (x AttachmentReference2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x AttachmentReference2) WithDefaultSType() AttachmentReference2 {
	return x.WithSType(VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReference2) WithSType(y StructureType) AttachmentReference2 {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkAttachmentReference2
func (x AttachmentReference2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReference2) WithPNext(y unsafe.Pointer) AttachmentReference2 {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Attachment returns the value of attachment from VkAttachmentReference2
func (x AttachmentReference2) Attachment() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.attachment)
	return *ptr
}

// WithAttachment sets the value for the Attachment on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReference2) WithAttachment(y uint32) AttachmentReference2 {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.attachment = *ptr
	return x
}

// Layout returns the value of layout from VkAttachmentReference2
func (x AttachmentReference2) Layout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.layout)
	return *ptr
}

// WithLayout sets the value for the Layout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReference2) WithLayout(y ImageLayout) AttachmentReference2 {
	ptr := /* typedef */ (*C.VkImageLayout)(&y)
	x.layout = *ptr
	return x
}

// AspectMask returns the value of aspectMask from VkAttachmentReference2
func (x AttachmentReference2) AspectMask() ImageAspectFlags {
	ptr := /* typedef */ (*ImageAspectFlags)(&x.aspectMask)
	return *ptr
}

// WithAspectMask sets the value for the AspectMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReference2) WithAspectMask(y ImageAspectFlags) AttachmentReference2 {
	ptr := /* typedef */ (*C.VkImageAspectFlags)(&y)
	x.aspectMask = *ptr
	return x
}

//SubpassDescription2 provides a go interface for VkSubpassDescription2.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSubpassDescription2.html
type SubpassDescription2 C.struct_VkSubpassDescription2

// SizeofSubpassDescription2 is the memory size of a SubpassDescription2
var SizeofSubpassDescription2 int = int(unsafe.Sizeof(SubpassDescription2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubpassDescription2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubpassDescription2) AsCPtr() *SubpassDescription2 {
	clone := (*SubpassDescription2)(newCBlock(C.ulong(SizeofSubpassDescription2)))
	*clone = x
	return clone
}

// SubpassDescription2FreeCSlice releases the memory allocated by SubpassDescription2MakeCSlice.
// It does not free pointers stored inside the slice.
func SubpassDescription2FreeCSlice(x []SubpassDescription2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubpassDescription2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubpassDescription2FreeCSlice must be called on the returned slice.
func SubpassDescription2MakeCSlice(x ...SubpassDescription2) []SubpassDescription2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassDescription2 * len(x)
	dst := unsafe.Slice((*SubpassDescription2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSubpassDescription2
func (x SubpassDescription2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SubpassDescription2) WithDefaultSType() SubpassDescription2 {
	return x.WithSType(VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription2) WithSType(y StructureType) SubpassDescription2 {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkSubpassDescription2
func (x SubpassDescription2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription2) WithPNext(y unsafe.Pointer) SubpassDescription2 {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkSubpassDescription2
func (x SubpassDescription2) Flags() SubpassDescriptionFlags {
	ptr := /* typedef */ (*SubpassDescriptionFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription2) WithFlags(y SubpassDescriptionFlags) SubpassDescription2 {
	ptr := /* typedef */ (*C.VkSubpassDescriptionFlags)(&y)
	x.flags = *ptr
	return x
}

// PipelineBindPoint returns the value of pipelineBindPoint from VkSubpassDescription2
func (x SubpassDescription2) PipelineBindPoint() PipelineBindPoint {
	ptr := /* typedef */ (*PipelineBindPoint)(&x.pipelineBindPoint)
	return *ptr
}

// WithPipelineBindPoint sets the value for the PipelineBindPoint on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription2) WithPipelineBindPoint(y PipelineBindPoint) SubpassDescription2 {
	ptr := /* typedef */ (*C.VkPipelineBindPoint)(&y)
	x.pipelineBindPoint = *ptr
	return x
}

// ViewMask returns the value of viewMask from VkSubpassDescription2
func (x SubpassDescription2) ViewMask() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.viewMask)
	return *ptr
}

// WithViewMask sets the value for the ViewMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription2) WithViewMask(y uint32) SubpassDescription2 {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.viewMask = *ptr
	return x
}

// InputAttachmentCount returns the value of inputAttachmentCount from VkSubpassDescription2
func (x SubpassDescription2) InputAttachmentCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.inputAttachmentCount)
	return *ptr
}

// WithInputAttachmentCount sets the value for the InputAttachmentCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription2) WithInputAttachmentCount(y uint32) SubpassDescription2 {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.inputAttachmentCount = *ptr
	return x
}

// PInputAttachments returns the value of pInputAttachments from VkSubpassDescription2
func (x SubpassDescription2) PInputAttachments() []AttachmentReference2 {
	ptr := func(x **C.struct_VkAttachmentReference2) *[]AttachmentReference2 { /* Slice */
		slc := unsafe.Slice((*AttachmentReference2)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pInputAttachments)
	return *ptr
}

// WithPInputAttachments sets the value for the PInputAttachments on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines InputAttachmentCount as the length of this field.
// InputAttachmentCount is updated with the length of the new value.
func (x SubpassDescription2) WithPInputAttachments(y []AttachmentReference2) SubpassDescription2 {
	ptr := func(x *[]AttachmentReference2) **C.struct_VkAttachmentReference2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkAttachmentReference2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkAttachmentReference2)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pInputAttachments = *ptr
	return x.WithInputAttachmentCount(uint32(len(y)))
}

// ColorAttachmentCount returns the value of colorAttachmentCount from VkSubpassDescription2
func (x SubpassDescription2) ColorAttachmentCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.colorAttachmentCount)
	return *ptr
}

// WithColorAttachmentCount sets the value for the ColorAttachmentCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription2) WithColorAttachmentCount(y uint32) SubpassDescription2 {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.colorAttachmentCount = *ptr
	return x
}

// PColorAttachments returns the value of pColorAttachments from VkSubpassDescription2
func (x SubpassDescription2) PColorAttachments() []AttachmentReference2 {
	ptr := func(x **C.struct_VkAttachmentReference2) *[]AttachmentReference2 { /* Slice */
		slc := unsafe.Slice((*AttachmentReference2)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pColorAttachments)
	return *ptr
}

// WithPColorAttachments sets the value for the PColorAttachments on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines ColorAttachmentCount as the length of this field.
// ColorAttachmentCount is updated with the length of the new value.
func (x SubpassDescription2) WithPColorAttachments(y []AttachmentReference2) SubpassDescription2 {
	ptr := func(x *[]AttachmentReference2) **C.struct_VkAttachmentReference2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkAttachmentReference2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkAttachmentReference2)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pColorAttachments = *ptr
	return x.WithColorAttachmentCount(uint32(len(y)))
}

// PResolveAttachments returns the value of pResolveAttachments from VkSubpassDescription2
func (x SubpassDescription2) PResolveAttachments() []AttachmentReference2 {
	ptr := func(x **C.struct_VkAttachmentReference2) *[]AttachmentReference2 { /* Slice */
		slc := unsafe.Slice((*AttachmentReference2)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pResolveAttachments)
	return *ptr
}

// WithPResolveAttachments sets the value for the PResolveAttachments on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines ColorAttachmentCount as the length of this field.
// ColorAttachmentCount is updated with the length of the new value.
func (x SubpassDescription2) WithPResolveAttachments(y []AttachmentReference2) SubpassDescription2 {
	ptr := func(x *[]AttachmentReference2) **C.struct_VkAttachmentReference2 { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkAttachmentReference2)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkAttachmentReference2)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pResolveAttachments = *ptr
	return x.WithColorAttachmentCount(uint32(len(y)))
}

// PDepthStencilAttachment returns the value of pDepthStencilAttachment from VkSubpassDescription2
func (x SubpassDescription2) PDepthStencilAttachment() *AttachmentReference2 {
	ptr := func(x **C.struct_VkAttachmentReference2) **AttachmentReference2 { /* Pointer */
		return (**AttachmentReference2)(unsafe.Pointer(x))
	}(&x.pDepthStencilAttachment)
	return *ptr
}

// WithPDepthStencilAttachment sets the value for the PDepthStencilAttachment on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription2) WithPDepthStencilAttachment(y *AttachmentReference2) SubpassDescription2 {
	ptr := func(x **AttachmentReference2) **C.struct_VkAttachmentReference2 { /* Pointer */
		return (**C.struct_VkAttachmentReference2)(unsafe.Pointer(x))
	}(&y)
	x.pDepthStencilAttachment = *ptr
	return x
}

// PreserveAttachmentCount returns the value of preserveAttachmentCount from VkSubpassDescription2
func (x SubpassDescription2) PreserveAttachmentCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.preserveAttachmentCount)
	return *ptr
}

// WithPreserveAttachmentCount sets the value for the PreserveAttachmentCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription2) WithPreserveAttachmentCount(y uint32) SubpassDescription2 {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.preserveAttachmentCount = *ptr
	return x
}

// PPreserveAttachments returns the value of pPreserveAttachments from VkSubpassDescription2
func (x SubpassDescription2) PPreserveAttachments() []uint32 {
	ptr := func(x **C.uint) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pPreserveAttachments)
	return *ptr
}

// WithPPreserveAttachments sets the value for the PPreserveAttachments on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines PreserveAttachmentCount as the length of this field.
// PreserveAttachmentCount is updated with the length of the new value.
func (x SubpassDescription2) WithPPreserveAttachments(y []uint32) SubpassDescription2 {
	ptr := func(x *[]uint32) **C.uint { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pPreserveAttachments = *ptr
	return x.WithPreserveAttachmentCount(uint32(len(y)))
}

//SubpassDependency2 provides a go interface for VkSubpassDependency2.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSubpassDependency2.html
type SubpassDependency2 C.struct_VkSubpassDependency2

// SizeofSubpassDependency2 is the memory size of a SubpassDependency2
var SizeofSubpassDependency2 int = int(unsafe.Sizeof(SubpassDependency2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubpassDependency2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubpassDependency2) AsCPtr() *SubpassDependency2 {
	clone := (*SubpassDependency2)(newCBlock(C.ulong(SizeofSubpassDependency2)))
	*clone = x
	return clone
}

// SubpassDependency2FreeCSlice releases the memory allocated by SubpassDependency2MakeCSlice.
// It does not free pointers stored inside the slice.
func SubpassDependency2FreeCSlice(x []SubpassDependency2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubpassDependency2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubpassDependency2FreeCSlice must be called on the returned slice.
func SubpassDependency2MakeCSlice(x ...SubpassDependency2) []SubpassDependency2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassDependency2 * len(x)
	dst := unsafe.Slice((*SubpassDependency2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSubpassDependency2
func (x SubpassDependency2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SubpassDependency2) WithDefaultSType() SubpassDependency2 {
	return x.WithSType(VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithSType(y StructureType) SubpassDependency2 {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkSubpassDependency2
func (x SubpassDependency2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithPNext(y unsafe.Pointer) SubpassDependency2 {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// SrcSubpass returns the value of srcSubpass from VkSubpassDependency2
func (x SubpassDependency2) SrcSubpass() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.srcSubpass)
	return *ptr
}

// WithSrcSubpass sets the value for the SrcSubpass on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithSrcSubpass(y uint32) SubpassDependency2 {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.srcSubpass = *ptr
	return x
}

// DstSubpass returns the value of dstSubpass from VkSubpassDependency2
func (x SubpassDependency2) DstSubpass() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.dstSubpass)
	return *ptr
}

// WithDstSubpass sets the value for the DstSubpass on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithDstSubpass(y uint32) SubpassDependency2 {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.dstSubpass = *ptr
	return x
}

// SrcStageMask returns the value of srcStageMask from VkSubpassDependency2
func (x SubpassDependency2) SrcStageMask() PipelineStageFlags {
	ptr := /* typedef */ (*PipelineStageFlags)(&x.srcStageMask)
	return *ptr
}

// WithSrcStageMask sets the value for the SrcStageMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithSrcStageMask(y PipelineStageFlags) SubpassDependency2 {
	ptr := /* typedef */ (*C.VkPipelineStageFlags)(&y)
	x.srcStageMask = *ptr
	return x
}

// DstStageMask returns the value of dstStageMask from VkSubpassDependency2
func (x SubpassDependency2) DstStageMask() PipelineStageFlags {
	ptr := /* typedef */ (*PipelineStageFlags)(&x.dstStageMask)
	return *ptr
}

// WithDstStageMask sets the value for the DstStageMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithDstStageMask(y PipelineStageFlags) SubpassDependency2 {
	ptr := /* typedef */ (*C.VkPipelineStageFlags)(&y)
	x.dstStageMask = *ptr
	return x
}

// SrcAccessMask returns the value of srcAccessMask from VkSubpassDependency2
func (x SubpassDependency2) SrcAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.srcAccessMask)
	return *ptr
}

// WithSrcAccessMask sets the value for the SrcAccessMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithSrcAccessMask(y AccessFlags) SubpassDependency2 {
	ptr := /* typedef */ (*C.VkAccessFlags)(&y)
	x.srcAccessMask = *ptr
	return x
}

// DstAccessMask returns the value of dstAccessMask from VkSubpassDependency2
func (x SubpassDependency2) DstAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.dstAccessMask)
	return *ptr
}

// WithDstAccessMask sets the value for the DstAccessMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithDstAccessMask(y AccessFlags) SubpassDependency2 {
	ptr := /* typedef */ (*C.VkAccessFlags)(&y)
	x.dstAccessMask = *ptr
	return x
}

// DependencyFlags returns the value of dependencyFlags from VkSubpassDependency2
func (x SubpassDependency2) DependencyFlags() DependencyFlags {
	ptr := /* typedef */ (*DependencyFlags)(&x.dependencyFlags)
	return *ptr
}

// WithDependencyFlags sets the value for the DependencyFlags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithDependencyFlags(y DependencyFlags) SubpassDependency2 {
	ptr := /* typedef */ (*C.VkDependencyFlags)(&y)
	x.dependencyFlags = *ptr
	return x
}

// ViewOffset returns the value of viewOffset from VkSubpassDependency2
func (x SubpassDependency2) ViewOffset() int32 {
	ptr := func(x *C.int) *int32 { /* Scalar */ return (*int32)(unsafe.Pointer(x)) }(&x.viewOffset)
	return *ptr
}

// WithViewOffset sets the value for the ViewOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithViewOffset(y int32) SubpassDependency2 {
	ptr := func(x *int32) *C.int { /* Scalar */ return (*C.int)(unsafe.Pointer(x)) }(&y)
	x.viewOffset = *ptr
	return x
}

//SubpassBeginInfo provides a go interface for VkSubpassBeginInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSubpassBeginInfo.html
type SubpassBeginInfo C.struct_VkSubpassBeginInfo

// SizeofSubpassBeginInfo is the memory size of a SubpassBeginInfo
var SizeofSubpassBeginInfo int = int(unsafe.Sizeof(SubpassBeginInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubpassBeginInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubpassBeginInfo) AsCPtr() *SubpassBeginInfo {
	clone := (*SubpassBeginInfo)(newCBlock(C.ulong(SizeofSubpassBeginInfo)))
	*clone = x
	return clone
}

// SubpassBeginInfoFreeCSlice releases the memory allocated by SubpassBeginInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SubpassBeginInfoFreeCSlice(x []SubpassBeginInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubpassBeginInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubpassBeginInfoFreeCSlice must be called on the returned slice.
func SubpassBeginInfoMakeCSlice(x ...SubpassBeginInfo) []SubpassBeginInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassBeginInfo * len(x)
	dst := unsafe.Slice((*SubpassBeginInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSubpassBeginInfo
func (x SubpassBeginInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SubpassBeginInfo) WithDefaultSType() SubpassBeginInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassBeginInfo) WithSType(y StructureType) SubpassBeginInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkSubpassBeginInfo
func (x SubpassBeginInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassBeginInfo) WithPNext(y unsafe.Pointer) SubpassBeginInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Contents returns the value of contents from VkSubpassBeginInfo
func (x SubpassBeginInfo) Contents() SubpassContents {
	ptr := /* typedef */ (*SubpassContents)(&x.contents)
	return *ptr
}

// WithContents sets the value for the Contents on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassBeginInfo) WithContents(y SubpassContents) SubpassBeginInfo {
	ptr := /* typedef */ (*C.VkSubpassContents)(&y)
	x.contents = *ptr
	return x
}

//SemaphoreWaitInfo provides a go interface for VkSemaphoreWaitInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSemaphoreWaitInfo.html
type SemaphoreWaitInfo C.struct_VkSemaphoreWaitInfo

// SizeofSemaphoreWaitInfo is the memory size of a SemaphoreWaitInfo
var SizeofSemaphoreWaitInfo int = int(unsafe.Sizeof(SemaphoreWaitInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SemaphoreWaitInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SemaphoreWaitInfo) AsCPtr() *SemaphoreWaitInfo {
	clone := (*SemaphoreWaitInfo)(newCBlock(C.ulong(SizeofSemaphoreWaitInfo)))
	*clone = x
	return clone
}

// SemaphoreWaitInfoFreeCSlice releases the memory allocated by SemaphoreWaitInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SemaphoreWaitInfoFreeCSlice(x []SemaphoreWaitInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SemaphoreWaitInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SemaphoreWaitInfoFreeCSlice must be called on the returned slice.
func SemaphoreWaitInfoMakeCSlice(x ...SemaphoreWaitInfo) []SemaphoreWaitInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSemaphoreWaitInfo * len(x)
	dst := unsafe.Slice((*SemaphoreWaitInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSemaphoreWaitInfo
func (x SemaphoreWaitInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SemaphoreWaitInfo) WithDefaultSType() SemaphoreWaitInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreWaitInfo) WithSType(y StructureType) SemaphoreWaitInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkSemaphoreWaitInfo
func (x SemaphoreWaitInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreWaitInfo) WithPNext(y unsafe.Pointer) SemaphoreWaitInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkSemaphoreWaitInfo
func (x SemaphoreWaitInfo) Flags() SemaphoreWaitFlags {
	ptr := /* typedef */ (*SemaphoreWaitFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreWaitInfo) WithFlags(y SemaphoreWaitFlags) SemaphoreWaitInfo {
	ptr := /* typedef */ (*C.VkSemaphoreWaitFlags)(&y)
	x.flags = *ptr
	return x
}

// SemaphoreCount returns the value of semaphoreCount from VkSemaphoreWaitInfo
func (x SemaphoreWaitInfo) SemaphoreCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.semaphoreCount)
	return *ptr
}

// WithSemaphoreCount sets the value for the SemaphoreCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreWaitInfo) WithSemaphoreCount(y uint32) SemaphoreWaitInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.semaphoreCount = *ptr
	return x
}

// PSemaphores returns the value of pSemaphores from VkSemaphoreWaitInfo
func (x SemaphoreWaitInfo) PSemaphores() []Semaphore {
	ptr := func(x **C.VkSemaphore) *[]Semaphore { /* Slice */
		slc := unsafe.Slice((*Semaphore)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pSemaphores)
	return *ptr
}

// WithPSemaphores sets the value for the PSemaphores on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SemaphoreCount as the length of this field.
// SemaphoreCount is updated with the length of the new value.
func (x SemaphoreWaitInfo) WithPSemaphores(y []Semaphore) SemaphoreWaitInfo {
	ptr := func(x *[]Semaphore) **C.VkSemaphore { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSemaphore)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSemaphore)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pSemaphores = *ptr
	return x.WithSemaphoreCount(uint32(len(y)))
}

// PValues returns the value of pValues from VkSemaphoreWaitInfo
func (x SemaphoreWaitInfo) PValues() []uint64 {
	ptr := func(x **C.ulonglong) *[]uint64 { /* Slice */
		slc := unsafe.Slice((*uint64)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pValues)
	return *ptr
}

// WithPValues sets the value for the PValues on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SemaphoreCount as the length of this field.
// SemaphoreCount is updated with the length of the new value.
func (x SemaphoreWaitInfo) WithPValues(y []uint64) SemaphoreWaitInfo {
	ptr := func(x *[]uint64) **C.ulonglong { /* Slice */
		if len(*x) > 0 {
			slc := (*C.ulonglong)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.ulonglong)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pValues = *ptr
	return x.WithSemaphoreCount(uint32(len(y)))
}

//PhysicalDevice8BitStorageFeatures provides a go interface for VkPhysicalDevice8BitStorageFeatures.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevice8BitStorageFeatures.html
type PhysicalDevice8BitStorageFeatures C.struct_VkPhysicalDevice8BitStorageFeatures

// SizeofPhysicalDevice8BitStorageFeatures is the memory size of a PhysicalDevice8BitStorageFeatures
var SizeofPhysicalDevice8BitStorageFeatures int = int(unsafe.Sizeof(PhysicalDevice8BitStorageFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDevice8BitStorageFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDevice8BitStorageFeatures) AsCPtr() *PhysicalDevice8BitStorageFeatures {
	clone := (*PhysicalDevice8BitStorageFeatures)(newCBlock(C.ulong(SizeofPhysicalDevice8BitStorageFeatures)))
	*clone = x
	return clone
}

// PhysicalDevice8BitStorageFeaturesFreeCSlice releases the memory allocated by PhysicalDevice8BitStorageFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDevice8BitStorageFeaturesFreeCSlice(x []PhysicalDevice8BitStorageFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDevice8BitStorageFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDevice8BitStorageFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDevice8BitStorageFeaturesMakeCSlice(x ...PhysicalDevice8BitStorageFeatures) []PhysicalDevice8BitStorageFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDevice8BitStorageFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDevice8BitStorageFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDevice8BitStorageFeatures
func (x PhysicalDevice8BitStorageFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDevice8BitStorageFeatures) WithDefaultSType() PhysicalDevice8BitStorageFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice8BitStorageFeatures) WithSType(y StructureType) PhysicalDevice8BitStorageFeatures {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDevice8BitStorageFeatures
func (x PhysicalDevice8BitStorageFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice8BitStorageFeatures) WithPNext(y unsafe.Pointer) PhysicalDevice8BitStorageFeatures {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// StorageBuffer8BitAccess returns the value of storageBuffer8BitAccess from VkPhysicalDevice8BitStorageFeatures
func (x PhysicalDevice8BitStorageFeatures) StorageBuffer8BitAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storageBuffer8BitAccess)
	return *ptr
}

// WithStorageBuffer8BitAccess sets the value for the StorageBuffer8BitAccess on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice8BitStorageFeatures) WithStorageBuffer8BitAccess(y Bool32) PhysicalDevice8BitStorageFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.storageBuffer8BitAccess = *ptr
	return x
}

// UniformAndStorageBuffer8BitAccess returns the value of uniformAndStorageBuffer8BitAccess from VkPhysicalDevice8BitStorageFeatures
func (x PhysicalDevice8BitStorageFeatures) UniformAndStorageBuffer8BitAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.uniformAndStorageBuffer8BitAccess)
	return *ptr
}

// WithUniformAndStorageBuffer8BitAccess sets the value for the UniformAndStorageBuffer8BitAccess on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice8BitStorageFeatures) WithUniformAndStorageBuffer8BitAccess(y Bool32) PhysicalDevice8BitStorageFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.uniformAndStorageBuffer8BitAccess = *ptr
	return x
}

// StoragePushConstant8 returns the value of storagePushConstant8 from VkPhysicalDevice8BitStorageFeatures
func (x PhysicalDevice8BitStorageFeatures) StoragePushConstant8() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storagePushConstant8)
	return *ptr
}

// WithStoragePushConstant8 sets the value for the StoragePushConstant8 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice8BitStorageFeatures) WithStoragePushConstant8(y Bool32) PhysicalDevice8BitStorageFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.storagePushConstant8 = *ptr
	return x
}

//SemaphoreSignalInfo provides a go interface for VkSemaphoreSignalInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSemaphoreSignalInfo.html
type SemaphoreSignalInfo C.struct_VkSemaphoreSignalInfo

// SizeofSemaphoreSignalInfo is the memory size of a SemaphoreSignalInfo
var SizeofSemaphoreSignalInfo int = int(unsafe.Sizeof(SemaphoreSignalInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SemaphoreSignalInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SemaphoreSignalInfo) AsCPtr() *SemaphoreSignalInfo {
	clone := (*SemaphoreSignalInfo)(newCBlock(C.ulong(SizeofSemaphoreSignalInfo)))
	*clone = x
	return clone
}

// SemaphoreSignalInfoFreeCSlice releases the memory allocated by SemaphoreSignalInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SemaphoreSignalInfoFreeCSlice(x []SemaphoreSignalInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SemaphoreSignalInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SemaphoreSignalInfoFreeCSlice must be called on the returned slice.
func SemaphoreSignalInfoMakeCSlice(x ...SemaphoreSignalInfo) []SemaphoreSignalInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSemaphoreSignalInfo * len(x)
	dst := unsafe.Slice((*SemaphoreSignalInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSemaphoreSignalInfo
func (x SemaphoreSignalInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SemaphoreSignalInfo) WithDefaultSType() SemaphoreSignalInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreSignalInfo) WithSType(y StructureType) SemaphoreSignalInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkSemaphoreSignalInfo
func (x SemaphoreSignalInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreSignalInfo) WithPNext(y unsafe.Pointer) SemaphoreSignalInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Semaphore returns the value of semaphore from VkSemaphoreSignalInfo
func (x SemaphoreSignalInfo) Semaphore() Semaphore {
	ptr := /* handle */ (*Semaphore)(&x.semaphore)
	return *ptr
}

// WithSemaphore sets the value for the Semaphore on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreSignalInfo) WithSemaphore(y Semaphore) SemaphoreSignalInfo {
	ptr := /* handle */ (*C.VkSemaphore)(&y)
	x.semaphore = *ptr
	return x
}

// Value returns the value of value from VkSemaphoreSignalInfo
func (x SemaphoreSignalInfo) Value() uint64 {
	ptr := func(x *C.ulonglong) *uint64 { /* Scalar */ return (*uint64)(unsafe.Pointer(x)) }(&x.value)
	return *ptr
}

// WithValue sets the value for the Value on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreSignalInfo) WithValue(y uint64) SemaphoreSignalInfo {
	ptr := func(x *uint64) *C.ulonglong { /* Scalar */ return (*C.ulonglong)(unsafe.Pointer(x)) }(&y)
	x.value = *ptr
	return x
}

//ConformanceVersion provides a go interface for VkConformanceVersion.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkConformanceVersion.html
type ConformanceVersion C.struct_VkConformanceVersion

// SizeofConformanceVersion is the memory size of a ConformanceVersion
var SizeofConformanceVersion int = int(unsafe.Sizeof(ConformanceVersion{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ConformanceVersion) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ConformanceVersion) AsCPtr() *ConformanceVersion {
	clone := (*ConformanceVersion)(newCBlock(C.ulong(SizeofConformanceVersion)))
	*clone = x
	return clone
}

// ConformanceVersionFreeCSlice releases the memory allocated by ConformanceVersionMakeCSlice.
// It does not free pointers stored inside the slice.
func ConformanceVersionFreeCSlice(x []ConformanceVersion) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ConformanceVersionMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ConformanceVersionFreeCSlice must be called on the returned slice.
func ConformanceVersionMakeCSlice(x ...ConformanceVersion) []ConformanceVersion {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofConformanceVersion * len(x)
	dst := unsafe.Slice((*ConformanceVersion)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Major returns the value of major from VkConformanceVersion
func (x ConformanceVersion) Major() byte {
	ptr := func(x *C.uchar) *byte { /* Scalar */ return (*byte)(unsafe.Pointer(x)) }(&x.major)
	return *ptr
}

// WithMajor sets the value for the Major on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ConformanceVersion) WithMajor(y byte) ConformanceVersion {
	ptr := func(x *byte) *C.uchar { /* Scalar */ return (*C.uchar)(unsafe.Pointer(x)) }(&y)
	x.major = *ptr
	return x
}

// Minor returns the value of minor from VkConformanceVersion
func (x ConformanceVersion) Minor() byte {
	ptr := func(x *C.uchar) *byte { /* Scalar */ return (*byte)(unsafe.Pointer(x)) }(&x.minor)
	return *ptr
}

// WithMinor sets the value for the Minor on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ConformanceVersion) WithMinor(y byte) ConformanceVersion {
	ptr := func(x *byte) *C.uchar { /* Scalar */ return (*C.uchar)(unsafe.Pointer(x)) }(&y)
	x.minor = *ptr
	return x
}

// Subminor returns the value of subminor from VkConformanceVersion
func (x ConformanceVersion) Subminor() byte {
	ptr := func(x *C.uchar) *byte { /* Scalar */ return (*byte)(unsafe.Pointer(x)) }(&x.subminor)
	return *ptr
}

// WithSubminor sets the value for the Subminor on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ConformanceVersion) WithSubminor(y byte) ConformanceVersion {
	ptr := func(x *byte) *C.uchar { /* Scalar */ return (*C.uchar)(unsafe.Pointer(x)) }(&y)
	x.subminor = *ptr
	return x
}

// Patch returns the value of patch from VkConformanceVersion
func (x ConformanceVersion) Patch() byte {
	ptr := func(x *C.uchar) *byte { /* Scalar */ return (*byte)(unsafe.Pointer(x)) }(&x.patch)
	return *ptr
}

// WithPatch sets the value for the Patch on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ConformanceVersion) WithPatch(y byte) ConformanceVersion {
	ptr := func(x *byte) *C.uchar { /* Scalar */ return (*C.uchar)(unsafe.Pointer(x)) }(&y)
	x.patch = *ptr
	return x
}

//PhysicalDeviceDriverProperties provides a go interface for VkPhysicalDeviceDriverProperties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceDriverProperties.html
type PhysicalDeviceDriverProperties C.struct_VkPhysicalDeviceDriverProperties

// SizeofPhysicalDeviceDriverProperties is the memory size of a PhysicalDeviceDriverProperties
var SizeofPhysicalDeviceDriverProperties int = int(unsafe.Sizeof(PhysicalDeviceDriverProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceDriverProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceDriverProperties) AsCPtr() *PhysicalDeviceDriverProperties {
	clone := (*PhysicalDeviceDriverProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceDriverProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceDriverPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceDriverPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceDriverPropertiesFreeCSlice(x []PhysicalDeviceDriverProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceDriverPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceDriverPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceDriverPropertiesMakeCSlice(x ...PhysicalDeviceDriverProperties) []PhysicalDeviceDriverProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceDriverProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceDriverProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceDriverProperties
func (x PhysicalDeviceDriverProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceDriverProperties) WithDefaultSType() PhysicalDeviceDriverProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDriverProperties) WithSType(y StructureType) PhysicalDeviceDriverProperties {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceDriverProperties
func (x PhysicalDeviceDriverProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDriverProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceDriverProperties {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// DriverID returns the value of driverID from VkPhysicalDeviceDriverProperties
func (x PhysicalDeviceDriverProperties) DriverID() DriverId {
	ptr := /* typedef */ (*DriverId)(&x.driverID)
	return *ptr
}

// DriverName returns the value of driverName from VkPhysicalDeviceDriverProperties
func (x PhysicalDeviceDriverProperties) DriverName() []byte {
	ptr := func(x *[VK_MAX_DRIVER_NAME_SIZE]C.char) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_DRIVER_NAME_SIZE)
		return &slc
	}(&x.driverName)
	return *ptr
}

// DriverInfo returns the value of driverInfo from VkPhysicalDeviceDriverProperties
func (x PhysicalDeviceDriverProperties) DriverInfo() []byte {
	ptr := func(x *[VK_MAX_DRIVER_INFO_SIZE]C.char) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_DRIVER_INFO_SIZE)
		return &slc
	}(&x.driverInfo)
	return *ptr
}

// ConformanceVersion returns the value of conformanceVersion from VkPhysicalDeviceDriverProperties
func (x PhysicalDeviceDriverProperties) ConformanceVersion() ConformanceVersion {
	ptr := /* typedef */ (*ConformanceVersion)(&x.conformanceVersion)
	return *ptr
}

//PhysicalDeviceBufferDeviceAddressFeatures provides a go interface for VkPhysicalDeviceBufferDeviceAddressFeatures.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceBufferDeviceAddressFeatures.html
type PhysicalDeviceBufferDeviceAddressFeatures C.struct_VkPhysicalDeviceBufferDeviceAddressFeatures

// SizeofPhysicalDeviceBufferDeviceAddressFeatures is the memory size of a PhysicalDeviceBufferDeviceAddressFeatures
var SizeofPhysicalDeviceBufferDeviceAddressFeatures int = int(unsafe.Sizeof(PhysicalDeviceBufferDeviceAddressFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceBufferDeviceAddressFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceBufferDeviceAddressFeatures) AsCPtr() *PhysicalDeviceBufferDeviceAddressFeatures {
	clone := (*PhysicalDeviceBufferDeviceAddressFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceBufferDeviceAddressFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceBufferDeviceAddressFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceBufferDeviceAddressFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceBufferDeviceAddressFeaturesFreeCSlice(x []PhysicalDeviceBufferDeviceAddressFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceBufferDeviceAddressFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceBufferDeviceAddressFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceBufferDeviceAddressFeaturesMakeCSlice(x ...PhysicalDeviceBufferDeviceAddressFeatures) []PhysicalDeviceBufferDeviceAddressFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceBufferDeviceAddressFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceBufferDeviceAddressFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceBufferDeviceAddressFeatures
func (x PhysicalDeviceBufferDeviceAddressFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceBufferDeviceAddressFeatures) WithDefaultSType() PhysicalDeviceBufferDeviceAddressFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceBufferDeviceAddressFeatures) WithSType(y StructureType) PhysicalDeviceBufferDeviceAddressFeatures {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceBufferDeviceAddressFeatures
func (x PhysicalDeviceBufferDeviceAddressFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceBufferDeviceAddressFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceBufferDeviceAddressFeatures {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// BufferDeviceAddress returns the value of bufferDeviceAddress from VkPhysicalDeviceBufferDeviceAddressFeatures
func (x PhysicalDeviceBufferDeviceAddressFeatures) BufferDeviceAddress() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.bufferDeviceAddress)
	return *ptr
}

// WithBufferDeviceAddress sets the value for the BufferDeviceAddress on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceBufferDeviceAddressFeatures) WithBufferDeviceAddress(y Bool32) PhysicalDeviceBufferDeviceAddressFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.bufferDeviceAddress = *ptr
	return x
}

// BufferDeviceAddressCaptureReplay returns the value of bufferDeviceAddressCaptureReplay from VkPhysicalDeviceBufferDeviceAddressFeatures
func (x PhysicalDeviceBufferDeviceAddressFeatures) BufferDeviceAddressCaptureReplay() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.bufferDeviceAddressCaptureReplay)
	return *ptr
}

// WithBufferDeviceAddressCaptureReplay sets the value for the BufferDeviceAddressCaptureReplay on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceBufferDeviceAddressFeatures) WithBufferDeviceAddressCaptureReplay(y Bool32) PhysicalDeviceBufferDeviceAddressFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.bufferDeviceAddressCaptureReplay = *ptr
	return x
}

// BufferDeviceAddressMultiDevice returns the value of bufferDeviceAddressMultiDevice from VkPhysicalDeviceBufferDeviceAddressFeatures
func (x PhysicalDeviceBufferDeviceAddressFeatures) BufferDeviceAddressMultiDevice() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.bufferDeviceAddressMultiDevice)
	return *ptr
}

// WithBufferDeviceAddressMultiDevice sets the value for the BufferDeviceAddressMultiDevice on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceBufferDeviceAddressFeatures) WithBufferDeviceAddressMultiDevice(y Bool32) PhysicalDeviceBufferDeviceAddressFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.bufferDeviceAddressMultiDevice = *ptr
	return x
}

//BufferDeviceAddressInfo provides a go interface for VkBufferDeviceAddressInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBufferDeviceAddressInfo.html
type BufferDeviceAddressInfo C.struct_VkBufferDeviceAddressInfo

// SizeofBufferDeviceAddressInfo is the memory size of a BufferDeviceAddressInfo
var SizeofBufferDeviceAddressInfo int = int(unsafe.Sizeof(BufferDeviceAddressInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferDeviceAddressInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferDeviceAddressInfo) AsCPtr() *BufferDeviceAddressInfo {
	clone := (*BufferDeviceAddressInfo)(newCBlock(C.ulong(SizeofBufferDeviceAddressInfo)))
	*clone = x
	return clone
}

// BufferDeviceAddressInfoFreeCSlice releases the memory allocated by BufferDeviceAddressInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BufferDeviceAddressInfoFreeCSlice(x []BufferDeviceAddressInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferDeviceAddressInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferDeviceAddressInfoFreeCSlice must be called on the returned slice.
func BufferDeviceAddressInfoMakeCSlice(x ...BufferDeviceAddressInfo) []BufferDeviceAddressInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferDeviceAddressInfo * len(x)
	dst := unsafe.Slice((*BufferDeviceAddressInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBufferDeviceAddressInfo
func (x BufferDeviceAddressInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BufferDeviceAddressInfo) WithDefaultSType() BufferDeviceAddressInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferDeviceAddressInfo) WithSType(y StructureType) BufferDeviceAddressInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkBufferDeviceAddressInfo
func (x BufferDeviceAddressInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferDeviceAddressInfo) WithPNext(y unsafe.Pointer) BufferDeviceAddressInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Buffer returns the value of buffer from VkBufferDeviceAddressInfo
func (x BufferDeviceAddressInfo) Buffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.buffer)
	return *ptr
}

// WithBuffer sets the value for the Buffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferDeviceAddressInfo) WithBuffer(y Buffer) BufferDeviceAddressInfo {
	ptr := /* handle */ (*C.VkBuffer)(&y)
	x.buffer = *ptr
	return x
}

//PhysicalDeviceShaderAtomicInt64Features provides a go interface for VkPhysicalDeviceShaderAtomicInt64Features.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderAtomicInt64Features.html
type PhysicalDeviceShaderAtomicInt64Features C.struct_VkPhysicalDeviceShaderAtomicInt64Features

// SizeofPhysicalDeviceShaderAtomicInt64Features is the memory size of a PhysicalDeviceShaderAtomicInt64Features
var SizeofPhysicalDeviceShaderAtomicInt64Features int = int(unsafe.Sizeof(PhysicalDeviceShaderAtomicInt64Features{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceShaderAtomicInt64Features) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceShaderAtomicInt64Features) AsCPtr() *PhysicalDeviceShaderAtomicInt64Features {
	clone := (*PhysicalDeviceShaderAtomicInt64Features)(newCBlock(C.ulong(SizeofPhysicalDeviceShaderAtomicInt64Features)))
	*clone = x
	return clone
}

// PhysicalDeviceShaderAtomicInt64FeaturesFreeCSlice releases the memory allocated by PhysicalDeviceShaderAtomicInt64FeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceShaderAtomicInt64FeaturesFreeCSlice(x []PhysicalDeviceShaderAtomicInt64Features) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceShaderAtomicInt64FeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceShaderAtomicInt64FeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceShaderAtomicInt64FeaturesMakeCSlice(x ...PhysicalDeviceShaderAtomicInt64Features) []PhysicalDeviceShaderAtomicInt64Features {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderAtomicInt64Features * len(x)
	dst := unsafe.Slice((*PhysicalDeviceShaderAtomicInt64Features)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceShaderAtomicInt64Features
func (x PhysicalDeviceShaderAtomicInt64Features) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceShaderAtomicInt64Features) WithDefaultSType() PhysicalDeviceShaderAtomicInt64Features {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderAtomicInt64Features) WithSType(y StructureType) PhysicalDeviceShaderAtomicInt64Features {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceShaderAtomicInt64Features
func (x PhysicalDeviceShaderAtomicInt64Features) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderAtomicInt64Features) WithPNext(y unsafe.Pointer) PhysicalDeviceShaderAtomicInt64Features {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// ShaderBufferInt64Atomics returns the value of shaderBufferInt64Atomics from VkPhysicalDeviceShaderAtomicInt64Features
func (x PhysicalDeviceShaderAtomicInt64Features) ShaderBufferInt64Atomics() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderBufferInt64Atomics)
	return *ptr
}

// WithShaderBufferInt64Atomics sets the value for the ShaderBufferInt64Atomics on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderAtomicInt64Features) WithShaderBufferInt64Atomics(y Bool32) PhysicalDeviceShaderAtomicInt64Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderBufferInt64Atomics = *ptr
	return x
}

// ShaderSharedInt64Atomics returns the value of shaderSharedInt64Atomics from VkPhysicalDeviceShaderAtomicInt64Features
func (x PhysicalDeviceShaderAtomicInt64Features) ShaderSharedInt64Atomics() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSharedInt64Atomics)
	return *ptr
}

// WithShaderSharedInt64Atomics sets the value for the ShaderSharedInt64Atomics on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderAtomicInt64Features) WithShaderSharedInt64Atomics(y Bool32) PhysicalDeviceShaderAtomicInt64Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderSharedInt64Atomics = *ptr
	return x
}

//PhysicalDeviceShaderFloat16Int8Features provides a go interface for VkPhysicalDeviceShaderFloat16Int8Features.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderFloat16Int8Features.html
type PhysicalDeviceShaderFloat16Int8Features C.struct_VkPhysicalDeviceShaderFloat16Int8Features

// SizeofPhysicalDeviceShaderFloat16Int8Features is the memory size of a PhysicalDeviceShaderFloat16Int8Features
var SizeofPhysicalDeviceShaderFloat16Int8Features int = int(unsafe.Sizeof(PhysicalDeviceShaderFloat16Int8Features{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceShaderFloat16Int8Features) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceShaderFloat16Int8Features) AsCPtr() *PhysicalDeviceShaderFloat16Int8Features {
	clone := (*PhysicalDeviceShaderFloat16Int8Features)(newCBlock(C.ulong(SizeofPhysicalDeviceShaderFloat16Int8Features)))
	*clone = x
	return clone
}

// PhysicalDeviceShaderFloat16Int8FeaturesFreeCSlice releases the memory allocated by PhysicalDeviceShaderFloat16Int8FeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceShaderFloat16Int8FeaturesFreeCSlice(x []PhysicalDeviceShaderFloat16Int8Features) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceShaderFloat16Int8FeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceShaderFloat16Int8FeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceShaderFloat16Int8FeaturesMakeCSlice(x ...PhysicalDeviceShaderFloat16Int8Features) []PhysicalDeviceShaderFloat16Int8Features {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderFloat16Int8Features * len(x)
	dst := unsafe.Slice((*PhysicalDeviceShaderFloat16Int8Features)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceShaderFloat16Int8Features
func (x PhysicalDeviceShaderFloat16Int8Features) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceShaderFloat16Int8Features) WithDefaultSType() PhysicalDeviceShaderFloat16Int8Features {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderFloat16Int8Features) WithSType(y StructureType) PhysicalDeviceShaderFloat16Int8Features {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceShaderFloat16Int8Features
func (x PhysicalDeviceShaderFloat16Int8Features) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderFloat16Int8Features) WithPNext(y unsafe.Pointer) PhysicalDeviceShaderFloat16Int8Features {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// ShaderFloat16 returns the value of shaderFloat16 from VkPhysicalDeviceShaderFloat16Int8Features
func (x PhysicalDeviceShaderFloat16Int8Features) ShaderFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderFloat16)
	return *ptr
}

// WithShaderFloat16 sets the value for the ShaderFloat16 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderFloat16Int8Features) WithShaderFloat16(y Bool32) PhysicalDeviceShaderFloat16Int8Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderFloat16 = *ptr
	return x
}

// ShaderInt8 returns the value of shaderInt8 from VkPhysicalDeviceShaderFloat16Int8Features
func (x PhysicalDeviceShaderFloat16Int8Features) ShaderInt8() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInt8)
	return *ptr
}

// WithShaderInt8 sets the value for the ShaderInt8 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderFloat16Int8Features) WithShaderInt8(y Bool32) PhysicalDeviceShaderFloat16Int8Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderInt8 = *ptr
	return x
}

//PhysicalDeviceFloatControlsProperties provides a go interface for VkPhysicalDeviceFloatControlsProperties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFloatControlsProperties.html
type PhysicalDeviceFloatControlsProperties C.struct_VkPhysicalDeviceFloatControlsProperties

// SizeofPhysicalDeviceFloatControlsProperties is the memory size of a PhysicalDeviceFloatControlsProperties
var SizeofPhysicalDeviceFloatControlsProperties int = int(unsafe.Sizeof(PhysicalDeviceFloatControlsProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceFloatControlsProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceFloatControlsProperties) AsCPtr() *PhysicalDeviceFloatControlsProperties {
	clone := (*PhysicalDeviceFloatControlsProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceFloatControlsProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceFloatControlsPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceFloatControlsPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceFloatControlsPropertiesFreeCSlice(x []PhysicalDeviceFloatControlsProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceFloatControlsPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceFloatControlsPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceFloatControlsPropertiesMakeCSlice(x ...PhysicalDeviceFloatControlsProperties) []PhysicalDeviceFloatControlsProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceFloatControlsProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceFloatControlsProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceFloatControlsProperties) WithDefaultSType() PhysicalDeviceFloatControlsProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFloatControlsProperties) WithSType(y StructureType) PhysicalDeviceFloatControlsProperties {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFloatControlsProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceFloatControlsProperties {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// DenormBehaviorIndependence returns the value of denormBehaviorIndependence from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) DenormBehaviorIndependence() ShaderFloatControlsIndependence {
	ptr := /* typedef */ (*ShaderFloatControlsIndependence)(&x.denormBehaviorIndependence)
	return *ptr
}

// RoundingModeIndependence returns the value of roundingModeIndependence from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) RoundingModeIndependence() ShaderFloatControlsIndependence {
	ptr := /* typedef */ (*ShaderFloatControlsIndependence)(&x.roundingModeIndependence)
	return *ptr
}

// ShaderSignedZeroInfNanPreserveFloat16 returns the value of shaderSignedZeroInfNanPreserveFloat16 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderSignedZeroInfNanPreserveFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSignedZeroInfNanPreserveFloat16)
	return *ptr
}

// ShaderSignedZeroInfNanPreserveFloat32 returns the value of shaderSignedZeroInfNanPreserveFloat32 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderSignedZeroInfNanPreserveFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSignedZeroInfNanPreserveFloat32)
	return *ptr
}

// ShaderSignedZeroInfNanPreserveFloat64 returns the value of shaderSignedZeroInfNanPreserveFloat64 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderSignedZeroInfNanPreserveFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSignedZeroInfNanPreserveFloat64)
	return *ptr
}

// ShaderDenormPreserveFloat16 returns the value of shaderDenormPreserveFloat16 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderDenormPreserveFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormPreserveFloat16)
	return *ptr
}

// ShaderDenormPreserveFloat32 returns the value of shaderDenormPreserveFloat32 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderDenormPreserveFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormPreserveFloat32)
	return *ptr
}

// ShaderDenormPreserveFloat64 returns the value of shaderDenormPreserveFloat64 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderDenormPreserveFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormPreserveFloat64)
	return *ptr
}

// ShaderDenormFlushToZeroFloat16 returns the value of shaderDenormFlushToZeroFloat16 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderDenormFlushToZeroFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormFlushToZeroFloat16)
	return *ptr
}

// ShaderDenormFlushToZeroFloat32 returns the value of shaderDenormFlushToZeroFloat32 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderDenormFlushToZeroFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormFlushToZeroFloat32)
	return *ptr
}

// ShaderDenormFlushToZeroFloat64 returns the value of shaderDenormFlushToZeroFloat64 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderDenormFlushToZeroFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormFlushToZeroFloat64)
	return *ptr
}

// ShaderRoundingModeRTEFloat16 returns the value of shaderRoundingModeRTEFloat16 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderRoundingModeRTEFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTEFloat16)
	return *ptr
}

// ShaderRoundingModeRTEFloat32 returns the value of shaderRoundingModeRTEFloat32 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderRoundingModeRTEFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTEFloat32)
	return *ptr
}

// ShaderRoundingModeRTEFloat64 returns the value of shaderRoundingModeRTEFloat64 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderRoundingModeRTEFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTEFloat64)
	return *ptr
}

// ShaderRoundingModeRTZFloat16 returns the value of shaderRoundingModeRTZFloat16 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderRoundingModeRTZFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTZFloat16)
	return *ptr
}

// ShaderRoundingModeRTZFloat32 returns the value of shaderRoundingModeRTZFloat32 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderRoundingModeRTZFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTZFloat32)
	return *ptr
}

// ShaderRoundingModeRTZFloat64 returns the value of shaderRoundingModeRTZFloat64 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderRoundingModeRTZFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTZFloat64)
	return *ptr
}

//BufferOpaqueCaptureAddressCreateInfo provides a go interface for VkBufferOpaqueCaptureAddressCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBufferOpaqueCaptureAddressCreateInfo.html
type BufferOpaqueCaptureAddressCreateInfo C.struct_VkBufferOpaqueCaptureAddressCreateInfo

// SizeofBufferOpaqueCaptureAddressCreateInfo is the memory size of a BufferOpaqueCaptureAddressCreateInfo
var SizeofBufferOpaqueCaptureAddressCreateInfo int = int(unsafe.Sizeof(BufferOpaqueCaptureAddressCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferOpaqueCaptureAddressCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferOpaqueCaptureAddressCreateInfo) AsCPtr() *BufferOpaqueCaptureAddressCreateInfo {
	clone := (*BufferOpaqueCaptureAddressCreateInfo)(newCBlock(C.ulong(SizeofBufferOpaqueCaptureAddressCreateInfo)))
	*clone = x
	return clone
}

// BufferOpaqueCaptureAddressCreateInfoFreeCSlice releases the memory allocated by BufferOpaqueCaptureAddressCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BufferOpaqueCaptureAddressCreateInfoFreeCSlice(x []BufferOpaqueCaptureAddressCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferOpaqueCaptureAddressCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferOpaqueCaptureAddressCreateInfoFreeCSlice must be called on the returned slice.
func BufferOpaqueCaptureAddressCreateInfoMakeCSlice(x ...BufferOpaqueCaptureAddressCreateInfo) []BufferOpaqueCaptureAddressCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferOpaqueCaptureAddressCreateInfo * len(x)
	dst := unsafe.Slice((*BufferOpaqueCaptureAddressCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBufferOpaqueCaptureAddressCreateInfo
func (x BufferOpaqueCaptureAddressCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BufferOpaqueCaptureAddressCreateInfo) WithDefaultSType() BufferOpaqueCaptureAddressCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferOpaqueCaptureAddressCreateInfo) WithSType(y StructureType) BufferOpaqueCaptureAddressCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkBufferOpaqueCaptureAddressCreateInfo
func (x BufferOpaqueCaptureAddressCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferOpaqueCaptureAddressCreateInfo) WithPNext(y unsafe.Pointer) BufferOpaqueCaptureAddressCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// OpaqueCaptureAddress returns the value of opaqueCaptureAddress from VkBufferOpaqueCaptureAddressCreateInfo
func (x BufferOpaqueCaptureAddressCreateInfo) OpaqueCaptureAddress() uint64 {
	ptr := func(x *C.ulonglong) *uint64 { /* Scalar */ return (*uint64)(unsafe.Pointer(x)) }(&x.opaqueCaptureAddress)
	return *ptr
}

// WithOpaqueCaptureAddress sets the value for the OpaqueCaptureAddress on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferOpaqueCaptureAddressCreateInfo) WithOpaqueCaptureAddress(y uint64) BufferOpaqueCaptureAddressCreateInfo {
	ptr := func(x *uint64) *C.ulonglong { /* Scalar */ return (*C.ulonglong)(unsafe.Pointer(x)) }(&y)
	x.opaqueCaptureAddress = *ptr
	return x
}

//MemoryOpaqueCaptureAddressAllocateInfo provides a go interface for VkMemoryOpaqueCaptureAddressAllocateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkMemoryOpaqueCaptureAddressAllocateInfo.html
type MemoryOpaqueCaptureAddressAllocateInfo C.struct_VkMemoryOpaqueCaptureAddressAllocateInfo

// SizeofMemoryOpaqueCaptureAddressAllocateInfo is the memory size of a MemoryOpaqueCaptureAddressAllocateInfo
var SizeofMemoryOpaqueCaptureAddressAllocateInfo int = int(unsafe.Sizeof(MemoryOpaqueCaptureAddressAllocateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryOpaqueCaptureAddressAllocateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryOpaqueCaptureAddressAllocateInfo) AsCPtr() *MemoryOpaqueCaptureAddressAllocateInfo {
	clone := (*MemoryOpaqueCaptureAddressAllocateInfo)(newCBlock(C.ulong(SizeofMemoryOpaqueCaptureAddressAllocateInfo)))
	*clone = x
	return clone
}

// MemoryOpaqueCaptureAddressAllocateInfoFreeCSlice releases the memory allocated by MemoryOpaqueCaptureAddressAllocateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryOpaqueCaptureAddressAllocateInfoFreeCSlice(x []MemoryOpaqueCaptureAddressAllocateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryOpaqueCaptureAddressAllocateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryOpaqueCaptureAddressAllocateInfoFreeCSlice must be called on the returned slice.
func MemoryOpaqueCaptureAddressAllocateInfoMakeCSlice(x ...MemoryOpaqueCaptureAddressAllocateInfo) []MemoryOpaqueCaptureAddressAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryOpaqueCaptureAddressAllocateInfo * len(x)
	dst := unsafe.Slice((*MemoryOpaqueCaptureAddressAllocateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkMemoryOpaqueCaptureAddressAllocateInfo
func (x MemoryOpaqueCaptureAddressAllocateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x MemoryOpaqueCaptureAddressAllocateInfo) WithDefaultSType() MemoryOpaqueCaptureAddressAllocateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryOpaqueCaptureAddressAllocateInfo) WithSType(y StructureType) MemoryOpaqueCaptureAddressAllocateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkMemoryOpaqueCaptureAddressAllocateInfo
func (x MemoryOpaqueCaptureAddressAllocateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryOpaqueCaptureAddressAllocateInfo) WithPNext(y unsafe.Pointer) MemoryOpaqueCaptureAddressAllocateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// OpaqueCaptureAddress returns the value of opaqueCaptureAddress from VkMemoryOpaqueCaptureAddressAllocateInfo
func (x MemoryOpaqueCaptureAddressAllocateInfo) OpaqueCaptureAddress() uint64 {
	ptr := func(x *C.ulonglong) *uint64 { /* Scalar */ return (*uint64)(unsafe.Pointer(x)) }(&x.opaqueCaptureAddress)
	return *ptr
}

// WithOpaqueCaptureAddress sets the value for the OpaqueCaptureAddress on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryOpaqueCaptureAddressAllocateInfo) WithOpaqueCaptureAddress(y uint64) MemoryOpaqueCaptureAddressAllocateInfo {
	ptr := func(x *uint64) *C.ulonglong { /* Scalar */ return (*C.ulonglong)(unsafe.Pointer(x)) }(&y)
	x.opaqueCaptureAddress = *ptr
	return x
}

//PhysicalDeviceDescriptorIndexingFeatures provides a go interface for VkPhysicalDeviceDescriptorIndexingFeatures.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceDescriptorIndexingFeatures.html
type PhysicalDeviceDescriptorIndexingFeatures C.struct_VkPhysicalDeviceDescriptorIndexingFeatures

// SizeofPhysicalDeviceDescriptorIndexingFeatures is the memory size of a PhysicalDeviceDescriptorIndexingFeatures
var SizeofPhysicalDeviceDescriptorIndexingFeatures int = int(unsafe.Sizeof(PhysicalDeviceDescriptorIndexingFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceDescriptorIndexingFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceDescriptorIndexingFeatures) AsCPtr() *PhysicalDeviceDescriptorIndexingFeatures {
	clone := (*PhysicalDeviceDescriptorIndexingFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceDescriptorIndexingFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceDescriptorIndexingFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceDescriptorIndexingFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceDescriptorIndexingFeaturesFreeCSlice(x []PhysicalDeviceDescriptorIndexingFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceDescriptorIndexingFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceDescriptorIndexingFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceDescriptorIndexingFeaturesMakeCSlice(x ...PhysicalDeviceDescriptorIndexingFeatures) []PhysicalDeviceDescriptorIndexingFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceDescriptorIndexingFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceDescriptorIndexingFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDefaultSType() PhysicalDeviceDescriptorIndexingFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithSType(y StructureType) PhysicalDeviceDescriptorIndexingFeatures {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceDescriptorIndexingFeatures {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// ShaderInputAttachmentArrayDynamicIndexing returns the value of shaderInputAttachmentArrayDynamicIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderInputAttachmentArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInputAttachmentArrayDynamicIndexing)
	return *ptr
}

// WithShaderInputAttachmentArrayDynamicIndexing sets the value for the ShaderInputAttachmentArrayDynamicIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderInputAttachmentArrayDynamicIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderInputAttachmentArrayDynamicIndexing = *ptr
	return x
}

// ShaderUniformTexelBufferArrayDynamicIndexing returns the value of shaderUniformTexelBufferArrayDynamicIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderUniformTexelBufferArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderUniformTexelBufferArrayDynamicIndexing)
	return *ptr
}

// WithShaderUniformTexelBufferArrayDynamicIndexing sets the value for the ShaderUniformTexelBufferArrayDynamicIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderUniformTexelBufferArrayDynamicIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderUniformTexelBufferArrayDynamicIndexing = *ptr
	return x
}

// ShaderStorageTexelBufferArrayDynamicIndexing returns the value of shaderStorageTexelBufferArrayDynamicIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderStorageTexelBufferArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageTexelBufferArrayDynamicIndexing)
	return *ptr
}

// WithShaderStorageTexelBufferArrayDynamicIndexing sets the value for the ShaderStorageTexelBufferArrayDynamicIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderStorageTexelBufferArrayDynamicIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderStorageTexelBufferArrayDynamicIndexing = *ptr
	return x
}

// ShaderUniformBufferArrayNonUniformIndexing returns the value of shaderUniformBufferArrayNonUniformIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderUniformBufferArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderUniformBufferArrayNonUniformIndexing)
	return *ptr
}

// WithShaderUniformBufferArrayNonUniformIndexing sets the value for the ShaderUniformBufferArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderUniformBufferArrayNonUniformIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderUniformBufferArrayNonUniformIndexing = *ptr
	return x
}

// ShaderSampledImageArrayNonUniformIndexing returns the value of shaderSampledImageArrayNonUniformIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderSampledImageArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSampledImageArrayNonUniformIndexing)
	return *ptr
}

// WithShaderSampledImageArrayNonUniformIndexing sets the value for the ShaderSampledImageArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderSampledImageArrayNonUniformIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderSampledImageArrayNonUniformIndexing = *ptr
	return x
}

// ShaderStorageBufferArrayNonUniformIndexing returns the value of shaderStorageBufferArrayNonUniformIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderStorageBufferArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageBufferArrayNonUniformIndexing)
	return *ptr
}

// WithShaderStorageBufferArrayNonUniformIndexing sets the value for the ShaderStorageBufferArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderStorageBufferArrayNonUniformIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderStorageBufferArrayNonUniformIndexing = *ptr
	return x
}

// ShaderStorageImageArrayNonUniformIndexing returns the value of shaderStorageImageArrayNonUniformIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderStorageImageArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageImageArrayNonUniformIndexing)
	return *ptr
}

// WithShaderStorageImageArrayNonUniformIndexing sets the value for the ShaderStorageImageArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderStorageImageArrayNonUniformIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderStorageImageArrayNonUniformIndexing = *ptr
	return x
}

// ShaderInputAttachmentArrayNonUniformIndexing returns the value of shaderInputAttachmentArrayNonUniformIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderInputAttachmentArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInputAttachmentArrayNonUniformIndexing)
	return *ptr
}

// WithShaderInputAttachmentArrayNonUniformIndexing sets the value for the ShaderInputAttachmentArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderInputAttachmentArrayNonUniformIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderInputAttachmentArrayNonUniformIndexing = *ptr
	return x
}

// ShaderUniformTexelBufferArrayNonUniformIndexing returns the value of shaderUniformTexelBufferArrayNonUniformIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderUniformTexelBufferArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderUniformTexelBufferArrayNonUniformIndexing)
	return *ptr
}

// WithShaderUniformTexelBufferArrayNonUniformIndexing sets the value for the ShaderUniformTexelBufferArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderUniformTexelBufferArrayNonUniformIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderUniformTexelBufferArrayNonUniformIndexing = *ptr
	return x
}

// ShaderStorageTexelBufferArrayNonUniformIndexing returns the value of shaderStorageTexelBufferArrayNonUniformIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderStorageTexelBufferArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageTexelBufferArrayNonUniformIndexing)
	return *ptr
}

// WithShaderStorageTexelBufferArrayNonUniformIndexing sets the value for the ShaderStorageTexelBufferArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderStorageTexelBufferArrayNonUniformIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderStorageTexelBufferArrayNonUniformIndexing = *ptr
	return x
}

// DescriptorBindingUniformBufferUpdateAfterBind returns the value of descriptorBindingUniformBufferUpdateAfterBind from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) DescriptorBindingUniformBufferUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingUniformBufferUpdateAfterBind)
	return *ptr
}

// WithDescriptorBindingUniformBufferUpdateAfterBind sets the value for the DescriptorBindingUniformBufferUpdateAfterBind on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDescriptorBindingUniformBufferUpdateAfterBind(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.descriptorBindingUniformBufferUpdateAfterBind = *ptr
	return x
}

// DescriptorBindingSampledImageUpdateAfterBind returns the value of descriptorBindingSampledImageUpdateAfterBind from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) DescriptorBindingSampledImageUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingSampledImageUpdateAfterBind)
	return *ptr
}

// WithDescriptorBindingSampledImageUpdateAfterBind sets the value for the DescriptorBindingSampledImageUpdateAfterBind on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDescriptorBindingSampledImageUpdateAfterBind(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.descriptorBindingSampledImageUpdateAfterBind = *ptr
	return x
}

// DescriptorBindingStorageImageUpdateAfterBind returns the value of descriptorBindingStorageImageUpdateAfterBind from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) DescriptorBindingStorageImageUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingStorageImageUpdateAfterBind)
	return *ptr
}

// WithDescriptorBindingStorageImageUpdateAfterBind sets the value for the DescriptorBindingStorageImageUpdateAfterBind on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDescriptorBindingStorageImageUpdateAfterBind(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.descriptorBindingStorageImageUpdateAfterBind = *ptr
	return x
}

// DescriptorBindingStorageBufferUpdateAfterBind returns the value of descriptorBindingStorageBufferUpdateAfterBind from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) DescriptorBindingStorageBufferUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingStorageBufferUpdateAfterBind)
	return *ptr
}

// WithDescriptorBindingStorageBufferUpdateAfterBind sets the value for the DescriptorBindingStorageBufferUpdateAfterBind on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDescriptorBindingStorageBufferUpdateAfterBind(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.descriptorBindingStorageBufferUpdateAfterBind = *ptr
	return x
}

// DescriptorBindingUniformTexelBufferUpdateAfterBind returns the value of descriptorBindingUniformTexelBufferUpdateAfterBind from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) DescriptorBindingUniformTexelBufferUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingUniformTexelBufferUpdateAfterBind)
	return *ptr
}

// WithDescriptorBindingUniformTexelBufferUpdateAfterBind sets the value for the DescriptorBindingUniformTexelBufferUpdateAfterBind on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDescriptorBindingUniformTexelBufferUpdateAfterBind(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.descriptorBindingUniformTexelBufferUpdateAfterBind = *ptr
	return x
}

// DescriptorBindingStorageTexelBufferUpdateAfterBind returns the value of descriptorBindingStorageTexelBufferUpdateAfterBind from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) DescriptorBindingStorageTexelBufferUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingStorageTexelBufferUpdateAfterBind)
	return *ptr
}

// WithDescriptorBindingStorageTexelBufferUpdateAfterBind sets the value for the DescriptorBindingStorageTexelBufferUpdateAfterBind on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDescriptorBindingStorageTexelBufferUpdateAfterBind(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.descriptorBindingStorageTexelBufferUpdateAfterBind = *ptr
	return x
}

// DescriptorBindingUpdateUnusedWhilePending returns the value of descriptorBindingUpdateUnusedWhilePending from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) DescriptorBindingUpdateUnusedWhilePending() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingUpdateUnusedWhilePending)
	return *ptr
}

// WithDescriptorBindingUpdateUnusedWhilePending sets the value for the DescriptorBindingUpdateUnusedWhilePending on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDescriptorBindingUpdateUnusedWhilePending(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.descriptorBindingUpdateUnusedWhilePending = *ptr
	return x
}

// DescriptorBindingPartiallyBound returns the value of descriptorBindingPartiallyBound from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) DescriptorBindingPartiallyBound() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingPartiallyBound)
	return *ptr
}

// WithDescriptorBindingPartiallyBound sets the value for the DescriptorBindingPartiallyBound on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDescriptorBindingPartiallyBound(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.descriptorBindingPartiallyBound = *ptr
	return x
}

// DescriptorBindingVariableDescriptorCount returns the value of descriptorBindingVariableDescriptorCount from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) DescriptorBindingVariableDescriptorCount() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingVariableDescriptorCount)
	return *ptr
}

// WithDescriptorBindingVariableDescriptorCount sets the value for the DescriptorBindingVariableDescriptorCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDescriptorBindingVariableDescriptorCount(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.descriptorBindingVariableDescriptorCount = *ptr
	return x
}

// RuntimeDescriptorArray returns the value of runtimeDescriptorArray from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) RuntimeDescriptorArray() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.runtimeDescriptorArray)
	return *ptr
}

// WithRuntimeDescriptorArray sets the value for the RuntimeDescriptorArray on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithRuntimeDescriptorArray(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.runtimeDescriptorArray = *ptr
	return x
}

//PhysicalDeviceDescriptorIndexingProperties provides a go interface for VkPhysicalDeviceDescriptorIndexingProperties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceDescriptorIndexingProperties.html
type PhysicalDeviceDescriptorIndexingProperties C.struct_VkPhysicalDeviceDescriptorIndexingProperties

// SizeofPhysicalDeviceDescriptorIndexingProperties is the memory size of a PhysicalDeviceDescriptorIndexingProperties
var SizeofPhysicalDeviceDescriptorIndexingProperties int = int(unsafe.Sizeof(PhysicalDeviceDescriptorIndexingProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceDescriptorIndexingProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceDescriptorIndexingProperties) AsCPtr() *PhysicalDeviceDescriptorIndexingProperties {
	clone := (*PhysicalDeviceDescriptorIndexingProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceDescriptorIndexingProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceDescriptorIndexingPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceDescriptorIndexingPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceDescriptorIndexingPropertiesFreeCSlice(x []PhysicalDeviceDescriptorIndexingProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceDescriptorIndexingPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceDescriptorIndexingPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceDescriptorIndexingPropertiesMakeCSlice(x ...PhysicalDeviceDescriptorIndexingProperties) []PhysicalDeviceDescriptorIndexingProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceDescriptorIndexingProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceDescriptorIndexingProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceDescriptorIndexingProperties) WithDefaultSType() PhysicalDeviceDescriptorIndexingProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingProperties) WithSType(y StructureType) PhysicalDeviceDescriptorIndexingProperties {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceDescriptorIndexingProperties {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// MaxUpdateAfterBindDescriptorsInAllPools returns the value of maxUpdateAfterBindDescriptorsInAllPools from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxUpdateAfterBindDescriptorsInAllPools() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxUpdateAfterBindDescriptorsInAllPools)
	return *ptr
}

// ShaderUniformBufferArrayNonUniformIndexingNative returns the value of shaderUniformBufferArrayNonUniformIndexingNative from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) ShaderUniformBufferArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderUniformBufferArrayNonUniformIndexingNative)
	return *ptr
}

// ShaderSampledImageArrayNonUniformIndexingNative returns the value of shaderSampledImageArrayNonUniformIndexingNative from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) ShaderSampledImageArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSampledImageArrayNonUniformIndexingNative)
	return *ptr
}

// ShaderStorageBufferArrayNonUniformIndexingNative returns the value of shaderStorageBufferArrayNonUniformIndexingNative from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) ShaderStorageBufferArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageBufferArrayNonUniformIndexingNative)
	return *ptr
}

// ShaderStorageImageArrayNonUniformIndexingNative returns the value of shaderStorageImageArrayNonUniformIndexingNative from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) ShaderStorageImageArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageImageArrayNonUniformIndexingNative)
	return *ptr
}

// ShaderInputAttachmentArrayNonUniformIndexingNative returns the value of shaderInputAttachmentArrayNonUniformIndexingNative from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) ShaderInputAttachmentArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInputAttachmentArrayNonUniformIndexingNative)
	return *ptr
}

// RobustBufferAccessUpdateAfterBind returns the value of robustBufferAccessUpdateAfterBind from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) RobustBufferAccessUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.robustBufferAccessUpdateAfterBind)
	return *ptr
}

// QuadDivergentImplicitLod returns the value of quadDivergentImplicitLod from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) QuadDivergentImplicitLod() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.quadDivergentImplicitLod)
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindSamplers returns the value of maxPerStageDescriptorUpdateAfterBindSamplers from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxPerStageDescriptorUpdateAfterBindSamplers() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxPerStageDescriptorUpdateAfterBindSamplers)
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindUniformBuffers returns the value of maxPerStageDescriptorUpdateAfterBindUniformBuffers from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxPerStageDescriptorUpdateAfterBindUniformBuffers() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxPerStageDescriptorUpdateAfterBindUniformBuffers)
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindStorageBuffers returns the value of maxPerStageDescriptorUpdateAfterBindStorageBuffers from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxPerStageDescriptorUpdateAfterBindStorageBuffers() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxPerStageDescriptorUpdateAfterBindStorageBuffers)
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindSampledImages returns the value of maxPerStageDescriptorUpdateAfterBindSampledImages from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxPerStageDescriptorUpdateAfterBindSampledImages() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxPerStageDescriptorUpdateAfterBindSampledImages)
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindStorageImages returns the value of maxPerStageDescriptorUpdateAfterBindStorageImages from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxPerStageDescriptorUpdateAfterBindStorageImages() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxPerStageDescriptorUpdateAfterBindStorageImages)
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindInputAttachments returns the value of maxPerStageDescriptorUpdateAfterBindInputAttachments from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxPerStageDescriptorUpdateAfterBindInputAttachments() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxPerStageDescriptorUpdateAfterBindInputAttachments)
	return *ptr
}

// MaxPerStageUpdateAfterBindResources returns the value of maxPerStageUpdateAfterBindResources from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxPerStageUpdateAfterBindResources() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxPerStageUpdateAfterBindResources)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindSamplers returns the value of maxDescriptorSetUpdateAfterBindSamplers from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxDescriptorSetUpdateAfterBindSamplers() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxDescriptorSetUpdateAfterBindSamplers)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindUniformBuffers returns the value of maxDescriptorSetUpdateAfterBindUniformBuffers from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxDescriptorSetUpdateAfterBindUniformBuffers() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxDescriptorSetUpdateAfterBindUniformBuffers)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic returns the value of maxDescriptorSetUpdateAfterBindUniformBuffersDynamic from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindStorageBuffers returns the value of maxDescriptorSetUpdateAfterBindStorageBuffers from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxDescriptorSetUpdateAfterBindStorageBuffers() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxDescriptorSetUpdateAfterBindStorageBuffers)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic returns the value of maxDescriptorSetUpdateAfterBindStorageBuffersDynamic from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindSampledImages returns the value of maxDescriptorSetUpdateAfterBindSampledImages from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxDescriptorSetUpdateAfterBindSampledImages() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxDescriptorSetUpdateAfterBindSampledImages)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindStorageImages returns the value of maxDescriptorSetUpdateAfterBindStorageImages from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxDescriptorSetUpdateAfterBindStorageImages() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxDescriptorSetUpdateAfterBindStorageImages)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindInputAttachments returns the value of maxDescriptorSetUpdateAfterBindInputAttachments from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxDescriptorSetUpdateAfterBindInputAttachments() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxDescriptorSetUpdateAfterBindInputAttachments)
	return *ptr
}

//DescriptorSetVariableDescriptorCountAllocateInfo provides a go interface for VkDescriptorSetVariableDescriptorCountAllocateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorSetVariableDescriptorCountAllocateInfo.html
type DescriptorSetVariableDescriptorCountAllocateInfo C.struct_VkDescriptorSetVariableDescriptorCountAllocateInfo

// SizeofDescriptorSetVariableDescriptorCountAllocateInfo is the memory size of a DescriptorSetVariableDescriptorCountAllocateInfo
var SizeofDescriptorSetVariableDescriptorCountAllocateInfo int = int(unsafe.Sizeof(DescriptorSetVariableDescriptorCountAllocateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorSetVariableDescriptorCountAllocateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorSetVariableDescriptorCountAllocateInfo) AsCPtr() *DescriptorSetVariableDescriptorCountAllocateInfo {
	clone := (*DescriptorSetVariableDescriptorCountAllocateInfo)(newCBlock(C.ulong(SizeofDescriptorSetVariableDescriptorCountAllocateInfo)))
	*clone = x
	return clone
}

// DescriptorSetVariableDescriptorCountAllocateInfoFreeCSlice releases the memory allocated by DescriptorSetVariableDescriptorCountAllocateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorSetVariableDescriptorCountAllocateInfoFreeCSlice(x []DescriptorSetVariableDescriptorCountAllocateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorSetVariableDescriptorCountAllocateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorSetVariableDescriptorCountAllocateInfoFreeCSlice must be called on the returned slice.
func DescriptorSetVariableDescriptorCountAllocateInfoMakeCSlice(x ...DescriptorSetVariableDescriptorCountAllocateInfo) []DescriptorSetVariableDescriptorCountAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetVariableDescriptorCountAllocateInfo * len(x)
	dst := unsafe.Slice((*DescriptorSetVariableDescriptorCountAllocateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDescriptorSetVariableDescriptorCountAllocateInfo
func (x DescriptorSetVariableDescriptorCountAllocateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DescriptorSetVariableDescriptorCountAllocateInfo) WithDefaultSType() DescriptorSetVariableDescriptorCountAllocateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetVariableDescriptorCountAllocateInfo) WithSType(y StructureType) DescriptorSetVariableDescriptorCountAllocateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDescriptorSetVariableDescriptorCountAllocateInfo
func (x DescriptorSetVariableDescriptorCountAllocateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetVariableDescriptorCountAllocateInfo) WithPNext(y unsafe.Pointer) DescriptorSetVariableDescriptorCountAllocateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// DescriptorSetCount returns the value of descriptorSetCount from VkDescriptorSetVariableDescriptorCountAllocateInfo
func (x DescriptorSetVariableDescriptorCountAllocateInfo) DescriptorSetCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.descriptorSetCount)
	return *ptr
}

// WithDescriptorSetCount sets the value for the DescriptorSetCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetVariableDescriptorCountAllocateInfo) WithDescriptorSetCount(y uint32) DescriptorSetVariableDescriptorCountAllocateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.descriptorSetCount = *ptr
	return x
}

// PDescriptorCounts returns the value of pDescriptorCounts from VkDescriptorSetVariableDescriptorCountAllocateInfo
func (x DescriptorSetVariableDescriptorCountAllocateInfo) PDescriptorCounts() []uint32 {
	ptr := func(x **C.uint) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pDescriptorCounts)
	return *ptr
}

// WithPDescriptorCounts sets the value for the PDescriptorCounts on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines DescriptorSetCount as the length of this field.
// DescriptorSetCount is updated with the length of the new value.
func (x DescriptorSetVariableDescriptorCountAllocateInfo) WithPDescriptorCounts(y []uint32) DescriptorSetVariableDescriptorCountAllocateInfo {
	ptr := func(x *[]uint32) **C.uint { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pDescriptorCounts = *ptr
	return x.WithDescriptorSetCount(uint32(len(y)))
}

//DescriptorSetVariableDescriptorCountLayoutSupport provides a go interface for VkDescriptorSetVariableDescriptorCountLayoutSupport.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorSetVariableDescriptorCountLayoutSupport.html
type DescriptorSetVariableDescriptorCountLayoutSupport C.struct_VkDescriptorSetVariableDescriptorCountLayoutSupport

// SizeofDescriptorSetVariableDescriptorCountLayoutSupport is the memory size of a DescriptorSetVariableDescriptorCountLayoutSupport
var SizeofDescriptorSetVariableDescriptorCountLayoutSupport int = int(unsafe.Sizeof(DescriptorSetVariableDescriptorCountLayoutSupport{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorSetVariableDescriptorCountLayoutSupport) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorSetVariableDescriptorCountLayoutSupport) AsCPtr() *DescriptorSetVariableDescriptorCountLayoutSupport {
	clone := (*DescriptorSetVariableDescriptorCountLayoutSupport)(newCBlock(C.ulong(SizeofDescriptorSetVariableDescriptorCountLayoutSupport)))
	*clone = x
	return clone
}

// DescriptorSetVariableDescriptorCountLayoutSupportFreeCSlice releases the memory allocated by DescriptorSetVariableDescriptorCountLayoutSupportMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorSetVariableDescriptorCountLayoutSupportFreeCSlice(x []DescriptorSetVariableDescriptorCountLayoutSupport) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorSetVariableDescriptorCountLayoutSupportMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorSetVariableDescriptorCountLayoutSupportFreeCSlice must be called on the returned slice.
func DescriptorSetVariableDescriptorCountLayoutSupportMakeCSlice(x ...DescriptorSetVariableDescriptorCountLayoutSupport) []DescriptorSetVariableDescriptorCountLayoutSupport {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetVariableDescriptorCountLayoutSupport * len(x)
	dst := unsafe.Slice((*DescriptorSetVariableDescriptorCountLayoutSupport)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDescriptorSetVariableDescriptorCountLayoutSupport
func (x DescriptorSetVariableDescriptorCountLayoutSupport) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DescriptorSetVariableDescriptorCountLayoutSupport) WithDefaultSType() DescriptorSetVariableDescriptorCountLayoutSupport {
	return x.WithSType(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetVariableDescriptorCountLayoutSupport) WithSType(y StructureType) DescriptorSetVariableDescriptorCountLayoutSupport {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDescriptorSetVariableDescriptorCountLayoutSupport
func (x DescriptorSetVariableDescriptorCountLayoutSupport) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetVariableDescriptorCountLayoutSupport) WithPNext(y unsafe.Pointer) DescriptorSetVariableDescriptorCountLayoutSupport {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// MaxVariableDescriptorCount returns the value of maxVariableDescriptorCount from VkDescriptorSetVariableDescriptorCountLayoutSupport
func (x DescriptorSetVariableDescriptorCountLayoutSupport) MaxVariableDescriptorCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxVariableDescriptorCount)
	return *ptr
}

//ImageFormatListCreateInfo provides a go interface for VkImageFormatListCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageFormatListCreateInfo.html
type ImageFormatListCreateInfo C.struct_VkImageFormatListCreateInfo

// SizeofImageFormatListCreateInfo is the memory size of a ImageFormatListCreateInfo
var SizeofImageFormatListCreateInfo int = int(unsafe.Sizeof(ImageFormatListCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageFormatListCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageFormatListCreateInfo) AsCPtr() *ImageFormatListCreateInfo {
	clone := (*ImageFormatListCreateInfo)(newCBlock(C.ulong(SizeofImageFormatListCreateInfo)))
	*clone = x
	return clone
}

// ImageFormatListCreateInfoFreeCSlice releases the memory allocated by ImageFormatListCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageFormatListCreateInfoFreeCSlice(x []ImageFormatListCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageFormatListCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageFormatListCreateInfoFreeCSlice must be called on the returned slice.
func ImageFormatListCreateInfoMakeCSlice(x ...ImageFormatListCreateInfo) []ImageFormatListCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageFormatListCreateInfo * len(x)
	dst := unsafe.Slice((*ImageFormatListCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageFormatListCreateInfo
func (x ImageFormatListCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ImageFormatListCreateInfo) WithDefaultSType() ImageFormatListCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageFormatListCreateInfo) WithSType(y StructureType) ImageFormatListCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkImageFormatListCreateInfo
func (x ImageFormatListCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageFormatListCreateInfo) WithPNext(y unsafe.Pointer) ImageFormatListCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// ViewFormatCount returns the value of viewFormatCount from VkImageFormatListCreateInfo
func (x ImageFormatListCreateInfo) ViewFormatCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.viewFormatCount)
	return *ptr
}

// WithViewFormatCount sets the value for the ViewFormatCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageFormatListCreateInfo) WithViewFormatCount(y uint32) ImageFormatListCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.viewFormatCount = *ptr
	return x
}

// PViewFormats returns the value of pViewFormats from VkImageFormatListCreateInfo
func (x ImageFormatListCreateInfo) PViewFormats() []Format {
	ptr := func(x **C.VkFormat) *[]Format { /* Slice */
		slc := unsafe.Slice((*Format)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pViewFormats)
	return *ptr
}

// WithPViewFormats sets the value for the PViewFormats on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines ViewFormatCount as the length of this field.
// ViewFormatCount is updated with the length of the new value.
func (x ImageFormatListCreateInfo) WithPViewFormats(y []Format) ImageFormatListCreateInfo {
	ptr := func(x *[]Format) **C.VkFormat { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkFormat)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkFormat)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pViewFormats = *ptr
	return x.WithViewFormatCount(uint32(len(y)))
}

//PhysicalDeviceVulkan12Properties provides a go interface for VkPhysicalDeviceVulkan12Properties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Properties.html
type PhysicalDeviceVulkan12Properties C.struct_VkPhysicalDeviceVulkan12Properties

// SizeofPhysicalDeviceVulkan12Properties is the memory size of a PhysicalDeviceVulkan12Properties
var SizeofPhysicalDeviceVulkan12Properties int = int(unsafe.Sizeof(PhysicalDeviceVulkan12Properties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceVulkan12Properties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceVulkan12Properties) AsCPtr() *PhysicalDeviceVulkan12Properties {
	clone := (*PhysicalDeviceVulkan12Properties)(newCBlock(C.ulong(SizeofPhysicalDeviceVulkan12Properties)))
	*clone = x
	return clone
}

// PhysicalDeviceVulkan12PropertiesFreeCSlice releases the memory allocated by PhysicalDeviceVulkan12PropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceVulkan12PropertiesFreeCSlice(x []PhysicalDeviceVulkan12Properties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceVulkan12PropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceVulkan12PropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceVulkan12PropertiesMakeCSlice(x ...PhysicalDeviceVulkan12Properties) []PhysicalDeviceVulkan12Properties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVulkan12Properties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceVulkan12Properties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceVulkan12Properties) WithDefaultSType() PhysicalDeviceVulkan12Properties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Properties) WithSType(y StructureType) PhysicalDeviceVulkan12Properties {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Properties) WithPNext(y unsafe.Pointer) PhysicalDeviceVulkan12Properties {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// DriverID returns the value of driverID from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) DriverID() DriverId {
	ptr := /* typedef */ (*DriverId)(&x.driverID)
	return *ptr
}

// DriverName returns the value of driverName from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) DriverName() []byte {
	ptr := func(x *[VK_MAX_DRIVER_NAME_SIZE]C.char) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_DRIVER_NAME_SIZE)
		return &slc
	}(&x.driverName)
	return *ptr
}

// DriverInfo returns the value of driverInfo from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) DriverInfo() []byte {
	ptr := func(x *[VK_MAX_DRIVER_INFO_SIZE]C.char) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_DRIVER_INFO_SIZE)
		return &slc
	}(&x.driverInfo)
	return *ptr
}

// ConformanceVersion returns the value of conformanceVersion from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ConformanceVersion() ConformanceVersion {
	ptr := /* typedef */ (*ConformanceVersion)(&x.conformanceVersion)
	return *ptr
}

// DenormBehaviorIndependence returns the value of denormBehaviorIndependence from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) DenormBehaviorIndependence() ShaderFloatControlsIndependence {
	ptr := /* typedef */ (*ShaderFloatControlsIndependence)(&x.denormBehaviorIndependence)
	return *ptr
}

// RoundingModeIndependence returns the value of roundingModeIndependence from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) RoundingModeIndependence() ShaderFloatControlsIndependence {
	ptr := /* typedef */ (*ShaderFloatControlsIndependence)(&x.roundingModeIndependence)
	return *ptr
}

// ShaderSignedZeroInfNanPreserveFloat16 returns the value of shaderSignedZeroInfNanPreserveFloat16 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderSignedZeroInfNanPreserveFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSignedZeroInfNanPreserveFloat16)
	return *ptr
}

// ShaderSignedZeroInfNanPreserveFloat32 returns the value of shaderSignedZeroInfNanPreserveFloat32 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderSignedZeroInfNanPreserveFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSignedZeroInfNanPreserveFloat32)
	return *ptr
}

// ShaderSignedZeroInfNanPreserveFloat64 returns the value of shaderSignedZeroInfNanPreserveFloat64 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderSignedZeroInfNanPreserveFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSignedZeroInfNanPreserveFloat64)
	return *ptr
}

// ShaderDenormPreserveFloat16 returns the value of shaderDenormPreserveFloat16 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderDenormPreserveFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormPreserveFloat16)
	return *ptr
}

// ShaderDenormPreserveFloat32 returns the value of shaderDenormPreserveFloat32 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderDenormPreserveFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormPreserveFloat32)
	return *ptr
}

// ShaderDenormPreserveFloat64 returns the value of shaderDenormPreserveFloat64 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderDenormPreserveFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormPreserveFloat64)
	return *ptr
}

// ShaderDenormFlushToZeroFloat16 returns the value of shaderDenormFlushToZeroFloat16 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderDenormFlushToZeroFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormFlushToZeroFloat16)
	return *ptr
}

// ShaderDenormFlushToZeroFloat32 returns the value of shaderDenormFlushToZeroFloat32 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderDenormFlushToZeroFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormFlushToZeroFloat32)
	return *ptr
}

// ShaderDenormFlushToZeroFloat64 returns the value of shaderDenormFlushToZeroFloat64 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderDenormFlushToZeroFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormFlushToZeroFloat64)
	return *ptr
}

// ShaderRoundingModeRTEFloat16 returns the value of shaderRoundingModeRTEFloat16 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderRoundingModeRTEFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTEFloat16)
	return *ptr
}

// ShaderRoundingModeRTEFloat32 returns the value of shaderRoundingModeRTEFloat32 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderRoundingModeRTEFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTEFloat32)
	return *ptr
}

// ShaderRoundingModeRTEFloat64 returns the value of shaderRoundingModeRTEFloat64 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderRoundingModeRTEFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTEFloat64)
	return *ptr
}

// ShaderRoundingModeRTZFloat16 returns the value of shaderRoundingModeRTZFloat16 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderRoundingModeRTZFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTZFloat16)
	return *ptr
}

// ShaderRoundingModeRTZFloat32 returns the value of shaderRoundingModeRTZFloat32 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderRoundingModeRTZFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTZFloat32)
	return *ptr
}

// ShaderRoundingModeRTZFloat64 returns the value of shaderRoundingModeRTZFloat64 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderRoundingModeRTZFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTZFloat64)
	return *ptr
}

// MaxUpdateAfterBindDescriptorsInAllPools returns the value of maxUpdateAfterBindDescriptorsInAllPools from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxUpdateAfterBindDescriptorsInAllPools() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxUpdateAfterBindDescriptorsInAllPools)
	return *ptr
}

// ShaderUniformBufferArrayNonUniformIndexingNative returns the value of shaderUniformBufferArrayNonUniformIndexingNative from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderUniformBufferArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderUniformBufferArrayNonUniformIndexingNative)
	return *ptr
}

// ShaderSampledImageArrayNonUniformIndexingNative returns the value of shaderSampledImageArrayNonUniformIndexingNative from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderSampledImageArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSampledImageArrayNonUniformIndexingNative)
	return *ptr
}

// ShaderStorageBufferArrayNonUniformIndexingNative returns the value of shaderStorageBufferArrayNonUniformIndexingNative from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderStorageBufferArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageBufferArrayNonUniformIndexingNative)
	return *ptr
}

// ShaderStorageImageArrayNonUniformIndexingNative returns the value of shaderStorageImageArrayNonUniformIndexingNative from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderStorageImageArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageImageArrayNonUniformIndexingNative)
	return *ptr
}

// ShaderInputAttachmentArrayNonUniformIndexingNative returns the value of shaderInputAttachmentArrayNonUniformIndexingNative from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderInputAttachmentArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInputAttachmentArrayNonUniformIndexingNative)
	return *ptr
}

// RobustBufferAccessUpdateAfterBind returns the value of robustBufferAccessUpdateAfterBind from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) RobustBufferAccessUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.robustBufferAccessUpdateAfterBind)
	return *ptr
}

// QuadDivergentImplicitLod returns the value of quadDivergentImplicitLod from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) QuadDivergentImplicitLod() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.quadDivergentImplicitLod)
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindSamplers returns the value of maxPerStageDescriptorUpdateAfterBindSamplers from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxPerStageDescriptorUpdateAfterBindSamplers() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxPerStageDescriptorUpdateAfterBindSamplers)
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindUniformBuffers returns the value of maxPerStageDescriptorUpdateAfterBindUniformBuffers from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxPerStageDescriptorUpdateAfterBindUniformBuffers() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxPerStageDescriptorUpdateAfterBindUniformBuffers)
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindStorageBuffers returns the value of maxPerStageDescriptorUpdateAfterBindStorageBuffers from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxPerStageDescriptorUpdateAfterBindStorageBuffers() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxPerStageDescriptorUpdateAfterBindStorageBuffers)
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindSampledImages returns the value of maxPerStageDescriptorUpdateAfterBindSampledImages from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxPerStageDescriptorUpdateAfterBindSampledImages() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxPerStageDescriptorUpdateAfterBindSampledImages)
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindStorageImages returns the value of maxPerStageDescriptorUpdateAfterBindStorageImages from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxPerStageDescriptorUpdateAfterBindStorageImages() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxPerStageDescriptorUpdateAfterBindStorageImages)
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindInputAttachments returns the value of maxPerStageDescriptorUpdateAfterBindInputAttachments from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxPerStageDescriptorUpdateAfterBindInputAttachments() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxPerStageDescriptorUpdateAfterBindInputAttachments)
	return *ptr
}

// MaxPerStageUpdateAfterBindResources returns the value of maxPerStageUpdateAfterBindResources from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxPerStageUpdateAfterBindResources() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxPerStageUpdateAfterBindResources)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindSamplers returns the value of maxDescriptorSetUpdateAfterBindSamplers from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxDescriptorSetUpdateAfterBindSamplers() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxDescriptorSetUpdateAfterBindSamplers)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindUniformBuffers returns the value of maxDescriptorSetUpdateAfterBindUniformBuffers from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxDescriptorSetUpdateAfterBindUniformBuffers() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxDescriptorSetUpdateAfterBindUniformBuffers)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic returns the value of maxDescriptorSetUpdateAfterBindUniformBuffersDynamic from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindStorageBuffers returns the value of maxDescriptorSetUpdateAfterBindStorageBuffers from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxDescriptorSetUpdateAfterBindStorageBuffers() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxDescriptorSetUpdateAfterBindStorageBuffers)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic returns the value of maxDescriptorSetUpdateAfterBindStorageBuffersDynamic from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindSampledImages returns the value of maxDescriptorSetUpdateAfterBindSampledImages from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxDescriptorSetUpdateAfterBindSampledImages() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxDescriptorSetUpdateAfterBindSampledImages)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindStorageImages returns the value of maxDescriptorSetUpdateAfterBindStorageImages from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxDescriptorSetUpdateAfterBindStorageImages() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxDescriptorSetUpdateAfterBindStorageImages)
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindInputAttachments returns the value of maxDescriptorSetUpdateAfterBindInputAttachments from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxDescriptorSetUpdateAfterBindInputAttachments() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxDescriptorSetUpdateAfterBindInputAttachments)
	return *ptr
}

// SupportedDepthResolveModes returns the value of supportedDepthResolveModes from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) SupportedDepthResolveModes() ResolveModeFlags {
	ptr := /* typedef */ (*ResolveModeFlags)(&x.supportedDepthResolveModes)
	return *ptr
}

// SupportedStencilResolveModes returns the value of supportedStencilResolveModes from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) SupportedStencilResolveModes() ResolveModeFlags {
	ptr := /* typedef */ (*ResolveModeFlags)(&x.supportedStencilResolveModes)
	return *ptr
}

// IndependentResolveNone returns the value of independentResolveNone from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) IndependentResolveNone() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.independentResolveNone)
	return *ptr
}

// IndependentResolve returns the value of independentResolve from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) IndependentResolve() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.independentResolve)
	return *ptr
}

// FilterMinmaxSingleComponentFormats returns the value of filterMinmaxSingleComponentFormats from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) FilterMinmaxSingleComponentFormats() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.filterMinmaxSingleComponentFormats)
	return *ptr
}

// FilterMinmaxImageComponentMapping returns the value of filterMinmaxImageComponentMapping from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) FilterMinmaxImageComponentMapping() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.filterMinmaxImageComponentMapping)
	return *ptr
}

// MaxTimelineSemaphoreValueDifference returns the value of maxTimelineSemaphoreValueDifference from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxTimelineSemaphoreValueDifference() uint64 {
	ptr := func(x *C.ulonglong) *uint64 { /* Scalar */ return (*uint64)(unsafe.Pointer(x)) }(&x.maxTimelineSemaphoreValueDifference)
	return *ptr
}

// FramebufferIntegerColorSampleCounts returns the value of framebufferIntegerColorSampleCounts from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) FramebufferIntegerColorSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.framebufferIntegerColorSampleCounts)
	return *ptr
}

//SubpassDescriptionDepthStencilResolve provides a go interface for VkSubpassDescriptionDepthStencilResolve.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSubpassDescriptionDepthStencilResolve.html
type SubpassDescriptionDepthStencilResolve C.struct_VkSubpassDescriptionDepthStencilResolve

// SizeofSubpassDescriptionDepthStencilResolve is the memory size of a SubpassDescriptionDepthStencilResolve
var SizeofSubpassDescriptionDepthStencilResolve int = int(unsafe.Sizeof(SubpassDescriptionDepthStencilResolve{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubpassDescriptionDepthStencilResolve) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubpassDescriptionDepthStencilResolve) AsCPtr() *SubpassDescriptionDepthStencilResolve {
	clone := (*SubpassDescriptionDepthStencilResolve)(newCBlock(C.ulong(SizeofSubpassDescriptionDepthStencilResolve)))
	*clone = x
	return clone
}

// SubpassDescriptionDepthStencilResolveFreeCSlice releases the memory allocated by SubpassDescriptionDepthStencilResolveMakeCSlice.
// It does not free pointers stored inside the slice.
func SubpassDescriptionDepthStencilResolveFreeCSlice(x []SubpassDescriptionDepthStencilResolve) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubpassDescriptionDepthStencilResolveMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubpassDescriptionDepthStencilResolveFreeCSlice must be called on the returned slice.
func SubpassDescriptionDepthStencilResolveMakeCSlice(x ...SubpassDescriptionDepthStencilResolve) []SubpassDescriptionDepthStencilResolve {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassDescriptionDepthStencilResolve * len(x)
	dst := unsafe.Slice((*SubpassDescriptionDepthStencilResolve)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSubpassDescriptionDepthStencilResolve
func (x SubpassDescriptionDepthStencilResolve) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SubpassDescriptionDepthStencilResolve) WithDefaultSType() SubpassDescriptionDepthStencilResolve {
	return x.WithSType(VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescriptionDepthStencilResolve) WithSType(y StructureType) SubpassDescriptionDepthStencilResolve {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkSubpassDescriptionDepthStencilResolve
func (x SubpassDescriptionDepthStencilResolve) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescriptionDepthStencilResolve) WithPNext(y unsafe.Pointer) SubpassDescriptionDepthStencilResolve {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// DepthResolveMode returns the value of depthResolveMode from VkSubpassDescriptionDepthStencilResolve
func (x SubpassDescriptionDepthStencilResolve) DepthResolveMode() ResolveModeFlagBits {
	ptr := /* typedef */ (*ResolveModeFlagBits)(&x.depthResolveMode)
	return *ptr
}

// WithDepthResolveMode sets the value for the DepthResolveMode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescriptionDepthStencilResolve) WithDepthResolveMode(y ResolveModeFlagBits) SubpassDescriptionDepthStencilResolve {
	ptr := /* typedef */ (*C.VkResolveModeFlagBits)(&y)
	x.depthResolveMode = *ptr
	return x
}

// StencilResolveMode returns the value of stencilResolveMode from VkSubpassDescriptionDepthStencilResolve
func (x SubpassDescriptionDepthStencilResolve) StencilResolveMode() ResolveModeFlagBits {
	ptr := /* typedef */ (*ResolveModeFlagBits)(&x.stencilResolveMode)
	return *ptr
}

// WithStencilResolveMode sets the value for the StencilResolveMode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescriptionDepthStencilResolve) WithStencilResolveMode(y ResolveModeFlagBits) SubpassDescriptionDepthStencilResolve {
	ptr := /* typedef */ (*C.VkResolveModeFlagBits)(&y)
	x.stencilResolveMode = *ptr
	return x
}

// PDepthStencilResolveAttachment returns the value of pDepthStencilResolveAttachment from VkSubpassDescriptionDepthStencilResolve
func (x SubpassDescriptionDepthStencilResolve) PDepthStencilResolveAttachment() *AttachmentReference2 {
	ptr := func(x **C.struct_VkAttachmentReference2) **AttachmentReference2 { /* Pointer */
		return (**AttachmentReference2)(unsafe.Pointer(x))
	}(&x.pDepthStencilResolveAttachment)
	return *ptr
}

// WithPDepthStencilResolveAttachment sets the value for the PDepthStencilResolveAttachment on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescriptionDepthStencilResolve) WithPDepthStencilResolveAttachment(y *AttachmentReference2) SubpassDescriptionDepthStencilResolve {
	ptr := func(x **AttachmentReference2) **C.struct_VkAttachmentReference2 { /* Pointer */
		return (**C.struct_VkAttachmentReference2)(unsafe.Pointer(x))
	}(&y)
	x.pDepthStencilResolveAttachment = *ptr
	return x
}

//PhysicalDeviceDepthStencilResolveProperties provides a go interface for VkPhysicalDeviceDepthStencilResolveProperties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceDepthStencilResolveProperties.html
type PhysicalDeviceDepthStencilResolveProperties C.struct_VkPhysicalDeviceDepthStencilResolveProperties

// SizeofPhysicalDeviceDepthStencilResolveProperties is the memory size of a PhysicalDeviceDepthStencilResolveProperties
var SizeofPhysicalDeviceDepthStencilResolveProperties int = int(unsafe.Sizeof(PhysicalDeviceDepthStencilResolveProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceDepthStencilResolveProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceDepthStencilResolveProperties) AsCPtr() *PhysicalDeviceDepthStencilResolveProperties {
	clone := (*PhysicalDeviceDepthStencilResolveProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceDepthStencilResolveProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceDepthStencilResolvePropertiesFreeCSlice releases the memory allocated by PhysicalDeviceDepthStencilResolvePropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceDepthStencilResolvePropertiesFreeCSlice(x []PhysicalDeviceDepthStencilResolveProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceDepthStencilResolvePropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceDepthStencilResolvePropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceDepthStencilResolvePropertiesMakeCSlice(x ...PhysicalDeviceDepthStencilResolveProperties) []PhysicalDeviceDepthStencilResolveProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceDepthStencilResolveProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceDepthStencilResolveProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceDepthStencilResolveProperties
func (x PhysicalDeviceDepthStencilResolveProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceDepthStencilResolveProperties) WithDefaultSType() PhysicalDeviceDepthStencilResolveProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDepthStencilResolveProperties) WithSType(y StructureType) PhysicalDeviceDepthStencilResolveProperties {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceDepthStencilResolveProperties
func (x PhysicalDeviceDepthStencilResolveProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDepthStencilResolveProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceDepthStencilResolveProperties {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// SupportedDepthResolveModes returns the value of supportedDepthResolveModes from VkPhysicalDeviceDepthStencilResolveProperties
func (x PhysicalDeviceDepthStencilResolveProperties) SupportedDepthResolveModes() ResolveModeFlags {
	ptr := /* typedef */ (*ResolveModeFlags)(&x.supportedDepthResolveModes)
	return *ptr
}

// SupportedStencilResolveModes returns the value of supportedStencilResolveModes from VkPhysicalDeviceDepthStencilResolveProperties
func (x PhysicalDeviceDepthStencilResolveProperties) SupportedStencilResolveModes() ResolveModeFlags {
	ptr := /* typedef */ (*ResolveModeFlags)(&x.supportedStencilResolveModes)
	return *ptr
}

// IndependentResolveNone returns the value of independentResolveNone from VkPhysicalDeviceDepthStencilResolveProperties
func (x PhysicalDeviceDepthStencilResolveProperties) IndependentResolveNone() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.independentResolveNone)
	return *ptr
}

// IndependentResolve returns the value of independentResolve from VkPhysicalDeviceDepthStencilResolveProperties
func (x PhysicalDeviceDepthStencilResolveProperties) IndependentResolve() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.independentResolve)
	return *ptr
}

//PhysicalDeviceVulkan12Features provides a go interface for VkPhysicalDeviceVulkan12Features.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html
type PhysicalDeviceVulkan12Features C.struct_VkPhysicalDeviceVulkan12Features

// SizeofPhysicalDeviceVulkan12Features is the memory size of a PhysicalDeviceVulkan12Features
var SizeofPhysicalDeviceVulkan12Features int = int(unsafe.Sizeof(PhysicalDeviceVulkan12Features{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceVulkan12Features) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceVulkan12Features) AsCPtr() *PhysicalDeviceVulkan12Features {
	clone := (*PhysicalDeviceVulkan12Features)(newCBlock(C.ulong(SizeofPhysicalDeviceVulkan12Features)))
	*clone = x
	return clone
}

// PhysicalDeviceVulkan12FeaturesFreeCSlice releases the memory allocated by PhysicalDeviceVulkan12FeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceVulkan12FeaturesFreeCSlice(x []PhysicalDeviceVulkan12Features) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceVulkan12FeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceVulkan12FeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceVulkan12FeaturesMakeCSlice(x ...PhysicalDeviceVulkan12Features) []PhysicalDeviceVulkan12Features {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVulkan12Features * len(x)
	dst := unsafe.Slice((*PhysicalDeviceVulkan12Features)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceVulkan12Features) WithDefaultSType() PhysicalDeviceVulkan12Features {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithSType(y StructureType) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithPNext(y unsafe.Pointer) PhysicalDeviceVulkan12Features {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// SamplerMirrorClampToEdge returns the value of samplerMirrorClampToEdge from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) SamplerMirrorClampToEdge() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.samplerMirrorClampToEdge)
	return *ptr
}

// WithSamplerMirrorClampToEdge sets the value for the SamplerMirrorClampToEdge on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithSamplerMirrorClampToEdge(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.samplerMirrorClampToEdge = *ptr
	return x
}

// DrawIndirectCount returns the value of drawIndirectCount from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DrawIndirectCount() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.drawIndirectCount)
	return *ptr
}

// WithDrawIndirectCount sets the value for the DrawIndirectCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDrawIndirectCount(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.drawIndirectCount = *ptr
	return x
}

// StorageBuffer8BitAccess returns the value of storageBuffer8BitAccess from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) StorageBuffer8BitAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storageBuffer8BitAccess)
	return *ptr
}

// WithStorageBuffer8BitAccess sets the value for the StorageBuffer8BitAccess on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithStorageBuffer8BitAccess(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.storageBuffer8BitAccess = *ptr
	return x
}

// UniformAndStorageBuffer8BitAccess returns the value of uniformAndStorageBuffer8BitAccess from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) UniformAndStorageBuffer8BitAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.uniformAndStorageBuffer8BitAccess)
	return *ptr
}

// WithUniformAndStorageBuffer8BitAccess sets the value for the UniformAndStorageBuffer8BitAccess on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithUniformAndStorageBuffer8BitAccess(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.uniformAndStorageBuffer8BitAccess = *ptr
	return x
}

// StoragePushConstant8 returns the value of storagePushConstant8 from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) StoragePushConstant8() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storagePushConstant8)
	return *ptr
}

// WithStoragePushConstant8 sets the value for the StoragePushConstant8 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithStoragePushConstant8(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.storagePushConstant8 = *ptr
	return x
}

// ShaderBufferInt64Atomics returns the value of shaderBufferInt64Atomics from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderBufferInt64Atomics() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderBufferInt64Atomics)
	return *ptr
}

// WithShaderBufferInt64Atomics sets the value for the ShaderBufferInt64Atomics on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderBufferInt64Atomics(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderBufferInt64Atomics = *ptr
	return x
}

// ShaderSharedInt64Atomics returns the value of shaderSharedInt64Atomics from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderSharedInt64Atomics() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSharedInt64Atomics)
	return *ptr
}

// WithShaderSharedInt64Atomics sets the value for the ShaderSharedInt64Atomics on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderSharedInt64Atomics(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderSharedInt64Atomics = *ptr
	return x
}

// ShaderFloat16 returns the value of shaderFloat16 from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderFloat16)
	return *ptr
}

// WithShaderFloat16 sets the value for the ShaderFloat16 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderFloat16(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderFloat16 = *ptr
	return x
}

// ShaderInt8 returns the value of shaderInt8 from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderInt8() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInt8)
	return *ptr
}

// WithShaderInt8 sets the value for the ShaderInt8 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderInt8(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderInt8 = *ptr
	return x
}

// DescriptorIndexing returns the value of descriptorIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorIndexing)
	return *ptr
}

// WithDescriptorIndexing sets the value for the DescriptorIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.descriptorIndexing = *ptr
	return x
}

// ShaderInputAttachmentArrayDynamicIndexing returns the value of shaderInputAttachmentArrayDynamicIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderInputAttachmentArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInputAttachmentArrayDynamicIndexing)
	return *ptr
}

// WithShaderInputAttachmentArrayDynamicIndexing sets the value for the ShaderInputAttachmentArrayDynamicIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderInputAttachmentArrayDynamicIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderInputAttachmentArrayDynamicIndexing = *ptr
	return x
}

// ShaderUniformTexelBufferArrayDynamicIndexing returns the value of shaderUniformTexelBufferArrayDynamicIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderUniformTexelBufferArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderUniformTexelBufferArrayDynamicIndexing)
	return *ptr
}

// WithShaderUniformTexelBufferArrayDynamicIndexing sets the value for the ShaderUniformTexelBufferArrayDynamicIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderUniformTexelBufferArrayDynamicIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderUniformTexelBufferArrayDynamicIndexing = *ptr
	return x
}

// ShaderStorageTexelBufferArrayDynamicIndexing returns the value of shaderStorageTexelBufferArrayDynamicIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderStorageTexelBufferArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageTexelBufferArrayDynamicIndexing)
	return *ptr
}

// WithShaderStorageTexelBufferArrayDynamicIndexing sets the value for the ShaderStorageTexelBufferArrayDynamicIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderStorageTexelBufferArrayDynamicIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderStorageTexelBufferArrayDynamicIndexing = *ptr
	return x
}

// ShaderUniformBufferArrayNonUniformIndexing returns the value of shaderUniformBufferArrayNonUniformIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderUniformBufferArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderUniformBufferArrayNonUniformIndexing)
	return *ptr
}

// WithShaderUniformBufferArrayNonUniformIndexing sets the value for the ShaderUniformBufferArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderUniformBufferArrayNonUniformIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderUniformBufferArrayNonUniformIndexing = *ptr
	return x
}

// ShaderSampledImageArrayNonUniformIndexing returns the value of shaderSampledImageArrayNonUniformIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderSampledImageArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSampledImageArrayNonUniformIndexing)
	return *ptr
}

// WithShaderSampledImageArrayNonUniformIndexing sets the value for the ShaderSampledImageArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderSampledImageArrayNonUniformIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderSampledImageArrayNonUniformIndexing = *ptr
	return x
}

// ShaderStorageBufferArrayNonUniformIndexing returns the value of shaderStorageBufferArrayNonUniformIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderStorageBufferArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageBufferArrayNonUniformIndexing)
	return *ptr
}

// WithShaderStorageBufferArrayNonUniformIndexing sets the value for the ShaderStorageBufferArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderStorageBufferArrayNonUniformIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderStorageBufferArrayNonUniformIndexing = *ptr
	return x
}

// ShaderStorageImageArrayNonUniformIndexing returns the value of shaderStorageImageArrayNonUniformIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderStorageImageArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageImageArrayNonUniformIndexing)
	return *ptr
}

// WithShaderStorageImageArrayNonUniformIndexing sets the value for the ShaderStorageImageArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderStorageImageArrayNonUniformIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderStorageImageArrayNonUniformIndexing = *ptr
	return x
}

// ShaderInputAttachmentArrayNonUniformIndexing returns the value of shaderInputAttachmentArrayNonUniformIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderInputAttachmentArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInputAttachmentArrayNonUniformIndexing)
	return *ptr
}

// WithShaderInputAttachmentArrayNonUniformIndexing sets the value for the ShaderInputAttachmentArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderInputAttachmentArrayNonUniformIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderInputAttachmentArrayNonUniformIndexing = *ptr
	return x
}

// ShaderUniformTexelBufferArrayNonUniformIndexing returns the value of shaderUniformTexelBufferArrayNonUniformIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderUniformTexelBufferArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderUniformTexelBufferArrayNonUniformIndexing)
	return *ptr
}

// WithShaderUniformTexelBufferArrayNonUniformIndexing sets the value for the ShaderUniformTexelBufferArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderUniformTexelBufferArrayNonUniformIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderUniformTexelBufferArrayNonUniformIndexing = *ptr
	return x
}

// ShaderStorageTexelBufferArrayNonUniformIndexing returns the value of shaderStorageTexelBufferArrayNonUniformIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderStorageTexelBufferArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageTexelBufferArrayNonUniformIndexing)
	return *ptr
}

// WithShaderStorageTexelBufferArrayNonUniformIndexing sets the value for the ShaderStorageTexelBufferArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderStorageTexelBufferArrayNonUniformIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderStorageTexelBufferArrayNonUniformIndexing = *ptr
	return x
}

// DescriptorBindingUniformBufferUpdateAfterBind returns the value of descriptorBindingUniformBufferUpdateAfterBind from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorBindingUniformBufferUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingUniformBufferUpdateAfterBind)
	return *ptr
}

// WithDescriptorBindingUniformBufferUpdateAfterBind sets the value for the DescriptorBindingUniformBufferUpdateAfterBind on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorBindingUniformBufferUpdateAfterBind(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.descriptorBindingUniformBufferUpdateAfterBind = *ptr
	return x
}

// DescriptorBindingSampledImageUpdateAfterBind returns the value of descriptorBindingSampledImageUpdateAfterBind from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorBindingSampledImageUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingSampledImageUpdateAfterBind)
	return *ptr
}

// WithDescriptorBindingSampledImageUpdateAfterBind sets the value for the DescriptorBindingSampledImageUpdateAfterBind on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorBindingSampledImageUpdateAfterBind(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.descriptorBindingSampledImageUpdateAfterBind = *ptr
	return x
}

// DescriptorBindingStorageImageUpdateAfterBind returns the value of descriptorBindingStorageImageUpdateAfterBind from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorBindingStorageImageUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingStorageImageUpdateAfterBind)
	return *ptr
}

// WithDescriptorBindingStorageImageUpdateAfterBind sets the value for the DescriptorBindingStorageImageUpdateAfterBind on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorBindingStorageImageUpdateAfterBind(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.descriptorBindingStorageImageUpdateAfterBind = *ptr
	return x
}

// DescriptorBindingStorageBufferUpdateAfterBind returns the value of descriptorBindingStorageBufferUpdateAfterBind from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorBindingStorageBufferUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingStorageBufferUpdateAfterBind)
	return *ptr
}

// WithDescriptorBindingStorageBufferUpdateAfterBind sets the value for the DescriptorBindingStorageBufferUpdateAfterBind on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorBindingStorageBufferUpdateAfterBind(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.descriptorBindingStorageBufferUpdateAfterBind = *ptr
	return x
}

// DescriptorBindingUniformTexelBufferUpdateAfterBind returns the value of descriptorBindingUniformTexelBufferUpdateAfterBind from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorBindingUniformTexelBufferUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingUniformTexelBufferUpdateAfterBind)
	return *ptr
}

// WithDescriptorBindingUniformTexelBufferUpdateAfterBind sets the value for the DescriptorBindingUniformTexelBufferUpdateAfterBind on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorBindingUniformTexelBufferUpdateAfterBind(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.descriptorBindingUniformTexelBufferUpdateAfterBind = *ptr
	return x
}

// DescriptorBindingStorageTexelBufferUpdateAfterBind returns the value of descriptorBindingStorageTexelBufferUpdateAfterBind from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorBindingStorageTexelBufferUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingStorageTexelBufferUpdateAfterBind)
	return *ptr
}

// WithDescriptorBindingStorageTexelBufferUpdateAfterBind sets the value for the DescriptorBindingStorageTexelBufferUpdateAfterBind on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorBindingStorageTexelBufferUpdateAfterBind(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.descriptorBindingStorageTexelBufferUpdateAfterBind = *ptr
	return x
}

// DescriptorBindingUpdateUnusedWhilePending returns the value of descriptorBindingUpdateUnusedWhilePending from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorBindingUpdateUnusedWhilePending() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingUpdateUnusedWhilePending)
	return *ptr
}

// WithDescriptorBindingUpdateUnusedWhilePending sets the value for the DescriptorBindingUpdateUnusedWhilePending on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorBindingUpdateUnusedWhilePending(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.descriptorBindingUpdateUnusedWhilePending = *ptr
	return x
}

// DescriptorBindingPartiallyBound returns the value of descriptorBindingPartiallyBound from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorBindingPartiallyBound() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingPartiallyBound)
	return *ptr
}

// WithDescriptorBindingPartiallyBound sets the value for the DescriptorBindingPartiallyBound on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorBindingPartiallyBound(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.descriptorBindingPartiallyBound = *ptr
	return x
}

// DescriptorBindingVariableDescriptorCount returns the value of descriptorBindingVariableDescriptorCount from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorBindingVariableDescriptorCount() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingVariableDescriptorCount)
	return *ptr
}

// WithDescriptorBindingVariableDescriptorCount sets the value for the DescriptorBindingVariableDescriptorCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorBindingVariableDescriptorCount(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.descriptorBindingVariableDescriptorCount = *ptr
	return x
}

// RuntimeDescriptorArray returns the value of runtimeDescriptorArray from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) RuntimeDescriptorArray() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.runtimeDescriptorArray)
	return *ptr
}

// WithRuntimeDescriptorArray sets the value for the RuntimeDescriptorArray on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithRuntimeDescriptorArray(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.runtimeDescriptorArray = *ptr
	return x
}

// SamplerFilterMinmax returns the value of samplerFilterMinmax from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) SamplerFilterMinmax() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.samplerFilterMinmax)
	return *ptr
}

// WithSamplerFilterMinmax sets the value for the SamplerFilterMinmax on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithSamplerFilterMinmax(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.samplerFilterMinmax = *ptr
	return x
}

// ScalarBlockLayout returns the value of scalarBlockLayout from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ScalarBlockLayout() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.scalarBlockLayout)
	return *ptr
}

// WithScalarBlockLayout sets the value for the ScalarBlockLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithScalarBlockLayout(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.scalarBlockLayout = *ptr
	return x
}

// ImagelessFramebuffer returns the value of imagelessFramebuffer from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ImagelessFramebuffer() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.imagelessFramebuffer)
	return *ptr
}

// WithImagelessFramebuffer sets the value for the ImagelessFramebuffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithImagelessFramebuffer(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.imagelessFramebuffer = *ptr
	return x
}

// UniformBufferStandardLayout returns the value of uniformBufferStandardLayout from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) UniformBufferStandardLayout() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.uniformBufferStandardLayout)
	return *ptr
}

// WithUniformBufferStandardLayout sets the value for the UniformBufferStandardLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithUniformBufferStandardLayout(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.uniformBufferStandardLayout = *ptr
	return x
}

// ShaderSubgroupExtendedTypes returns the value of shaderSubgroupExtendedTypes from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderSubgroupExtendedTypes() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSubgroupExtendedTypes)
	return *ptr
}

// WithShaderSubgroupExtendedTypes sets the value for the ShaderSubgroupExtendedTypes on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderSubgroupExtendedTypes(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderSubgroupExtendedTypes = *ptr
	return x
}

// SeparateDepthStencilLayouts returns the value of separateDepthStencilLayouts from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) SeparateDepthStencilLayouts() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.separateDepthStencilLayouts)
	return *ptr
}

// WithSeparateDepthStencilLayouts sets the value for the SeparateDepthStencilLayouts on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithSeparateDepthStencilLayouts(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.separateDepthStencilLayouts = *ptr
	return x
}

// HostQueryReset returns the value of hostQueryReset from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) HostQueryReset() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.hostQueryReset)
	return *ptr
}

// WithHostQueryReset sets the value for the HostQueryReset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithHostQueryReset(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.hostQueryReset = *ptr
	return x
}

// TimelineSemaphore returns the value of timelineSemaphore from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) TimelineSemaphore() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.timelineSemaphore)
	return *ptr
}

// WithTimelineSemaphore sets the value for the TimelineSemaphore on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithTimelineSemaphore(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.timelineSemaphore = *ptr
	return x
}

// BufferDeviceAddress returns the value of bufferDeviceAddress from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) BufferDeviceAddress() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.bufferDeviceAddress)
	return *ptr
}

// WithBufferDeviceAddress sets the value for the BufferDeviceAddress on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithBufferDeviceAddress(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.bufferDeviceAddress = *ptr
	return x
}

// BufferDeviceAddressCaptureReplay returns the value of bufferDeviceAddressCaptureReplay from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) BufferDeviceAddressCaptureReplay() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.bufferDeviceAddressCaptureReplay)
	return *ptr
}

// WithBufferDeviceAddressCaptureReplay sets the value for the BufferDeviceAddressCaptureReplay on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithBufferDeviceAddressCaptureReplay(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.bufferDeviceAddressCaptureReplay = *ptr
	return x
}

// BufferDeviceAddressMultiDevice returns the value of bufferDeviceAddressMultiDevice from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) BufferDeviceAddressMultiDevice() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.bufferDeviceAddressMultiDevice)
	return *ptr
}

// WithBufferDeviceAddressMultiDevice sets the value for the BufferDeviceAddressMultiDevice on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithBufferDeviceAddressMultiDevice(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.bufferDeviceAddressMultiDevice = *ptr
	return x
}

// VulkanMemoryModel returns the value of vulkanMemoryModel from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) VulkanMemoryModel() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.vulkanMemoryModel)
	return *ptr
}

// WithVulkanMemoryModel sets the value for the VulkanMemoryModel on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithVulkanMemoryModel(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.vulkanMemoryModel = *ptr
	return x
}

// VulkanMemoryModelDeviceScope returns the value of vulkanMemoryModelDeviceScope from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) VulkanMemoryModelDeviceScope() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.vulkanMemoryModelDeviceScope)
	return *ptr
}

// WithVulkanMemoryModelDeviceScope sets the value for the VulkanMemoryModelDeviceScope on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithVulkanMemoryModelDeviceScope(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.vulkanMemoryModelDeviceScope = *ptr
	return x
}

// VulkanMemoryModelAvailabilityVisibilityChains returns the value of vulkanMemoryModelAvailabilityVisibilityChains from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) VulkanMemoryModelAvailabilityVisibilityChains() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.vulkanMemoryModelAvailabilityVisibilityChains)
	return *ptr
}

// WithVulkanMemoryModelAvailabilityVisibilityChains sets the value for the VulkanMemoryModelAvailabilityVisibilityChains on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithVulkanMemoryModelAvailabilityVisibilityChains(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.vulkanMemoryModelAvailabilityVisibilityChains = *ptr
	return x
}

// ShaderOutputViewportIndex returns the value of shaderOutputViewportIndex from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderOutputViewportIndex() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderOutputViewportIndex)
	return *ptr
}

// WithShaderOutputViewportIndex sets the value for the ShaderOutputViewportIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderOutputViewportIndex(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderOutputViewportIndex = *ptr
	return x
}

// ShaderOutputLayer returns the value of shaderOutputLayer from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderOutputLayer() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderOutputLayer)
	return *ptr
}

// WithShaderOutputLayer sets the value for the ShaderOutputLayer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderOutputLayer(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderOutputLayer = *ptr
	return x
}

// SubgroupBroadcastDynamicId returns the value of subgroupBroadcastDynamicId from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) SubgroupBroadcastDynamicId() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.subgroupBroadcastDynamicId)
	return *ptr
}

// WithSubgroupBroadcastDynamicId sets the value for the SubgroupBroadcastDynamicId on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithSubgroupBroadcastDynamicId(y Bool32) PhysicalDeviceVulkan12Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.subgroupBroadcastDynamicId = *ptr
	return x
}

//PhysicalDeviceVulkan11Properties provides a go interface for VkPhysicalDeviceVulkan11Properties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan11Properties.html
type PhysicalDeviceVulkan11Properties C.struct_VkPhysicalDeviceVulkan11Properties

// SizeofPhysicalDeviceVulkan11Properties is the memory size of a PhysicalDeviceVulkan11Properties
var SizeofPhysicalDeviceVulkan11Properties int = int(unsafe.Sizeof(PhysicalDeviceVulkan11Properties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceVulkan11Properties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceVulkan11Properties) AsCPtr() *PhysicalDeviceVulkan11Properties {
	clone := (*PhysicalDeviceVulkan11Properties)(newCBlock(C.ulong(SizeofPhysicalDeviceVulkan11Properties)))
	*clone = x
	return clone
}

// PhysicalDeviceVulkan11PropertiesFreeCSlice releases the memory allocated by PhysicalDeviceVulkan11PropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceVulkan11PropertiesFreeCSlice(x []PhysicalDeviceVulkan11Properties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceVulkan11PropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceVulkan11PropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceVulkan11PropertiesMakeCSlice(x ...PhysicalDeviceVulkan11Properties) []PhysicalDeviceVulkan11Properties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVulkan11Properties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceVulkan11Properties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceVulkan11Properties) WithDefaultSType() PhysicalDeviceVulkan11Properties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Properties) WithSType(y StructureType) PhysicalDeviceVulkan11Properties {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Properties) WithPNext(y unsafe.Pointer) PhysicalDeviceVulkan11Properties {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// DeviceUUID returns the value of deviceUUID from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) DeviceUUID() []byte {
	ptr := func(x *[VK_UUID_SIZE]C.uchar) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_UUID_SIZE)
		return &slc
	}(&x.deviceUUID)
	return *ptr
}

// DriverUUID returns the value of driverUUID from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) DriverUUID() []byte {
	ptr := func(x *[VK_UUID_SIZE]C.uchar) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_UUID_SIZE)
		return &slc
	}(&x.driverUUID)
	return *ptr
}

// DeviceLUID returns the value of deviceLUID from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) DeviceLUID() []byte {
	ptr := func(x *[VK_LUID_SIZE]C.uchar) *[]byte { /* Array */
		slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_LUID_SIZE)
		return &slc
	}(&x.deviceLUID)
	return *ptr
}

// DeviceNodeMask returns the value of deviceNodeMask from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) DeviceNodeMask() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.deviceNodeMask)
	return *ptr
}

// DeviceLUIDValid returns the value of deviceLUIDValid from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) DeviceLUIDValid() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.deviceLUIDValid)
	return *ptr
}

// SubgroupSize returns the value of subgroupSize from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) SubgroupSize() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.subgroupSize)
	return *ptr
}

// SubgroupSupportedStages returns the value of subgroupSupportedStages from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) SubgroupSupportedStages() ShaderStageFlags {
	ptr := /* typedef */ (*ShaderStageFlags)(&x.subgroupSupportedStages)
	return *ptr
}

// SubgroupSupportedOperations returns the value of subgroupSupportedOperations from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) SubgroupSupportedOperations() SubgroupFeatureFlags {
	ptr := /* typedef */ (*SubgroupFeatureFlags)(&x.subgroupSupportedOperations)
	return *ptr
}

// SubgroupQuadOperationsInAllStages returns the value of subgroupQuadOperationsInAllStages from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) SubgroupQuadOperationsInAllStages() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.subgroupQuadOperationsInAllStages)
	return *ptr
}

// PointClippingBehavior returns the value of pointClippingBehavior from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) PointClippingBehavior() PointClippingBehavior {
	ptr := /* typedef */ (*PointClippingBehavior)(&x.pointClippingBehavior)
	return *ptr
}

// MaxMultiviewViewCount returns the value of maxMultiviewViewCount from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) MaxMultiviewViewCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxMultiviewViewCount)
	return *ptr
}

// MaxMultiviewInstanceIndex returns the value of maxMultiviewInstanceIndex from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) MaxMultiviewInstanceIndex() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxMultiviewInstanceIndex)
	return *ptr
}

// ProtectedNoFault returns the value of protectedNoFault from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) ProtectedNoFault() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.protectedNoFault)
	return *ptr
}

// MaxPerSetDescriptors returns the value of maxPerSetDescriptors from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) MaxPerSetDescriptors() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxPerSetDescriptors)
	return *ptr
}

// MaxMemoryAllocationSize returns the value of maxMemoryAllocationSize from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) MaxMemoryAllocationSize() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.maxMemoryAllocationSize)
	return *ptr
}

//PhysicalDeviceScalarBlockLayoutFeatures provides a go interface for VkPhysicalDeviceScalarBlockLayoutFeatures.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceScalarBlockLayoutFeatures.html
type PhysicalDeviceScalarBlockLayoutFeatures C.struct_VkPhysicalDeviceScalarBlockLayoutFeatures

// SizeofPhysicalDeviceScalarBlockLayoutFeatures is the memory size of a PhysicalDeviceScalarBlockLayoutFeatures
var SizeofPhysicalDeviceScalarBlockLayoutFeatures int = int(unsafe.Sizeof(PhysicalDeviceScalarBlockLayoutFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceScalarBlockLayoutFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceScalarBlockLayoutFeatures) AsCPtr() *PhysicalDeviceScalarBlockLayoutFeatures {
	clone := (*PhysicalDeviceScalarBlockLayoutFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceScalarBlockLayoutFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceScalarBlockLayoutFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceScalarBlockLayoutFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceScalarBlockLayoutFeaturesFreeCSlice(x []PhysicalDeviceScalarBlockLayoutFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceScalarBlockLayoutFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceScalarBlockLayoutFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceScalarBlockLayoutFeaturesMakeCSlice(x ...PhysicalDeviceScalarBlockLayoutFeatures) []PhysicalDeviceScalarBlockLayoutFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceScalarBlockLayoutFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceScalarBlockLayoutFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceScalarBlockLayoutFeatures
func (x PhysicalDeviceScalarBlockLayoutFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceScalarBlockLayoutFeatures) WithDefaultSType() PhysicalDeviceScalarBlockLayoutFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceScalarBlockLayoutFeatures) WithSType(y StructureType) PhysicalDeviceScalarBlockLayoutFeatures {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceScalarBlockLayoutFeatures
func (x PhysicalDeviceScalarBlockLayoutFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceScalarBlockLayoutFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceScalarBlockLayoutFeatures {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// ScalarBlockLayout returns the value of scalarBlockLayout from VkPhysicalDeviceScalarBlockLayoutFeatures
func (x PhysicalDeviceScalarBlockLayoutFeatures) ScalarBlockLayout() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.scalarBlockLayout)
	return *ptr
}

// WithScalarBlockLayout sets the value for the ScalarBlockLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceScalarBlockLayoutFeatures) WithScalarBlockLayout(y Bool32) PhysicalDeviceScalarBlockLayoutFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.scalarBlockLayout = *ptr
	return x
}

//ImageStencilUsageCreateInfo provides a go interface for VkImageStencilUsageCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageStencilUsageCreateInfo.html
type ImageStencilUsageCreateInfo C.struct_VkImageStencilUsageCreateInfo

// SizeofImageStencilUsageCreateInfo is the memory size of a ImageStencilUsageCreateInfo
var SizeofImageStencilUsageCreateInfo int = int(unsafe.Sizeof(ImageStencilUsageCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageStencilUsageCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageStencilUsageCreateInfo) AsCPtr() *ImageStencilUsageCreateInfo {
	clone := (*ImageStencilUsageCreateInfo)(newCBlock(C.ulong(SizeofImageStencilUsageCreateInfo)))
	*clone = x
	return clone
}

// ImageStencilUsageCreateInfoFreeCSlice releases the memory allocated by ImageStencilUsageCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageStencilUsageCreateInfoFreeCSlice(x []ImageStencilUsageCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageStencilUsageCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageStencilUsageCreateInfoFreeCSlice must be called on the returned slice.
func ImageStencilUsageCreateInfoMakeCSlice(x ...ImageStencilUsageCreateInfo) []ImageStencilUsageCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageStencilUsageCreateInfo * len(x)
	dst := unsafe.Slice((*ImageStencilUsageCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageStencilUsageCreateInfo
func (x ImageStencilUsageCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ImageStencilUsageCreateInfo) WithDefaultSType() ImageStencilUsageCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageStencilUsageCreateInfo) WithSType(y StructureType) ImageStencilUsageCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkImageStencilUsageCreateInfo
func (x ImageStencilUsageCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageStencilUsageCreateInfo) WithPNext(y unsafe.Pointer) ImageStencilUsageCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// StencilUsage returns the value of stencilUsage from VkImageStencilUsageCreateInfo
func (x ImageStencilUsageCreateInfo) StencilUsage() ImageUsageFlags {
	ptr := /* typedef */ (*ImageUsageFlags)(&x.stencilUsage)
	return *ptr
}

// WithStencilUsage sets the value for the StencilUsage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageStencilUsageCreateInfo) WithStencilUsage(y ImageUsageFlags) ImageStencilUsageCreateInfo {
	ptr := /* typedef */ (*C.VkImageUsageFlags)(&y)
	x.stencilUsage = *ptr
	return x
}

//PhysicalDeviceVulkan11Features provides a go interface for VkPhysicalDeviceVulkan11Features.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan11Features.html
type PhysicalDeviceVulkan11Features C.struct_VkPhysicalDeviceVulkan11Features

// SizeofPhysicalDeviceVulkan11Features is the memory size of a PhysicalDeviceVulkan11Features
var SizeofPhysicalDeviceVulkan11Features int = int(unsafe.Sizeof(PhysicalDeviceVulkan11Features{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceVulkan11Features) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceVulkan11Features) AsCPtr() *PhysicalDeviceVulkan11Features {
	clone := (*PhysicalDeviceVulkan11Features)(newCBlock(C.ulong(SizeofPhysicalDeviceVulkan11Features)))
	*clone = x
	return clone
}

// PhysicalDeviceVulkan11FeaturesFreeCSlice releases the memory allocated by PhysicalDeviceVulkan11FeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceVulkan11FeaturesFreeCSlice(x []PhysicalDeviceVulkan11Features) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceVulkan11FeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceVulkan11FeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceVulkan11FeaturesMakeCSlice(x ...PhysicalDeviceVulkan11Features) []PhysicalDeviceVulkan11Features {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVulkan11Features * len(x)
	dst := unsafe.Slice((*PhysicalDeviceVulkan11Features)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceVulkan11Features) WithDefaultSType() PhysicalDeviceVulkan11Features {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithSType(y StructureType) PhysicalDeviceVulkan11Features {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithPNext(y unsafe.Pointer) PhysicalDeviceVulkan11Features {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// StorageBuffer16BitAccess returns the value of storageBuffer16BitAccess from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) StorageBuffer16BitAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storageBuffer16BitAccess)
	return *ptr
}

// WithStorageBuffer16BitAccess sets the value for the StorageBuffer16BitAccess on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithStorageBuffer16BitAccess(y Bool32) PhysicalDeviceVulkan11Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.storageBuffer16BitAccess = *ptr
	return x
}

// UniformAndStorageBuffer16BitAccess returns the value of uniformAndStorageBuffer16BitAccess from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) UniformAndStorageBuffer16BitAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.uniformAndStorageBuffer16BitAccess)
	return *ptr
}

// WithUniformAndStorageBuffer16BitAccess sets the value for the UniformAndStorageBuffer16BitAccess on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithUniformAndStorageBuffer16BitAccess(y Bool32) PhysicalDeviceVulkan11Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.uniformAndStorageBuffer16BitAccess = *ptr
	return x
}

// StoragePushConstant16 returns the value of storagePushConstant16 from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) StoragePushConstant16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storagePushConstant16)
	return *ptr
}

// WithStoragePushConstant16 sets the value for the StoragePushConstant16 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithStoragePushConstant16(y Bool32) PhysicalDeviceVulkan11Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.storagePushConstant16 = *ptr
	return x
}

// StorageInputOutput16 returns the value of storageInputOutput16 from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) StorageInputOutput16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storageInputOutput16)
	return *ptr
}

// WithStorageInputOutput16 sets the value for the StorageInputOutput16 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithStorageInputOutput16(y Bool32) PhysicalDeviceVulkan11Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.storageInputOutput16 = *ptr
	return x
}

// Multiview returns the value of multiview from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) Multiview() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.multiview)
	return *ptr
}

// WithMultiview sets the value for the Multiview on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithMultiview(y Bool32) PhysicalDeviceVulkan11Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.multiview = *ptr
	return x
}

// MultiviewGeometryShader returns the value of multiviewGeometryShader from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) MultiviewGeometryShader() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.multiviewGeometryShader)
	return *ptr
}

// WithMultiviewGeometryShader sets the value for the MultiviewGeometryShader on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithMultiviewGeometryShader(y Bool32) PhysicalDeviceVulkan11Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.multiviewGeometryShader = *ptr
	return x
}

// MultiviewTessellationShader returns the value of multiviewTessellationShader from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) MultiviewTessellationShader() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.multiviewTessellationShader)
	return *ptr
}

// WithMultiviewTessellationShader sets the value for the MultiviewTessellationShader on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithMultiviewTessellationShader(y Bool32) PhysicalDeviceVulkan11Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.multiviewTessellationShader = *ptr
	return x
}

// VariablePointersStorageBuffer returns the value of variablePointersStorageBuffer from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) VariablePointersStorageBuffer() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.variablePointersStorageBuffer)
	return *ptr
}

// WithVariablePointersStorageBuffer sets the value for the VariablePointersStorageBuffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithVariablePointersStorageBuffer(y Bool32) PhysicalDeviceVulkan11Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.variablePointersStorageBuffer = *ptr
	return x
}

// VariablePointers returns the value of variablePointers from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) VariablePointers() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.variablePointers)
	return *ptr
}

// WithVariablePointers sets the value for the VariablePointers on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithVariablePointers(y Bool32) PhysicalDeviceVulkan11Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.variablePointers = *ptr
	return x
}

// ProtectedMemory returns the value of protectedMemory from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) ProtectedMemory() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.protectedMemory)
	return *ptr
}

// WithProtectedMemory sets the value for the ProtectedMemory on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithProtectedMemory(y Bool32) PhysicalDeviceVulkan11Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.protectedMemory = *ptr
	return x
}

// SamplerYcbcrConversion returns the value of samplerYcbcrConversion from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) SamplerYcbcrConversion() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.samplerYcbcrConversion)
	return *ptr
}

// WithSamplerYcbcrConversion sets the value for the SamplerYcbcrConversion on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithSamplerYcbcrConversion(y Bool32) PhysicalDeviceVulkan11Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.samplerYcbcrConversion = *ptr
	return x
}

// ShaderDrawParameters returns the value of shaderDrawParameters from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) ShaderDrawParameters() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDrawParameters)
	return *ptr
}

// WithShaderDrawParameters sets the value for the ShaderDrawParameters on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithShaderDrawParameters(y Bool32) PhysicalDeviceVulkan11Features {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderDrawParameters = *ptr
	return x
}

//SamplerReductionModeCreateInfo provides a go interface for VkSamplerReductionModeCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSamplerReductionModeCreateInfo.html
type SamplerReductionModeCreateInfo C.struct_VkSamplerReductionModeCreateInfo

// SizeofSamplerReductionModeCreateInfo is the memory size of a SamplerReductionModeCreateInfo
var SizeofSamplerReductionModeCreateInfo int = int(unsafe.Sizeof(SamplerReductionModeCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SamplerReductionModeCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SamplerReductionModeCreateInfo) AsCPtr() *SamplerReductionModeCreateInfo {
	clone := (*SamplerReductionModeCreateInfo)(newCBlock(C.ulong(SizeofSamplerReductionModeCreateInfo)))
	*clone = x
	return clone
}

// SamplerReductionModeCreateInfoFreeCSlice releases the memory allocated by SamplerReductionModeCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SamplerReductionModeCreateInfoFreeCSlice(x []SamplerReductionModeCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SamplerReductionModeCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SamplerReductionModeCreateInfoFreeCSlice must be called on the returned slice.
func SamplerReductionModeCreateInfoMakeCSlice(x ...SamplerReductionModeCreateInfo) []SamplerReductionModeCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSamplerReductionModeCreateInfo * len(x)
	dst := unsafe.Slice((*SamplerReductionModeCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSamplerReductionModeCreateInfo
func (x SamplerReductionModeCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SamplerReductionModeCreateInfo) WithDefaultSType() SamplerReductionModeCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerReductionModeCreateInfo) WithSType(y StructureType) SamplerReductionModeCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkSamplerReductionModeCreateInfo
func (x SamplerReductionModeCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerReductionModeCreateInfo) WithPNext(y unsafe.Pointer) SamplerReductionModeCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// ReductionMode returns the value of reductionMode from VkSamplerReductionModeCreateInfo
func (x SamplerReductionModeCreateInfo) ReductionMode() SamplerReductionMode {
	ptr := /* typedef */ (*SamplerReductionMode)(&x.reductionMode)
	return *ptr
}

// WithReductionMode sets the value for the ReductionMode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerReductionModeCreateInfo) WithReductionMode(y SamplerReductionMode) SamplerReductionModeCreateInfo {
	ptr := /* typedef */ (*C.VkSamplerReductionMode)(&y)
	x.reductionMode = *ptr
	return x
}

//PhysicalDeviceSamplerFilterMinmaxProperties provides a go interface for VkPhysicalDeviceSamplerFilterMinmaxProperties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceSamplerFilterMinmaxProperties.html
type PhysicalDeviceSamplerFilterMinmaxProperties C.struct_VkPhysicalDeviceSamplerFilterMinmaxProperties

// SizeofPhysicalDeviceSamplerFilterMinmaxProperties is the memory size of a PhysicalDeviceSamplerFilterMinmaxProperties
var SizeofPhysicalDeviceSamplerFilterMinmaxProperties int = int(unsafe.Sizeof(PhysicalDeviceSamplerFilterMinmaxProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceSamplerFilterMinmaxProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceSamplerFilterMinmaxProperties) AsCPtr() *PhysicalDeviceSamplerFilterMinmaxProperties {
	clone := (*PhysicalDeviceSamplerFilterMinmaxProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceSamplerFilterMinmaxProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceSamplerFilterMinmaxPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceSamplerFilterMinmaxPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceSamplerFilterMinmaxPropertiesFreeCSlice(x []PhysicalDeviceSamplerFilterMinmaxProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceSamplerFilterMinmaxPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceSamplerFilterMinmaxPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceSamplerFilterMinmaxPropertiesMakeCSlice(x ...PhysicalDeviceSamplerFilterMinmaxProperties) []PhysicalDeviceSamplerFilterMinmaxProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSamplerFilterMinmaxProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceSamplerFilterMinmaxProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceSamplerFilterMinmaxProperties
func (x PhysicalDeviceSamplerFilterMinmaxProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceSamplerFilterMinmaxProperties) WithDefaultSType() PhysicalDeviceSamplerFilterMinmaxProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSamplerFilterMinmaxProperties) WithSType(y StructureType) PhysicalDeviceSamplerFilterMinmaxProperties {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceSamplerFilterMinmaxProperties
func (x PhysicalDeviceSamplerFilterMinmaxProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSamplerFilterMinmaxProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceSamplerFilterMinmaxProperties {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// FilterMinmaxSingleComponentFormats returns the value of filterMinmaxSingleComponentFormats from VkPhysicalDeviceSamplerFilterMinmaxProperties
func (x PhysicalDeviceSamplerFilterMinmaxProperties) FilterMinmaxSingleComponentFormats() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.filterMinmaxSingleComponentFormats)
	return *ptr
}

// FilterMinmaxImageComponentMapping returns the value of filterMinmaxImageComponentMapping from VkPhysicalDeviceSamplerFilterMinmaxProperties
func (x PhysicalDeviceSamplerFilterMinmaxProperties) FilterMinmaxImageComponentMapping() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.filterMinmaxImageComponentMapping)
	return *ptr
}

//PhysicalDeviceVulkanMemoryModelFeatures provides a go interface for VkPhysicalDeviceVulkanMemoryModelFeatures.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkanMemoryModelFeatures.html
type PhysicalDeviceVulkanMemoryModelFeatures C.struct_VkPhysicalDeviceVulkanMemoryModelFeatures

// SizeofPhysicalDeviceVulkanMemoryModelFeatures is the memory size of a PhysicalDeviceVulkanMemoryModelFeatures
var SizeofPhysicalDeviceVulkanMemoryModelFeatures int = int(unsafe.Sizeof(PhysicalDeviceVulkanMemoryModelFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceVulkanMemoryModelFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceVulkanMemoryModelFeatures) AsCPtr() *PhysicalDeviceVulkanMemoryModelFeatures {
	clone := (*PhysicalDeviceVulkanMemoryModelFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceVulkanMemoryModelFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceVulkanMemoryModelFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceVulkanMemoryModelFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceVulkanMemoryModelFeaturesFreeCSlice(x []PhysicalDeviceVulkanMemoryModelFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceVulkanMemoryModelFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceVulkanMemoryModelFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceVulkanMemoryModelFeaturesMakeCSlice(x ...PhysicalDeviceVulkanMemoryModelFeatures) []PhysicalDeviceVulkanMemoryModelFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVulkanMemoryModelFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceVulkanMemoryModelFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceVulkanMemoryModelFeatures
func (x PhysicalDeviceVulkanMemoryModelFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceVulkanMemoryModelFeatures) WithDefaultSType() PhysicalDeviceVulkanMemoryModelFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkanMemoryModelFeatures) WithSType(y StructureType) PhysicalDeviceVulkanMemoryModelFeatures {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceVulkanMemoryModelFeatures
func (x PhysicalDeviceVulkanMemoryModelFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkanMemoryModelFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceVulkanMemoryModelFeatures {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// VulkanMemoryModel returns the value of vulkanMemoryModel from VkPhysicalDeviceVulkanMemoryModelFeatures
func (x PhysicalDeviceVulkanMemoryModelFeatures) VulkanMemoryModel() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.vulkanMemoryModel)
	return *ptr
}

// WithVulkanMemoryModel sets the value for the VulkanMemoryModel on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkanMemoryModelFeatures) WithVulkanMemoryModel(y Bool32) PhysicalDeviceVulkanMemoryModelFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.vulkanMemoryModel = *ptr
	return x
}

// VulkanMemoryModelDeviceScope returns the value of vulkanMemoryModelDeviceScope from VkPhysicalDeviceVulkanMemoryModelFeatures
func (x PhysicalDeviceVulkanMemoryModelFeatures) VulkanMemoryModelDeviceScope() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.vulkanMemoryModelDeviceScope)
	return *ptr
}

// WithVulkanMemoryModelDeviceScope sets the value for the VulkanMemoryModelDeviceScope on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkanMemoryModelFeatures) WithVulkanMemoryModelDeviceScope(y Bool32) PhysicalDeviceVulkanMemoryModelFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.vulkanMemoryModelDeviceScope = *ptr
	return x
}

// VulkanMemoryModelAvailabilityVisibilityChains returns the value of vulkanMemoryModelAvailabilityVisibilityChains from VkPhysicalDeviceVulkanMemoryModelFeatures
func (x PhysicalDeviceVulkanMemoryModelFeatures) VulkanMemoryModelAvailabilityVisibilityChains() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.vulkanMemoryModelAvailabilityVisibilityChains)
	return *ptr
}

// WithVulkanMemoryModelAvailabilityVisibilityChains sets the value for the VulkanMemoryModelAvailabilityVisibilityChains on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkanMemoryModelFeatures) WithVulkanMemoryModelAvailabilityVisibilityChains(y Bool32) PhysicalDeviceVulkanMemoryModelFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.vulkanMemoryModelAvailabilityVisibilityChains = *ptr
	return x
}

//PhysicalDeviceImagelessFramebufferFeatures provides a go interface for VkPhysicalDeviceImagelessFramebufferFeatures.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceImagelessFramebufferFeatures.html
type PhysicalDeviceImagelessFramebufferFeatures C.struct_VkPhysicalDeviceImagelessFramebufferFeatures

// SizeofPhysicalDeviceImagelessFramebufferFeatures is the memory size of a PhysicalDeviceImagelessFramebufferFeatures
var SizeofPhysicalDeviceImagelessFramebufferFeatures int = int(unsafe.Sizeof(PhysicalDeviceImagelessFramebufferFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceImagelessFramebufferFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceImagelessFramebufferFeatures) AsCPtr() *PhysicalDeviceImagelessFramebufferFeatures {
	clone := (*PhysicalDeviceImagelessFramebufferFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceImagelessFramebufferFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceImagelessFramebufferFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceImagelessFramebufferFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceImagelessFramebufferFeaturesFreeCSlice(x []PhysicalDeviceImagelessFramebufferFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceImagelessFramebufferFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceImagelessFramebufferFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceImagelessFramebufferFeaturesMakeCSlice(x ...PhysicalDeviceImagelessFramebufferFeatures) []PhysicalDeviceImagelessFramebufferFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceImagelessFramebufferFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceImagelessFramebufferFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceImagelessFramebufferFeatures
func (x PhysicalDeviceImagelessFramebufferFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceImagelessFramebufferFeatures) WithDefaultSType() PhysicalDeviceImagelessFramebufferFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImagelessFramebufferFeatures) WithSType(y StructureType) PhysicalDeviceImagelessFramebufferFeatures {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceImagelessFramebufferFeatures
func (x PhysicalDeviceImagelessFramebufferFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImagelessFramebufferFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceImagelessFramebufferFeatures {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// ImagelessFramebuffer returns the value of imagelessFramebuffer from VkPhysicalDeviceImagelessFramebufferFeatures
func (x PhysicalDeviceImagelessFramebufferFeatures) ImagelessFramebuffer() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.imagelessFramebuffer)
	return *ptr
}

// WithImagelessFramebuffer sets the value for the ImagelessFramebuffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImagelessFramebufferFeatures) WithImagelessFramebuffer(y Bool32) PhysicalDeviceImagelessFramebufferFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.imagelessFramebuffer = *ptr
	return x
}

//FramebufferAttachmentsCreateInfo provides a go interface for VkFramebufferAttachmentsCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFramebufferAttachmentsCreateInfo.html
type FramebufferAttachmentsCreateInfo C.struct_VkFramebufferAttachmentsCreateInfo

// SizeofFramebufferAttachmentsCreateInfo is the memory size of a FramebufferAttachmentsCreateInfo
var SizeofFramebufferAttachmentsCreateInfo int = int(unsafe.Sizeof(FramebufferAttachmentsCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *FramebufferAttachmentsCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x FramebufferAttachmentsCreateInfo) AsCPtr() *FramebufferAttachmentsCreateInfo {
	clone := (*FramebufferAttachmentsCreateInfo)(newCBlock(C.ulong(SizeofFramebufferAttachmentsCreateInfo)))
	*clone = x
	return clone
}

// FramebufferAttachmentsCreateInfoFreeCSlice releases the memory allocated by FramebufferAttachmentsCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func FramebufferAttachmentsCreateInfoFreeCSlice(x []FramebufferAttachmentsCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// FramebufferAttachmentsCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. FramebufferAttachmentsCreateInfoFreeCSlice must be called on the returned slice.
func FramebufferAttachmentsCreateInfoMakeCSlice(x ...FramebufferAttachmentsCreateInfo) []FramebufferAttachmentsCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFramebufferAttachmentsCreateInfo * len(x)
	dst := unsafe.Slice((*FramebufferAttachmentsCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkFramebufferAttachmentsCreateInfo
func (x FramebufferAttachmentsCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x FramebufferAttachmentsCreateInfo) WithDefaultSType() FramebufferAttachmentsCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentsCreateInfo) WithSType(y StructureType) FramebufferAttachmentsCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkFramebufferAttachmentsCreateInfo
func (x FramebufferAttachmentsCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentsCreateInfo) WithPNext(y unsafe.Pointer) FramebufferAttachmentsCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// AttachmentImageInfoCount returns the value of attachmentImageInfoCount from VkFramebufferAttachmentsCreateInfo
func (x FramebufferAttachmentsCreateInfo) AttachmentImageInfoCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.attachmentImageInfoCount)
	return *ptr
}

// WithAttachmentImageInfoCount sets the value for the AttachmentImageInfoCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentsCreateInfo) WithAttachmentImageInfoCount(y uint32) FramebufferAttachmentsCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.attachmentImageInfoCount = *ptr
	return x
}

// PAttachmentImageInfos returns the value of pAttachmentImageInfos from VkFramebufferAttachmentsCreateInfo
func (x FramebufferAttachmentsCreateInfo) PAttachmentImageInfos() []FramebufferAttachmentImageInfo {
	ptr := func(x **C.struct_VkFramebufferAttachmentImageInfo) *[]FramebufferAttachmentImageInfo { /* Slice */
		slc := unsafe.Slice((*FramebufferAttachmentImageInfo)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pAttachmentImageInfos)
	return *ptr
}

// WithPAttachmentImageInfos sets the value for the PAttachmentImageInfos on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines AttachmentImageInfoCount as the length of this field.
// AttachmentImageInfoCount is updated with the length of the new value.
func (x FramebufferAttachmentsCreateInfo) WithPAttachmentImageInfos(y []FramebufferAttachmentImageInfo) FramebufferAttachmentsCreateInfo {
	ptr := func(x *[]FramebufferAttachmentImageInfo) **C.struct_VkFramebufferAttachmentImageInfo { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkFramebufferAttachmentImageInfo)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkFramebufferAttachmentImageInfo)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pAttachmentImageInfos = *ptr
	return x.WithAttachmentImageInfoCount(uint32(len(y)))
}

//FramebufferAttachmentImageInfo provides a go interface for VkFramebufferAttachmentImageInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFramebufferAttachmentImageInfo.html
type FramebufferAttachmentImageInfo C.struct_VkFramebufferAttachmentImageInfo

// SizeofFramebufferAttachmentImageInfo is the memory size of a FramebufferAttachmentImageInfo
var SizeofFramebufferAttachmentImageInfo int = int(unsafe.Sizeof(FramebufferAttachmentImageInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *FramebufferAttachmentImageInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x FramebufferAttachmentImageInfo) AsCPtr() *FramebufferAttachmentImageInfo {
	clone := (*FramebufferAttachmentImageInfo)(newCBlock(C.ulong(SizeofFramebufferAttachmentImageInfo)))
	*clone = x
	return clone
}

// FramebufferAttachmentImageInfoFreeCSlice releases the memory allocated by FramebufferAttachmentImageInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func FramebufferAttachmentImageInfoFreeCSlice(x []FramebufferAttachmentImageInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// FramebufferAttachmentImageInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. FramebufferAttachmentImageInfoFreeCSlice must be called on the returned slice.
func FramebufferAttachmentImageInfoMakeCSlice(x ...FramebufferAttachmentImageInfo) []FramebufferAttachmentImageInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFramebufferAttachmentImageInfo * len(x)
	dst := unsafe.Slice((*FramebufferAttachmentImageInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkFramebufferAttachmentImageInfo
func (x FramebufferAttachmentImageInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x FramebufferAttachmentImageInfo) WithDefaultSType() FramebufferAttachmentImageInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentImageInfo) WithSType(y StructureType) FramebufferAttachmentImageInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkFramebufferAttachmentImageInfo
func (x FramebufferAttachmentImageInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentImageInfo) WithPNext(y unsafe.Pointer) FramebufferAttachmentImageInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkFramebufferAttachmentImageInfo
func (x FramebufferAttachmentImageInfo) Flags() ImageCreateFlags {
	ptr := /* typedef */ (*ImageCreateFlags)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentImageInfo) WithFlags(y ImageCreateFlags) FramebufferAttachmentImageInfo {
	ptr := /* typedef */ (*C.VkImageCreateFlags)(&y)
	x.flags = *ptr
	return x
}

// Usage returns the value of usage from VkFramebufferAttachmentImageInfo
func (x FramebufferAttachmentImageInfo) Usage() ImageUsageFlags {
	ptr := /* typedef */ (*ImageUsageFlags)(&x.usage)
	return *ptr
}

// WithUsage sets the value for the Usage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentImageInfo) WithUsage(y ImageUsageFlags) FramebufferAttachmentImageInfo {
	ptr := /* typedef */ (*C.VkImageUsageFlags)(&y)
	x.usage = *ptr
	return x
}

// Width returns the value of width from VkFramebufferAttachmentImageInfo
func (x FramebufferAttachmentImageInfo) Width() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.width)
	return *ptr
}

// WithWidth sets the value for the Width on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentImageInfo) WithWidth(y uint32) FramebufferAttachmentImageInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.width = *ptr
	return x
}

// Height returns the value of height from VkFramebufferAttachmentImageInfo
func (x FramebufferAttachmentImageInfo) Height() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.height)
	return *ptr
}

// WithHeight sets the value for the Height on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentImageInfo) WithHeight(y uint32) FramebufferAttachmentImageInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.height = *ptr
	return x
}

// LayerCount returns the value of layerCount from VkFramebufferAttachmentImageInfo
func (x FramebufferAttachmentImageInfo) LayerCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.layerCount)
	return *ptr
}

// WithLayerCount sets the value for the LayerCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentImageInfo) WithLayerCount(y uint32) FramebufferAttachmentImageInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.layerCount = *ptr
	return x
}

// ViewFormatCount returns the value of viewFormatCount from VkFramebufferAttachmentImageInfo
func (x FramebufferAttachmentImageInfo) ViewFormatCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.viewFormatCount)
	return *ptr
}

// WithViewFormatCount sets the value for the ViewFormatCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentImageInfo) WithViewFormatCount(y uint32) FramebufferAttachmentImageInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.viewFormatCount = *ptr
	return x
}

// PViewFormats returns the value of pViewFormats from VkFramebufferAttachmentImageInfo
func (x FramebufferAttachmentImageInfo) PViewFormats() []Format {
	ptr := func(x **C.VkFormat) *[]Format { /* Slice */
		slc := unsafe.Slice((*Format)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pViewFormats)
	return *ptr
}

// WithPViewFormats sets the value for the PViewFormats on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines ViewFormatCount as the length of this field.
// ViewFormatCount is updated with the length of the new value.
func (x FramebufferAttachmentImageInfo) WithPViewFormats(y []Format) FramebufferAttachmentImageInfo {
	ptr := func(x *[]Format) **C.VkFormat { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkFormat)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkFormat)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pViewFormats = *ptr
	return x.WithViewFormatCount(uint32(len(y)))
}

//RenderPassAttachmentBeginInfo provides a go interface for VkRenderPassAttachmentBeginInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkRenderPassAttachmentBeginInfo.html
type RenderPassAttachmentBeginInfo C.struct_VkRenderPassAttachmentBeginInfo

// SizeofRenderPassAttachmentBeginInfo is the memory size of a RenderPassAttachmentBeginInfo
var SizeofRenderPassAttachmentBeginInfo int = int(unsafe.Sizeof(RenderPassAttachmentBeginInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *RenderPassAttachmentBeginInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x RenderPassAttachmentBeginInfo) AsCPtr() *RenderPassAttachmentBeginInfo {
	clone := (*RenderPassAttachmentBeginInfo)(newCBlock(C.ulong(SizeofRenderPassAttachmentBeginInfo)))
	*clone = x
	return clone
}

// RenderPassAttachmentBeginInfoFreeCSlice releases the memory allocated by RenderPassAttachmentBeginInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func RenderPassAttachmentBeginInfoFreeCSlice(x []RenderPassAttachmentBeginInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// RenderPassAttachmentBeginInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. RenderPassAttachmentBeginInfoFreeCSlice must be called on the returned slice.
func RenderPassAttachmentBeginInfoMakeCSlice(x ...RenderPassAttachmentBeginInfo) []RenderPassAttachmentBeginInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderPassAttachmentBeginInfo * len(x)
	dst := unsafe.Slice((*RenderPassAttachmentBeginInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkRenderPassAttachmentBeginInfo
func (x RenderPassAttachmentBeginInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x RenderPassAttachmentBeginInfo) WithDefaultSType() RenderPassAttachmentBeginInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassAttachmentBeginInfo) WithSType(y StructureType) RenderPassAttachmentBeginInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkRenderPassAttachmentBeginInfo
func (x RenderPassAttachmentBeginInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassAttachmentBeginInfo) WithPNext(y unsafe.Pointer) RenderPassAttachmentBeginInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// AttachmentCount returns the value of attachmentCount from VkRenderPassAttachmentBeginInfo
func (x RenderPassAttachmentBeginInfo) AttachmentCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.attachmentCount)
	return *ptr
}

// WithAttachmentCount sets the value for the AttachmentCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassAttachmentBeginInfo) WithAttachmentCount(y uint32) RenderPassAttachmentBeginInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.attachmentCount = *ptr
	return x
}

// PAttachments returns the value of pAttachments from VkRenderPassAttachmentBeginInfo
func (x RenderPassAttachmentBeginInfo) PAttachments() []ImageView {
	ptr := func(x **C.VkImageView) *[]ImageView { /* Slice */
		slc := unsafe.Slice((*ImageView)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pAttachments)
	return *ptr
}

// WithPAttachments sets the value for the PAttachments on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines AttachmentCount as the length of this field.
// AttachmentCount is updated with the length of the new value.
func (x RenderPassAttachmentBeginInfo) WithPAttachments(y []ImageView) RenderPassAttachmentBeginInfo {
	ptr := func(x *[]ImageView) **C.VkImageView { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkImageView)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkImageView)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pAttachments = *ptr
	return x.WithAttachmentCount(uint32(len(y)))
}

//PhysicalDeviceUniformBufferStandardLayoutFeatures provides a go interface for VkPhysicalDeviceUniformBufferStandardLayoutFeatures.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceUniformBufferStandardLayoutFeatures.html
type PhysicalDeviceUniformBufferStandardLayoutFeatures C.struct_VkPhysicalDeviceUniformBufferStandardLayoutFeatures

// SizeofPhysicalDeviceUniformBufferStandardLayoutFeatures is the memory size of a PhysicalDeviceUniformBufferStandardLayoutFeatures
var SizeofPhysicalDeviceUniformBufferStandardLayoutFeatures int = int(unsafe.Sizeof(PhysicalDeviceUniformBufferStandardLayoutFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceUniformBufferStandardLayoutFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceUniformBufferStandardLayoutFeatures) AsCPtr() *PhysicalDeviceUniformBufferStandardLayoutFeatures {
	clone := (*PhysicalDeviceUniformBufferStandardLayoutFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceUniformBufferStandardLayoutFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceUniformBufferStandardLayoutFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceUniformBufferStandardLayoutFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceUniformBufferStandardLayoutFeaturesFreeCSlice(x []PhysicalDeviceUniformBufferStandardLayoutFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceUniformBufferStandardLayoutFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceUniformBufferStandardLayoutFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceUniformBufferStandardLayoutFeaturesMakeCSlice(x ...PhysicalDeviceUniformBufferStandardLayoutFeatures) []PhysicalDeviceUniformBufferStandardLayoutFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceUniformBufferStandardLayoutFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceUniformBufferStandardLayoutFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceUniformBufferStandardLayoutFeatures
func (x PhysicalDeviceUniformBufferStandardLayoutFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceUniformBufferStandardLayoutFeatures) WithDefaultSType() PhysicalDeviceUniformBufferStandardLayoutFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceUniformBufferStandardLayoutFeatures) WithSType(y StructureType) PhysicalDeviceUniformBufferStandardLayoutFeatures {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceUniformBufferStandardLayoutFeatures
func (x PhysicalDeviceUniformBufferStandardLayoutFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceUniformBufferStandardLayoutFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceUniformBufferStandardLayoutFeatures {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// UniformBufferStandardLayout returns the value of uniformBufferStandardLayout from VkPhysicalDeviceUniformBufferStandardLayoutFeatures
func (x PhysicalDeviceUniformBufferStandardLayoutFeatures) UniformBufferStandardLayout() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.uniformBufferStandardLayout)
	return *ptr
}

// WithUniformBufferStandardLayout sets the value for the UniformBufferStandardLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceUniformBufferStandardLayoutFeatures) WithUniformBufferStandardLayout(y Bool32) PhysicalDeviceUniformBufferStandardLayoutFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.uniformBufferStandardLayout = *ptr
	return x
}

//PhysicalDeviceShaderSubgroupExtendedTypesFeatures provides a go interface for VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.html
type PhysicalDeviceShaderSubgroupExtendedTypesFeatures C.struct_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures

// SizeofPhysicalDeviceShaderSubgroupExtendedTypesFeatures is the memory size of a PhysicalDeviceShaderSubgroupExtendedTypesFeatures
var SizeofPhysicalDeviceShaderSubgroupExtendedTypesFeatures int = int(unsafe.Sizeof(PhysicalDeviceShaderSubgroupExtendedTypesFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceShaderSubgroupExtendedTypesFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceShaderSubgroupExtendedTypesFeatures) AsCPtr() *PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
	clone := (*PhysicalDeviceShaderSubgroupExtendedTypesFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceShaderSubgroupExtendedTypesFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceShaderSubgroupExtendedTypesFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceShaderSubgroupExtendedTypesFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceShaderSubgroupExtendedTypesFeaturesFreeCSlice(x []PhysicalDeviceShaderSubgroupExtendedTypesFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceShaderSubgroupExtendedTypesFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceShaderSubgroupExtendedTypesFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceShaderSubgroupExtendedTypesFeaturesMakeCSlice(x ...PhysicalDeviceShaderSubgroupExtendedTypesFeatures) []PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderSubgroupExtendedTypesFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceShaderSubgroupExtendedTypesFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures
func (x PhysicalDeviceShaderSubgroupExtendedTypesFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceShaderSubgroupExtendedTypesFeatures) WithDefaultSType() PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderSubgroupExtendedTypesFeatures) WithSType(y StructureType) PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures
func (x PhysicalDeviceShaderSubgroupExtendedTypesFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderSubgroupExtendedTypesFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// ShaderSubgroupExtendedTypes returns the value of shaderSubgroupExtendedTypes from VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures
func (x PhysicalDeviceShaderSubgroupExtendedTypesFeatures) ShaderSubgroupExtendedTypes() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSubgroupExtendedTypes)
	return *ptr
}

// WithShaderSubgroupExtendedTypes sets the value for the ShaderSubgroupExtendedTypes on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderSubgroupExtendedTypesFeatures) WithShaderSubgroupExtendedTypes(y Bool32) PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderSubgroupExtendedTypes = *ptr
	return x
}

//PhysicalDeviceSeparateDepthStencilLayoutsFeatures provides a go interface for VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.html
type PhysicalDeviceSeparateDepthStencilLayoutsFeatures C.struct_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures

// SizeofPhysicalDeviceSeparateDepthStencilLayoutsFeatures is the memory size of a PhysicalDeviceSeparateDepthStencilLayoutsFeatures
var SizeofPhysicalDeviceSeparateDepthStencilLayoutsFeatures int = int(unsafe.Sizeof(PhysicalDeviceSeparateDepthStencilLayoutsFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceSeparateDepthStencilLayoutsFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceSeparateDepthStencilLayoutsFeatures) AsCPtr() *PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
	clone := (*PhysicalDeviceSeparateDepthStencilLayoutsFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceSeparateDepthStencilLayoutsFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceSeparateDepthStencilLayoutsFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceSeparateDepthStencilLayoutsFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceSeparateDepthStencilLayoutsFeaturesFreeCSlice(x []PhysicalDeviceSeparateDepthStencilLayoutsFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceSeparateDepthStencilLayoutsFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceSeparateDepthStencilLayoutsFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceSeparateDepthStencilLayoutsFeaturesMakeCSlice(x ...PhysicalDeviceSeparateDepthStencilLayoutsFeatures) []PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSeparateDepthStencilLayoutsFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceSeparateDepthStencilLayoutsFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures
func (x PhysicalDeviceSeparateDepthStencilLayoutsFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceSeparateDepthStencilLayoutsFeatures) WithDefaultSType() PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSeparateDepthStencilLayoutsFeatures) WithSType(y StructureType) PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures
func (x PhysicalDeviceSeparateDepthStencilLayoutsFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSeparateDepthStencilLayoutsFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// SeparateDepthStencilLayouts returns the value of separateDepthStencilLayouts from VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures
func (x PhysicalDeviceSeparateDepthStencilLayoutsFeatures) SeparateDepthStencilLayouts() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.separateDepthStencilLayouts)
	return *ptr
}

// WithSeparateDepthStencilLayouts sets the value for the SeparateDepthStencilLayouts on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSeparateDepthStencilLayoutsFeatures) WithSeparateDepthStencilLayouts(y Bool32) PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.separateDepthStencilLayouts = *ptr
	return x
}

//AttachmentReferenceStencilLayout provides a go interface for VkAttachmentReferenceStencilLayout.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkAttachmentReferenceStencilLayout.html
type AttachmentReferenceStencilLayout C.struct_VkAttachmentReferenceStencilLayout

// SizeofAttachmentReferenceStencilLayout is the memory size of a AttachmentReferenceStencilLayout
var SizeofAttachmentReferenceStencilLayout int = int(unsafe.Sizeof(AttachmentReferenceStencilLayout{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *AttachmentReferenceStencilLayout) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x AttachmentReferenceStencilLayout) AsCPtr() *AttachmentReferenceStencilLayout {
	clone := (*AttachmentReferenceStencilLayout)(newCBlock(C.ulong(SizeofAttachmentReferenceStencilLayout)))
	*clone = x
	return clone
}

// AttachmentReferenceStencilLayoutFreeCSlice releases the memory allocated by AttachmentReferenceStencilLayoutMakeCSlice.
// It does not free pointers stored inside the slice.
func AttachmentReferenceStencilLayoutFreeCSlice(x []AttachmentReferenceStencilLayout) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// AttachmentReferenceStencilLayoutMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. AttachmentReferenceStencilLayoutFreeCSlice must be called on the returned slice.
func AttachmentReferenceStencilLayoutMakeCSlice(x ...AttachmentReferenceStencilLayout) []AttachmentReferenceStencilLayout {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAttachmentReferenceStencilLayout * len(x)
	dst := unsafe.Slice((*AttachmentReferenceStencilLayout)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkAttachmentReferenceStencilLayout
func (x AttachmentReferenceStencilLayout) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x AttachmentReferenceStencilLayout) WithDefaultSType() AttachmentReferenceStencilLayout {
	return x.WithSType(VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReferenceStencilLayout) WithSType(y StructureType) AttachmentReferenceStencilLayout {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkAttachmentReferenceStencilLayout
func (x AttachmentReferenceStencilLayout) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReferenceStencilLayout) WithPNext(y unsafe.Pointer) AttachmentReferenceStencilLayout {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// StencilLayout returns the value of stencilLayout from VkAttachmentReferenceStencilLayout
func (x AttachmentReferenceStencilLayout) StencilLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.stencilLayout)
	return *ptr
}

// WithStencilLayout sets the value for the StencilLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReferenceStencilLayout) WithStencilLayout(y ImageLayout) AttachmentReferenceStencilLayout {
	ptr := /* typedef */ (*C.VkImageLayout)(&y)
	x.stencilLayout = *ptr
	return x
}

//AttachmentDescriptionStencilLayout provides a go interface for VkAttachmentDescriptionStencilLayout.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkAttachmentDescriptionStencilLayout.html
type AttachmentDescriptionStencilLayout C.struct_VkAttachmentDescriptionStencilLayout

// SizeofAttachmentDescriptionStencilLayout is the memory size of a AttachmentDescriptionStencilLayout
var SizeofAttachmentDescriptionStencilLayout int = int(unsafe.Sizeof(AttachmentDescriptionStencilLayout{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *AttachmentDescriptionStencilLayout) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x AttachmentDescriptionStencilLayout) AsCPtr() *AttachmentDescriptionStencilLayout {
	clone := (*AttachmentDescriptionStencilLayout)(newCBlock(C.ulong(SizeofAttachmentDescriptionStencilLayout)))
	*clone = x
	return clone
}

// AttachmentDescriptionStencilLayoutFreeCSlice releases the memory allocated by AttachmentDescriptionStencilLayoutMakeCSlice.
// It does not free pointers stored inside the slice.
func AttachmentDescriptionStencilLayoutFreeCSlice(x []AttachmentDescriptionStencilLayout) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// AttachmentDescriptionStencilLayoutMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. AttachmentDescriptionStencilLayoutFreeCSlice must be called on the returned slice.
func AttachmentDescriptionStencilLayoutMakeCSlice(x ...AttachmentDescriptionStencilLayout) []AttachmentDescriptionStencilLayout {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAttachmentDescriptionStencilLayout * len(x)
	dst := unsafe.Slice((*AttachmentDescriptionStencilLayout)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkAttachmentDescriptionStencilLayout
func (x AttachmentDescriptionStencilLayout) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x AttachmentDescriptionStencilLayout) WithDefaultSType() AttachmentDescriptionStencilLayout {
	return x.WithSType(VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescriptionStencilLayout) WithSType(y StructureType) AttachmentDescriptionStencilLayout {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkAttachmentDescriptionStencilLayout
func (x AttachmentDescriptionStencilLayout) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescriptionStencilLayout) WithPNext(y unsafe.Pointer) AttachmentDescriptionStencilLayout {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// StencilInitialLayout returns the value of stencilInitialLayout from VkAttachmentDescriptionStencilLayout
func (x AttachmentDescriptionStencilLayout) StencilInitialLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.stencilInitialLayout)
	return *ptr
}

// WithStencilInitialLayout sets the value for the StencilInitialLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescriptionStencilLayout) WithStencilInitialLayout(y ImageLayout) AttachmentDescriptionStencilLayout {
	ptr := /* typedef */ (*C.VkImageLayout)(&y)
	x.stencilInitialLayout = *ptr
	return x
}

// StencilFinalLayout returns the value of stencilFinalLayout from VkAttachmentDescriptionStencilLayout
func (x AttachmentDescriptionStencilLayout) StencilFinalLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.stencilFinalLayout)
	return *ptr
}

// WithStencilFinalLayout sets the value for the StencilFinalLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescriptionStencilLayout) WithStencilFinalLayout(y ImageLayout) AttachmentDescriptionStencilLayout {
	ptr := /* typedef */ (*C.VkImageLayout)(&y)
	x.stencilFinalLayout = *ptr
	return x
}

//TimelineSemaphoreSubmitInfo provides a go interface for VkTimelineSemaphoreSubmitInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkTimelineSemaphoreSubmitInfo.html
type TimelineSemaphoreSubmitInfo C.struct_VkTimelineSemaphoreSubmitInfo

// SizeofTimelineSemaphoreSubmitInfo is the memory size of a TimelineSemaphoreSubmitInfo
var SizeofTimelineSemaphoreSubmitInfo int = int(unsafe.Sizeof(TimelineSemaphoreSubmitInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *TimelineSemaphoreSubmitInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x TimelineSemaphoreSubmitInfo) AsCPtr() *TimelineSemaphoreSubmitInfo {
	clone := (*TimelineSemaphoreSubmitInfo)(newCBlock(C.ulong(SizeofTimelineSemaphoreSubmitInfo)))
	*clone = x
	return clone
}

// TimelineSemaphoreSubmitInfoFreeCSlice releases the memory allocated by TimelineSemaphoreSubmitInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func TimelineSemaphoreSubmitInfoFreeCSlice(x []TimelineSemaphoreSubmitInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// TimelineSemaphoreSubmitInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. TimelineSemaphoreSubmitInfoFreeCSlice must be called on the returned slice.
func TimelineSemaphoreSubmitInfoMakeCSlice(x ...TimelineSemaphoreSubmitInfo) []TimelineSemaphoreSubmitInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofTimelineSemaphoreSubmitInfo * len(x)
	dst := unsafe.Slice((*TimelineSemaphoreSubmitInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkTimelineSemaphoreSubmitInfo
func (x TimelineSemaphoreSubmitInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x TimelineSemaphoreSubmitInfo) WithDefaultSType() TimelineSemaphoreSubmitInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x TimelineSemaphoreSubmitInfo) WithSType(y StructureType) TimelineSemaphoreSubmitInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkTimelineSemaphoreSubmitInfo
func (x TimelineSemaphoreSubmitInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x TimelineSemaphoreSubmitInfo) WithPNext(y unsafe.Pointer) TimelineSemaphoreSubmitInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// WaitSemaphoreValueCount returns the value of waitSemaphoreValueCount from VkTimelineSemaphoreSubmitInfo
func (x TimelineSemaphoreSubmitInfo) WaitSemaphoreValueCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.waitSemaphoreValueCount)
	return *ptr
}

// WithWaitSemaphoreValueCount sets the value for the WaitSemaphoreValueCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x TimelineSemaphoreSubmitInfo) WithWaitSemaphoreValueCount(y uint32) TimelineSemaphoreSubmitInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.waitSemaphoreValueCount = *ptr
	return x
}

// PWaitSemaphoreValues returns the value of pWaitSemaphoreValues from VkTimelineSemaphoreSubmitInfo
func (x TimelineSemaphoreSubmitInfo) PWaitSemaphoreValues() []uint64 {
	ptr := func(x **C.ulonglong) *[]uint64 { /* Slice */
		slc := unsafe.Slice((*uint64)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pWaitSemaphoreValues)
	return *ptr
}

// WithPWaitSemaphoreValues sets the value for the PWaitSemaphoreValues on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines WaitSemaphoreValueCount as the length of this field.
// WaitSemaphoreValueCount is updated with the length of the new value.
func (x TimelineSemaphoreSubmitInfo) WithPWaitSemaphoreValues(y []uint64) TimelineSemaphoreSubmitInfo {
	ptr := func(x *[]uint64) **C.ulonglong { /* Slice */
		if len(*x) > 0 {
			slc := (*C.ulonglong)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.ulonglong)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pWaitSemaphoreValues = *ptr
	return x.WithWaitSemaphoreValueCount(uint32(len(y)))
}

// SignalSemaphoreValueCount returns the value of signalSemaphoreValueCount from VkTimelineSemaphoreSubmitInfo
func (x TimelineSemaphoreSubmitInfo) SignalSemaphoreValueCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.signalSemaphoreValueCount)
	return *ptr
}

// WithSignalSemaphoreValueCount sets the value for the SignalSemaphoreValueCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x TimelineSemaphoreSubmitInfo) WithSignalSemaphoreValueCount(y uint32) TimelineSemaphoreSubmitInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.signalSemaphoreValueCount = *ptr
	return x
}

// PSignalSemaphoreValues returns the value of pSignalSemaphoreValues from VkTimelineSemaphoreSubmitInfo
func (x TimelineSemaphoreSubmitInfo) PSignalSemaphoreValues() []uint64 {
	ptr := func(x **C.ulonglong) *[]uint64 { /* Slice */
		slc := unsafe.Slice((*uint64)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pSignalSemaphoreValues)
	return *ptr
}

// WithPSignalSemaphoreValues sets the value for the PSignalSemaphoreValues on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SignalSemaphoreValueCount as the length of this field.
// SignalSemaphoreValueCount is updated with the length of the new value.
func (x TimelineSemaphoreSubmitInfo) WithPSignalSemaphoreValues(y []uint64) TimelineSemaphoreSubmitInfo {
	ptr := func(x *[]uint64) **C.ulonglong { /* Slice */
		if len(*x) > 0 {
			slc := (*C.ulonglong)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.ulonglong)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pSignalSemaphoreValues = *ptr
	return x.WithSignalSemaphoreValueCount(uint32(len(y)))
}

//PhysicalDeviceHostQueryResetFeatures provides a go interface for VkPhysicalDeviceHostQueryResetFeatures.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceHostQueryResetFeatures.html
type PhysicalDeviceHostQueryResetFeatures C.struct_VkPhysicalDeviceHostQueryResetFeatures

// SizeofPhysicalDeviceHostQueryResetFeatures is the memory size of a PhysicalDeviceHostQueryResetFeatures
var SizeofPhysicalDeviceHostQueryResetFeatures int = int(unsafe.Sizeof(PhysicalDeviceHostQueryResetFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceHostQueryResetFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceHostQueryResetFeatures) AsCPtr() *PhysicalDeviceHostQueryResetFeatures {
	clone := (*PhysicalDeviceHostQueryResetFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceHostQueryResetFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceHostQueryResetFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceHostQueryResetFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceHostQueryResetFeaturesFreeCSlice(x []PhysicalDeviceHostQueryResetFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceHostQueryResetFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceHostQueryResetFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceHostQueryResetFeaturesMakeCSlice(x ...PhysicalDeviceHostQueryResetFeatures) []PhysicalDeviceHostQueryResetFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceHostQueryResetFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceHostQueryResetFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceHostQueryResetFeatures
func (x PhysicalDeviceHostQueryResetFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceHostQueryResetFeatures) WithDefaultSType() PhysicalDeviceHostQueryResetFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceHostQueryResetFeatures) WithSType(y StructureType) PhysicalDeviceHostQueryResetFeatures {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceHostQueryResetFeatures
func (x PhysicalDeviceHostQueryResetFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceHostQueryResetFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceHostQueryResetFeatures {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// HostQueryReset returns the value of hostQueryReset from VkPhysicalDeviceHostQueryResetFeatures
func (x PhysicalDeviceHostQueryResetFeatures) HostQueryReset() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.hostQueryReset)
	return *ptr
}

// WithHostQueryReset sets the value for the HostQueryReset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceHostQueryResetFeatures) WithHostQueryReset(y Bool32) PhysicalDeviceHostQueryResetFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.hostQueryReset = *ptr
	return x
}

//SemaphoreTypeCreateInfo provides a go interface for VkSemaphoreTypeCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSemaphoreTypeCreateInfo.html
type SemaphoreTypeCreateInfo C.struct_VkSemaphoreTypeCreateInfo

// SizeofSemaphoreTypeCreateInfo is the memory size of a SemaphoreTypeCreateInfo
var SizeofSemaphoreTypeCreateInfo int = int(unsafe.Sizeof(SemaphoreTypeCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SemaphoreTypeCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SemaphoreTypeCreateInfo) AsCPtr() *SemaphoreTypeCreateInfo {
	clone := (*SemaphoreTypeCreateInfo)(newCBlock(C.ulong(SizeofSemaphoreTypeCreateInfo)))
	*clone = x
	return clone
}

// SemaphoreTypeCreateInfoFreeCSlice releases the memory allocated by SemaphoreTypeCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SemaphoreTypeCreateInfoFreeCSlice(x []SemaphoreTypeCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SemaphoreTypeCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SemaphoreTypeCreateInfoFreeCSlice must be called on the returned slice.
func SemaphoreTypeCreateInfoMakeCSlice(x ...SemaphoreTypeCreateInfo) []SemaphoreTypeCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSemaphoreTypeCreateInfo * len(x)
	dst := unsafe.Slice((*SemaphoreTypeCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSemaphoreTypeCreateInfo
func (x SemaphoreTypeCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SemaphoreTypeCreateInfo) WithDefaultSType() SemaphoreTypeCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreTypeCreateInfo) WithSType(y StructureType) SemaphoreTypeCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkSemaphoreTypeCreateInfo
func (x SemaphoreTypeCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreTypeCreateInfo) WithPNext(y unsafe.Pointer) SemaphoreTypeCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// SemaphoreType returns the value of semaphoreType from VkSemaphoreTypeCreateInfo
func (x SemaphoreTypeCreateInfo) SemaphoreType() SemaphoreType {
	ptr := /* typedef */ (*SemaphoreType)(&x.semaphoreType)
	return *ptr
}

// WithSemaphoreType sets the value for the SemaphoreType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreTypeCreateInfo) WithSemaphoreType(y SemaphoreType) SemaphoreTypeCreateInfo {
	ptr := /* typedef */ (*C.VkSemaphoreType)(&y)
	x.semaphoreType = *ptr
	return x
}

// InitialValue returns the value of initialValue from VkSemaphoreTypeCreateInfo
func (x SemaphoreTypeCreateInfo) InitialValue() uint64 {
	ptr := func(x *C.ulonglong) *uint64 { /* Scalar */ return (*uint64)(unsafe.Pointer(x)) }(&x.initialValue)
	return *ptr
}

// WithInitialValue sets the value for the InitialValue on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreTypeCreateInfo) WithInitialValue(y uint64) SemaphoreTypeCreateInfo {
	ptr := func(x *uint64) *C.ulonglong { /* Scalar */ return (*C.ulonglong)(unsafe.Pointer(x)) }(&y)
	x.initialValue = *ptr
	return x
}

//PhysicalDeviceTimelineSemaphoreProperties provides a go interface for VkPhysicalDeviceTimelineSemaphoreProperties.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceTimelineSemaphoreProperties.html
type PhysicalDeviceTimelineSemaphoreProperties C.struct_VkPhysicalDeviceTimelineSemaphoreProperties

// SizeofPhysicalDeviceTimelineSemaphoreProperties is the memory size of a PhysicalDeviceTimelineSemaphoreProperties
var SizeofPhysicalDeviceTimelineSemaphoreProperties int = int(unsafe.Sizeof(PhysicalDeviceTimelineSemaphoreProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceTimelineSemaphoreProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceTimelineSemaphoreProperties) AsCPtr() *PhysicalDeviceTimelineSemaphoreProperties {
	clone := (*PhysicalDeviceTimelineSemaphoreProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceTimelineSemaphoreProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceTimelineSemaphorePropertiesFreeCSlice releases the memory allocated by PhysicalDeviceTimelineSemaphorePropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceTimelineSemaphorePropertiesFreeCSlice(x []PhysicalDeviceTimelineSemaphoreProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceTimelineSemaphorePropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceTimelineSemaphorePropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceTimelineSemaphorePropertiesMakeCSlice(x ...PhysicalDeviceTimelineSemaphoreProperties) []PhysicalDeviceTimelineSemaphoreProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceTimelineSemaphoreProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceTimelineSemaphoreProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceTimelineSemaphoreProperties
func (x PhysicalDeviceTimelineSemaphoreProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceTimelineSemaphoreProperties) WithDefaultSType() PhysicalDeviceTimelineSemaphoreProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceTimelineSemaphoreProperties) WithSType(y StructureType) PhysicalDeviceTimelineSemaphoreProperties {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceTimelineSemaphoreProperties
func (x PhysicalDeviceTimelineSemaphoreProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceTimelineSemaphoreProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceTimelineSemaphoreProperties {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// MaxTimelineSemaphoreValueDifference returns the value of maxTimelineSemaphoreValueDifference from VkPhysicalDeviceTimelineSemaphoreProperties
func (x PhysicalDeviceTimelineSemaphoreProperties) MaxTimelineSemaphoreValueDifference() uint64 {
	ptr := func(x *C.ulonglong) *uint64 { /* Scalar */ return (*uint64)(unsafe.Pointer(x)) }(&x.maxTimelineSemaphoreValueDifference)
	return *ptr
}

//PhysicalDeviceTimelineSemaphoreFeatures provides a go interface for VkPhysicalDeviceTimelineSemaphoreFeatures.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceTimelineSemaphoreFeatures.html
type PhysicalDeviceTimelineSemaphoreFeatures C.struct_VkPhysicalDeviceTimelineSemaphoreFeatures

// SizeofPhysicalDeviceTimelineSemaphoreFeatures is the memory size of a PhysicalDeviceTimelineSemaphoreFeatures
var SizeofPhysicalDeviceTimelineSemaphoreFeatures int = int(unsafe.Sizeof(PhysicalDeviceTimelineSemaphoreFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceTimelineSemaphoreFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceTimelineSemaphoreFeatures) AsCPtr() *PhysicalDeviceTimelineSemaphoreFeatures {
	clone := (*PhysicalDeviceTimelineSemaphoreFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceTimelineSemaphoreFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceTimelineSemaphoreFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceTimelineSemaphoreFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceTimelineSemaphoreFeaturesFreeCSlice(x []PhysicalDeviceTimelineSemaphoreFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceTimelineSemaphoreFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceTimelineSemaphoreFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceTimelineSemaphoreFeaturesMakeCSlice(x ...PhysicalDeviceTimelineSemaphoreFeatures) []PhysicalDeviceTimelineSemaphoreFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceTimelineSemaphoreFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceTimelineSemaphoreFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceTimelineSemaphoreFeatures
func (x PhysicalDeviceTimelineSemaphoreFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceTimelineSemaphoreFeatures) WithDefaultSType() PhysicalDeviceTimelineSemaphoreFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceTimelineSemaphoreFeatures) WithSType(y StructureType) PhysicalDeviceTimelineSemaphoreFeatures {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceTimelineSemaphoreFeatures
func (x PhysicalDeviceTimelineSemaphoreFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceTimelineSemaphoreFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceTimelineSemaphoreFeatures {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// TimelineSemaphore returns the value of timelineSemaphore from VkPhysicalDeviceTimelineSemaphoreFeatures
func (x PhysicalDeviceTimelineSemaphoreFeatures) TimelineSemaphore() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.timelineSemaphore)
	return *ptr
}

// WithTimelineSemaphore sets the value for the TimelineSemaphore on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceTimelineSemaphoreFeatures) WithTimelineSemaphore(y Bool32) PhysicalDeviceTimelineSemaphoreFeatures {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.timelineSemaphore = *ptr
	return x
}

//DescriptorSetLayoutBindingFlagsCreateInfo provides a go interface for VkDescriptorSetLayoutBindingFlagsCreateInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorSetLayoutBindingFlagsCreateInfo.html
type DescriptorSetLayoutBindingFlagsCreateInfo C.struct_VkDescriptorSetLayoutBindingFlagsCreateInfo

// SizeofDescriptorSetLayoutBindingFlagsCreateInfo is the memory size of a DescriptorSetLayoutBindingFlagsCreateInfo
var SizeofDescriptorSetLayoutBindingFlagsCreateInfo int = int(unsafe.Sizeof(DescriptorSetLayoutBindingFlagsCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorSetLayoutBindingFlagsCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorSetLayoutBindingFlagsCreateInfo) AsCPtr() *DescriptorSetLayoutBindingFlagsCreateInfo {
	clone := (*DescriptorSetLayoutBindingFlagsCreateInfo)(newCBlock(C.ulong(SizeofDescriptorSetLayoutBindingFlagsCreateInfo)))
	*clone = x
	return clone
}

// DescriptorSetLayoutBindingFlagsCreateInfoFreeCSlice releases the memory allocated by DescriptorSetLayoutBindingFlagsCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorSetLayoutBindingFlagsCreateInfoFreeCSlice(x []DescriptorSetLayoutBindingFlagsCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorSetLayoutBindingFlagsCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorSetLayoutBindingFlagsCreateInfoFreeCSlice must be called on the returned slice.
func DescriptorSetLayoutBindingFlagsCreateInfoMakeCSlice(x ...DescriptorSetLayoutBindingFlagsCreateInfo) []DescriptorSetLayoutBindingFlagsCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetLayoutBindingFlagsCreateInfo * len(x)
	dst := unsafe.Slice((*DescriptorSetLayoutBindingFlagsCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDescriptorSetLayoutBindingFlagsCreateInfo
func (x DescriptorSetLayoutBindingFlagsCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DescriptorSetLayoutBindingFlagsCreateInfo) WithDefaultSType() DescriptorSetLayoutBindingFlagsCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutBindingFlagsCreateInfo) WithSType(y StructureType) DescriptorSetLayoutBindingFlagsCreateInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDescriptorSetLayoutBindingFlagsCreateInfo
func (x DescriptorSetLayoutBindingFlagsCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutBindingFlagsCreateInfo) WithPNext(y unsafe.Pointer) DescriptorSetLayoutBindingFlagsCreateInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// BindingCount returns the value of bindingCount from VkDescriptorSetLayoutBindingFlagsCreateInfo
func (x DescriptorSetLayoutBindingFlagsCreateInfo) BindingCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.bindingCount)
	return *ptr
}

// WithBindingCount sets the value for the BindingCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutBindingFlagsCreateInfo) WithBindingCount(y uint32) DescriptorSetLayoutBindingFlagsCreateInfo {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.bindingCount = *ptr
	return x
}

// PBindingFlags returns the value of pBindingFlags from VkDescriptorSetLayoutBindingFlagsCreateInfo
func (x DescriptorSetLayoutBindingFlagsCreateInfo) PBindingFlags() []DescriptorBindingFlags {
	ptr := func(x **C.VkDescriptorBindingFlags) *[]DescriptorBindingFlags { /* Slice */
		slc := unsafe.Slice((*DescriptorBindingFlags)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pBindingFlags)
	return *ptr
}

// WithPBindingFlags sets the value for the PBindingFlags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines BindingCount as the length of this field.
// BindingCount is updated with the length of the new value.
func (x DescriptorSetLayoutBindingFlagsCreateInfo) WithPBindingFlags(y []DescriptorBindingFlags) DescriptorSetLayoutBindingFlagsCreateInfo {
	ptr := func(x *[]DescriptorBindingFlags) **C.VkDescriptorBindingFlags { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkDescriptorBindingFlags)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkDescriptorBindingFlags)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pBindingFlags = *ptr
	return x.WithBindingCount(uint32(len(y)))
}

//DeviceMemoryOpaqueCaptureAddressInfo provides a go interface for VkDeviceMemoryOpaqueCaptureAddressInfo.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDeviceMemoryOpaqueCaptureAddressInfo.html
type DeviceMemoryOpaqueCaptureAddressInfo C.struct_VkDeviceMemoryOpaqueCaptureAddressInfo

// SizeofDeviceMemoryOpaqueCaptureAddressInfo is the memory size of a DeviceMemoryOpaqueCaptureAddressInfo
var SizeofDeviceMemoryOpaqueCaptureAddressInfo int = int(unsafe.Sizeof(DeviceMemoryOpaqueCaptureAddressInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceMemoryOpaqueCaptureAddressInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceMemoryOpaqueCaptureAddressInfo) AsCPtr() *DeviceMemoryOpaqueCaptureAddressInfo {
	clone := (*DeviceMemoryOpaqueCaptureAddressInfo)(newCBlock(C.ulong(SizeofDeviceMemoryOpaqueCaptureAddressInfo)))
	*clone = x
	return clone
}

// DeviceMemoryOpaqueCaptureAddressInfoFreeCSlice releases the memory allocated by DeviceMemoryOpaqueCaptureAddressInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceMemoryOpaqueCaptureAddressInfoFreeCSlice(x []DeviceMemoryOpaqueCaptureAddressInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceMemoryOpaqueCaptureAddressInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceMemoryOpaqueCaptureAddressInfoFreeCSlice must be called on the returned slice.
func DeviceMemoryOpaqueCaptureAddressInfoMakeCSlice(x ...DeviceMemoryOpaqueCaptureAddressInfo) []DeviceMemoryOpaqueCaptureAddressInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceMemoryOpaqueCaptureAddressInfo * len(x)
	dst := unsafe.Slice((*DeviceMemoryOpaqueCaptureAddressInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceMemoryOpaqueCaptureAddressInfo
func (x DeviceMemoryOpaqueCaptureAddressInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DeviceMemoryOpaqueCaptureAddressInfo) WithDefaultSType() DeviceMemoryOpaqueCaptureAddressInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceMemoryOpaqueCaptureAddressInfo) WithSType(y StructureType) DeviceMemoryOpaqueCaptureAddressInfo {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDeviceMemoryOpaqueCaptureAddressInfo
func (x DeviceMemoryOpaqueCaptureAddressInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceMemoryOpaqueCaptureAddressInfo) WithPNext(y unsafe.Pointer) DeviceMemoryOpaqueCaptureAddressInfo {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Memory returns the value of memory from VkDeviceMemoryOpaqueCaptureAddressInfo
func (x DeviceMemoryOpaqueCaptureAddressInfo) Memory() DeviceMemory {
	ptr := /* handle */ (*DeviceMemory)(&x.memory)
	return *ptr
}

// WithMemory sets the value for the Memory on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceMemoryOpaqueCaptureAddressInfo) WithMemory(y DeviceMemory) DeviceMemoryOpaqueCaptureAddressInfo {
	ptr := /* handle */ (*C.VkDeviceMemory)(&y)
	x.memory = *ptr
	return x
}

func (x DeviceFacade) WaitSemaphores(pWaitInfo *SemaphoreWaitInfo, timeout uint64) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **SemaphoreWaitInfo) **C.struct_VkSemaphoreWaitInfo { /* Pointer */
		return (**C.struct_VkSemaphoreWaitInfo)(unsafe.Pointer(x))
	}(&pWaitInfo)
	p2 := func(x *uint64) *C.ulonglong { /* Scalar */ return (*C.ulonglong)(unsafe.Pointer(x)) }(&timeout)
	ret := C.vkWaitSemaphores(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) ResetQueryPool(queryPool QueryPool, firstQuery uint32, queryCount uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkQueryPool)(&queryPool)
	p2 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&firstQuery)
	p3 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&queryCount)
	C.vkResetQueryPool(addrs, *p0, *p1, *p2, *p3)
}

func (x DeviceFacade) GetSemaphoreCounterValue(semaphore Semaphore, pValue *uint64) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkSemaphore)(&semaphore)
	p2 := func(x **uint64) **C.ulonglong { /* Pointer */ return (**C.ulonglong)(unsafe.Pointer(x)) }(&pValue)
	ret := C.vkGetSemaphoreCounterValue(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x CommandBufferFacade) CmdBeginRenderPass2(pRenderPassBegin *RenderPassBeginInfo, pSubpassBeginInfo *SubpassBeginInfo) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **RenderPassBeginInfo) **C.struct_VkRenderPassBeginInfo { /* Pointer */
		return (**C.struct_VkRenderPassBeginInfo)(unsafe.Pointer(x))
	}(&pRenderPassBegin)
	p2 := func(x **SubpassBeginInfo) **C.struct_VkSubpassBeginInfo { /* Pointer */
		return (**C.struct_VkSubpassBeginInfo)(unsafe.Pointer(x))
	}(&pSubpassBeginInfo)
	C.vkCmdBeginRenderPass2(addrs, *p0, *p1, *p2)
}

func (x CommandBufferFacade) CmdEndRenderPass2(pSubpassEndInfo *SubpassEndInfo) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **SubpassEndInfo) **C.struct_VkSubpassEndInfo { /* Pointer */
		return (**C.struct_VkSubpassEndInfo)(unsafe.Pointer(x))
	}(&pSubpassEndInfo)
	C.vkCmdEndRenderPass2(addrs, *p0, *p1)
}

func (x DeviceFacade) GetBufferDeviceAddress(pInfo *BufferDeviceAddressInfo) DeviceAddress {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **BufferDeviceAddressInfo) **C.struct_VkBufferDeviceAddressInfo { /* Pointer */
		return (**C.struct_VkBufferDeviceAddressInfo)(unsafe.Pointer(x))
	}(&pInfo)
	ret := C.vkGetBufferDeviceAddress(addrs, *p0, *p1)
	retPtr := /* typedef */ (*DeviceAddress)(&ret)
	return *retPtr
}

func (x DeviceFacade) GetBufferOpaqueCaptureAddress(pInfo *BufferDeviceAddressInfo) uint64 {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **BufferDeviceAddressInfo) **C.struct_VkBufferDeviceAddressInfo { /* Pointer */
		return (**C.struct_VkBufferDeviceAddressInfo)(unsafe.Pointer(x))
	}(&pInfo)
	ret := C.vkGetBufferOpaqueCaptureAddress(addrs, *p0, *p1)
	retPtr := func(x *C.ulonglong) *uint64 { /* Scalar */ return (*uint64)(unsafe.Pointer(x)) }(&ret)
	return *retPtr
}

func (x DeviceFacade) GetDeviceMemoryOpaqueCaptureAddress(pInfo *DeviceMemoryOpaqueCaptureAddressInfo) uint64 {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DeviceMemoryOpaqueCaptureAddressInfo) **C.struct_VkDeviceMemoryOpaqueCaptureAddressInfo { /* Pointer */
		return (**C.struct_VkDeviceMemoryOpaqueCaptureAddressInfo)(unsafe.Pointer(x))
	}(&pInfo)
	ret := C.vkGetDeviceMemoryOpaqueCaptureAddress(addrs, *p0, *p1)
	retPtr := func(x *C.ulonglong) *uint64 { /* Scalar */ return (*uint64)(unsafe.Pointer(x)) }(&ret)
	return *retPtr
}

func (x CommandBufferFacade) CmdNextSubpass2(pSubpassBeginInfo *SubpassBeginInfo, pSubpassEndInfo *SubpassEndInfo) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **SubpassBeginInfo) **C.struct_VkSubpassBeginInfo { /* Pointer */
		return (**C.struct_VkSubpassBeginInfo)(unsafe.Pointer(x))
	}(&pSubpassBeginInfo)
	p2 := func(x **SubpassEndInfo) **C.struct_VkSubpassEndInfo { /* Pointer */
		return (**C.struct_VkSubpassEndInfo)(unsafe.Pointer(x))
	}(&pSubpassEndInfo)
	C.vkCmdNextSubpass2(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) CreateRenderPass2(pCreateInfo *RenderPassCreateInfo2, pAllocator *AllocationCallbacks, pRenderPass *RenderPass) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **RenderPassCreateInfo2) **C.struct_VkRenderPassCreateInfo2 { /* Pointer */
		return (**C.struct_VkRenderPassCreateInfo2)(unsafe.Pointer(x))
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p3 := func(x **RenderPass) **C.VkRenderPass { /* Pointer */ return (**C.VkRenderPass)(unsafe.Pointer(x)) }(&pRenderPass)
	ret := C.vkCreateRenderPass2(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x CommandBufferFacade) CmdDrawIndexedIndirectCount(buffer Buffer, offset DeviceSize, countBuffer Buffer, countBufferOffset DeviceSize, maxDrawCount uint32, stride uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&buffer)
	p2 := /* typedef */ (*C.VkDeviceSize)(&offset)
	p3 := /* handle */ (*C.VkBuffer)(&countBuffer)
	p4 := /* typedef */ (*C.VkDeviceSize)(&countBufferOffset)
	p5 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&maxDrawCount)
	p6 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&stride)
	C.vkCmdDrawIndexedIndirectCount(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6)
}

func (x CommandBufferFacade) CmdDrawIndirectCount(buffer Buffer, offset DeviceSize, countBuffer Buffer, countBufferOffset DeviceSize, maxDrawCount uint32, stride uint32) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&buffer)
	p2 := /* typedef */ (*C.VkDeviceSize)(&offset)
	p3 := /* handle */ (*C.VkBuffer)(&countBuffer)
	p4 := /* typedef */ (*C.VkDeviceSize)(&countBufferOffset)
	p5 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&maxDrawCount)
	p6 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&stride)
	C.vkCmdDrawIndirectCount(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6)
}

func (x DeviceFacade) SignalSemaphore(pSignalInfo *SemaphoreSignalInfo) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **SemaphoreSignalInfo) **C.struct_VkSemaphoreSignalInfo { /* Pointer */
		return (**C.struct_VkSemaphoreSignalInfo)(unsafe.Pointer(x))
	}(&pSignalInfo)
	ret := C.vkSignalSemaphore(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// SurfaceKHR is a Handle to a vulkan resource.
// SurfaceKHR is a child of Instance.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSurfaceKHR.html
type SurfaceKHR C.VkSurfaceKHR

// NullSurfaceKHR is a typed Null value for the SurfaceKHR type.
var NullSurfaceKHR SurfaceKHR

// MakeSurfaceKHRFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent InstanceFacade) MakeSurfaceKHRFacade(x SurfaceKHR) SurfaceKHRFacade {
	return SurfaceKHRFacade{
		H:     x,
		procs: parent.procs,
	}
}

// SurfaceKHRFacade is a SurfaceKHR handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type SurfaceKHRFacade struct {
	H     SurfaceKHR     // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// PresentModeKHR is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPresentModeKHR.html
type PresentModeKHR uint32

const (
	VK_PRESENT_MODE_IMMEDIATE_KHR    PresentModeKHR = 0
	VK_PRESENT_MODE_MAILBOX_KHR      PresentModeKHR = 1
	VK_PRESENT_MODE_FIFO_KHR         PresentModeKHR = 2
	VK_PRESENT_MODE_FIFO_RELAXED_KHR PresentModeKHR = 3
)

var (
	reversePresentModeKHR map[PresentModeKHR]string = map[PresentModeKHR]string{
		VK_PRESENT_MODE_IMMEDIATE_KHR:    "VK_PRESENT_MODE_IMMEDIATE_KHR",
		VK_PRESENT_MODE_MAILBOX_KHR:      "VK_PRESENT_MODE_MAILBOX_KHR",
		VK_PRESENT_MODE_FIFO_KHR:         "VK_PRESENT_MODE_FIFO_KHR",
		VK_PRESENT_MODE_FIFO_RELAXED_KHR: "VK_PRESENT_MODE_FIFO_RELAXED_KHR",
	}
)

func (x PresentModeKHR) String() string {
	if s, ok := reversePresentModeKHR[x]; ok {
		return s
	}
	return fmt.Sprintf("PresentModeKHR=%d", x)
}

// CompositeAlphaFlagBitsKHR is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCompositeAlphaFlagBitsKHR.html
type CompositeAlphaFlagBitsKHR uint32

const (
	VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR          CompositeAlphaFlagBitsKHR = (1 << 0)
	VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR  CompositeAlphaFlagBitsKHR = (1 << 1)
	VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR CompositeAlphaFlagBitsKHR = (1 << 2)
	VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR         CompositeAlphaFlagBitsKHR = (1 << 3)
)

var (
	reverseCompositeAlphaFlagBitsKHR map[CompositeAlphaFlagBitsKHR]string = map[CompositeAlphaFlagBitsKHR]string{
		VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR:          "VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR",
		VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR:  "VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR",
		VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR: "VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR",
		VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR:         "VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR",
	}
)

func (x CompositeAlphaFlagBitsKHR) String() string {
	if s, ok := reverseCompositeAlphaFlagBitsKHR[x]; ok {
		return s
	}
	return fmt.Sprintf("CompositeAlphaFlagBitsKHR=%d", x)
}

// ColorSpaceKHR is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkColorSpaceKHR.html
type ColorSpaceKHR uint32

const (
	VK_COLOR_SPACE_SRGB_NONLINEAR_KHR ColorSpaceKHR = 0
	VK_COLORSPACE_SRGB_NONLINEAR_KHR  ColorSpaceKHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR
)

var (
	reverseColorSpaceKHR map[ColorSpaceKHR]string = map[ColorSpaceKHR]string{
		VK_COLOR_SPACE_SRGB_NONLINEAR_KHR: "VK_COLOR_SPACE_SRGB_NONLINEAR_KHR",
	}
)

func (x ColorSpaceKHR) String() string {
	if s, ok := reverseColorSpaceKHR[x]; ok {
		return s
	}
	return fmt.Sprintf("ColorSpaceKHR=%d", x)
}

// SurfaceTransformFlagBitsKHR is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSurfaceTransformFlagBitsKHR.html
type SurfaceTransformFlagBitsKHR uint32

const (
	VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR                     SurfaceTransformFlagBitsKHR = (1 << 0)
	VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR                    SurfaceTransformFlagBitsKHR = (1 << 1)
	VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR                   SurfaceTransformFlagBitsKHR = (1 << 2)
	VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR                   SurfaceTransformFlagBitsKHR = (1 << 3)
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR            SurfaceTransformFlagBitsKHR = (1 << 4)
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR  SurfaceTransformFlagBitsKHR = (1 << 5)
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR SurfaceTransformFlagBitsKHR = (1 << 6)
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR SurfaceTransformFlagBitsKHR = (1 << 7)
	VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR                      SurfaceTransformFlagBitsKHR = (1 << 8)
)

var (
	reverseSurfaceTransformFlagBitsKHR map[SurfaceTransformFlagBitsKHR]string = map[SurfaceTransformFlagBitsKHR]string{
		VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR:                     "VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR",
		VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR:                    "VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR",
		VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR:                   "VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR",
		VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR:                   "VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR",
		VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR:            "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR",
		VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR:  "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR",
		VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR: "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR",
		VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR: "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR",
		VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR:                      "VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR",
	}
)

func (x SurfaceTransformFlagBitsKHR) String() string {
	if s, ok := reverseSurfaceTransformFlagBitsKHR[x]; ok {
		return s
	}
	return fmt.Sprintf("SurfaceTransformFlagBitsKHR=%d", x)
}

// CompositeAlphaFlagsKHR is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCompositeAlphaFlagsKHR.html
type CompositeAlphaFlagsKHR Flags

// SurfaceTransformFlagsKHR is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSurfaceTransformFlagsKHR.html
type SurfaceTransformFlagsKHR Flags

//SurfaceCapabilitiesKHR provides a go interface for VkSurfaceCapabilitiesKHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSurfaceCapabilitiesKHR.html
type SurfaceCapabilitiesKHR C.struct_VkSurfaceCapabilitiesKHR

// SizeofSurfaceCapabilitiesKHR is the memory size of a SurfaceCapabilitiesKHR
var SizeofSurfaceCapabilitiesKHR int = int(unsafe.Sizeof(SurfaceCapabilitiesKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SurfaceCapabilitiesKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SurfaceCapabilitiesKHR) AsCPtr() *SurfaceCapabilitiesKHR {
	clone := (*SurfaceCapabilitiesKHR)(newCBlock(C.ulong(SizeofSurfaceCapabilitiesKHR)))
	*clone = x
	return clone
}

// SurfaceCapabilitiesKHRFreeCSlice releases the memory allocated by SurfaceCapabilitiesKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func SurfaceCapabilitiesKHRFreeCSlice(x []SurfaceCapabilitiesKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SurfaceCapabilitiesKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SurfaceCapabilitiesKHRFreeCSlice must be called on the returned slice.
func SurfaceCapabilitiesKHRMakeCSlice(x ...SurfaceCapabilitiesKHR) []SurfaceCapabilitiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSurfaceCapabilitiesKHR * len(x)
	dst := unsafe.Slice((*SurfaceCapabilitiesKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// MinImageCount returns the value of minImageCount from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) MinImageCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.minImageCount)
	return *ptr
}

// MaxImageCount returns the value of maxImageCount from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) MaxImageCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxImageCount)
	return *ptr
}

// CurrentExtent returns the value of currentExtent from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) CurrentExtent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.currentExtent)
	return *ptr
}

// MinImageExtent returns the value of minImageExtent from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) MinImageExtent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.minImageExtent)
	return *ptr
}

// MaxImageExtent returns the value of maxImageExtent from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) MaxImageExtent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.maxImageExtent)
	return *ptr
}

// MaxImageArrayLayers returns the value of maxImageArrayLayers from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) MaxImageArrayLayers() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.maxImageArrayLayers)
	return *ptr
}

// SupportedTransforms returns the value of supportedTransforms from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) SupportedTransforms() SurfaceTransformFlagsKHR {
	ptr := /* typedef */ (*SurfaceTransformFlagsKHR)(&x.supportedTransforms)
	return *ptr
}

// CurrentTransform returns the value of currentTransform from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) CurrentTransform() SurfaceTransformFlagBitsKHR {
	ptr := /* typedef */ (*SurfaceTransformFlagBitsKHR)(&x.currentTransform)
	return *ptr
}

// SupportedCompositeAlpha returns the value of supportedCompositeAlpha from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) SupportedCompositeAlpha() CompositeAlphaFlagsKHR {
	ptr := /* typedef */ (*CompositeAlphaFlagsKHR)(&x.supportedCompositeAlpha)
	return *ptr
}

// SupportedUsageFlags returns the value of supportedUsageFlags from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) SupportedUsageFlags() ImageUsageFlags {
	ptr := /* typedef */ (*ImageUsageFlags)(&x.supportedUsageFlags)
	return *ptr
}

//SurfaceFormatKHR provides a go interface for VkSurfaceFormatKHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSurfaceFormatKHR.html
type SurfaceFormatKHR C.struct_VkSurfaceFormatKHR

// SizeofSurfaceFormatKHR is the memory size of a SurfaceFormatKHR
var SizeofSurfaceFormatKHR int = int(unsafe.Sizeof(SurfaceFormatKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SurfaceFormatKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SurfaceFormatKHR) AsCPtr() *SurfaceFormatKHR {
	clone := (*SurfaceFormatKHR)(newCBlock(C.ulong(SizeofSurfaceFormatKHR)))
	*clone = x
	return clone
}

// SurfaceFormatKHRFreeCSlice releases the memory allocated by SurfaceFormatKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func SurfaceFormatKHRFreeCSlice(x []SurfaceFormatKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SurfaceFormatKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SurfaceFormatKHRFreeCSlice must be called on the returned slice.
func SurfaceFormatKHRMakeCSlice(x ...SurfaceFormatKHR) []SurfaceFormatKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSurfaceFormatKHR * len(x)
	dst := unsafe.Slice((*SurfaceFormatKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Format returns the value of format from VkSurfaceFormatKHR
func (x SurfaceFormatKHR) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format)
	return *ptr
}

// ColorSpace returns the value of colorSpace from VkSurfaceFormatKHR
func (x SurfaceFormatKHR) ColorSpace() ColorSpaceKHR {
	ptr := /* typedef */ (*ColorSpaceKHR)(&x.colorSpace)
	return *ptr
}

func (x PhysicalDeviceFacade) GetPhysicalDeviceSurfacePresentModesKHR(surface SurfaceKHR, pPresentModeCount *uint32, pPresentModes []PresentModeKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* handle */ (*C.VkSurfaceKHR)(&surface)
	p2 := func(x **uint32) **C.uint { /* Pointer */ return (**C.uint)(unsafe.Pointer(x)) }(&pPresentModeCount)
	p3 := func(x *[]PresentModeKHR) **C.VkPresentModeKHR { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkPresentModeKHR)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkPresentModeKHR)(unsafe.Pointer((&ptr)))
	}(&pPresentModes)
	ret := C.vkGetPhysicalDeviceSurfacePresentModesKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x PhysicalDeviceFacade) GetPhysicalDeviceSurfaceFormatsKHR(surface SurfaceKHR, pSurfaceFormatCount *uint32, pSurfaceFormats []SurfaceFormatKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* handle */ (*C.VkSurfaceKHR)(&surface)
	p2 := func(x **uint32) **C.uint { /* Pointer */ return (**C.uint)(unsafe.Pointer(x)) }(&pSurfaceFormatCount)
	p3 := func(x *[]SurfaceFormatKHR) **C.struct_VkSurfaceFormatKHR { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSurfaceFormatKHR)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSurfaceFormatKHR)(unsafe.Pointer((&ptr)))
	}(&pSurfaceFormats)
	ret := C.vkGetPhysicalDeviceSurfaceFormatsKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x PhysicalDeviceFacade) GetPhysicalDeviceSurfaceCapabilitiesKHR(surface SurfaceKHR, pSurfaceCapabilities *SurfaceCapabilitiesKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* handle */ (*C.VkSurfaceKHR)(&surface)
	p2 := func(x **SurfaceCapabilitiesKHR) **C.struct_VkSurfaceCapabilitiesKHR { /* Pointer */
		return (**C.struct_VkSurfaceCapabilitiesKHR)(unsafe.Pointer(x))
	}(&pSurfaceCapabilities)
	ret := C.vkGetPhysicalDeviceSurfaceCapabilitiesKHR(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x PhysicalDeviceFacade) GetPhysicalDeviceSurfaceSupportKHR(queueFamilyIndex uint32, surface SurfaceKHR, pSupported *Bool32) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&queueFamilyIndex)
	p2 := /* handle */ (*C.VkSurfaceKHR)(&surface)
	p3 := func(x **Bool32) **C.VkBool32 { /* Pointer */ return (**C.VkBool32)(unsafe.Pointer(x)) }(&pSupported)
	ret := C.vkGetPhysicalDeviceSurfaceSupportKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x InstanceFacade) DestroySurfaceKHR(surface SurfaceKHR, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkInstance)(&x.H)
	p1 := /* handle */ (*C.VkSurfaceKHR)(&surface)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	C.vkDestroySurfaceKHR(addrs, *p0, *p1, *p2)
}

//PhysicalDeviceSurfaceInfo2KHR provides a go interface for VkPhysicalDeviceSurfaceInfo2KHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceSurfaceInfo2KHR.html
type PhysicalDeviceSurfaceInfo2KHR C.struct_VkPhysicalDeviceSurfaceInfo2KHR

// SizeofPhysicalDeviceSurfaceInfo2KHR is the memory size of a PhysicalDeviceSurfaceInfo2KHR
var SizeofPhysicalDeviceSurfaceInfo2KHR int = int(unsafe.Sizeof(PhysicalDeviceSurfaceInfo2KHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceSurfaceInfo2KHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceSurfaceInfo2KHR) AsCPtr() *PhysicalDeviceSurfaceInfo2KHR {
	clone := (*PhysicalDeviceSurfaceInfo2KHR)(newCBlock(C.ulong(SizeofPhysicalDeviceSurfaceInfo2KHR)))
	*clone = x
	return clone
}

// PhysicalDeviceSurfaceInfo2KHRFreeCSlice releases the memory allocated by PhysicalDeviceSurfaceInfo2KHRMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceSurfaceInfo2KHRFreeCSlice(x []PhysicalDeviceSurfaceInfo2KHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceSurfaceInfo2KHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceSurfaceInfo2KHRFreeCSlice must be called on the returned slice.
func PhysicalDeviceSurfaceInfo2KHRMakeCSlice(x ...PhysicalDeviceSurfaceInfo2KHR) []PhysicalDeviceSurfaceInfo2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSurfaceInfo2KHR * len(x)
	dst := unsafe.Slice((*PhysicalDeviceSurfaceInfo2KHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceSurfaceInfo2KHR
func (x PhysicalDeviceSurfaceInfo2KHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceSurfaceInfo2KHR) WithDefaultSType() PhysicalDeviceSurfaceInfo2KHR {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSurfaceInfo2KHR) WithSType(y StructureType) PhysicalDeviceSurfaceInfo2KHR {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceSurfaceInfo2KHR
func (x PhysicalDeviceSurfaceInfo2KHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSurfaceInfo2KHR) WithPNext(y unsafe.Pointer) PhysicalDeviceSurfaceInfo2KHR {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Surface returns the value of surface from VkPhysicalDeviceSurfaceInfo2KHR
func (x PhysicalDeviceSurfaceInfo2KHR) Surface() SurfaceKHR {
	ptr := /* handle */ (*SurfaceKHR)(&x.surface)
	return *ptr
}

// WithSurface sets the value for the Surface on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSurfaceInfo2KHR) WithSurface(y SurfaceKHR) PhysicalDeviceSurfaceInfo2KHR {
	ptr := /* handle */ (*C.VkSurfaceKHR)(&y)
	x.surface = *ptr
	return x
}

//SurfaceCapabilities2KHR provides a go interface for VkSurfaceCapabilities2KHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSurfaceCapabilities2KHR.html
type SurfaceCapabilities2KHR C.struct_VkSurfaceCapabilities2KHR

// SizeofSurfaceCapabilities2KHR is the memory size of a SurfaceCapabilities2KHR
var SizeofSurfaceCapabilities2KHR int = int(unsafe.Sizeof(SurfaceCapabilities2KHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SurfaceCapabilities2KHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SurfaceCapabilities2KHR) AsCPtr() *SurfaceCapabilities2KHR {
	clone := (*SurfaceCapabilities2KHR)(newCBlock(C.ulong(SizeofSurfaceCapabilities2KHR)))
	*clone = x
	return clone
}

// SurfaceCapabilities2KHRFreeCSlice releases the memory allocated by SurfaceCapabilities2KHRMakeCSlice.
// It does not free pointers stored inside the slice.
func SurfaceCapabilities2KHRFreeCSlice(x []SurfaceCapabilities2KHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SurfaceCapabilities2KHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SurfaceCapabilities2KHRFreeCSlice must be called on the returned slice.
func SurfaceCapabilities2KHRMakeCSlice(x ...SurfaceCapabilities2KHR) []SurfaceCapabilities2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSurfaceCapabilities2KHR * len(x)
	dst := unsafe.Slice((*SurfaceCapabilities2KHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSurfaceCapabilities2KHR
func (x SurfaceCapabilities2KHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SurfaceCapabilities2KHR) WithDefaultSType() SurfaceCapabilities2KHR {
	return x.WithSType(VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SurfaceCapabilities2KHR) WithSType(y StructureType) SurfaceCapabilities2KHR {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkSurfaceCapabilities2KHR
func (x SurfaceCapabilities2KHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SurfaceCapabilities2KHR) WithPNext(y unsafe.Pointer) SurfaceCapabilities2KHR {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// SurfaceCapabilities returns the value of surfaceCapabilities from VkSurfaceCapabilities2KHR
func (x SurfaceCapabilities2KHR) SurfaceCapabilities() SurfaceCapabilitiesKHR {
	ptr := /* typedef */ (*SurfaceCapabilitiesKHR)(&x.surfaceCapabilities)
	return *ptr
}

//SurfaceFormat2KHR provides a go interface for VkSurfaceFormat2KHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSurfaceFormat2KHR.html
type SurfaceFormat2KHR C.struct_VkSurfaceFormat2KHR

// SizeofSurfaceFormat2KHR is the memory size of a SurfaceFormat2KHR
var SizeofSurfaceFormat2KHR int = int(unsafe.Sizeof(SurfaceFormat2KHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SurfaceFormat2KHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SurfaceFormat2KHR) AsCPtr() *SurfaceFormat2KHR {
	clone := (*SurfaceFormat2KHR)(newCBlock(C.ulong(SizeofSurfaceFormat2KHR)))
	*clone = x
	return clone
}

// SurfaceFormat2KHRFreeCSlice releases the memory allocated by SurfaceFormat2KHRMakeCSlice.
// It does not free pointers stored inside the slice.
func SurfaceFormat2KHRFreeCSlice(x []SurfaceFormat2KHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SurfaceFormat2KHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SurfaceFormat2KHRFreeCSlice must be called on the returned slice.
func SurfaceFormat2KHRMakeCSlice(x ...SurfaceFormat2KHR) []SurfaceFormat2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSurfaceFormat2KHR * len(x)
	dst := unsafe.Slice((*SurfaceFormat2KHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSurfaceFormat2KHR
func (x SurfaceFormat2KHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SurfaceFormat2KHR) WithDefaultSType() SurfaceFormat2KHR {
	return x.WithSType(VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SurfaceFormat2KHR) WithSType(y StructureType) SurfaceFormat2KHR {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkSurfaceFormat2KHR
func (x SurfaceFormat2KHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SurfaceFormat2KHR) WithPNext(y unsafe.Pointer) SurfaceFormat2KHR {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// SurfaceFormat returns the value of surfaceFormat from VkSurfaceFormat2KHR
func (x SurfaceFormat2KHR) SurfaceFormat() SurfaceFormatKHR {
	ptr := /* typedef */ (*SurfaceFormatKHR)(&x.surfaceFormat)
	return *ptr
}

func (x PhysicalDeviceFacade) GetPhysicalDeviceSurfaceCapabilities2KHR(pSurfaceInfo *PhysicalDeviceSurfaceInfo2KHR, pSurfaceCapabilities *SurfaceCapabilities2KHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceSurfaceInfo2KHR) **C.struct_VkPhysicalDeviceSurfaceInfo2KHR { /* Pointer */
		return (**C.struct_VkPhysicalDeviceSurfaceInfo2KHR)(unsafe.Pointer(x))
	}(&pSurfaceInfo)
	p2 := func(x **SurfaceCapabilities2KHR) **C.struct_VkSurfaceCapabilities2KHR { /* Pointer */
		return (**C.struct_VkSurfaceCapabilities2KHR)(unsafe.Pointer(x))
	}(&pSurfaceCapabilities)
	ret := C.vkGetPhysicalDeviceSurfaceCapabilities2KHR(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x PhysicalDeviceFacade) GetPhysicalDeviceSurfaceFormats2KHR(pSurfaceInfo *PhysicalDeviceSurfaceInfo2KHR, pSurfaceFormatCount *uint32, pSurfaceFormats []SurfaceFormat2KHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceSurfaceInfo2KHR) **C.struct_VkPhysicalDeviceSurfaceInfo2KHR { /* Pointer */
		return (**C.struct_VkPhysicalDeviceSurfaceInfo2KHR)(unsafe.Pointer(x))
	}(&pSurfaceInfo)
	p2 := func(x **uint32) **C.uint { /* Pointer */ return (**C.uint)(unsafe.Pointer(x)) }(&pSurfaceFormatCount)
	p3 := func(x *[]SurfaceFormat2KHR) **C.struct_VkSurfaceFormat2KHR { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSurfaceFormat2KHR)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSurfaceFormat2KHR)(unsafe.Pointer((&ptr)))
	}(&pSurfaceFormats)
	ret := C.vkGetPhysicalDeviceSurfaceFormats2KHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

//SurfaceProtectedCapabilitiesKHR provides a go interface for VkSurfaceProtectedCapabilitiesKHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSurfaceProtectedCapabilitiesKHR.html
type SurfaceProtectedCapabilitiesKHR C.struct_VkSurfaceProtectedCapabilitiesKHR

// SizeofSurfaceProtectedCapabilitiesKHR is the memory size of a SurfaceProtectedCapabilitiesKHR
var SizeofSurfaceProtectedCapabilitiesKHR int = int(unsafe.Sizeof(SurfaceProtectedCapabilitiesKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SurfaceProtectedCapabilitiesKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SurfaceProtectedCapabilitiesKHR) AsCPtr() *SurfaceProtectedCapabilitiesKHR {
	clone := (*SurfaceProtectedCapabilitiesKHR)(newCBlock(C.ulong(SizeofSurfaceProtectedCapabilitiesKHR)))
	*clone = x
	return clone
}

// SurfaceProtectedCapabilitiesKHRFreeCSlice releases the memory allocated by SurfaceProtectedCapabilitiesKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func SurfaceProtectedCapabilitiesKHRFreeCSlice(x []SurfaceProtectedCapabilitiesKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SurfaceProtectedCapabilitiesKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SurfaceProtectedCapabilitiesKHRFreeCSlice must be called on the returned slice.
func SurfaceProtectedCapabilitiesKHRMakeCSlice(x ...SurfaceProtectedCapabilitiesKHR) []SurfaceProtectedCapabilitiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSurfaceProtectedCapabilitiesKHR * len(x)
	dst := unsafe.Slice((*SurfaceProtectedCapabilitiesKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSurfaceProtectedCapabilitiesKHR
func (x SurfaceProtectedCapabilitiesKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SurfaceProtectedCapabilitiesKHR) WithDefaultSType() SurfaceProtectedCapabilitiesKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SurfaceProtectedCapabilitiesKHR) WithSType(y StructureType) SurfaceProtectedCapabilitiesKHR {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkSurfaceProtectedCapabilitiesKHR
func (x SurfaceProtectedCapabilitiesKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SurfaceProtectedCapabilitiesKHR) WithPNext(y unsafe.Pointer) SurfaceProtectedCapabilitiesKHR {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// SupportsProtected returns the value of supportsProtected from VkSurfaceProtectedCapabilitiesKHR
func (x SurfaceProtectedCapabilitiesKHR) SupportsProtected() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.supportsProtected)
	return *ptr
}

// WithSupportsProtected sets the value for the SupportsProtected on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SurfaceProtectedCapabilitiesKHR) WithSupportsProtected(y Bool32) SurfaceProtectedCapabilitiesKHR {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.supportsProtected = *ptr
	return x
}

// SwapchainKHR is a Handle to a vulkan resource.
// SwapchainKHR is a child of SurfaceKHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSwapchainKHR.html
type SwapchainKHR C.VkSwapchainKHR

// NullSwapchainKHR is a typed Null value for the SwapchainKHR type.
var NullSwapchainKHR SwapchainKHR

// MakeSwapchainKHRFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent SurfaceKHRFacade) MakeSwapchainKHRFacade(x SwapchainKHR) SwapchainKHRFacade {
	return SwapchainKHRFacade{
		H:     x,
		procs: parent.procs,
	}
}

// SwapchainKHRFacade is a SwapchainKHR handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type SwapchainKHRFacade struct {
	H     SwapchainKHR   // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// SwapchainCreateFlagBitsKHR is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSwapchainCreateFlagBitsKHR.html
type SwapchainCreateFlagBitsKHR uint32

const (
	VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR SwapchainCreateFlagBitsKHR = (1 << 0)
	VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR                   SwapchainCreateFlagBitsKHR = (1 << 1)
)

var (
	reverseSwapchainCreateFlagBitsKHR map[SwapchainCreateFlagBitsKHR]string = map[SwapchainCreateFlagBitsKHR]string{
		VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR: "VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR",
		VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR:                   "VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR",
	}
)

func (x SwapchainCreateFlagBitsKHR) String() string {
	if s, ok := reverseSwapchainCreateFlagBitsKHR[x]; ok {
		return s
	}
	return fmt.Sprintf("SwapchainCreateFlagBitsKHR=%d", x)
}

// DeviceGroupPresentModeFlagBitsKHR is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDeviceGroupPresentModeFlagBitsKHR.html
type DeviceGroupPresentModeFlagBitsKHR uint32

const (
	VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR              DeviceGroupPresentModeFlagBitsKHR = (1 << 0)
	VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR             DeviceGroupPresentModeFlagBitsKHR = (1 << 1)
	VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR                DeviceGroupPresentModeFlagBitsKHR = (1 << 2)
	VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR DeviceGroupPresentModeFlagBitsKHR = (1 << 3)
)

var (
	reverseDeviceGroupPresentModeFlagBitsKHR map[DeviceGroupPresentModeFlagBitsKHR]string = map[DeviceGroupPresentModeFlagBitsKHR]string{
		VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR:              "VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR",
		VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR:             "VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR",
		VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR:                "VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR",
		VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR: "VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR",
	}
)

func (x DeviceGroupPresentModeFlagBitsKHR) String() string {
	if s, ok := reverseDeviceGroupPresentModeFlagBitsKHR[x]; ok {
		return s
	}
	return fmt.Sprintf("DeviceGroupPresentModeFlagBitsKHR=%d", x)
}

// DeviceGroupPresentModeFlagsKHR is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDeviceGroupPresentModeFlagsKHR.html
type DeviceGroupPresentModeFlagsKHR Flags

// SwapchainCreateFlagsKHR is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSwapchainCreateFlagsKHR.html
type SwapchainCreateFlagsKHR Flags

//BindImageMemorySwapchainInfoKHR provides a go interface for VkBindImageMemorySwapchainInfoKHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBindImageMemorySwapchainInfoKHR.html
type BindImageMemorySwapchainInfoKHR C.struct_VkBindImageMemorySwapchainInfoKHR

// SizeofBindImageMemorySwapchainInfoKHR is the memory size of a BindImageMemorySwapchainInfoKHR
var SizeofBindImageMemorySwapchainInfoKHR int = int(unsafe.Sizeof(BindImageMemorySwapchainInfoKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BindImageMemorySwapchainInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BindImageMemorySwapchainInfoKHR) AsCPtr() *BindImageMemorySwapchainInfoKHR {
	clone := (*BindImageMemorySwapchainInfoKHR)(newCBlock(C.ulong(SizeofBindImageMemorySwapchainInfoKHR)))
	*clone = x
	return clone
}

// BindImageMemorySwapchainInfoKHRFreeCSlice releases the memory allocated by BindImageMemorySwapchainInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func BindImageMemorySwapchainInfoKHRFreeCSlice(x []BindImageMemorySwapchainInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BindImageMemorySwapchainInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BindImageMemorySwapchainInfoKHRFreeCSlice must be called on the returned slice.
func BindImageMemorySwapchainInfoKHRMakeCSlice(x ...BindImageMemorySwapchainInfoKHR) []BindImageMemorySwapchainInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindImageMemorySwapchainInfoKHR * len(x)
	dst := unsafe.Slice((*BindImageMemorySwapchainInfoKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBindImageMemorySwapchainInfoKHR
func (x BindImageMemorySwapchainInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BindImageMemorySwapchainInfoKHR) WithDefaultSType() BindImageMemorySwapchainInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemorySwapchainInfoKHR) WithSType(y StructureType) BindImageMemorySwapchainInfoKHR {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkBindImageMemorySwapchainInfoKHR
func (x BindImageMemorySwapchainInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemorySwapchainInfoKHR) WithPNext(y unsafe.Pointer) BindImageMemorySwapchainInfoKHR {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Swapchain returns the value of swapchain from VkBindImageMemorySwapchainInfoKHR
func (x BindImageMemorySwapchainInfoKHR) Swapchain() SwapchainKHR {
	ptr := /* handle */ (*SwapchainKHR)(&x.swapchain)
	return *ptr
}

// WithSwapchain sets the value for the Swapchain on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemorySwapchainInfoKHR) WithSwapchain(y SwapchainKHR) BindImageMemorySwapchainInfoKHR {
	ptr := /* handle */ (*C.VkSwapchainKHR)(&y)
	x.swapchain = *ptr
	return x
}

// ImageIndex returns the value of imageIndex from VkBindImageMemorySwapchainInfoKHR
func (x BindImageMemorySwapchainInfoKHR) ImageIndex() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.imageIndex)
	return *ptr
}

// WithImageIndex sets the value for the ImageIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemorySwapchainInfoKHR) WithImageIndex(y uint32) BindImageMemorySwapchainInfoKHR {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.imageIndex = *ptr
	return x
}

//SwapchainCreateInfoKHR provides a go interface for VkSwapchainCreateInfoKHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSwapchainCreateInfoKHR.html
type SwapchainCreateInfoKHR C.struct_VkSwapchainCreateInfoKHR

// SizeofSwapchainCreateInfoKHR is the memory size of a SwapchainCreateInfoKHR
var SizeofSwapchainCreateInfoKHR int = int(unsafe.Sizeof(SwapchainCreateInfoKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SwapchainCreateInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SwapchainCreateInfoKHR) AsCPtr() *SwapchainCreateInfoKHR {
	clone := (*SwapchainCreateInfoKHR)(newCBlock(C.ulong(SizeofSwapchainCreateInfoKHR)))
	*clone = x
	return clone
}

// SwapchainCreateInfoKHRFreeCSlice releases the memory allocated by SwapchainCreateInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func SwapchainCreateInfoKHRFreeCSlice(x []SwapchainCreateInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SwapchainCreateInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SwapchainCreateInfoKHRFreeCSlice must be called on the returned slice.
func SwapchainCreateInfoKHRMakeCSlice(x ...SwapchainCreateInfoKHR) []SwapchainCreateInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSwapchainCreateInfoKHR * len(x)
	dst := unsafe.Slice((*SwapchainCreateInfoKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SwapchainCreateInfoKHR) WithDefaultSType() SwapchainCreateInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithSType(y StructureType) SwapchainCreateInfoKHR {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithPNext(y unsafe.Pointer) SwapchainCreateInfoKHR {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) Flags() SwapchainCreateFlagsKHR {
	ptr := /* typedef */ (*SwapchainCreateFlagsKHR)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithFlags(y SwapchainCreateFlagsKHR) SwapchainCreateInfoKHR {
	ptr := /* typedef */ (*C.VkSwapchainCreateFlagsKHR)(&y)
	x.flags = *ptr
	return x
}

// Surface returns the value of surface from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) Surface() SurfaceKHR {
	ptr := /* handle */ (*SurfaceKHR)(&x.surface)
	return *ptr
}

// WithSurface sets the value for the Surface on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithSurface(y SurfaceKHR) SwapchainCreateInfoKHR {
	ptr := /* handle */ (*C.VkSurfaceKHR)(&y)
	x.surface = *ptr
	return x
}

// MinImageCount returns the value of minImageCount from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) MinImageCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.minImageCount)
	return *ptr
}

// WithMinImageCount sets the value for the MinImageCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithMinImageCount(y uint32) SwapchainCreateInfoKHR {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.minImageCount = *ptr
	return x
}

// ImageFormat returns the value of imageFormat from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) ImageFormat() Format {
	ptr := /* typedef */ (*Format)(&x.imageFormat)
	return *ptr
}

// WithImageFormat sets the value for the ImageFormat on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithImageFormat(y Format) SwapchainCreateInfoKHR {
	ptr := /* typedef */ (*C.VkFormat)(&y)
	x.imageFormat = *ptr
	return x
}

// ImageColorSpace returns the value of imageColorSpace from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) ImageColorSpace() ColorSpaceKHR {
	ptr := /* typedef */ (*ColorSpaceKHR)(&x.imageColorSpace)
	return *ptr
}

// WithImageColorSpace sets the value for the ImageColorSpace on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithImageColorSpace(y ColorSpaceKHR) SwapchainCreateInfoKHR {
	ptr := /* typedef */ (*C.VkColorSpaceKHR)(&y)
	x.imageColorSpace = *ptr
	return x
}

// ImageExtent returns the value of imageExtent from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) ImageExtent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.imageExtent)
	return *ptr
}

// WithImageExtent sets the value for the ImageExtent on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithImageExtent(y Extent2D) SwapchainCreateInfoKHR {
	ptr := /* typedef */ (*C.struct_VkExtent2D)(&y)
	x.imageExtent = *ptr
	return x
}

// ImageArrayLayers returns the value of imageArrayLayers from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) ImageArrayLayers() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.imageArrayLayers)
	return *ptr
}

// WithImageArrayLayers sets the value for the ImageArrayLayers on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithImageArrayLayers(y uint32) SwapchainCreateInfoKHR {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.imageArrayLayers = *ptr
	return x
}

// ImageUsage returns the value of imageUsage from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) ImageUsage() ImageUsageFlags {
	ptr := /* typedef */ (*ImageUsageFlags)(&x.imageUsage)
	return *ptr
}

// WithImageUsage sets the value for the ImageUsage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithImageUsage(y ImageUsageFlags) SwapchainCreateInfoKHR {
	ptr := /* typedef */ (*C.VkImageUsageFlags)(&y)
	x.imageUsage = *ptr
	return x
}

// ImageSharingMode returns the value of imageSharingMode from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) ImageSharingMode() SharingMode {
	ptr := /* typedef */ (*SharingMode)(&x.imageSharingMode)
	return *ptr
}

// WithImageSharingMode sets the value for the ImageSharingMode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithImageSharingMode(y SharingMode) SwapchainCreateInfoKHR {
	ptr := /* typedef */ (*C.VkSharingMode)(&y)
	x.imageSharingMode = *ptr
	return x
}

// QueueFamilyIndexCount returns the value of queueFamilyIndexCount from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) QueueFamilyIndexCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.queueFamilyIndexCount)
	return *ptr
}

// WithQueueFamilyIndexCount sets the value for the QueueFamilyIndexCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithQueueFamilyIndexCount(y uint32) SwapchainCreateInfoKHR {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.queueFamilyIndexCount = *ptr
	return x
}

// PQueueFamilyIndices returns the value of pQueueFamilyIndices from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) PQueueFamilyIndices() []uint32 {
	ptr := func(x **C.uint) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pQueueFamilyIndices)
	return *ptr
}

// WithPQueueFamilyIndices sets the value for the PQueueFamilyIndices on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines QueueFamilyIndexCount as the length of this field.
// QueueFamilyIndexCount is updated with the length of the new value.
func (x SwapchainCreateInfoKHR) WithPQueueFamilyIndices(y []uint32) SwapchainCreateInfoKHR {
	ptr := func(x *[]uint32) **C.uint { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pQueueFamilyIndices = *ptr
	return x.WithQueueFamilyIndexCount(uint32(len(y)))
}

// PreTransform returns the value of preTransform from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) PreTransform() SurfaceTransformFlagBitsKHR {
	ptr := /* typedef */ (*SurfaceTransformFlagBitsKHR)(&x.preTransform)
	return *ptr
}

// WithPreTransform sets the value for the PreTransform on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithPreTransform(y SurfaceTransformFlagBitsKHR) SwapchainCreateInfoKHR {
	ptr := /* typedef */ (*C.VkSurfaceTransformFlagBitsKHR)(&y)
	x.preTransform = *ptr
	return x
}

// CompositeAlpha returns the value of compositeAlpha from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) CompositeAlpha() CompositeAlphaFlagBitsKHR {
	ptr := /* typedef */ (*CompositeAlphaFlagBitsKHR)(&x.compositeAlpha)
	return *ptr
}

// WithCompositeAlpha sets the value for the CompositeAlpha on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithCompositeAlpha(y CompositeAlphaFlagBitsKHR) SwapchainCreateInfoKHR {
	ptr := /* typedef */ (*C.VkCompositeAlphaFlagBitsKHR)(&y)
	x.compositeAlpha = *ptr
	return x
}

// PresentMode returns the value of presentMode from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) PresentMode() PresentModeKHR {
	ptr := /* typedef */ (*PresentModeKHR)(&x.presentMode)
	return *ptr
}

// WithPresentMode sets the value for the PresentMode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithPresentMode(y PresentModeKHR) SwapchainCreateInfoKHR {
	ptr := /* typedef */ (*C.VkPresentModeKHR)(&y)
	x.presentMode = *ptr
	return x
}

// Clipped returns the value of clipped from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) Clipped() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.clipped)
	return *ptr
}

// WithClipped sets the value for the Clipped on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithClipped(y Bool32) SwapchainCreateInfoKHR {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.clipped = *ptr
	return x
}

// OldSwapchain returns the value of oldSwapchain from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) OldSwapchain() SwapchainKHR {
	ptr := /* handle */ (*SwapchainKHR)(&x.oldSwapchain)
	return *ptr
}

// WithOldSwapchain sets the value for the OldSwapchain on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithOldSwapchain(y SwapchainKHR) SwapchainCreateInfoKHR {
	ptr := /* handle */ (*C.VkSwapchainKHR)(&y)
	x.oldSwapchain = *ptr
	return x
}

//PresentInfoKHR provides a go interface for VkPresentInfoKHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPresentInfoKHR.html
type PresentInfoKHR C.struct_VkPresentInfoKHR

// SizeofPresentInfoKHR is the memory size of a PresentInfoKHR
var SizeofPresentInfoKHR int = int(unsafe.Sizeof(PresentInfoKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PresentInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PresentInfoKHR) AsCPtr() *PresentInfoKHR {
	clone := (*PresentInfoKHR)(newCBlock(C.ulong(SizeofPresentInfoKHR)))
	*clone = x
	return clone
}

// PresentInfoKHRFreeCSlice releases the memory allocated by PresentInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func PresentInfoKHRFreeCSlice(x []PresentInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PresentInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PresentInfoKHRFreeCSlice must be called on the returned slice.
func PresentInfoKHRMakeCSlice(x ...PresentInfoKHR) []PresentInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPresentInfoKHR * len(x)
	dst := unsafe.Slice((*PresentInfoKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPresentInfoKHR
func (x PresentInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PresentInfoKHR) WithDefaultSType() PresentInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_PRESENT_INFO_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PresentInfoKHR) WithSType(y StructureType) PresentInfoKHR {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPresentInfoKHR
func (x PresentInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PresentInfoKHR) WithPNext(y unsafe.Pointer) PresentInfoKHR {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// WaitSemaphoreCount returns the value of waitSemaphoreCount from VkPresentInfoKHR
func (x PresentInfoKHR) WaitSemaphoreCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.waitSemaphoreCount)
	return *ptr
}

// WithWaitSemaphoreCount sets the value for the WaitSemaphoreCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PresentInfoKHR) WithWaitSemaphoreCount(y uint32) PresentInfoKHR {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.waitSemaphoreCount = *ptr
	return x
}

// PWaitSemaphores returns the value of pWaitSemaphores from VkPresentInfoKHR
func (x PresentInfoKHR) PWaitSemaphores() []Semaphore {
	ptr := func(x **C.VkSemaphore) *[]Semaphore { /* Slice */
		slc := unsafe.Slice((*Semaphore)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pWaitSemaphores)
	return *ptr
}

// WithPWaitSemaphores sets the value for the PWaitSemaphores on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines WaitSemaphoreCount as the length of this field.
// WaitSemaphoreCount is updated with the length of the new value.
func (x PresentInfoKHR) WithPWaitSemaphores(y []Semaphore) PresentInfoKHR {
	ptr := func(x *[]Semaphore) **C.VkSemaphore { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSemaphore)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSemaphore)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pWaitSemaphores = *ptr
	return x.WithWaitSemaphoreCount(uint32(len(y)))
}

// SwapchainCount returns the value of swapchainCount from VkPresentInfoKHR
func (x PresentInfoKHR) SwapchainCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.swapchainCount)
	return *ptr
}

// WithSwapchainCount sets the value for the SwapchainCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PresentInfoKHR) WithSwapchainCount(y uint32) PresentInfoKHR {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.swapchainCount = *ptr
	return x
}

// PSwapchains returns the value of pSwapchains from VkPresentInfoKHR
func (x PresentInfoKHR) PSwapchains() []SwapchainKHR {
	ptr := func(x **C.VkSwapchainKHR) *[]SwapchainKHR { /* Slice */
		slc := unsafe.Slice((*SwapchainKHR)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pSwapchains)
	return *ptr
}

// WithPSwapchains sets the value for the PSwapchains on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SwapchainCount as the length of this field.
// SwapchainCount is updated with the length of the new value.
func (x PresentInfoKHR) WithPSwapchains(y []SwapchainKHR) PresentInfoKHR {
	ptr := func(x *[]SwapchainKHR) **C.VkSwapchainKHR { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSwapchainKHR)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSwapchainKHR)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pSwapchains = *ptr
	return x.WithSwapchainCount(uint32(len(y)))
}

// PImageIndices returns the value of pImageIndices from VkPresentInfoKHR
func (x PresentInfoKHR) PImageIndices() []uint32 {
	ptr := func(x **C.uint) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pImageIndices)
	return *ptr
}

// WithPImageIndices sets the value for the PImageIndices on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SwapchainCount as the length of this field.
// SwapchainCount is updated with the length of the new value.
func (x PresentInfoKHR) WithPImageIndices(y []uint32) PresentInfoKHR {
	ptr := func(x *[]uint32) **C.uint { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pImageIndices = *ptr
	return x.WithSwapchainCount(uint32(len(y)))
}

// PResults returns the value of pResults from VkPresentInfoKHR
func (x PresentInfoKHR) PResults() []Result {
	ptr := func(x **C.VkResult) *[]Result { /* Slice */
		slc := unsafe.Slice((*Result)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pResults)
	return *ptr
}

// WithPResults sets the value for the PResults on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SwapchainCount as the length of this field.
// SwapchainCount is updated with the length of the new value.
func (x PresentInfoKHR) WithPResults(y []Result) PresentInfoKHR {
	ptr := func(x *[]Result) **C.VkResult { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkResult)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkResult)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pResults = *ptr
	return x.WithSwapchainCount(uint32(len(y)))
}

//DeviceGroupPresentCapabilitiesKHR provides a go interface for VkDeviceGroupPresentCapabilitiesKHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDeviceGroupPresentCapabilitiesKHR.html
type DeviceGroupPresentCapabilitiesKHR C.struct_VkDeviceGroupPresentCapabilitiesKHR

// SizeofDeviceGroupPresentCapabilitiesKHR is the memory size of a DeviceGroupPresentCapabilitiesKHR
var SizeofDeviceGroupPresentCapabilitiesKHR int = int(unsafe.Sizeof(DeviceGroupPresentCapabilitiesKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceGroupPresentCapabilitiesKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceGroupPresentCapabilitiesKHR) AsCPtr() *DeviceGroupPresentCapabilitiesKHR {
	clone := (*DeviceGroupPresentCapabilitiesKHR)(newCBlock(C.ulong(SizeofDeviceGroupPresentCapabilitiesKHR)))
	*clone = x
	return clone
}

// DeviceGroupPresentCapabilitiesKHRFreeCSlice releases the memory allocated by DeviceGroupPresentCapabilitiesKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceGroupPresentCapabilitiesKHRFreeCSlice(x []DeviceGroupPresentCapabilitiesKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceGroupPresentCapabilitiesKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceGroupPresentCapabilitiesKHRFreeCSlice must be called on the returned slice.
func DeviceGroupPresentCapabilitiesKHRMakeCSlice(x ...DeviceGroupPresentCapabilitiesKHR) []DeviceGroupPresentCapabilitiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupPresentCapabilitiesKHR * len(x)
	dst := unsafe.Slice((*DeviceGroupPresentCapabilitiesKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceGroupPresentCapabilitiesKHR
func (x DeviceGroupPresentCapabilitiesKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DeviceGroupPresentCapabilitiesKHR) WithDefaultSType() DeviceGroupPresentCapabilitiesKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupPresentCapabilitiesKHR) WithSType(y StructureType) DeviceGroupPresentCapabilitiesKHR {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDeviceGroupPresentCapabilitiesKHR
func (x DeviceGroupPresentCapabilitiesKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupPresentCapabilitiesKHR) WithPNext(y unsafe.Pointer) DeviceGroupPresentCapabilitiesKHR {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// PresentMask returns the value of presentMask from VkDeviceGroupPresentCapabilitiesKHR
func (x DeviceGroupPresentCapabilitiesKHR) PresentMask() []uint32 {
	ptr := func(x *[VK_MAX_DEVICE_GROUP_SIZE]C.uint) *[]uint32 { /* Array */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), VK_MAX_DEVICE_GROUP_SIZE)
		return &slc
	}(&x.presentMask)
	return *ptr
}

// Modes returns the value of modes from VkDeviceGroupPresentCapabilitiesKHR
func (x DeviceGroupPresentCapabilitiesKHR) Modes() DeviceGroupPresentModeFlagsKHR {
	ptr := /* typedef */ (*DeviceGroupPresentModeFlagsKHR)(&x.modes)
	return *ptr
}

//DeviceGroupPresentInfoKHR provides a go interface for VkDeviceGroupPresentInfoKHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDeviceGroupPresentInfoKHR.html
type DeviceGroupPresentInfoKHR C.struct_VkDeviceGroupPresentInfoKHR

// SizeofDeviceGroupPresentInfoKHR is the memory size of a DeviceGroupPresentInfoKHR
var SizeofDeviceGroupPresentInfoKHR int = int(unsafe.Sizeof(DeviceGroupPresentInfoKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceGroupPresentInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceGroupPresentInfoKHR) AsCPtr() *DeviceGroupPresentInfoKHR {
	clone := (*DeviceGroupPresentInfoKHR)(newCBlock(C.ulong(SizeofDeviceGroupPresentInfoKHR)))
	*clone = x
	return clone
}

// DeviceGroupPresentInfoKHRFreeCSlice releases the memory allocated by DeviceGroupPresentInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceGroupPresentInfoKHRFreeCSlice(x []DeviceGroupPresentInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceGroupPresentInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceGroupPresentInfoKHRFreeCSlice must be called on the returned slice.
func DeviceGroupPresentInfoKHRMakeCSlice(x ...DeviceGroupPresentInfoKHR) []DeviceGroupPresentInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupPresentInfoKHR * len(x)
	dst := unsafe.Slice((*DeviceGroupPresentInfoKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceGroupPresentInfoKHR
func (x DeviceGroupPresentInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DeviceGroupPresentInfoKHR) WithDefaultSType() DeviceGroupPresentInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupPresentInfoKHR) WithSType(y StructureType) DeviceGroupPresentInfoKHR {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDeviceGroupPresentInfoKHR
func (x DeviceGroupPresentInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupPresentInfoKHR) WithPNext(y unsafe.Pointer) DeviceGroupPresentInfoKHR {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// SwapchainCount returns the value of swapchainCount from VkDeviceGroupPresentInfoKHR
func (x DeviceGroupPresentInfoKHR) SwapchainCount() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.swapchainCount)
	return *ptr
}

// WithSwapchainCount sets the value for the SwapchainCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupPresentInfoKHR) WithSwapchainCount(y uint32) DeviceGroupPresentInfoKHR {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.swapchainCount = *ptr
	return x
}

// PDeviceMasks returns the value of pDeviceMasks from VkDeviceGroupPresentInfoKHR
func (x DeviceGroupPresentInfoKHR) PDeviceMasks() []uint32 {
	ptr := func(x **C.uint) *[]uint32 { /* Slice */
		slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31))
		return &slc
	}(&x.pDeviceMasks)
	return *ptr
}

// WithPDeviceMasks sets the value for the PDeviceMasks on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
//
// The specification defines SwapchainCount as the length of this field.
// SwapchainCount is updated with the length of the new value.
func (x DeviceGroupPresentInfoKHR) WithPDeviceMasks(y []uint32) DeviceGroupPresentInfoKHR {
	ptr := func(x *[]uint32) **C.uint { /* Slice */
		if len(*x) > 0 {
			slc := (*C.uint)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.uint)(unsafe.Pointer((&ptr)))
	}(&y)
	x.pDeviceMasks = *ptr
	return x.WithSwapchainCount(uint32(len(y)))
}

// Mode returns the value of mode from VkDeviceGroupPresentInfoKHR
func (x DeviceGroupPresentInfoKHR) Mode() DeviceGroupPresentModeFlagBitsKHR {
	ptr := /* typedef */ (*DeviceGroupPresentModeFlagBitsKHR)(&x.mode)
	return *ptr
}

// WithMode sets the value for the Mode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupPresentInfoKHR) WithMode(y DeviceGroupPresentModeFlagBitsKHR) DeviceGroupPresentInfoKHR {
	ptr := /* typedef */ (*C.VkDeviceGroupPresentModeFlagBitsKHR)(&y)
	x.mode = *ptr
	return x
}

//DeviceGroupSwapchainCreateInfoKHR provides a go interface for VkDeviceGroupSwapchainCreateInfoKHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDeviceGroupSwapchainCreateInfoKHR.html
type DeviceGroupSwapchainCreateInfoKHR C.struct_VkDeviceGroupSwapchainCreateInfoKHR

// SizeofDeviceGroupSwapchainCreateInfoKHR is the memory size of a DeviceGroupSwapchainCreateInfoKHR
var SizeofDeviceGroupSwapchainCreateInfoKHR int = int(unsafe.Sizeof(DeviceGroupSwapchainCreateInfoKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceGroupSwapchainCreateInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceGroupSwapchainCreateInfoKHR) AsCPtr() *DeviceGroupSwapchainCreateInfoKHR {
	clone := (*DeviceGroupSwapchainCreateInfoKHR)(newCBlock(C.ulong(SizeofDeviceGroupSwapchainCreateInfoKHR)))
	*clone = x
	return clone
}

// DeviceGroupSwapchainCreateInfoKHRFreeCSlice releases the memory allocated by DeviceGroupSwapchainCreateInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceGroupSwapchainCreateInfoKHRFreeCSlice(x []DeviceGroupSwapchainCreateInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceGroupSwapchainCreateInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceGroupSwapchainCreateInfoKHRFreeCSlice must be called on the returned slice.
func DeviceGroupSwapchainCreateInfoKHRMakeCSlice(x ...DeviceGroupSwapchainCreateInfoKHR) []DeviceGroupSwapchainCreateInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupSwapchainCreateInfoKHR * len(x)
	dst := unsafe.Slice((*DeviceGroupSwapchainCreateInfoKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceGroupSwapchainCreateInfoKHR
func (x DeviceGroupSwapchainCreateInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DeviceGroupSwapchainCreateInfoKHR) WithDefaultSType() DeviceGroupSwapchainCreateInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupSwapchainCreateInfoKHR) WithSType(y StructureType) DeviceGroupSwapchainCreateInfoKHR {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDeviceGroupSwapchainCreateInfoKHR
func (x DeviceGroupSwapchainCreateInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupSwapchainCreateInfoKHR) WithPNext(y unsafe.Pointer) DeviceGroupSwapchainCreateInfoKHR {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Modes returns the value of modes from VkDeviceGroupSwapchainCreateInfoKHR
func (x DeviceGroupSwapchainCreateInfoKHR) Modes() DeviceGroupPresentModeFlagsKHR {
	ptr := /* typedef */ (*DeviceGroupPresentModeFlagsKHR)(&x.modes)
	return *ptr
}

// WithModes sets the value for the Modes on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupSwapchainCreateInfoKHR) WithModes(y DeviceGroupPresentModeFlagsKHR) DeviceGroupSwapchainCreateInfoKHR {
	ptr := /* typedef */ (*C.VkDeviceGroupPresentModeFlagsKHR)(&y)
	x.modes = *ptr
	return x
}

//AcquireNextImageInfoKHR provides a go interface for VkAcquireNextImageInfoKHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkAcquireNextImageInfoKHR.html
type AcquireNextImageInfoKHR C.struct_VkAcquireNextImageInfoKHR

// SizeofAcquireNextImageInfoKHR is the memory size of a AcquireNextImageInfoKHR
var SizeofAcquireNextImageInfoKHR int = int(unsafe.Sizeof(AcquireNextImageInfoKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *AcquireNextImageInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x AcquireNextImageInfoKHR) AsCPtr() *AcquireNextImageInfoKHR {
	clone := (*AcquireNextImageInfoKHR)(newCBlock(C.ulong(SizeofAcquireNextImageInfoKHR)))
	*clone = x
	return clone
}

// AcquireNextImageInfoKHRFreeCSlice releases the memory allocated by AcquireNextImageInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func AcquireNextImageInfoKHRFreeCSlice(x []AcquireNextImageInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// AcquireNextImageInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. AcquireNextImageInfoKHRFreeCSlice must be called on the returned slice.
func AcquireNextImageInfoKHRMakeCSlice(x ...AcquireNextImageInfoKHR) []AcquireNextImageInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAcquireNextImageInfoKHR * len(x)
	dst := unsafe.Slice((*AcquireNextImageInfoKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkAcquireNextImageInfoKHR
func (x AcquireNextImageInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x AcquireNextImageInfoKHR) WithDefaultSType() AcquireNextImageInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AcquireNextImageInfoKHR) WithSType(y StructureType) AcquireNextImageInfoKHR {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkAcquireNextImageInfoKHR
func (x AcquireNextImageInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AcquireNextImageInfoKHR) WithPNext(y unsafe.Pointer) AcquireNextImageInfoKHR {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Swapchain returns the value of swapchain from VkAcquireNextImageInfoKHR
func (x AcquireNextImageInfoKHR) Swapchain() SwapchainKHR {
	ptr := /* handle */ (*SwapchainKHR)(&x.swapchain)
	return *ptr
}

// WithSwapchain sets the value for the Swapchain on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AcquireNextImageInfoKHR) WithSwapchain(y SwapchainKHR) AcquireNextImageInfoKHR {
	ptr := /* handle */ (*C.VkSwapchainKHR)(&y)
	x.swapchain = *ptr
	return x
}

// Timeout returns the value of timeout from VkAcquireNextImageInfoKHR
func (x AcquireNextImageInfoKHR) Timeout() uint64 {
	ptr := func(x *C.ulonglong) *uint64 { /* Scalar */ return (*uint64)(unsafe.Pointer(x)) }(&x.timeout)
	return *ptr
}

// WithTimeout sets the value for the Timeout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AcquireNextImageInfoKHR) WithTimeout(y uint64) AcquireNextImageInfoKHR {
	ptr := func(x *uint64) *C.ulonglong { /* Scalar */ return (*C.ulonglong)(unsafe.Pointer(x)) }(&y)
	x.timeout = *ptr
	return x
}

// Semaphore returns the value of semaphore from VkAcquireNextImageInfoKHR
func (x AcquireNextImageInfoKHR) Semaphore() Semaphore {
	ptr := /* handle */ (*Semaphore)(&x.semaphore)
	return *ptr
}

// WithSemaphore sets the value for the Semaphore on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AcquireNextImageInfoKHR) WithSemaphore(y Semaphore) AcquireNextImageInfoKHR {
	ptr := /* handle */ (*C.VkSemaphore)(&y)
	x.semaphore = *ptr
	return x
}

// Fence returns the value of fence from VkAcquireNextImageInfoKHR
func (x AcquireNextImageInfoKHR) Fence() Fence {
	ptr := /* handle */ (*Fence)(&x.fence)
	return *ptr
}

// WithFence sets the value for the Fence on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AcquireNextImageInfoKHR) WithFence(y Fence) AcquireNextImageInfoKHR {
	ptr := /* handle */ (*C.VkFence)(&y)
	x.fence = *ptr
	return x
}

// DeviceMask returns the value of deviceMask from VkAcquireNextImageInfoKHR
func (x AcquireNextImageInfoKHR) DeviceMask() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.deviceMask)
	return *ptr
}

// WithDeviceMask sets the value for the DeviceMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AcquireNextImageInfoKHR) WithDeviceMask(y uint32) AcquireNextImageInfoKHR {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.deviceMask = *ptr
	return x
}

//ImageSwapchainCreateInfoKHR provides a go interface for VkImageSwapchainCreateInfoKHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageSwapchainCreateInfoKHR.html
type ImageSwapchainCreateInfoKHR C.struct_VkImageSwapchainCreateInfoKHR

// SizeofImageSwapchainCreateInfoKHR is the memory size of a ImageSwapchainCreateInfoKHR
var SizeofImageSwapchainCreateInfoKHR int = int(unsafe.Sizeof(ImageSwapchainCreateInfoKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageSwapchainCreateInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageSwapchainCreateInfoKHR) AsCPtr() *ImageSwapchainCreateInfoKHR {
	clone := (*ImageSwapchainCreateInfoKHR)(newCBlock(C.ulong(SizeofImageSwapchainCreateInfoKHR)))
	*clone = x
	return clone
}

// ImageSwapchainCreateInfoKHRFreeCSlice releases the memory allocated by ImageSwapchainCreateInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageSwapchainCreateInfoKHRFreeCSlice(x []ImageSwapchainCreateInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageSwapchainCreateInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageSwapchainCreateInfoKHRFreeCSlice must be called on the returned slice.
func ImageSwapchainCreateInfoKHRMakeCSlice(x ...ImageSwapchainCreateInfoKHR) []ImageSwapchainCreateInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageSwapchainCreateInfoKHR * len(x)
	dst := unsafe.Slice((*ImageSwapchainCreateInfoKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageSwapchainCreateInfoKHR
func (x ImageSwapchainCreateInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ImageSwapchainCreateInfoKHR) WithDefaultSType() ImageSwapchainCreateInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSwapchainCreateInfoKHR) WithSType(y StructureType) ImageSwapchainCreateInfoKHR {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkImageSwapchainCreateInfoKHR
func (x ImageSwapchainCreateInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSwapchainCreateInfoKHR) WithPNext(y unsafe.Pointer) ImageSwapchainCreateInfoKHR {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Swapchain returns the value of swapchain from VkImageSwapchainCreateInfoKHR
func (x ImageSwapchainCreateInfoKHR) Swapchain() SwapchainKHR {
	ptr := /* handle */ (*SwapchainKHR)(&x.swapchain)
	return *ptr
}

// WithSwapchain sets the value for the Swapchain on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSwapchainCreateInfoKHR) WithSwapchain(y SwapchainKHR) ImageSwapchainCreateInfoKHR {
	ptr := /* handle */ (*C.VkSwapchainKHR)(&y)
	x.swapchain = *ptr
	return x
}

func (x PhysicalDeviceFacade) GetPhysicalDevicePresentRectanglesKHR(surface SurfaceKHR, pRectCount *uint32, pRects []Rect2D) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* handle */ (*C.VkSurfaceKHR)(&surface)
	p2 := func(x **uint32) **C.uint { /* Pointer */ return (**C.uint)(unsafe.Pointer(x)) }(&pRectCount)
	p3 := func(x *[]Rect2D) **C.struct_VkRect2D { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkRect2D)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkRect2D)(unsafe.Pointer((&ptr)))
	}(&pRects)
	ret := C.vkGetPhysicalDevicePresentRectanglesKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) AcquireNextImage2KHR(pAcquireInfo *AcquireNextImageInfoKHR, pImageIndex *uint32) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **AcquireNextImageInfoKHR) **C.struct_VkAcquireNextImageInfoKHR { /* Pointer */
		return (**C.struct_VkAcquireNextImageInfoKHR)(unsafe.Pointer(x))
	}(&pAcquireInfo)
	p2 := func(x **uint32) **C.uint { /* Pointer */ return (**C.uint)(unsafe.Pointer(x)) }(&pImageIndex)
	ret := C.vkAcquireNextImage2KHR(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) GetDeviceGroupSurfacePresentModesKHR(surface SurfaceKHR, pModes *DeviceGroupPresentModeFlagsKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkSurfaceKHR)(&surface)
	p2 := func(x **DeviceGroupPresentModeFlagsKHR) **C.VkDeviceGroupPresentModeFlagsKHR { /* Pointer */
		return (**C.VkDeviceGroupPresentModeFlagsKHR)(unsafe.Pointer(x))
	}(&pModes)
	ret := C.vkGetDeviceGroupSurfacePresentModesKHR(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) GetDeviceGroupPresentCapabilitiesKHR(pDeviceGroupPresentCapabilities *DeviceGroupPresentCapabilitiesKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DeviceGroupPresentCapabilitiesKHR) **C.struct_VkDeviceGroupPresentCapabilitiesKHR { /* Pointer */
		return (**C.struct_VkDeviceGroupPresentCapabilitiesKHR)(unsafe.Pointer(x))
	}(&pDeviceGroupPresentCapabilities)
	ret := C.vkGetDeviceGroupPresentCapabilitiesKHR(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x QueueFacade) QueuePresentKHR(pPresentInfo *PresentInfoKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkQueue)(&x.H)
	p1 := func(x **PresentInfoKHR) **C.struct_VkPresentInfoKHR { /* Pointer */
		return (**C.struct_VkPresentInfoKHR)(unsafe.Pointer(x))
	}(&pPresentInfo)
	ret := C.vkQueuePresentKHR(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) AcquireNextImageKHR(swapchain SwapchainKHR, timeout uint64, semaphore Semaphore, fence Fence, pImageIndex *uint32) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkSwapchainKHR)(&swapchain)
	p2 := func(x *uint64) *C.ulonglong { /* Scalar */ return (*C.ulonglong)(unsafe.Pointer(x)) }(&timeout)
	p3 := /* handle */ (*C.VkSemaphore)(&semaphore)
	p4 := /* handle */ (*C.VkFence)(&fence)
	p5 := func(x **uint32) **C.uint { /* Pointer */ return (**C.uint)(unsafe.Pointer(x)) }(&pImageIndex)
	ret := C.vkAcquireNextImageKHR(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) GetSwapchainImagesKHR(swapchain SwapchainKHR, pSwapchainImageCount *uint32, pSwapchainImages []Image) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkSwapchainKHR)(&swapchain)
	p2 := func(x **uint32) **C.uint { /* Pointer */ return (**C.uint)(unsafe.Pointer(x)) }(&pSwapchainImageCount)
	p3 := func(x *[]Image) **C.VkImage { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkImage)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkImage)(unsafe.Pointer((&ptr)))
	}(&pSwapchainImages)
	ret := C.vkGetSwapchainImagesKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x DeviceFacade) DestroySwapchainKHR(swapchain SwapchainKHR, pAllocator *AllocationCallbacks) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkSwapchainKHR)(&swapchain)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	C.vkDestroySwapchainKHR(addrs, *p0, *p1, *p2)
}

func (x DeviceFacade) CreateSwapchainKHR(pCreateInfo *SwapchainCreateInfoKHR, pAllocator *AllocationCallbacks, pSwapchain *SwapchainKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **SwapchainCreateInfoKHR) **C.struct_VkSwapchainCreateInfoKHR { /* Pointer */
		return (**C.struct_VkSwapchainCreateInfoKHR)(unsafe.Pointer(x))
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p3 := func(x **SwapchainKHR) **C.VkSwapchainKHR { /* Pointer */ return (**C.VkSwapchainKHR)(unsafe.Pointer(x)) }(&pSwapchain)
	ret := C.vkCreateSwapchainKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DisplayKHR is a Handle to a vulkan resource.
// DisplayKHR is a child of PhysicalDevice.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDisplayKHR.html
type DisplayKHR C.VkDisplayKHR

// NullDisplayKHR is a typed Null value for the DisplayKHR type.
var NullDisplayKHR DisplayKHR

// MakeDisplayKHRFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent PhysicalDeviceFacade) MakeDisplayKHRFacade(x DisplayKHR) DisplayKHRFacade {
	return DisplayKHRFacade{
		H:     x,
		procs: parent.procs,
	}
}

// DisplayKHRFacade is a DisplayKHR handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type DisplayKHRFacade struct {
	H     DisplayKHR     // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// DisplayModeKHR is a Handle to a vulkan resource.
// DisplayModeKHR is a child of DisplayKHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDisplayModeKHR.html
type DisplayModeKHR C.VkDisplayModeKHR

// NullDisplayModeKHR is a typed Null value for the DisplayModeKHR type.
var NullDisplayModeKHR DisplayModeKHR

// MakeDisplayModeKHRFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DisplayKHRFacade) MakeDisplayModeKHRFacade(x DisplayModeKHR) DisplayModeKHRFacade {
	return DisplayModeKHRFacade{
		H:     x,
		procs: parent.procs,
	}
}

// DisplayModeKHRFacade is a DisplayModeKHR handle with the proc addresses pointer. It allows
// the invocation of methods against the handle -- functions that take the handle
// as the first parameter.
type DisplayModeKHRFacade struct {
	H     DisplayModeKHR // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}

// DisplayPlaneAlphaFlagBitsKHR is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDisplayPlaneAlphaFlagBitsKHR.html
type DisplayPlaneAlphaFlagBitsKHR uint32

const (
	VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR                  DisplayPlaneAlphaFlagBitsKHR = (1 << 0)
	VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR                  DisplayPlaneAlphaFlagBitsKHR = (1 << 1)
	VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR               DisplayPlaneAlphaFlagBitsKHR = (1 << 2)
	VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR DisplayPlaneAlphaFlagBitsKHR = (1 << 3)
)

var (
	reverseDisplayPlaneAlphaFlagBitsKHR map[DisplayPlaneAlphaFlagBitsKHR]string = map[DisplayPlaneAlphaFlagBitsKHR]string{
		VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR:                  "VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR",
		VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR:                  "VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR",
		VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR:               "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR",
		VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR: "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR",
	}
)

func (x DisplayPlaneAlphaFlagBitsKHR) String() string {
	if s, ok := reverseDisplayPlaneAlphaFlagBitsKHR[x]; ok {
		return s
	}
	return fmt.Sprintf("DisplayPlaneAlphaFlagBitsKHR=%d", x)
}

// DisplayModeCreateFlagsKHR is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDisplayModeCreateFlagsKHR.html
type DisplayModeCreateFlagsKHR Flags

// DisplayPlaneAlphaFlagsKHR is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDisplayPlaneAlphaFlagsKHR.html
type DisplayPlaneAlphaFlagsKHR Flags

// DisplaySurfaceCreateFlagsKHR is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDisplaySurfaceCreateFlagsKHR.html
type DisplaySurfaceCreateFlagsKHR Flags

//DisplayPlanePropertiesKHR provides a go interface for VkDisplayPlanePropertiesKHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDisplayPlanePropertiesKHR.html
type DisplayPlanePropertiesKHR C.struct_VkDisplayPlanePropertiesKHR

// SizeofDisplayPlanePropertiesKHR is the memory size of a DisplayPlanePropertiesKHR
var SizeofDisplayPlanePropertiesKHR int = int(unsafe.Sizeof(DisplayPlanePropertiesKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayPlanePropertiesKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayPlanePropertiesKHR) AsCPtr() *DisplayPlanePropertiesKHR {
	clone := (*DisplayPlanePropertiesKHR)(newCBlock(C.ulong(SizeofDisplayPlanePropertiesKHR)))
	*clone = x
	return clone
}

// DisplayPlanePropertiesKHRFreeCSlice releases the memory allocated by DisplayPlanePropertiesKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayPlanePropertiesKHRFreeCSlice(x []DisplayPlanePropertiesKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayPlanePropertiesKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayPlanePropertiesKHRFreeCSlice must be called on the returned slice.
func DisplayPlanePropertiesKHRMakeCSlice(x ...DisplayPlanePropertiesKHR) []DisplayPlanePropertiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPlanePropertiesKHR * len(x)
	dst := unsafe.Slice((*DisplayPlanePropertiesKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// CurrentDisplay returns the value of currentDisplay from VkDisplayPlanePropertiesKHR
func (x DisplayPlanePropertiesKHR) CurrentDisplay() DisplayKHR {
	ptr := /* handle */ (*DisplayKHR)(&x.currentDisplay)
	return *ptr
}

// CurrentStackIndex returns the value of currentStackIndex from VkDisplayPlanePropertiesKHR
func (x DisplayPlanePropertiesKHR) CurrentStackIndex() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.currentStackIndex)
	return *ptr
}

//DisplayModePropertiesKHR provides a go interface for VkDisplayModePropertiesKHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDisplayModePropertiesKHR.html
type DisplayModePropertiesKHR C.struct_VkDisplayModePropertiesKHR

// SizeofDisplayModePropertiesKHR is the memory size of a DisplayModePropertiesKHR
var SizeofDisplayModePropertiesKHR int = int(unsafe.Sizeof(DisplayModePropertiesKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayModePropertiesKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayModePropertiesKHR) AsCPtr() *DisplayModePropertiesKHR {
	clone := (*DisplayModePropertiesKHR)(newCBlock(C.ulong(SizeofDisplayModePropertiesKHR)))
	*clone = x
	return clone
}

// DisplayModePropertiesKHRFreeCSlice releases the memory allocated by DisplayModePropertiesKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayModePropertiesKHRFreeCSlice(x []DisplayModePropertiesKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayModePropertiesKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayModePropertiesKHRFreeCSlice must be called on the returned slice.
func DisplayModePropertiesKHRMakeCSlice(x ...DisplayModePropertiesKHR) []DisplayModePropertiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayModePropertiesKHR * len(x)
	dst := unsafe.Slice((*DisplayModePropertiesKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// DisplayMode returns the value of displayMode from VkDisplayModePropertiesKHR
func (x DisplayModePropertiesKHR) DisplayMode() DisplayModeKHR {
	ptr := /* handle */ (*DisplayModeKHR)(&x.displayMode)
	return *ptr
}

// Parameters returns the value of parameters from VkDisplayModePropertiesKHR
func (x DisplayModePropertiesKHR) Parameters() DisplayModeParametersKHR {
	ptr := /* typedef */ (*DisplayModeParametersKHR)(&x.parameters)
	return *ptr
}

//DisplayPropertiesKHR provides a go interface for VkDisplayPropertiesKHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDisplayPropertiesKHR.html
type DisplayPropertiesKHR C.struct_VkDisplayPropertiesKHR

// SizeofDisplayPropertiesKHR is the memory size of a DisplayPropertiesKHR
var SizeofDisplayPropertiesKHR int = int(unsafe.Sizeof(DisplayPropertiesKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayPropertiesKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayPropertiesKHR) AsCPtr() *DisplayPropertiesKHR {
	clone := (*DisplayPropertiesKHR)(newCBlock(C.ulong(SizeofDisplayPropertiesKHR)))
	*clone = x
	return clone
}

// DisplayPropertiesKHRFreeCSlice releases the memory allocated by DisplayPropertiesKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayPropertiesKHRFreeCSlice(x []DisplayPropertiesKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayPropertiesKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayPropertiesKHRFreeCSlice must be called on the returned slice.
func DisplayPropertiesKHRMakeCSlice(x ...DisplayPropertiesKHR) []DisplayPropertiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPropertiesKHR * len(x)
	dst := unsafe.Slice((*DisplayPropertiesKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Display returns the value of display from VkDisplayPropertiesKHR
func (x DisplayPropertiesKHR) Display() DisplayKHR {
	ptr := /* handle */ (*DisplayKHR)(&x.display)
	return *ptr
}

// DisplayName returns the value of displayName from VkDisplayPropertiesKHR
func (x DisplayPropertiesKHR) DisplayName() *byte {
	ptr := func(x **C.char) **byte { /* Pointer */ return (**byte)(unsafe.Pointer(x)) }(&x.displayName)
	return *ptr
}

// PhysicalDimensions returns the value of physicalDimensions from VkDisplayPropertiesKHR
func (x DisplayPropertiesKHR) PhysicalDimensions() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.physicalDimensions)
	return *ptr
}

// PhysicalResolution returns the value of physicalResolution from VkDisplayPropertiesKHR
func (x DisplayPropertiesKHR) PhysicalResolution() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.physicalResolution)
	return *ptr
}

// SupportedTransforms returns the value of supportedTransforms from VkDisplayPropertiesKHR
func (x DisplayPropertiesKHR) SupportedTransforms() SurfaceTransformFlagsKHR {
	ptr := /* typedef */ (*SurfaceTransformFlagsKHR)(&x.supportedTransforms)
	return *ptr
}

// PlaneReorderPossible returns the value of planeReorderPossible from VkDisplayPropertiesKHR
func (x DisplayPropertiesKHR) PlaneReorderPossible() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.planeReorderPossible)
	return *ptr
}

// PersistentContent returns the value of persistentContent from VkDisplayPropertiesKHR
func (x DisplayPropertiesKHR) PersistentContent() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.persistentContent)
	return *ptr
}

//DisplayModeCreateInfoKHR provides a go interface for VkDisplayModeCreateInfoKHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDisplayModeCreateInfoKHR.html
type DisplayModeCreateInfoKHR C.struct_VkDisplayModeCreateInfoKHR

// SizeofDisplayModeCreateInfoKHR is the memory size of a DisplayModeCreateInfoKHR
var SizeofDisplayModeCreateInfoKHR int = int(unsafe.Sizeof(DisplayModeCreateInfoKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayModeCreateInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayModeCreateInfoKHR) AsCPtr() *DisplayModeCreateInfoKHR {
	clone := (*DisplayModeCreateInfoKHR)(newCBlock(C.ulong(SizeofDisplayModeCreateInfoKHR)))
	*clone = x
	return clone
}

// DisplayModeCreateInfoKHRFreeCSlice releases the memory allocated by DisplayModeCreateInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayModeCreateInfoKHRFreeCSlice(x []DisplayModeCreateInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayModeCreateInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayModeCreateInfoKHRFreeCSlice must be called on the returned slice.
func DisplayModeCreateInfoKHRMakeCSlice(x ...DisplayModeCreateInfoKHR) []DisplayModeCreateInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayModeCreateInfoKHR * len(x)
	dst := unsafe.Slice((*DisplayModeCreateInfoKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDisplayModeCreateInfoKHR
func (x DisplayModeCreateInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DisplayModeCreateInfoKHR) WithDefaultSType() DisplayModeCreateInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayModeCreateInfoKHR) WithSType(y StructureType) DisplayModeCreateInfoKHR {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDisplayModeCreateInfoKHR
func (x DisplayModeCreateInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayModeCreateInfoKHR) WithPNext(y unsafe.Pointer) DisplayModeCreateInfoKHR {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkDisplayModeCreateInfoKHR
func (x DisplayModeCreateInfoKHR) Flags() DisplayModeCreateFlagsKHR {
	ptr := /* typedef */ (*DisplayModeCreateFlagsKHR)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayModeCreateInfoKHR) WithFlags(y DisplayModeCreateFlagsKHR) DisplayModeCreateInfoKHR {
	ptr := /* typedef */ (*C.VkDisplayModeCreateFlagsKHR)(&y)
	x.flags = *ptr
	return x
}

// Parameters returns the value of parameters from VkDisplayModeCreateInfoKHR
func (x DisplayModeCreateInfoKHR) Parameters() DisplayModeParametersKHR {
	ptr := /* typedef */ (*DisplayModeParametersKHR)(&x.parameters)
	return *ptr
}

// WithParameters sets the value for the Parameters on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayModeCreateInfoKHR) WithParameters(y DisplayModeParametersKHR) DisplayModeCreateInfoKHR {
	ptr := /* typedef */ (*C.struct_VkDisplayModeParametersKHR)(&y)
	x.parameters = *ptr
	return x
}

//DisplayPlaneCapabilitiesKHR provides a go interface for VkDisplayPlaneCapabilitiesKHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDisplayPlaneCapabilitiesKHR.html
type DisplayPlaneCapabilitiesKHR C.struct_VkDisplayPlaneCapabilitiesKHR

// SizeofDisplayPlaneCapabilitiesKHR is the memory size of a DisplayPlaneCapabilitiesKHR
var SizeofDisplayPlaneCapabilitiesKHR int = int(unsafe.Sizeof(DisplayPlaneCapabilitiesKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayPlaneCapabilitiesKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayPlaneCapabilitiesKHR) AsCPtr() *DisplayPlaneCapabilitiesKHR {
	clone := (*DisplayPlaneCapabilitiesKHR)(newCBlock(C.ulong(SizeofDisplayPlaneCapabilitiesKHR)))
	*clone = x
	return clone
}

// DisplayPlaneCapabilitiesKHRFreeCSlice releases the memory allocated by DisplayPlaneCapabilitiesKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayPlaneCapabilitiesKHRFreeCSlice(x []DisplayPlaneCapabilitiesKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayPlaneCapabilitiesKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayPlaneCapabilitiesKHRFreeCSlice must be called on the returned slice.
func DisplayPlaneCapabilitiesKHRMakeCSlice(x ...DisplayPlaneCapabilitiesKHR) []DisplayPlaneCapabilitiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPlaneCapabilitiesKHR * len(x)
	dst := unsafe.Slice((*DisplayPlaneCapabilitiesKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SupportedAlpha returns the value of supportedAlpha from VkDisplayPlaneCapabilitiesKHR
func (x DisplayPlaneCapabilitiesKHR) SupportedAlpha() DisplayPlaneAlphaFlagsKHR {
	ptr := /* typedef */ (*DisplayPlaneAlphaFlagsKHR)(&x.supportedAlpha)
	return *ptr
}

// MinSrcPosition returns the value of minSrcPosition from VkDisplayPlaneCapabilitiesKHR
func (x DisplayPlaneCapabilitiesKHR) MinSrcPosition() Offset2D {
	ptr := /* typedef */ (*Offset2D)(&x.minSrcPosition)
	return *ptr
}

// MaxSrcPosition returns the value of maxSrcPosition from VkDisplayPlaneCapabilitiesKHR
func (x DisplayPlaneCapabilitiesKHR) MaxSrcPosition() Offset2D {
	ptr := /* typedef */ (*Offset2D)(&x.maxSrcPosition)
	return *ptr
}

// MinSrcExtent returns the value of minSrcExtent from VkDisplayPlaneCapabilitiesKHR
func (x DisplayPlaneCapabilitiesKHR) MinSrcExtent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.minSrcExtent)
	return *ptr
}

// MaxSrcExtent returns the value of maxSrcExtent from VkDisplayPlaneCapabilitiesKHR
func (x DisplayPlaneCapabilitiesKHR) MaxSrcExtent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.maxSrcExtent)
	return *ptr
}

// MinDstPosition returns the value of minDstPosition from VkDisplayPlaneCapabilitiesKHR
func (x DisplayPlaneCapabilitiesKHR) MinDstPosition() Offset2D {
	ptr := /* typedef */ (*Offset2D)(&x.minDstPosition)
	return *ptr
}

// MaxDstPosition returns the value of maxDstPosition from VkDisplayPlaneCapabilitiesKHR
func (x DisplayPlaneCapabilitiesKHR) MaxDstPosition() Offset2D {
	ptr := /* typedef */ (*Offset2D)(&x.maxDstPosition)
	return *ptr
}

// MinDstExtent returns the value of minDstExtent from VkDisplayPlaneCapabilitiesKHR
func (x DisplayPlaneCapabilitiesKHR) MinDstExtent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.minDstExtent)
	return *ptr
}

// MaxDstExtent returns the value of maxDstExtent from VkDisplayPlaneCapabilitiesKHR
func (x DisplayPlaneCapabilitiesKHR) MaxDstExtent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.maxDstExtent)
	return *ptr
}

//DisplayModeParametersKHR provides a go interface for VkDisplayModeParametersKHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDisplayModeParametersKHR.html
type DisplayModeParametersKHR C.struct_VkDisplayModeParametersKHR

// SizeofDisplayModeParametersKHR is the memory size of a DisplayModeParametersKHR
var SizeofDisplayModeParametersKHR int = int(unsafe.Sizeof(DisplayModeParametersKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayModeParametersKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayModeParametersKHR) AsCPtr() *DisplayModeParametersKHR {
	clone := (*DisplayModeParametersKHR)(newCBlock(C.ulong(SizeofDisplayModeParametersKHR)))
	*clone = x
	return clone
}

// DisplayModeParametersKHRFreeCSlice releases the memory allocated by DisplayModeParametersKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayModeParametersKHRFreeCSlice(x []DisplayModeParametersKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayModeParametersKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayModeParametersKHRFreeCSlice must be called on the returned slice.
func DisplayModeParametersKHRMakeCSlice(x ...DisplayModeParametersKHR) []DisplayModeParametersKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayModeParametersKHR * len(x)
	dst := unsafe.Slice((*DisplayModeParametersKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// VisibleRegion returns the value of visibleRegion from VkDisplayModeParametersKHR
func (x DisplayModeParametersKHR) VisibleRegion() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.visibleRegion)
	return *ptr
}

// WithVisibleRegion sets the value for the VisibleRegion on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayModeParametersKHR) WithVisibleRegion(y Extent2D) DisplayModeParametersKHR {
	ptr := /* typedef */ (*C.struct_VkExtent2D)(&y)
	x.visibleRegion = *ptr
	return x
}

// RefreshRate returns the value of refreshRate from VkDisplayModeParametersKHR
func (x DisplayModeParametersKHR) RefreshRate() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.refreshRate)
	return *ptr
}

// WithRefreshRate sets the value for the RefreshRate on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayModeParametersKHR) WithRefreshRate(y uint32) DisplayModeParametersKHR {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.refreshRate = *ptr
	return x
}

//DisplaySurfaceCreateInfoKHR provides a go interface for VkDisplaySurfaceCreateInfoKHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDisplaySurfaceCreateInfoKHR.html
type DisplaySurfaceCreateInfoKHR C.struct_VkDisplaySurfaceCreateInfoKHR

// SizeofDisplaySurfaceCreateInfoKHR is the memory size of a DisplaySurfaceCreateInfoKHR
var SizeofDisplaySurfaceCreateInfoKHR int = int(unsafe.Sizeof(DisplaySurfaceCreateInfoKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplaySurfaceCreateInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplaySurfaceCreateInfoKHR) AsCPtr() *DisplaySurfaceCreateInfoKHR {
	clone := (*DisplaySurfaceCreateInfoKHR)(newCBlock(C.ulong(SizeofDisplaySurfaceCreateInfoKHR)))
	*clone = x
	return clone
}

// DisplaySurfaceCreateInfoKHRFreeCSlice releases the memory allocated by DisplaySurfaceCreateInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplaySurfaceCreateInfoKHRFreeCSlice(x []DisplaySurfaceCreateInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplaySurfaceCreateInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplaySurfaceCreateInfoKHRFreeCSlice must be called on the returned slice.
func DisplaySurfaceCreateInfoKHRMakeCSlice(x ...DisplaySurfaceCreateInfoKHR) []DisplaySurfaceCreateInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplaySurfaceCreateInfoKHR * len(x)
	dst := unsafe.Slice((*DisplaySurfaceCreateInfoKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DisplaySurfaceCreateInfoKHR) WithDefaultSType() DisplaySurfaceCreateInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithSType(y StructureType) DisplaySurfaceCreateInfoKHR {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithPNext(y unsafe.Pointer) DisplaySurfaceCreateInfoKHR {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Flags returns the value of flags from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) Flags() DisplaySurfaceCreateFlagsKHR {
	ptr := /* typedef */ (*DisplaySurfaceCreateFlagsKHR)(&x.flags)
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithFlags(y DisplaySurfaceCreateFlagsKHR) DisplaySurfaceCreateInfoKHR {
	ptr := /* typedef */ (*C.VkDisplaySurfaceCreateFlagsKHR)(&y)
	x.flags = *ptr
	return x
}

// DisplayMode returns the value of displayMode from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) DisplayMode() DisplayModeKHR {
	ptr := /* handle */ (*DisplayModeKHR)(&x.displayMode)
	return *ptr
}

// WithDisplayMode sets the value for the DisplayMode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithDisplayMode(y DisplayModeKHR) DisplaySurfaceCreateInfoKHR {
	ptr := /* handle */ (*C.VkDisplayModeKHR)(&y)
	x.displayMode = *ptr
	return x
}

// PlaneIndex returns the value of planeIndex from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) PlaneIndex() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.planeIndex)
	return *ptr
}

// WithPlaneIndex sets the value for the PlaneIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithPlaneIndex(y uint32) DisplaySurfaceCreateInfoKHR {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.planeIndex = *ptr
	return x
}

// PlaneStackIndex returns the value of planeStackIndex from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) PlaneStackIndex() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.planeStackIndex)
	return *ptr
}

// WithPlaneStackIndex sets the value for the PlaneStackIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithPlaneStackIndex(y uint32) DisplaySurfaceCreateInfoKHR {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.planeStackIndex = *ptr
	return x
}

// Transform returns the value of transform from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) Transform() SurfaceTransformFlagBitsKHR {
	ptr := /* typedef */ (*SurfaceTransformFlagBitsKHR)(&x.transform)
	return *ptr
}

// WithTransform sets the value for the Transform on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithTransform(y SurfaceTransformFlagBitsKHR) DisplaySurfaceCreateInfoKHR {
	ptr := /* typedef */ (*C.VkSurfaceTransformFlagBitsKHR)(&y)
	x.transform = *ptr
	return x
}

// GlobalAlpha returns the value of globalAlpha from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) GlobalAlpha() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ return (*float32)(unsafe.Pointer(x)) }(&x.globalAlpha)
	return *ptr
}

// WithGlobalAlpha sets the value for the GlobalAlpha on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithGlobalAlpha(y float32) DisplaySurfaceCreateInfoKHR {
	ptr := func(x *float32) *C.float { /* Scalar */ return (*C.float)(unsafe.Pointer(x)) }(&y)
	x.globalAlpha = *ptr
	return x
}

// AlphaMode returns the value of alphaMode from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) AlphaMode() DisplayPlaneAlphaFlagBitsKHR {
	ptr := /* typedef */ (*DisplayPlaneAlphaFlagBitsKHR)(&x.alphaMode)
	return *ptr
}

// WithAlphaMode sets the value for the AlphaMode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithAlphaMode(y DisplayPlaneAlphaFlagBitsKHR) DisplaySurfaceCreateInfoKHR {
	ptr := /* typedef */ (*C.VkDisplayPlaneAlphaFlagBitsKHR)(&y)
	x.alphaMode = *ptr
	return x
}

// ImageExtent returns the value of imageExtent from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) ImageExtent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.imageExtent)
	return *ptr
}

// WithImageExtent sets the value for the ImageExtent on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithImageExtent(y Extent2D) DisplaySurfaceCreateInfoKHR {
	ptr := /* typedef */ (*C.struct_VkExtent2D)(&y)
	x.imageExtent = *ptr
	return x
}

func (x InstanceFacade) CreateDisplayPlaneSurfaceKHR(pCreateInfo *DisplaySurfaceCreateInfoKHR, pAllocator *AllocationCallbacks, pSurface *SurfaceKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkInstance)(&x.H)
	p1 := func(x **DisplaySurfaceCreateInfoKHR) **C.struct_VkDisplaySurfaceCreateInfoKHR { /* Pointer */
		return (**C.struct_VkDisplaySurfaceCreateInfoKHR)(unsafe.Pointer(x))
	}(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p3 := func(x **SurfaceKHR) **C.VkSurfaceKHR { /* Pointer */ return (**C.VkSurfaceKHR)(unsafe.Pointer(x)) }(&pSurface)
	ret := C.vkCreateDisplayPlaneSurfaceKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x PhysicalDeviceFacade) GetDisplayPlaneCapabilitiesKHR(mode DisplayModeKHR, planeIndex uint32, pCapabilities *DisplayPlaneCapabilitiesKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* handle */ (*C.VkDisplayModeKHR)(&mode)
	p2 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&planeIndex)
	p3 := func(x **DisplayPlaneCapabilitiesKHR) **C.struct_VkDisplayPlaneCapabilitiesKHR { /* Pointer */
		return (**C.struct_VkDisplayPlaneCapabilitiesKHR)(unsafe.Pointer(x))
	}(&pCapabilities)
	ret := C.vkGetDisplayPlaneCapabilitiesKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x PhysicalDeviceFacade) CreateDisplayModeKHR(display DisplayKHR, pCreateInfo *DisplayModeCreateInfoKHR, pAllocator *AllocationCallbacks, pMode *DisplayModeKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* handle */ (*C.VkDisplayKHR)(&display)
	p2 := func(x **DisplayModeCreateInfoKHR) **C.struct_VkDisplayModeCreateInfoKHR { /* Pointer */
		return (**C.struct_VkDisplayModeCreateInfoKHR)(unsafe.Pointer(x))
	}(&pCreateInfo)
	p3 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p4 := func(x **DisplayModeKHR) **C.VkDisplayModeKHR { /* Pointer */
		return (**C.VkDisplayModeKHR)(unsafe.Pointer(x))
	}(&pMode)
	ret := C.vkCreateDisplayModeKHR(addrs, *p0, *p1, *p2, *p3, *p4)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x PhysicalDeviceFacade) GetDisplayModePropertiesKHR(display DisplayKHR, pPropertyCount *uint32, pProperties []DisplayModePropertiesKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* handle */ (*C.VkDisplayKHR)(&display)
	p2 := func(x **uint32) **C.uint { /* Pointer */ return (**C.uint)(unsafe.Pointer(x)) }(&pPropertyCount)
	p3 := func(x *[]DisplayModePropertiesKHR) **C.struct_VkDisplayModePropertiesKHR { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDisplayModePropertiesKHR)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDisplayModePropertiesKHR)(unsafe.Pointer((&ptr)))
	}(&pProperties)
	ret := C.vkGetDisplayModePropertiesKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x PhysicalDeviceFacade) GetDisplayPlaneSupportedDisplaysKHR(planeIndex uint32, pDisplayCount *uint32, pDisplays []DisplayKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&planeIndex)
	p2 := func(x **uint32) **C.uint { /* Pointer */ return (**C.uint)(unsafe.Pointer(x)) }(&pDisplayCount)
	p3 := func(x *[]DisplayKHR) **C.VkDisplayKHR { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkDisplayKHR)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkDisplayKHR)(unsafe.Pointer((&ptr)))
	}(&pDisplays)
	ret := C.vkGetDisplayPlaneSupportedDisplaysKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x PhysicalDeviceFacade) GetPhysicalDeviceDisplayPlanePropertiesKHR(pPropertyCount *uint32, pProperties []DisplayPlanePropertiesKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **uint32) **C.uint { /* Pointer */ return (**C.uint)(unsafe.Pointer(x)) }(&pPropertyCount)
	p2 := func(x *[]DisplayPlanePropertiesKHR) **C.struct_VkDisplayPlanePropertiesKHR { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDisplayPlanePropertiesKHR)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDisplayPlanePropertiesKHR)(unsafe.Pointer((&ptr)))
	}(&pProperties)
	ret := C.vkGetPhysicalDeviceDisplayPlanePropertiesKHR(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x PhysicalDeviceFacade) GetPhysicalDeviceDisplayPropertiesKHR(pPropertyCount *uint32, pProperties []DisplayPropertiesKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **uint32) **C.uint { /* Pointer */ return (**C.uint)(unsafe.Pointer(x)) }(&pPropertyCount)
	p2 := func(x *[]DisplayPropertiesKHR) **C.struct_VkDisplayPropertiesKHR { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDisplayPropertiesKHR)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDisplayPropertiesKHR)(unsafe.Pointer((&ptr)))
	}(&pProperties)
	ret := C.vkGetPhysicalDeviceDisplayPropertiesKHR(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

//DisplayModeProperties2KHR provides a go interface for VkDisplayModeProperties2KHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDisplayModeProperties2KHR.html
type DisplayModeProperties2KHR C.struct_VkDisplayModeProperties2KHR

// SizeofDisplayModeProperties2KHR is the memory size of a DisplayModeProperties2KHR
var SizeofDisplayModeProperties2KHR int = int(unsafe.Sizeof(DisplayModeProperties2KHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayModeProperties2KHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayModeProperties2KHR) AsCPtr() *DisplayModeProperties2KHR {
	clone := (*DisplayModeProperties2KHR)(newCBlock(C.ulong(SizeofDisplayModeProperties2KHR)))
	*clone = x
	return clone
}

// DisplayModeProperties2KHRFreeCSlice releases the memory allocated by DisplayModeProperties2KHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayModeProperties2KHRFreeCSlice(x []DisplayModeProperties2KHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayModeProperties2KHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayModeProperties2KHRFreeCSlice must be called on the returned slice.
func DisplayModeProperties2KHRMakeCSlice(x ...DisplayModeProperties2KHR) []DisplayModeProperties2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayModeProperties2KHR * len(x)
	dst := unsafe.Slice((*DisplayModeProperties2KHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDisplayModeProperties2KHR
func (x DisplayModeProperties2KHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DisplayModeProperties2KHR) WithDefaultSType() DisplayModeProperties2KHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayModeProperties2KHR) WithSType(y StructureType) DisplayModeProperties2KHR {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDisplayModeProperties2KHR
func (x DisplayModeProperties2KHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayModeProperties2KHR) WithPNext(y unsafe.Pointer) DisplayModeProperties2KHR {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// DisplayModeProperties returns the value of displayModeProperties from VkDisplayModeProperties2KHR
func (x DisplayModeProperties2KHR) DisplayModeProperties() DisplayModePropertiesKHR {
	ptr := /* typedef */ (*DisplayModePropertiesKHR)(&x.displayModeProperties)
	return *ptr
}

//DisplayPlaneInfo2KHR provides a go interface for VkDisplayPlaneInfo2KHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDisplayPlaneInfo2KHR.html
type DisplayPlaneInfo2KHR C.struct_VkDisplayPlaneInfo2KHR

// SizeofDisplayPlaneInfo2KHR is the memory size of a DisplayPlaneInfo2KHR
var SizeofDisplayPlaneInfo2KHR int = int(unsafe.Sizeof(DisplayPlaneInfo2KHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayPlaneInfo2KHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayPlaneInfo2KHR) AsCPtr() *DisplayPlaneInfo2KHR {
	clone := (*DisplayPlaneInfo2KHR)(newCBlock(C.ulong(SizeofDisplayPlaneInfo2KHR)))
	*clone = x
	return clone
}

// DisplayPlaneInfo2KHRFreeCSlice releases the memory allocated by DisplayPlaneInfo2KHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayPlaneInfo2KHRFreeCSlice(x []DisplayPlaneInfo2KHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayPlaneInfo2KHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayPlaneInfo2KHRFreeCSlice must be called on the returned slice.
func DisplayPlaneInfo2KHRMakeCSlice(x ...DisplayPlaneInfo2KHR) []DisplayPlaneInfo2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPlaneInfo2KHR * len(x)
	dst := unsafe.Slice((*DisplayPlaneInfo2KHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDisplayPlaneInfo2KHR
func (x DisplayPlaneInfo2KHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DisplayPlaneInfo2KHR) WithDefaultSType() DisplayPlaneInfo2KHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPlaneInfo2KHR) WithSType(y StructureType) DisplayPlaneInfo2KHR {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDisplayPlaneInfo2KHR
func (x DisplayPlaneInfo2KHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPlaneInfo2KHR) WithPNext(y unsafe.Pointer) DisplayPlaneInfo2KHR {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Mode returns the value of mode from VkDisplayPlaneInfo2KHR
func (x DisplayPlaneInfo2KHR) Mode() DisplayModeKHR {
	ptr := /* handle */ (*DisplayModeKHR)(&x.mode)
	return *ptr
}

// WithMode sets the value for the Mode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPlaneInfo2KHR) WithMode(y DisplayModeKHR) DisplayPlaneInfo2KHR {
	ptr := /* handle */ (*C.VkDisplayModeKHR)(&y)
	x.mode = *ptr
	return x
}

// PlaneIndex returns the value of planeIndex from VkDisplayPlaneInfo2KHR
func (x DisplayPlaneInfo2KHR) PlaneIndex() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.planeIndex)
	return *ptr
}

// WithPlaneIndex sets the value for the PlaneIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPlaneInfo2KHR) WithPlaneIndex(y uint32) DisplayPlaneInfo2KHR {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.planeIndex = *ptr
	return x
}

//DisplayPlaneCapabilities2KHR provides a go interface for VkDisplayPlaneCapabilities2KHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDisplayPlaneCapabilities2KHR.html
type DisplayPlaneCapabilities2KHR C.struct_VkDisplayPlaneCapabilities2KHR

// SizeofDisplayPlaneCapabilities2KHR is the memory size of a DisplayPlaneCapabilities2KHR
var SizeofDisplayPlaneCapabilities2KHR int = int(unsafe.Sizeof(DisplayPlaneCapabilities2KHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayPlaneCapabilities2KHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayPlaneCapabilities2KHR) AsCPtr() *DisplayPlaneCapabilities2KHR {
	clone := (*DisplayPlaneCapabilities2KHR)(newCBlock(C.ulong(SizeofDisplayPlaneCapabilities2KHR)))
	*clone = x
	return clone
}

// DisplayPlaneCapabilities2KHRFreeCSlice releases the memory allocated by DisplayPlaneCapabilities2KHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayPlaneCapabilities2KHRFreeCSlice(x []DisplayPlaneCapabilities2KHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayPlaneCapabilities2KHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayPlaneCapabilities2KHRFreeCSlice must be called on the returned slice.
func DisplayPlaneCapabilities2KHRMakeCSlice(x ...DisplayPlaneCapabilities2KHR) []DisplayPlaneCapabilities2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPlaneCapabilities2KHR * len(x)
	dst := unsafe.Slice((*DisplayPlaneCapabilities2KHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDisplayPlaneCapabilities2KHR
func (x DisplayPlaneCapabilities2KHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DisplayPlaneCapabilities2KHR) WithDefaultSType() DisplayPlaneCapabilities2KHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPlaneCapabilities2KHR) WithSType(y StructureType) DisplayPlaneCapabilities2KHR {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDisplayPlaneCapabilities2KHR
func (x DisplayPlaneCapabilities2KHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPlaneCapabilities2KHR) WithPNext(y unsafe.Pointer) DisplayPlaneCapabilities2KHR {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// Capabilities returns the value of capabilities from VkDisplayPlaneCapabilities2KHR
func (x DisplayPlaneCapabilities2KHR) Capabilities() DisplayPlaneCapabilitiesKHR {
	ptr := /* typedef */ (*DisplayPlaneCapabilitiesKHR)(&x.capabilities)
	return *ptr
}

//DisplayProperties2KHR provides a go interface for VkDisplayProperties2KHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDisplayProperties2KHR.html
type DisplayProperties2KHR C.struct_VkDisplayProperties2KHR

// SizeofDisplayProperties2KHR is the memory size of a DisplayProperties2KHR
var SizeofDisplayProperties2KHR int = int(unsafe.Sizeof(DisplayProperties2KHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayProperties2KHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayProperties2KHR) AsCPtr() *DisplayProperties2KHR {
	clone := (*DisplayProperties2KHR)(newCBlock(C.ulong(SizeofDisplayProperties2KHR)))
	*clone = x
	return clone
}

// DisplayProperties2KHRFreeCSlice releases the memory allocated by DisplayProperties2KHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayProperties2KHRFreeCSlice(x []DisplayProperties2KHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayProperties2KHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayProperties2KHRFreeCSlice must be called on the returned slice.
func DisplayProperties2KHRMakeCSlice(x ...DisplayProperties2KHR) []DisplayProperties2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayProperties2KHR * len(x)
	dst := unsafe.Slice((*DisplayProperties2KHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDisplayProperties2KHR
func (x DisplayProperties2KHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DisplayProperties2KHR) WithDefaultSType() DisplayProperties2KHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayProperties2KHR) WithSType(y StructureType) DisplayProperties2KHR {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDisplayProperties2KHR
func (x DisplayProperties2KHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayProperties2KHR) WithPNext(y unsafe.Pointer) DisplayProperties2KHR {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// DisplayProperties returns the value of displayProperties from VkDisplayProperties2KHR
func (x DisplayProperties2KHR) DisplayProperties() DisplayPropertiesKHR {
	ptr := /* typedef */ (*DisplayPropertiesKHR)(&x.displayProperties)
	return *ptr
}

//DisplayPlaneProperties2KHR provides a go interface for VkDisplayPlaneProperties2KHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDisplayPlaneProperties2KHR.html
type DisplayPlaneProperties2KHR C.struct_VkDisplayPlaneProperties2KHR

// SizeofDisplayPlaneProperties2KHR is the memory size of a DisplayPlaneProperties2KHR
var SizeofDisplayPlaneProperties2KHR int = int(unsafe.Sizeof(DisplayPlaneProperties2KHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayPlaneProperties2KHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayPlaneProperties2KHR) AsCPtr() *DisplayPlaneProperties2KHR {
	clone := (*DisplayPlaneProperties2KHR)(newCBlock(C.ulong(SizeofDisplayPlaneProperties2KHR)))
	*clone = x
	return clone
}

// DisplayPlaneProperties2KHRFreeCSlice releases the memory allocated by DisplayPlaneProperties2KHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayPlaneProperties2KHRFreeCSlice(x []DisplayPlaneProperties2KHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayPlaneProperties2KHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayPlaneProperties2KHRFreeCSlice must be called on the returned slice.
func DisplayPlaneProperties2KHRMakeCSlice(x ...DisplayPlaneProperties2KHR) []DisplayPlaneProperties2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPlaneProperties2KHR * len(x)
	dst := unsafe.Slice((*DisplayPlaneProperties2KHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDisplayPlaneProperties2KHR
func (x DisplayPlaneProperties2KHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DisplayPlaneProperties2KHR) WithDefaultSType() DisplayPlaneProperties2KHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPlaneProperties2KHR) WithSType(y StructureType) DisplayPlaneProperties2KHR {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDisplayPlaneProperties2KHR
func (x DisplayPlaneProperties2KHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPlaneProperties2KHR) WithPNext(y unsafe.Pointer) DisplayPlaneProperties2KHR {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// DisplayPlaneProperties returns the value of displayPlaneProperties from VkDisplayPlaneProperties2KHR
func (x DisplayPlaneProperties2KHR) DisplayPlaneProperties() DisplayPlanePropertiesKHR {
	ptr := /* typedef */ (*DisplayPlanePropertiesKHR)(&x.displayPlaneProperties)
	return *ptr
}

func (x PhysicalDeviceFacade) GetDisplayPlaneCapabilities2KHR(pDisplayPlaneInfo *DisplayPlaneInfo2KHR, pCapabilities *DisplayPlaneCapabilities2KHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **DisplayPlaneInfo2KHR) **C.struct_VkDisplayPlaneInfo2KHR { /* Pointer */
		return (**C.struct_VkDisplayPlaneInfo2KHR)(unsafe.Pointer(x))
	}(&pDisplayPlaneInfo)
	p2 := func(x **DisplayPlaneCapabilities2KHR) **C.struct_VkDisplayPlaneCapabilities2KHR { /* Pointer */
		return (**C.struct_VkDisplayPlaneCapabilities2KHR)(unsafe.Pointer(x))
	}(&pCapabilities)
	ret := C.vkGetDisplayPlaneCapabilities2KHR(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x PhysicalDeviceFacade) GetPhysicalDeviceDisplayProperties2KHR(pPropertyCount *uint32, pProperties []DisplayProperties2KHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **uint32) **C.uint { /* Pointer */ return (**C.uint)(unsafe.Pointer(x)) }(&pPropertyCount)
	p2 := func(x *[]DisplayProperties2KHR) **C.struct_VkDisplayProperties2KHR { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDisplayProperties2KHR)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDisplayProperties2KHR)(unsafe.Pointer((&ptr)))
	}(&pProperties)
	ret := C.vkGetPhysicalDeviceDisplayProperties2KHR(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x PhysicalDeviceFacade) GetPhysicalDeviceDisplayPlaneProperties2KHR(pPropertyCount *uint32, pProperties []DisplayPlaneProperties2KHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **uint32) **C.uint { /* Pointer */ return (**C.uint)(unsafe.Pointer(x)) }(&pPropertyCount)
	p2 := func(x *[]DisplayPlaneProperties2KHR) **C.struct_VkDisplayPlaneProperties2KHR { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDisplayPlaneProperties2KHR)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDisplayPlaneProperties2KHR)(unsafe.Pointer((&ptr)))
	}(&pProperties)
	ret := C.vkGetPhysicalDeviceDisplayPlaneProperties2KHR(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

func (x PhysicalDeviceFacade) GetDisplayModeProperties2KHR(display DisplayKHR, pPropertyCount *uint32, pProperties []DisplayModeProperties2KHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* handle */ (*C.VkDisplayKHR)(&display)
	p2 := func(x **uint32) **C.uint { /* Pointer */ return (**C.uint)(unsafe.Pointer(x)) }(&pPropertyCount)
	p3 := func(x *[]DisplayModeProperties2KHR) **C.struct_VkDisplayModeProperties2KHR { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkDisplayModeProperties2KHR)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkDisplayModeProperties2KHR)(unsafe.Pointer((&ptr)))
	}(&pProperties)
	ret := C.vkGetDisplayModeProperties2KHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

//DisplayPresentInfoKHR provides a go interface for VkDisplayPresentInfoKHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDisplayPresentInfoKHR.html
type DisplayPresentInfoKHR C.struct_VkDisplayPresentInfoKHR

// SizeofDisplayPresentInfoKHR is the memory size of a DisplayPresentInfoKHR
var SizeofDisplayPresentInfoKHR int = int(unsafe.Sizeof(DisplayPresentInfoKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayPresentInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayPresentInfoKHR) AsCPtr() *DisplayPresentInfoKHR {
	clone := (*DisplayPresentInfoKHR)(newCBlock(C.ulong(SizeofDisplayPresentInfoKHR)))
	*clone = x
	return clone
}

// DisplayPresentInfoKHRFreeCSlice releases the memory allocated by DisplayPresentInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayPresentInfoKHRFreeCSlice(x []DisplayPresentInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayPresentInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayPresentInfoKHRFreeCSlice must be called on the returned slice.
func DisplayPresentInfoKHRMakeCSlice(x ...DisplayPresentInfoKHR) []DisplayPresentInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPresentInfoKHR * len(x)
	dst := unsafe.Slice((*DisplayPresentInfoKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDisplayPresentInfoKHR
func (x DisplayPresentInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DisplayPresentInfoKHR) WithDefaultSType() DisplayPresentInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPresentInfoKHR) WithSType(y StructureType) DisplayPresentInfoKHR {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkDisplayPresentInfoKHR
func (x DisplayPresentInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPresentInfoKHR) WithPNext(y unsafe.Pointer) DisplayPresentInfoKHR {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// SrcRect returns the value of srcRect from VkDisplayPresentInfoKHR
func (x DisplayPresentInfoKHR) SrcRect() Rect2D {
	ptr := /* typedef */ (*Rect2D)(&x.srcRect)
	return *ptr
}

// WithSrcRect sets the value for the SrcRect on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPresentInfoKHR) WithSrcRect(y Rect2D) DisplayPresentInfoKHR {
	ptr := /* typedef */ (*C.struct_VkRect2D)(&y)
	x.srcRect = *ptr
	return x
}

// DstRect returns the value of dstRect from VkDisplayPresentInfoKHR
func (x DisplayPresentInfoKHR) DstRect() Rect2D {
	ptr := /* typedef */ (*Rect2D)(&x.dstRect)
	return *ptr
}

// WithDstRect sets the value for the DstRect on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPresentInfoKHR) WithDstRect(y Rect2D) DisplayPresentInfoKHR {
	ptr := /* typedef */ (*C.struct_VkRect2D)(&y)
	x.dstRect = *ptr
	return x
}

// Persistent returns the value of persistent from VkDisplayPresentInfoKHR
func (x DisplayPresentInfoKHR) Persistent() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.persistent)
	return *ptr
}

// WithPersistent sets the value for the Persistent on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPresentInfoKHR) WithPersistent(y Bool32) DisplayPresentInfoKHR {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.persistent = *ptr
	return x
}

func (x DeviceFacade) CreateSharedSwapchainsKHR(swapchainCount uint32, pCreateInfos []SwapchainCreateInfoKHR, pAllocator *AllocationCallbacks, pSwapchains []SwapchainKHR) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&swapchainCount)
	p2 := func(x *[]SwapchainCreateInfoKHR) **C.struct_VkSwapchainCreateInfoKHR { /* Slice */
		if len(*x) > 0 {
			slc := (*C.struct_VkSwapchainCreateInfoKHR)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.struct_VkSwapchainCreateInfoKHR)(unsafe.Pointer((&ptr)))
	}(&pCreateInfos)
	p3 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */
		return (**C.struct_VkAllocationCallbacks)(unsafe.Pointer(x))
	}(&pAllocator)
	p4 := func(x *[]SwapchainKHR) **C.VkSwapchainKHR { /* Slice */
		if len(*x) > 0 {
			slc := (*C.VkSwapchainKHR)(unsafe.Pointer(&((*x)[0])))
			return &slc
		}
		var ptr unsafe.Pointer
		return (**C.VkSwapchainKHR)(unsafe.Pointer((&ptr)))
	}(&pSwapchains)
	ret := C.vkCreateSharedSwapchainsKHR(addrs, *p0, *p1, *p2, *p3, *p4)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// FormatFeatureFlagBits2KHR is an Enum from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFormatFeatureFlagBits2KHR.html
type FormatFeatureFlagBits2KHR uint64

const (
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR                                                           FormatFeatureFlagBits2KHR = (1 << 0)
	VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR                                                           FormatFeatureFlagBits2KHR = (1 << 1)
	VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR                                                    FormatFeatureFlagBits2KHR = (1 << 2)
	VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR                                                    FormatFeatureFlagBits2KHR = (1 << 3)
	VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR                                                    FormatFeatureFlagBits2KHR = (1 << 4)
	VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR                                             FormatFeatureFlagBits2KHR = (1 << 5)
	VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR                                                           FormatFeatureFlagBits2KHR = (1 << 6)
	VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR                                                        FormatFeatureFlagBits2KHR = (1 << 7)
	VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR                                                  FormatFeatureFlagBits2KHR = (1 << 8)
	VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR                                                FormatFeatureFlagBits2KHR = (1 << 9)
	VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR                                                                FormatFeatureFlagBits2KHR = (1 << 10)
	VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR                                                                FormatFeatureFlagBits2KHR = (1 << 11)
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR                                             FormatFeatureFlagBits2KHR = (1 << 12)
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT                                              FormatFeatureFlagBits2KHR = (1 << 13)
	VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR                                                            FormatFeatureFlagBits2KHR = (1 << 14)
	VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR                                                            FormatFeatureFlagBits2KHR = (1 << 15)
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR                                             FormatFeatureFlagBits2KHR = (1 << 16)
	VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR                                                 FormatFeatureFlagBits2KHR = (1 << 17)
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR                            FormatFeatureFlagBits2KHR = (1 << 18)
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR           FormatFeatureFlagBits2KHR = (1 << 19)
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR           FormatFeatureFlagBits2KHR = (1 << 20)
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR FormatFeatureFlagBits2KHR = (1 << 21)
	VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR                                                                FormatFeatureFlagBits2KHR = (1 << 22)
	VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR                                                  FormatFeatureFlagBits2KHR = (1 << 23)
	VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR                                             FormatFeatureFlagBits2KHR = (1 << 31)
	VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR                                            FormatFeatureFlagBits2KHR = (1 << 32)
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR                                          FormatFeatureFlagBits2KHR = (1 << 33)
)

var (
	reverseFormatFeatureFlagBits2KHR map[FormatFeatureFlagBits2KHR]string = map[FormatFeatureFlagBits2KHR]string{
		VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR:                                                           "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR",
		VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR:                                                           "VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR",
		VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR:                                                    "VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR",
		VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR:                                                    "VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR",
		VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR:                                                    "VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR",
		VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR:                                             "VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR",
		VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR:                                                           "VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR",
		VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR:                                                        "VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR",
		VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR:                                                  "VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR",
		VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR:                                                "VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR",
		VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR:                                                                "VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR",
		VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR:                                                                "VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR",
		VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR:                                             "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR",
		VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT:                                              "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT",
		VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR:                                                            "VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR",
		VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR:                                                            "VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR",
		VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR:                                             "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR",
		VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR:                                                 "VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR",
		VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR:                            "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR",
		VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR:           "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR",
		VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR:           "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR",
		VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR: "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR",
		VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR:                                                                "VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR",
		VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR:                                                  "VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR",
		VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR:                                             "VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR",
		VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR:                                            "VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR",
		VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR:                                          "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR",
	}
)

func (x FormatFeatureFlagBits2KHR) String() string {
	if s, ok := reverseFormatFeatureFlagBits2KHR[x]; ok {
		return s
	}
	return fmt.Sprintf("FormatFeatureFlagBits2KHR=%d", x)
}

// Flags64 is a base type in the vulkan specification.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFlags64.html
type Flags64 uint64

// FormatFeatureFlags2KHR is a bitmask from the Vulkan API.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFormatFeatureFlags2KHR.html
type FormatFeatureFlags2KHR Flags64

//FormatProperties3KHR provides a go interface for VkFormatProperties3KHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFormatProperties3KHR.html
type FormatProperties3KHR C.struct_VkFormatProperties3KHR

// SizeofFormatProperties3KHR is the memory size of a FormatProperties3KHR
var SizeofFormatProperties3KHR int = int(unsafe.Sizeof(FormatProperties3KHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *FormatProperties3KHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x FormatProperties3KHR) AsCPtr() *FormatProperties3KHR {
	clone := (*FormatProperties3KHR)(newCBlock(C.ulong(SizeofFormatProperties3KHR)))
	*clone = x
	return clone
}

// FormatProperties3KHRFreeCSlice releases the memory allocated by FormatProperties3KHRMakeCSlice.
// It does not free pointers stored inside the slice.
func FormatProperties3KHRFreeCSlice(x []FormatProperties3KHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// FormatProperties3KHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. FormatProperties3KHRFreeCSlice must be called on the returned slice.
func FormatProperties3KHRMakeCSlice(x ...FormatProperties3KHR) []FormatProperties3KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFormatProperties3KHR * len(x)
	dst := unsafe.Slice((*FormatProperties3KHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkFormatProperties3KHR
func (x FormatProperties3KHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x FormatProperties3KHR) WithDefaultSType() FormatProperties3KHR {
	return x.WithSType(VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FormatProperties3KHR) WithSType(y StructureType) FormatProperties3KHR {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkFormatProperties3KHR
func (x FormatProperties3KHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FormatProperties3KHR) WithPNext(y unsafe.Pointer) FormatProperties3KHR {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// LinearTilingFeatures returns the value of linearTilingFeatures from VkFormatProperties3KHR
func (x FormatProperties3KHR) LinearTilingFeatures() FormatFeatureFlags2KHR {
	ptr := /* typedef */ (*FormatFeatureFlags2KHR)(&x.linearTilingFeatures)
	return *ptr
}

// OptimalTilingFeatures returns the value of optimalTilingFeatures from VkFormatProperties3KHR
func (x FormatProperties3KHR) OptimalTilingFeatures() FormatFeatureFlags2KHR {
	ptr := /* typedef */ (*FormatFeatureFlags2KHR)(&x.optimalTilingFeatures)
	return *ptr
}

// BufferFeatures returns the value of bufferFeatures from VkFormatProperties3KHR
func (x FormatProperties3KHR) BufferFeatures() FormatFeatureFlags2KHR {
	ptr := /* typedef */ (*FormatFeatureFlags2KHR)(&x.bufferFeatures)
	return *ptr
}

//PhysicalDevicePortabilitySubsetFeaturesKHR provides a go interface for VkPhysicalDevicePortabilitySubsetFeaturesKHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html
type PhysicalDevicePortabilitySubsetFeaturesKHR C.struct_VkPhysicalDevicePortabilitySubsetFeaturesKHR

// SizeofPhysicalDevicePortabilitySubsetFeaturesKHR is the memory size of a PhysicalDevicePortabilitySubsetFeaturesKHR
var SizeofPhysicalDevicePortabilitySubsetFeaturesKHR int = int(unsafe.Sizeof(PhysicalDevicePortabilitySubsetFeaturesKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDevicePortabilitySubsetFeaturesKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) AsCPtr() *PhysicalDevicePortabilitySubsetFeaturesKHR {
	clone := (*PhysicalDevicePortabilitySubsetFeaturesKHR)(newCBlock(C.ulong(SizeofPhysicalDevicePortabilitySubsetFeaturesKHR)))
	*clone = x
	return clone
}

// PhysicalDevicePortabilitySubsetFeaturesKHRFreeCSlice releases the memory allocated by PhysicalDevicePortabilitySubsetFeaturesKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDevicePortabilitySubsetFeaturesKHRFreeCSlice(x []PhysicalDevicePortabilitySubsetFeaturesKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDevicePortabilitySubsetFeaturesKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDevicePortabilitySubsetFeaturesKHRFreeCSlice must be called on the returned slice.
func PhysicalDevicePortabilitySubsetFeaturesKHRMakeCSlice(x ...PhysicalDevicePortabilitySubsetFeaturesKHR) []PhysicalDevicePortabilitySubsetFeaturesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDevicePortabilitySubsetFeaturesKHR * len(x)
	dst := unsafe.Slice((*PhysicalDevicePortabilitySubsetFeaturesKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithDefaultSType() PhysicalDevicePortabilitySubsetFeaturesKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithSType(y StructureType) PhysicalDevicePortabilitySubsetFeaturesKHR {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithPNext(y unsafe.Pointer) PhysicalDevicePortabilitySubsetFeaturesKHR {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// ConstantAlphaColorBlendFactors returns the value of constantAlphaColorBlendFactors from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) ConstantAlphaColorBlendFactors() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.constantAlphaColorBlendFactors)
	return *ptr
}

// WithConstantAlphaColorBlendFactors sets the value for the ConstantAlphaColorBlendFactors on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithConstantAlphaColorBlendFactors(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.constantAlphaColorBlendFactors = *ptr
	return x
}

// Events returns the value of events from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) Events() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.events)
	return *ptr
}

// WithEvents sets the value for the Events on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithEvents(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.events = *ptr
	return x
}

// ImageViewFormatReinterpretation returns the value of imageViewFormatReinterpretation from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) ImageViewFormatReinterpretation() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.imageViewFormatReinterpretation)
	return *ptr
}

// WithImageViewFormatReinterpretation sets the value for the ImageViewFormatReinterpretation on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithImageViewFormatReinterpretation(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.imageViewFormatReinterpretation = *ptr
	return x
}

// ImageViewFormatSwizzle returns the value of imageViewFormatSwizzle from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) ImageViewFormatSwizzle() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.imageViewFormatSwizzle)
	return *ptr
}

// WithImageViewFormatSwizzle sets the value for the ImageViewFormatSwizzle on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithImageViewFormatSwizzle(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.imageViewFormatSwizzle = *ptr
	return x
}

// ImageView2DOn3DImage returns the value of imageView2DOn3DImage from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) ImageView2DOn3DImage() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.imageView2DOn3DImage)
	return *ptr
}

// WithImageView2DOn3DImage sets the value for the ImageView2DOn3DImage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithImageView2DOn3DImage(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.imageView2DOn3DImage = *ptr
	return x
}

// MultisampleArrayImage returns the value of multisampleArrayImage from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) MultisampleArrayImage() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.multisampleArrayImage)
	return *ptr
}

// WithMultisampleArrayImage sets the value for the MultisampleArrayImage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithMultisampleArrayImage(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.multisampleArrayImage = *ptr
	return x
}

// MutableComparisonSamplers returns the value of mutableComparisonSamplers from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) MutableComparisonSamplers() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.mutableComparisonSamplers)
	return *ptr
}

// WithMutableComparisonSamplers sets the value for the MutableComparisonSamplers on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithMutableComparisonSamplers(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.mutableComparisonSamplers = *ptr
	return x
}

// PointPolygons returns the value of pointPolygons from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) PointPolygons() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.pointPolygons)
	return *ptr
}

// WithPointPolygons sets the value for the PointPolygons on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithPointPolygons(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.pointPolygons = *ptr
	return x
}

// SamplerMipLodBias returns the value of samplerMipLodBias from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) SamplerMipLodBias() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.samplerMipLodBias)
	return *ptr
}

// WithSamplerMipLodBias sets the value for the SamplerMipLodBias on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithSamplerMipLodBias(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.samplerMipLodBias = *ptr
	return x
}

// SeparateStencilMaskRef returns the value of separateStencilMaskRef from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) SeparateStencilMaskRef() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.separateStencilMaskRef)
	return *ptr
}

// WithSeparateStencilMaskRef sets the value for the SeparateStencilMaskRef on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithSeparateStencilMaskRef(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.separateStencilMaskRef = *ptr
	return x
}

// ShaderSampleRateInterpolationFunctions returns the value of shaderSampleRateInterpolationFunctions from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) ShaderSampleRateInterpolationFunctions() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSampleRateInterpolationFunctions)
	return *ptr
}

// WithShaderSampleRateInterpolationFunctions sets the value for the ShaderSampleRateInterpolationFunctions on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithShaderSampleRateInterpolationFunctions(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.shaderSampleRateInterpolationFunctions = *ptr
	return x
}

// TessellationIsolines returns the value of tessellationIsolines from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) TessellationIsolines() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.tessellationIsolines)
	return *ptr
}

// WithTessellationIsolines sets the value for the TessellationIsolines on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithTessellationIsolines(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.tessellationIsolines = *ptr
	return x
}

// TessellationPointMode returns the value of tessellationPointMode from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) TessellationPointMode() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.tessellationPointMode)
	return *ptr
}

// WithTessellationPointMode sets the value for the TessellationPointMode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithTessellationPointMode(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.tessellationPointMode = *ptr
	return x
}

// TriangleFans returns the value of triangleFans from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) TriangleFans() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.triangleFans)
	return *ptr
}

// WithTriangleFans sets the value for the TriangleFans on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithTriangleFans(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.triangleFans = *ptr
	return x
}

// VertexAttributeAccessBeyondStride returns the value of vertexAttributeAccessBeyondStride from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) VertexAttributeAccessBeyondStride() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.vertexAttributeAccessBeyondStride)
	return *ptr
}

// WithVertexAttributeAccessBeyondStride sets the value for the VertexAttributeAccessBeyondStride on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithVertexAttributeAccessBeyondStride(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	ptr := /* typedef */ (*C.VkBool32)(&y)
	x.vertexAttributeAccessBeyondStride = *ptr
	return x
}

//PhysicalDevicePortabilitySubsetPropertiesKHR provides a go interface for VkPhysicalDevicePortabilitySubsetPropertiesKHR.
// See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePortabilitySubsetPropertiesKHR.html
type PhysicalDevicePortabilitySubsetPropertiesKHR C.struct_VkPhysicalDevicePortabilitySubsetPropertiesKHR

// SizeofPhysicalDevicePortabilitySubsetPropertiesKHR is the memory size of a PhysicalDevicePortabilitySubsetPropertiesKHR
var SizeofPhysicalDevicePortabilitySubsetPropertiesKHR int = int(unsafe.Sizeof(PhysicalDevicePortabilitySubsetPropertiesKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDevicePortabilitySubsetPropertiesKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDevicePortabilitySubsetPropertiesKHR) AsCPtr() *PhysicalDevicePortabilitySubsetPropertiesKHR {
	clone := (*PhysicalDevicePortabilitySubsetPropertiesKHR)(newCBlock(C.ulong(SizeofPhysicalDevicePortabilitySubsetPropertiesKHR)))
	*clone = x
	return clone
}

// PhysicalDevicePortabilitySubsetPropertiesKHRFreeCSlice releases the memory allocated by PhysicalDevicePortabilitySubsetPropertiesKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDevicePortabilitySubsetPropertiesKHRFreeCSlice(x []PhysicalDevicePortabilitySubsetPropertiesKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDevicePortabilitySubsetPropertiesKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDevicePortabilitySubsetPropertiesKHRFreeCSlice must be called on the returned slice.
func PhysicalDevicePortabilitySubsetPropertiesKHRMakeCSlice(x ...PhysicalDevicePortabilitySubsetPropertiesKHR) []PhysicalDevicePortabilitySubsetPropertiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDevicePortabilitySubsetPropertiesKHR * len(x)
	dst := unsafe.Slice((*PhysicalDevicePortabilitySubsetPropertiesKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDevicePortabilitySubsetPropertiesKHR
func (x PhysicalDevicePortabilitySubsetPropertiesKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType)
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDevicePortabilitySubsetPropertiesKHR) WithDefaultSType() PhysicalDevicePortabilitySubsetPropertiesKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetPropertiesKHR) WithSType(y StructureType) PhysicalDevicePortabilitySubsetPropertiesKHR {
	ptr := /* typedef */ (*C.VkStructureType)(&y)
	x.sType = *ptr
	return x
}

// PNext returns the value of pNext from VkPhysicalDevicePortabilitySubsetPropertiesKHR
func (x PhysicalDevicePortabilitySubsetPropertiesKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&x.pNext)
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetPropertiesKHR) WithPNext(y unsafe.Pointer) PhysicalDevicePortabilitySubsetPropertiesKHR {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ return (*unsafe.Pointer)(unsafe.Pointer(x)) }(&y)
	x.pNext = *ptr
	return x
}

// MinVertexInputBindingStrideAlignment returns the value of minVertexInputBindingStrideAlignment from VkPhysicalDevicePortabilitySubsetPropertiesKHR
func (x PhysicalDevicePortabilitySubsetPropertiesKHR) MinVertexInputBindingStrideAlignment() uint32 {
	ptr := func(x *C.uint) *uint32 { /* Scalar */ return (*uint32)(unsafe.Pointer(x)) }(&x.minVertexInputBindingStrideAlignment)
	return *ptr
}

// WithMinVertexInputBindingStrideAlignment sets the value for the MinVertexInputBindingStrideAlignment on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetPropertiesKHR) WithMinVertexInputBindingStrideAlignment(y uint32) PhysicalDevicePortabilitySubsetPropertiesKHR {
	ptr := func(x *uint32) *C.uint { /* Scalar */ return (*C.uint)(unsafe.Pointer(x)) }(&y)
	x.minVertexInputBindingStrideAlignment = *ptr
	return x
}

func newCBlock(sz C.ulong) unsafe.Pointer {
	ptr := C.malloc(sz)
	C.memset(ptr, 0, sz)
	return ptr
}

func nullTerminatedBuffer(s string) *bytes.Buffer {
	var str bytes.Buffer
	var isNullTerminated bool
	for _, c := range ([]byte)(s) {
		if c == 0 {
			isNullTerminated = true
		}
		str.WriteByte(c)
		if isNullTerminated {
			break
		}
	}
	if !isNullTerminated {
		str.WriteByte(0)
	}
	return &str
}
