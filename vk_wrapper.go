package vks

//#cgo LDFLAGS: -lvulkan
//#include <stdlib.h>
//#include <string.h>
//#include "vk_wrapper.h"
import "C"
import (
	"bytes"
	"fmt"
	"unsafe"
)

// Init loads the Vulkan library.
func Init() Result {
	ret := C.vksDynamicLoad()
	ptr := (*Result)(&ret)
	return *ptr
}

// Destroy unloads the Vulkan Library.
func Destroy() {
	C.vksDynamicUnload()
}

// NewCString allocates the provided string on the C heap. FreeCString must be
// called when the string is no longer needed.
func NewCString(s string) *byte {
	b := nullTerminatedBuffer(s).Bytes()
	ptr := C.malloc(C.ulong(len(b)))
	C.memcpy(ptr, unsafe.Pointer(&b[0]), C.ulong(len(b)))
	return (*byte)(ptr)
}

// FreeCString releases the C heap memory allocated by NewCString.
func FreeCString(ptr *byte) {
	if ptr != nil {
		C.free(unsafe.Pointer(ptr))
	}
}

// These are API constants.
const (
	VK_MAX_PHYSICAL_DEVICE_NAME_SIZE = 256
	VK_UUID_SIZE = 16
	VK_LUID_SIZE = 8
	VK_LUID_SIZE_KHR = VK_LUID_SIZE
	VK_MAX_EXTENSION_NAME_SIZE = 256
	VK_MAX_DESCRIPTION_SIZE = 256
	VK_MAX_MEMORY_TYPES = 32
	VK_MAX_MEMORY_HEAPS = 16
	VK_LOD_CLAMP_NONE = 1000.0
	VK_REMAINING_MIP_LEVELS = ^uint32(0)
	VK_REMAINING_ARRAY_LAYERS = ^uint32(0)
	VK_WHOLE_SIZE = ^uint64(0)
	VK_ATTACHMENT_UNUSED = ^uint32(0)
	VK_TRUE = 1
	VK_FALSE = 0
	VK_QUEUE_FAMILY_IGNORED = ^uint32(0)
	VK_QUEUE_FAMILY_EXTERNAL = ^uint32(1)
	VK_QUEUE_FAMILY_EXTERNAL_KHR = VK_QUEUE_FAMILY_EXTERNAL
	VK_QUEUE_FAMILY_FOREIGN_EXT = ^uint32(2)
	VK_SUBPASS_EXTERNAL = ^uint32(0)
	VK_MAX_DEVICE_GROUP_SIZE = 32
	VK_MAX_DEVICE_GROUP_SIZE_KHR = VK_MAX_DEVICE_GROUP_SIZE
	VK_MAX_DRIVER_NAME_SIZE = 256
	VK_MAX_DRIVER_NAME_SIZE_KHR = VK_MAX_DRIVER_NAME_SIZE
	VK_MAX_DRIVER_INFO_SIZE = 256
	VK_MAX_DRIVER_INFO_SIZE_KHR = VK_MAX_DRIVER_INFO_SIZE
	VK_SHADER_UNUSED_KHR = ^uint32(0)
	VK_SHADER_UNUSED_NV = VK_SHADER_UNUSED_KHR
	VK_MAX_GLOBAL_PRIORITY_SIZE_KHR = 16
	VK_MAX_GLOBAL_PRIORITY_SIZE_EXT = VK_MAX_GLOBAL_PRIORITY_SIZE_KHR
	VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT = 32
	VK_KHR_SURFACE_SPEC_VERSION = 25
	VK_KHR_SURFACE_EXTENSION_NAME = "VK_KHR_surface"
	VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION = 1
	VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME = "VK_KHR_get_surface_capabilities2"
	VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION = 1
	VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME = "VK_KHR_surface_protected_capabilities"
	VK_KHR_SWAPCHAIN_SPEC_VERSION = 70
	VK_KHR_SWAPCHAIN_EXTENSION_NAME = "VK_KHR_swapchain"
	VK_KHR_DISPLAY_SPEC_VERSION = 23
	VK_KHR_DISPLAY_EXTENSION_NAME = "VK_KHR_display"
	VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION = 1
	VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME = "VK_KHR_get_display_properties2"
	VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION = 10
	VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME = "VK_KHR_display_swapchain"
	VK_KHR_FORMAT_FEATURE_FLAGS_2_SPEC_VERSION = 1
	VK_KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME = "VK_KHR_format_feature_flags2"
	VK_KHR_PORTABILITY_SUBSET_SPEC_VERSION = 1
	VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME = "VK_KHR_portability_subset"
)

// ApiVersion is an implementation of the Vulkan Make Api Version
// defines. See
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_MAKE_API_VERSION.html
type ApiVersion uint32

// MakeApiVersion creates a Version based on the provided Variant, maJor, miNor,
// and Patch.
func MakeApiVersion(v, j, n, p int) ApiVersion {
	return ApiVersion((uint32(v) << 29) | (uint32(j) << 22) | (uint32(n) << 12) | (uint32(p)))
}

func (v ApiVersion) Major() uint32   { return uint32((v >> 22) & 0x7F) }
func (v ApiVersion) Minor() uint32   { return uint32((v >> 12) & 0x3FF) }
func (v ApiVersion) Patch() uint32   { return uint32(v & 0xFFF) }
func (v ApiVersion) Variant() uint32 { return uint32(v >> 29) }
func (v ApiVersion) String() string {
	return fmt.Sprintf("%d[v.%d.%d.%d.%d]", v, v.Variant(), v.Major(), v.Minor(), v.Patch())
}

var (
	VK_API_VERSION_1_0         ApiVersion = MakeApiVersion(0, 1, 0, 0)
	VK_API_VERSION_1_1         ApiVersion = MakeApiVersion(0, 1, 1, 0)
	VK_API_VERSION_1_2         ApiVersion = MakeApiVersion(0, 1, 2, 0)
	VK_API_VERSION_1_3         ApiVersion = MakeApiVersion(0, 1, 3, 0)
	VK_HEADER_VERSION_COMPLETE ApiVersion = MakeApiVersion(0, 1, 3, HeaderVersion)
)

// HeaderVersion is the version of the vk specification used to generate this.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_API_VERSION.html
const HeaderVersion = 220

// SampleMask basetype
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSampleMask.html
type SampleMask uint32

// Flags basetype
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFlags.html
type Flags uint32

// DeviceSize basetype
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceSize.html
type DeviceSize uint64

// Bool32 basetype
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBool32.html
type Bool32 uint32

// DeviceAddress basetype
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceAddress.html
type DeviceAddress uint64

// CommandBuffer is a Handle to a vulkan resource.
// CommandBuffer is a child of CommandPool.
//
// Use CommandPoolFacade.MakeCommandBufferFacade to create a facade around this object to invoke methods.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBuffer.html
type CommandBuffer C.VkCommandBuffer

// NullCommandBuffer is a typed Null value for the CommandBuffer type.
var NullCommandBuffer CommandBuffer

// MakeCommandBufferFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent CommandPoolFacade) MakeCommandBufferFacade(x CommandBuffer) CommandBufferFacade {
	return CommandBufferFacade{
		H:     x,
		procs: parent.procs,
	}
}

// CommandBufferFacade is a CommandBuffer handle with the proc addresses pointer. It allows
// the invocation of methods against the handle. In the vulkan spec, these would be the functions
// that take the handle as the first parameter.
//
// Use the H field to get the handle back.
type CommandBufferFacade struct {
	H     CommandBuffer   // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}


// Instance is a Handle to a vulkan resource.
//
// Use MakeInstanceFacade to create a facade around this object to invoke methods.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInstance.html
type Instance C.VkInstance

// NullInstance is a typed Null value for the Instance type.
var NullInstance Instance

// MakeInstanceFacadeFacade provides a facade interface to the handle. It loads the proc
// addresses for the provided Instance handle.
func MakeInstanceFacade(x Instance) InstanceFacade {
	var addrs C.vksProcAddr
	C.vksLoadInstanceProcAddrs(x, &addrs)
	return InstanceFacade{
		H:     x,
		procs: &addrs,
	}
}

// InstanceFacade is a Instance handle with the proc addresses pointer. It allows
// the invocation of methods against the handle. In the vulkan spec, these would be the functions
// that take the handle as the first parameter.
//
// Use the H field to get the handle back.
type InstanceFacade struct {
	H     Instance   // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}


// Sampler is a Handle to a vulkan resource.
// Sampler is a child of Device.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSampler.html
type Sampler C.VkSampler

// NullSampler is a typed Null value for the Sampler type.
var NullSampler Sampler


// Fence is a Handle to a vulkan resource.
// Fence is a child of Device.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFence.html
type Fence C.VkFence

// NullFence is a typed Null value for the Fence type.
var NullFence Fence


// BufferView is a Handle to a vulkan resource.
// BufferView is a child of Device.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferView.html
type BufferView C.VkBufferView

// NullBufferView is a typed Null value for the BufferView type.
var NullBufferView BufferView


// CommandPool is a Handle to a vulkan resource.
// CommandPool is a child of Device.
//
// Use DeviceFacade.MakeCommandPoolFacade to create a facade around this object to invoke methods.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPool.html
type CommandPool C.VkCommandPool

// NullCommandPool is a typed Null value for the CommandPool type.
var NullCommandPool CommandPool

// MakeCommandPoolFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DeviceFacade) MakeCommandPoolFacade(x CommandPool) CommandPoolFacade {
	return CommandPoolFacade{
		H:     x,
		procs: parent.procs,
	}
}

// CommandPoolFacade is a CommandPool handle with the proc addresses pointer. It allows
// the invocation of methods against the handle. In the vulkan spec, these would be the functions
// that take the handle as the first parameter.
//
// Use the H field to get the handle back.
type CommandPoolFacade struct {
	H     CommandPool   // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}


// ImageView is a Handle to a vulkan resource.
// ImageView is a child of Device.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageView.html
type ImageView C.VkImageView

// NullImageView is a typed Null value for the ImageView type.
var NullImageView ImageView


// DescriptorPool is a Handle to a vulkan resource.
// DescriptorPool is a child of Device.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPool.html
type DescriptorPool C.VkDescriptorPool

// NullDescriptorPool is a typed Null value for the DescriptorPool type.
var NullDescriptorPool DescriptorPool


// DescriptorSet is a Handle to a vulkan resource.
// DescriptorSet is a child of DescriptorPool.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSet.html
type DescriptorSet C.VkDescriptorSet

// NullDescriptorSet is a typed Null value for the DescriptorSet type.
var NullDescriptorSet DescriptorSet


// DescriptorSetLayout is a Handle to a vulkan resource.
// DescriptorSetLayout is a child of Device.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayout.html
type DescriptorSetLayout C.VkDescriptorSetLayout

// NullDescriptorSetLayout is a typed Null value for the DescriptorSetLayout type.
var NullDescriptorSetLayout DescriptorSetLayout


// RenderPass is a Handle to a vulkan resource.
// RenderPass is a child of Device.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPass.html
type RenderPass C.VkRenderPass

// NullRenderPass is a typed Null value for the RenderPass type.
var NullRenderPass RenderPass


// QueryPool is a Handle to a vulkan resource.
// QueryPool is a child of Device.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPool.html
type QueryPool C.VkQueryPool

// NullQueryPool is a typed Null value for the QueryPool type.
var NullQueryPool QueryPool


// Event is a Handle to a vulkan resource.
// Event is a child of Device.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkEvent.html
type Event C.VkEvent

// NullEvent is a typed Null value for the Event type.
var NullEvent Event


// Semaphore is a Handle to a vulkan resource.
// Semaphore is a child of Device.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphore.html
type Semaphore C.VkSemaphore

// NullSemaphore is a typed Null value for the Semaphore type.
var NullSemaphore Semaphore


// Framebuffer is a Handle to a vulkan resource.
// Framebuffer is a child of Device.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebuffer.html
type Framebuffer C.VkFramebuffer

// NullFramebuffer is a typed Null value for the Framebuffer type.
var NullFramebuffer Framebuffer


// Buffer is a Handle to a vulkan resource.
// Buffer is a child of Device.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBuffer.html
type Buffer C.VkBuffer

// NullBuffer is a typed Null value for the Buffer type.
var NullBuffer Buffer


// PipelineLayout is a Handle to a vulkan resource.
// PipelineLayout is a child of Device.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineLayout.html
type PipelineLayout C.VkPipelineLayout

// NullPipelineLayout is a typed Null value for the PipelineLayout type.
var NullPipelineLayout PipelineLayout


// Device is a Handle to a vulkan resource.
// Device is a child of PhysicalDevice.
//
// Use PhysicalDeviceFacade.MakeDeviceFacade to create a facade around this object to invoke methods.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDevice.html
type Device C.VkDevice

// NullDevice is a typed Null value for the Device type.
var NullDevice Device

// MakeDeviceFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent PhysicalDeviceFacade) MakeDeviceFacade(x Device) DeviceFacade {
	return DeviceFacade{
		H:     x,
		procs: parent.procs,
	}
}

// DeviceFacade is a Device handle with the proc addresses pointer. It allows
// the invocation of methods against the handle. In the vulkan spec, these would be the functions
// that take the handle as the first parameter.
//
// Use the H field to get the handle back.
type DeviceFacade struct {
	H     Device   // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}


// PhysicalDevice is a Handle to a vulkan resource.
// PhysicalDevice is a child of Instance.
//
// Use InstanceFacade.MakePhysicalDeviceFacade to create a facade around this object to invoke methods.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice.html
type PhysicalDevice C.VkPhysicalDevice

// NullPhysicalDevice is a typed Null value for the PhysicalDevice type.
var NullPhysicalDevice PhysicalDevice

// MakePhysicalDeviceFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent InstanceFacade) MakePhysicalDeviceFacade(x PhysicalDevice) PhysicalDeviceFacade {
	return PhysicalDeviceFacade{
		H:     x,
		procs: parent.procs,
	}
}

// PhysicalDeviceFacade is a PhysicalDevice handle with the proc addresses pointer. It allows
// the invocation of methods against the handle. In the vulkan spec, these would be the functions
// that take the handle as the first parameter.
//
// Use the H field to get the handle back.
type PhysicalDeviceFacade struct {
	H     PhysicalDevice   // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}


// DeviceMemory is a Handle to a vulkan resource.
// DeviceMemory is a child of Device.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceMemory.html
type DeviceMemory C.VkDeviceMemory

// NullDeviceMemory is a typed Null value for the DeviceMemory type.
var NullDeviceMemory DeviceMemory


// Pipeline is a Handle to a vulkan resource.
// Pipeline is a child of Device.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipeline.html
type Pipeline C.VkPipeline

// NullPipeline is a typed Null value for the Pipeline type.
var NullPipeline Pipeline


// ShaderModule is a Handle to a vulkan resource.
// ShaderModule is a child of Device.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderModule.html
type ShaderModule C.VkShaderModule

// NullShaderModule is a typed Null value for the ShaderModule type.
var NullShaderModule ShaderModule


// PipelineCache is a Handle to a vulkan resource.
// PipelineCache is a child of Device.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCache.html
type PipelineCache C.VkPipelineCache

// NullPipelineCache is a typed Null value for the PipelineCache type.
var NullPipelineCache PipelineCache


// Queue is a Handle to a vulkan resource.
// Queue is a child of Device.
//
// Use DeviceFacade.MakeQueueFacade to create a facade around this object to invoke methods.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueue.html
type Queue C.VkQueue

// NullQueue is a typed Null value for the Queue type.
var NullQueue Queue

// MakeQueueFacadeprovides a facade interface to the handle. It requires
// the parent facade to copy the proc addresses.
func (parent DeviceFacade) MakeQueueFacade(x Queue) QueueFacade {
	return QueueFacade{
		H:     x,
		procs: parent.procs,
	}
}

// QueueFacade is a Queue handle with the proc addresses pointer. It allows
// the invocation of methods against the handle. In the vulkan spec, these would be the functions
// that take the handle as the first parameter.
//
// Use the H field to get the handle back.
type QueueFacade struct {
	H     Queue   // The vulkan Handle
	procs *C.vksProcAddr // The addresses for commands.
}


// Image is a Handle to a vulkan resource.
// Image is a child of Device.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImage.html
type Image C.VkImage

// NullImage is a typed Null value for the Image type.
var NullImage Image


// PipelineCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreateFlagBits.html
type PipelineCreateFlagBits uint32

const (
	VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT PipelineCreateFlagBits = (1 << 0)
	VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT PipelineCreateFlagBits = (1 << 1)
	VK_PIPELINE_CREATE_DERIVATIVE_BIT PipelineCreateFlagBits = (1 << 2)
	VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT PipelineCreateFlagBits = (1 << 3)
	VK_PIPELINE_CREATE_DISPATCH_BASE_BIT PipelineCreateFlagBits = (1 << 4)
	VK_PIPELINE_CREATE_DISPATCH_BASE PipelineCreateFlagBits = VK_PIPELINE_CREATE_DISPATCH_BASE_BIT
	VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT PipelineCreateFlagBits = (1 << 8)
	VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT PipelineCreateFlagBits = (1 << 9)
)

var (
	reversePipelineCreateFlagBits map[PipelineCreateFlagBits]string = map[PipelineCreateFlagBits]string{ 
		VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT: "VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT",
		VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT: "VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT",
		VK_PIPELINE_CREATE_DERIVATIVE_BIT: "VK_PIPELINE_CREATE_DERIVATIVE_BIT",
		VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT: "VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT",
		VK_PIPELINE_CREATE_DISPATCH_BASE_BIT: "VK_PIPELINE_CREATE_DISPATCH_BASE_BIT",
		VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT: "VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT",
		VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT: "VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT",
	}
)
func (x PipelineCreateFlagBits) String() string {
	if s, ok := reversePipelineCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("PipelineCreateFlagBits=%d", x)
}

// CommandBufferLevel enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferLevel.html
type CommandBufferLevel uint32

const (
	VK_COMMAND_BUFFER_LEVEL_PRIMARY CommandBufferLevel = 0
	VK_COMMAND_BUFFER_LEVEL_SECONDARY CommandBufferLevel = 1
)

var (
	reverseCommandBufferLevel map[CommandBufferLevel]string = map[CommandBufferLevel]string{ 
		VK_COMMAND_BUFFER_LEVEL_PRIMARY: "VK_COMMAND_BUFFER_LEVEL_PRIMARY",
		VK_COMMAND_BUFFER_LEVEL_SECONDARY: "VK_COMMAND_BUFFER_LEVEL_SECONDARY",
	}
)
func (x CommandBufferLevel) String() string {
	if s, ok := reverseCommandBufferLevel[x]; ok {
		return s
	}
	return fmt.Sprintf("CommandBufferLevel=%d", x)
}

// VendorId enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVendorId.html
type VendorId uint32

const (
	VK_VENDOR_ID_VIV VendorId = 0x10001
	VK_VENDOR_ID_VSI VendorId = 0x10002
	VK_VENDOR_ID_KAZAN VendorId = 0x10003
	VK_VENDOR_ID_CODEPLAY VendorId = 0x10004
	VK_VENDOR_ID_MESA VendorId = 0x10005
	VK_VENDOR_ID_POCL VendorId = 0x10006
)

var (
	reverseVendorId map[VendorId]string = map[VendorId]string{ 
		VK_VENDOR_ID_VIV: "VK_VENDOR_ID_VIV",
		VK_VENDOR_ID_VSI: "VK_VENDOR_ID_VSI",
		VK_VENDOR_ID_KAZAN: "VK_VENDOR_ID_KAZAN",
		VK_VENDOR_ID_CODEPLAY: "VK_VENDOR_ID_CODEPLAY",
		VK_VENDOR_ID_MESA: "VK_VENDOR_ID_MESA",
		VK_VENDOR_ID_POCL: "VK_VENDOR_ID_POCL",
	}
)
func (x VendorId) String() string {
	if s, ok := reverseVendorId[x]; ok {
		return s
	}
	return fmt.Sprintf("VendorId=%d", x)
}

// AttachmentStoreOp enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentStoreOp.html
type AttachmentStoreOp uint32

const (
	VK_ATTACHMENT_STORE_OP_STORE AttachmentStoreOp = 0
	VK_ATTACHMENT_STORE_OP_DONT_CARE AttachmentStoreOp = 1
	VK_ATTACHMENT_STORE_OP_NONE AttachmentStoreOp = 1000301000
)

var (
	reverseAttachmentStoreOp map[AttachmentStoreOp]string = map[AttachmentStoreOp]string{ 
		VK_ATTACHMENT_STORE_OP_STORE: "VK_ATTACHMENT_STORE_OP_STORE",
		VK_ATTACHMENT_STORE_OP_DONT_CARE: "VK_ATTACHMENT_STORE_OP_DONT_CARE",
		VK_ATTACHMENT_STORE_OP_NONE: "VK_ATTACHMENT_STORE_OP_NONE",
	}
)
func (x AttachmentStoreOp) String() string {
	if s, ok := reverseAttachmentStoreOp[x]; ok {
		return s
	}
	return fmt.Sprintf("AttachmentStoreOp=%d", x)
}

// ObjectType enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkObjectType.html
type ObjectType uint32

const (
	VK_OBJECT_TYPE_UNKNOWN ObjectType = 0
	VK_OBJECT_TYPE_INSTANCE ObjectType = 1
	VK_OBJECT_TYPE_PHYSICAL_DEVICE ObjectType = 2
	VK_OBJECT_TYPE_DEVICE ObjectType = 3
	VK_OBJECT_TYPE_QUEUE ObjectType = 4
	VK_OBJECT_TYPE_SEMAPHORE ObjectType = 5
	VK_OBJECT_TYPE_COMMAND_BUFFER ObjectType = 6
	VK_OBJECT_TYPE_FENCE ObjectType = 7
	VK_OBJECT_TYPE_DEVICE_MEMORY ObjectType = 8
	VK_OBJECT_TYPE_BUFFER ObjectType = 9
	VK_OBJECT_TYPE_IMAGE ObjectType = 10
	VK_OBJECT_TYPE_EVENT ObjectType = 11
	VK_OBJECT_TYPE_QUERY_POOL ObjectType = 12
	VK_OBJECT_TYPE_BUFFER_VIEW ObjectType = 13
	VK_OBJECT_TYPE_IMAGE_VIEW ObjectType = 14
	VK_OBJECT_TYPE_SHADER_MODULE ObjectType = 15
	VK_OBJECT_TYPE_PIPELINE_CACHE ObjectType = 16
	VK_OBJECT_TYPE_PIPELINE_LAYOUT ObjectType = 17
	VK_OBJECT_TYPE_RENDER_PASS ObjectType = 18
	VK_OBJECT_TYPE_PIPELINE ObjectType = 19
	VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT ObjectType = 20
	VK_OBJECT_TYPE_SAMPLER ObjectType = 21
	VK_OBJECT_TYPE_DESCRIPTOR_POOL ObjectType = 22
	VK_OBJECT_TYPE_DESCRIPTOR_SET ObjectType = 23
	VK_OBJECT_TYPE_FRAMEBUFFER ObjectType = 24
	VK_OBJECT_TYPE_COMMAND_POOL ObjectType = 25
	VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION ObjectType = 1000156000
	VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE ObjectType = 1000085000
	VK_OBJECT_TYPE_PRIVATE_DATA_SLOT ObjectType = 1000295000
	VK_OBJECT_TYPE_SURFACE_KHR ObjectType = 1000000000
	VK_OBJECT_TYPE_SWAPCHAIN_KHR ObjectType = 1000001000
	VK_OBJECT_TYPE_DISPLAY_KHR ObjectType = 1000002000
	VK_OBJECT_TYPE_DISPLAY_MODE_KHR ObjectType = 1000002001
)

var (
	reverseObjectType map[ObjectType]string = map[ObjectType]string{ 
		VK_OBJECT_TYPE_UNKNOWN: "VK_OBJECT_TYPE_UNKNOWN",
		VK_OBJECT_TYPE_INSTANCE: "VK_OBJECT_TYPE_INSTANCE",
		VK_OBJECT_TYPE_PHYSICAL_DEVICE: "VK_OBJECT_TYPE_PHYSICAL_DEVICE",
		VK_OBJECT_TYPE_DEVICE: "VK_OBJECT_TYPE_DEVICE",
		VK_OBJECT_TYPE_QUEUE: "VK_OBJECT_TYPE_QUEUE",
		VK_OBJECT_TYPE_SEMAPHORE: "VK_OBJECT_TYPE_SEMAPHORE",
		VK_OBJECT_TYPE_COMMAND_BUFFER: "VK_OBJECT_TYPE_COMMAND_BUFFER",
		VK_OBJECT_TYPE_FENCE: "VK_OBJECT_TYPE_FENCE",
		VK_OBJECT_TYPE_DEVICE_MEMORY: "VK_OBJECT_TYPE_DEVICE_MEMORY",
		VK_OBJECT_TYPE_BUFFER: "VK_OBJECT_TYPE_BUFFER",
		VK_OBJECT_TYPE_IMAGE: "VK_OBJECT_TYPE_IMAGE",
		VK_OBJECT_TYPE_EVENT: "VK_OBJECT_TYPE_EVENT",
		VK_OBJECT_TYPE_QUERY_POOL: "VK_OBJECT_TYPE_QUERY_POOL",
		VK_OBJECT_TYPE_BUFFER_VIEW: "VK_OBJECT_TYPE_BUFFER_VIEW",
		VK_OBJECT_TYPE_IMAGE_VIEW: "VK_OBJECT_TYPE_IMAGE_VIEW",
		VK_OBJECT_TYPE_SHADER_MODULE: "VK_OBJECT_TYPE_SHADER_MODULE",
		VK_OBJECT_TYPE_PIPELINE_CACHE: "VK_OBJECT_TYPE_PIPELINE_CACHE",
		VK_OBJECT_TYPE_PIPELINE_LAYOUT: "VK_OBJECT_TYPE_PIPELINE_LAYOUT",
		VK_OBJECT_TYPE_RENDER_PASS: "VK_OBJECT_TYPE_RENDER_PASS",
		VK_OBJECT_TYPE_PIPELINE: "VK_OBJECT_TYPE_PIPELINE",
		VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT: "VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT",
		VK_OBJECT_TYPE_SAMPLER: "VK_OBJECT_TYPE_SAMPLER",
		VK_OBJECT_TYPE_DESCRIPTOR_POOL: "VK_OBJECT_TYPE_DESCRIPTOR_POOL",
		VK_OBJECT_TYPE_DESCRIPTOR_SET: "VK_OBJECT_TYPE_DESCRIPTOR_SET",
		VK_OBJECT_TYPE_FRAMEBUFFER: "VK_OBJECT_TYPE_FRAMEBUFFER",
		VK_OBJECT_TYPE_COMMAND_POOL: "VK_OBJECT_TYPE_COMMAND_POOL",
		VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION: "VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION",
		VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE: "VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE",
		VK_OBJECT_TYPE_PRIVATE_DATA_SLOT: "VK_OBJECT_TYPE_PRIVATE_DATA_SLOT",
		VK_OBJECT_TYPE_SURFACE_KHR: "VK_OBJECT_TYPE_SURFACE_KHR",
		VK_OBJECT_TYPE_SWAPCHAIN_KHR: "VK_OBJECT_TYPE_SWAPCHAIN_KHR",
		VK_OBJECT_TYPE_DISPLAY_KHR: "VK_OBJECT_TYPE_DISPLAY_KHR",
		VK_OBJECT_TYPE_DISPLAY_MODE_KHR: "VK_OBJECT_TYPE_DISPLAY_MODE_KHR",
	}
)
func (x ObjectType) String() string {
	if s, ok := reverseObjectType[x]; ok {
		return s
	}
	return fmt.Sprintf("ObjectType=%d", x)
}

// DependencyFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDependencyFlagBits.html
type DependencyFlagBits uint32

const (
	VK_DEPENDENCY_BY_REGION_BIT DependencyFlagBits = (1 << 0)
	VK_DEPENDENCY_DEVICE_GROUP_BIT DependencyFlagBits = (1 << 2)
	VK_DEPENDENCY_VIEW_LOCAL_BIT DependencyFlagBits = (1 << 1)
)

var (
	reverseDependencyFlagBits map[DependencyFlagBits]string = map[DependencyFlagBits]string{ 
		VK_DEPENDENCY_BY_REGION_BIT: "VK_DEPENDENCY_BY_REGION_BIT",
		VK_DEPENDENCY_DEVICE_GROUP_BIT: "VK_DEPENDENCY_DEVICE_GROUP_BIT",
		VK_DEPENDENCY_VIEW_LOCAL_BIT: "VK_DEPENDENCY_VIEW_LOCAL_BIT",
	}
)
func (x DependencyFlagBits) String() string {
	if s, ok := reverseDependencyFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("DependencyFlagBits=%d", x)
}

// FramebufferCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebufferCreateFlagBits.html
type FramebufferCreateFlagBits uint32

const (
	VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT FramebufferCreateFlagBits = (1 << 0)
)

var (
	reverseFramebufferCreateFlagBits map[FramebufferCreateFlagBits]string = map[FramebufferCreateFlagBits]string{ 
		VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT: "VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT",
	}
)
func (x FramebufferCreateFlagBits) String() string {
	if s, ok := reverseFramebufferCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("FramebufferCreateFlagBits=%d", x)
}

// QueryType enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryType.html
type QueryType uint32

const (
	VK_QUERY_TYPE_OCCLUSION QueryType = 0
	VK_QUERY_TYPE_PIPELINE_STATISTICS QueryType = 1
	VK_QUERY_TYPE_TIMESTAMP QueryType = 2
)

var (
	reverseQueryType map[QueryType]string = map[QueryType]string{ 
		VK_QUERY_TYPE_OCCLUSION: "VK_QUERY_TYPE_OCCLUSION",
		VK_QUERY_TYPE_PIPELINE_STATISTICS: "VK_QUERY_TYPE_PIPELINE_STATISTICS",
		VK_QUERY_TYPE_TIMESTAMP: "VK_QUERY_TYPE_TIMESTAMP",
	}
)
func (x QueryType) String() string {
	if s, ok := reverseQueryType[x]; ok {
		return s
	}
	return fmt.Sprintf("QueryType=%d", x)
}

// PipelineBindPoint enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineBindPoint.html
type PipelineBindPoint uint32

const (
	VK_PIPELINE_BIND_POINT_GRAPHICS PipelineBindPoint = 0
	VK_PIPELINE_BIND_POINT_COMPUTE PipelineBindPoint = 1
)

var (
	reversePipelineBindPoint map[PipelineBindPoint]string = map[PipelineBindPoint]string{ 
		VK_PIPELINE_BIND_POINT_GRAPHICS: "VK_PIPELINE_BIND_POINT_GRAPHICS",
		VK_PIPELINE_BIND_POINT_COMPUTE: "VK_PIPELINE_BIND_POINT_COMPUTE",
	}
)
func (x PipelineBindPoint) String() string {
	if s, ok := reversePipelineBindPoint[x]; ok {
		return s
	}
	return fmt.Sprintf("PipelineBindPoint=%d", x)
}

// AttachmentLoadOp enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentLoadOp.html
type AttachmentLoadOp uint32

const (
	VK_ATTACHMENT_LOAD_OP_LOAD AttachmentLoadOp = 0
	VK_ATTACHMENT_LOAD_OP_CLEAR AttachmentLoadOp = 1
	VK_ATTACHMENT_LOAD_OP_DONT_CARE AttachmentLoadOp = 2
)

var (
	reverseAttachmentLoadOp map[AttachmentLoadOp]string = map[AttachmentLoadOp]string{ 
		VK_ATTACHMENT_LOAD_OP_LOAD: "VK_ATTACHMENT_LOAD_OP_LOAD",
		VK_ATTACHMENT_LOAD_OP_CLEAR: "VK_ATTACHMENT_LOAD_OP_CLEAR",
		VK_ATTACHMENT_LOAD_OP_DONT_CARE: "VK_ATTACHMENT_LOAD_OP_DONT_CARE",
	}
)
func (x AttachmentLoadOp) String() string {
	if s, ok := reverseAttachmentLoadOp[x]; ok {
		return s
	}
	return fmt.Sprintf("AttachmentLoadOp=%d", x)
}

// SparseMemoryBindFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseMemoryBindFlagBits.html
type SparseMemoryBindFlagBits uint32

const (
	VK_SPARSE_MEMORY_BIND_METADATA_BIT SparseMemoryBindFlagBits = (1 << 0)
)

var (
	reverseSparseMemoryBindFlagBits map[SparseMemoryBindFlagBits]string = map[SparseMemoryBindFlagBits]string{ 
		VK_SPARSE_MEMORY_BIND_METADATA_BIT: "VK_SPARSE_MEMORY_BIND_METADATA_BIT",
	}
)
func (x SparseMemoryBindFlagBits) String() string {
	if s, ok := reverseSparseMemoryBindFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("SparseMemoryBindFlagBits=%d", x)
}

// AttachmentDescriptionFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentDescriptionFlagBits.html
type AttachmentDescriptionFlagBits uint32

const (
	VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT AttachmentDescriptionFlagBits = (1 << 0)
)

var (
	reverseAttachmentDescriptionFlagBits map[AttachmentDescriptionFlagBits]string = map[AttachmentDescriptionFlagBits]string{ 
		VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT: "VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT",
	}
)
func (x AttachmentDescriptionFlagBits) String() string {
	if s, ok := reverseAttachmentDescriptionFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("AttachmentDescriptionFlagBits=%d", x)
}

// BufferCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCreateFlagBits.html
type BufferCreateFlagBits uint32

const (
	VK_BUFFER_CREATE_SPARSE_BINDING_BIT BufferCreateFlagBits = (1 << 0)
	VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT BufferCreateFlagBits = (1 << 1)
	VK_BUFFER_CREATE_SPARSE_ALIASED_BIT BufferCreateFlagBits = (1 << 2)
	VK_BUFFER_CREATE_PROTECTED_BIT BufferCreateFlagBits = (1 << 3)
	VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT BufferCreateFlagBits = (1 << 4)
)

var (
	reverseBufferCreateFlagBits map[BufferCreateFlagBits]string = map[BufferCreateFlagBits]string{ 
		VK_BUFFER_CREATE_SPARSE_BINDING_BIT: "VK_BUFFER_CREATE_SPARSE_BINDING_BIT",
		VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT: "VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT",
		VK_BUFFER_CREATE_SPARSE_ALIASED_BIT: "VK_BUFFER_CREATE_SPARSE_ALIASED_BIT",
		VK_BUFFER_CREATE_PROTECTED_BIT: "VK_BUFFER_CREATE_PROTECTED_BIT",
		VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT: "VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT",
	}
)
func (x BufferCreateFlagBits) String() string {
	if s, ok := reverseBufferCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("BufferCreateFlagBits=%d", x)
}

// AccessFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccessFlagBits.html
type AccessFlagBits uint32

const (
	VK_ACCESS_INDIRECT_COMMAND_READ_BIT AccessFlagBits = (1 << 0)
	VK_ACCESS_INDEX_READ_BIT AccessFlagBits = (1 << 1)
	VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT AccessFlagBits = (1 << 2)
	VK_ACCESS_UNIFORM_READ_BIT AccessFlagBits = (1 << 3)
	VK_ACCESS_INPUT_ATTACHMENT_READ_BIT AccessFlagBits = (1 << 4)
	VK_ACCESS_SHADER_READ_BIT AccessFlagBits = (1 << 5)
	VK_ACCESS_SHADER_WRITE_BIT AccessFlagBits = (1 << 6)
	VK_ACCESS_COLOR_ATTACHMENT_READ_BIT AccessFlagBits = (1 << 7)
	VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT AccessFlagBits = (1 << 8)
	VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT AccessFlagBits = (1 << 9)
	VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT AccessFlagBits = (1 << 10)
	VK_ACCESS_TRANSFER_READ_BIT AccessFlagBits = (1 << 11)
	VK_ACCESS_TRANSFER_WRITE_BIT AccessFlagBits = (1 << 12)
	VK_ACCESS_HOST_READ_BIT AccessFlagBits = (1 << 13)
	VK_ACCESS_HOST_WRITE_BIT AccessFlagBits = (1 << 14)
	VK_ACCESS_MEMORY_READ_BIT AccessFlagBits = (1 << 15)
	VK_ACCESS_MEMORY_WRITE_BIT AccessFlagBits = (1 << 16)
	VK_ACCESS_NONE AccessFlagBits = 0
)

var (
	reverseAccessFlagBits map[AccessFlagBits]string = map[AccessFlagBits]string{ 
		VK_ACCESS_INDIRECT_COMMAND_READ_BIT: "VK_ACCESS_INDIRECT_COMMAND_READ_BIT",
		VK_ACCESS_INDEX_READ_BIT: "VK_ACCESS_INDEX_READ_BIT",
		VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT: "VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT",
		VK_ACCESS_UNIFORM_READ_BIT: "VK_ACCESS_UNIFORM_READ_BIT",
		VK_ACCESS_INPUT_ATTACHMENT_READ_BIT: "VK_ACCESS_INPUT_ATTACHMENT_READ_BIT",
		VK_ACCESS_SHADER_READ_BIT: "VK_ACCESS_SHADER_READ_BIT",
		VK_ACCESS_SHADER_WRITE_BIT: "VK_ACCESS_SHADER_WRITE_BIT",
		VK_ACCESS_COLOR_ATTACHMENT_READ_BIT: "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT",
		VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT: "VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT",
		VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT: "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT",
		VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT: "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT",
		VK_ACCESS_TRANSFER_READ_BIT: "VK_ACCESS_TRANSFER_READ_BIT",
		VK_ACCESS_TRANSFER_WRITE_BIT: "VK_ACCESS_TRANSFER_WRITE_BIT",
		VK_ACCESS_HOST_READ_BIT: "VK_ACCESS_HOST_READ_BIT",
		VK_ACCESS_HOST_WRITE_BIT: "VK_ACCESS_HOST_WRITE_BIT",
		VK_ACCESS_MEMORY_READ_BIT: "VK_ACCESS_MEMORY_READ_BIT",
		VK_ACCESS_MEMORY_WRITE_BIT: "VK_ACCESS_MEMORY_WRITE_BIT",
		VK_ACCESS_NONE: "VK_ACCESS_NONE",
	}
)
func (x AccessFlagBits) String() string {
	if s, ok := reverseAccessFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("AccessFlagBits=%d", x)
}

// DescriptorType enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorType.html
type DescriptorType uint32

const (
	VK_DESCRIPTOR_TYPE_SAMPLER DescriptorType = 0
	VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER DescriptorType = 1
	VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE DescriptorType = 2
	VK_DESCRIPTOR_TYPE_STORAGE_IMAGE DescriptorType = 3
	VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER DescriptorType = 4
	VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER DescriptorType = 5
	VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER DescriptorType = 6
	VK_DESCRIPTOR_TYPE_STORAGE_BUFFER DescriptorType = 7
	VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC DescriptorType = 8
	VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC DescriptorType = 9
	VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT DescriptorType = 10
	VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK DescriptorType = 1000138000
)

var (
	reverseDescriptorType map[DescriptorType]string = map[DescriptorType]string{ 
		VK_DESCRIPTOR_TYPE_SAMPLER: "VK_DESCRIPTOR_TYPE_SAMPLER",
		VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER: "VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER",
		VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE: "VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE",
		VK_DESCRIPTOR_TYPE_STORAGE_IMAGE: "VK_DESCRIPTOR_TYPE_STORAGE_IMAGE",
		VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER: "VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER",
		VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER: "VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER",
		VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER: "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER",
		VK_DESCRIPTOR_TYPE_STORAGE_BUFFER: "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER",
		VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC: "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC",
		VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC: "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC",
		VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT: "VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT",
		VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK: "VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK",
	}
)
func (x DescriptorType) String() string {
	if s, ok := reverseDescriptorType[x]; ok {
		return s
	}
	return fmt.Sprintf("DescriptorType=%d", x)
}

// BufferUsageFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferUsageFlagBits.html
type BufferUsageFlagBits uint32

const (
	VK_BUFFER_USAGE_TRANSFER_SRC_BIT BufferUsageFlagBits = (1 << 0)
	VK_BUFFER_USAGE_TRANSFER_DST_BIT BufferUsageFlagBits = (1 << 1)
	VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT BufferUsageFlagBits = (1 << 2)
	VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT BufferUsageFlagBits = (1 << 3)
	VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT BufferUsageFlagBits = (1 << 4)
	VK_BUFFER_USAGE_STORAGE_BUFFER_BIT BufferUsageFlagBits = (1 << 5)
	VK_BUFFER_USAGE_INDEX_BUFFER_BIT BufferUsageFlagBits = (1 << 6)
	VK_BUFFER_USAGE_VERTEX_BUFFER_BIT BufferUsageFlagBits = (1 << 7)
	VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT BufferUsageFlagBits = (1 << 8)
	VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT BufferUsageFlagBits = (1 << 17)
)

var (
	reverseBufferUsageFlagBits map[BufferUsageFlagBits]string = map[BufferUsageFlagBits]string{ 
		VK_BUFFER_USAGE_TRANSFER_SRC_BIT: "VK_BUFFER_USAGE_TRANSFER_SRC_BIT",
		VK_BUFFER_USAGE_TRANSFER_DST_BIT: "VK_BUFFER_USAGE_TRANSFER_DST_BIT",
		VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT: "VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT",
		VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT: "VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT",
		VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT: "VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT",
		VK_BUFFER_USAGE_STORAGE_BUFFER_BIT: "VK_BUFFER_USAGE_STORAGE_BUFFER_BIT",
		VK_BUFFER_USAGE_INDEX_BUFFER_BIT: "VK_BUFFER_USAGE_INDEX_BUFFER_BIT",
		VK_BUFFER_USAGE_VERTEX_BUFFER_BIT: "VK_BUFFER_USAGE_VERTEX_BUFFER_BIT",
		VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT: "VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT",
		VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT: "VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT",
	}
)
func (x BufferUsageFlagBits) String() string {
	if s, ok := reverseBufferUsageFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("BufferUsageFlagBits=%d", x)
}

// DescriptorSetLayoutCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutCreateFlagBits.html
type DescriptorSetLayoutCreateFlagBits uint32

const (
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT DescriptorSetLayoutCreateFlagBits = (1 << 1)
)

var (
	reverseDescriptorSetLayoutCreateFlagBits map[DescriptorSetLayoutCreateFlagBits]string = map[DescriptorSetLayoutCreateFlagBits]string{ 
		VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT: "VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT",
	}
)
func (x DescriptorSetLayoutCreateFlagBits) String() string {
	if s, ok := reverseDescriptorSetLayoutCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("DescriptorSetLayoutCreateFlagBits=%d", x)
}

// RenderPassCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreateFlagBits.html
type RenderPassCreateFlagBits uint32

// QueryResultFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryResultFlagBits.html
type QueryResultFlagBits uint32

const (
	VK_QUERY_RESULT_64_BIT QueryResultFlagBits = (1 << 0)
	VK_QUERY_RESULT_WAIT_BIT QueryResultFlagBits = (1 << 1)
	VK_QUERY_RESULT_WITH_AVAILABILITY_BIT QueryResultFlagBits = (1 << 2)
	VK_QUERY_RESULT_PARTIAL_BIT QueryResultFlagBits = (1 << 3)
)

var (
	reverseQueryResultFlagBits map[QueryResultFlagBits]string = map[QueryResultFlagBits]string{ 
		VK_QUERY_RESULT_64_BIT: "VK_QUERY_RESULT_64_BIT",
		VK_QUERY_RESULT_WAIT_BIT: "VK_QUERY_RESULT_WAIT_BIT",
		VK_QUERY_RESULT_WITH_AVAILABILITY_BIT: "VK_QUERY_RESULT_WITH_AVAILABILITY_BIT",
		VK_QUERY_RESULT_PARTIAL_BIT: "VK_QUERY_RESULT_PARTIAL_BIT",
	}
)
func (x QueryResultFlagBits) String() string {
	if s, ok := reverseQueryResultFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("QueryResultFlagBits=%d", x)
}

// SharingMode enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSharingMode.html
type SharingMode uint32

const (
	VK_SHARING_MODE_EXCLUSIVE SharingMode = 0
	VK_SHARING_MODE_CONCURRENT SharingMode = 1
)

var (
	reverseSharingMode map[SharingMode]string = map[SharingMode]string{ 
		VK_SHARING_MODE_EXCLUSIVE: "VK_SHARING_MODE_EXCLUSIVE",
		VK_SHARING_MODE_CONCURRENT: "VK_SHARING_MODE_CONCURRENT",
	}
)
func (x SharingMode) String() string {
	if s, ok := reverseSharingMode[x]; ok {
		return s
	}
	return fmt.Sprintf("SharingMode=%d", x)
}

// InternalAllocationType enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInternalAllocationType.html
type InternalAllocationType uint32

const (
	VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE InternalAllocationType = 0
)

var (
	reverseInternalAllocationType map[InternalAllocationType]string = map[InternalAllocationType]string{ 
		VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE: "VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE",
	}
)
func (x InternalAllocationType) String() string {
	if s, ok := reverseInternalAllocationType[x]; ok {
		return s
	}
	return fmt.Sprintf("InternalAllocationType=%d", x)
}

// DescriptorPoolCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolCreateFlagBits.html
type DescriptorPoolCreateFlagBits uint32

const (
	VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT DescriptorPoolCreateFlagBits = (1 << 0)
	VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT DescriptorPoolCreateFlagBits = (1 << 1)
)

var (
	reverseDescriptorPoolCreateFlagBits map[DescriptorPoolCreateFlagBits]string = map[DescriptorPoolCreateFlagBits]string{ 
		VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT: "VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT",
		VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT: "VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT",
	}
)
func (x DescriptorPoolCreateFlagBits) String() string {
	if s, ok := reverseDescriptorPoolCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("DescriptorPoolCreateFlagBits=%d", x)
}

// SubpassDescriptionFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDescriptionFlagBits.html
type SubpassDescriptionFlagBits uint32

// SamplerMipmapMode enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerMipmapMode.html
type SamplerMipmapMode uint32

const (
	VK_SAMPLER_MIPMAP_MODE_NEAREST SamplerMipmapMode = 0
	VK_SAMPLER_MIPMAP_MODE_LINEAR SamplerMipmapMode = 1
)

var (
	reverseSamplerMipmapMode map[SamplerMipmapMode]string = map[SamplerMipmapMode]string{ 
		VK_SAMPLER_MIPMAP_MODE_NEAREST: "VK_SAMPLER_MIPMAP_MODE_NEAREST",
		VK_SAMPLER_MIPMAP_MODE_LINEAR: "VK_SAMPLER_MIPMAP_MODE_LINEAR",
	}
)
func (x SamplerMipmapMode) String() string {
	if s, ok := reverseSamplerMipmapMode[x]; ok {
		return s
	}
	return fmt.Sprintf("SamplerMipmapMode=%d", x)
}

// CommandPoolCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolCreateFlagBits.html
type CommandPoolCreateFlagBits uint32

const (
	VK_COMMAND_POOL_CREATE_TRANSIENT_BIT CommandPoolCreateFlagBits = (1 << 0)
	VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT CommandPoolCreateFlagBits = (1 << 1)
	VK_COMMAND_POOL_CREATE_PROTECTED_BIT CommandPoolCreateFlagBits = (1 << 2)
)

var (
	reverseCommandPoolCreateFlagBits map[CommandPoolCreateFlagBits]string = map[CommandPoolCreateFlagBits]string{ 
		VK_COMMAND_POOL_CREATE_TRANSIENT_BIT: "VK_COMMAND_POOL_CREATE_TRANSIENT_BIT",
		VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT: "VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT",
		VK_COMMAND_POOL_CREATE_PROTECTED_BIT: "VK_COMMAND_POOL_CREATE_PROTECTED_BIT",
	}
)
func (x CommandPoolCreateFlagBits) String() string {
	if s, ok := reverseCommandPoolCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("CommandPoolCreateFlagBits=%d", x)
}

// SamplerCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerCreateFlagBits.html
type SamplerCreateFlagBits uint32

// SamplerAddressMode enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerAddressMode.html
type SamplerAddressMode uint32

const (
	VK_SAMPLER_ADDRESS_MODE_REPEAT SamplerAddressMode = 0
	VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT SamplerAddressMode = 1
	VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE SamplerAddressMode = 2
	VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER SamplerAddressMode = 3
	VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE SamplerAddressMode = 4
)

var (
	reverseSamplerAddressMode map[SamplerAddressMode]string = map[SamplerAddressMode]string{ 
		VK_SAMPLER_ADDRESS_MODE_REPEAT: "VK_SAMPLER_ADDRESS_MODE_REPEAT",
		VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT: "VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT",
		VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE: "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE",
		VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER: "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER",
		VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE: "VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE",
	}
)
func (x SamplerAddressMode) String() string {
	if s, ok := reverseSamplerAddressMode[x]; ok {
		return s
	}
	return fmt.Sprintf("SamplerAddressMode=%d", x)
}

// Format enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormat.html
type Format uint32

const (
	VK_FORMAT_UNDEFINED Format = 0
	VK_FORMAT_R4G4_UNORM_PACK8 Format = 1
	VK_FORMAT_R4G4B4A4_UNORM_PACK16 Format = 2
	VK_FORMAT_B4G4R4A4_UNORM_PACK16 Format = 3
	VK_FORMAT_R5G6B5_UNORM_PACK16 Format = 4
	VK_FORMAT_B5G6R5_UNORM_PACK16 Format = 5
	VK_FORMAT_R5G5B5A1_UNORM_PACK16 Format = 6
	VK_FORMAT_B5G5R5A1_UNORM_PACK16 Format = 7
	VK_FORMAT_A1R5G5B5_UNORM_PACK16 Format = 8
	VK_FORMAT_R8_UNORM Format = 9
	VK_FORMAT_R8_SNORM Format = 10
	VK_FORMAT_R8_USCALED Format = 11
	VK_FORMAT_R8_SSCALED Format = 12
	VK_FORMAT_R8_UINT Format = 13
	VK_FORMAT_R8_SINT Format = 14
	VK_FORMAT_R8_SRGB Format = 15
	VK_FORMAT_R8G8_UNORM Format = 16
	VK_FORMAT_R8G8_SNORM Format = 17
	VK_FORMAT_R8G8_USCALED Format = 18
	VK_FORMAT_R8G8_SSCALED Format = 19
	VK_FORMAT_R8G8_UINT Format = 20
	VK_FORMAT_R8G8_SINT Format = 21
	VK_FORMAT_R8G8_SRGB Format = 22
	VK_FORMAT_R8G8B8_UNORM Format = 23
	VK_FORMAT_R8G8B8_SNORM Format = 24
	VK_FORMAT_R8G8B8_USCALED Format = 25
	VK_FORMAT_R8G8B8_SSCALED Format = 26
	VK_FORMAT_R8G8B8_UINT Format = 27
	VK_FORMAT_R8G8B8_SINT Format = 28
	VK_FORMAT_R8G8B8_SRGB Format = 29
	VK_FORMAT_B8G8R8_UNORM Format = 30
	VK_FORMAT_B8G8R8_SNORM Format = 31
	VK_FORMAT_B8G8R8_USCALED Format = 32
	VK_FORMAT_B8G8R8_SSCALED Format = 33
	VK_FORMAT_B8G8R8_UINT Format = 34
	VK_FORMAT_B8G8R8_SINT Format = 35
	VK_FORMAT_B8G8R8_SRGB Format = 36
	VK_FORMAT_R8G8B8A8_UNORM Format = 37
	VK_FORMAT_R8G8B8A8_SNORM Format = 38
	VK_FORMAT_R8G8B8A8_USCALED Format = 39
	VK_FORMAT_R8G8B8A8_SSCALED Format = 40
	VK_FORMAT_R8G8B8A8_UINT Format = 41
	VK_FORMAT_R8G8B8A8_SINT Format = 42
	VK_FORMAT_R8G8B8A8_SRGB Format = 43
	VK_FORMAT_B8G8R8A8_UNORM Format = 44
	VK_FORMAT_B8G8R8A8_SNORM Format = 45
	VK_FORMAT_B8G8R8A8_USCALED Format = 46
	VK_FORMAT_B8G8R8A8_SSCALED Format = 47
	VK_FORMAT_B8G8R8A8_UINT Format = 48
	VK_FORMAT_B8G8R8A8_SINT Format = 49
	VK_FORMAT_B8G8R8A8_SRGB Format = 50
	VK_FORMAT_A8B8G8R8_UNORM_PACK32 Format = 51
	VK_FORMAT_A8B8G8R8_SNORM_PACK32 Format = 52
	VK_FORMAT_A8B8G8R8_USCALED_PACK32 Format = 53
	VK_FORMAT_A8B8G8R8_SSCALED_PACK32 Format = 54
	VK_FORMAT_A8B8G8R8_UINT_PACK32 Format = 55
	VK_FORMAT_A8B8G8R8_SINT_PACK32 Format = 56
	VK_FORMAT_A8B8G8R8_SRGB_PACK32 Format = 57
	VK_FORMAT_A2R10G10B10_UNORM_PACK32 Format = 58
	VK_FORMAT_A2R10G10B10_SNORM_PACK32 Format = 59
	VK_FORMAT_A2R10G10B10_USCALED_PACK32 Format = 60
	VK_FORMAT_A2R10G10B10_SSCALED_PACK32 Format = 61
	VK_FORMAT_A2R10G10B10_UINT_PACK32 Format = 62
	VK_FORMAT_A2R10G10B10_SINT_PACK32 Format = 63
	VK_FORMAT_A2B10G10R10_UNORM_PACK32 Format = 64
	VK_FORMAT_A2B10G10R10_SNORM_PACK32 Format = 65
	VK_FORMAT_A2B10G10R10_USCALED_PACK32 Format = 66
	VK_FORMAT_A2B10G10R10_SSCALED_PACK32 Format = 67
	VK_FORMAT_A2B10G10R10_UINT_PACK32 Format = 68
	VK_FORMAT_A2B10G10R10_SINT_PACK32 Format = 69
	VK_FORMAT_R16_UNORM Format = 70
	VK_FORMAT_R16_SNORM Format = 71
	VK_FORMAT_R16_USCALED Format = 72
	VK_FORMAT_R16_SSCALED Format = 73
	VK_FORMAT_R16_UINT Format = 74
	VK_FORMAT_R16_SINT Format = 75
	VK_FORMAT_R16_SFLOAT Format = 76
	VK_FORMAT_R16G16_UNORM Format = 77
	VK_FORMAT_R16G16_SNORM Format = 78
	VK_FORMAT_R16G16_USCALED Format = 79
	VK_FORMAT_R16G16_SSCALED Format = 80
	VK_FORMAT_R16G16_UINT Format = 81
	VK_FORMAT_R16G16_SINT Format = 82
	VK_FORMAT_R16G16_SFLOAT Format = 83
	VK_FORMAT_R16G16B16_UNORM Format = 84
	VK_FORMAT_R16G16B16_SNORM Format = 85
	VK_FORMAT_R16G16B16_USCALED Format = 86
	VK_FORMAT_R16G16B16_SSCALED Format = 87
	VK_FORMAT_R16G16B16_UINT Format = 88
	VK_FORMAT_R16G16B16_SINT Format = 89
	VK_FORMAT_R16G16B16_SFLOAT Format = 90
	VK_FORMAT_R16G16B16A16_UNORM Format = 91
	VK_FORMAT_R16G16B16A16_SNORM Format = 92
	VK_FORMAT_R16G16B16A16_USCALED Format = 93
	VK_FORMAT_R16G16B16A16_SSCALED Format = 94
	VK_FORMAT_R16G16B16A16_UINT Format = 95
	VK_FORMAT_R16G16B16A16_SINT Format = 96
	VK_FORMAT_R16G16B16A16_SFLOAT Format = 97
	VK_FORMAT_R32_UINT Format = 98
	VK_FORMAT_R32_SINT Format = 99
	VK_FORMAT_R32_SFLOAT Format = 100
	VK_FORMAT_R32G32_UINT Format = 101
	VK_FORMAT_R32G32_SINT Format = 102
	VK_FORMAT_R32G32_SFLOAT Format = 103
	VK_FORMAT_R32G32B32_UINT Format = 104
	VK_FORMAT_R32G32B32_SINT Format = 105
	VK_FORMAT_R32G32B32_SFLOAT Format = 106
	VK_FORMAT_R32G32B32A32_UINT Format = 107
	VK_FORMAT_R32G32B32A32_SINT Format = 108
	VK_FORMAT_R32G32B32A32_SFLOAT Format = 109
	VK_FORMAT_R64_UINT Format = 110
	VK_FORMAT_R64_SINT Format = 111
	VK_FORMAT_R64_SFLOAT Format = 112
	VK_FORMAT_R64G64_UINT Format = 113
	VK_FORMAT_R64G64_SINT Format = 114
	VK_FORMAT_R64G64_SFLOAT Format = 115
	VK_FORMAT_R64G64B64_UINT Format = 116
	VK_FORMAT_R64G64B64_SINT Format = 117
	VK_FORMAT_R64G64B64_SFLOAT Format = 118
	VK_FORMAT_R64G64B64A64_UINT Format = 119
	VK_FORMAT_R64G64B64A64_SINT Format = 120
	VK_FORMAT_R64G64B64A64_SFLOAT Format = 121
	VK_FORMAT_B10G11R11_UFLOAT_PACK32 Format = 122
	VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 Format = 123
	VK_FORMAT_D16_UNORM Format = 124
	VK_FORMAT_X8_D24_UNORM_PACK32 Format = 125
	VK_FORMAT_D32_SFLOAT Format = 126
	VK_FORMAT_S8_UINT Format = 127
	VK_FORMAT_D16_UNORM_S8_UINT Format = 128
	VK_FORMAT_D24_UNORM_S8_UINT Format = 129
	VK_FORMAT_D32_SFLOAT_S8_UINT Format = 130
	VK_FORMAT_BC1_RGB_UNORM_BLOCK Format = 131
	VK_FORMAT_BC1_RGB_SRGB_BLOCK Format = 132
	VK_FORMAT_BC1_RGBA_UNORM_BLOCK Format = 133
	VK_FORMAT_BC1_RGBA_SRGB_BLOCK Format = 134
	VK_FORMAT_BC2_UNORM_BLOCK Format = 135
	VK_FORMAT_BC2_SRGB_BLOCK Format = 136
	VK_FORMAT_BC3_UNORM_BLOCK Format = 137
	VK_FORMAT_BC3_SRGB_BLOCK Format = 138
	VK_FORMAT_BC4_UNORM_BLOCK Format = 139
	VK_FORMAT_BC4_SNORM_BLOCK Format = 140
	VK_FORMAT_BC5_UNORM_BLOCK Format = 141
	VK_FORMAT_BC5_SNORM_BLOCK Format = 142
	VK_FORMAT_BC6H_UFLOAT_BLOCK Format = 143
	VK_FORMAT_BC6H_SFLOAT_BLOCK Format = 144
	VK_FORMAT_BC7_UNORM_BLOCK Format = 145
	VK_FORMAT_BC7_SRGB_BLOCK Format = 146
	VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK Format = 147
	VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK Format = 148
	VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK Format = 149
	VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK Format = 150
	VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK Format = 151
	VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK Format = 152
	VK_FORMAT_EAC_R11_UNORM_BLOCK Format = 153
	VK_FORMAT_EAC_R11_SNORM_BLOCK Format = 154
	VK_FORMAT_EAC_R11G11_UNORM_BLOCK Format = 155
	VK_FORMAT_EAC_R11G11_SNORM_BLOCK Format = 156
	VK_FORMAT_ASTC_4x4_UNORM_BLOCK Format = 157
	VK_FORMAT_ASTC_4x4_SRGB_BLOCK Format = 158
	VK_FORMAT_ASTC_5x4_UNORM_BLOCK Format = 159
	VK_FORMAT_ASTC_5x4_SRGB_BLOCK Format = 160
	VK_FORMAT_ASTC_5x5_UNORM_BLOCK Format = 161
	VK_FORMAT_ASTC_5x5_SRGB_BLOCK Format = 162
	VK_FORMAT_ASTC_6x5_UNORM_BLOCK Format = 163
	VK_FORMAT_ASTC_6x5_SRGB_BLOCK Format = 164
	VK_FORMAT_ASTC_6x6_UNORM_BLOCK Format = 165
	VK_FORMAT_ASTC_6x6_SRGB_BLOCK Format = 166
	VK_FORMAT_ASTC_8x5_UNORM_BLOCK Format = 167
	VK_FORMAT_ASTC_8x5_SRGB_BLOCK Format = 168
	VK_FORMAT_ASTC_8x6_UNORM_BLOCK Format = 169
	VK_FORMAT_ASTC_8x6_SRGB_BLOCK Format = 170
	VK_FORMAT_ASTC_8x8_UNORM_BLOCK Format = 171
	VK_FORMAT_ASTC_8x8_SRGB_BLOCK Format = 172
	VK_FORMAT_ASTC_10x5_UNORM_BLOCK Format = 173
	VK_FORMAT_ASTC_10x5_SRGB_BLOCK Format = 174
	VK_FORMAT_ASTC_10x6_UNORM_BLOCK Format = 175
	VK_FORMAT_ASTC_10x6_SRGB_BLOCK Format = 176
	VK_FORMAT_ASTC_10x8_UNORM_BLOCK Format = 177
	VK_FORMAT_ASTC_10x8_SRGB_BLOCK Format = 178
	VK_FORMAT_ASTC_10x10_UNORM_BLOCK Format = 179
	VK_FORMAT_ASTC_10x10_SRGB_BLOCK Format = 180
	VK_FORMAT_ASTC_12x10_UNORM_BLOCK Format = 181
	VK_FORMAT_ASTC_12x10_SRGB_BLOCK Format = 182
	VK_FORMAT_ASTC_12x12_UNORM_BLOCK Format = 183
	VK_FORMAT_ASTC_12x12_SRGB_BLOCK Format = 184
	VK_FORMAT_G8B8G8R8_422_UNORM Format = 1000156000
	VK_FORMAT_B8G8R8G8_422_UNORM Format = 1000156001
	VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM Format = 1000156002
	VK_FORMAT_G8_B8R8_2PLANE_420_UNORM Format = 1000156003
	VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM Format = 1000156004
	VK_FORMAT_G8_B8R8_2PLANE_422_UNORM Format = 1000156005
	VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM Format = 1000156006
	VK_FORMAT_R10X6_UNORM_PACK16 Format = 1000156007
	VK_FORMAT_R10X6G10X6_UNORM_2PACK16 Format = 1000156008
	VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 Format = 1000156009
	VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 Format = 1000156010
	VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 Format = 1000156011
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 Format = 1000156012
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 Format = 1000156013
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 Format = 1000156014
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 Format = 1000156015
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 Format = 1000156016
	VK_FORMAT_R12X4_UNORM_PACK16 Format = 1000156017
	VK_FORMAT_R12X4G12X4_UNORM_2PACK16 Format = 1000156018
	VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 Format = 1000156019
	VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 Format = 1000156020
	VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 Format = 1000156021
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 Format = 1000156022
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 Format = 1000156023
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 Format = 1000156024
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 Format = 1000156025
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 Format = 1000156026
	VK_FORMAT_G16B16G16R16_422_UNORM Format = 1000156027
	VK_FORMAT_B16G16R16G16_422_UNORM Format = 1000156028
	VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM Format = 1000156029
	VK_FORMAT_G16_B16R16_2PLANE_420_UNORM Format = 1000156030
	VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM Format = 1000156031
	VK_FORMAT_G16_B16R16_2PLANE_422_UNORM Format = 1000156032
	VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM Format = 1000156033
	VK_FORMAT_G8_B8R8_2PLANE_444_UNORM Format = 1000330000
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16 Format = 1000330001
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16 Format = 1000330002
	VK_FORMAT_G16_B16R16_2PLANE_444_UNORM Format = 1000330003
	VK_FORMAT_A4R4G4B4_UNORM_PACK16 Format = 1000340000
	VK_FORMAT_A4B4G4R4_UNORM_PACK16 Format = 1000340001
	VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK Format = 1000066000
	VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK Format = 1000066001
	VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK Format = 1000066002
	VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK Format = 1000066003
	VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK Format = 1000066004
	VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK Format = 1000066005
	VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK Format = 1000066006
	VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK Format = 1000066007
	VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK Format = 1000066008
	VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK Format = 1000066009
	VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK Format = 1000066010
	VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK Format = 1000066011
	VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK Format = 1000066012
	VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK Format = 1000066013
)

var (
	reverseFormat map[Format]string = map[Format]string{ 
		VK_FORMAT_UNDEFINED: "VK_FORMAT_UNDEFINED",
		VK_FORMAT_R4G4_UNORM_PACK8: "VK_FORMAT_R4G4_UNORM_PACK8",
		VK_FORMAT_R4G4B4A4_UNORM_PACK16: "VK_FORMAT_R4G4B4A4_UNORM_PACK16",
		VK_FORMAT_B4G4R4A4_UNORM_PACK16: "VK_FORMAT_B4G4R4A4_UNORM_PACK16",
		VK_FORMAT_R5G6B5_UNORM_PACK16: "VK_FORMAT_R5G6B5_UNORM_PACK16",
		VK_FORMAT_B5G6R5_UNORM_PACK16: "VK_FORMAT_B5G6R5_UNORM_PACK16",
		VK_FORMAT_R5G5B5A1_UNORM_PACK16: "VK_FORMAT_R5G5B5A1_UNORM_PACK16",
		VK_FORMAT_B5G5R5A1_UNORM_PACK16: "VK_FORMAT_B5G5R5A1_UNORM_PACK16",
		VK_FORMAT_A1R5G5B5_UNORM_PACK16: "VK_FORMAT_A1R5G5B5_UNORM_PACK16",
		VK_FORMAT_R8_UNORM: "VK_FORMAT_R8_UNORM",
		VK_FORMAT_R8_SNORM: "VK_FORMAT_R8_SNORM",
		VK_FORMAT_R8_USCALED: "VK_FORMAT_R8_USCALED",
		VK_FORMAT_R8_SSCALED: "VK_FORMAT_R8_SSCALED",
		VK_FORMAT_R8_UINT: "VK_FORMAT_R8_UINT",
		VK_FORMAT_R8_SINT: "VK_FORMAT_R8_SINT",
		VK_FORMAT_R8_SRGB: "VK_FORMAT_R8_SRGB",
		VK_FORMAT_R8G8_UNORM: "VK_FORMAT_R8G8_UNORM",
		VK_FORMAT_R8G8_SNORM: "VK_FORMAT_R8G8_SNORM",
		VK_FORMAT_R8G8_USCALED: "VK_FORMAT_R8G8_USCALED",
		VK_FORMAT_R8G8_SSCALED: "VK_FORMAT_R8G8_SSCALED",
		VK_FORMAT_R8G8_UINT: "VK_FORMAT_R8G8_UINT",
		VK_FORMAT_R8G8_SINT: "VK_FORMAT_R8G8_SINT",
		VK_FORMAT_R8G8_SRGB: "VK_FORMAT_R8G8_SRGB",
		VK_FORMAT_R8G8B8_UNORM: "VK_FORMAT_R8G8B8_UNORM",
		VK_FORMAT_R8G8B8_SNORM: "VK_FORMAT_R8G8B8_SNORM",
		VK_FORMAT_R8G8B8_USCALED: "VK_FORMAT_R8G8B8_USCALED",
		VK_FORMAT_R8G8B8_SSCALED: "VK_FORMAT_R8G8B8_SSCALED",
		VK_FORMAT_R8G8B8_UINT: "VK_FORMAT_R8G8B8_UINT",
		VK_FORMAT_R8G8B8_SINT: "VK_FORMAT_R8G8B8_SINT",
		VK_FORMAT_R8G8B8_SRGB: "VK_FORMAT_R8G8B8_SRGB",
		VK_FORMAT_B8G8R8_UNORM: "VK_FORMAT_B8G8R8_UNORM",
		VK_FORMAT_B8G8R8_SNORM: "VK_FORMAT_B8G8R8_SNORM",
		VK_FORMAT_B8G8R8_USCALED: "VK_FORMAT_B8G8R8_USCALED",
		VK_FORMAT_B8G8R8_SSCALED: "VK_FORMAT_B8G8R8_SSCALED",
		VK_FORMAT_B8G8R8_UINT: "VK_FORMAT_B8G8R8_UINT",
		VK_FORMAT_B8G8R8_SINT: "VK_FORMAT_B8G8R8_SINT",
		VK_FORMAT_B8G8R8_SRGB: "VK_FORMAT_B8G8R8_SRGB",
		VK_FORMAT_R8G8B8A8_UNORM: "VK_FORMAT_R8G8B8A8_UNORM",
		VK_FORMAT_R8G8B8A8_SNORM: "VK_FORMAT_R8G8B8A8_SNORM",
		VK_FORMAT_R8G8B8A8_USCALED: "VK_FORMAT_R8G8B8A8_USCALED",
		VK_FORMAT_R8G8B8A8_SSCALED: "VK_FORMAT_R8G8B8A8_SSCALED",
		VK_FORMAT_R8G8B8A8_UINT: "VK_FORMAT_R8G8B8A8_UINT",
		VK_FORMAT_R8G8B8A8_SINT: "VK_FORMAT_R8G8B8A8_SINT",
		VK_FORMAT_R8G8B8A8_SRGB: "VK_FORMAT_R8G8B8A8_SRGB",
		VK_FORMAT_B8G8R8A8_UNORM: "VK_FORMAT_B8G8R8A8_UNORM",
		VK_FORMAT_B8G8R8A8_SNORM: "VK_FORMAT_B8G8R8A8_SNORM",
		VK_FORMAT_B8G8R8A8_USCALED: "VK_FORMAT_B8G8R8A8_USCALED",
		VK_FORMAT_B8G8R8A8_SSCALED: "VK_FORMAT_B8G8R8A8_SSCALED",
		VK_FORMAT_B8G8R8A8_UINT: "VK_FORMAT_B8G8R8A8_UINT",
		VK_FORMAT_B8G8R8A8_SINT: "VK_FORMAT_B8G8R8A8_SINT",
		VK_FORMAT_B8G8R8A8_SRGB: "VK_FORMAT_B8G8R8A8_SRGB",
		VK_FORMAT_A8B8G8R8_UNORM_PACK32: "VK_FORMAT_A8B8G8R8_UNORM_PACK32",
		VK_FORMAT_A8B8G8R8_SNORM_PACK32: "VK_FORMAT_A8B8G8R8_SNORM_PACK32",
		VK_FORMAT_A8B8G8R8_USCALED_PACK32: "VK_FORMAT_A8B8G8R8_USCALED_PACK32",
		VK_FORMAT_A8B8G8R8_SSCALED_PACK32: "VK_FORMAT_A8B8G8R8_SSCALED_PACK32",
		VK_FORMAT_A8B8G8R8_UINT_PACK32: "VK_FORMAT_A8B8G8R8_UINT_PACK32",
		VK_FORMAT_A8B8G8R8_SINT_PACK32: "VK_FORMAT_A8B8G8R8_SINT_PACK32",
		VK_FORMAT_A8B8G8R8_SRGB_PACK32: "VK_FORMAT_A8B8G8R8_SRGB_PACK32",
		VK_FORMAT_A2R10G10B10_UNORM_PACK32: "VK_FORMAT_A2R10G10B10_UNORM_PACK32",
		VK_FORMAT_A2R10G10B10_SNORM_PACK32: "VK_FORMAT_A2R10G10B10_SNORM_PACK32",
		VK_FORMAT_A2R10G10B10_USCALED_PACK32: "VK_FORMAT_A2R10G10B10_USCALED_PACK32",
		VK_FORMAT_A2R10G10B10_SSCALED_PACK32: "VK_FORMAT_A2R10G10B10_SSCALED_PACK32",
		VK_FORMAT_A2R10G10B10_UINT_PACK32: "VK_FORMAT_A2R10G10B10_UINT_PACK32",
		VK_FORMAT_A2R10G10B10_SINT_PACK32: "VK_FORMAT_A2R10G10B10_SINT_PACK32",
		VK_FORMAT_A2B10G10R10_UNORM_PACK32: "VK_FORMAT_A2B10G10R10_UNORM_PACK32",
		VK_FORMAT_A2B10G10R10_SNORM_PACK32: "VK_FORMAT_A2B10G10R10_SNORM_PACK32",
		VK_FORMAT_A2B10G10R10_USCALED_PACK32: "VK_FORMAT_A2B10G10R10_USCALED_PACK32",
		VK_FORMAT_A2B10G10R10_SSCALED_PACK32: "VK_FORMAT_A2B10G10R10_SSCALED_PACK32",
		VK_FORMAT_A2B10G10R10_UINT_PACK32: "VK_FORMAT_A2B10G10R10_UINT_PACK32",
		VK_FORMAT_A2B10G10R10_SINT_PACK32: "VK_FORMAT_A2B10G10R10_SINT_PACK32",
		VK_FORMAT_R16_UNORM: "VK_FORMAT_R16_UNORM",
		VK_FORMAT_R16_SNORM: "VK_FORMAT_R16_SNORM",
		VK_FORMAT_R16_USCALED: "VK_FORMAT_R16_USCALED",
		VK_FORMAT_R16_SSCALED: "VK_FORMAT_R16_SSCALED",
		VK_FORMAT_R16_UINT: "VK_FORMAT_R16_UINT",
		VK_FORMAT_R16_SINT: "VK_FORMAT_R16_SINT",
		VK_FORMAT_R16_SFLOAT: "VK_FORMAT_R16_SFLOAT",
		VK_FORMAT_R16G16_UNORM: "VK_FORMAT_R16G16_UNORM",
		VK_FORMAT_R16G16_SNORM: "VK_FORMAT_R16G16_SNORM",
		VK_FORMAT_R16G16_USCALED: "VK_FORMAT_R16G16_USCALED",
		VK_FORMAT_R16G16_SSCALED: "VK_FORMAT_R16G16_SSCALED",
		VK_FORMAT_R16G16_UINT: "VK_FORMAT_R16G16_UINT",
		VK_FORMAT_R16G16_SINT: "VK_FORMAT_R16G16_SINT",
		VK_FORMAT_R16G16_SFLOAT: "VK_FORMAT_R16G16_SFLOAT",
		VK_FORMAT_R16G16B16_UNORM: "VK_FORMAT_R16G16B16_UNORM",
		VK_FORMAT_R16G16B16_SNORM: "VK_FORMAT_R16G16B16_SNORM",
		VK_FORMAT_R16G16B16_USCALED: "VK_FORMAT_R16G16B16_USCALED",
		VK_FORMAT_R16G16B16_SSCALED: "VK_FORMAT_R16G16B16_SSCALED",
		VK_FORMAT_R16G16B16_UINT: "VK_FORMAT_R16G16B16_UINT",
		VK_FORMAT_R16G16B16_SINT: "VK_FORMAT_R16G16B16_SINT",
		VK_FORMAT_R16G16B16_SFLOAT: "VK_FORMAT_R16G16B16_SFLOAT",
		VK_FORMAT_R16G16B16A16_UNORM: "VK_FORMAT_R16G16B16A16_UNORM",
		VK_FORMAT_R16G16B16A16_SNORM: "VK_FORMAT_R16G16B16A16_SNORM",
		VK_FORMAT_R16G16B16A16_USCALED: "VK_FORMAT_R16G16B16A16_USCALED",
		VK_FORMAT_R16G16B16A16_SSCALED: "VK_FORMAT_R16G16B16A16_SSCALED",
		VK_FORMAT_R16G16B16A16_UINT: "VK_FORMAT_R16G16B16A16_UINT",
		VK_FORMAT_R16G16B16A16_SINT: "VK_FORMAT_R16G16B16A16_SINT",
		VK_FORMAT_R16G16B16A16_SFLOAT: "VK_FORMAT_R16G16B16A16_SFLOAT",
		VK_FORMAT_R32_UINT: "VK_FORMAT_R32_UINT",
		VK_FORMAT_R32_SINT: "VK_FORMAT_R32_SINT",
		VK_FORMAT_R32_SFLOAT: "VK_FORMAT_R32_SFLOAT",
		VK_FORMAT_R32G32_UINT: "VK_FORMAT_R32G32_UINT",
		VK_FORMAT_R32G32_SINT: "VK_FORMAT_R32G32_SINT",
		VK_FORMAT_R32G32_SFLOAT: "VK_FORMAT_R32G32_SFLOAT",
		VK_FORMAT_R32G32B32_UINT: "VK_FORMAT_R32G32B32_UINT",
		VK_FORMAT_R32G32B32_SINT: "VK_FORMAT_R32G32B32_SINT",
		VK_FORMAT_R32G32B32_SFLOAT: "VK_FORMAT_R32G32B32_SFLOAT",
		VK_FORMAT_R32G32B32A32_UINT: "VK_FORMAT_R32G32B32A32_UINT",
		VK_FORMAT_R32G32B32A32_SINT: "VK_FORMAT_R32G32B32A32_SINT",
		VK_FORMAT_R32G32B32A32_SFLOAT: "VK_FORMAT_R32G32B32A32_SFLOAT",
		VK_FORMAT_R64_UINT: "VK_FORMAT_R64_UINT",
		VK_FORMAT_R64_SINT: "VK_FORMAT_R64_SINT",
		VK_FORMAT_R64_SFLOAT: "VK_FORMAT_R64_SFLOAT",
		VK_FORMAT_R64G64_UINT: "VK_FORMAT_R64G64_UINT",
		VK_FORMAT_R64G64_SINT: "VK_FORMAT_R64G64_SINT",
		VK_FORMAT_R64G64_SFLOAT: "VK_FORMAT_R64G64_SFLOAT",
		VK_FORMAT_R64G64B64_UINT: "VK_FORMAT_R64G64B64_UINT",
		VK_FORMAT_R64G64B64_SINT: "VK_FORMAT_R64G64B64_SINT",
		VK_FORMAT_R64G64B64_SFLOAT: "VK_FORMAT_R64G64B64_SFLOAT",
		VK_FORMAT_R64G64B64A64_UINT: "VK_FORMAT_R64G64B64A64_UINT",
		VK_FORMAT_R64G64B64A64_SINT: "VK_FORMAT_R64G64B64A64_SINT",
		VK_FORMAT_R64G64B64A64_SFLOAT: "VK_FORMAT_R64G64B64A64_SFLOAT",
		VK_FORMAT_B10G11R11_UFLOAT_PACK32: "VK_FORMAT_B10G11R11_UFLOAT_PACK32",
		VK_FORMAT_E5B9G9R9_UFLOAT_PACK32: "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32",
		VK_FORMAT_D16_UNORM: "VK_FORMAT_D16_UNORM",
		VK_FORMAT_X8_D24_UNORM_PACK32: "VK_FORMAT_X8_D24_UNORM_PACK32",
		VK_FORMAT_D32_SFLOAT: "VK_FORMAT_D32_SFLOAT",
		VK_FORMAT_S8_UINT: "VK_FORMAT_S8_UINT",
		VK_FORMAT_D16_UNORM_S8_UINT: "VK_FORMAT_D16_UNORM_S8_UINT",
		VK_FORMAT_D24_UNORM_S8_UINT: "VK_FORMAT_D24_UNORM_S8_UINT",
		VK_FORMAT_D32_SFLOAT_S8_UINT: "VK_FORMAT_D32_SFLOAT_S8_UINT",
		VK_FORMAT_BC1_RGB_UNORM_BLOCK: "VK_FORMAT_BC1_RGB_UNORM_BLOCK",
		VK_FORMAT_BC1_RGB_SRGB_BLOCK: "VK_FORMAT_BC1_RGB_SRGB_BLOCK",
		VK_FORMAT_BC1_RGBA_UNORM_BLOCK: "VK_FORMAT_BC1_RGBA_UNORM_BLOCK",
		VK_FORMAT_BC1_RGBA_SRGB_BLOCK: "VK_FORMAT_BC1_RGBA_SRGB_BLOCK",
		VK_FORMAT_BC2_UNORM_BLOCK: "VK_FORMAT_BC2_UNORM_BLOCK",
		VK_FORMAT_BC2_SRGB_BLOCK: "VK_FORMAT_BC2_SRGB_BLOCK",
		VK_FORMAT_BC3_UNORM_BLOCK: "VK_FORMAT_BC3_UNORM_BLOCK",
		VK_FORMAT_BC3_SRGB_BLOCK: "VK_FORMAT_BC3_SRGB_BLOCK",
		VK_FORMAT_BC4_UNORM_BLOCK: "VK_FORMAT_BC4_UNORM_BLOCK",
		VK_FORMAT_BC4_SNORM_BLOCK: "VK_FORMAT_BC4_SNORM_BLOCK",
		VK_FORMAT_BC5_UNORM_BLOCK: "VK_FORMAT_BC5_UNORM_BLOCK",
		VK_FORMAT_BC5_SNORM_BLOCK: "VK_FORMAT_BC5_SNORM_BLOCK",
		VK_FORMAT_BC6H_UFLOAT_BLOCK: "VK_FORMAT_BC6H_UFLOAT_BLOCK",
		VK_FORMAT_BC6H_SFLOAT_BLOCK: "VK_FORMAT_BC6H_SFLOAT_BLOCK",
		VK_FORMAT_BC7_UNORM_BLOCK: "VK_FORMAT_BC7_UNORM_BLOCK",
		VK_FORMAT_BC7_SRGB_BLOCK: "VK_FORMAT_BC7_SRGB_BLOCK",
		VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK: "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK",
		VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK: "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK",
		VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK: "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK",
		VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK: "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK",
		VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK: "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK",
		VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK: "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK",
		VK_FORMAT_EAC_R11_UNORM_BLOCK: "VK_FORMAT_EAC_R11_UNORM_BLOCK",
		VK_FORMAT_EAC_R11_SNORM_BLOCK: "VK_FORMAT_EAC_R11_SNORM_BLOCK",
		VK_FORMAT_EAC_R11G11_UNORM_BLOCK: "VK_FORMAT_EAC_R11G11_UNORM_BLOCK",
		VK_FORMAT_EAC_R11G11_SNORM_BLOCK: "VK_FORMAT_EAC_R11G11_SNORM_BLOCK",
		VK_FORMAT_ASTC_4x4_UNORM_BLOCK: "VK_FORMAT_ASTC_4x4_UNORM_BLOCK",
		VK_FORMAT_ASTC_4x4_SRGB_BLOCK: "VK_FORMAT_ASTC_4x4_SRGB_BLOCK",
		VK_FORMAT_ASTC_5x4_UNORM_BLOCK: "VK_FORMAT_ASTC_5x4_UNORM_BLOCK",
		VK_FORMAT_ASTC_5x4_SRGB_BLOCK: "VK_FORMAT_ASTC_5x4_SRGB_BLOCK",
		VK_FORMAT_ASTC_5x5_UNORM_BLOCK: "VK_FORMAT_ASTC_5x5_UNORM_BLOCK",
		VK_FORMAT_ASTC_5x5_SRGB_BLOCK: "VK_FORMAT_ASTC_5x5_SRGB_BLOCK",
		VK_FORMAT_ASTC_6x5_UNORM_BLOCK: "VK_FORMAT_ASTC_6x5_UNORM_BLOCK",
		VK_FORMAT_ASTC_6x5_SRGB_BLOCK: "VK_FORMAT_ASTC_6x5_SRGB_BLOCK",
		VK_FORMAT_ASTC_6x6_UNORM_BLOCK: "VK_FORMAT_ASTC_6x6_UNORM_BLOCK",
		VK_FORMAT_ASTC_6x6_SRGB_BLOCK: "VK_FORMAT_ASTC_6x6_SRGB_BLOCK",
		VK_FORMAT_ASTC_8x5_UNORM_BLOCK: "VK_FORMAT_ASTC_8x5_UNORM_BLOCK",
		VK_FORMAT_ASTC_8x5_SRGB_BLOCK: "VK_FORMAT_ASTC_8x5_SRGB_BLOCK",
		VK_FORMAT_ASTC_8x6_UNORM_BLOCK: "VK_FORMAT_ASTC_8x6_UNORM_BLOCK",
		VK_FORMAT_ASTC_8x6_SRGB_BLOCK: "VK_FORMAT_ASTC_8x6_SRGB_BLOCK",
		VK_FORMAT_ASTC_8x8_UNORM_BLOCK: "VK_FORMAT_ASTC_8x8_UNORM_BLOCK",
		VK_FORMAT_ASTC_8x8_SRGB_BLOCK: "VK_FORMAT_ASTC_8x8_SRGB_BLOCK",
		VK_FORMAT_ASTC_10x5_UNORM_BLOCK: "VK_FORMAT_ASTC_10x5_UNORM_BLOCK",
		VK_FORMAT_ASTC_10x5_SRGB_BLOCK: "VK_FORMAT_ASTC_10x5_SRGB_BLOCK",
		VK_FORMAT_ASTC_10x6_UNORM_BLOCK: "VK_FORMAT_ASTC_10x6_UNORM_BLOCK",
		VK_FORMAT_ASTC_10x6_SRGB_BLOCK: "VK_FORMAT_ASTC_10x6_SRGB_BLOCK",
		VK_FORMAT_ASTC_10x8_UNORM_BLOCK: "VK_FORMAT_ASTC_10x8_UNORM_BLOCK",
		VK_FORMAT_ASTC_10x8_SRGB_BLOCK: "VK_FORMAT_ASTC_10x8_SRGB_BLOCK",
		VK_FORMAT_ASTC_10x10_UNORM_BLOCK: "VK_FORMAT_ASTC_10x10_UNORM_BLOCK",
		VK_FORMAT_ASTC_10x10_SRGB_BLOCK: "VK_FORMAT_ASTC_10x10_SRGB_BLOCK",
		VK_FORMAT_ASTC_12x10_UNORM_BLOCK: "VK_FORMAT_ASTC_12x10_UNORM_BLOCK",
		VK_FORMAT_ASTC_12x10_SRGB_BLOCK: "VK_FORMAT_ASTC_12x10_SRGB_BLOCK",
		VK_FORMAT_ASTC_12x12_UNORM_BLOCK: "VK_FORMAT_ASTC_12x12_UNORM_BLOCK",
		VK_FORMAT_ASTC_12x12_SRGB_BLOCK: "VK_FORMAT_ASTC_12x12_SRGB_BLOCK",
		VK_FORMAT_G8B8G8R8_422_UNORM: "VK_FORMAT_G8B8G8R8_422_UNORM",
		VK_FORMAT_B8G8R8G8_422_UNORM: "VK_FORMAT_B8G8R8G8_422_UNORM",
		VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM: "VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM",
		VK_FORMAT_G8_B8R8_2PLANE_420_UNORM: "VK_FORMAT_G8_B8R8_2PLANE_420_UNORM",
		VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM: "VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM",
		VK_FORMAT_G8_B8R8_2PLANE_422_UNORM: "VK_FORMAT_G8_B8R8_2PLANE_422_UNORM",
		VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM: "VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM",
		VK_FORMAT_R10X6_UNORM_PACK16: "VK_FORMAT_R10X6_UNORM_PACK16",
		VK_FORMAT_R10X6G10X6_UNORM_2PACK16: "VK_FORMAT_R10X6G10X6_UNORM_2PACK16",
		VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16: "VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16",
		VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16: "VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16",
		VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16: "VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16",
		VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16: "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16",
		VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16: "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16",
		VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16: "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16",
		VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16: "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16",
		VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16: "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16",
		VK_FORMAT_R12X4_UNORM_PACK16: "VK_FORMAT_R12X4_UNORM_PACK16",
		VK_FORMAT_R12X4G12X4_UNORM_2PACK16: "VK_FORMAT_R12X4G12X4_UNORM_2PACK16",
		VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16: "VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16",
		VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16: "VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16",
		VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16: "VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16",
		VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16: "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16",
		VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16: "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16",
		VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16: "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16",
		VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16: "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16",
		VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16: "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16",
		VK_FORMAT_G16B16G16R16_422_UNORM: "VK_FORMAT_G16B16G16R16_422_UNORM",
		VK_FORMAT_B16G16R16G16_422_UNORM: "VK_FORMAT_B16G16R16G16_422_UNORM",
		VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM: "VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM",
		VK_FORMAT_G16_B16R16_2PLANE_420_UNORM: "VK_FORMAT_G16_B16R16_2PLANE_420_UNORM",
		VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM: "VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM",
		VK_FORMAT_G16_B16R16_2PLANE_422_UNORM: "VK_FORMAT_G16_B16R16_2PLANE_422_UNORM",
		VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM: "VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM",
		VK_FORMAT_G8_B8R8_2PLANE_444_UNORM: "VK_FORMAT_G8_B8R8_2PLANE_444_UNORM",
		VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16: "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16",
		VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16: "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16",
		VK_FORMAT_G16_B16R16_2PLANE_444_UNORM: "VK_FORMAT_G16_B16R16_2PLANE_444_UNORM",
		VK_FORMAT_A4R4G4B4_UNORM_PACK16: "VK_FORMAT_A4R4G4B4_UNORM_PACK16",
		VK_FORMAT_A4B4G4R4_UNORM_PACK16: "VK_FORMAT_A4B4G4R4_UNORM_PACK16",
		VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK: "VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK",
		VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK: "VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK",
		VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK: "VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK",
		VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK: "VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK",
		VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK: "VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK",
		VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK: "VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK",
		VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK: "VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK",
		VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK: "VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK",
		VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK: "VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK",
		VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK: "VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK",
		VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK: "VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK",
		VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK: "VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK",
		VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK: "VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK",
		VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK: "VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK",
	}
)
func (x Format) String() string {
	if s, ok := reverseFormat[x]; ok {
		return s
	}
	return fmt.Sprintf("Format=%d", x)
}

// FormatFeatureFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatFeatureFlagBits.html
type FormatFeatureFlagBits uint32

const (
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT FormatFeatureFlagBits = (1 << 0)
	VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT FormatFeatureFlagBits = (1 << 1)
	VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT FormatFeatureFlagBits = (1 << 2)
	VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT FormatFeatureFlagBits = (1 << 3)
	VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT FormatFeatureFlagBits = (1 << 4)
	VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT FormatFeatureFlagBits = (1 << 5)
	VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT FormatFeatureFlagBits = (1 << 6)
	VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT FormatFeatureFlagBits = (1 << 7)
	VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT FormatFeatureFlagBits = (1 << 8)
	VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT FormatFeatureFlagBits = (1 << 9)
	VK_FORMAT_FEATURE_BLIT_SRC_BIT FormatFeatureFlagBits = (1 << 10)
	VK_FORMAT_FEATURE_BLIT_DST_BIT FormatFeatureFlagBits = (1 << 11)
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT FormatFeatureFlagBits = (1 << 12)
	VK_FORMAT_FEATURE_TRANSFER_SRC_BIT FormatFeatureFlagBits = (1 << 14)
	VK_FORMAT_FEATURE_TRANSFER_DST_BIT FormatFeatureFlagBits = (1 << 15)
	VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT FormatFeatureFlagBits = (1 << 17)
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT FormatFeatureFlagBits = (1 << 18)
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT FormatFeatureFlagBits = (1 << 19)
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT FormatFeatureFlagBits = (1 << 20)
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT FormatFeatureFlagBits = (1 << 21)
	VK_FORMAT_FEATURE_DISJOINT_BIT FormatFeatureFlagBits = (1 << 22)
	VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT FormatFeatureFlagBits = (1 << 23)
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT FormatFeatureFlagBits = (1 << 16)
)

var (
	reverseFormatFeatureFlagBits map[FormatFeatureFlagBits]string = map[FormatFeatureFlagBits]string{ 
		VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT: "VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT",
		VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT: "VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT",
		VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT: "VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT",
		VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT: "VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT",
		VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT: "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT",
		VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT: "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT",
		VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT: "VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT",
		VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT: "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT",
		VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT: "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT",
		VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT: "VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT",
		VK_FORMAT_FEATURE_BLIT_SRC_BIT: "VK_FORMAT_FEATURE_BLIT_SRC_BIT",
		VK_FORMAT_FEATURE_BLIT_DST_BIT: "VK_FORMAT_FEATURE_BLIT_DST_BIT",
		VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT: "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT",
		VK_FORMAT_FEATURE_TRANSFER_SRC_BIT: "VK_FORMAT_FEATURE_TRANSFER_SRC_BIT",
		VK_FORMAT_FEATURE_TRANSFER_DST_BIT: "VK_FORMAT_FEATURE_TRANSFER_DST_BIT",
		VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT: "VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT",
		VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT: "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT",
		VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT: "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT",
		VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT: "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT",
		VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT: "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT",
		VK_FORMAT_FEATURE_DISJOINT_BIT: "VK_FORMAT_FEATURE_DISJOINT_BIT",
		VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT: "VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT",
		VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT: "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT",
	}
)
func (x FormatFeatureFlagBits) String() string {
	if s, ok := reverseFormatFeatureFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("FormatFeatureFlagBits=%d", x)
}

// SparseImageFormatFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageFormatFlagBits.html
type SparseImageFormatFlagBits uint32

const (
	VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT SparseImageFormatFlagBits = (1 << 0)
	VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT SparseImageFormatFlagBits = (1 << 1)
	VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT SparseImageFormatFlagBits = (1 << 2)
)

var (
	reverseSparseImageFormatFlagBits map[SparseImageFormatFlagBits]string = map[SparseImageFormatFlagBits]string{ 
		VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT: "VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT",
		VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT: "VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT",
		VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT: "VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT",
	}
)
func (x SparseImageFormatFlagBits) String() string {
	if s, ok := reverseSparseImageFormatFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("SparseImageFormatFlagBits=%d", x)
}

// CommandPoolResetFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolResetFlagBits.html
type CommandPoolResetFlagBits uint32

const (
	VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT CommandPoolResetFlagBits = (1 << 0)
)

var (
	reverseCommandPoolResetFlagBits map[CommandPoolResetFlagBits]string = map[CommandPoolResetFlagBits]string{ 
		VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT: "VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT",
	}
)
func (x CommandPoolResetFlagBits) String() string {
	if s, ok := reverseCommandPoolResetFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("CommandPoolResetFlagBits=%d", x)
}

// ImageCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCreateFlagBits.html
type ImageCreateFlagBits uint32

const (
	VK_IMAGE_CREATE_SPARSE_BINDING_BIT ImageCreateFlagBits = (1 << 0)
	VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT ImageCreateFlagBits = (1 << 1)
	VK_IMAGE_CREATE_SPARSE_ALIASED_BIT ImageCreateFlagBits = (1 << 2)
	VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT ImageCreateFlagBits = (1 << 3)
	VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT ImageCreateFlagBits = (1 << 4)
	VK_IMAGE_CREATE_ALIAS_BIT ImageCreateFlagBits = (1 << 10)
	VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT ImageCreateFlagBits = (1 << 6)
	VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT ImageCreateFlagBits = (1 << 5)
	VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT ImageCreateFlagBits = (1 << 7)
	VK_IMAGE_CREATE_EXTENDED_USAGE_BIT ImageCreateFlagBits = (1 << 8)
	VK_IMAGE_CREATE_PROTECTED_BIT ImageCreateFlagBits = (1 << 11)
	VK_IMAGE_CREATE_DISJOINT_BIT ImageCreateFlagBits = (1 << 9)
)

var (
	reverseImageCreateFlagBits map[ImageCreateFlagBits]string = map[ImageCreateFlagBits]string{ 
		VK_IMAGE_CREATE_SPARSE_BINDING_BIT: "VK_IMAGE_CREATE_SPARSE_BINDING_BIT",
		VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT: "VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT",
		VK_IMAGE_CREATE_SPARSE_ALIASED_BIT: "VK_IMAGE_CREATE_SPARSE_ALIASED_BIT",
		VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT: "VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT",
		VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT: "VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT",
		VK_IMAGE_CREATE_ALIAS_BIT: "VK_IMAGE_CREATE_ALIAS_BIT",
		VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT: "VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT",
		VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT: "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT",
		VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT: "VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT",
		VK_IMAGE_CREATE_EXTENDED_USAGE_BIT: "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT",
		VK_IMAGE_CREATE_PROTECTED_BIT: "VK_IMAGE_CREATE_PROTECTED_BIT",
		VK_IMAGE_CREATE_DISJOINT_BIT: "VK_IMAGE_CREATE_DISJOINT_BIT",
	}
)
func (x ImageCreateFlagBits) String() string {
	if s, ok := reverseImageCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ImageCreateFlagBits=%d", x)
}

// FenceCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFenceCreateFlagBits.html
type FenceCreateFlagBits uint32

const (
	VK_FENCE_CREATE_SIGNALED_BIT FenceCreateFlagBits = (1 << 0)
)

var (
	reverseFenceCreateFlagBits map[FenceCreateFlagBits]string = map[FenceCreateFlagBits]string{ 
		VK_FENCE_CREATE_SIGNALED_BIT: "VK_FENCE_CREATE_SIGNALED_BIT",
	}
)
func (x FenceCreateFlagBits) String() string {
	if s, ok := reverseFenceCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("FenceCreateFlagBits=%d", x)
}

// Filter enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFilter.html
type Filter uint32

const (
	VK_FILTER_NEAREST Filter = 0
	VK_FILTER_LINEAR Filter = 1
)

var (
	reverseFilter map[Filter]string = map[Filter]string{ 
		VK_FILTER_NEAREST: "VK_FILTER_NEAREST",
		VK_FILTER_LINEAR: "VK_FILTER_LINEAR",
	}
)
func (x Filter) String() string {
	if s, ok := reverseFilter[x]; ok {
		return s
	}
	return fmt.Sprintf("Filter=%d", x)
}

// ImageTiling enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageTiling.html
type ImageTiling uint32

const (
	VK_IMAGE_TILING_OPTIMAL ImageTiling = 0
	VK_IMAGE_TILING_LINEAR ImageTiling = 1
)

var (
	reverseImageTiling map[ImageTiling]string = map[ImageTiling]string{ 
		VK_IMAGE_TILING_OPTIMAL: "VK_IMAGE_TILING_OPTIMAL",
		VK_IMAGE_TILING_LINEAR: "VK_IMAGE_TILING_LINEAR",
	}
)
func (x ImageTiling) String() string {
	if s, ok := reverseImageTiling[x]; ok {
		return s
	}
	return fmt.Sprintf("ImageTiling=%d", x)
}

// ImageType enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageType.html
type ImageType uint32

const (
	VK_IMAGE_TYPE_1D ImageType = 0
	VK_IMAGE_TYPE_2D ImageType = 1
	VK_IMAGE_TYPE_3D ImageType = 2
)

var (
	reverseImageType map[ImageType]string = map[ImageType]string{ 
		VK_IMAGE_TYPE_1D: "VK_IMAGE_TYPE_1D",
		VK_IMAGE_TYPE_2D: "VK_IMAGE_TYPE_2D",
		VK_IMAGE_TYPE_3D: "VK_IMAGE_TYPE_3D",
	}
)
func (x ImageType) String() string {
	if s, ok := reverseImageType[x]; ok {
		return s
	}
	return fmt.Sprintf("ImageType=%d", x)
}

// ImageUsageFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageUsageFlagBits.html
type ImageUsageFlagBits uint32

const (
	VK_IMAGE_USAGE_TRANSFER_SRC_BIT ImageUsageFlagBits = (1 << 0)
	VK_IMAGE_USAGE_TRANSFER_DST_BIT ImageUsageFlagBits = (1 << 1)
	VK_IMAGE_USAGE_SAMPLED_BIT ImageUsageFlagBits = (1 << 2)
	VK_IMAGE_USAGE_STORAGE_BIT ImageUsageFlagBits = (1 << 3)
	VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT ImageUsageFlagBits = (1 << 4)
	VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT ImageUsageFlagBits = (1 << 5)
	VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT ImageUsageFlagBits = (1 << 6)
	VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT ImageUsageFlagBits = (1 << 7)
)

var (
	reverseImageUsageFlagBits map[ImageUsageFlagBits]string = map[ImageUsageFlagBits]string{ 
		VK_IMAGE_USAGE_TRANSFER_SRC_BIT: "VK_IMAGE_USAGE_TRANSFER_SRC_BIT",
		VK_IMAGE_USAGE_TRANSFER_DST_BIT: "VK_IMAGE_USAGE_TRANSFER_DST_BIT",
		VK_IMAGE_USAGE_SAMPLED_BIT: "VK_IMAGE_USAGE_SAMPLED_BIT",
		VK_IMAGE_USAGE_STORAGE_BIT: "VK_IMAGE_USAGE_STORAGE_BIT",
		VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT: "VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT",
		VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT: "VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT",
		VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT: "VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT",
		VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT: "VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT",
	}
)
func (x ImageUsageFlagBits) String() string {
	if s, ok := reverseImageUsageFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ImageUsageFlagBits=%d", x)
}

// ImageAspectFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageAspectFlagBits.html
type ImageAspectFlagBits uint32

const (
	VK_IMAGE_ASPECT_COLOR_BIT ImageAspectFlagBits = (1 << 0)
	VK_IMAGE_ASPECT_DEPTH_BIT ImageAspectFlagBits = (1 << 1)
	VK_IMAGE_ASPECT_STENCIL_BIT ImageAspectFlagBits = (1 << 2)
	VK_IMAGE_ASPECT_METADATA_BIT ImageAspectFlagBits = (1 << 3)
	VK_IMAGE_ASPECT_PLANE_0_BIT ImageAspectFlagBits = (1 << 4)
	VK_IMAGE_ASPECT_PLANE_1_BIT ImageAspectFlagBits = (1 << 5)
	VK_IMAGE_ASPECT_PLANE_2_BIT ImageAspectFlagBits = (1 << 6)
	VK_IMAGE_ASPECT_NONE ImageAspectFlagBits = 0
)

var (
	reverseImageAspectFlagBits map[ImageAspectFlagBits]string = map[ImageAspectFlagBits]string{ 
		VK_IMAGE_ASPECT_COLOR_BIT: "VK_IMAGE_ASPECT_COLOR_BIT",
		VK_IMAGE_ASPECT_DEPTH_BIT: "VK_IMAGE_ASPECT_DEPTH_BIT",
		VK_IMAGE_ASPECT_STENCIL_BIT: "VK_IMAGE_ASPECT_STENCIL_BIT",
		VK_IMAGE_ASPECT_METADATA_BIT: "VK_IMAGE_ASPECT_METADATA_BIT",
		VK_IMAGE_ASPECT_PLANE_0_BIT: "VK_IMAGE_ASPECT_PLANE_0_BIT",
		VK_IMAGE_ASPECT_PLANE_1_BIT: "VK_IMAGE_ASPECT_PLANE_1_BIT",
		VK_IMAGE_ASPECT_PLANE_2_BIT: "VK_IMAGE_ASPECT_PLANE_2_BIT",
		VK_IMAGE_ASPECT_NONE: "VK_IMAGE_ASPECT_NONE",
	}
)
func (x ImageAspectFlagBits) String() string {
	if s, ok := reverseImageAspectFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ImageAspectFlagBits=%d", x)
}

// CommandBufferResetFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferResetFlagBits.html
type CommandBufferResetFlagBits uint32

const (
	VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT CommandBufferResetFlagBits = (1 << 0)
)

var (
	reverseCommandBufferResetFlagBits map[CommandBufferResetFlagBits]string = map[CommandBufferResetFlagBits]string{ 
		VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT: "VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT",
	}
)
func (x CommandBufferResetFlagBits) String() string {
	if s, ok := reverseCommandBufferResetFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("CommandBufferResetFlagBits=%d", x)
}

// ImageLayout enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageLayout.html
type ImageLayout uint32

const (
	VK_IMAGE_LAYOUT_UNDEFINED ImageLayout = 0
	VK_IMAGE_LAYOUT_GENERAL ImageLayout = 1
	VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL ImageLayout = 2
	VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL ImageLayout = 3
	VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL ImageLayout = 4
	VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL ImageLayout = 5
	VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL ImageLayout = 6
	VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL ImageLayout = 7
	VK_IMAGE_LAYOUT_PREINITIALIZED ImageLayout = 8
	VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL ImageLayout = 1000117000
	VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL ImageLayout = 1000117001
	VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL ImageLayout = 1000241000
	VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL ImageLayout = 1000241001
	VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL ImageLayout = 1000241002
	VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL ImageLayout = 1000241003
	VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL ImageLayout = 1000314000
	VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL ImageLayout = 1000314001
	VK_IMAGE_LAYOUT_PRESENT_SRC_KHR ImageLayout = 1000001002
)

var (
	reverseImageLayout map[ImageLayout]string = map[ImageLayout]string{ 
		VK_IMAGE_LAYOUT_UNDEFINED: "VK_IMAGE_LAYOUT_UNDEFINED",
		VK_IMAGE_LAYOUT_GENERAL: "VK_IMAGE_LAYOUT_GENERAL",
		VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL: "VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL",
		VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL: "VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL",
		VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL: "VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL",
		VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL: "VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL",
		VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL: "VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL",
		VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL: "VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL",
		VK_IMAGE_LAYOUT_PREINITIALIZED: "VK_IMAGE_LAYOUT_PREINITIALIZED",
		VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL: "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL",
		VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL: "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL",
		VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL: "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL",
		VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL: "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL",
		VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL: "VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL",
		VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL: "VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL",
		VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL: "VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL",
		VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL: "VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL",
		VK_IMAGE_LAYOUT_PRESENT_SRC_KHR: "VK_IMAGE_LAYOUT_PRESENT_SRC_KHR",
	}
)
func (x ImageLayout) String() string {
	if s, ok := reverseImageLayout[x]; ok {
		return s
	}
	return fmt.Sprintf("ImageLayout=%d", x)
}

// InstanceCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateFlagBits.html
type InstanceCreateFlagBits uint32

// BorderColor enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBorderColor.html
type BorderColor uint32

const (
	VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK BorderColor = 0
	VK_BORDER_COLOR_INT_TRANSPARENT_BLACK BorderColor = 1
	VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK BorderColor = 2
	VK_BORDER_COLOR_INT_OPAQUE_BLACK BorderColor = 3
	VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE BorderColor = 4
	VK_BORDER_COLOR_INT_OPAQUE_WHITE BorderColor = 5
)

var (
	reverseBorderColor map[BorderColor]string = map[BorderColor]string{ 
		VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK: "VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK",
		VK_BORDER_COLOR_INT_TRANSPARENT_BLACK: "VK_BORDER_COLOR_INT_TRANSPARENT_BLACK",
		VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK: "VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK",
		VK_BORDER_COLOR_INT_OPAQUE_BLACK: "VK_BORDER_COLOR_INT_OPAQUE_BLACK",
		VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE: "VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE",
		VK_BORDER_COLOR_INT_OPAQUE_WHITE: "VK_BORDER_COLOR_INT_OPAQUE_WHITE",
	}
)
func (x BorderColor) String() string {
	if s, ok := reverseBorderColor[x]; ok {
		return s
	}
	return fmt.Sprintf("BorderColor=%d", x)
}

// CommandBufferUsageFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferUsageFlagBits.html
type CommandBufferUsageFlagBits uint32

const (
	VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT CommandBufferUsageFlagBits = (1 << 0)
	VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT CommandBufferUsageFlagBits = (1 << 1)
	VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT CommandBufferUsageFlagBits = (1 << 2)
)

var (
	reverseCommandBufferUsageFlagBits map[CommandBufferUsageFlagBits]string = map[CommandBufferUsageFlagBits]string{ 
		VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT: "VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT",
		VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT: "VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT",
		VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT: "VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT",
	}
)
func (x CommandBufferUsageFlagBits) String() string {
	if s, ok := reverseCommandBufferUsageFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("CommandBufferUsageFlagBits=%d", x)
}

// QueryControlFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryControlFlagBits.html
type QueryControlFlagBits uint32

const (
	VK_QUERY_CONTROL_PRECISE_BIT QueryControlFlagBits = (1 << 0)
)

var (
	reverseQueryControlFlagBits map[QueryControlFlagBits]string = map[QueryControlFlagBits]string{ 
		VK_QUERY_CONTROL_PRECISE_BIT: "VK_QUERY_CONTROL_PRECISE_BIT",
	}
)
func (x QueryControlFlagBits) String() string {
	if s, ok := reverseQueryControlFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("QueryControlFlagBits=%d", x)
}

// MemoryHeapFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryHeapFlagBits.html
type MemoryHeapFlagBits uint32

const (
	VK_MEMORY_HEAP_DEVICE_LOCAL_BIT MemoryHeapFlagBits = (1 << 0)
	VK_MEMORY_HEAP_MULTI_INSTANCE_BIT MemoryHeapFlagBits = (1 << 1)
)

var (
	reverseMemoryHeapFlagBits map[MemoryHeapFlagBits]string = map[MemoryHeapFlagBits]string{ 
		VK_MEMORY_HEAP_DEVICE_LOCAL_BIT: "VK_MEMORY_HEAP_DEVICE_LOCAL_BIT",
		VK_MEMORY_HEAP_MULTI_INSTANCE_BIT: "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT",
	}
)
func (x MemoryHeapFlagBits) String() string {
	if s, ok := reverseMemoryHeapFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("MemoryHeapFlagBits=%d", x)
}

// ComponentSwizzle enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkComponentSwizzle.html
type ComponentSwizzle uint32

const (
	VK_COMPONENT_SWIZZLE_IDENTITY ComponentSwizzle = 0
	VK_COMPONENT_SWIZZLE_ZERO ComponentSwizzle = 1
	VK_COMPONENT_SWIZZLE_ONE ComponentSwizzle = 2
	VK_COMPONENT_SWIZZLE_R ComponentSwizzle = 3
	VK_COMPONENT_SWIZZLE_G ComponentSwizzle = 4
	VK_COMPONENT_SWIZZLE_B ComponentSwizzle = 5
	VK_COMPONENT_SWIZZLE_A ComponentSwizzle = 6
)

var (
	reverseComponentSwizzle map[ComponentSwizzle]string = map[ComponentSwizzle]string{ 
		VK_COMPONENT_SWIZZLE_IDENTITY: "VK_COMPONENT_SWIZZLE_IDENTITY",
		VK_COMPONENT_SWIZZLE_ZERO: "VK_COMPONENT_SWIZZLE_ZERO",
		VK_COMPONENT_SWIZZLE_ONE: "VK_COMPONENT_SWIZZLE_ONE",
		VK_COMPONENT_SWIZZLE_R: "VK_COMPONENT_SWIZZLE_R",
		VK_COMPONENT_SWIZZLE_G: "VK_COMPONENT_SWIZZLE_G",
		VK_COMPONENT_SWIZZLE_B: "VK_COMPONENT_SWIZZLE_B",
		VK_COMPONENT_SWIZZLE_A: "VK_COMPONENT_SWIZZLE_A",
	}
)
func (x ComponentSwizzle) String() string {
	if s, ok := reverseComponentSwizzle[x]; ok {
		return s
	}
	return fmt.Sprintf("ComponentSwizzle=%d", x)
}

// MemoryPropertyFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryPropertyFlagBits.html
type MemoryPropertyFlagBits uint32

const (
	VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT MemoryPropertyFlagBits = (1 << 0)
	VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT MemoryPropertyFlagBits = (1 << 1)
	VK_MEMORY_PROPERTY_HOST_COHERENT_BIT MemoryPropertyFlagBits = (1 << 2)
	VK_MEMORY_PROPERTY_HOST_CACHED_BIT MemoryPropertyFlagBits = (1 << 3)
	VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT MemoryPropertyFlagBits = (1 << 4)
	VK_MEMORY_PROPERTY_PROTECTED_BIT MemoryPropertyFlagBits = (1 << 5)
)

var (
	reverseMemoryPropertyFlagBits map[MemoryPropertyFlagBits]string = map[MemoryPropertyFlagBits]string{ 
		VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT: "VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT",
		VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT: "VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT",
		VK_MEMORY_PROPERTY_HOST_COHERENT_BIT: "VK_MEMORY_PROPERTY_HOST_COHERENT_BIT",
		VK_MEMORY_PROPERTY_HOST_CACHED_BIT: "VK_MEMORY_PROPERTY_HOST_CACHED_BIT",
		VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT: "VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT",
		VK_MEMORY_PROPERTY_PROTECTED_BIT: "VK_MEMORY_PROPERTY_PROTECTED_BIT",
	}
)
func (x MemoryPropertyFlagBits) String() string {
	if s, ok := reverseMemoryPropertyFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("MemoryPropertyFlagBits=%d", x)
}

// PipelineCacheHeaderVersion enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCacheHeaderVersion.html
type PipelineCacheHeaderVersion uint32

const (
	VK_PIPELINE_CACHE_HEADER_VERSION_ONE PipelineCacheHeaderVersion = 1
)

var (
	reversePipelineCacheHeaderVersion map[PipelineCacheHeaderVersion]string = map[PipelineCacheHeaderVersion]string{ 
		VK_PIPELINE_CACHE_HEADER_VERSION_ONE: "VK_PIPELINE_CACHE_HEADER_VERSION_ONE",
	}
)
func (x PipelineCacheHeaderVersion) String() string {
	if s, ok := reversePipelineCacheHeaderVersion[x]; ok {
		return s
	}
	return fmt.Sprintf("PipelineCacheHeaderVersion=%d", x)
}

// VertexInputRate enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVertexInputRate.html
type VertexInputRate uint32

const (
	VK_VERTEX_INPUT_RATE_VERTEX VertexInputRate = 0
	VK_VERTEX_INPUT_RATE_INSTANCE VertexInputRate = 1
)

var (
	reverseVertexInputRate map[VertexInputRate]string = map[VertexInputRate]string{ 
		VK_VERTEX_INPUT_RATE_VERTEX: "VK_VERTEX_INPUT_RATE_VERTEX",
		VK_VERTEX_INPUT_RATE_INSTANCE: "VK_VERTEX_INPUT_RATE_INSTANCE",
	}
)
func (x VertexInputRate) String() string {
	if s, ok := reverseVertexInputRate[x]; ok {
		return s
	}
	return fmt.Sprintf("VertexInputRate=%d", x)
}

// StructureType enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkStructureType.html
type StructureType uint32

const (
	VK_STRUCTURE_TYPE_APPLICATION_INFO StructureType = 0
	VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO StructureType = 1
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO StructureType = 2
	VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO StructureType = 3
	VK_STRUCTURE_TYPE_SUBMIT_INFO StructureType = 4
	VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO StructureType = 5
	VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE StructureType = 6
	VK_STRUCTURE_TYPE_BIND_SPARSE_INFO StructureType = 7
	VK_STRUCTURE_TYPE_FENCE_CREATE_INFO StructureType = 8
	VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO StructureType = 9
	VK_STRUCTURE_TYPE_EVENT_CREATE_INFO StructureType = 10
	VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO StructureType = 11
	VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO StructureType = 12
	VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO StructureType = 13
	VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO StructureType = 14
	VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO StructureType = 15
	VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO StructureType = 16
	VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO StructureType = 17
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO StructureType = 18
	VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO StructureType = 19
	VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO StructureType = 20
	VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO StructureType = 21
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO StructureType = 22
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO StructureType = 23
	VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO StructureType = 24
	VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO StructureType = 25
	VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO StructureType = 26
	VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO StructureType = 27
	VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO StructureType = 28
	VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO StructureType = 29
	VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO StructureType = 30
	VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO StructureType = 31
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO StructureType = 32
	VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO StructureType = 33
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO StructureType = 34
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET StructureType = 35
	VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET StructureType = 36
	VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO StructureType = 37
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO StructureType = 38
	VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO StructureType = 39
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO StructureType = 40
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO StructureType = 41
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO StructureType = 42
	VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO StructureType = 43
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER StructureType = 44
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER StructureType = 45
	VK_STRUCTURE_TYPE_MEMORY_BARRIER StructureType = 46
	VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO StructureType = 47
	VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO StructureType = 48
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES StructureType = 1000094000
	VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO StructureType = 1000157000
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO StructureType = 1000157001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES StructureType = 1000083000
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS StructureType = 1000127000
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO StructureType = 1000127001
	VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO StructureType = 1000060000
	VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO StructureType = 1000060003
	VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO StructureType = 1000060004
	VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO StructureType = 1000060005
	VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO StructureType = 1000060006
	VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO StructureType = 1000060013
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO StructureType = 1000060014
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES StructureType = 1000070000
	VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO StructureType = 1000070001
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 StructureType = 1000146000
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 StructureType = 1000146001
	VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 StructureType = 1000146002
	VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 StructureType = 1000146003
	VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 StructureType = 1000146004
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 StructureType = 1000059000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 StructureType = 1000059001
	VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 StructureType = 1000059002
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 StructureType = 1000059003
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 StructureType = 1000059004
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 StructureType = 1000059005
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 StructureType = 1000059006
	VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 StructureType = 1000059007
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 StructureType = 1000059008
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES StructureType = 1000117000
	VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO StructureType = 1000117001
	VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO StructureType = 1000117002
	VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO StructureType = 1000117003
	VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO StructureType = 1000053000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES StructureType = 1000053001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES StructureType = 1000053002
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES StructureType = 1000120000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES StructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES
	VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO StructureType = 1000145000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES StructureType = 1000145001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES StructureType = 1000145002
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 StructureType = 1000145003
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO StructureType = 1000156000
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO StructureType = 1000156001
	VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO StructureType = 1000156002
	VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO StructureType = 1000156003
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES StructureType = 1000156004
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES StructureType = 1000156005
	VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO StructureType = 1000085000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO StructureType = 1000071000
	VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES StructureType = 1000071001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO StructureType = 1000071002
	VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES StructureType = 1000071003
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES StructureType = 1000071004
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO StructureType = 1000072000
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO StructureType = 1000072001
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO StructureType = 1000072002
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO StructureType = 1000112000
	VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES StructureType = 1000112001
	VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO StructureType = 1000113000
	VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO StructureType = 1000077000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO StructureType = 1000076000
	VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES StructureType = 1000076001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES StructureType = 1000168000
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT StructureType = 1000168001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES StructureType = 1000063000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES StructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES StructureType = 49
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES StructureType = 50
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES StructureType = 51
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES StructureType = 52
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO StructureType = 1000147000
	VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2 StructureType = 1000109000
	VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2 StructureType = 1000109001
	VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2 StructureType = 1000109002
	VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2 StructureType = 1000109003
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2 StructureType = 1000109004
	VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO StructureType = 1000109005
	VK_STRUCTURE_TYPE_SUBPASS_END_INFO StructureType = 1000109006
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES StructureType = 1000177000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES StructureType = 1000196000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES StructureType = 1000180000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES StructureType = 1000082000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES StructureType = 1000197000
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO StructureType = 1000161000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES StructureType = 1000161001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES StructureType = 1000161002
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO StructureType = 1000161003
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT StructureType = 1000161004
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES StructureType = 1000199000
	VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE StructureType = 1000199001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES StructureType = 1000221000
	VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO StructureType = 1000246000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES StructureType = 1000130000
	VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO StructureType = 1000130001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES StructureType = 1000211000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES StructureType = 1000108000
	VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO StructureType = 1000108001
	VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO StructureType = 1000108002
	VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO StructureType = 1000108003
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES StructureType = 1000253000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES StructureType = 1000175000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES StructureType = 1000241000
	VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT StructureType = 1000241001
	VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT StructureType = 1000241002
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES StructureType = 1000261000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES StructureType = 1000207000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES StructureType = 1000207001
	VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO StructureType = 1000207002
	VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO StructureType = 1000207003
	VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO StructureType = 1000207004
	VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO StructureType = 1000207005
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES StructureType = 1000257000
	VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO StructureType = 1000244001
	VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO StructureType = 1000257002
	VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO StructureType = 1000257003
	VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO StructureType = 1000257004
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES StructureType = 53
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES StructureType = 54
	VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO StructureType = 1000192000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES StructureType = 1000215000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES StructureType = 1000245000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES StructureType = 1000276000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES StructureType = 1000295000
	VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO StructureType = 1000295001
	VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO StructureType = 1000295002
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES StructureType = 1000297000
	VK_STRUCTURE_TYPE_MEMORY_BARRIER_2 StructureType = 1000314000
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2 StructureType = 1000314001
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2 StructureType = 1000314002
	VK_STRUCTURE_TYPE_DEPENDENCY_INFO StructureType = 1000314003
	VK_STRUCTURE_TYPE_SUBMIT_INFO_2 StructureType = 1000314004
	VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO StructureType = 1000314005
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO StructureType = 1000314006
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES StructureType = 1000314007
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES StructureType = 1000325000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES StructureType = 1000335000
	VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2 StructureType = 1000337000
	VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2 StructureType = 1000337001
	VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2 StructureType = 1000337002
	VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2 StructureType = 1000337003
	VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2 StructureType = 1000337004
	VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2 StructureType = 1000337005
	VK_STRUCTURE_TYPE_BUFFER_COPY_2 StructureType = 1000337006
	VK_STRUCTURE_TYPE_IMAGE_COPY_2 StructureType = 1000337007
	VK_STRUCTURE_TYPE_IMAGE_BLIT_2 StructureType = 1000337008
	VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2 StructureType = 1000337009
	VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2 StructureType = 1000337010
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES StructureType = 1000225000
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO StructureType = 1000225001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES StructureType = 1000225002
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES StructureType = 1000138000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES StructureType = 1000138001
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK StructureType = 1000138002
	VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO StructureType = 1000138003
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES StructureType = 1000066000
	VK_STRUCTURE_TYPE_RENDERING_INFO StructureType = 1000044000
	VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO StructureType = 1000044001
	VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO StructureType = 1000044002
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES StructureType = 1000044003
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO StructureType = 1000044004
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES StructureType = 1000280000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES StructureType = 1000280001
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES StructureType = 1000281001
	VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 StructureType = 1000360000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES StructureType = 1000413000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES StructureType = 1000413001
	VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS StructureType = 1000413002
	VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS StructureType = 1000413003
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR StructureType = 1000119000
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR StructureType = 1000119001
	VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR StructureType = 1000119002
	VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR StructureType = 1000239000
	VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR StructureType = 1000001000
	VK_STRUCTURE_TYPE_PRESENT_INFO_KHR StructureType = 1000001001
	VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR StructureType = 1000060007
	VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR StructureType = 1000060008
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR StructureType = 1000060009
	VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR StructureType = 1000060010
	VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR StructureType = 1000060011
	VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR StructureType = 1000060012
	VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR StructureType = 1000002000
	VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR StructureType = 1000002001
	VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR StructureType = 1000121000
	VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR StructureType = 1000121001
	VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR StructureType = 1000121002
	VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR StructureType = 1000121003
	VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR StructureType = 1000121004
	VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR StructureType = 1000003000
	VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR StructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR StructureType = 1000163000
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR StructureType = 1000163001
)

var (
	reverseStructureType map[StructureType]string = map[StructureType]string{ 
		VK_STRUCTURE_TYPE_APPLICATION_INFO: "VK_STRUCTURE_TYPE_APPLICATION_INFO",
		VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO: "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO",
		VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO: "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO",
		VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO: "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO",
		VK_STRUCTURE_TYPE_SUBMIT_INFO: "VK_STRUCTURE_TYPE_SUBMIT_INFO",
		VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO: "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO",
		VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE: "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE",
		VK_STRUCTURE_TYPE_BIND_SPARSE_INFO: "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO",
		VK_STRUCTURE_TYPE_FENCE_CREATE_INFO: "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO",
		VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO: "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO",
		VK_STRUCTURE_TYPE_EVENT_CREATE_INFO: "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO",
		VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO: "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO",
		VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO: "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO",
		VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO: "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO",
		VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO: "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO",
		VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO: "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO",
		VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO: "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO: "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO: "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO: "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO: "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO: "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO: "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO: "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO: "VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO: "VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO: "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO: "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO: "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO",
		VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO: "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO: "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO",
		VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO: "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO",
		VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO: "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO",
		VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO: "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO",
		VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO: "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO",
		VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET: "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET",
		VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET: "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET",
		VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO: "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO",
		VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO: "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO",
		VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO: "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO",
		VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO: "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO",
		VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO: "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO",
		VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO: "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO",
		VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO: "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO",
		VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER: "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER",
		VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER: "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER",
		VK_STRUCTURE_TYPE_MEMORY_BARRIER: "VK_STRUCTURE_TYPE_MEMORY_BARRIER",
		VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO: "VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO",
		VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO: "VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES",
		VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO: "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO",
		VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO: "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES",
		VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS: "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS",
		VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO: "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO",
		VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO: "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO",
		VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO: "VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO",
		VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO: "VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO",
		VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO: "VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO",
		VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO: "VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO",
		VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO: "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO",
		VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO: "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES",
		VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO: "VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO",
		VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2: "VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2",
		VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2: "VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2",
		VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2: "VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2",
		VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2: "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2",
		VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2: "VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2",
		VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2: "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2",
		VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2: "VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2",
		VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2: "VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2",
		VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2: "VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES",
		VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO: "VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO",
		VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO: "VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO: "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO: "VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES",
		VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO: "VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES",
		VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2: "VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2",
		VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO: "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO",
		VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO: "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO",
		VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO: "VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO",
		VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO: "VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES",
		VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES: "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES",
		VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO: "VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO",
		VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES: "VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO",
		VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES: "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES",
		VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO: "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO",
		VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO: "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO",
		VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO: "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO",
		VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES: "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES",
		VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO: "VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO",
		VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO: "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO",
		VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES: "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES",
		VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT: "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES",
		VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO: "VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO",
		VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2: "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2",
		VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2: "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2",
		VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2: "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2",
		VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2: "VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2",
		VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2: "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2",
		VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO: "VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO",
		VK_STRUCTURE_TYPE_SUBPASS_END_INFO: "VK_STRUCTURE_TYPE_SUBPASS_END_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES",
		VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO: "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES",
		VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO: "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO",
		VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT: "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES",
		VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE: "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES",
		VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO: "VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES",
		VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO: "VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES",
		VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO: "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO",
		VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO: "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO",
		VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO: "VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES",
		VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT: "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT",
		VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT: "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES",
		VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO: "VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO",
		VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO: "VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO",
		VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO: "VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO",
		VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO: "VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES",
		VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO: "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO",
		VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO: "VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO",
		VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO: "VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO",
		VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO: "VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES",
		VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO: "VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES",
		VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO: "VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO",
		VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO: "VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES",
		VK_STRUCTURE_TYPE_MEMORY_BARRIER_2: "VK_STRUCTURE_TYPE_MEMORY_BARRIER_2",
		VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2: "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2",
		VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2: "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2",
		VK_STRUCTURE_TYPE_DEPENDENCY_INFO: "VK_STRUCTURE_TYPE_DEPENDENCY_INFO",
		VK_STRUCTURE_TYPE_SUBMIT_INFO_2: "VK_STRUCTURE_TYPE_SUBMIT_INFO_2",
		VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO: "VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO",
		VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO: "VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES",
		VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2: "VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2",
		VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2: "VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2",
		VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2: "VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2",
		VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2: "VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2",
		VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2: "VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2",
		VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2: "VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2",
		VK_STRUCTURE_TYPE_BUFFER_COPY_2: "VK_STRUCTURE_TYPE_BUFFER_COPY_2",
		VK_STRUCTURE_TYPE_IMAGE_COPY_2: "VK_STRUCTURE_TYPE_IMAGE_COPY_2",
		VK_STRUCTURE_TYPE_IMAGE_BLIT_2: "VK_STRUCTURE_TYPE_IMAGE_BLIT_2",
		VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2: "VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2",
		VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2: "VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES",
		VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO: "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES",
		VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK: "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK",
		VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO: "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES",
		VK_STRUCTURE_TYPE_RENDERING_INFO: "VK_STRUCTURE_TYPE_RENDERING_INFO",
		VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO: "VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO",
		VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO: "VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES",
		VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO: "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES",
		VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3: "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES",
		VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS: "VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS",
		VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS: "VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR",
		VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR: "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR",
		VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR: "VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR",
		VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR: "VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR",
		VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR: "VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR",
		VK_STRUCTURE_TYPE_PRESENT_INFO_KHR: "VK_STRUCTURE_TYPE_PRESENT_INFO_KHR",
		VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR: "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR",
		VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR: "VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR",
		VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR: "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR",
		VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR: "VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR",
		VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR: "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR",
		VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR: "VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR",
		VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR: "VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR",
		VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR: "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR",
		VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR: "VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR",
		VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR: "VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR",
		VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR: "VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR",
		VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR: "VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR",
		VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR: "VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR",
		VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR: "VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR",
		VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR: "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR",
	}
)
func (x StructureType) String() string {
	if s, ok := reverseStructureType[x]; ok {
		return s
	}
	return fmt.Sprintf("StructureType=%d", x)
}

// StencilOp enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkStencilOp.html
type StencilOp uint32

const (
	VK_STENCIL_OP_KEEP StencilOp = 0
	VK_STENCIL_OP_ZERO StencilOp = 1
	VK_STENCIL_OP_REPLACE StencilOp = 2
	VK_STENCIL_OP_INCREMENT_AND_CLAMP StencilOp = 3
	VK_STENCIL_OP_DECREMENT_AND_CLAMP StencilOp = 4
	VK_STENCIL_OP_INVERT StencilOp = 5
	VK_STENCIL_OP_INCREMENT_AND_WRAP StencilOp = 6
	VK_STENCIL_OP_DECREMENT_AND_WRAP StencilOp = 7
)

var (
	reverseStencilOp map[StencilOp]string = map[StencilOp]string{ 
		VK_STENCIL_OP_KEEP: "VK_STENCIL_OP_KEEP",
		VK_STENCIL_OP_ZERO: "VK_STENCIL_OP_ZERO",
		VK_STENCIL_OP_REPLACE: "VK_STENCIL_OP_REPLACE",
		VK_STENCIL_OP_INCREMENT_AND_CLAMP: "VK_STENCIL_OP_INCREMENT_AND_CLAMP",
		VK_STENCIL_OP_DECREMENT_AND_CLAMP: "VK_STENCIL_OP_DECREMENT_AND_CLAMP",
		VK_STENCIL_OP_INVERT: "VK_STENCIL_OP_INVERT",
		VK_STENCIL_OP_INCREMENT_AND_WRAP: "VK_STENCIL_OP_INCREMENT_AND_WRAP",
		VK_STENCIL_OP_DECREMENT_AND_WRAP: "VK_STENCIL_OP_DECREMENT_AND_WRAP",
	}
)
func (x StencilOp) String() string {
	if s, ok := reverseStencilOp[x]; ok {
		return s
	}
	return fmt.Sprintf("StencilOp=%d", x)
}

// ImageViewCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateFlagBits.html
type ImageViewCreateFlagBits uint32

// ShaderStageFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderStageFlagBits.html
type ShaderStageFlagBits uint32

const (
	VK_SHADER_STAGE_VERTEX_BIT ShaderStageFlagBits = (1 << 0)
	VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT ShaderStageFlagBits = (1 << 1)
	VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT ShaderStageFlagBits = (1 << 2)
	VK_SHADER_STAGE_GEOMETRY_BIT ShaderStageFlagBits = (1 << 3)
	VK_SHADER_STAGE_FRAGMENT_BIT ShaderStageFlagBits = (1 << 4)
	VK_SHADER_STAGE_COMPUTE_BIT ShaderStageFlagBits = (1 << 5)
	VK_SHADER_STAGE_ALL_GRAPHICS ShaderStageFlagBits = 0x0000001F
	VK_SHADER_STAGE_ALL ShaderStageFlagBits = 0x7FFFFFFF
)

var (
	reverseShaderStageFlagBits map[ShaderStageFlagBits]string = map[ShaderStageFlagBits]string{ 
		VK_SHADER_STAGE_VERTEX_BIT: "VK_SHADER_STAGE_VERTEX_BIT",
		VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT: "VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT",
		VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT: "VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT",
		VK_SHADER_STAGE_GEOMETRY_BIT: "VK_SHADER_STAGE_GEOMETRY_BIT",
		VK_SHADER_STAGE_FRAGMENT_BIT: "VK_SHADER_STAGE_FRAGMENT_BIT",
		VK_SHADER_STAGE_COMPUTE_BIT: "VK_SHADER_STAGE_COMPUTE_BIT",
		VK_SHADER_STAGE_ALL_GRAPHICS: "VK_SHADER_STAGE_ALL_GRAPHICS",
		VK_SHADER_STAGE_ALL: "VK_SHADER_STAGE_ALL",
	}
)
func (x ShaderStageFlagBits) String() string {
	if s, ok := reverseShaderStageFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ShaderStageFlagBits=%d", x)
}

// Result enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkResult.html
type Result int32

const (
	VK_SUCCESS Result = 0
	VK_NOT_READY Result = 1
	VK_TIMEOUT Result = 2
	VK_EVENT_SET Result = 3
	VK_EVENT_RESET Result = 4
	VK_INCOMPLETE Result = 5
	VK_ERROR_OUT_OF_HOST_MEMORY Result = -1
	VK_ERROR_OUT_OF_DEVICE_MEMORY Result = -2
	VK_ERROR_INITIALIZATION_FAILED Result = -3
	VK_ERROR_DEVICE_LOST Result = -4
	VK_ERROR_MEMORY_MAP_FAILED Result = -5
	VK_ERROR_LAYER_NOT_PRESENT Result = -6
	VK_ERROR_EXTENSION_NOT_PRESENT Result = -7
	VK_ERROR_FEATURE_NOT_PRESENT Result = -8
	VK_ERROR_INCOMPATIBLE_DRIVER Result = -9
	VK_ERROR_TOO_MANY_OBJECTS Result = -10
	VK_ERROR_FORMAT_NOT_SUPPORTED Result = -11
	VK_ERROR_FRAGMENTED_POOL Result = -12
	VK_ERROR_UNKNOWN Result = -13
	VK_ERROR_OUT_OF_POOL_MEMORY Result = 1000069000
	VK_ERROR_INVALID_EXTERNAL_HANDLE Result = 1000072003
	VK_ERROR_FRAGMENTATION Result = 1000161000
	VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS Result = 1000257000
	VK_PIPELINE_COMPILE_REQUIRED Result = 1000297000
	VK_ERROR_SURFACE_LOST_KHR Result = 1000000000
	VK_ERROR_NATIVE_WINDOW_IN_USE_KHR Result = 1000000001
	VK_SUBOPTIMAL_KHR Result = 1000001003
	VK_ERROR_OUT_OF_DATE_KHR Result = 1000001004
	VK_ERROR_INCOMPATIBLE_DISPLAY_KHR Result = 1000003001
)

var (
	reverseResult map[Result]string = map[Result]string{ 
		VK_SUCCESS: "VK_SUCCESS",
		VK_NOT_READY: "VK_NOT_READY",
		VK_TIMEOUT: "VK_TIMEOUT",
		VK_EVENT_SET: "VK_EVENT_SET",
		VK_EVENT_RESET: "VK_EVENT_RESET",
		VK_INCOMPLETE: "VK_INCOMPLETE",
		VK_ERROR_OUT_OF_HOST_MEMORY: "VK_ERROR_OUT_OF_HOST_MEMORY",
		VK_ERROR_OUT_OF_DEVICE_MEMORY: "VK_ERROR_OUT_OF_DEVICE_MEMORY",
		VK_ERROR_INITIALIZATION_FAILED: "VK_ERROR_INITIALIZATION_FAILED",
		VK_ERROR_DEVICE_LOST: "VK_ERROR_DEVICE_LOST",
		VK_ERROR_MEMORY_MAP_FAILED: "VK_ERROR_MEMORY_MAP_FAILED",
		VK_ERROR_LAYER_NOT_PRESENT: "VK_ERROR_LAYER_NOT_PRESENT",
		VK_ERROR_EXTENSION_NOT_PRESENT: "VK_ERROR_EXTENSION_NOT_PRESENT",
		VK_ERROR_FEATURE_NOT_PRESENT: "VK_ERROR_FEATURE_NOT_PRESENT",
		VK_ERROR_INCOMPATIBLE_DRIVER: "VK_ERROR_INCOMPATIBLE_DRIVER",
		VK_ERROR_TOO_MANY_OBJECTS: "VK_ERROR_TOO_MANY_OBJECTS",
		VK_ERROR_FORMAT_NOT_SUPPORTED: "VK_ERROR_FORMAT_NOT_SUPPORTED",
		VK_ERROR_FRAGMENTED_POOL: "VK_ERROR_FRAGMENTED_POOL",
		VK_ERROR_UNKNOWN: "VK_ERROR_UNKNOWN",
		VK_ERROR_OUT_OF_POOL_MEMORY: "VK_ERROR_OUT_OF_POOL_MEMORY",
		VK_ERROR_INVALID_EXTERNAL_HANDLE: "VK_ERROR_INVALID_EXTERNAL_HANDLE",
		VK_ERROR_FRAGMENTATION: "VK_ERROR_FRAGMENTATION",
		VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS: "VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS",
		VK_PIPELINE_COMPILE_REQUIRED: "VK_PIPELINE_COMPILE_REQUIRED",
		VK_ERROR_SURFACE_LOST_KHR: "VK_ERROR_SURFACE_LOST_KHR",
		VK_ERROR_NATIVE_WINDOW_IN_USE_KHR: "VK_ERROR_NATIVE_WINDOW_IN_USE_KHR",
		VK_SUBOPTIMAL_KHR: "VK_SUBOPTIMAL_KHR",
		VK_ERROR_OUT_OF_DATE_KHR: "VK_ERROR_OUT_OF_DATE_KHR",
		VK_ERROR_INCOMPATIBLE_DISPLAY_KHR: "VK_ERROR_INCOMPATIBLE_DISPLAY_KHR",
	}
)
func (x Result) String() string {
	if s, ok := reverseResult[x]; ok {
		return s
	}
	return fmt.Sprintf("Result=%d", x)
}

// PrimitiveTopology enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPrimitiveTopology.html
type PrimitiveTopology uint32

const (
	VK_PRIMITIVE_TOPOLOGY_POINT_LIST PrimitiveTopology = 0
	VK_PRIMITIVE_TOPOLOGY_LINE_LIST PrimitiveTopology = 1
	VK_PRIMITIVE_TOPOLOGY_LINE_STRIP PrimitiveTopology = 2
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST PrimitiveTopology = 3
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP PrimitiveTopology = 4
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN PrimitiveTopology = 5
	VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY PrimitiveTopology = 6
	VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY PrimitiveTopology = 7
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY PrimitiveTopology = 8
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY PrimitiveTopology = 9
	VK_PRIMITIVE_TOPOLOGY_PATCH_LIST PrimitiveTopology = 10
)

var (
	reversePrimitiveTopology map[PrimitiveTopology]string = map[PrimitiveTopology]string{ 
		VK_PRIMITIVE_TOPOLOGY_POINT_LIST: "VK_PRIMITIVE_TOPOLOGY_POINT_LIST",
		VK_PRIMITIVE_TOPOLOGY_LINE_LIST: "VK_PRIMITIVE_TOPOLOGY_LINE_LIST",
		VK_PRIMITIVE_TOPOLOGY_LINE_STRIP: "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP",
		VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST: "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST",
		VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP: "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP",
		VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN: "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN",
		VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY: "VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY",
		VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY: "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY",
		VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY: "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY",
		VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY: "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY",
		VK_PRIMITIVE_TOPOLOGY_PATCH_LIST: "VK_PRIMITIVE_TOPOLOGY_PATCH_LIST",
	}
)
func (x PrimitiveTopology) String() string {
	if s, ok := reversePrimitiveTopology[x]; ok {
		return s
	}
	return fmt.Sprintf("PrimitiveTopology=%d", x)
}

// PhysicalDeviceType enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceType.html
type PhysicalDeviceType uint32

const (
	VK_PHYSICAL_DEVICE_TYPE_OTHER PhysicalDeviceType = 0
	VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU PhysicalDeviceType = 1
	VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU PhysicalDeviceType = 2
	VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU PhysicalDeviceType = 3
	VK_PHYSICAL_DEVICE_TYPE_CPU PhysicalDeviceType = 4
)

var (
	reversePhysicalDeviceType map[PhysicalDeviceType]string = map[PhysicalDeviceType]string{ 
		VK_PHYSICAL_DEVICE_TYPE_OTHER: "VK_PHYSICAL_DEVICE_TYPE_OTHER",
		VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU: "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU",
		VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU: "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU",
		VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU: "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU",
		VK_PHYSICAL_DEVICE_TYPE_CPU: "VK_PHYSICAL_DEVICE_TYPE_CPU",
	}
)
func (x PhysicalDeviceType) String() string {
	if s, ok := reversePhysicalDeviceType[x]; ok {
		return s
	}
	return fmt.Sprintf("PhysicalDeviceType=%d", x)
}

// PolygonMode enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPolygonMode.html
type PolygonMode uint32

const (
	VK_POLYGON_MODE_FILL PolygonMode = 0
	VK_POLYGON_MODE_LINE PolygonMode = 1
	VK_POLYGON_MODE_POINT PolygonMode = 2
)

var (
	reversePolygonMode map[PolygonMode]string = map[PolygonMode]string{ 
		VK_POLYGON_MODE_FILL: "VK_POLYGON_MODE_FILL",
		VK_POLYGON_MODE_LINE: "VK_POLYGON_MODE_LINE",
		VK_POLYGON_MODE_POINT: "VK_POLYGON_MODE_POINT",
	}
)
func (x PolygonMode) String() string {
	if s, ok := reversePolygonMode[x]; ok {
		return s
	}
	return fmt.Sprintf("PolygonMode=%d", x)
}

// QueueFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFlagBits.html
type QueueFlagBits uint32

const (
	VK_QUEUE_GRAPHICS_BIT QueueFlagBits = (1 << 0)
	VK_QUEUE_COMPUTE_BIT QueueFlagBits = (1 << 1)
	VK_QUEUE_TRANSFER_BIT QueueFlagBits = (1 << 2)
	VK_QUEUE_SPARSE_BINDING_BIT QueueFlagBits = (1 << 3)
	VK_QUEUE_PROTECTED_BIT QueueFlagBits = (1 << 4)
)

var (
	reverseQueueFlagBits map[QueueFlagBits]string = map[QueueFlagBits]string{ 
		VK_QUEUE_GRAPHICS_BIT: "VK_QUEUE_GRAPHICS_BIT",
		VK_QUEUE_COMPUTE_BIT: "VK_QUEUE_COMPUTE_BIT",
		VK_QUEUE_TRANSFER_BIT: "VK_QUEUE_TRANSFER_BIT",
		VK_QUEUE_SPARSE_BINDING_BIT: "VK_QUEUE_SPARSE_BINDING_BIT",
		VK_QUEUE_PROTECTED_BIT: "VK_QUEUE_PROTECTED_BIT",
	}
)
func (x QueueFlagBits) String() string {
	if s, ok := reverseQueueFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("QueueFlagBits=%d", x)
}

// QueryPipelineStatisticFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPipelineStatisticFlagBits.html
type QueryPipelineStatisticFlagBits uint32

const (
	VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT QueryPipelineStatisticFlagBits = (1 << 0)
	VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT QueryPipelineStatisticFlagBits = (1 << 1)
	VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT QueryPipelineStatisticFlagBits = (1 << 2)
	VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT QueryPipelineStatisticFlagBits = (1 << 3)
	VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT QueryPipelineStatisticFlagBits = (1 << 4)
	VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT QueryPipelineStatisticFlagBits = (1 << 5)
	VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT QueryPipelineStatisticFlagBits = (1 << 6)
	VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT QueryPipelineStatisticFlagBits = (1 << 7)
	VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT QueryPipelineStatisticFlagBits = (1 << 8)
	VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT QueryPipelineStatisticFlagBits = (1 << 9)
	VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT QueryPipelineStatisticFlagBits = (1 << 10)
)

var (
	reverseQueryPipelineStatisticFlagBits map[QueryPipelineStatisticFlagBits]string = map[QueryPipelineStatisticFlagBits]string{ 
		VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT: "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT",
		VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT: "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT",
		VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT: "VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT",
		VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT: "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT",
		VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT: "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT",
		VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT: "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT",
		VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT: "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT",
		VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT: "VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT",
		VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT: "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT",
		VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT: "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT",
		VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT: "VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT",
	}
)
func (x QueryPipelineStatisticFlagBits) String() string {
	if s, ok := reverseQueryPipelineStatisticFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("QueryPipelineStatisticFlagBits=%d", x)
}

// SubpassContents enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassContents.html
type SubpassContents uint32

const (
	VK_SUBPASS_CONTENTS_INLINE SubpassContents = 0
	VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS SubpassContents = 1
)

var (
	reverseSubpassContents map[SubpassContents]string = map[SubpassContents]string{ 
		VK_SUBPASS_CONTENTS_INLINE: "VK_SUBPASS_CONTENTS_INLINE",
		VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS: "VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS",
	}
)
func (x SubpassContents) String() string {
	if s, ok := reverseSubpassContents[x]; ok {
		return s
	}
	return fmt.Sprintf("SubpassContents=%d", x)
}

// ImageViewType enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewType.html
type ImageViewType uint32

const (
	VK_IMAGE_VIEW_TYPE_1D ImageViewType = 0
	VK_IMAGE_VIEW_TYPE_2D ImageViewType = 1
	VK_IMAGE_VIEW_TYPE_3D ImageViewType = 2
	VK_IMAGE_VIEW_TYPE_CUBE ImageViewType = 3
	VK_IMAGE_VIEW_TYPE_1D_ARRAY ImageViewType = 4
	VK_IMAGE_VIEW_TYPE_2D_ARRAY ImageViewType = 5
	VK_IMAGE_VIEW_TYPE_CUBE_ARRAY ImageViewType = 6
)

var (
	reverseImageViewType map[ImageViewType]string = map[ImageViewType]string{ 
		VK_IMAGE_VIEW_TYPE_1D: "VK_IMAGE_VIEW_TYPE_1D",
		VK_IMAGE_VIEW_TYPE_2D: "VK_IMAGE_VIEW_TYPE_2D",
		VK_IMAGE_VIEW_TYPE_3D: "VK_IMAGE_VIEW_TYPE_3D",
		VK_IMAGE_VIEW_TYPE_CUBE: "VK_IMAGE_VIEW_TYPE_CUBE",
		VK_IMAGE_VIEW_TYPE_1D_ARRAY: "VK_IMAGE_VIEW_TYPE_1D_ARRAY",
		VK_IMAGE_VIEW_TYPE_2D_ARRAY: "VK_IMAGE_VIEW_TYPE_2D_ARRAY",
		VK_IMAGE_VIEW_TYPE_CUBE_ARRAY: "VK_IMAGE_VIEW_TYPE_CUBE_ARRAY",
	}
)
func (x ImageViewType) String() string {
	if s, ok := reverseImageViewType[x]; ok {
		return s
	}
	return fmt.Sprintf("ImageViewType=%d", x)
}

// SystemAllocationScope enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSystemAllocationScope.html
type SystemAllocationScope uint32

const (
	VK_SYSTEM_ALLOCATION_SCOPE_COMMAND SystemAllocationScope = 0
	VK_SYSTEM_ALLOCATION_SCOPE_OBJECT SystemAllocationScope = 1
	VK_SYSTEM_ALLOCATION_SCOPE_CACHE SystemAllocationScope = 2
	VK_SYSTEM_ALLOCATION_SCOPE_DEVICE SystemAllocationScope = 3
	VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE SystemAllocationScope = 4
)

var (
	reverseSystemAllocationScope map[SystemAllocationScope]string = map[SystemAllocationScope]string{ 
		VK_SYSTEM_ALLOCATION_SCOPE_COMMAND: "VK_SYSTEM_ALLOCATION_SCOPE_COMMAND",
		VK_SYSTEM_ALLOCATION_SCOPE_OBJECT: "VK_SYSTEM_ALLOCATION_SCOPE_OBJECT",
		VK_SYSTEM_ALLOCATION_SCOPE_CACHE: "VK_SYSTEM_ALLOCATION_SCOPE_CACHE",
		VK_SYSTEM_ALLOCATION_SCOPE_DEVICE: "VK_SYSTEM_ALLOCATION_SCOPE_DEVICE",
		VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE: "VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE",
	}
)
func (x SystemAllocationScope) String() string {
	if s, ok := reverseSystemAllocationScope[x]; ok {
		return s
	}
	return fmt.Sprintf("SystemAllocationScope=%d", x)
}

// IndexType enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkIndexType.html
type IndexType uint32

const (
	VK_INDEX_TYPE_UINT16 IndexType = 0
	VK_INDEX_TYPE_UINT32 IndexType = 1
)

var (
	reverseIndexType map[IndexType]string = map[IndexType]string{ 
		VK_INDEX_TYPE_UINT16: "VK_INDEX_TYPE_UINT16",
		VK_INDEX_TYPE_UINT32: "VK_INDEX_TYPE_UINT32",
	}
)
func (x IndexType) String() string {
	if s, ok := reverseIndexType[x]; ok {
		return s
	}
	return fmt.Sprintf("IndexType=%d", x)
}

// StencilFaceFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkStencilFaceFlagBits.html
type StencilFaceFlagBits uint32

const (
	VK_STENCIL_FACE_FRONT_BIT StencilFaceFlagBits = (1 << 0)
	VK_STENCIL_FACE_BACK_BIT StencilFaceFlagBits = (1 << 1)
	VK_STENCIL_FACE_FRONT_AND_BACK StencilFaceFlagBits = 0x00000003
	VK_STENCIL_FRONT_AND_BACK StencilFaceFlagBits = VK_STENCIL_FACE_FRONT_AND_BACK
)

var (
	reverseStencilFaceFlagBits map[StencilFaceFlagBits]string = map[StencilFaceFlagBits]string{ 
		VK_STENCIL_FACE_FRONT_BIT: "VK_STENCIL_FACE_FRONT_BIT",
		VK_STENCIL_FACE_BACK_BIT: "VK_STENCIL_FACE_BACK_BIT",
		VK_STENCIL_FACE_FRONT_AND_BACK: "VK_STENCIL_FACE_FRONT_AND_BACK",
	}
)
func (x StencilFaceFlagBits) String() string {
	if s, ok := reverseStencilFaceFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("StencilFaceFlagBits=%d", x)
}

// BlendFactor enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBlendFactor.html
type BlendFactor uint32

const (
	VK_BLEND_FACTOR_ZERO BlendFactor = 0
	VK_BLEND_FACTOR_ONE BlendFactor = 1
	VK_BLEND_FACTOR_SRC_COLOR BlendFactor = 2
	VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR BlendFactor = 3
	VK_BLEND_FACTOR_DST_COLOR BlendFactor = 4
	VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR BlendFactor = 5
	VK_BLEND_FACTOR_SRC_ALPHA BlendFactor = 6
	VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA BlendFactor = 7
	VK_BLEND_FACTOR_DST_ALPHA BlendFactor = 8
	VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA BlendFactor = 9
	VK_BLEND_FACTOR_CONSTANT_COLOR BlendFactor = 10
	VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR BlendFactor = 11
	VK_BLEND_FACTOR_CONSTANT_ALPHA BlendFactor = 12
	VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA BlendFactor = 13
	VK_BLEND_FACTOR_SRC_ALPHA_SATURATE BlendFactor = 14
	VK_BLEND_FACTOR_SRC1_COLOR BlendFactor = 15
	VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR BlendFactor = 16
	VK_BLEND_FACTOR_SRC1_ALPHA BlendFactor = 17
	VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA BlendFactor = 18
)

var (
	reverseBlendFactor map[BlendFactor]string = map[BlendFactor]string{ 
		VK_BLEND_FACTOR_ZERO: "VK_BLEND_FACTOR_ZERO",
		VK_BLEND_FACTOR_ONE: "VK_BLEND_FACTOR_ONE",
		VK_BLEND_FACTOR_SRC_COLOR: "VK_BLEND_FACTOR_SRC_COLOR",
		VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR: "VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR",
		VK_BLEND_FACTOR_DST_COLOR: "VK_BLEND_FACTOR_DST_COLOR",
		VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR: "VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR",
		VK_BLEND_FACTOR_SRC_ALPHA: "VK_BLEND_FACTOR_SRC_ALPHA",
		VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA: "VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA",
		VK_BLEND_FACTOR_DST_ALPHA: "VK_BLEND_FACTOR_DST_ALPHA",
		VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA: "VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA",
		VK_BLEND_FACTOR_CONSTANT_COLOR: "VK_BLEND_FACTOR_CONSTANT_COLOR",
		VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR: "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR",
		VK_BLEND_FACTOR_CONSTANT_ALPHA: "VK_BLEND_FACTOR_CONSTANT_ALPHA",
		VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA: "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA",
		VK_BLEND_FACTOR_SRC_ALPHA_SATURATE: "VK_BLEND_FACTOR_SRC_ALPHA_SATURATE",
		VK_BLEND_FACTOR_SRC1_COLOR: "VK_BLEND_FACTOR_SRC1_COLOR",
		VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR: "VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR",
		VK_BLEND_FACTOR_SRC1_ALPHA: "VK_BLEND_FACTOR_SRC1_ALPHA",
		VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA: "VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA",
	}
)
func (x BlendFactor) String() string {
	if s, ok := reverseBlendFactor[x]; ok {
		return s
	}
	return fmt.Sprintf("BlendFactor=%d", x)
}

// BlendOp enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBlendOp.html
type BlendOp uint32

const (
	VK_BLEND_OP_ADD BlendOp = 0
	VK_BLEND_OP_SUBTRACT BlendOp = 1
	VK_BLEND_OP_REVERSE_SUBTRACT BlendOp = 2
	VK_BLEND_OP_MIN BlendOp = 3
	VK_BLEND_OP_MAX BlendOp = 4
)

var (
	reverseBlendOp map[BlendOp]string = map[BlendOp]string{ 
		VK_BLEND_OP_ADD: "VK_BLEND_OP_ADD",
		VK_BLEND_OP_SUBTRACT: "VK_BLEND_OP_SUBTRACT",
		VK_BLEND_OP_REVERSE_SUBTRACT: "VK_BLEND_OP_REVERSE_SUBTRACT",
		VK_BLEND_OP_MIN: "VK_BLEND_OP_MIN",
		VK_BLEND_OP_MAX: "VK_BLEND_OP_MAX",
	}
)
func (x BlendOp) String() string {
	if s, ok := reverseBlendOp[x]; ok {
		return s
	}
	return fmt.Sprintf("BlendOp=%d", x)
}

// PipelineShaderStageCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageCreateFlagBits.html
type PipelineShaderStageCreateFlagBits uint32

const (
	VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT PipelineShaderStageCreateFlagBits = (1 << 0)
	VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT PipelineShaderStageCreateFlagBits = (1 << 1)
)

var (
	reversePipelineShaderStageCreateFlagBits map[PipelineShaderStageCreateFlagBits]string = map[PipelineShaderStageCreateFlagBits]string{ 
		VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT: "VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT",
		VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT: "VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT",
	}
)
func (x PipelineShaderStageCreateFlagBits) String() string {
	if s, ok := reversePipelineShaderStageCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("PipelineShaderStageCreateFlagBits=%d", x)
}

// CompareOp enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCompareOp.html
type CompareOp uint32

const (
	VK_COMPARE_OP_NEVER CompareOp = 0
	VK_COMPARE_OP_LESS CompareOp = 1
	VK_COMPARE_OP_EQUAL CompareOp = 2
	VK_COMPARE_OP_LESS_OR_EQUAL CompareOp = 3
	VK_COMPARE_OP_GREATER CompareOp = 4
	VK_COMPARE_OP_NOT_EQUAL CompareOp = 5
	VK_COMPARE_OP_GREATER_OR_EQUAL CompareOp = 6
	VK_COMPARE_OP_ALWAYS CompareOp = 7
)

var (
	reverseCompareOp map[CompareOp]string = map[CompareOp]string{ 
		VK_COMPARE_OP_NEVER: "VK_COMPARE_OP_NEVER",
		VK_COMPARE_OP_LESS: "VK_COMPARE_OP_LESS",
		VK_COMPARE_OP_EQUAL: "VK_COMPARE_OP_EQUAL",
		VK_COMPARE_OP_LESS_OR_EQUAL: "VK_COMPARE_OP_LESS_OR_EQUAL",
		VK_COMPARE_OP_GREATER: "VK_COMPARE_OP_GREATER",
		VK_COMPARE_OP_NOT_EQUAL: "VK_COMPARE_OP_NOT_EQUAL",
		VK_COMPARE_OP_GREATER_OR_EQUAL: "VK_COMPARE_OP_GREATER_OR_EQUAL",
		VK_COMPARE_OP_ALWAYS: "VK_COMPARE_OP_ALWAYS",
	}
)
func (x CompareOp) String() string {
	if s, ok := reverseCompareOp[x]; ok {
		return s
	}
	return fmt.Sprintf("CompareOp=%d", x)
}

// CullModeFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCullModeFlagBits.html
type CullModeFlagBits uint32

const (
	VK_CULL_MODE_NONE CullModeFlagBits = 0
	VK_CULL_MODE_FRONT_BIT CullModeFlagBits = (1 << 0)
	VK_CULL_MODE_BACK_BIT CullModeFlagBits = (1 << 1)
	VK_CULL_MODE_FRONT_AND_BACK CullModeFlagBits = 0x00000003
)

var (
	reverseCullModeFlagBits map[CullModeFlagBits]string = map[CullModeFlagBits]string{ 
		VK_CULL_MODE_NONE: "VK_CULL_MODE_NONE",
		VK_CULL_MODE_FRONT_BIT: "VK_CULL_MODE_FRONT_BIT",
		VK_CULL_MODE_BACK_BIT: "VK_CULL_MODE_BACK_BIT",
		VK_CULL_MODE_FRONT_AND_BACK: "VK_CULL_MODE_FRONT_AND_BACK",
	}
)
func (x CullModeFlagBits) String() string {
	if s, ok := reverseCullModeFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("CullModeFlagBits=%d", x)
}

// DynamicState enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDynamicState.html
type DynamicState uint32

const (
	VK_DYNAMIC_STATE_VIEWPORT DynamicState = 0
	VK_DYNAMIC_STATE_SCISSOR DynamicState = 1
	VK_DYNAMIC_STATE_LINE_WIDTH DynamicState = 2
	VK_DYNAMIC_STATE_DEPTH_BIAS DynamicState = 3
	VK_DYNAMIC_STATE_BLEND_CONSTANTS DynamicState = 4
	VK_DYNAMIC_STATE_DEPTH_BOUNDS DynamicState = 5
	VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK DynamicState = 6
	VK_DYNAMIC_STATE_STENCIL_WRITE_MASK DynamicState = 7
	VK_DYNAMIC_STATE_STENCIL_REFERENCE DynamicState = 8
	VK_DYNAMIC_STATE_CULL_MODE DynamicState = 1000267000
	VK_DYNAMIC_STATE_FRONT_FACE DynamicState = 1000267001
	VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY DynamicState = 1000267002
	VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT DynamicState = 1000267003
	VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT DynamicState = 1000267004
	VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE DynamicState = 1000267005
	VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE DynamicState = 1000267006
	VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE DynamicState = 1000267007
	VK_DYNAMIC_STATE_DEPTH_COMPARE_OP DynamicState = 1000267008
	VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE DynamicState = 1000267009
	VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE DynamicState = 1000267010
	VK_DYNAMIC_STATE_STENCIL_OP DynamicState = 1000267011
	VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE DynamicState = 1000377001
	VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE DynamicState = 1000377002
	VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE DynamicState = 1000377004
)

var (
	reverseDynamicState map[DynamicState]string = map[DynamicState]string{ 
		VK_DYNAMIC_STATE_VIEWPORT: "VK_DYNAMIC_STATE_VIEWPORT",
		VK_DYNAMIC_STATE_SCISSOR: "VK_DYNAMIC_STATE_SCISSOR",
		VK_DYNAMIC_STATE_LINE_WIDTH: "VK_DYNAMIC_STATE_LINE_WIDTH",
		VK_DYNAMIC_STATE_DEPTH_BIAS: "VK_DYNAMIC_STATE_DEPTH_BIAS",
		VK_DYNAMIC_STATE_BLEND_CONSTANTS: "VK_DYNAMIC_STATE_BLEND_CONSTANTS",
		VK_DYNAMIC_STATE_DEPTH_BOUNDS: "VK_DYNAMIC_STATE_DEPTH_BOUNDS",
		VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK: "VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK",
		VK_DYNAMIC_STATE_STENCIL_WRITE_MASK: "VK_DYNAMIC_STATE_STENCIL_WRITE_MASK",
		VK_DYNAMIC_STATE_STENCIL_REFERENCE: "VK_DYNAMIC_STATE_STENCIL_REFERENCE",
		VK_DYNAMIC_STATE_CULL_MODE: "VK_DYNAMIC_STATE_CULL_MODE",
		VK_DYNAMIC_STATE_FRONT_FACE: "VK_DYNAMIC_STATE_FRONT_FACE",
		VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY: "VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY",
		VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT: "VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT",
		VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT: "VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT",
		VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE: "VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE",
		VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE: "VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE",
		VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE: "VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE",
		VK_DYNAMIC_STATE_DEPTH_COMPARE_OP: "VK_DYNAMIC_STATE_DEPTH_COMPARE_OP",
		VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE: "VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE",
		VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE: "VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE",
		VK_DYNAMIC_STATE_STENCIL_OP: "VK_DYNAMIC_STATE_STENCIL_OP",
		VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE: "VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE",
		VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE: "VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE",
		VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE: "VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE",
	}
)
func (x DynamicState) String() string {
	if s, ok := reverseDynamicState[x]; ok {
		return s
	}
	return fmt.Sprintf("DynamicState=%d", x)
}

// FrontFace enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFrontFace.html
type FrontFace uint32

const (
	VK_FRONT_FACE_COUNTER_CLOCKWISE FrontFace = 0
	VK_FRONT_FACE_CLOCKWISE FrontFace = 1
)

var (
	reverseFrontFace map[FrontFace]string = map[FrontFace]string{ 
		VK_FRONT_FACE_COUNTER_CLOCKWISE: "VK_FRONT_FACE_COUNTER_CLOCKWISE",
		VK_FRONT_FACE_CLOCKWISE: "VK_FRONT_FACE_CLOCKWISE",
	}
)
func (x FrontFace) String() string {
	if s, ok := reverseFrontFace[x]; ok {
		return s
	}
	return fmt.Sprintf("FrontFace=%d", x)
}

// EventCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkEventCreateFlagBits.html
type EventCreateFlagBits uint32

const (
	VK_EVENT_CREATE_DEVICE_ONLY_BIT EventCreateFlagBits = (1 << 0)
)

var (
	reverseEventCreateFlagBits map[EventCreateFlagBits]string = map[EventCreateFlagBits]string{ 
		VK_EVENT_CREATE_DEVICE_ONLY_BIT: "VK_EVENT_CREATE_DEVICE_ONLY_BIT",
	}
)
func (x EventCreateFlagBits) String() string {
	if s, ok := reverseEventCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("EventCreateFlagBits=%d", x)
}

// PipelineStageFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineStageFlagBits.html
type PipelineStageFlagBits uint32

const (
	VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT PipelineStageFlagBits = (1 << 0)
	VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT PipelineStageFlagBits = (1 << 1)
	VK_PIPELINE_STAGE_VERTEX_INPUT_BIT PipelineStageFlagBits = (1 << 2)
	VK_PIPELINE_STAGE_VERTEX_SHADER_BIT PipelineStageFlagBits = (1 << 3)
	VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT PipelineStageFlagBits = (1 << 4)
	VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT PipelineStageFlagBits = (1 << 5)
	VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT PipelineStageFlagBits = (1 << 6)
	VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT PipelineStageFlagBits = (1 << 7)
	VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT PipelineStageFlagBits = (1 << 8)
	VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT PipelineStageFlagBits = (1 << 9)
	VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT PipelineStageFlagBits = (1 << 10)
	VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT PipelineStageFlagBits = (1 << 11)
	VK_PIPELINE_STAGE_TRANSFER_BIT PipelineStageFlagBits = (1 << 12)
	VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT PipelineStageFlagBits = (1 << 13)
	VK_PIPELINE_STAGE_HOST_BIT PipelineStageFlagBits = (1 << 14)
	VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT PipelineStageFlagBits = (1 << 15)
	VK_PIPELINE_STAGE_ALL_COMMANDS_BIT PipelineStageFlagBits = (1 << 16)
	VK_PIPELINE_STAGE_NONE PipelineStageFlagBits = 0
)

var (
	reversePipelineStageFlagBits map[PipelineStageFlagBits]string = map[PipelineStageFlagBits]string{ 
		VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT: "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT",
		VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT: "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT",
		VK_PIPELINE_STAGE_VERTEX_INPUT_BIT: "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT",
		VK_PIPELINE_STAGE_VERTEX_SHADER_BIT: "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT",
		VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT: "VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT",
		VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT: "VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT",
		VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT: "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT",
		VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT: "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT",
		VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT: "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT",
		VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT: "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT",
		VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT: "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT",
		VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT: "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT",
		VK_PIPELINE_STAGE_TRANSFER_BIT: "VK_PIPELINE_STAGE_TRANSFER_BIT",
		VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT: "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT",
		VK_PIPELINE_STAGE_HOST_BIT: "VK_PIPELINE_STAGE_HOST_BIT",
		VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT: "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT",
		VK_PIPELINE_STAGE_ALL_COMMANDS_BIT: "VK_PIPELINE_STAGE_ALL_COMMANDS_BIT",
		VK_PIPELINE_STAGE_NONE: "VK_PIPELINE_STAGE_NONE",
	}
)
func (x PipelineStageFlagBits) String() string {
	if s, ok := reversePipelineStageFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("PipelineStageFlagBits=%d", x)
}

// LogicOp enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkLogicOp.html
type LogicOp uint32

const (
	VK_LOGIC_OP_CLEAR LogicOp = 0
	VK_LOGIC_OP_AND LogicOp = 1
	VK_LOGIC_OP_AND_REVERSE LogicOp = 2
	VK_LOGIC_OP_COPY LogicOp = 3
	VK_LOGIC_OP_AND_INVERTED LogicOp = 4
	VK_LOGIC_OP_NO_OP LogicOp = 5
	VK_LOGIC_OP_XOR LogicOp = 6
	VK_LOGIC_OP_OR LogicOp = 7
	VK_LOGIC_OP_NOR LogicOp = 8
	VK_LOGIC_OP_EQUIVALENT LogicOp = 9
	VK_LOGIC_OP_INVERT LogicOp = 10
	VK_LOGIC_OP_OR_REVERSE LogicOp = 11
	VK_LOGIC_OP_COPY_INVERTED LogicOp = 12
	VK_LOGIC_OP_OR_INVERTED LogicOp = 13
	VK_LOGIC_OP_NAND LogicOp = 14
	VK_LOGIC_OP_SET LogicOp = 15
)

var (
	reverseLogicOp map[LogicOp]string = map[LogicOp]string{ 
		VK_LOGIC_OP_CLEAR: "VK_LOGIC_OP_CLEAR",
		VK_LOGIC_OP_AND: "VK_LOGIC_OP_AND",
		VK_LOGIC_OP_AND_REVERSE: "VK_LOGIC_OP_AND_REVERSE",
		VK_LOGIC_OP_COPY: "VK_LOGIC_OP_COPY",
		VK_LOGIC_OP_AND_INVERTED: "VK_LOGIC_OP_AND_INVERTED",
		VK_LOGIC_OP_NO_OP: "VK_LOGIC_OP_NO_OP",
		VK_LOGIC_OP_XOR: "VK_LOGIC_OP_XOR",
		VK_LOGIC_OP_OR: "VK_LOGIC_OP_OR",
		VK_LOGIC_OP_NOR: "VK_LOGIC_OP_NOR",
		VK_LOGIC_OP_EQUIVALENT: "VK_LOGIC_OP_EQUIVALENT",
		VK_LOGIC_OP_INVERT: "VK_LOGIC_OP_INVERT",
		VK_LOGIC_OP_OR_REVERSE: "VK_LOGIC_OP_OR_REVERSE",
		VK_LOGIC_OP_COPY_INVERTED: "VK_LOGIC_OP_COPY_INVERTED",
		VK_LOGIC_OP_OR_INVERTED: "VK_LOGIC_OP_OR_INVERTED",
		VK_LOGIC_OP_NAND: "VK_LOGIC_OP_NAND",
		VK_LOGIC_OP_SET: "VK_LOGIC_OP_SET",
	}
)
func (x LogicOp) String() string {
	if s, ok := reverseLogicOp[x]; ok {
		return s
	}
	return fmt.Sprintf("LogicOp=%d", x)
}

// SampleCountFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSampleCountFlagBits.html
type SampleCountFlagBits uint32

const (
	VK_SAMPLE_COUNT_1_BIT SampleCountFlagBits = (1 << 0)
	VK_SAMPLE_COUNT_2_BIT SampleCountFlagBits = (1 << 1)
	VK_SAMPLE_COUNT_4_BIT SampleCountFlagBits = (1 << 2)
	VK_SAMPLE_COUNT_8_BIT SampleCountFlagBits = (1 << 3)
	VK_SAMPLE_COUNT_16_BIT SampleCountFlagBits = (1 << 4)
	VK_SAMPLE_COUNT_32_BIT SampleCountFlagBits = (1 << 5)
	VK_SAMPLE_COUNT_64_BIT SampleCountFlagBits = (1 << 6)
)

var (
	reverseSampleCountFlagBits map[SampleCountFlagBits]string = map[SampleCountFlagBits]string{ 
		VK_SAMPLE_COUNT_1_BIT: "VK_SAMPLE_COUNT_1_BIT",
		VK_SAMPLE_COUNT_2_BIT: "VK_SAMPLE_COUNT_2_BIT",
		VK_SAMPLE_COUNT_4_BIT: "VK_SAMPLE_COUNT_4_BIT",
		VK_SAMPLE_COUNT_8_BIT: "VK_SAMPLE_COUNT_8_BIT",
		VK_SAMPLE_COUNT_16_BIT: "VK_SAMPLE_COUNT_16_BIT",
		VK_SAMPLE_COUNT_32_BIT: "VK_SAMPLE_COUNT_32_BIT",
		VK_SAMPLE_COUNT_64_BIT: "VK_SAMPLE_COUNT_64_BIT",
	}
)
func (x SampleCountFlagBits) String() string {
	if s, ok := reverseSampleCountFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("SampleCountFlagBits=%d", x)
}

// ColorComponentFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkColorComponentFlagBits.html
type ColorComponentFlagBits uint32

const (
	VK_COLOR_COMPONENT_R_BIT ColorComponentFlagBits = (1 << 0)
	VK_COLOR_COMPONENT_G_BIT ColorComponentFlagBits = (1 << 1)
	VK_COLOR_COMPONENT_B_BIT ColorComponentFlagBits = (1 << 2)
	VK_COLOR_COMPONENT_A_BIT ColorComponentFlagBits = (1 << 3)
)

var (
	reverseColorComponentFlagBits map[ColorComponentFlagBits]string = map[ColorComponentFlagBits]string{ 
		VK_COLOR_COMPONENT_R_BIT: "VK_COLOR_COMPONENT_R_BIT",
		VK_COLOR_COMPONENT_G_BIT: "VK_COLOR_COMPONENT_G_BIT",
		VK_COLOR_COMPONENT_B_BIT: "VK_COLOR_COMPONENT_B_BIT",
		VK_COLOR_COMPONENT_A_BIT: "VK_COLOR_COMPONENT_A_BIT",
	}
)
func (x ColorComponentFlagBits) String() string {
	if s, ok := reverseColorComponentFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ColorComponentFlagBits=%d", x)
}

// PipelineColorBlendStateCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineColorBlendStateCreateFlagBits.html
type PipelineColorBlendStateCreateFlagBits uint32

// PipelineColorBlendStateCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineColorBlendStateCreateFlags.html
type PipelineColorBlendStateCreateFlags Flags

// PipelineCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreateFlags.html
type PipelineCreateFlags Flags

// PipelineDepthStencilStateCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineDepthStencilStateCreateFlagBits.html
type PipelineDepthStencilStateCreateFlagBits uint32

// PipelineDepthStencilStateCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineDepthStencilStateCreateFlags.html
type PipelineDepthStencilStateCreateFlags Flags

// PipelineDynamicStateCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineDynamicStateCreateFlags.html
type PipelineDynamicStateCreateFlags Flags

// PipelineStageFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineStageFlags.html
type PipelineStageFlags Flags

// PipelineInputAssemblyStateCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineInputAssemblyStateCreateFlags.html
type PipelineInputAssemblyStateCreateFlags Flags

// PipelineLayoutCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineLayoutCreateFlagBits.html
type PipelineLayoutCreateFlagBits uint32

// PipelineLayoutCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineLayoutCreateFlags.html
type PipelineLayoutCreateFlags Flags

// PipelineMultisampleStateCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineMultisampleStateCreateFlags.html
type PipelineMultisampleStateCreateFlags Flags

// CullModeFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCullModeFlags.html
type CullModeFlags Flags

// PipelineRasterizationStateCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationStateCreateFlags.html
type PipelineRasterizationStateCreateFlags Flags

// DeviceQueueCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateFlagBits.html
type DeviceQueueCreateFlagBits uint32

const (
	VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT DeviceQueueCreateFlagBits = (1 << 0)
)

var (
	reverseDeviceQueueCreateFlagBits map[DeviceQueueCreateFlagBits]string = map[DeviceQueueCreateFlagBits]string{ 
		VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT: "VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT",
	}
)
func (x DeviceQueueCreateFlagBits) String() string {
	if s, ok := reverseDeviceQueueCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("DeviceQueueCreateFlagBits=%d", x)
}

// DeviceQueueCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateFlags.html
type DeviceQueueCreateFlags Flags

// ColorComponentFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkColorComponentFlags.html
type ColorComponentFlags Flags

// EventCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkEventCreateFlags.html
type EventCreateFlags Flags

// DeviceCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceCreateFlags.html
type DeviceCreateFlags Flags

// PipelineShaderStageCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageCreateFlags.html
type PipelineShaderStageCreateFlags Flags

// PipelineCacheCreateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCacheCreateFlagBits.html
type PipelineCacheCreateFlagBits uint32

const (
	VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT PipelineCacheCreateFlagBits = (1 << 0)
)

var (
	reversePipelineCacheCreateFlagBits map[PipelineCacheCreateFlagBits]string = map[PipelineCacheCreateFlagBits]string{ 
		VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT: "VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT",
	}
)
func (x PipelineCacheCreateFlagBits) String() string {
	if s, ok := reversePipelineCacheCreateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("PipelineCacheCreateFlagBits=%d", x)
}

// PipelineCacheCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCacheCreateFlags.html
type PipelineCacheCreateFlags Flags

// MemoryMapFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryMapFlags.html
type MemoryMapFlags Flags

// PipelineTessellationStateCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineTessellationStateCreateFlags.html
type PipelineTessellationStateCreateFlags Flags

// ShaderModuleCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderModuleCreateFlags.html
type ShaderModuleCreateFlags Flags

// PipelineVertexInputStateCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineVertexInputStateCreateFlags.html
type PipelineVertexInputStateCreateFlags Flags

// SampleCountFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSampleCountFlags.html
type SampleCountFlags Flags

// QueueFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFlags.html
type QueueFlags Flags

// ImageViewCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateFlags.html
type ImageViewCreateFlags Flags

// ShaderStageFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderStageFlags.html
type ShaderStageFlags Flags

// MemoryPropertyFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryPropertyFlags.html
type MemoryPropertyFlags Flags

// MemoryHeapFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryHeapFlags.html
type MemoryHeapFlags Flags

// InstanceCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateFlags.html
type InstanceCreateFlags Flags

// ImageUsageFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageUsageFlags.html
type ImageUsageFlags Flags

// ImageAspectFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageAspectFlags.html
type ImageAspectFlags Flags

// ImageCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCreateFlags.html
type ImageCreateFlags Flags

// BufferViewCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferViewCreateFlags.html
type BufferViewCreateFlags Flags

// FormatFeatureFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatFeatureFlags.html
type FormatFeatureFlags Flags

// SparseImageFormatFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageFormatFlags.html
type SparseImageFormatFlags Flags

// SamplerCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerCreateFlags.html
type SamplerCreateFlags Flags

// DescriptorPoolResetFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolResetFlags.html
type DescriptorPoolResetFlags Flags

// BufferUsageFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferUsageFlags.html
type BufferUsageFlags Flags

// DescriptorSetLayoutCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutCreateFlags.html
type DescriptorSetLayoutCreateFlags Flags

// BufferCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCreateFlags.html
type BufferCreateFlags Flags

// AccessFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccessFlags.html
type AccessFlags Flags

// AttachmentDescriptionFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentDescriptionFlags.html
type AttachmentDescriptionFlags Flags

// SparseMemoryBindFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseMemoryBindFlags.html
type SparseMemoryBindFlags Flags

// DependencyFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDependencyFlags.html
type DependencyFlags Flags

// FramebufferCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebufferCreateFlags.html
type FramebufferCreateFlags Flags

// QueryResultFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryResultFlags.html
type QueryResultFlags Flags

// RenderPassCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreateFlags.html
type RenderPassCreateFlags Flags

// SubpassDescriptionFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDescriptionFlags.html
type SubpassDescriptionFlags Flags

// CommandPoolCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolCreateFlags.html
type CommandPoolCreateFlags Flags

// CommandPoolResetFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolResetFlags.html
type CommandPoolResetFlags Flags

// FenceCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFenceCreateFlags.html
type FenceCreateFlags Flags

// QueryPoolCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPoolCreateFlags.html
type QueryPoolCreateFlags Flags

// CommandBufferResetFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferResetFlags.html
type CommandBufferResetFlags Flags

// QueryPipelineStatisticFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPipelineStatisticFlags.html
type QueryPipelineStatisticFlags Flags

// CommandBufferUsageFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferUsageFlags.html
type CommandBufferUsageFlags Flags

// SemaphoreCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreCreateFlags.html
type SemaphoreCreateFlags Flags

// QueryControlFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryControlFlags.html
type QueryControlFlags Flags

// StencilFaceFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkStencilFaceFlags.html
type StencilFaceFlags Flags

// DescriptorPoolCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolCreateFlags.html
type DescriptorPoolCreateFlags Flags

// PipelineViewportStateCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportStateCreateFlags.html
type PipelineViewportStateCreateFlags Flags

// PFN_vkReallocationFunction function pointer
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkReallocationFunction.html
type PFN_vkReallocationFunction C.PFN_vkReallocationFunction

// PFN_vkAllocationFunction function pointer
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkAllocationFunction.html
type PFN_vkAllocationFunction C.PFN_vkAllocationFunction

// PFN_vkFreeFunction function pointer
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkFreeFunction.html
type PFN_vkFreeFunction C.PFN_vkFreeFunction

// PFN_vkInternalAllocationNotification function pointer
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkInternalAllocationNotification.html
type PFN_vkInternalAllocationNotification C.PFN_vkInternalAllocationNotification

// PFN_vkInternalFreeNotification function pointer
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkInternalFreeNotification.html
type PFN_vkInternalFreeNotification C.PFN_vkInternalFreeNotification

// PFN_vkVoidFunction function pointer
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/PFN_vkVoidFunction.html
type PFN_vkVoidFunction C.PFN_vkVoidFunction

// CopyDescriptorSet provides a go interface for VkCopyDescriptorSet.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyDescriptorSet.html
type CopyDescriptorSet C.struct_VkCopyDescriptorSet

// SizeofCopyDescriptorSet is the memory size of a CopyDescriptorSet
var SizeofCopyDescriptorSet int = int(unsafe.Sizeof(CopyDescriptorSet{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *CopyDescriptorSet) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x CopyDescriptorSet) AsCPtr() *CopyDescriptorSet {
	clone := (*CopyDescriptorSet)(newCBlock(C.ulong(SizeofCopyDescriptorSet)))
	*clone = x
	return clone
}

// CopyDescriptorSetFreeCSlice releases the memory allocated by CopyDescriptorSetMakeCSlice.
// It does not free pointers stored inside the slice.
func CopyDescriptorSetFreeCSlice(x []CopyDescriptorSet) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// CopyDescriptorSetMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. CopyDescriptorSetFreeCSlice must be called on the returned slice.
func CopyDescriptorSetMakeCSlice(x ...CopyDescriptorSet) []CopyDescriptorSet {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCopyDescriptorSet * len(x)
	dst := unsafe.Slice((*CopyDescriptorSet)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkCopyDescriptorSet
func (x CopyDescriptorSet) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x CopyDescriptorSet) WithDefaultSType() CopyDescriptorSet {
	return x.WithSType(VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyDescriptorSet) WithSType(y StructureType) CopyDescriptorSet {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkCopyDescriptorSet
func (x CopyDescriptorSet) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyDescriptorSet) WithPNext(y unsafe.Pointer) CopyDescriptorSet {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SrcSet returns the value of srcSet from VkCopyDescriptorSet
func (x CopyDescriptorSet) SrcSet() DescriptorSet {
	ptr := /* handle */ (*DescriptorSet)(&x.srcSet) 
	return *ptr
}

// WithSrcSet sets the value for the SrcSet on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyDescriptorSet) WithSrcSet(y DescriptorSet) CopyDescriptorSet {
	x.srcSet = *(/* handle */ (*C.VkDescriptorSet)(&y))
	return x
}

// SrcBinding returns the value of srcBinding from VkCopyDescriptorSet
func (x CopyDescriptorSet) SrcBinding() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.srcBinding) 
	return *ptr
}

// WithSrcBinding sets the value for the SrcBinding on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyDescriptorSet) WithSrcBinding(y uint32) CopyDescriptorSet {
	x.srcBinding = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// SrcArrayElement returns the value of srcArrayElement from VkCopyDescriptorSet
func (x CopyDescriptorSet) SrcArrayElement() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.srcArrayElement) 
	return *ptr
}

// WithSrcArrayElement sets the value for the SrcArrayElement on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyDescriptorSet) WithSrcArrayElement(y uint32) CopyDescriptorSet {
	x.srcArrayElement = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// DstSet returns the value of dstSet from VkCopyDescriptorSet
func (x CopyDescriptorSet) DstSet() DescriptorSet {
	ptr := /* handle */ (*DescriptorSet)(&x.dstSet) 
	return *ptr
}

// WithDstSet sets the value for the DstSet on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyDescriptorSet) WithDstSet(y DescriptorSet) CopyDescriptorSet {
	x.dstSet = *(/* handle */ (*C.VkDescriptorSet)(&y))
	return x
}

// DstBinding returns the value of dstBinding from VkCopyDescriptorSet
func (x CopyDescriptorSet) DstBinding() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dstBinding) 
	return *ptr
}

// WithDstBinding sets the value for the DstBinding on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyDescriptorSet) WithDstBinding(y uint32) CopyDescriptorSet {
	x.dstBinding = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// DstArrayElement returns the value of dstArrayElement from VkCopyDescriptorSet
func (x CopyDescriptorSet) DstArrayElement() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dstArrayElement) 
	return *ptr
}

// WithDstArrayElement sets the value for the DstArrayElement on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyDescriptorSet) WithDstArrayElement(y uint32) CopyDescriptorSet {
	x.dstArrayElement = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// DescriptorCount returns the value of descriptorCount from VkCopyDescriptorSet
func (x CopyDescriptorSet) DescriptorCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.descriptorCount) 
	return *ptr
}

// WithDescriptorCount sets the value for the DescriptorCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyDescriptorSet) WithDescriptorCount(y uint32) CopyDescriptorSet {
	x.descriptorCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// ImageResolve provides a go interface for VkImageResolve.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageResolve.html
type ImageResolve C.struct_VkImageResolve

// SizeofImageResolve is the memory size of a ImageResolve
var SizeofImageResolve int = int(unsafe.Sizeof(ImageResolve{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageResolve) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageResolve) AsCPtr() *ImageResolve {
	clone := (*ImageResolve)(newCBlock(C.ulong(SizeofImageResolve)))
	*clone = x
	return clone
}

// ImageResolveFreeCSlice releases the memory allocated by ImageResolveMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageResolveFreeCSlice(x []ImageResolve) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageResolveMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageResolveFreeCSlice must be called on the returned slice.
func ImageResolveMakeCSlice(x ...ImageResolve) []ImageResolve {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageResolve * len(x)
	dst := unsafe.Slice((*ImageResolve)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SrcSubresource returns the value of srcSubresource from VkImageResolve
func (x ImageResolve) SrcSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.srcSubresource) 
	return *ptr
}

// WithSrcSubresource sets the value for the SrcSubresource on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve) WithSrcSubresource(y ImageSubresourceLayers) ImageResolve {
	x.srcSubresource = *(/* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}

// SrcOffset returns the value of srcOffset from VkImageResolve
func (x ImageResolve) SrcOffset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.srcOffset) 
	return *ptr
}

// WithSrcOffset sets the value for the SrcOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve) WithSrcOffset(y Offset3D) ImageResolve {
	x.srcOffset = *(/* typedef */ (*C.struct_VkOffset3D)(&y))
	return x
}

// DstSubresource returns the value of dstSubresource from VkImageResolve
func (x ImageResolve) DstSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.dstSubresource) 
	return *ptr
}

// WithDstSubresource sets the value for the DstSubresource on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve) WithDstSubresource(y ImageSubresourceLayers) ImageResolve {
	x.dstSubresource = *(/* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}

// DstOffset returns the value of dstOffset from VkImageResolve
func (x ImageResolve) DstOffset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.dstOffset) 
	return *ptr
}

// WithDstOffset sets the value for the DstOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve) WithDstOffset(y Offset3D) ImageResolve {
	x.dstOffset = *(/* typedef */ (*C.struct_VkOffset3D)(&y))
	return x
}

// Extent returns the value of extent from VkImageResolve
func (x ImageResolve) Extent() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.extent) 
	return *ptr
}

// WithExtent sets the value for the Extent on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve) WithExtent(y Extent3D) ImageResolve {
	x.extent = *(/* typedef */ (*C.struct_VkExtent3D)(&y))
	return x
}

// ImageCopy provides a go interface for VkImageCopy.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCopy.html
type ImageCopy C.struct_VkImageCopy

// SizeofImageCopy is the memory size of a ImageCopy
var SizeofImageCopy int = int(unsafe.Sizeof(ImageCopy{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageCopy) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageCopy) AsCPtr() *ImageCopy {
	clone := (*ImageCopy)(newCBlock(C.ulong(SizeofImageCopy)))
	*clone = x
	return clone
}

// ImageCopyFreeCSlice releases the memory allocated by ImageCopyMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageCopyFreeCSlice(x []ImageCopy) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageCopyMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageCopyFreeCSlice must be called on the returned slice.
func ImageCopyMakeCSlice(x ...ImageCopy) []ImageCopy {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageCopy * len(x)
	dst := unsafe.Slice((*ImageCopy)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SrcSubresource returns the value of srcSubresource from VkImageCopy
func (x ImageCopy) SrcSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.srcSubresource) 
	return *ptr
}

// WithSrcSubresource sets the value for the SrcSubresource on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy) WithSrcSubresource(y ImageSubresourceLayers) ImageCopy {
	x.srcSubresource = *(/* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}

// SrcOffset returns the value of srcOffset from VkImageCopy
func (x ImageCopy) SrcOffset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.srcOffset) 
	return *ptr
}

// WithSrcOffset sets the value for the SrcOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy) WithSrcOffset(y Offset3D) ImageCopy {
	x.srcOffset = *(/* typedef */ (*C.struct_VkOffset3D)(&y))
	return x
}

// DstSubresource returns the value of dstSubresource from VkImageCopy
func (x ImageCopy) DstSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.dstSubresource) 
	return *ptr
}

// WithDstSubresource sets the value for the DstSubresource on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy) WithDstSubresource(y ImageSubresourceLayers) ImageCopy {
	x.dstSubresource = *(/* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}

// DstOffset returns the value of dstOffset from VkImageCopy
func (x ImageCopy) DstOffset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.dstOffset) 
	return *ptr
}

// WithDstOffset sets the value for the DstOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy) WithDstOffset(y Offset3D) ImageCopy {
	x.dstOffset = *(/* typedef */ (*C.struct_VkOffset3D)(&y))
	return x
}

// Extent returns the value of extent from VkImageCopy
func (x ImageCopy) Extent() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.extent) 
	return *ptr
}

// WithExtent sets the value for the Extent on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy) WithExtent(y Extent3D) ImageCopy {
	x.extent = *(/* typedef */ (*C.struct_VkExtent3D)(&y))
	return x
}

// SemaphoreCreateInfo provides a go interface for VkSemaphoreCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreCreateInfo.html
type SemaphoreCreateInfo C.struct_VkSemaphoreCreateInfo

// SizeofSemaphoreCreateInfo is the memory size of a SemaphoreCreateInfo
var SizeofSemaphoreCreateInfo int = int(unsafe.Sizeof(SemaphoreCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SemaphoreCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SemaphoreCreateInfo) AsCPtr() *SemaphoreCreateInfo {
	clone := (*SemaphoreCreateInfo)(newCBlock(C.ulong(SizeofSemaphoreCreateInfo)))
	*clone = x
	return clone
}

// SemaphoreCreateInfoFreeCSlice releases the memory allocated by SemaphoreCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SemaphoreCreateInfoFreeCSlice(x []SemaphoreCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SemaphoreCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SemaphoreCreateInfoFreeCSlice must be called on the returned slice.
func SemaphoreCreateInfoMakeCSlice(x ...SemaphoreCreateInfo) []SemaphoreCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSemaphoreCreateInfo * len(x)
	dst := unsafe.Slice((*SemaphoreCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSemaphoreCreateInfo
func (x SemaphoreCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SemaphoreCreateInfo) WithDefaultSType() SemaphoreCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreCreateInfo) WithSType(y StructureType) SemaphoreCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkSemaphoreCreateInfo
func (x SemaphoreCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreCreateInfo) WithPNext(y unsafe.Pointer) SemaphoreCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkSemaphoreCreateInfo
func (x SemaphoreCreateInfo) Flags() SemaphoreCreateFlags {
	ptr := /* typedef */ (*SemaphoreCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreCreateInfo) WithFlags(y SemaphoreCreateFlags) SemaphoreCreateInfo {
	x.flags = *(/* typedef */ (*C.VkSemaphoreCreateFlags)(&y))
	return x
}

// ImageBlit provides a go interface for VkImageBlit.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageBlit.html
type ImageBlit C.struct_VkImageBlit

// SizeofImageBlit is the memory size of a ImageBlit
var SizeofImageBlit int = int(unsafe.Sizeof(ImageBlit{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageBlit) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageBlit) AsCPtr() *ImageBlit {
	clone := (*ImageBlit)(newCBlock(C.ulong(SizeofImageBlit)))
	*clone = x
	return clone
}

// ImageBlitFreeCSlice releases the memory allocated by ImageBlitMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageBlitFreeCSlice(x []ImageBlit) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageBlitMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageBlitFreeCSlice must be called on the returned slice.
func ImageBlitMakeCSlice(x ...ImageBlit) []ImageBlit {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageBlit * len(x)
	dst := unsafe.Slice((*ImageBlit)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SrcSubresource returns the value of srcSubresource from VkImageBlit
func (x ImageBlit) SrcSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.srcSubresource) 
	return *ptr
}

// WithSrcSubresource sets the value for the SrcSubresource on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageBlit) WithSrcSubresource(y ImageSubresourceLayers) ImageBlit {
	x.srcSubresource = *(/* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}

// SrcOffsets returns the value of srcOffsets from VkImageBlit
func (x ImageBlit) SrcOffsets() []Offset3D {
	ptr := func(x *[2]C.struct_VkOffset3D) *[]Offset3D { /* Array */ slc := unsafe.Slice((*Offset3D)(unsafe.Pointer(x)), 2); return &slc }(&x.srcOffsets) 
	return *ptr
}

// WithSrcOffsets sets the value for the SrcOffsets on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageBlit) WithSrcOffsets(y []Offset3D) ImageBlit {
	ptr := func(x *[]Offset3D) **C.struct_VkOffset3D { /* Array */ if len(*x) > 0 { slc := (*C.struct_VkOffset3D)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkOffset3D)(unsafe.Pointer((&ptr))) }(&y)
	copy(x.srcOffsets[:], unsafe.Slice(*ptr, len(y)))
	return x
}

// DstSubresource returns the value of dstSubresource from VkImageBlit
func (x ImageBlit) DstSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.dstSubresource) 
	return *ptr
}

// WithDstSubresource sets the value for the DstSubresource on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageBlit) WithDstSubresource(y ImageSubresourceLayers) ImageBlit {
	x.dstSubresource = *(/* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}

// DstOffsets returns the value of dstOffsets from VkImageBlit
func (x ImageBlit) DstOffsets() []Offset3D {
	ptr := func(x *[2]C.struct_VkOffset3D) *[]Offset3D { /* Array */ slc := unsafe.Slice((*Offset3D)(unsafe.Pointer(x)), 2); return &slc }(&x.dstOffsets) 
	return *ptr
}

// WithDstOffsets sets the value for the DstOffsets on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageBlit) WithDstOffsets(y []Offset3D) ImageBlit {
	ptr := func(x *[]Offset3D) **C.struct_VkOffset3D { /* Array */ if len(*x) > 0 { slc := (*C.struct_VkOffset3D)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkOffset3D)(unsafe.Pointer((&ptr))) }(&y)
	copy(x.dstOffsets[:], unsafe.Slice(*ptr, len(y)))
	return x
}

// DescriptorBufferInfo provides a go interface for VkDescriptorBufferInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorBufferInfo.html
type DescriptorBufferInfo C.struct_VkDescriptorBufferInfo

// SizeofDescriptorBufferInfo is the memory size of a DescriptorBufferInfo
var SizeofDescriptorBufferInfo int = int(unsafe.Sizeof(DescriptorBufferInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorBufferInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorBufferInfo) AsCPtr() *DescriptorBufferInfo {
	clone := (*DescriptorBufferInfo)(newCBlock(C.ulong(SizeofDescriptorBufferInfo)))
	*clone = x
	return clone
}

// DescriptorBufferInfoFreeCSlice releases the memory allocated by DescriptorBufferInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorBufferInfoFreeCSlice(x []DescriptorBufferInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorBufferInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorBufferInfoFreeCSlice must be called on the returned slice.
func DescriptorBufferInfoMakeCSlice(x ...DescriptorBufferInfo) []DescriptorBufferInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorBufferInfo * len(x)
	dst := unsafe.Slice((*DescriptorBufferInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Buffer returns the value of buffer from VkDescriptorBufferInfo
func (x DescriptorBufferInfo) Buffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.buffer) 
	return *ptr
}

// WithBuffer sets the value for the Buffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorBufferInfo) WithBuffer(y Buffer) DescriptorBufferInfo {
	x.buffer = *(/* handle */ (*C.VkBuffer)(&y))
	return x
}

// Offset returns the value of offset from VkDescriptorBufferInfo
func (x DescriptorBufferInfo) Offset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.offset) 
	return *ptr
}

// WithOffset sets the value for the Offset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorBufferInfo) WithOffset(y DeviceSize) DescriptorBufferInfo {
	x.offset = *(/* typedef */ (*C.VkDeviceSize)(&y))
	return x
}

// Range_ returns the value of range from VkDescriptorBufferInfo
func (x DescriptorBufferInfo) Range_() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x._range) 
	return *ptr
}

// WithRange_ sets the value for the Range_ on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorBufferInfo) WithRange_(y DeviceSize) DescriptorBufferInfo {
	x._range = *(/* typedef */ (*C.VkDeviceSize)(&y))
	return x
}

// FenceCreateInfo provides a go interface for VkFenceCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFenceCreateInfo.html
type FenceCreateInfo C.struct_VkFenceCreateInfo

// SizeofFenceCreateInfo is the memory size of a FenceCreateInfo
var SizeofFenceCreateInfo int = int(unsafe.Sizeof(FenceCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *FenceCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x FenceCreateInfo) AsCPtr() *FenceCreateInfo {
	clone := (*FenceCreateInfo)(newCBlock(C.ulong(SizeofFenceCreateInfo)))
	*clone = x
	return clone
}

// FenceCreateInfoFreeCSlice releases the memory allocated by FenceCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func FenceCreateInfoFreeCSlice(x []FenceCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// FenceCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. FenceCreateInfoFreeCSlice must be called on the returned slice.
func FenceCreateInfoMakeCSlice(x ...FenceCreateInfo) []FenceCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFenceCreateInfo * len(x)
	dst := unsafe.Slice((*FenceCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkFenceCreateInfo
func (x FenceCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x FenceCreateInfo) WithDefaultSType() FenceCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_FENCE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FenceCreateInfo) WithSType(y StructureType) FenceCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkFenceCreateInfo
func (x FenceCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FenceCreateInfo) WithPNext(y unsafe.Pointer) FenceCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkFenceCreateInfo
func (x FenceCreateInfo) Flags() FenceCreateFlags {
	ptr := /* typedef */ (*FenceCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FenceCreateInfo) WithFlags(y FenceCreateFlags) FenceCreateInfo {
	x.flags = *(/* typedef */ (*C.VkFenceCreateFlags)(&y))
	return x
}

// QueryPoolCreateInfo provides a go interface for VkQueryPoolCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueryPoolCreateInfo.html
type QueryPoolCreateInfo C.struct_VkQueryPoolCreateInfo

// SizeofQueryPoolCreateInfo is the memory size of a QueryPoolCreateInfo
var SizeofQueryPoolCreateInfo int = int(unsafe.Sizeof(QueryPoolCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *QueryPoolCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x QueryPoolCreateInfo) AsCPtr() *QueryPoolCreateInfo {
	clone := (*QueryPoolCreateInfo)(newCBlock(C.ulong(SizeofQueryPoolCreateInfo)))
	*clone = x
	return clone
}

// QueryPoolCreateInfoFreeCSlice releases the memory allocated by QueryPoolCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func QueryPoolCreateInfoFreeCSlice(x []QueryPoolCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// QueryPoolCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. QueryPoolCreateInfoFreeCSlice must be called on the returned slice.
func QueryPoolCreateInfoMakeCSlice(x ...QueryPoolCreateInfo) []QueryPoolCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofQueryPoolCreateInfo * len(x)
	dst := unsafe.Slice((*QueryPoolCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkQueryPoolCreateInfo
func (x QueryPoolCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x QueryPoolCreateInfo) WithDefaultSType() QueryPoolCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x QueryPoolCreateInfo) WithSType(y StructureType) QueryPoolCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkQueryPoolCreateInfo
func (x QueryPoolCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x QueryPoolCreateInfo) WithPNext(y unsafe.Pointer) QueryPoolCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkQueryPoolCreateInfo
func (x QueryPoolCreateInfo) Flags() QueryPoolCreateFlags {
	ptr := /* typedef */ (*QueryPoolCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x QueryPoolCreateInfo) WithFlags(y QueryPoolCreateFlags) QueryPoolCreateInfo {
	x.flags = *(/* typedef */ (*C.VkQueryPoolCreateFlags)(&y))
	return x
}

// QueryType returns the value of queryType from VkQueryPoolCreateInfo
func (x QueryPoolCreateInfo) QueryType() QueryType {
	ptr := /* typedef */ (*QueryType)(&x.queryType) 
	return *ptr
}

// WithQueryType sets the value for the QueryType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x QueryPoolCreateInfo) WithQueryType(y QueryType) QueryPoolCreateInfo {
	x.queryType = *(/* typedef */ (*C.VkQueryType)(&y))
	return x
}

// QueryCount returns the value of queryCount from VkQueryPoolCreateInfo
func (x QueryPoolCreateInfo) QueryCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.queryCount) 
	return *ptr
}

// WithQueryCount sets the value for the QueryCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x QueryPoolCreateInfo) WithQueryCount(y uint32) QueryPoolCreateInfo {
	x.queryCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PipelineStatistics returns the value of pipelineStatistics from VkQueryPoolCreateInfo
func (x QueryPoolCreateInfo) PipelineStatistics() QueryPipelineStatisticFlags {
	ptr := /* typedef */ (*QueryPipelineStatisticFlags)(&x.pipelineStatistics) 
	return *ptr
}

// WithPipelineStatistics sets the value for the PipelineStatistics on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x QueryPoolCreateInfo) WithPipelineStatistics(y QueryPipelineStatisticFlags) QueryPoolCreateInfo {
	x.pipelineStatistics = *(/* typedef */ (*C.VkQueryPipelineStatisticFlags)(&y))
	return x
}

// ClearRect provides a go interface for VkClearRect.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearRect.html
type ClearRect C.struct_VkClearRect

// SizeofClearRect is the memory size of a ClearRect
var SizeofClearRect int = int(unsafe.Sizeof(ClearRect{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ClearRect) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ClearRect) AsCPtr() *ClearRect {
	clone := (*ClearRect)(newCBlock(C.ulong(SizeofClearRect)))
	*clone = x
	return clone
}

// ClearRectFreeCSlice releases the memory allocated by ClearRectMakeCSlice.
// It does not free pointers stored inside the slice.
func ClearRectFreeCSlice(x []ClearRect) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ClearRectMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ClearRectFreeCSlice must be called on the returned slice.
func ClearRectMakeCSlice(x ...ClearRect) []ClearRect {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofClearRect * len(x)
	dst := unsafe.Slice((*ClearRect)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Rect returns the value of rect from VkClearRect
func (x ClearRect) Rect() Rect2D {
	ptr := /* typedef */ (*Rect2D)(&x.rect) 
	return *ptr
}

// WithRect sets the value for the Rect on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ClearRect) WithRect(y Rect2D) ClearRect {
	x.rect = *(/* typedef */ (*C.struct_VkRect2D)(&y))
	return x
}

// BaseArrayLayer returns the value of baseArrayLayer from VkClearRect
func (x ClearRect) BaseArrayLayer() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.baseArrayLayer) 
	return *ptr
}

// WithBaseArrayLayer sets the value for the BaseArrayLayer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ClearRect) WithBaseArrayLayer(y uint32) ClearRect {
	x.baseArrayLayer = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// LayerCount returns the value of layerCount from VkClearRect
func (x ClearRect) LayerCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.layerCount) 
	return *ptr
}

// WithLayerCount sets the value for the LayerCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ClearRect) WithLayerCount(y uint32) ClearRect {
	x.layerCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// ClearDepthStencilValue provides a go interface for VkClearDepthStencilValue.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearDepthStencilValue.html
type ClearDepthStencilValue C.struct_VkClearDepthStencilValue

// SizeofClearDepthStencilValue is the memory size of a ClearDepthStencilValue
var SizeofClearDepthStencilValue int = int(unsafe.Sizeof(ClearDepthStencilValue{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ClearDepthStencilValue) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ClearDepthStencilValue) AsCPtr() *ClearDepthStencilValue {
	clone := (*ClearDepthStencilValue)(newCBlock(C.ulong(SizeofClearDepthStencilValue)))
	*clone = x
	return clone
}

// ClearDepthStencilValueFreeCSlice releases the memory allocated by ClearDepthStencilValueMakeCSlice.
// It does not free pointers stored inside the slice.
func ClearDepthStencilValueFreeCSlice(x []ClearDepthStencilValue) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ClearDepthStencilValueMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ClearDepthStencilValueFreeCSlice must be called on the returned slice.
func ClearDepthStencilValueMakeCSlice(x ...ClearDepthStencilValue) []ClearDepthStencilValue {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofClearDepthStencilValue * len(x)
	dst := unsafe.Slice((*ClearDepthStencilValue)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Depth returns the value of depth from VkClearDepthStencilValue
func (x ClearDepthStencilValue) Depth() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.depth) 
	return *ptr
}

// WithDepth sets the value for the Depth on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ClearDepthStencilValue) WithDepth(y float32) ClearDepthStencilValue {
	x.depth = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}

// Stencil returns the value of stencil from VkClearDepthStencilValue
func (x ClearDepthStencilValue) Stencil() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.stencil) 
	return *ptr
}

// WithStencil sets the value for the Stencil on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ClearDepthStencilValue) WithStencil(y uint32) ClearDepthStencilValue {
	x.stencil = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PipelineCacheHeaderVersionOne provides a go interface for VkPipelineCacheHeaderVersionOne.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCacheHeaderVersionOne.html
type PipelineCacheHeaderVersionOne C.struct_VkPipelineCacheHeaderVersionOne

// SizeofPipelineCacheHeaderVersionOne is the memory size of a PipelineCacheHeaderVersionOne
var SizeofPipelineCacheHeaderVersionOne int = int(unsafe.Sizeof(PipelineCacheHeaderVersionOne{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineCacheHeaderVersionOne) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineCacheHeaderVersionOne) AsCPtr() *PipelineCacheHeaderVersionOne {
	clone := (*PipelineCacheHeaderVersionOne)(newCBlock(C.ulong(SizeofPipelineCacheHeaderVersionOne)))
	*clone = x
	return clone
}

// PipelineCacheHeaderVersionOneFreeCSlice releases the memory allocated by PipelineCacheHeaderVersionOneMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineCacheHeaderVersionOneFreeCSlice(x []PipelineCacheHeaderVersionOne) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineCacheHeaderVersionOneMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineCacheHeaderVersionOneFreeCSlice must be called on the returned slice.
func PipelineCacheHeaderVersionOneMakeCSlice(x ...PipelineCacheHeaderVersionOne) []PipelineCacheHeaderVersionOne {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineCacheHeaderVersionOne * len(x)
	dst := unsafe.Slice((*PipelineCacheHeaderVersionOne)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// HeaderSize returns the value of headerSize from VkPipelineCacheHeaderVersionOne
func (x PipelineCacheHeaderVersionOne) HeaderSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.headerSize) 
	return *ptr
}

// WithHeaderSize sets the value for the HeaderSize on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheHeaderVersionOne) WithHeaderSize(y uint32) PipelineCacheHeaderVersionOne {
	x.headerSize = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// HeaderVersion returns the value of headerVersion from VkPipelineCacheHeaderVersionOne
func (x PipelineCacheHeaderVersionOne) HeaderVersion() PipelineCacheHeaderVersion {
	ptr := /* typedef */ (*PipelineCacheHeaderVersion)(&x.headerVersion) 
	return *ptr
}

// WithHeaderVersion sets the value for the HeaderVersion on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheHeaderVersionOne) WithHeaderVersion(y PipelineCacheHeaderVersion) PipelineCacheHeaderVersionOne {
	x.headerVersion = *(/* typedef */ (*C.VkPipelineCacheHeaderVersion)(&y))
	return x
}

// VendorID returns the value of vendorID from VkPipelineCacheHeaderVersionOne
func (x PipelineCacheHeaderVersionOne) VendorID() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.vendorID) 
	return *ptr
}

// WithVendorID sets the value for the VendorID on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheHeaderVersionOne) WithVendorID(y uint32) PipelineCacheHeaderVersionOne {
	x.vendorID = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// DeviceID returns the value of deviceID from VkPipelineCacheHeaderVersionOne
func (x PipelineCacheHeaderVersionOne) DeviceID() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.deviceID) 
	return *ptr
}

// WithDeviceID sets the value for the DeviceID on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheHeaderVersionOne) WithDeviceID(y uint32) PipelineCacheHeaderVersionOne {
	x.deviceID = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PipelineCacheUUID returns the value of pipelineCacheUUID from VkPipelineCacheHeaderVersionOne
func (x PipelineCacheHeaderVersionOne) PipelineCacheUUID() []byte {
	ptr := func(x *[VK_UUID_SIZE]C.uint8_t) *[]byte { /* Array */ slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_UUID_SIZE); return &slc }(&x.pipelineCacheUUID) 
	return *ptr
}

// WithPipelineCacheUUID sets the value for the PipelineCacheUUID on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheHeaderVersionOne) WithPipelineCacheUUID(y []byte) PipelineCacheHeaderVersionOne {
	ptr := func(x *[]byte) **C.uint8_t { /* Array */ if len(*x) > 0 { slc := (*C.uint8_t)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.uint8_t)(unsafe.Pointer((&ptr))) }(&y)
	copy(x.pipelineCacheUUID[:], unsafe.Slice(*ptr, len(y)))
	return x
}

// ClearAttachment provides a go interface for VkClearAttachment.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearAttachment.html
type ClearAttachment C.struct_VkClearAttachment

// SizeofClearAttachment is the memory size of a ClearAttachment
var SizeofClearAttachment int = int(unsafe.Sizeof(ClearAttachment{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ClearAttachment) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ClearAttachment) AsCPtr() *ClearAttachment {
	clone := (*ClearAttachment)(newCBlock(C.ulong(SizeofClearAttachment)))
	*clone = x
	return clone
}

// ClearAttachmentFreeCSlice releases the memory allocated by ClearAttachmentMakeCSlice.
// It does not free pointers stored inside the slice.
func ClearAttachmentFreeCSlice(x []ClearAttachment) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ClearAttachmentMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ClearAttachmentFreeCSlice must be called on the returned slice.
func ClearAttachmentMakeCSlice(x ...ClearAttachment) []ClearAttachment {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofClearAttachment * len(x)
	dst := unsafe.Slice((*ClearAttachment)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// AspectMask returns the value of aspectMask from VkClearAttachment
func (x ClearAttachment) AspectMask() ImageAspectFlags {
	ptr := /* typedef */ (*ImageAspectFlags)(&x.aspectMask) 
	return *ptr
}

// WithAspectMask sets the value for the AspectMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ClearAttachment) WithAspectMask(y ImageAspectFlags) ClearAttachment {
	x.aspectMask = *(/* typedef */ (*C.VkImageAspectFlags)(&y))
	return x
}

// ColorAttachment returns the value of colorAttachment from VkClearAttachment
func (x ClearAttachment) ColorAttachment() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.colorAttachment) 
	return *ptr
}

// WithColorAttachment sets the value for the ColorAttachment on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ClearAttachment) WithColorAttachment(y uint32) ClearAttachment {
	x.colorAttachment = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// ClearValue returns the value of clearValue from VkClearAttachment
func (x ClearAttachment) ClearValue() ClearValue {
	ptr := /* typedef */ (*ClearValue)(&x.clearValue) 
	return *ptr
}

// WithClearValue sets the value for the ClearValue on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ClearAttachment) WithClearValue(y ClearValue) ClearAttachment {
	x.clearValue = *(/* typedef */ (*C.VkClearValue)(&y))
	return x
}

// BufferImageCopy provides a go interface for VkBufferImageCopy.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferImageCopy.html
type BufferImageCopy C.struct_VkBufferImageCopy

// SizeofBufferImageCopy is the memory size of a BufferImageCopy
var SizeofBufferImageCopy int = int(unsafe.Sizeof(BufferImageCopy{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferImageCopy) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferImageCopy) AsCPtr() *BufferImageCopy {
	clone := (*BufferImageCopy)(newCBlock(C.ulong(SizeofBufferImageCopy)))
	*clone = x
	return clone
}

// BufferImageCopyFreeCSlice releases the memory allocated by BufferImageCopyMakeCSlice.
// It does not free pointers stored inside the slice.
func BufferImageCopyFreeCSlice(x []BufferImageCopy) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferImageCopyMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferImageCopyFreeCSlice must be called on the returned slice.
func BufferImageCopyMakeCSlice(x ...BufferImageCopy) []BufferImageCopy {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferImageCopy * len(x)
	dst := unsafe.Slice((*BufferImageCopy)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// BufferOffset returns the value of bufferOffset from VkBufferImageCopy
func (x BufferImageCopy) BufferOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.bufferOffset) 
	return *ptr
}

// WithBufferOffset sets the value for the BufferOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy) WithBufferOffset(y DeviceSize) BufferImageCopy {
	x.bufferOffset = *(/* typedef */ (*C.VkDeviceSize)(&y))
	return x
}

// BufferRowLength returns the value of bufferRowLength from VkBufferImageCopy
func (x BufferImageCopy) BufferRowLength() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.bufferRowLength) 
	return *ptr
}

// WithBufferRowLength sets the value for the BufferRowLength on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy) WithBufferRowLength(y uint32) BufferImageCopy {
	x.bufferRowLength = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// BufferImageHeight returns the value of bufferImageHeight from VkBufferImageCopy
func (x BufferImageCopy) BufferImageHeight() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.bufferImageHeight) 
	return *ptr
}

// WithBufferImageHeight sets the value for the BufferImageHeight on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy) WithBufferImageHeight(y uint32) BufferImageCopy {
	x.bufferImageHeight = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// ImageSubresource returns the value of imageSubresource from VkBufferImageCopy
func (x BufferImageCopy) ImageSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.imageSubresource) 
	return *ptr
}

// WithImageSubresource sets the value for the ImageSubresource on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy) WithImageSubresource(y ImageSubresourceLayers) BufferImageCopy {
	x.imageSubresource = *(/* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}

// ImageOffset returns the value of imageOffset from VkBufferImageCopy
func (x BufferImageCopy) ImageOffset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.imageOffset) 
	return *ptr
}

// WithImageOffset sets the value for the ImageOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy) WithImageOffset(y Offset3D) BufferImageCopy {
	x.imageOffset = *(/* typedef */ (*C.struct_VkOffset3D)(&y))
	return x
}

// ImageExtent returns the value of imageExtent from VkBufferImageCopy
func (x BufferImageCopy) ImageExtent() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.imageExtent) 
	return *ptr
}

// WithImageExtent sets the value for the ImageExtent on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy) WithImageExtent(y Extent3D) BufferImageCopy {
	x.imageExtent = *(/* typedef */ (*C.struct_VkExtent3D)(&y))
	return x
}

// BufferCopy provides a go interface for VkBufferCopy.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCopy.html
type BufferCopy C.struct_VkBufferCopy

// SizeofBufferCopy is the memory size of a BufferCopy
var SizeofBufferCopy int = int(unsafe.Sizeof(BufferCopy{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferCopy) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferCopy) AsCPtr() *BufferCopy {
	clone := (*BufferCopy)(newCBlock(C.ulong(SizeofBufferCopy)))
	*clone = x
	return clone
}

// BufferCopyFreeCSlice releases the memory allocated by BufferCopyMakeCSlice.
// It does not free pointers stored inside the slice.
func BufferCopyFreeCSlice(x []BufferCopy) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferCopyMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferCopyFreeCSlice must be called on the returned slice.
func BufferCopyMakeCSlice(x ...BufferCopy) []BufferCopy {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferCopy * len(x)
	dst := unsafe.Slice((*BufferCopy)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SrcOffset returns the value of srcOffset from VkBufferCopy
func (x BufferCopy) SrcOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.srcOffset) 
	return *ptr
}

// WithSrcOffset sets the value for the SrcOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCopy) WithSrcOffset(y DeviceSize) BufferCopy {
	x.srcOffset = *(/* typedef */ (*C.VkDeviceSize)(&y))
	return x
}

// DstOffset returns the value of dstOffset from VkBufferCopy
func (x BufferCopy) DstOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.dstOffset) 
	return *ptr
}

// WithDstOffset sets the value for the DstOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCopy) WithDstOffset(y DeviceSize) BufferCopy {
	x.dstOffset = *(/* typedef */ (*C.VkDeviceSize)(&y))
	return x
}

// Size returns the value of size from VkBufferCopy
func (x BufferCopy) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size) 
	return *ptr
}

// WithSize sets the value for the Size on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCopy) WithSize(y DeviceSize) BufferCopy {
	x.size = *(/* typedef */ (*C.VkDeviceSize)(&y))
	return x
}

// SparseMemoryBind provides a go interface for VkSparseMemoryBind.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseMemoryBind.html
type SparseMemoryBind C.struct_VkSparseMemoryBind

// SizeofSparseMemoryBind is the memory size of a SparseMemoryBind
var SizeofSparseMemoryBind int = int(unsafe.Sizeof(SparseMemoryBind{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SparseMemoryBind) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SparseMemoryBind) AsCPtr() *SparseMemoryBind {
	clone := (*SparseMemoryBind)(newCBlock(C.ulong(SizeofSparseMemoryBind)))
	*clone = x
	return clone
}

// SparseMemoryBindFreeCSlice releases the memory allocated by SparseMemoryBindMakeCSlice.
// It does not free pointers stored inside the slice.
func SparseMemoryBindFreeCSlice(x []SparseMemoryBind) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SparseMemoryBindMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SparseMemoryBindFreeCSlice must be called on the returned slice.
func SparseMemoryBindMakeCSlice(x ...SparseMemoryBind) []SparseMemoryBind {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseMemoryBind * len(x)
	dst := unsafe.Slice((*SparseMemoryBind)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// ResourceOffset returns the value of resourceOffset from VkSparseMemoryBind
func (x SparseMemoryBind) ResourceOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.resourceOffset) 
	return *ptr
}

// WithResourceOffset sets the value for the ResourceOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseMemoryBind) WithResourceOffset(y DeviceSize) SparseMemoryBind {
	x.resourceOffset = *(/* typedef */ (*C.VkDeviceSize)(&y))
	return x
}

// Size returns the value of size from VkSparseMemoryBind
func (x SparseMemoryBind) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size) 
	return *ptr
}

// WithSize sets the value for the Size on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseMemoryBind) WithSize(y DeviceSize) SparseMemoryBind {
	x.size = *(/* typedef */ (*C.VkDeviceSize)(&y))
	return x
}

// Memory returns the value of memory from VkSparseMemoryBind
func (x SparseMemoryBind) Memory() DeviceMemory {
	ptr := /* handle */ (*DeviceMemory)(&x.memory) 
	return *ptr
}

// WithMemory sets the value for the Memory on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseMemoryBind) WithMemory(y DeviceMemory) SparseMemoryBind {
	x.memory = *(/* handle */ (*C.VkDeviceMemory)(&y))
	return x
}

// MemoryOffset returns the value of memoryOffset from VkSparseMemoryBind
func (x SparseMemoryBind) MemoryOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.memoryOffset) 
	return *ptr
}

// WithMemoryOffset sets the value for the MemoryOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseMemoryBind) WithMemoryOffset(y DeviceSize) SparseMemoryBind {
	x.memoryOffset = *(/* typedef */ (*C.VkDeviceSize)(&y))
	return x
}

// Flags returns the value of flags from VkSparseMemoryBind
func (x SparseMemoryBind) Flags() SparseMemoryBindFlags {
	ptr := /* typedef */ (*SparseMemoryBindFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseMemoryBind) WithFlags(y SparseMemoryBindFlags) SparseMemoryBind {
	x.flags = *(/* typedef */ (*C.VkSparseMemoryBindFlags)(&y))
	return x
}

// SparseImageOpaqueMemoryBindInfo provides a go interface for VkSparseImageOpaqueMemoryBindInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageOpaqueMemoryBindInfo.html
type SparseImageOpaqueMemoryBindInfo C.struct_VkSparseImageOpaqueMemoryBindInfo

// SizeofSparseImageOpaqueMemoryBindInfo is the memory size of a SparseImageOpaqueMemoryBindInfo
var SizeofSparseImageOpaqueMemoryBindInfo int = int(unsafe.Sizeof(SparseImageOpaqueMemoryBindInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SparseImageOpaqueMemoryBindInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SparseImageOpaqueMemoryBindInfo) AsCPtr() *SparseImageOpaqueMemoryBindInfo {
	clone := (*SparseImageOpaqueMemoryBindInfo)(newCBlock(C.ulong(SizeofSparseImageOpaqueMemoryBindInfo)))
	*clone = x
	return clone
}

// SparseImageOpaqueMemoryBindInfoFreeCSlice releases the memory allocated by SparseImageOpaqueMemoryBindInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SparseImageOpaqueMemoryBindInfoFreeCSlice(x []SparseImageOpaqueMemoryBindInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SparseImageOpaqueMemoryBindInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SparseImageOpaqueMemoryBindInfoFreeCSlice must be called on the returned slice.
func SparseImageOpaqueMemoryBindInfoMakeCSlice(x ...SparseImageOpaqueMemoryBindInfo) []SparseImageOpaqueMemoryBindInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageOpaqueMemoryBindInfo * len(x)
	dst := unsafe.Slice((*SparseImageOpaqueMemoryBindInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Image returns the value of image from VkSparseImageOpaqueMemoryBindInfo
func (x SparseImageOpaqueMemoryBindInfo) Image() Image {
	ptr := /* handle */ (*Image)(&x.image) 
	return *ptr
}

// WithImage sets the value for the Image on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageOpaqueMemoryBindInfo) WithImage(y Image) SparseImageOpaqueMemoryBindInfo {
	x.image = *(/* handle */ (*C.VkImage)(&y))
	return x
}

// BindCount returns the value of bindCount from VkSparseImageOpaqueMemoryBindInfo
func (x SparseImageOpaqueMemoryBindInfo) BindCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.bindCount) 
	return *ptr
}

// WithBindCount sets the value for the BindCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageOpaqueMemoryBindInfo) WithBindCount(y uint32) SparseImageOpaqueMemoryBindInfo {
	x.bindCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PBinds returns the value of pBinds from VkSparseImageOpaqueMemoryBindInfo
func (x SparseImageOpaqueMemoryBindInfo) PBinds() []SparseMemoryBind {
	ptr := func(x **C.struct_VkSparseMemoryBind) *[]SparseMemoryBind { /* Slice */ slc := unsafe.Slice((*SparseMemoryBind)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pBinds) 
	return *ptr
}

// WithPBinds sets the value for the PBinds on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines BindCount as the length of this field.
// BindCount is updated with the length of the new value.
func (x SparseImageOpaqueMemoryBindInfo) WithPBinds(y []SparseMemoryBind) SparseImageOpaqueMemoryBindInfo {
	x.pBinds = *(func(x *[]SparseMemoryBind) **C.struct_VkSparseMemoryBind { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkSparseMemoryBind)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkSparseMemoryBind)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithBindCount(uint32(len(y)))
}

// BufferCreateInfo provides a go interface for VkBufferCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCreateInfo.html
type BufferCreateInfo C.struct_VkBufferCreateInfo

// SizeofBufferCreateInfo is the memory size of a BufferCreateInfo
var SizeofBufferCreateInfo int = int(unsafe.Sizeof(BufferCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferCreateInfo) AsCPtr() *BufferCreateInfo {
	clone := (*BufferCreateInfo)(newCBlock(C.ulong(SizeofBufferCreateInfo)))
	*clone = x
	return clone
}

// BufferCreateInfoFreeCSlice releases the memory allocated by BufferCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BufferCreateInfoFreeCSlice(x []BufferCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferCreateInfoFreeCSlice must be called on the returned slice.
func BufferCreateInfoMakeCSlice(x ...BufferCreateInfo) []BufferCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferCreateInfo * len(x)
	dst := unsafe.Slice((*BufferCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBufferCreateInfo
func (x BufferCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BufferCreateInfo) WithDefaultSType() BufferCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCreateInfo) WithSType(y StructureType) BufferCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkBufferCreateInfo
func (x BufferCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCreateInfo) WithPNext(y unsafe.Pointer) BufferCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkBufferCreateInfo
func (x BufferCreateInfo) Flags() BufferCreateFlags {
	ptr := /* typedef */ (*BufferCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCreateInfo) WithFlags(y BufferCreateFlags) BufferCreateInfo {
	x.flags = *(/* typedef */ (*C.VkBufferCreateFlags)(&y))
	return x
}

// Size returns the value of size from VkBufferCreateInfo
func (x BufferCreateInfo) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size) 
	return *ptr
}

// WithSize sets the value for the Size on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCreateInfo) WithSize(y DeviceSize) BufferCreateInfo {
	x.size = *(/* typedef */ (*C.VkDeviceSize)(&y))
	return x
}

// Usage returns the value of usage from VkBufferCreateInfo
func (x BufferCreateInfo) Usage() BufferUsageFlags {
	ptr := /* typedef */ (*BufferUsageFlags)(&x.usage) 
	return *ptr
}

// WithUsage sets the value for the Usage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCreateInfo) WithUsage(y BufferUsageFlags) BufferCreateInfo {
	x.usage = *(/* typedef */ (*C.VkBufferUsageFlags)(&y))
	return x
}

// SharingMode returns the value of sharingMode from VkBufferCreateInfo
func (x BufferCreateInfo) SharingMode() SharingMode {
	ptr := /* typedef */ (*SharingMode)(&x.sharingMode) 
	return *ptr
}

// WithSharingMode sets the value for the SharingMode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCreateInfo) WithSharingMode(y SharingMode) BufferCreateInfo {
	x.sharingMode = *(/* typedef */ (*C.VkSharingMode)(&y))
	return x
}

// QueueFamilyIndexCount returns the value of queueFamilyIndexCount from VkBufferCreateInfo
func (x BufferCreateInfo) QueueFamilyIndexCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.queueFamilyIndexCount) 
	return *ptr
}

// WithQueueFamilyIndexCount sets the value for the QueueFamilyIndexCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCreateInfo) WithQueueFamilyIndexCount(y uint32) BufferCreateInfo {
	x.queueFamilyIndexCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PQueueFamilyIndices returns the value of pQueueFamilyIndices from VkBufferCreateInfo
func (x BufferCreateInfo) PQueueFamilyIndices() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */ slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pQueueFamilyIndices) 
	return *ptr
}

// WithPQueueFamilyIndices sets the value for the PQueueFamilyIndices on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines QueueFamilyIndexCount as the length of this field.
// QueueFamilyIndexCount is updated with the length of the new value.
func (x BufferCreateInfo) WithPQueueFamilyIndices(y []uint32) BufferCreateInfo {
	x.pQueueFamilyIndices = *(func(x *[]uint32) **C.uint32_t { /* Slice */ if len(*x) > 0 { slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.uint32_t)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithQueueFamilyIndexCount(uint32(len(y)))
}

// SparseImageMemoryRequirements provides a go interface for VkSparseImageMemoryRequirements.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageMemoryRequirements.html
type SparseImageMemoryRequirements C.struct_VkSparseImageMemoryRequirements

// SizeofSparseImageMemoryRequirements is the memory size of a SparseImageMemoryRequirements
var SizeofSparseImageMemoryRequirements int = int(unsafe.Sizeof(SparseImageMemoryRequirements{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SparseImageMemoryRequirements) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SparseImageMemoryRequirements) AsCPtr() *SparseImageMemoryRequirements {
	clone := (*SparseImageMemoryRequirements)(newCBlock(C.ulong(SizeofSparseImageMemoryRequirements)))
	*clone = x
	return clone
}

// SparseImageMemoryRequirementsFreeCSlice releases the memory allocated by SparseImageMemoryRequirementsMakeCSlice.
// It does not free pointers stored inside the slice.
func SparseImageMemoryRequirementsFreeCSlice(x []SparseImageMemoryRequirements) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SparseImageMemoryRequirementsMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SparseImageMemoryRequirementsFreeCSlice must be called on the returned slice.
func SparseImageMemoryRequirementsMakeCSlice(x ...SparseImageMemoryRequirements) []SparseImageMemoryRequirements {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageMemoryRequirements * len(x)
	dst := unsafe.Slice((*SparseImageMemoryRequirements)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// FormatProperties returns the value of formatProperties from VkSparseImageMemoryRequirements
func (x SparseImageMemoryRequirements) FormatProperties() SparseImageFormatProperties {
	ptr := /* typedef */ (*SparseImageFormatProperties)(&x.formatProperties) 
	return *ptr
}

// ImageMipTailFirstLod returns the value of imageMipTailFirstLod from VkSparseImageMemoryRequirements
func (x SparseImageMemoryRequirements) ImageMipTailFirstLod() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.imageMipTailFirstLod) 
	return *ptr
}

// ImageMipTailSize returns the value of imageMipTailSize from VkSparseImageMemoryRequirements
func (x SparseImageMemoryRequirements) ImageMipTailSize() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.imageMipTailSize) 
	return *ptr
}

// ImageMipTailOffset returns the value of imageMipTailOffset from VkSparseImageMemoryRequirements
func (x SparseImageMemoryRequirements) ImageMipTailOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.imageMipTailOffset) 
	return *ptr
}

// ImageMipTailStride returns the value of imageMipTailStride from VkSparseImageMemoryRequirements
func (x SparseImageMemoryRequirements) ImageMipTailStride() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.imageMipTailStride) 
	return *ptr
}

// SparseImageMemoryBindInfo provides a go interface for VkSparseImageMemoryBindInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageMemoryBindInfo.html
type SparseImageMemoryBindInfo C.struct_VkSparseImageMemoryBindInfo

// SizeofSparseImageMemoryBindInfo is the memory size of a SparseImageMemoryBindInfo
var SizeofSparseImageMemoryBindInfo int = int(unsafe.Sizeof(SparseImageMemoryBindInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SparseImageMemoryBindInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SparseImageMemoryBindInfo) AsCPtr() *SparseImageMemoryBindInfo {
	clone := (*SparseImageMemoryBindInfo)(newCBlock(C.ulong(SizeofSparseImageMemoryBindInfo)))
	*clone = x
	return clone
}

// SparseImageMemoryBindInfoFreeCSlice releases the memory allocated by SparseImageMemoryBindInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SparseImageMemoryBindInfoFreeCSlice(x []SparseImageMemoryBindInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SparseImageMemoryBindInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SparseImageMemoryBindInfoFreeCSlice must be called on the returned slice.
func SparseImageMemoryBindInfoMakeCSlice(x ...SparseImageMemoryBindInfo) []SparseImageMemoryBindInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageMemoryBindInfo * len(x)
	dst := unsafe.Slice((*SparseImageMemoryBindInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Image returns the value of image from VkSparseImageMemoryBindInfo
func (x SparseImageMemoryBindInfo) Image() Image {
	ptr := /* handle */ (*Image)(&x.image) 
	return *ptr
}

// WithImage sets the value for the Image on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryBindInfo) WithImage(y Image) SparseImageMemoryBindInfo {
	x.image = *(/* handle */ (*C.VkImage)(&y))
	return x
}

// BindCount returns the value of bindCount from VkSparseImageMemoryBindInfo
func (x SparseImageMemoryBindInfo) BindCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.bindCount) 
	return *ptr
}

// WithBindCount sets the value for the BindCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryBindInfo) WithBindCount(y uint32) SparseImageMemoryBindInfo {
	x.bindCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PBinds returns the value of pBinds from VkSparseImageMemoryBindInfo
func (x SparseImageMemoryBindInfo) PBinds() []SparseImageMemoryBind {
	ptr := func(x **C.struct_VkSparseImageMemoryBind) *[]SparseImageMemoryBind { /* Slice */ slc := unsafe.Slice((*SparseImageMemoryBind)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pBinds) 
	return *ptr
}

// WithPBinds sets the value for the PBinds on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines BindCount as the length of this field.
// BindCount is updated with the length of the new value.
func (x SparseImageMemoryBindInfo) WithPBinds(y []SparseImageMemoryBind) SparseImageMemoryBindInfo {
	x.pBinds = *(func(x *[]SparseImageMemoryBind) **C.struct_VkSparseImageMemoryBind { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkSparseImageMemoryBind)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkSparseImageMemoryBind)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithBindCount(uint32(len(y)))
}

// SparseImageMemoryBind provides a go interface for VkSparseImageMemoryBind.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageMemoryBind.html
type SparseImageMemoryBind C.struct_VkSparseImageMemoryBind

// SizeofSparseImageMemoryBind is the memory size of a SparseImageMemoryBind
var SizeofSparseImageMemoryBind int = int(unsafe.Sizeof(SparseImageMemoryBind{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SparseImageMemoryBind) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SparseImageMemoryBind) AsCPtr() *SparseImageMemoryBind {
	clone := (*SparseImageMemoryBind)(newCBlock(C.ulong(SizeofSparseImageMemoryBind)))
	*clone = x
	return clone
}

// SparseImageMemoryBindFreeCSlice releases the memory allocated by SparseImageMemoryBindMakeCSlice.
// It does not free pointers stored inside the slice.
func SparseImageMemoryBindFreeCSlice(x []SparseImageMemoryBind) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SparseImageMemoryBindMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SparseImageMemoryBindFreeCSlice must be called on the returned slice.
func SparseImageMemoryBindMakeCSlice(x ...SparseImageMemoryBind) []SparseImageMemoryBind {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageMemoryBind * len(x)
	dst := unsafe.Slice((*SparseImageMemoryBind)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Subresource returns the value of subresource from VkSparseImageMemoryBind
func (x SparseImageMemoryBind) Subresource() ImageSubresource {
	ptr := /* typedef */ (*ImageSubresource)(&x.subresource) 
	return *ptr
}

// WithSubresource sets the value for the Subresource on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryBind) WithSubresource(y ImageSubresource) SparseImageMemoryBind {
	x.subresource = *(/* typedef */ (*C.struct_VkImageSubresource)(&y))
	return x
}

// Offset returns the value of offset from VkSparseImageMemoryBind
func (x SparseImageMemoryBind) Offset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.offset) 
	return *ptr
}

// WithOffset sets the value for the Offset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryBind) WithOffset(y Offset3D) SparseImageMemoryBind {
	x.offset = *(/* typedef */ (*C.struct_VkOffset3D)(&y))
	return x
}

// Extent returns the value of extent from VkSparseImageMemoryBind
func (x SparseImageMemoryBind) Extent() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.extent) 
	return *ptr
}

// WithExtent sets the value for the Extent on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryBind) WithExtent(y Extent3D) SparseImageMemoryBind {
	x.extent = *(/* typedef */ (*C.struct_VkExtent3D)(&y))
	return x
}

// Memory returns the value of memory from VkSparseImageMemoryBind
func (x SparseImageMemoryBind) Memory() DeviceMemory {
	ptr := /* handle */ (*DeviceMemory)(&x.memory) 
	return *ptr
}

// WithMemory sets the value for the Memory on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryBind) WithMemory(y DeviceMemory) SparseImageMemoryBind {
	x.memory = *(/* handle */ (*C.VkDeviceMemory)(&y))
	return x
}

// MemoryOffset returns the value of memoryOffset from VkSparseImageMemoryBind
func (x SparseImageMemoryBind) MemoryOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.memoryOffset) 
	return *ptr
}

// WithMemoryOffset sets the value for the MemoryOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryBind) WithMemoryOffset(y DeviceSize) SparseImageMemoryBind {
	x.memoryOffset = *(/* typedef */ (*C.VkDeviceSize)(&y))
	return x
}

// Flags returns the value of flags from VkSparseImageMemoryBind
func (x SparseImageMemoryBind) Flags() SparseMemoryBindFlags {
	ptr := /* typedef */ (*SparseMemoryBindFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryBind) WithFlags(y SparseMemoryBindFlags) SparseImageMemoryBind {
	x.flags = *(/* typedef */ (*C.VkSparseMemoryBindFlags)(&y))
	return x
}

// ImageSubresourceLayers provides a go interface for VkImageSubresourceLayers.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSubresourceLayers.html
type ImageSubresourceLayers C.struct_VkImageSubresourceLayers

// SizeofImageSubresourceLayers is the memory size of a ImageSubresourceLayers
var SizeofImageSubresourceLayers int = int(unsafe.Sizeof(ImageSubresourceLayers{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageSubresourceLayers) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageSubresourceLayers) AsCPtr() *ImageSubresourceLayers {
	clone := (*ImageSubresourceLayers)(newCBlock(C.ulong(SizeofImageSubresourceLayers)))
	*clone = x
	return clone
}

// ImageSubresourceLayersFreeCSlice releases the memory allocated by ImageSubresourceLayersMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageSubresourceLayersFreeCSlice(x []ImageSubresourceLayers) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageSubresourceLayersMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageSubresourceLayersFreeCSlice must be called on the returned slice.
func ImageSubresourceLayersMakeCSlice(x ...ImageSubresourceLayers) []ImageSubresourceLayers {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageSubresourceLayers * len(x)
	dst := unsafe.Slice((*ImageSubresourceLayers)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// AspectMask returns the value of aspectMask from VkImageSubresourceLayers
func (x ImageSubresourceLayers) AspectMask() ImageAspectFlags {
	ptr := /* typedef */ (*ImageAspectFlags)(&x.aspectMask) 
	return *ptr
}

// WithAspectMask sets the value for the AspectMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresourceLayers) WithAspectMask(y ImageAspectFlags) ImageSubresourceLayers {
	x.aspectMask = *(/* typedef */ (*C.VkImageAspectFlags)(&y))
	return x
}

// MipLevel returns the value of mipLevel from VkImageSubresourceLayers
func (x ImageSubresourceLayers) MipLevel() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.mipLevel) 
	return *ptr
}

// WithMipLevel sets the value for the MipLevel on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresourceLayers) WithMipLevel(y uint32) ImageSubresourceLayers {
	x.mipLevel = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// BaseArrayLayer returns the value of baseArrayLayer from VkImageSubresourceLayers
func (x ImageSubresourceLayers) BaseArrayLayer() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.baseArrayLayer) 
	return *ptr
}

// WithBaseArrayLayer sets the value for the BaseArrayLayer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresourceLayers) WithBaseArrayLayer(y uint32) ImageSubresourceLayers {
	x.baseArrayLayer = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// LayerCount returns the value of layerCount from VkImageSubresourceLayers
func (x ImageSubresourceLayers) LayerCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.layerCount) 
	return *ptr
}

// WithLayerCount sets the value for the LayerCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresourceLayers) WithLayerCount(y uint32) ImageSubresourceLayers {
	x.layerCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// Offset3D provides a go interface for VkOffset3D.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkOffset3D.html
type Offset3D C.struct_VkOffset3D

// SizeofOffset3D is the memory size of a Offset3D
var SizeofOffset3D int = int(unsafe.Sizeof(Offset3D{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *Offset3D) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x Offset3D) AsCPtr() *Offset3D {
	clone := (*Offset3D)(newCBlock(C.ulong(SizeofOffset3D)))
	*clone = x
	return clone
}

// Offset3DFreeCSlice releases the memory allocated by Offset3DMakeCSlice.
// It does not free pointers stored inside the slice.
func Offset3DFreeCSlice(x []Offset3D) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// Offset3DMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. Offset3DFreeCSlice must be called on the returned slice.
func Offset3DMakeCSlice(x ...Offset3D) []Offset3D {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofOffset3D * len(x)
	dst := unsafe.Slice((*Offset3D)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// X returns the value of x from VkOffset3D
func (x Offset3D) X() int32 {
	ptr := func(x *C.int32_t) *int32 { /* Scalar */ c2g := int32(*x); return &c2g }(&x.x) 
	return *ptr
}

// WithX sets the value for the X on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Offset3D) WithX(y int32) Offset3D {
	x.x = *(func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&y))
	return x
}

// Y returns the value of y from VkOffset3D
func (x Offset3D) Y() int32 {
	ptr := func(x *C.int32_t) *int32 { /* Scalar */ c2g := int32(*x); return &c2g }(&x.y) 
	return *ptr
}

// WithY sets the value for the Y on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Offset3D) WithY(y int32) Offset3D {
	x.y = *(func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&y))
	return x
}

// Z returns the value of z from VkOffset3D
func (x Offset3D) Z() int32 {
	ptr := func(x *C.int32_t) *int32 { /* Scalar */ c2g := int32(*x); return &c2g }(&x.z) 
	return *ptr
}

// WithZ sets the value for the Z on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Offset3D) WithZ(y int32) Offset3D {
	x.z = *(func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&y))
	return x
}

// SparseImageFormatProperties provides a go interface for VkSparseImageFormatProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageFormatProperties.html
type SparseImageFormatProperties C.struct_VkSparseImageFormatProperties

// SizeofSparseImageFormatProperties is the memory size of a SparseImageFormatProperties
var SizeofSparseImageFormatProperties int = int(unsafe.Sizeof(SparseImageFormatProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SparseImageFormatProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SparseImageFormatProperties) AsCPtr() *SparseImageFormatProperties {
	clone := (*SparseImageFormatProperties)(newCBlock(C.ulong(SizeofSparseImageFormatProperties)))
	*clone = x
	return clone
}

// SparseImageFormatPropertiesFreeCSlice releases the memory allocated by SparseImageFormatPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func SparseImageFormatPropertiesFreeCSlice(x []SparseImageFormatProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SparseImageFormatPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SparseImageFormatPropertiesFreeCSlice must be called on the returned slice.
func SparseImageFormatPropertiesMakeCSlice(x ...SparseImageFormatProperties) []SparseImageFormatProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageFormatProperties * len(x)
	dst := unsafe.Slice((*SparseImageFormatProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// AspectMask returns the value of aspectMask from VkSparseImageFormatProperties
func (x SparseImageFormatProperties) AspectMask() ImageAspectFlags {
	ptr := /* typedef */ (*ImageAspectFlags)(&x.aspectMask) 
	return *ptr
}

// ImageGranularity returns the value of imageGranularity from VkSparseImageFormatProperties
func (x SparseImageFormatProperties) ImageGranularity() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.imageGranularity) 
	return *ptr
}

// Flags returns the value of flags from VkSparseImageFormatProperties
func (x SparseImageFormatProperties) Flags() SparseImageFormatFlags {
	ptr := /* typedef */ (*SparseImageFormatFlags)(&x.flags) 
	return *ptr
}

// SparseBufferMemoryBindInfo provides a go interface for VkSparseBufferMemoryBindInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseBufferMemoryBindInfo.html
type SparseBufferMemoryBindInfo C.struct_VkSparseBufferMemoryBindInfo

// SizeofSparseBufferMemoryBindInfo is the memory size of a SparseBufferMemoryBindInfo
var SizeofSparseBufferMemoryBindInfo int = int(unsafe.Sizeof(SparseBufferMemoryBindInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SparseBufferMemoryBindInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SparseBufferMemoryBindInfo) AsCPtr() *SparseBufferMemoryBindInfo {
	clone := (*SparseBufferMemoryBindInfo)(newCBlock(C.ulong(SizeofSparseBufferMemoryBindInfo)))
	*clone = x
	return clone
}

// SparseBufferMemoryBindInfoFreeCSlice releases the memory allocated by SparseBufferMemoryBindInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SparseBufferMemoryBindInfoFreeCSlice(x []SparseBufferMemoryBindInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SparseBufferMemoryBindInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SparseBufferMemoryBindInfoFreeCSlice must be called on the returned slice.
func SparseBufferMemoryBindInfoMakeCSlice(x ...SparseBufferMemoryBindInfo) []SparseBufferMemoryBindInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseBufferMemoryBindInfo * len(x)
	dst := unsafe.Slice((*SparseBufferMemoryBindInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Buffer returns the value of buffer from VkSparseBufferMemoryBindInfo
func (x SparseBufferMemoryBindInfo) Buffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.buffer) 
	return *ptr
}

// WithBuffer sets the value for the Buffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseBufferMemoryBindInfo) WithBuffer(y Buffer) SparseBufferMemoryBindInfo {
	x.buffer = *(/* handle */ (*C.VkBuffer)(&y))
	return x
}

// BindCount returns the value of bindCount from VkSparseBufferMemoryBindInfo
func (x SparseBufferMemoryBindInfo) BindCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.bindCount) 
	return *ptr
}

// WithBindCount sets the value for the BindCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseBufferMemoryBindInfo) WithBindCount(y uint32) SparseBufferMemoryBindInfo {
	x.bindCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PBinds returns the value of pBinds from VkSparseBufferMemoryBindInfo
func (x SparseBufferMemoryBindInfo) PBinds() []SparseMemoryBind {
	ptr := func(x **C.struct_VkSparseMemoryBind) *[]SparseMemoryBind { /* Slice */ slc := unsafe.Slice((*SparseMemoryBind)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pBinds) 
	return *ptr
}

// WithPBinds sets the value for the PBinds on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines BindCount as the length of this field.
// BindCount is updated with the length of the new value.
func (x SparseBufferMemoryBindInfo) WithPBinds(y []SparseMemoryBind) SparseBufferMemoryBindInfo {
	x.pBinds = *(func(x *[]SparseMemoryBind) **C.struct_VkSparseMemoryBind { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkSparseMemoryBind)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkSparseMemoryBind)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithBindCount(uint32(len(y)))
}

// BufferViewCreateInfo provides a go interface for VkBufferViewCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferViewCreateInfo.html
type BufferViewCreateInfo C.struct_VkBufferViewCreateInfo

// SizeofBufferViewCreateInfo is the memory size of a BufferViewCreateInfo
var SizeofBufferViewCreateInfo int = int(unsafe.Sizeof(BufferViewCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferViewCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferViewCreateInfo) AsCPtr() *BufferViewCreateInfo {
	clone := (*BufferViewCreateInfo)(newCBlock(C.ulong(SizeofBufferViewCreateInfo)))
	*clone = x
	return clone
}

// BufferViewCreateInfoFreeCSlice releases the memory allocated by BufferViewCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BufferViewCreateInfoFreeCSlice(x []BufferViewCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferViewCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferViewCreateInfoFreeCSlice must be called on the returned slice.
func BufferViewCreateInfoMakeCSlice(x ...BufferViewCreateInfo) []BufferViewCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferViewCreateInfo * len(x)
	dst := unsafe.Slice((*BufferViewCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBufferViewCreateInfo
func (x BufferViewCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BufferViewCreateInfo) WithDefaultSType() BufferViewCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferViewCreateInfo) WithSType(y StructureType) BufferViewCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkBufferViewCreateInfo
func (x BufferViewCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferViewCreateInfo) WithPNext(y unsafe.Pointer) BufferViewCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkBufferViewCreateInfo
func (x BufferViewCreateInfo) Flags() BufferViewCreateFlags {
	ptr := /* typedef */ (*BufferViewCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferViewCreateInfo) WithFlags(y BufferViewCreateFlags) BufferViewCreateInfo {
	x.flags = *(/* typedef */ (*C.VkBufferViewCreateFlags)(&y))
	return x
}

// Buffer returns the value of buffer from VkBufferViewCreateInfo
func (x BufferViewCreateInfo) Buffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.buffer) 
	return *ptr
}

// WithBuffer sets the value for the Buffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferViewCreateInfo) WithBuffer(y Buffer) BufferViewCreateInfo {
	x.buffer = *(/* handle */ (*C.VkBuffer)(&y))
	return x
}

// Format returns the value of format from VkBufferViewCreateInfo
func (x BufferViewCreateInfo) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format) 
	return *ptr
}

// WithFormat sets the value for the Format on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferViewCreateInfo) WithFormat(y Format) BufferViewCreateInfo {
	x.format = *(/* typedef */ (*C.VkFormat)(&y))
	return x
}

// Offset returns the value of offset from VkBufferViewCreateInfo
func (x BufferViewCreateInfo) Offset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.offset) 
	return *ptr
}

// WithOffset sets the value for the Offset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferViewCreateInfo) WithOffset(y DeviceSize) BufferViewCreateInfo {
	x.offset = *(/* typedef */ (*C.VkDeviceSize)(&y))
	return x
}

// Range_ returns the value of range from VkBufferViewCreateInfo
func (x BufferViewCreateInfo) Range_() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x._range) 
	return *ptr
}

// WithRange_ sets the value for the Range_ on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferViewCreateInfo) WithRange_(y DeviceSize) BufferViewCreateInfo {
	x._range = *(/* typedef */ (*C.VkDeviceSize)(&y))
	return x
}

// Rect2D provides a go interface for VkRect2D.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRect2D.html
type Rect2D C.struct_VkRect2D

// SizeofRect2D is the memory size of a Rect2D
var SizeofRect2D int = int(unsafe.Sizeof(Rect2D{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *Rect2D) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x Rect2D) AsCPtr() *Rect2D {
	clone := (*Rect2D)(newCBlock(C.ulong(SizeofRect2D)))
	*clone = x
	return clone
}

// Rect2DFreeCSlice releases the memory allocated by Rect2DMakeCSlice.
// It does not free pointers stored inside the slice.
func Rect2DFreeCSlice(x []Rect2D) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// Rect2DMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. Rect2DFreeCSlice must be called on the returned slice.
func Rect2DMakeCSlice(x ...Rect2D) []Rect2D {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRect2D * len(x)
	dst := unsafe.Slice((*Rect2D)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Offset returns the value of offset from VkRect2D
func (x Rect2D) Offset() Offset2D {
	ptr := /* typedef */ (*Offset2D)(&x.offset) 
	return *ptr
}

// WithOffset sets the value for the Offset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Rect2D) WithOffset(y Offset2D) Rect2D {
	x.offset = *(/* typedef */ (*C.struct_VkOffset2D)(&y))
	return x
}

// Extent returns the value of extent from VkRect2D
func (x Rect2D) Extent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.extent) 
	return *ptr
}

// WithExtent sets the value for the Extent on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Rect2D) WithExtent(y Extent2D) Rect2D {
	x.extent = *(/* typedef */ (*C.struct_VkExtent2D)(&y))
	return x
}

// SamplerCreateInfo provides a go interface for VkSamplerCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerCreateInfo.html
type SamplerCreateInfo C.struct_VkSamplerCreateInfo

// SizeofSamplerCreateInfo is the memory size of a SamplerCreateInfo
var SizeofSamplerCreateInfo int = int(unsafe.Sizeof(SamplerCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SamplerCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SamplerCreateInfo) AsCPtr() *SamplerCreateInfo {
	clone := (*SamplerCreateInfo)(newCBlock(C.ulong(SizeofSamplerCreateInfo)))
	*clone = x
	return clone
}

// SamplerCreateInfoFreeCSlice releases the memory allocated by SamplerCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SamplerCreateInfoFreeCSlice(x []SamplerCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SamplerCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SamplerCreateInfoFreeCSlice must be called on the returned slice.
func SamplerCreateInfoMakeCSlice(x ...SamplerCreateInfo) []SamplerCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSamplerCreateInfo * len(x)
	dst := unsafe.Slice((*SamplerCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSamplerCreateInfo
func (x SamplerCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SamplerCreateInfo) WithDefaultSType() SamplerCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithSType(y StructureType) SamplerCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkSamplerCreateInfo
func (x SamplerCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithPNext(y unsafe.Pointer) SamplerCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkSamplerCreateInfo
func (x SamplerCreateInfo) Flags() SamplerCreateFlags {
	ptr := /* typedef */ (*SamplerCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithFlags(y SamplerCreateFlags) SamplerCreateInfo {
	x.flags = *(/* typedef */ (*C.VkSamplerCreateFlags)(&y))
	return x
}

// MagFilter returns the value of magFilter from VkSamplerCreateInfo
func (x SamplerCreateInfo) MagFilter() Filter {
	ptr := /* typedef */ (*Filter)(&x.magFilter) 
	return *ptr
}

// WithMagFilter sets the value for the MagFilter on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithMagFilter(y Filter) SamplerCreateInfo {
	x.magFilter = *(/* typedef */ (*C.VkFilter)(&y))
	return x
}

// MinFilter returns the value of minFilter from VkSamplerCreateInfo
func (x SamplerCreateInfo) MinFilter() Filter {
	ptr := /* typedef */ (*Filter)(&x.minFilter) 
	return *ptr
}

// WithMinFilter sets the value for the MinFilter on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithMinFilter(y Filter) SamplerCreateInfo {
	x.minFilter = *(/* typedef */ (*C.VkFilter)(&y))
	return x
}

// MipmapMode returns the value of mipmapMode from VkSamplerCreateInfo
func (x SamplerCreateInfo) MipmapMode() SamplerMipmapMode {
	ptr := /* typedef */ (*SamplerMipmapMode)(&x.mipmapMode) 
	return *ptr
}

// WithMipmapMode sets the value for the MipmapMode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithMipmapMode(y SamplerMipmapMode) SamplerCreateInfo {
	x.mipmapMode = *(/* typedef */ (*C.VkSamplerMipmapMode)(&y))
	return x
}

// AddressModeU returns the value of addressModeU from VkSamplerCreateInfo
func (x SamplerCreateInfo) AddressModeU() SamplerAddressMode {
	ptr := /* typedef */ (*SamplerAddressMode)(&x.addressModeU) 
	return *ptr
}

// WithAddressModeU sets the value for the AddressModeU on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithAddressModeU(y SamplerAddressMode) SamplerCreateInfo {
	x.addressModeU = *(/* typedef */ (*C.VkSamplerAddressMode)(&y))
	return x
}

// AddressModeV returns the value of addressModeV from VkSamplerCreateInfo
func (x SamplerCreateInfo) AddressModeV() SamplerAddressMode {
	ptr := /* typedef */ (*SamplerAddressMode)(&x.addressModeV) 
	return *ptr
}

// WithAddressModeV sets the value for the AddressModeV on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithAddressModeV(y SamplerAddressMode) SamplerCreateInfo {
	x.addressModeV = *(/* typedef */ (*C.VkSamplerAddressMode)(&y))
	return x
}

// AddressModeW returns the value of addressModeW from VkSamplerCreateInfo
func (x SamplerCreateInfo) AddressModeW() SamplerAddressMode {
	ptr := /* typedef */ (*SamplerAddressMode)(&x.addressModeW) 
	return *ptr
}

// WithAddressModeW sets the value for the AddressModeW on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithAddressModeW(y SamplerAddressMode) SamplerCreateInfo {
	x.addressModeW = *(/* typedef */ (*C.VkSamplerAddressMode)(&y))
	return x
}

// MipLodBias returns the value of mipLodBias from VkSamplerCreateInfo
func (x SamplerCreateInfo) MipLodBias() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.mipLodBias) 
	return *ptr
}

// WithMipLodBias sets the value for the MipLodBias on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithMipLodBias(y float32) SamplerCreateInfo {
	x.mipLodBias = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}

// AnisotropyEnable returns the value of anisotropyEnable from VkSamplerCreateInfo
func (x SamplerCreateInfo) AnisotropyEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.anisotropyEnable) 
	return *ptr
}

// WithAnisotropyEnable sets the value for the AnisotropyEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithAnisotropyEnable(y Bool32) SamplerCreateInfo {
	x.anisotropyEnable = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// MaxAnisotropy returns the value of maxAnisotropy from VkSamplerCreateInfo
func (x SamplerCreateInfo) MaxAnisotropy() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.maxAnisotropy) 
	return *ptr
}

// WithMaxAnisotropy sets the value for the MaxAnisotropy on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithMaxAnisotropy(y float32) SamplerCreateInfo {
	x.maxAnisotropy = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}

// CompareEnable returns the value of compareEnable from VkSamplerCreateInfo
func (x SamplerCreateInfo) CompareEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.compareEnable) 
	return *ptr
}

// WithCompareEnable sets the value for the CompareEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithCompareEnable(y Bool32) SamplerCreateInfo {
	x.compareEnable = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// CompareOp returns the value of compareOp from VkSamplerCreateInfo
func (x SamplerCreateInfo) CompareOp() CompareOp {
	ptr := /* typedef */ (*CompareOp)(&x.compareOp) 
	return *ptr
}

// WithCompareOp sets the value for the CompareOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithCompareOp(y CompareOp) SamplerCreateInfo {
	x.compareOp = *(/* typedef */ (*C.VkCompareOp)(&y))
	return x
}

// MinLod returns the value of minLod from VkSamplerCreateInfo
func (x SamplerCreateInfo) MinLod() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.minLod) 
	return *ptr
}

// WithMinLod sets the value for the MinLod on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithMinLod(y float32) SamplerCreateInfo {
	x.minLod = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}

// MaxLod returns the value of maxLod from VkSamplerCreateInfo
func (x SamplerCreateInfo) MaxLod() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.maxLod) 
	return *ptr
}

// WithMaxLod sets the value for the MaxLod on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithMaxLod(y float32) SamplerCreateInfo {
	x.maxLod = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}

// BorderColor returns the value of borderColor from VkSamplerCreateInfo
func (x SamplerCreateInfo) BorderColor() BorderColor {
	ptr := /* typedef */ (*BorderColor)(&x.borderColor) 
	return *ptr
}

// WithBorderColor sets the value for the BorderColor on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithBorderColor(y BorderColor) SamplerCreateInfo {
	x.borderColor = *(/* typedef */ (*C.VkBorderColor)(&y))
	return x
}

// UnnormalizedCoordinates returns the value of unnormalizedCoordinates from VkSamplerCreateInfo
func (x SamplerCreateInfo) UnnormalizedCoordinates() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.unnormalizedCoordinates) 
	return *ptr
}

// WithUnnormalizedCoordinates sets the value for the UnnormalizedCoordinates on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerCreateInfo) WithUnnormalizedCoordinates(y Bool32) SamplerCreateInfo {
	x.unnormalizedCoordinates = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// EventCreateInfo provides a go interface for VkEventCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkEventCreateInfo.html
type EventCreateInfo C.struct_VkEventCreateInfo

// SizeofEventCreateInfo is the memory size of a EventCreateInfo
var SizeofEventCreateInfo int = int(unsafe.Sizeof(EventCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *EventCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x EventCreateInfo) AsCPtr() *EventCreateInfo {
	clone := (*EventCreateInfo)(newCBlock(C.ulong(SizeofEventCreateInfo)))
	*clone = x
	return clone
}

// EventCreateInfoFreeCSlice releases the memory allocated by EventCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func EventCreateInfoFreeCSlice(x []EventCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// EventCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. EventCreateInfoFreeCSlice must be called on the returned slice.
func EventCreateInfoMakeCSlice(x ...EventCreateInfo) []EventCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofEventCreateInfo * len(x)
	dst := unsafe.Slice((*EventCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkEventCreateInfo
func (x EventCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x EventCreateInfo) WithDefaultSType() EventCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_EVENT_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x EventCreateInfo) WithSType(y StructureType) EventCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkEventCreateInfo
func (x EventCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x EventCreateInfo) WithPNext(y unsafe.Pointer) EventCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkEventCreateInfo
func (x EventCreateInfo) Flags() EventCreateFlags {
	ptr := /* typedef */ (*EventCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x EventCreateInfo) WithFlags(y EventCreateFlags) EventCreateInfo {
	x.flags = *(/* typedef */ (*C.VkEventCreateFlags)(&y))
	return x
}

// ImageSubresource provides a go interface for VkImageSubresource.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSubresource.html
type ImageSubresource C.struct_VkImageSubresource

// SizeofImageSubresource is the memory size of a ImageSubresource
var SizeofImageSubresource int = int(unsafe.Sizeof(ImageSubresource{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageSubresource) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageSubresource) AsCPtr() *ImageSubresource {
	clone := (*ImageSubresource)(newCBlock(C.ulong(SizeofImageSubresource)))
	*clone = x
	return clone
}

// ImageSubresourceFreeCSlice releases the memory allocated by ImageSubresourceMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageSubresourceFreeCSlice(x []ImageSubresource) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageSubresourceMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageSubresourceFreeCSlice must be called on the returned slice.
func ImageSubresourceMakeCSlice(x ...ImageSubresource) []ImageSubresource {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageSubresource * len(x)
	dst := unsafe.Slice((*ImageSubresource)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// AspectMask returns the value of aspectMask from VkImageSubresource
func (x ImageSubresource) AspectMask() ImageAspectFlags {
	ptr := /* typedef */ (*ImageAspectFlags)(&x.aspectMask) 
	return *ptr
}

// WithAspectMask sets the value for the AspectMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresource) WithAspectMask(y ImageAspectFlags) ImageSubresource {
	x.aspectMask = *(/* typedef */ (*C.VkImageAspectFlags)(&y))
	return x
}

// MipLevel returns the value of mipLevel from VkImageSubresource
func (x ImageSubresource) MipLevel() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.mipLevel) 
	return *ptr
}

// WithMipLevel sets the value for the MipLevel on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresource) WithMipLevel(y uint32) ImageSubresource {
	x.mipLevel = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// ArrayLayer returns the value of arrayLayer from VkImageSubresource
func (x ImageSubresource) ArrayLayer() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.arrayLayer) 
	return *ptr
}

// WithArrayLayer sets the value for the ArrayLayer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresource) WithArrayLayer(y uint32) ImageSubresource {
	x.arrayLayer = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// ImageCreateInfo provides a go interface for VkImageCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCreateInfo.html
type ImageCreateInfo C.struct_VkImageCreateInfo

// SizeofImageCreateInfo is the memory size of a ImageCreateInfo
var SizeofImageCreateInfo int = int(unsafe.Sizeof(ImageCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageCreateInfo) AsCPtr() *ImageCreateInfo {
	clone := (*ImageCreateInfo)(newCBlock(C.ulong(SizeofImageCreateInfo)))
	*clone = x
	return clone
}

// ImageCreateInfoFreeCSlice releases the memory allocated by ImageCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageCreateInfoFreeCSlice(x []ImageCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageCreateInfoFreeCSlice must be called on the returned slice.
func ImageCreateInfoMakeCSlice(x ...ImageCreateInfo) []ImageCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageCreateInfo * len(x)
	dst := unsafe.Slice((*ImageCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageCreateInfo
func (x ImageCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ImageCreateInfo) WithDefaultSType() ImageCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithSType(y StructureType) ImageCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkImageCreateInfo
func (x ImageCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithPNext(y unsafe.Pointer) ImageCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkImageCreateInfo
func (x ImageCreateInfo) Flags() ImageCreateFlags {
	ptr := /* typedef */ (*ImageCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithFlags(y ImageCreateFlags) ImageCreateInfo {
	x.flags = *(/* typedef */ (*C.VkImageCreateFlags)(&y))
	return x
}

// ImageType returns the value of imageType from VkImageCreateInfo
func (x ImageCreateInfo) ImageType() ImageType {
	ptr := /* typedef */ (*ImageType)(&x.imageType) 
	return *ptr
}

// WithImageType sets the value for the ImageType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithImageType(y ImageType) ImageCreateInfo {
	x.imageType = *(/* typedef */ (*C.VkImageType)(&y))
	return x
}

// Format returns the value of format from VkImageCreateInfo
func (x ImageCreateInfo) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format) 
	return *ptr
}

// WithFormat sets the value for the Format on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithFormat(y Format) ImageCreateInfo {
	x.format = *(/* typedef */ (*C.VkFormat)(&y))
	return x
}

// Extent returns the value of extent from VkImageCreateInfo
func (x ImageCreateInfo) Extent() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.extent) 
	return *ptr
}

// WithExtent sets the value for the Extent on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithExtent(y Extent3D) ImageCreateInfo {
	x.extent = *(/* typedef */ (*C.struct_VkExtent3D)(&y))
	return x
}

// MipLevels returns the value of mipLevels from VkImageCreateInfo
func (x ImageCreateInfo) MipLevels() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.mipLevels) 
	return *ptr
}

// WithMipLevels sets the value for the MipLevels on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithMipLevels(y uint32) ImageCreateInfo {
	x.mipLevels = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// ArrayLayers returns the value of arrayLayers from VkImageCreateInfo
func (x ImageCreateInfo) ArrayLayers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.arrayLayers) 
	return *ptr
}

// WithArrayLayers sets the value for the ArrayLayers on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithArrayLayers(y uint32) ImageCreateInfo {
	x.arrayLayers = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// Samples returns the value of samples from VkImageCreateInfo
func (x ImageCreateInfo) Samples() SampleCountFlagBits {
	ptr := /* typedef */ (*SampleCountFlagBits)(&x.samples) 
	return *ptr
}

// WithSamples sets the value for the Samples on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithSamples(y SampleCountFlagBits) ImageCreateInfo {
	x.samples = *(/* typedef */ (*C.VkSampleCountFlagBits)(&y))
	return x
}

// Tiling returns the value of tiling from VkImageCreateInfo
func (x ImageCreateInfo) Tiling() ImageTiling {
	ptr := /* typedef */ (*ImageTiling)(&x.tiling) 
	return *ptr
}

// WithTiling sets the value for the Tiling on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithTiling(y ImageTiling) ImageCreateInfo {
	x.tiling = *(/* typedef */ (*C.VkImageTiling)(&y))
	return x
}

// Usage returns the value of usage from VkImageCreateInfo
func (x ImageCreateInfo) Usage() ImageUsageFlags {
	ptr := /* typedef */ (*ImageUsageFlags)(&x.usage) 
	return *ptr
}

// WithUsage sets the value for the Usage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithUsage(y ImageUsageFlags) ImageCreateInfo {
	x.usage = *(/* typedef */ (*C.VkImageUsageFlags)(&y))
	return x
}

// SharingMode returns the value of sharingMode from VkImageCreateInfo
func (x ImageCreateInfo) SharingMode() SharingMode {
	ptr := /* typedef */ (*SharingMode)(&x.sharingMode) 
	return *ptr
}

// WithSharingMode sets the value for the SharingMode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithSharingMode(y SharingMode) ImageCreateInfo {
	x.sharingMode = *(/* typedef */ (*C.VkSharingMode)(&y))
	return x
}

// QueueFamilyIndexCount returns the value of queueFamilyIndexCount from VkImageCreateInfo
func (x ImageCreateInfo) QueueFamilyIndexCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.queueFamilyIndexCount) 
	return *ptr
}

// WithQueueFamilyIndexCount sets the value for the QueueFamilyIndexCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithQueueFamilyIndexCount(y uint32) ImageCreateInfo {
	x.queueFamilyIndexCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PQueueFamilyIndices returns the value of pQueueFamilyIndices from VkImageCreateInfo
func (x ImageCreateInfo) PQueueFamilyIndices() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */ slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pQueueFamilyIndices) 
	return *ptr
}

// WithPQueueFamilyIndices sets the value for the PQueueFamilyIndices on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines QueueFamilyIndexCount as the length of this field.
// QueueFamilyIndexCount is updated with the length of the new value.
func (x ImageCreateInfo) WithPQueueFamilyIndices(y []uint32) ImageCreateInfo {
	x.pQueueFamilyIndices = *(func(x *[]uint32) **C.uint32_t { /* Slice */ if len(*x) > 0 { slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.uint32_t)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithQueueFamilyIndexCount(uint32(len(y)))
}

// InitialLayout returns the value of initialLayout from VkImageCreateInfo
func (x ImageCreateInfo) InitialLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.initialLayout) 
	return *ptr
}

// WithInitialLayout sets the value for the InitialLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCreateInfo) WithInitialLayout(y ImageLayout) ImageCreateInfo {
	x.initialLayout = *(/* typedef */ (*C.VkImageLayout)(&y))
	return x
}

// BindSparseInfo provides a go interface for VkBindSparseInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindSparseInfo.html
type BindSparseInfo C.struct_VkBindSparseInfo

// SizeofBindSparseInfo is the memory size of a BindSparseInfo
var SizeofBindSparseInfo int = int(unsafe.Sizeof(BindSparseInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BindSparseInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BindSparseInfo) AsCPtr() *BindSparseInfo {
	clone := (*BindSparseInfo)(newCBlock(C.ulong(SizeofBindSparseInfo)))
	*clone = x
	return clone
}

// BindSparseInfoFreeCSlice releases the memory allocated by BindSparseInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BindSparseInfoFreeCSlice(x []BindSparseInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BindSparseInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BindSparseInfoFreeCSlice must be called on the returned slice.
func BindSparseInfoMakeCSlice(x ...BindSparseInfo) []BindSparseInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindSparseInfo * len(x)
	dst := unsafe.Slice((*BindSparseInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBindSparseInfo
func (x BindSparseInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BindSparseInfo) WithDefaultSType() BindSparseInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BIND_SPARSE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindSparseInfo) WithSType(y StructureType) BindSparseInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkBindSparseInfo
func (x BindSparseInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindSparseInfo) WithPNext(y unsafe.Pointer) BindSparseInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// WaitSemaphoreCount returns the value of waitSemaphoreCount from VkBindSparseInfo
func (x BindSparseInfo) WaitSemaphoreCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.waitSemaphoreCount) 
	return *ptr
}

// WithWaitSemaphoreCount sets the value for the WaitSemaphoreCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindSparseInfo) WithWaitSemaphoreCount(y uint32) BindSparseInfo {
	x.waitSemaphoreCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PWaitSemaphores returns the value of pWaitSemaphores from VkBindSparseInfo
func (x BindSparseInfo) PWaitSemaphores() []Semaphore {
	ptr := func(x **C.VkSemaphore) *[]Semaphore { /* Slice */ slc := unsafe.Slice((*Semaphore)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pWaitSemaphores) 
	return *ptr
}

// WithPWaitSemaphores sets the value for the PWaitSemaphores on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines WaitSemaphoreCount as the length of this field.
// WaitSemaphoreCount is updated with the length of the new value.
func (x BindSparseInfo) WithPWaitSemaphores(y []Semaphore) BindSparseInfo {
	x.pWaitSemaphores = *(func(x *[]Semaphore) **C.VkSemaphore { /* Slice */ if len(*x) > 0 { slc := (*C.VkSemaphore)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkSemaphore)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithWaitSemaphoreCount(uint32(len(y)))
}

// BufferBindCount returns the value of bufferBindCount from VkBindSparseInfo
func (x BindSparseInfo) BufferBindCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.bufferBindCount) 
	return *ptr
}

// WithBufferBindCount sets the value for the BufferBindCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindSparseInfo) WithBufferBindCount(y uint32) BindSparseInfo {
	x.bufferBindCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PBufferBinds returns the value of pBufferBinds from VkBindSparseInfo
func (x BindSparseInfo) PBufferBinds() []SparseBufferMemoryBindInfo {
	ptr := func(x **C.struct_VkSparseBufferMemoryBindInfo) *[]SparseBufferMemoryBindInfo { /* Slice */ slc := unsafe.Slice((*SparseBufferMemoryBindInfo)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pBufferBinds) 
	return *ptr
}

// WithPBufferBinds sets the value for the PBufferBinds on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines BufferBindCount as the length of this field.
// BufferBindCount is updated with the length of the new value.
func (x BindSparseInfo) WithPBufferBinds(y []SparseBufferMemoryBindInfo) BindSparseInfo {
	x.pBufferBinds = *(func(x *[]SparseBufferMemoryBindInfo) **C.struct_VkSparseBufferMemoryBindInfo { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkSparseBufferMemoryBindInfo)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkSparseBufferMemoryBindInfo)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithBufferBindCount(uint32(len(y)))
}

// ImageOpaqueBindCount returns the value of imageOpaqueBindCount from VkBindSparseInfo
func (x BindSparseInfo) ImageOpaqueBindCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.imageOpaqueBindCount) 
	return *ptr
}

// WithImageOpaqueBindCount sets the value for the ImageOpaqueBindCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindSparseInfo) WithImageOpaqueBindCount(y uint32) BindSparseInfo {
	x.imageOpaqueBindCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PImageOpaqueBinds returns the value of pImageOpaqueBinds from VkBindSparseInfo
func (x BindSparseInfo) PImageOpaqueBinds() []SparseImageOpaqueMemoryBindInfo {
	ptr := func(x **C.struct_VkSparseImageOpaqueMemoryBindInfo) *[]SparseImageOpaqueMemoryBindInfo { /* Slice */ slc := unsafe.Slice((*SparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pImageOpaqueBinds) 
	return *ptr
}

// WithPImageOpaqueBinds sets the value for the PImageOpaqueBinds on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines ImageOpaqueBindCount as the length of this field.
// ImageOpaqueBindCount is updated with the length of the new value.
func (x BindSparseInfo) WithPImageOpaqueBinds(y []SparseImageOpaqueMemoryBindInfo) BindSparseInfo {
	x.pImageOpaqueBinds = *(func(x *[]SparseImageOpaqueMemoryBindInfo) **C.struct_VkSparseImageOpaqueMemoryBindInfo { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithImageOpaqueBindCount(uint32(len(y)))
}

// ImageBindCount returns the value of imageBindCount from VkBindSparseInfo
func (x BindSparseInfo) ImageBindCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.imageBindCount) 
	return *ptr
}

// WithImageBindCount sets the value for the ImageBindCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindSparseInfo) WithImageBindCount(y uint32) BindSparseInfo {
	x.imageBindCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PImageBinds returns the value of pImageBinds from VkBindSparseInfo
func (x BindSparseInfo) PImageBinds() []SparseImageMemoryBindInfo {
	ptr := func(x **C.struct_VkSparseImageMemoryBindInfo) *[]SparseImageMemoryBindInfo { /* Slice */ slc := unsafe.Slice((*SparseImageMemoryBindInfo)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pImageBinds) 
	return *ptr
}

// WithPImageBinds sets the value for the PImageBinds on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines ImageBindCount as the length of this field.
// ImageBindCount is updated with the length of the new value.
func (x BindSparseInfo) WithPImageBinds(y []SparseImageMemoryBindInfo) BindSparseInfo {
	x.pImageBinds = *(func(x *[]SparseImageMemoryBindInfo) **C.struct_VkSparseImageMemoryBindInfo { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkSparseImageMemoryBindInfo)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkSparseImageMemoryBindInfo)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithImageBindCount(uint32(len(y)))
}

// SignalSemaphoreCount returns the value of signalSemaphoreCount from VkBindSparseInfo
func (x BindSparseInfo) SignalSemaphoreCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.signalSemaphoreCount) 
	return *ptr
}

// WithSignalSemaphoreCount sets the value for the SignalSemaphoreCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindSparseInfo) WithSignalSemaphoreCount(y uint32) BindSparseInfo {
	x.signalSemaphoreCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PSignalSemaphores returns the value of pSignalSemaphores from VkBindSparseInfo
func (x BindSparseInfo) PSignalSemaphores() []Semaphore {
	ptr := func(x **C.VkSemaphore) *[]Semaphore { /* Slice */ slc := unsafe.Slice((*Semaphore)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pSignalSemaphores) 
	return *ptr
}

// WithPSignalSemaphores sets the value for the PSignalSemaphores on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines SignalSemaphoreCount as the length of this field.
// SignalSemaphoreCount is updated with the length of the new value.
func (x BindSparseInfo) WithPSignalSemaphores(y []Semaphore) BindSparseInfo {
	x.pSignalSemaphores = *(func(x *[]Semaphore) **C.VkSemaphore { /* Slice */ if len(*x) > 0 { slc := (*C.VkSemaphore)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkSemaphore)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithSignalSemaphoreCount(uint32(len(y)))
}

// SubresourceLayout provides a go interface for VkSubresourceLayout.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubresourceLayout.html
type SubresourceLayout C.struct_VkSubresourceLayout

// SizeofSubresourceLayout is the memory size of a SubresourceLayout
var SizeofSubresourceLayout int = int(unsafe.Sizeof(SubresourceLayout{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubresourceLayout) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubresourceLayout) AsCPtr() *SubresourceLayout {
	clone := (*SubresourceLayout)(newCBlock(C.ulong(SizeofSubresourceLayout)))
	*clone = x
	return clone
}

// SubresourceLayoutFreeCSlice releases the memory allocated by SubresourceLayoutMakeCSlice.
// It does not free pointers stored inside the slice.
func SubresourceLayoutFreeCSlice(x []SubresourceLayout) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubresourceLayoutMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubresourceLayoutFreeCSlice must be called on the returned slice.
func SubresourceLayoutMakeCSlice(x ...SubresourceLayout) []SubresourceLayout {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubresourceLayout * len(x)
	dst := unsafe.Slice((*SubresourceLayout)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Offset returns the value of offset from VkSubresourceLayout
func (x SubresourceLayout) Offset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.offset) 
	return *ptr
}

// Size returns the value of size from VkSubresourceLayout
func (x SubresourceLayout) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size) 
	return *ptr
}

// RowPitch returns the value of rowPitch from VkSubresourceLayout
func (x SubresourceLayout) RowPitch() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.rowPitch) 
	return *ptr
}

// ArrayPitch returns the value of arrayPitch from VkSubresourceLayout
func (x SubresourceLayout) ArrayPitch() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.arrayPitch) 
	return *ptr
}

// DepthPitch returns the value of depthPitch from VkSubresourceLayout
func (x SubresourceLayout) DepthPitch() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.depthPitch) 
	return *ptr
}

// AllocationCallbacks provides a go interface for VkAllocationCallbacks.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAllocationCallbacks.html
type AllocationCallbacks C.struct_VkAllocationCallbacks

// SizeofAllocationCallbacks is the memory size of a AllocationCallbacks
var SizeofAllocationCallbacks int = int(unsafe.Sizeof(AllocationCallbacks{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *AllocationCallbacks) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x AllocationCallbacks) AsCPtr() *AllocationCallbacks {
	clone := (*AllocationCallbacks)(newCBlock(C.ulong(SizeofAllocationCallbacks)))
	*clone = x
	return clone
}

// AllocationCallbacksFreeCSlice releases the memory allocated by AllocationCallbacksMakeCSlice.
// It does not free pointers stored inside the slice.
func AllocationCallbacksFreeCSlice(x []AllocationCallbacks) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// AllocationCallbacksMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. AllocationCallbacksFreeCSlice must be called on the returned slice.
func AllocationCallbacksMakeCSlice(x ...AllocationCallbacks) []AllocationCallbacks {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAllocationCallbacks * len(x)
	dst := unsafe.Slice((*AllocationCallbacks)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// PUserData returns the value of pUserData from VkAllocationCallbacks
func (x AllocationCallbacks) PUserData() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pUserData) 
	return *ptr
}

// WithPUserData sets the value for the PUserData on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AllocationCallbacks) WithPUserData(y unsafe.Pointer) AllocationCallbacks {
	x.pUserData = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// PfnAllocation returns the value of pfnAllocation from VkAllocationCallbacks
func (x AllocationCallbacks) PfnAllocation() PFN_vkAllocationFunction {
	ptr := /* typedef */ (*PFN_vkAllocationFunction)(&x.pfnAllocation) 
	return *ptr
}

// WithPfnAllocation sets the value for the PfnAllocation on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AllocationCallbacks) WithPfnAllocation(y PFN_vkAllocationFunction) AllocationCallbacks {
	x.pfnAllocation = *(/* typedef */ (*C.PFN_vkAllocationFunction)(&y))
	return x
}

// PfnReallocation returns the value of pfnReallocation from VkAllocationCallbacks
func (x AllocationCallbacks) PfnReallocation() PFN_vkReallocationFunction {
	ptr := /* typedef */ (*PFN_vkReallocationFunction)(&x.pfnReallocation) 
	return *ptr
}

// WithPfnReallocation sets the value for the PfnReallocation on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AllocationCallbacks) WithPfnReallocation(y PFN_vkReallocationFunction) AllocationCallbacks {
	x.pfnReallocation = *(/* typedef */ (*C.PFN_vkReallocationFunction)(&y))
	return x
}

// PfnFree returns the value of pfnFree from VkAllocationCallbacks
func (x AllocationCallbacks) PfnFree() PFN_vkFreeFunction {
	ptr := /* typedef */ (*PFN_vkFreeFunction)(&x.pfnFree) 
	return *ptr
}

// WithPfnFree sets the value for the PfnFree on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AllocationCallbacks) WithPfnFree(y PFN_vkFreeFunction) AllocationCallbacks {
	x.pfnFree = *(/* typedef */ (*C.PFN_vkFreeFunction)(&y))
	return x
}

// PfnInternalAllocation returns the value of pfnInternalAllocation from VkAllocationCallbacks
func (x AllocationCallbacks) PfnInternalAllocation() PFN_vkInternalAllocationNotification {
	ptr := /* typedef */ (*PFN_vkInternalAllocationNotification)(&x.pfnInternalAllocation) 
	return *ptr
}

// WithPfnInternalAllocation sets the value for the PfnInternalAllocation on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AllocationCallbacks) WithPfnInternalAllocation(y PFN_vkInternalAllocationNotification) AllocationCallbacks {
	x.pfnInternalAllocation = *(/* typedef */ (*C.PFN_vkInternalAllocationNotification)(&y))
	return x
}

// PfnInternalFree returns the value of pfnInternalFree from VkAllocationCallbacks
func (x AllocationCallbacks) PfnInternalFree() PFN_vkInternalFreeNotification {
	ptr := /* typedef */ (*PFN_vkInternalFreeNotification)(&x.pfnInternalFree) 
	return *ptr
}

// WithPfnInternalFree sets the value for the PfnInternalFree on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AllocationCallbacks) WithPfnInternalFree(y PFN_vkInternalFreeNotification) AllocationCallbacks {
	x.pfnInternalFree = *(/* typedef */ (*C.PFN_vkInternalFreeNotification)(&y))
	return x
}

// ApplicationInfo provides a go interface for VkApplicationInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkApplicationInfo.html
type ApplicationInfo C.struct_VkApplicationInfo

// SizeofApplicationInfo is the memory size of a ApplicationInfo
var SizeofApplicationInfo int = int(unsafe.Sizeof(ApplicationInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ApplicationInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ApplicationInfo) AsCPtr() *ApplicationInfo {
	clone := (*ApplicationInfo)(newCBlock(C.ulong(SizeofApplicationInfo)))
	*clone = x
	return clone
}

// ApplicationInfoFreeCSlice releases the memory allocated by ApplicationInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ApplicationInfoFreeCSlice(x []ApplicationInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ApplicationInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ApplicationInfoFreeCSlice must be called on the returned slice.
func ApplicationInfoMakeCSlice(x ...ApplicationInfo) []ApplicationInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofApplicationInfo * len(x)
	dst := unsafe.Slice((*ApplicationInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkApplicationInfo
func (x ApplicationInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ApplicationInfo) WithDefaultSType() ApplicationInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_APPLICATION_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ApplicationInfo) WithSType(y StructureType) ApplicationInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkApplicationInfo
func (x ApplicationInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ApplicationInfo) WithPNext(y unsafe.Pointer) ApplicationInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// PApplicationName returns the value of pApplicationName from VkApplicationInfo
func (x ApplicationInfo) PApplicationName() *byte {
	ptr := func(x **C.char) **byte { /* Pointer */ return (**byte)(unsafe.Pointer(x)) }(&x.pApplicationName) 
	return *ptr
}

// WithPApplicationName sets the value for the PApplicationName on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ApplicationInfo) WithPApplicationName(y *byte) ApplicationInfo {
	x.pApplicationName = *(func(x **byte) **C.char { /* Pointer */ return (**C.char)(unsafe.Pointer(x)) }(&y))
	return x
}

// ApplicationVersion returns the value of applicationVersion from VkApplicationInfo
func (x ApplicationInfo) ApplicationVersion() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.applicationVersion) 
	return *ptr
}

// WithApplicationVersion sets the value for the ApplicationVersion on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ApplicationInfo) WithApplicationVersion(y uint32) ApplicationInfo {
	x.applicationVersion = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PEngineName returns the value of pEngineName from VkApplicationInfo
func (x ApplicationInfo) PEngineName() *byte {
	ptr := func(x **C.char) **byte { /* Pointer */ return (**byte)(unsafe.Pointer(x)) }(&x.pEngineName) 
	return *ptr
}

// WithPEngineName sets the value for the PEngineName on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ApplicationInfo) WithPEngineName(y *byte) ApplicationInfo {
	x.pEngineName = *(func(x **byte) **C.char { /* Pointer */ return (**C.char)(unsafe.Pointer(x)) }(&y))
	return x
}

// EngineVersion returns the value of engineVersion from VkApplicationInfo
func (x ApplicationInfo) EngineVersion() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.engineVersion) 
	return *ptr
}

// WithEngineVersion sets the value for the EngineVersion on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ApplicationInfo) WithEngineVersion(y uint32) ApplicationInfo {
	x.engineVersion = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// ApiVersion returns the value of apiVersion from VkApplicationInfo
func (x ApplicationInfo) ApiVersion() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.apiVersion) 
	return *ptr
}

// WithApiVersion sets the value for the ApiVersion on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ApplicationInfo) WithApiVersion(y uint32) ApplicationInfo {
	x.apiVersion = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// ComponentMapping provides a go interface for VkComponentMapping.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkComponentMapping.html
type ComponentMapping C.struct_VkComponentMapping

// SizeofComponentMapping is the memory size of a ComponentMapping
var SizeofComponentMapping int = int(unsafe.Sizeof(ComponentMapping{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ComponentMapping) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ComponentMapping) AsCPtr() *ComponentMapping {
	clone := (*ComponentMapping)(newCBlock(C.ulong(SizeofComponentMapping)))
	*clone = x
	return clone
}

// ComponentMappingFreeCSlice releases the memory allocated by ComponentMappingMakeCSlice.
// It does not free pointers stored inside the slice.
func ComponentMappingFreeCSlice(x []ComponentMapping) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ComponentMappingMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ComponentMappingFreeCSlice must be called on the returned slice.
func ComponentMappingMakeCSlice(x ...ComponentMapping) []ComponentMapping {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofComponentMapping * len(x)
	dst := unsafe.Slice((*ComponentMapping)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// R returns the value of r from VkComponentMapping
func (x ComponentMapping) R() ComponentSwizzle {
	ptr := /* typedef */ (*ComponentSwizzle)(&x.r) 
	return *ptr
}

// WithR sets the value for the R on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComponentMapping) WithR(y ComponentSwizzle) ComponentMapping {
	x.r = *(/* typedef */ (*C.VkComponentSwizzle)(&y))
	return x
}

// G returns the value of g from VkComponentMapping
func (x ComponentMapping) G() ComponentSwizzle {
	ptr := /* typedef */ (*ComponentSwizzle)(&x.g) 
	return *ptr
}

// WithG sets the value for the G on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComponentMapping) WithG(y ComponentSwizzle) ComponentMapping {
	x.g = *(/* typedef */ (*C.VkComponentSwizzle)(&y))
	return x
}

// B returns the value of b from VkComponentMapping
func (x ComponentMapping) B() ComponentSwizzle {
	ptr := /* typedef */ (*ComponentSwizzle)(&x.b) 
	return *ptr
}

// WithB sets the value for the B on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComponentMapping) WithB(y ComponentSwizzle) ComponentMapping {
	x.b = *(/* typedef */ (*C.VkComponentSwizzle)(&y))
	return x
}

// A returns the value of a from VkComponentMapping
func (x ComponentMapping) A() ComponentSwizzle {
	ptr := /* typedef */ (*ComponentSwizzle)(&x.a) 
	return *ptr
}

// WithA sets the value for the A on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComponentMapping) WithA(y ComponentSwizzle) ComponentMapping {
	x.a = *(/* typedef */ (*C.VkComponentSwizzle)(&y))
	return x
}

// FormatProperties provides a go interface for VkFormatProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatProperties.html
type FormatProperties C.struct_VkFormatProperties

// SizeofFormatProperties is the memory size of a FormatProperties
var SizeofFormatProperties int = int(unsafe.Sizeof(FormatProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *FormatProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x FormatProperties) AsCPtr() *FormatProperties {
	clone := (*FormatProperties)(newCBlock(C.ulong(SizeofFormatProperties)))
	*clone = x
	return clone
}

// FormatPropertiesFreeCSlice releases the memory allocated by FormatPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func FormatPropertiesFreeCSlice(x []FormatProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// FormatPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. FormatPropertiesFreeCSlice must be called on the returned slice.
func FormatPropertiesMakeCSlice(x ...FormatProperties) []FormatProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFormatProperties * len(x)
	dst := unsafe.Slice((*FormatProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// LinearTilingFeatures returns the value of linearTilingFeatures from VkFormatProperties
func (x FormatProperties) LinearTilingFeatures() FormatFeatureFlags {
	ptr := /* typedef */ (*FormatFeatureFlags)(&x.linearTilingFeatures) 
	return *ptr
}

// OptimalTilingFeatures returns the value of optimalTilingFeatures from VkFormatProperties
func (x FormatProperties) OptimalTilingFeatures() FormatFeatureFlags {
	ptr := /* typedef */ (*FormatFeatureFlags)(&x.optimalTilingFeatures) 
	return *ptr
}

// BufferFeatures returns the value of bufferFeatures from VkFormatProperties
func (x FormatProperties) BufferFeatures() FormatFeatureFlags {
	ptr := /* typedef */ (*FormatFeatureFlags)(&x.bufferFeatures) 
	return *ptr
}

// ImageSubresourceRange provides a go interface for VkImageSubresourceRange.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSubresourceRange.html
type ImageSubresourceRange C.struct_VkImageSubresourceRange

// SizeofImageSubresourceRange is the memory size of a ImageSubresourceRange
var SizeofImageSubresourceRange int = int(unsafe.Sizeof(ImageSubresourceRange{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageSubresourceRange) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageSubresourceRange) AsCPtr() *ImageSubresourceRange {
	clone := (*ImageSubresourceRange)(newCBlock(C.ulong(SizeofImageSubresourceRange)))
	*clone = x
	return clone
}

// ImageSubresourceRangeFreeCSlice releases the memory allocated by ImageSubresourceRangeMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageSubresourceRangeFreeCSlice(x []ImageSubresourceRange) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageSubresourceRangeMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageSubresourceRangeFreeCSlice must be called on the returned slice.
func ImageSubresourceRangeMakeCSlice(x ...ImageSubresourceRange) []ImageSubresourceRange {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageSubresourceRange * len(x)
	dst := unsafe.Slice((*ImageSubresourceRange)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// AspectMask returns the value of aspectMask from VkImageSubresourceRange
func (x ImageSubresourceRange) AspectMask() ImageAspectFlags {
	ptr := /* typedef */ (*ImageAspectFlags)(&x.aspectMask) 
	return *ptr
}

// WithAspectMask sets the value for the AspectMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresourceRange) WithAspectMask(y ImageAspectFlags) ImageSubresourceRange {
	x.aspectMask = *(/* typedef */ (*C.VkImageAspectFlags)(&y))
	return x
}

// BaseMipLevel returns the value of baseMipLevel from VkImageSubresourceRange
func (x ImageSubresourceRange) BaseMipLevel() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.baseMipLevel) 
	return *ptr
}

// WithBaseMipLevel sets the value for the BaseMipLevel on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresourceRange) WithBaseMipLevel(y uint32) ImageSubresourceRange {
	x.baseMipLevel = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// LevelCount returns the value of levelCount from VkImageSubresourceRange
func (x ImageSubresourceRange) LevelCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.levelCount) 
	return *ptr
}

// WithLevelCount sets the value for the LevelCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresourceRange) WithLevelCount(y uint32) ImageSubresourceRange {
	x.levelCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// BaseArrayLayer returns the value of baseArrayLayer from VkImageSubresourceRange
func (x ImageSubresourceRange) BaseArrayLayer() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.baseArrayLayer) 
	return *ptr
}

// WithBaseArrayLayer sets the value for the BaseArrayLayer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresourceRange) WithBaseArrayLayer(y uint32) ImageSubresourceRange {
	x.baseArrayLayer = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// LayerCount returns the value of layerCount from VkImageSubresourceRange
func (x ImageSubresourceRange) LayerCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.layerCount) 
	return *ptr
}

// WithLayerCount sets the value for the LayerCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSubresourceRange) WithLayerCount(y uint32) ImageSubresourceRange {
	x.layerCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// CommandBufferInheritanceInfo provides a go interface for VkCommandBufferInheritanceInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferInheritanceInfo.html
type CommandBufferInheritanceInfo C.struct_VkCommandBufferInheritanceInfo

// SizeofCommandBufferInheritanceInfo is the memory size of a CommandBufferInheritanceInfo
var SizeofCommandBufferInheritanceInfo int = int(unsafe.Sizeof(CommandBufferInheritanceInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *CommandBufferInheritanceInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x CommandBufferInheritanceInfo) AsCPtr() *CommandBufferInheritanceInfo {
	clone := (*CommandBufferInheritanceInfo)(newCBlock(C.ulong(SizeofCommandBufferInheritanceInfo)))
	*clone = x
	return clone
}

// CommandBufferInheritanceInfoFreeCSlice releases the memory allocated by CommandBufferInheritanceInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func CommandBufferInheritanceInfoFreeCSlice(x []CommandBufferInheritanceInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// CommandBufferInheritanceInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. CommandBufferInheritanceInfoFreeCSlice must be called on the returned slice.
func CommandBufferInheritanceInfoMakeCSlice(x ...CommandBufferInheritanceInfo) []CommandBufferInheritanceInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCommandBufferInheritanceInfo * len(x)
	dst := unsafe.Slice((*CommandBufferInheritanceInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkCommandBufferInheritanceInfo
func (x CommandBufferInheritanceInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x CommandBufferInheritanceInfo) WithDefaultSType() CommandBufferInheritanceInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceInfo) WithSType(y StructureType) CommandBufferInheritanceInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkCommandBufferInheritanceInfo
func (x CommandBufferInheritanceInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceInfo) WithPNext(y unsafe.Pointer) CommandBufferInheritanceInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// RenderPass returns the value of renderPass from VkCommandBufferInheritanceInfo
func (x CommandBufferInheritanceInfo) RenderPass() RenderPass {
	ptr := /* handle */ (*RenderPass)(&x.renderPass) 
	return *ptr
}

// WithRenderPass sets the value for the RenderPass on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceInfo) WithRenderPass(y RenderPass) CommandBufferInheritanceInfo {
	x.renderPass = *(/* handle */ (*C.VkRenderPass)(&y))
	return x
}

// Subpass returns the value of subpass from VkCommandBufferInheritanceInfo
func (x CommandBufferInheritanceInfo) Subpass() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.subpass) 
	return *ptr
}

// WithSubpass sets the value for the Subpass on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceInfo) WithSubpass(y uint32) CommandBufferInheritanceInfo {
	x.subpass = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// Framebuffer returns the value of framebuffer from VkCommandBufferInheritanceInfo
func (x CommandBufferInheritanceInfo) Framebuffer() Framebuffer {
	ptr := /* handle */ (*Framebuffer)(&x.framebuffer) 
	return *ptr
}

// WithFramebuffer sets the value for the Framebuffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceInfo) WithFramebuffer(y Framebuffer) CommandBufferInheritanceInfo {
	x.framebuffer = *(/* handle */ (*C.VkFramebuffer)(&y))
	return x
}

// OcclusionQueryEnable returns the value of occlusionQueryEnable from VkCommandBufferInheritanceInfo
func (x CommandBufferInheritanceInfo) OcclusionQueryEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.occlusionQueryEnable) 
	return *ptr
}

// WithOcclusionQueryEnable sets the value for the OcclusionQueryEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceInfo) WithOcclusionQueryEnable(y Bool32) CommandBufferInheritanceInfo {
	x.occlusionQueryEnable = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// QueryFlags returns the value of queryFlags from VkCommandBufferInheritanceInfo
func (x CommandBufferInheritanceInfo) QueryFlags() QueryControlFlags {
	ptr := /* typedef */ (*QueryControlFlags)(&x.queryFlags) 
	return *ptr
}

// WithQueryFlags sets the value for the QueryFlags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceInfo) WithQueryFlags(y QueryControlFlags) CommandBufferInheritanceInfo {
	x.queryFlags = *(/* typedef */ (*C.VkQueryControlFlags)(&y))
	return x
}

// PipelineStatistics returns the value of pipelineStatistics from VkCommandBufferInheritanceInfo
func (x CommandBufferInheritanceInfo) PipelineStatistics() QueryPipelineStatisticFlags {
	ptr := /* typedef */ (*QueryPipelineStatisticFlags)(&x.pipelineStatistics) 
	return *ptr
}

// WithPipelineStatistics sets the value for the PipelineStatistics on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceInfo) WithPipelineStatistics(y QueryPipelineStatisticFlags) CommandBufferInheritanceInfo {
	x.pipelineStatistics = *(/* typedef */ (*C.VkQueryPipelineStatisticFlags)(&y))
	return x
}

// CommandBufferBeginInfo provides a go interface for VkCommandBufferBeginInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferBeginInfo.html
type CommandBufferBeginInfo C.struct_VkCommandBufferBeginInfo

// SizeofCommandBufferBeginInfo is the memory size of a CommandBufferBeginInfo
var SizeofCommandBufferBeginInfo int = int(unsafe.Sizeof(CommandBufferBeginInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *CommandBufferBeginInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x CommandBufferBeginInfo) AsCPtr() *CommandBufferBeginInfo {
	clone := (*CommandBufferBeginInfo)(newCBlock(C.ulong(SizeofCommandBufferBeginInfo)))
	*clone = x
	return clone
}

// CommandBufferBeginInfoFreeCSlice releases the memory allocated by CommandBufferBeginInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func CommandBufferBeginInfoFreeCSlice(x []CommandBufferBeginInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// CommandBufferBeginInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. CommandBufferBeginInfoFreeCSlice must be called on the returned slice.
func CommandBufferBeginInfoMakeCSlice(x ...CommandBufferBeginInfo) []CommandBufferBeginInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCommandBufferBeginInfo * len(x)
	dst := unsafe.Slice((*CommandBufferBeginInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkCommandBufferBeginInfo
func (x CommandBufferBeginInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x CommandBufferBeginInfo) WithDefaultSType() CommandBufferBeginInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferBeginInfo) WithSType(y StructureType) CommandBufferBeginInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkCommandBufferBeginInfo
func (x CommandBufferBeginInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferBeginInfo) WithPNext(y unsafe.Pointer) CommandBufferBeginInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkCommandBufferBeginInfo
func (x CommandBufferBeginInfo) Flags() CommandBufferUsageFlags {
	ptr := /* typedef */ (*CommandBufferUsageFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferBeginInfo) WithFlags(y CommandBufferUsageFlags) CommandBufferBeginInfo {
	x.flags = *(/* typedef */ (*C.VkCommandBufferUsageFlags)(&y))
	return x
}

// PInheritanceInfo returns the value of pInheritanceInfo from VkCommandBufferBeginInfo
func (x CommandBufferBeginInfo) PInheritanceInfo() *CommandBufferInheritanceInfo {
	ptr := func(x **C.struct_VkCommandBufferInheritanceInfo) **CommandBufferInheritanceInfo { /* Pointer */ c2g := (*CommandBufferInheritanceInfo)(*x); return &c2g }(&x.pInheritanceInfo) 
	return *ptr
}

// WithPInheritanceInfo sets the value for the PInheritanceInfo on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferBeginInfo) WithPInheritanceInfo(y *CommandBufferInheritanceInfo) CommandBufferBeginInfo {
	x.pInheritanceInfo = *(func(x **CommandBufferInheritanceInfo) **C.struct_VkCommandBufferInheritanceInfo { /* Pointer */ g2c := (*C.struct_VkCommandBufferInheritanceInfo)(*x); return &g2c }(&y))
	return x
}

// MemoryRequirements provides a go interface for VkMemoryRequirements.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryRequirements.html
type MemoryRequirements C.struct_VkMemoryRequirements

// SizeofMemoryRequirements is the memory size of a MemoryRequirements
var SizeofMemoryRequirements int = int(unsafe.Sizeof(MemoryRequirements{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryRequirements) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryRequirements) AsCPtr() *MemoryRequirements {
	clone := (*MemoryRequirements)(newCBlock(C.ulong(SizeofMemoryRequirements)))
	*clone = x
	return clone
}

// MemoryRequirementsFreeCSlice releases the memory allocated by MemoryRequirementsMakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryRequirementsFreeCSlice(x []MemoryRequirements) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryRequirementsMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryRequirementsFreeCSlice must be called on the returned slice.
func MemoryRequirementsMakeCSlice(x ...MemoryRequirements) []MemoryRequirements {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryRequirements * len(x)
	dst := unsafe.Slice((*MemoryRequirements)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Size returns the value of size from VkMemoryRequirements
func (x MemoryRequirements) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size) 
	return *ptr
}

// Alignment returns the value of alignment from VkMemoryRequirements
func (x MemoryRequirements) Alignment() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.alignment) 
	return *ptr
}

// MemoryTypeBits returns the value of memoryTypeBits from VkMemoryRequirements
func (x MemoryRequirements) MemoryTypeBits() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.memoryTypeBits) 
	return *ptr
}

// ImageViewCreateInfo provides a go interface for VkImageViewCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateInfo.html
type ImageViewCreateInfo C.struct_VkImageViewCreateInfo

// SizeofImageViewCreateInfo is the memory size of a ImageViewCreateInfo
var SizeofImageViewCreateInfo int = int(unsafe.Sizeof(ImageViewCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageViewCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageViewCreateInfo) AsCPtr() *ImageViewCreateInfo {
	clone := (*ImageViewCreateInfo)(newCBlock(C.ulong(SizeofImageViewCreateInfo)))
	*clone = x
	return clone
}

// ImageViewCreateInfoFreeCSlice releases the memory allocated by ImageViewCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageViewCreateInfoFreeCSlice(x []ImageViewCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageViewCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageViewCreateInfoFreeCSlice must be called on the returned slice.
func ImageViewCreateInfoMakeCSlice(x ...ImageViewCreateInfo) []ImageViewCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageViewCreateInfo * len(x)
	dst := unsafe.Slice((*ImageViewCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageViewCreateInfo
func (x ImageViewCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ImageViewCreateInfo) WithDefaultSType() ImageViewCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewCreateInfo) WithSType(y StructureType) ImageViewCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkImageViewCreateInfo
func (x ImageViewCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewCreateInfo) WithPNext(y unsafe.Pointer) ImageViewCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkImageViewCreateInfo
func (x ImageViewCreateInfo) Flags() ImageViewCreateFlags {
	ptr := /* typedef */ (*ImageViewCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewCreateInfo) WithFlags(y ImageViewCreateFlags) ImageViewCreateInfo {
	x.flags = *(/* typedef */ (*C.VkImageViewCreateFlags)(&y))
	return x
}

// Image returns the value of image from VkImageViewCreateInfo
func (x ImageViewCreateInfo) Image() Image {
	ptr := /* handle */ (*Image)(&x.image) 
	return *ptr
}

// WithImage sets the value for the Image on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewCreateInfo) WithImage(y Image) ImageViewCreateInfo {
	x.image = *(/* handle */ (*C.VkImage)(&y))
	return x
}

// ViewType returns the value of viewType from VkImageViewCreateInfo
func (x ImageViewCreateInfo) ViewType() ImageViewType {
	ptr := /* typedef */ (*ImageViewType)(&x.viewType) 
	return *ptr
}

// WithViewType sets the value for the ViewType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewCreateInfo) WithViewType(y ImageViewType) ImageViewCreateInfo {
	x.viewType = *(/* typedef */ (*C.VkImageViewType)(&y))
	return x
}

// Format returns the value of format from VkImageViewCreateInfo
func (x ImageViewCreateInfo) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format) 
	return *ptr
}

// WithFormat sets the value for the Format on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewCreateInfo) WithFormat(y Format) ImageViewCreateInfo {
	x.format = *(/* typedef */ (*C.VkFormat)(&y))
	return x
}

// Components returns the value of components from VkImageViewCreateInfo
func (x ImageViewCreateInfo) Components() ComponentMapping {
	ptr := /* typedef */ (*ComponentMapping)(&x.components) 
	return *ptr
}

// WithComponents sets the value for the Components on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewCreateInfo) WithComponents(y ComponentMapping) ImageViewCreateInfo {
	x.components = *(/* typedef */ (*C.struct_VkComponentMapping)(&y))
	return x
}

// SubresourceRange returns the value of subresourceRange from VkImageViewCreateInfo
func (x ImageViewCreateInfo) SubresourceRange() ImageSubresourceRange {
	ptr := /* typedef */ (*ImageSubresourceRange)(&x.subresourceRange) 
	return *ptr
}

// WithSubresourceRange sets the value for the SubresourceRange on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewCreateInfo) WithSubresourceRange(y ImageSubresourceRange) ImageViewCreateInfo {
	x.subresourceRange = *(/* typedef */ (*C.struct_VkImageSubresourceRange)(&y))
	return x
}

// CommandBufferAllocateInfo provides a go interface for VkCommandBufferAllocateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferAllocateInfo.html
type CommandBufferAllocateInfo C.struct_VkCommandBufferAllocateInfo

// SizeofCommandBufferAllocateInfo is the memory size of a CommandBufferAllocateInfo
var SizeofCommandBufferAllocateInfo int = int(unsafe.Sizeof(CommandBufferAllocateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *CommandBufferAllocateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x CommandBufferAllocateInfo) AsCPtr() *CommandBufferAllocateInfo {
	clone := (*CommandBufferAllocateInfo)(newCBlock(C.ulong(SizeofCommandBufferAllocateInfo)))
	*clone = x
	return clone
}

// CommandBufferAllocateInfoFreeCSlice releases the memory allocated by CommandBufferAllocateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func CommandBufferAllocateInfoFreeCSlice(x []CommandBufferAllocateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// CommandBufferAllocateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. CommandBufferAllocateInfoFreeCSlice must be called on the returned slice.
func CommandBufferAllocateInfoMakeCSlice(x ...CommandBufferAllocateInfo) []CommandBufferAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCommandBufferAllocateInfo * len(x)
	dst := unsafe.Slice((*CommandBufferAllocateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkCommandBufferAllocateInfo
func (x CommandBufferAllocateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x CommandBufferAllocateInfo) WithDefaultSType() CommandBufferAllocateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferAllocateInfo) WithSType(y StructureType) CommandBufferAllocateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkCommandBufferAllocateInfo
func (x CommandBufferAllocateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferAllocateInfo) WithPNext(y unsafe.Pointer) CommandBufferAllocateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// CommandPool returns the value of commandPool from VkCommandBufferAllocateInfo
func (x CommandBufferAllocateInfo) CommandPool() CommandPool {
	ptr := /* handle */ (*CommandPool)(&x.commandPool) 
	return *ptr
}

// WithCommandPool sets the value for the CommandPool on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferAllocateInfo) WithCommandPool(y CommandPool) CommandBufferAllocateInfo {
	x.commandPool = *(/* handle */ (*C.VkCommandPool)(&y))
	return x
}

// Level returns the value of level from VkCommandBufferAllocateInfo
func (x CommandBufferAllocateInfo) Level() CommandBufferLevel {
	ptr := /* typedef */ (*CommandBufferLevel)(&x.level) 
	return *ptr
}

// WithLevel sets the value for the Level on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferAllocateInfo) WithLevel(y CommandBufferLevel) CommandBufferAllocateInfo {
	x.level = *(/* typedef */ (*C.VkCommandBufferLevel)(&y))
	return x
}

// CommandBufferCount returns the value of commandBufferCount from VkCommandBufferAllocateInfo
func (x CommandBufferAllocateInfo) CommandBufferCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.commandBufferCount) 
	return *ptr
}

// WithCommandBufferCount sets the value for the CommandBufferCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferAllocateInfo) WithCommandBufferCount(y uint32) CommandBufferAllocateInfo {
	x.commandBufferCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// ImageFormatProperties provides a go interface for VkImageFormatProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageFormatProperties.html
type ImageFormatProperties C.struct_VkImageFormatProperties

// SizeofImageFormatProperties is the memory size of a ImageFormatProperties
var SizeofImageFormatProperties int = int(unsafe.Sizeof(ImageFormatProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageFormatProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageFormatProperties) AsCPtr() *ImageFormatProperties {
	clone := (*ImageFormatProperties)(newCBlock(C.ulong(SizeofImageFormatProperties)))
	*clone = x
	return clone
}

// ImageFormatPropertiesFreeCSlice releases the memory allocated by ImageFormatPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageFormatPropertiesFreeCSlice(x []ImageFormatProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageFormatPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageFormatPropertiesFreeCSlice must be called on the returned slice.
func ImageFormatPropertiesMakeCSlice(x ...ImageFormatProperties) []ImageFormatProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageFormatProperties * len(x)
	dst := unsafe.Slice((*ImageFormatProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// MaxExtent returns the value of maxExtent from VkImageFormatProperties
func (x ImageFormatProperties) MaxExtent() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.maxExtent) 
	return *ptr
}

// MaxMipLevels returns the value of maxMipLevels from VkImageFormatProperties
func (x ImageFormatProperties) MaxMipLevels() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxMipLevels) 
	return *ptr
}

// MaxArrayLayers returns the value of maxArrayLayers from VkImageFormatProperties
func (x ImageFormatProperties) MaxArrayLayers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxArrayLayers) 
	return *ptr
}

// SampleCounts returns the value of sampleCounts from VkImageFormatProperties
func (x ImageFormatProperties) SampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.sampleCounts) 
	return *ptr
}

// MaxResourceSize returns the value of maxResourceSize from VkImageFormatProperties
func (x ImageFormatProperties) MaxResourceSize() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.maxResourceSize) 
	return *ptr
}

// BaseInStructure provides a go interface for VkBaseInStructure.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBaseInStructure.html
type BaseInStructure C.struct_VkBaseInStructure

// SizeofBaseInStructure is the memory size of a BaseInStructure
var SizeofBaseInStructure int = int(unsafe.Sizeof(BaseInStructure{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BaseInStructure) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BaseInStructure) AsCPtr() *BaseInStructure {
	clone := (*BaseInStructure)(newCBlock(C.ulong(SizeofBaseInStructure)))
	*clone = x
	return clone
}

// BaseInStructureFreeCSlice releases the memory allocated by BaseInStructureMakeCSlice.
// It does not free pointers stored inside the slice.
func BaseInStructureFreeCSlice(x []BaseInStructure) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BaseInStructureMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BaseInStructureFreeCSlice must be called on the returned slice.
func BaseInStructureMakeCSlice(x ...BaseInStructure) []BaseInStructure {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBaseInStructure * len(x)
	dst := unsafe.Slice((*BaseInStructure)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBaseInStructure
func (x BaseInStructure) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BaseInStructure) WithSType(y StructureType) BaseInStructure {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkBaseInStructure
func (x BaseInStructure) PNext() *BaseInStructure {
	ptr := func(x **C.struct_VkBaseInStructure) **BaseInStructure { /* Pointer */ c2g := (*BaseInStructure)(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BaseInStructure) WithPNext(y *BaseInStructure) BaseInStructure {
	x.pNext = *(func(x **BaseInStructure) **C.struct_VkBaseInStructure { /* Pointer */ g2c := (*C.struct_VkBaseInStructure)(*x); return &g2c }(&y))
	return x
}

// InstanceCreateInfo provides a go interface for VkInstanceCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInstanceCreateInfo.html
type InstanceCreateInfo C.struct_VkInstanceCreateInfo

// SizeofInstanceCreateInfo is the memory size of a InstanceCreateInfo
var SizeofInstanceCreateInfo int = int(unsafe.Sizeof(InstanceCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *InstanceCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x InstanceCreateInfo) AsCPtr() *InstanceCreateInfo {
	clone := (*InstanceCreateInfo)(newCBlock(C.ulong(SizeofInstanceCreateInfo)))
	*clone = x
	return clone
}

// InstanceCreateInfoFreeCSlice releases the memory allocated by InstanceCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func InstanceCreateInfoFreeCSlice(x []InstanceCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// InstanceCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. InstanceCreateInfoFreeCSlice must be called on the returned slice.
func InstanceCreateInfoMakeCSlice(x ...InstanceCreateInfo) []InstanceCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofInstanceCreateInfo * len(x)
	dst := unsafe.Slice((*InstanceCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkInstanceCreateInfo
func (x InstanceCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x InstanceCreateInfo) WithDefaultSType() InstanceCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InstanceCreateInfo) WithSType(y StructureType) InstanceCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkInstanceCreateInfo
func (x InstanceCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InstanceCreateInfo) WithPNext(y unsafe.Pointer) InstanceCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkInstanceCreateInfo
func (x InstanceCreateInfo) Flags() InstanceCreateFlags {
	ptr := /* typedef */ (*InstanceCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InstanceCreateInfo) WithFlags(y InstanceCreateFlags) InstanceCreateInfo {
	x.flags = *(/* typedef */ (*C.VkInstanceCreateFlags)(&y))
	return x
}

// PApplicationInfo returns the value of pApplicationInfo from VkInstanceCreateInfo
func (x InstanceCreateInfo) PApplicationInfo() *ApplicationInfo {
	ptr := func(x **C.struct_VkApplicationInfo) **ApplicationInfo { /* Pointer */ c2g := (*ApplicationInfo)(*x); return &c2g }(&x.pApplicationInfo) 
	return *ptr
}

// WithPApplicationInfo sets the value for the PApplicationInfo on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InstanceCreateInfo) WithPApplicationInfo(y *ApplicationInfo) InstanceCreateInfo {
	x.pApplicationInfo = *(func(x **ApplicationInfo) **C.struct_VkApplicationInfo { /* Pointer */ g2c := (*C.struct_VkApplicationInfo)(*x); return &g2c }(&y))
	return x
}

// EnabledLayerCount returns the value of enabledLayerCount from VkInstanceCreateInfo
func (x InstanceCreateInfo) EnabledLayerCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.enabledLayerCount) 
	return *ptr
}

// WithEnabledLayerCount sets the value for the EnabledLayerCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InstanceCreateInfo) WithEnabledLayerCount(y uint32) InstanceCreateInfo {
	x.enabledLayerCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PpEnabledLayerNames returns the value of ppEnabledLayerNames from VkInstanceCreateInfo
func (x InstanceCreateInfo) PpEnabledLayerNames() []*byte {
	ptr := func(x ***C.char) *[]*byte { /* Slice */ slc := unsafe.Slice((**byte)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.ppEnabledLayerNames) 
	return *ptr
}

// WithPpEnabledLayerNames sets the value for the PpEnabledLayerNames on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InstanceCreateInfo) WithPpEnabledLayerNames(y []*byte) InstanceCreateInfo {
	x.ppEnabledLayerNames = *(func(x *[]*byte) ***C.char { /* Slice */ if len(*x) > 0 { slc := (**C.char)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (***C.char)(unsafe.Pointer((&ptr))) }(&y))
	return x
}

// EnabledExtensionCount returns the value of enabledExtensionCount from VkInstanceCreateInfo
func (x InstanceCreateInfo) EnabledExtensionCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.enabledExtensionCount) 
	return *ptr
}

// WithEnabledExtensionCount sets the value for the EnabledExtensionCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InstanceCreateInfo) WithEnabledExtensionCount(y uint32) InstanceCreateInfo {
	x.enabledExtensionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PpEnabledExtensionNames returns the value of ppEnabledExtensionNames from VkInstanceCreateInfo
func (x InstanceCreateInfo) PpEnabledExtensionNames() []*byte {
	ptr := func(x ***C.char) *[]*byte { /* Slice */ slc := unsafe.Slice((**byte)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.ppEnabledExtensionNames) 
	return *ptr
}

// WithPpEnabledExtensionNames sets the value for the PpEnabledExtensionNames on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InstanceCreateInfo) WithPpEnabledExtensionNames(y []*byte) InstanceCreateInfo {
	x.ppEnabledExtensionNames = *(func(x *[]*byte) ***C.char { /* Slice */ if len(*x) > 0 { slc := (**C.char)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (***C.char)(unsafe.Pointer((&ptr))) }(&y))
	return x
}

// CommandPoolCreateInfo provides a go interface for VkCommandPoolCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolCreateInfo.html
type CommandPoolCreateInfo C.struct_VkCommandPoolCreateInfo

// SizeofCommandPoolCreateInfo is the memory size of a CommandPoolCreateInfo
var SizeofCommandPoolCreateInfo int = int(unsafe.Sizeof(CommandPoolCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *CommandPoolCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x CommandPoolCreateInfo) AsCPtr() *CommandPoolCreateInfo {
	clone := (*CommandPoolCreateInfo)(newCBlock(C.ulong(SizeofCommandPoolCreateInfo)))
	*clone = x
	return clone
}

// CommandPoolCreateInfoFreeCSlice releases the memory allocated by CommandPoolCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func CommandPoolCreateInfoFreeCSlice(x []CommandPoolCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// CommandPoolCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. CommandPoolCreateInfoFreeCSlice must be called on the returned slice.
func CommandPoolCreateInfoMakeCSlice(x ...CommandPoolCreateInfo) []CommandPoolCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCommandPoolCreateInfo * len(x)
	dst := unsafe.Slice((*CommandPoolCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkCommandPoolCreateInfo
func (x CommandPoolCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x CommandPoolCreateInfo) WithDefaultSType() CommandPoolCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandPoolCreateInfo) WithSType(y StructureType) CommandPoolCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkCommandPoolCreateInfo
func (x CommandPoolCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandPoolCreateInfo) WithPNext(y unsafe.Pointer) CommandPoolCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkCommandPoolCreateInfo
func (x CommandPoolCreateInfo) Flags() CommandPoolCreateFlags {
	ptr := /* typedef */ (*CommandPoolCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandPoolCreateInfo) WithFlags(y CommandPoolCreateFlags) CommandPoolCreateInfo {
	x.flags = *(/* typedef */ (*C.VkCommandPoolCreateFlags)(&y))
	return x
}

// QueueFamilyIndex returns the value of queueFamilyIndex from VkCommandPoolCreateInfo
func (x CommandPoolCreateInfo) QueueFamilyIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.queueFamilyIndex) 
	return *ptr
}

// WithQueueFamilyIndex sets the value for the QueueFamilyIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandPoolCreateInfo) WithQueueFamilyIndex(y uint32) CommandPoolCreateInfo {
	x.queueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// ShaderModuleCreateInfo provides a go interface for VkShaderModuleCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderModuleCreateInfo.html
type ShaderModuleCreateInfo C.struct_VkShaderModuleCreateInfo

// SizeofShaderModuleCreateInfo is the memory size of a ShaderModuleCreateInfo
var SizeofShaderModuleCreateInfo int = int(unsafe.Sizeof(ShaderModuleCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ShaderModuleCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ShaderModuleCreateInfo) AsCPtr() *ShaderModuleCreateInfo {
	clone := (*ShaderModuleCreateInfo)(newCBlock(C.ulong(SizeofShaderModuleCreateInfo)))
	*clone = x
	return clone
}

// ShaderModuleCreateInfoFreeCSlice releases the memory allocated by ShaderModuleCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ShaderModuleCreateInfoFreeCSlice(x []ShaderModuleCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ShaderModuleCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ShaderModuleCreateInfoFreeCSlice must be called on the returned slice.
func ShaderModuleCreateInfoMakeCSlice(x ...ShaderModuleCreateInfo) []ShaderModuleCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofShaderModuleCreateInfo * len(x)
	dst := unsafe.Slice((*ShaderModuleCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkShaderModuleCreateInfo
func (x ShaderModuleCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ShaderModuleCreateInfo) WithDefaultSType() ShaderModuleCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ShaderModuleCreateInfo) WithSType(y StructureType) ShaderModuleCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkShaderModuleCreateInfo
func (x ShaderModuleCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ShaderModuleCreateInfo) WithPNext(y unsafe.Pointer) ShaderModuleCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkShaderModuleCreateInfo
func (x ShaderModuleCreateInfo) Flags() ShaderModuleCreateFlags {
	ptr := /* typedef */ (*ShaderModuleCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ShaderModuleCreateInfo) WithFlags(y ShaderModuleCreateFlags) ShaderModuleCreateInfo {
	x.flags = *(/* typedef */ (*C.VkShaderModuleCreateFlags)(&y))
	return x
}

// CodeSize returns the value of codeSize from VkShaderModuleCreateInfo
func (x ShaderModuleCreateInfo) CodeSize() uint64 {
	ptr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.codeSize) 
	return *ptr
}

// WithCodeSize sets the value for the CodeSize on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ShaderModuleCreateInfo) WithCodeSize(y uint64) ShaderModuleCreateInfo {
	x.codeSize = *(func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&y))
	return x
}

// PCode returns the value of pCode from VkShaderModuleCreateInfo
func (x ShaderModuleCreateInfo) PCode() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */ slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pCode) 
	return *ptr
}

// WithPCode sets the value for the PCode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ShaderModuleCreateInfo) WithPCode(y []uint32) ShaderModuleCreateInfo {
	x.pCode = *(func(x *[]uint32) **C.uint32_t { /* Slice */ if len(*x) > 0 { slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.uint32_t)(unsafe.Pointer((&ptr))) }(&y))
	return x
}

// DescriptorImageInfo provides a go interface for VkDescriptorImageInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorImageInfo.html
type DescriptorImageInfo C.struct_VkDescriptorImageInfo

// SizeofDescriptorImageInfo is the memory size of a DescriptorImageInfo
var SizeofDescriptorImageInfo int = int(unsafe.Sizeof(DescriptorImageInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorImageInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorImageInfo) AsCPtr() *DescriptorImageInfo {
	clone := (*DescriptorImageInfo)(newCBlock(C.ulong(SizeofDescriptorImageInfo)))
	*clone = x
	return clone
}

// DescriptorImageInfoFreeCSlice releases the memory allocated by DescriptorImageInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorImageInfoFreeCSlice(x []DescriptorImageInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorImageInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorImageInfoFreeCSlice must be called on the returned slice.
func DescriptorImageInfoMakeCSlice(x ...DescriptorImageInfo) []DescriptorImageInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorImageInfo * len(x)
	dst := unsafe.Slice((*DescriptorImageInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Sampler returns the value of sampler from VkDescriptorImageInfo
func (x DescriptorImageInfo) Sampler() Sampler {
	ptr := /* handle */ (*Sampler)(&x.sampler) 
	return *ptr
}

// WithSampler sets the value for the Sampler on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorImageInfo) WithSampler(y Sampler) DescriptorImageInfo {
	x.sampler = *(/* handle */ (*C.VkSampler)(&y))
	return x
}

// ImageView returns the value of imageView from VkDescriptorImageInfo
func (x DescriptorImageInfo) ImageView() ImageView {
	ptr := /* handle */ (*ImageView)(&x.imageView) 
	return *ptr
}

// WithImageView sets the value for the ImageView on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorImageInfo) WithImageView(y ImageView) DescriptorImageInfo {
	x.imageView = *(/* handle */ (*C.VkImageView)(&y))
	return x
}

// ImageLayout returns the value of imageLayout from VkDescriptorImageInfo
func (x DescriptorImageInfo) ImageLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.imageLayout) 
	return *ptr
}

// WithImageLayout sets the value for the ImageLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorImageInfo) WithImageLayout(y ImageLayout) DescriptorImageInfo {
	x.imageLayout = *(/* typedef */ (*C.VkImageLayout)(&y))
	return x
}

// Offset2D provides a go interface for VkOffset2D.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkOffset2D.html
type Offset2D C.struct_VkOffset2D

// SizeofOffset2D is the memory size of a Offset2D
var SizeofOffset2D int = int(unsafe.Sizeof(Offset2D{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *Offset2D) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x Offset2D) AsCPtr() *Offset2D {
	clone := (*Offset2D)(newCBlock(C.ulong(SizeofOffset2D)))
	*clone = x
	return clone
}

// Offset2DFreeCSlice releases the memory allocated by Offset2DMakeCSlice.
// It does not free pointers stored inside the slice.
func Offset2DFreeCSlice(x []Offset2D) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// Offset2DMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. Offset2DFreeCSlice must be called on the returned slice.
func Offset2DMakeCSlice(x ...Offset2D) []Offset2D {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofOffset2D * len(x)
	dst := unsafe.Slice((*Offset2D)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// X returns the value of x from VkOffset2D
func (x Offset2D) X() int32 {
	ptr := func(x *C.int32_t) *int32 { /* Scalar */ c2g := int32(*x); return &c2g }(&x.x) 
	return *ptr
}

// WithX sets the value for the X on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Offset2D) WithX(y int32) Offset2D {
	x.x = *(func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&y))
	return x
}

// Y returns the value of y from VkOffset2D
func (x Offset2D) Y() int32 {
	ptr := func(x *C.int32_t) *int32 { /* Scalar */ c2g := int32(*x); return &c2g }(&x.y) 
	return *ptr
}

// WithY sets the value for the Y on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Offset2D) WithY(y int32) Offset2D {
	x.y = *(func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&y))
	return x
}

// PushConstantRange provides a go interface for VkPushConstantRange.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPushConstantRange.html
type PushConstantRange C.struct_VkPushConstantRange

// SizeofPushConstantRange is the memory size of a PushConstantRange
var SizeofPushConstantRange int = int(unsafe.Sizeof(PushConstantRange{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PushConstantRange) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PushConstantRange) AsCPtr() *PushConstantRange {
	clone := (*PushConstantRange)(newCBlock(C.ulong(SizeofPushConstantRange)))
	*clone = x
	return clone
}

// PushConstantRangeFreeCSlice releases the memory allocated by PushConstantRangeMakeCSlice.
// It does not free pointers stored inside the slice.
func PushConstantRangeFreeCSlice(x []PushConstantRange) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PushConstantRangeMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PushConstantRangeFreeCSlice must be called on the returned slice.
func PushConstantRangeMakeCSlice(x ...PushConstantRange) []PushConstantRange {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPushConstantRange * len(x)
	dst := unsafe.Slice((*PushConstantRange)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// StageFlags returns the value of stageFlags from VkPushConstantRange
func (x PushConstantRange) StageFlags() ShaderStageFlags {
	ptr := /* typedef */ (*ShaderStageFlags)(&x.stageFlags) 
	return *ptr
}

// WithStageFlags sets the value for the StageFlags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PushConstantRange) WithStageFlags(y ShaderStageFlags) PushConstantRange {
	x.stageFlags = *(/* typedef */ (*C.VkShaderStageFlags)(&y))
	return x
}

// Offset returns the value of offset from VkPushConstantRange
func (x PushConstantRange) Offset() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.offset) 
	return *ptr
}

// WithOffset sets the value for the Offset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PushConstantRange) WithOffset(y uint32) PushConstantRange {
	x.offset = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// Size returns the value of size from VkPushConstantRange
func (x PushConstantRange) Size() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.size) 
	return *ptr
}

// WithSize sets the value for the Size on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PushConstantRange) WithSize(y uint32) PushConstantRange {
	x.size = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PipelineLayoutCreateInfo provides a go interface for VkPipelineLayoutCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineLayoutCreateInfo.html
type PipelineLayoutCreateInfo C.struct_VkPipelineLayoutCreateInfo

// SizeofPipelineLayoutCreateInfo is the memory size of a PipelineLayoutCreateInfo
var SizeofPipelineLayoutCreateInfo int = int(unsafe.Sizeof(PipelineLayoutCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineLayoutCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineLayoutCreateInfo) AsCPtr() *PipelineLayoutCreateInfo {
	clone := (*PipelineLayoutCreateInfo)(newCBlock(C.ulong(SizeofPipelineLayoutCreateInfo)))
	*clone = x
	return clone
}

// PipelineLayoutCreateInfoFreeCSlice releases the memory allocated by PipelineLayoutCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineLayoutCreateInfoFreeCSlice(x []PipelineLayoutCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineLayoutCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineLayoutCreateInfoFreeCSlice must be called on the returned slice.
func PipelineLayoutCreateInfoMakeCSlice(x ...PipelineLayoutCreateInfo) []PipelineLayoutCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineLayoutCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineLayoutCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineLayoutCreateInfo
func (x PipelineLayoutCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineLayoutCreateInfo) WithDefaultSType() PipelineLayoutCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineLayoutCreateInfo) WithSType(y StructureType) PipelineLayoutCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPipelineLayoutCreateInfo
func (x PipelineLayoutCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineLayoutCreateInfo) WithPNext(y unsafe.Pointer) PipelineLayoutCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkPipelineLayoutCreateInfo
func (x PipelineLayoutCreateInfo) Flags() PipelineLayoutCreateFlags {
	ptr := /* typedef */ (*PipelineLayoutCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineLayoutCreateInfo) WithFlags(y PipelineLayoutCreateFlags) PipelineLayoutCreateInfo {
	x.flags = *(/* typedef */ (*C.VkPipelineLayoutCreateFlags)(&y))
	return x
}

// SetLayoutCount returns the value of setLayoutCount from VkPipelineLayoutCreateInfo
func (x PipelineLayoutCreateInfo) SetLayoutCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.setLayoutCount) 
	return *ptr
}

// WithSetLayoutCount sets the value for the SetLayoutCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineLayoutCreateInfo) WithSetLayoutCount(y uint32) PipelineLayoutCreateInfo {
	x.setLayoutCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PSetLayouts returns the value of pSetLayouts from VkPipelineLayoutCreateInfo
func (x PipelineLayoutCreateInfo) PSetLayouts() []DescriptorSetLayout {
	ptr := func(x **C.VkDescriptorSetLayout) *[]DescriptorSetLayout { /* Slice */ slc := unsafe.Slice((*DescriptorSetLayout)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pSetLayouts) 
	return *ptr
}

// WithPSetLayouts sets the value for the PSetLayouts on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines SetLayoutCount as the length of this field.
// SetLayoutCount is updated with the length of the new value.
func (x PipelineLayoutCreateInfo) WithPSetLayouts(y []DescriptorSetLayout) PipelineLayoutCreateInfo {
	x.pSetLayouts = *(func(x *[]DescriptorSetLayout) **C.VkDescriptorSetLayout { /* Slice */ if len(*x) > 0 { slc := (*C.VkDescriptorSetLayout)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkDescriptorSetLayout)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithSetLayoutCount(uint32(len(y)))
}

// PushConstantRangeCount returns the value of pushConstantRangeCount from VkPipelineLayoutCreateInfo
func (x PipelineLayoutCreateInfo) PushConstantRangeCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.pushConstantRangeCount) 
	return *ptr
}

// WithPushConstantRangeCount sets the value for the PushConstantRangeCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineLayoutCreateInfo) WithPushConstantRangeCount(y uint32) PipelineLayoutCreateInfo {
	x.pushConstantRangeCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PPushConstantRanges returns the value of pPushConstantRanges from VkPipelineLayoutCreateInfo
func (x PipelineLayoutCreateInfo) PPushConstantRanges() []PushConstantRange {
	ptr := func(x **C.struct_VkPushConstantRange) *[]PushConstantRange { /* Slice */ slc := unsafe.Slice((*PushConstantRange)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pPushConstantRanges) 
	return *ptr
}

// WithPPushConstantRanges sets the value for the PPushConstantRanges on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines PushConstantRangeCount as the length of this field.
// PushConstantRangeCount is updated with the length of the new value.
func (x PipelineLayoutCreateInfo) WithPPushConstantRanges(y []PushConstantRange) PipelineLayoutCreateInfo {
	x.pPushConstantRanges = *(func(x *[]PushConstantRange) **C.struct_VkPushConstantRange { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkPushConstantRange)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkPushConstantRange)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithPushConstantRangeCount(uint32(len(y)))
}

// MemoryHeap provides a go interface for VkMemoryHeap.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryHeap.html
type MemoryHeap C.struct_VkMemoryHeap

// SizeofMemoryHeap is the memory size of a MemoryHeap
var SizeofMemoryHeap int = int(unsafe.Sizeof(MemoryHeap{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryHeap) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryHeap) AsCPtr() *MemoryHeap {
	clone := (*MemoryHeap)(newCBlock(C.ulong(SizeofMemoryHeap)))
	*clone = x
	return clone
}

// MemoryHeapFreeCSlice releases the memory allocated by MemoryHeapMakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryHeapFreeCSlice(x []MemoryHeap) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryHeapMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryHeapFreeCSlice must be called on the returned slice.
func MemoryHeapMakeCSlice(x ...MemoryHeap) []MemoryHeap {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryHeap * len(x)
	dst := unsafe.Slice((*MemoryHeap)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Size returns the value of size from VkMemoryHeap
func (x MemoryHeap) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size) 
	return *ptr
}

// Flags returns the value of flags from VkMemoryHeap
func (x MemoryHeap) Flags() MemoryHeapFlags {
	ptr := /* typedef */ (*MemoryHeapFlags)(&x.flags) 
	return *ptr
}

// MemoryAllocateInfo provides a go interface for VkMemoryAllocateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryAllocateInfo.html
type MemoryAllocateInfo C.struct_VkMemoryAllocateInfo

// SizeofMemoryAllocateInfo is the memory size of a MemoryAllocateInfo
var SizeofMemoryAllocateInfo int = int(unsafe.Sizeof(MemoryAllocateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryAllocateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryAllocateInfo) AsCPtr() *MemoryAllocateInfo {
	clone := (*MemoryAllocateInfo)(newCBlock(C.ulong(SizeofMemoryAllocateInfo)))
	*clone = x
	return clone
}

// MemoryAllocateInfoFreeCSlice releases the memory allocated by MemoryAllocateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryAllocateInfoFreeCSlice(x []MemoryAllocateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryAllocateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryAllocateInfoFreeCSlice must be called on the returned slice.
func MemoryAllocateInfoMakeCSlice(x ...MemoryAllocateInfo) []MemoryAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryAllocateInfo * len(x)
	dst := unsafe.Slice((*MemoryAllocateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkMemoryAllocateInfo
func (x MemoryAllocateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x MemoryAllocateInfo) WithDefaultSType() MemoryAllocateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryAllocateInfo) WithSType(y StructureType) MemoryAllocateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkMemoryAllocateInfo
func (x MemoryAllocateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryAllocateInfo) WithPNext(y unsafe.Pointer) MemoryAllocateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// AllocationSize returns the value of allocationSize from VkMemoryAllocateInfo
func (x MemoryAllocateInfo) AllocationSize() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.allocationSize) 
	return *ptr
}

// WithAllocationSize sets the value for the AllocationSize on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryAllocateInfo) WithAllocationSize(y DeviceSize) MemoryAllocateInfo {
	x.allocationSize = *(/* typedef */ (*C.VkDeviceSize)(&y))
	return x
}

// MemoryTypeIndex returns the value of memoryTypeIndex from VkMemoryAllocateInfo
func (x MemoryAllocateInfo) MemoryTypeIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.memoryTypeIndex) 
	return *ptr
}

// WithMemoryTypeIndex sets the value for the MemoryTypeIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryAllocateInfo) WithMemoryTypeIndex(y uint32) MemoryAllocateInfo {
	x.memoryTypeIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PipelineCacheCreateInfo provides a go interface for VkPipelineCacheCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCacheCreateInfo.html
type PipelineCacheCreateInfo C.struct_VkPipelineCacheCreateInfo

// SizeofPipelineCacheCreateInfo is the memory size of a PipelineCacheCreateInfo
var SizeofPipelineCacheCreateInfo int = int(unsafe.Sizeof(PipelineCacheCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineCacheCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineCacheCreateInfo) AsCPtr() *PipelineCacheCreateInfo {
	clone := (*PipelineCacheCreateInfo)(newCBlock(C.ulong(SizeofPipelineCacheCreateInfo)))
	*clone = x
	return clone
}

// PipelineCacheCreateInfoFreeCSlice releases the memory allocated by PipelineCacheCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineCacheCreateInfoFreeCSlice(x []PipelineCacheCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineCacheCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineCacheCreateInfoFreeCSlice must be called on the returned slice.
func PipelineCacheCreateInfoMakeCSlice(x ...PipelineCacheCreateInfo) []PipelineCacheCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineCacheCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineCacheCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineCacheCreateInfo
func (x PipelineCacheCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineCacheCreateInfo) WithDefaultSType() PipelineCacheCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheCreateInfo) WithSType(y StructureType) PipelineCacheCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPipelineCacheCreateInfo
func (x PipelineCacheCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheCreateInfo) WithPNext(y unsafe.Pointer) PipelineCacheCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkPipelineCacheCreateInfo
func (x PipelineCacheCreateInfo) Flags() PipelineCacheCreateFlags {
	ptr := /* typedef */ (*PipelineCacheCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheCreateInfo) WithFlags(y PipelineCacheCreateFlags) PipelineCacheCreateInfo {
	x.flags = *(/* typedef */ (*C.VkPipelineCacheCreateFlags)(&y))
	return x
}

// InitialDataSize returns the value of initialDataSize from VkPipelineCacheCreateInfo
func (x PipelineCacheCreateInfo) InitialDataSize() uint64 {
	ptr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.initialDataSize) 
	return *ptr
}

// WithInitialDataSize sets the value for the InitialDataSize on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheCreateInfo) WithInitialDataSize(y uint64) PipelineCacheCreateInfo {
	x.initialDataSize = *(func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&y))
	return x
}

// PInitialData returns the value of pInitialData from VkPipelineCacheCreateInfo
func (x PipelineCacheCreateInfo) PInitialData() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pInitialData) 
	return *ptr
}

// WithPInitialData sets the value for the PInitialData on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCacheCreateInfo) WithPInitialData(y unsafe.Pointer) PipelineCacheCreateInfo {
	x.pInitialData = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SubpassDescription provides a go interface for VkSubpassDescription.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDescription.html
type SubpassDescription C.struct_VkSubpassDescription

// SizeofSubpassDescription is the memory size of a SubpassDescription
var SizeofSubpassDescription int = int(unsafe.Sizeof(SubpassDescription{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubpassDescription) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubpassDescription) AsCPtr() *SubpassDescription {
	clone := (*SubpassDescription)(newCBlock(C.ulong(SizeofSubpassDescription)))
	*clone = x
	return clone
}

// SubpassDescriptionFreeCSlice releases the memory allocated by SubpassDescriptionMakeCSlice.
// It does not free pointers stored inside the slice.
func SubpassDescriptionFreeCSlice(x []SubpassDescription) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubpassDescriptionMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubpassDescriptionFreeCSlice must be called on the returned slice.
func SubpassDescriptionMakeCSlice(x ...SubpassDescription) []SubpassDescription {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassDescription * len(x)
	dst := unsafe.Slice((*SubpassDescription)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Flags returns the value of flags from VkSubpassDescription
func (x SubpassDescription) Flags() SubpassDescriptionFlags {
	ptr := /* typedef */ (*SubpassDescriptionFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription) WithFlags(y SubpassDescriptionFlags) SubpassDescription {
	x.flags = *(/* typedef */ (*C.VkSubpassDescriptionFlags)(&y))
	return x
}

// PipelineBindPoint returns the value of pipelineBindPoint from VkSubpassDescription
func (x SubpassDescription) PipelineBindPoint() PipelineBindPoint {
	ptr := /* typedef */ (*PipelineBindPoint)(&x.pipelineBindPoint) 
	return *ptr
}

// WithPipelineBindPoint sets the value for the PipelineBindPoint on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription) WithPipelineBindPoint(y PipelineBindPoint) SubpassDescription {
	x.pipelineBindPoint = *(/* typedef */ (*C.VkPipelineBindPoint)(&y))
	return x
}

// InputAttachmentCount returns the value of inputAttachmentCount from VkSubpassDescription
func (x SubpassDescription) InputAttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.inputAttachmentCount) 
	return *ptr
}

// WithInputAttachmentCount sets the value for the InputAttachmentCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription) WithInputAttachmentCount(y uint32) SubpassDescription {
	x.inputAttachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PInputAttachments returns the value of pInputAttachments from VkSubpassDescription
func (x SubpassDescription) PInputAttachments() []AttachmentReference {
	ptr := func(x **C.struct_VkAttachmentReference) *[]AttachmentReference { /* Slice */ slc := unsafe.Slice((*AttachmentReference)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pInputAttachments) 
	return *ptr
}

// WithPInputAttachments sets the value for the PInputAttachments on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines InputAttachmentCount as the length of this field.
// InputAttachmentCount is updated with the length of the new value.
func (x SubpassDescription) WithPInputAttachments(y []AttachmentReference) SubpassDescription {
	x.pInputAttachments = *(func(x *[]AttachmentReference) **C.struct_VkAttachmentReference { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkAttachmentReference)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkAttachmentReference)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithInputAttachmentCount(uint32(len(y)))
}

// ColorAttachmentCount returns the value of colorAttachmentCount from VkSubpassDescription
func (x SubpassDescription) ColorAttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.colorAttachmentCount) 
	return *ptr
}

// WithColorAttachmentCount sets the value for the ColorAttachmentCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription) WithColorAttachmentCount(y uint32) SubpassDescription {
	x.colorAttachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PColorAttachments returns the value of pColorAttachments from VkSubpassDescription
func (x SubpassDescription) PColorAttachments() []AttachmentReference {
	ptr := func(x **C.struct_VkAttachmentReference) *[]AttachmentReference { /* Slice */ slc := unsafe.Slice((*AttachmentReference)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pColorAttachments) 
	return *ptr
}

// WithPColorAttachments sets the value for the PColorAttachments on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines ColorAttachmentCount as the length of this field.
// ColorAttachmentCount is updated with the length of the new value.
func (x SubpassDescription) WithPColorAttachments(y []AttachmentReference) SubpassDescription {
	x.pColorAttachments = *(func(x *[]AttachmentReference) **C.struct_VkAttachmentReference { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkAttachmentReference)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkAttachmentReference)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithColorAttachmentCount(uint32(len(y)))
}

// PResolveAttachments returns the value of pResolveAttachments from VkSubpassDescription
func (x SubpassDescription) PResolveAttachments() []AttachmentReference {
	ptr := func(x **C.struct_VkAttachmentReference) *[]AttachmentReference { /* Slice */ slc := unsafe.Slice((*AttachmentReference)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pResolveAttachments) 
	return *ptr
}

// WithPResolveAttachments sets the value for the PResolveAttachments on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines ColorAttachmentCount as the length of this field.
// ColorAttachmentCount is updated with the length of the new value.
func (x SubpassDescription) WithPResolveAttachments(y []AttachmentReference) SubpassDescription {
	x.pResolveAttachments = *(func(x *[]AttachmentReference) **C.struct_VkAttachmentReference { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkAttachmentReference)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkAttachmentReference)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithColorAttachmentCount(uint32(len(y)))
}

// PDepthStencilAttachment returns the value of pDepthStencilAttachment from VkSubpassDescription
func (x SubpassDescription) PDepthStencilAttachment() *AttachmentReference {
	ptr := func(x **C.struct_VkAttachmentReference) **AttachmentReference { /* Pointer */ c2g := (*AttachmentReference)(*x); return &c2g }(&x.pDepthStencilAttachment) 
	return *ptr
}

// WithPDepthStencilAttachment sets the value for the PDepthStencilAttachment on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription) WithPDepthStencilAttachment(y *AttachmentReference) SubpassDescription {
	x.pDepthStencilAttachment = *(func(x **AttachmentReference) **C.struct_VkAttachmentReference { /* Pointer */ g2c := (*C.struct_VkAttachmentReference)(*x); return &g2c }(&y))
	return x
}

// PreserveAttachmentCount returns the value of preserveAttachmentCount from VkSubpassDescription
func (x SubpassDescription) PreserveAttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.preserveAttachmentCount) 
	return *ptr
}

// WithPreserveAttachmentCount sets the value for the PreserveAttachmentCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription) WithPreserveAttachmentCount(y uint32) SubpassDescription {
	x.preserveAttachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PPreserveAttachments returns the value of pPreserveAttachments from VkSubpassDescription
func (x SubpassDescription) PPreserveAttachments() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */ slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pPreserveAttachments) 
	return *ptr
}

// WithPPreserveAttachments sets the value for the PPreserveAttachments on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines PreserveAttachmentCount as the length of this field.
// PreserveAttachmentCount is updated with the length of the new value.
func (x SubpassDescription) WithPPreserveAttachments(y []uint32) SubpassDescription {
	x.pPreserveAttachments = *(func(x *[]uint32) **C.uint32_t { /* Slice */ if len(*x) > 0 { slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.uint32_t)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithPreserveAttachmentCount(uint32(len(y)))
}

// SubpassDependency provides a go interface for VkSubpassDependency.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDependency.html
type SubpassDependency C.struct_VkSubpassDependency

// SizeofSubpassDependency is the memory size of a SubpassDependency
var SizeofSubpassDependency int = int(unsafe.Sizeof(SubpassDependency{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubpassDependency) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubpassDependency) AsCPtr() *SubpassDependency {
	clone := (*SubpassDependency)(newCBlock(C.ulong(SizeofSubpassDependency)))
	*clone = x
	return clone
}

// SubpassDependencyFreeCSlice releases the memory allocated by SubpassDependencyMakeCSlice.
// It does not free pointers stored inside the slice.
func SubpassDependencyFreeCSlice(x []SubpassDependency) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubpassDependencyMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubpassDependencyFreeCSlice must be called on the returned slice.
func SubpassDependencyMakeCSlice(x ...SubpassDependency) []SubpassDependency {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassDependency * len(x)
	dst := unsafe.Slice((*SubpassDependency)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SrcSubpass returns the value of srcSubpass from VkSubpassDependency
func (x SubpassDependency) SrcSubpass() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.srcSubpass) 
	return *ptr
}

// WithSrcSubpass sets the value for the SrcSubpass on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency) WithSrcSubpass(y uint32) SubpassDependency {
	x.srcSubpass = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// DstSubpass returns the value of dstSubpass from VkSubpassDependency
func (x SubpassDependency) DstSubpass() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dstSubpass) 
	return *ptr
}

// WithDstSubpass sets the value for the DstSubpass on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency) WithDstSubpass(y uint32) SubpassDependency {
	x.dstSubpass = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// SrcStageMask returns the value of srcStageMask from VkSubpassDependency
func (x SubpassDependency) SrcStageMask() PipelineStageFlags {
	ptr := /* typedef */ (*PipelineStageFlags)(&x.srcStageMask) 
	return *ptr
}

// WithSrcStageMask sets the value for the SrcStageMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency) WithSrcStageMask(y PipelineStageFlags) SubpassDependency {
	x.srcStageMask = *(/* typedef */ (*C.VkPipelineStageFlags)(&y))
	return x
}

// DstStageMask returns the value of dstStageMask from VkSubpassDependency
func (x SubpassDependency) DstStageMask() PipelineStageFlags {
	ptr := /* typedef */ (*PipelineStageFlags)(&x.dstStageMask) 
	return *ptr
}

// WithDstStageMask sets the value for the DstStageMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency) WithDstStageMask(y PipelineStageFlags) SubpassDependency {
	x.dstStageMask = *(/* typedef */ (*C.VkPipelineStageFlags)(&y))
	return x
}

// SrcAccessMask returns the value of srcAccessMask from VkSubpassDependency
func (x SubpassDependency) SrcAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.srcAccessMask) 
	return *ptr
}

// WithSrcAccessMask sets the value for the SrcAccessMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency) WithSrcAccessMask(y AccessFlags) SubpassDependency {
	x.srcAccessMask = *(/* typedef */ (*C.VkAccessFlags)(&y))
	return x
}

// DstAccessMask returns the value of dstAccessMask from VkSubpassDependency
func (x SubpassDependency) DstAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.dstAccessMask) 
	return *ptr
}

// WithDstAccessMask sets the value for the DstAccessMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency) WithDstAccessMask(y AccessFlags) SubpassDependency {
	x.dstAccessMask = *(/* typedef */ (*C.VkAccessFlags)(&y))
	return x
}

// DependencyFlags returns the value of dependencyFlags from VkSubpassDependency
func (x SubpassDependency) DependencyFlags() DependencyFlags {
	ptr := /* typedef */ (*DependencyFlags)(&x.dependencyFlags) 
	return *ptr
}

// WithDependencyFlags sets the value for the DependencyFlags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency) WithDependencyFlags(y DependencyFlags) SubpassDependency {
	x.dependencyFlags = *(/* typedef */ (*C.VkDependencyFlags)(&y))
	return x
}

// RenderPassCreateInfo provides a go interface for VkRenderPassCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreateInfo.html
type RenderPassCreateInfo C.struct_VkRenderPassCreateInfo

// SizeofRenderPassCreateInfo is the memory size of a RenderPassCreateInfo
var SizeofRenderPassCreateInfo int = int(unsafe.Sizeof(RenderPassCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *RenderPassCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x RenderPassCreateInfo) AsCPtr() *RenderPassCreateInfo {
	clone := (*RenderPassCreateInfo)(newCBlock(C.ulong(SizeofRenderPassCreateInfo)))
	*clone = x
	return clone
}

// RenderPassCreateInfoFreeCSlice releases the memory allocated by RenderPassCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func RenderPassCreateInfoFreeCSlice(x []RenderPassCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// RenderPassCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. RenderPassCreateInfoFreeCSlice must be called on the returned slice.
func RenderPassCreateInfoMakeCSlice(x ...RenderPassCreateInfo) []RenderPassCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderPassCreateInfo * len(x)
	dst := unsafe.Slice((*RenderPassCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkRenderPassCreateInfo
func (x RenderPassCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x RenderPassCreateInfo) WithDefaultSType() RenderPassCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo) WithSType(y StructureType) RenderPassCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkRenderPassCreateInfo
func (x RenderPassCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo) WithPNext(y unsafe.Pointer) RenderPassCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkRenderPassCreateInfo
func (x RenderPassCreateInfo) Flags() RenderPassCreateFlags {
	ptr := /* typedef */ (*RenderPassCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo) WithFlags(y RenderPassCreateFlags) RenderPassCreateInfo {
	x.flags = *(/* typedef */ (*C.VkRenderPassCreateFlags)(&y))
	return x
}

// AttachmentCount returns the value of attachmentCount from VkRenderPassCreateInfo
func (x RenderPassCreateInfo) AttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.attachmentCount) 
	return *ptr
}

// WithAttachmentCount sets the value for the AttachmentCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo) WithAttachmentCount(y uint32) RenderPassCreateInfo {
	x.attachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PAttachments returns the value of pAttachments from VkRenderPassCreateInfo
func (x RenderPassCreateInfo) PAttachments() []AttachmentDescription {
	ptr := func(x **C.struct_VkAttachmentDescription) *[]AttachmentDescription { /* Slice */ slc := unsafe.Slice((*AttachmentDescription)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pAttachments) 
	return *ptr
}

// WithPAttachments sets the value for the PAttachments on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines AttachmentCount as the length of this field.
// AttachmentCount is updated with the length of the new value.
func (x RenderPassCreateInfo) WithPAttachments(y []AttachmentDescription) RenderPassCreateInfo {
	x.pAttachments = *(func(x *[]AttachmentDescription) **C.struct_VkAttachmentDescription { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkAttachmentDescription)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkAttachmentDescription)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithAttachmentCount(uint32(len(y)))
}

// SubpassCount returns the value of subpassCount from VkRenderPassCreateInfo
func (x RenderPassCreateInfo) SubpassCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.subpassCount) 
	return *ptr
}

// WithSubpassCount sets the value for the SubpassCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo) WithSubpassCount(y uint32) RenderPassCreateInfo {
	x.subpassCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PSubpasses returns the value of pSubpasses from VkRenderPassCreateInfo
func (x RenderPassCreateInfo) PSubpasses() []SubpassDescription {
	ptr := func(x **C.struct_VkSubpassDescription) *[]SubpassDescription { /* Slice */ slc := unsafe.Slice((*SubpassDescription)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pSubpasses) 
	return *ptr
}

// WithPSubpasses sets the value for the PSubpasses on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines SubpassCount as the length of this field.
// SubpassCount is updated with the length of the new value.
func (x RenderPassCreateInfo) WithPSubpasses(y []SubpassDescription) RenderPassCreateInfo {
	x.pSubpasses = *(func(x *[]SubpassDescription) **C.struct_VkSubpassDescription { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkSubpassDescription)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkSubpassDescription)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithSubpassCount(uint32(len(y)))
}

// DependencyCount returns the value of dependencyCount from VkRenderPassCreateInfo
func (x RenderPassCreateInfo) DependencyCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dependencyCount) 
	return *ptr
}

// WithDependencyCount sets the value for the DependencyCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo) WithDependencyCount(y uint32) RenderPassCreateInfo {
	x.dependencyCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PDependencies returns the value of pDependencies from VkRenderPassCreateInfo
func (x RenderPassCreateInfo) PDependencies() []SubpassDependency {
	ptr := func(x **C.struct_VkSubpassDependency) *[]SubpassDependency { /* Slice */ slc := unsafe.Slice((*SubpassDependency)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pDependencies) 
	return *ptr
}

// WithPDependencies sets the value for the PDependencies on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines DependencyCount as the length of this field.
// DependencyCount is updated with the length of the new value.
func (x RenderPassCreateInfo) WithPDependencies(y []SubpassDependency) RenderPassCreateInfo {
	x.pDependencies = *(func(x *[]SubpassDependency) **C.struct_VkSubpassDependency { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkSubpassDependency)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkSubpassDependency)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithDependencyCount(uint32(len(y)))
}

// MappedMemoryRange provides a go interface for VkMappedMemoryRange.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMappedMemoryRange.html
type MappedMemoryRange C.struct_VkMappedMemoryRange

// SizeofMappedMemoryRange is the memory size of a MappedMemoryRange
var SizeofMappedMemoryRange int = int(unsafe.Sizeof(MappedMemoryRange{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MappedMemoryRange) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MappedMemoryRange) AsCPtr() *MappedMemoryRange {
	clone := (*MappedMemoryRange)(newCBlock(C.ulong(SizeofMappedMemoryRange)))
	*clone = x
	return clone
}

// MappedMemoryRangeFreeCSlice releases the memory allocated by MappedMemoryRangeMakeCSlice.
// It does not free pointers stored inside the slice.
func MappedMemoryRangeFreeCSlice(x []MappedMemoryRange) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MappedMemoryRangeMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MappedMemoryRangeFreeCSlice must be called on the returned slice.
func MappedMemoryRangeMakeCSlice(x ...MappedMemoryRange) []MappedMemoryRange {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMappedMemoryRange * len(x)
	dst := unsafe.Slice((*MappedMemoryRange)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkMappedMemoryRange
func (x MappedMemoryRange) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x MappedMemoryRange) WithDefaultSType() MappedMemoryRange {
	return x.WithSType(VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MappedMemoryRange) WithSType(y StructureType) MappedMemoryRange {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkMappedMemoryRange
func (x MappedMemoryRange) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MappedMemoryRange) WithPNext(y unsafe.Pointer) MappedMemoryRange {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Memory returns the value of memory from VkMappedMemoryRange
func (x MappedMemoryRange) Memory() DeviceMemory {
	ptr := /* handle */ (*DeviceMemory)(&x.memory) 
	return *ptr
}

// WithMemory sets the value for the Memory on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MappedMemoryRange) WithMemory(y DeviceMemory) MappedMemoryRange {
	x.memory = *(/* handle */ (*C.VkDeviceMemory)(&y))
	return x
}

// Offset returns the value of offset from VkMappedMemoryRange
func (x MappedMemoryRange) Offset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.offset) 
	return *ptr
}

// WithOffset sets the value for the Offset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MappedMemoryRange) WithOffset(y DeviceSize) MappedMemoryRange {
	x.offset = *(/* typedef */ (*C.VkDeviceSize)(&y))
	return x
}

// Size returns the value of size from VkMappedMemoryRange
func (x MappedMemoryRange) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size) 
	return *ptr
}

// WithSize sets the value for the Size on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MappedMemoryRange) WithSize(y DeviceSize) MappedMemoryRange {
	x.size = *(/* typedef */ (*C.VkDeviceSize)(&y))
	return x
}

// RenderPassBeginInfo provides a go interface for VkRenderPassBeginInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassBeginInfo.html
type RenderPassBeginInfo C.struct_VkRenderPassBeginInfo

// SizeofRenderPassBeginInfo is the memory size of a RenderPassBeginInfo
var SizeofRenderPassBeginInfo int = int(unsafe.Sizeof(RenderPassBeginInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *RenderPassBeginInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x RenderPassBeginInfo) AsCPtr() *RenderPassBeginInfo {
	clone := (*RenderPassBeginInfo)(newCBlock(C.ulong(SizeofRenderPassBeginInfo)))
	*clone = x
	return clone
}

// RenderPassBeginInfoFreeCSlice releases the memory allocated by RenderPassBeginInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func RenderPassBeginInfoFreeCSlice(x []RenderPassBeginInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// RenderPassBeginInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. RenderPassBeginInfoFreeCSlice must be called on the returned slice.
func RenderPassBeginInfoMakeCSlice(x ...RenderPassBeginInfo) []RenderPassBeginInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderPassBeginInfo * len(x)
	dst := unsafe.Slice((*RenderPassBeginInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkRenderPassBeginInfo
func (x RenderPassBeginInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x RenderPassBeginInfo) WithDefaultSType() RenderPassBeginInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassBeginInfo) WithSType(y StructureType) RenderPassBeginInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkRenderPassBeginInfo
func (x RenderPassBeginInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassBeginInfo) WithPNext(y unsafe.Pointer) RenderPassBeginInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// RenderPass returns the value of renderPass from VkRenderPassBeginInfo
func (x RenderPassBeginInfo) RenderPass() RenderPass {
	ptr := /* handle */ (*RenderPass)(&x.renderPass) 
	return *ptr
}

// WithRenderPass sets the value for the RenderPass on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassBeginInfo) WithRenderPass(y RenderPass) RenderPassBeginInfo {
	x.renderPass = *(/* handle */ (*C.VkRenderPass)(&y))
	return x
}

// Framebuffer returns the value of framebuffer from VkRenderPassBeginInfo
func (x RenderPassBeginInfo) Framebuffer() Framebuffer {
	ptr := /* handle */ (*Framebuffer)(&x.framebuffer) 
	return *ptr
}

// WithFramebuffer sets the value for the Framebuffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassBeginInfo) WithFramebuffer(y Framebuffer) RenderPassBeginInfo {
	x.framebuffer = *(/* handle */ (*C.VkFramebuffer)(&y))
	return x
}

// RenderArea returns the value of renderArea from VkRenderPassBeginInfo
func (x RenderPassBeginInfo) RenderArea() Rect2D {
	ptr := /* typedef */ (*Rect2D)(&x.renderArea) 
	return *ptr
}

// WithRenderArea sets the value for the RenderArea on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassBeginInfo) WithRenderArea(y Rect2D) RenderPassBeginInfo {
	x.renderArea = *(/* typedef */ (*C.struct_VkRect2D)(&y))
	return x
}

// ClearValueCount returns the value of clearValueCount from VkRenderPassBeginInfo
func (x RenderPassBeginInfo) ClearValueCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.clearValueCount) 
	return *ptr
}

// WithClearValueCount sets the value for the ClearValueCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassBeginInfo) WithClearValueCount(y uint32) RenderPassBeginInfo {
	x.clearValueCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PClearValues returns the value of pClearValues from VkRenderPassBeginInfo
func (x RenderPassBeginInfo) PClearValues() []ClearValue {
	ptr := func(x **C.VkClearValue) *[]ClearValue { /* Slice */ slc := unsafe.Slice((*ClearValue)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pClearValues) 
	return *ptr
}

// WithPClearValues sets the value for the PClearValues on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines ClearValueCount as the length of this field.
// ClearValueCount is updated with the length of the new value.
func (x RenderPassBeginInfo) WithPClearValues(y []ClearValue) RenderPassBeginInfo {
	x.pClearValues = *(func(x *[]ClearValue) **C.VkClearValue { /* Slice */ if len(*x) > 0 { slc := (*C.VkClearValue)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkClearValue)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithClearValueCount(uint32(len(y)))
}

// MemoryType provides a go interface for VkMemoryType.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryType.html
type MemoryType C.struct_VkMemoryType

// SizeofMemoryType is the memory size of a MemoryType
var SizeofMemoryType int = int(unsafe.Sizeof(MemoryType{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryType) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryType) AsCPtr() *MemoryType {
	clone := (*MemoryType)(newCBlock(C.ulong(SizeofMemoryType)))
	*clone = x
	return clone
}

// MemoryTypeFreeCSlice releases the memory allocated by MemoryTypeMakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryTypeFreeCSlice(x []MemoryType) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryTypeMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryTypeFreeCSlice must be called on the returned slice.
func MemoryTypeMakeCSlice(x ...MemoryType) []MemoryType {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryType * len(x)
	dst := unsafe.Slice((*MemoryType)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// PropertyFlags returns the value of propertyFlags from VkMemoryType
func (x MemoryType) PropertyFlags() MemoryPropertyFlags {
	ptr := /* typedef */ (*MemoryPropertyFlags)(&x.propertyFlags) 
	return *ptr
}

// HeapIndex returns the value of heapIndex from VkMemoryType
func (x MemoryType) HeapIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.heapIndex) 
	return *ptr
}

// BaseOutStructure provides a go interface for VkBaseOutStructure.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBaseOutStructure.html
type BaseOutStructure C.struct_VkBaseOutStructure

// SizeofBaseOutStructure is the memory size of a BaseOutStructure
var SizeofBaseOutStructure int = int(unsafe.Sizeof(BaseOutStructure{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BaseOutStructure) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BaseOutStructure) AsCPtr() *BaseOutStructure {
	clone := (*BaseOutStructure)(newCBlock(C.ulong(SizeofBaseOutStructure)))
	*clone = x
	return clone
}

// BaseOutStructureFreeCSlice releases the memory allocated by BaseOutStructureMakeCSlice.
// It does not free pointers stored inside the slice.
func BaseOutStructureFreeCSlice(x []BaseOutStructure) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BaseOutStructureMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BaseOutStructureFreeCSlice must be called on the returned slice.
func BaseOutStructureMakeCSlice(x ...BaseOutStructure) []BaseOutStructure {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBaseOutStructure * len(x)
	dst := unsafe.Slice((*BaseOutStructure)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBaseOutStructure
func (x BaseOutStructure) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BaseOutStructure) WithSType(y StructureType) BaseOutStructure {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkBaseOutStructure
func (x BaseOutStructure) PNext() *BaseOutStructure {
	ptr := func(x **C.struct_VkBaseOutStructure) **BaseOutStructure { /* Pointer */ c2g := (*BaseOutStructure)(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BaseOutStructure) WithPNext(y *BaseOutStructure) BaseOutStructure {
	x.pNext = *(func(x **BaseOutStructure) **C.struct_VkBaseOutStructure { /* Pointer */ g2c := (*C.struct_VkBaseOutStructure)(*x); return &g2c }(&y))
	return x
}

// BufferMemoryBarrier provides a go interface for VkBufferMemoryBarrier.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferMemoryBarrier.html
type BufferMemoryBarrier C.struct_VkBufferMemoryBarrier

// SizeofBufferMemoryBarrier is the memory size of a BufferMemoryBarrier
var SizeofBufferMemoryBarrier int = int(unsafe.Sizeof(BufferMemoryBarrier{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferMemoryBarrier) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferMemoryBarrier) AsCPtr() *BufferMemoryBarrier {
	clone := (*BufferMemoryBarrier)(newCBlock(C.ulong(SizeofBufferMemoryBarrier)))
	*clone = x
	return clone
}

// BufferMemoryBarrierFreeCSlice releases the memory allocated by BufferMemoryBarrierMakeCSlice.
// It does not free pointers stored inside the slice.
func BufferMemoryBarrierFreeCSlice(x []BufferMemoryBarrier) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferMemoryBarrierMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferMemoryBarrierFreeCSlice must be called on the returned slice.
func BufferMemoryBarrierMakeCSlice(x ...BufferMemoryBarrier) []BufferMemoryBarrier {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferMemoryBarrier * len(x)
	dst := unsafe.Slice((*BufferMemoryBarrier)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBufferMemoryBarrier
func (x BufferMemoryBarrier) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BufferMemoryBarrier) WithDefaultSType() BufferMemoryBarrier {
	return x.WithSType(VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier) WithSType(y StructureType) BufferMemoryBarrier {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkBufferMemoryBarrier
func (x BufferMemoryBarrier) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier) WithPNext(y unsafe.Pointer) BufferMemoryBarrier {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SrcAccessMask returns the value of srcAccessMask from VkBufferMemoryBarrier
func (x BufferMemoryBarrier) SrcAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.srcAccessMask) 
	return *ptr
}

// WithSrcAccessMask sets the value for the SrcAccessMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier) WithSrcAccessMask(y AccessFlags) BufferMemoryBarrier {
	x.srcAccessMask = *(/* typedef */ (*C.VkAccessFlags)(&y))
	return x
}

// DstAccessMask returns the value of dstAccessMask from VkBufferMemoryBarrier
func (x BufferMemoryBarrier) DstAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.dstAccessMask) 
	return *ptr
}

// WithDstAccessMask sets the value for the DstAccessMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier) WithDstAccessMask(y AccessFlags) BufferMemoryBarrier {
	x.dstAccessMask = *(/* typedef */ (*C.VkAccessFlags)(&y))
	return x
}

// SrcQueueFamilyIndex returns the value of srcQueueFamilyIndex from VkBufferMemoryBarrier
func (x BufferMemoryBarrier) SrcQueueFamilyIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.srcQueueFamilyIndex) 
	return *ptr
}

// WithSrcQueueFamilyIndex sets the value for the SrcQueueFamilyIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier) WithSrcQueueFamilyIndex(y uint32) BufferMemoryBarrier {
	x.srcQueueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// DstQueueFamilyIndex returns the value of dstQueueFamilyIndex from VkBufferMemoryBarrier
func (x BufferMemoryBarrier) DstQueueFamilyIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dstQueueFamilyIndex) 
	return *ptr
}

// WithDstQueueFamilyIndex sets the value for the DstQueueFamilyIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier) WithDstQueueFamilyIndex(y uint32) BufferMemoryBarrier {
	x.dstQueueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// Buffer returns the value of buffer from VkBufferMemoryBarrier
func (x BufferMemoryBarrier) Buffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.buffer) 
	return *ptr
}

// WithBuffer sets the value for the Buffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier) WithBuffer(y Buffer) BufferMemoryBarrier {
	x.buffer = *(/* handle */ (*C.VkBuffer)(&y))
	return x
}

// Offset returns the value of offset from VkBufferMemoryBarrier
func (x BufferMemoryBarrier) Offset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.offset) 
	return *ptr
}

// WithOffset sets the value for the Offset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier) WithOffset(y DeviceSize) BufferMemoryBarrier {
	x.offset = *(/* typedef */ (*C.VkDeviceSize)(&y))
	return x
}

// Size returns the value of size from VkBufferMemoryBarrier
func (x BufferMemoryBarrier) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size) 
	return *ptr
}

// WithSize sets the value for the Size on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier) WithSize(y DeviceSize) BufferMemoryBarrier {
	x.size = *(/* typedef */ (*C.VkDeviceSize)(&y))
	return x
}

// ComputePipelineCreateInfo provides a go interface for VkComputePipelineCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkComputePipelineCreateInfo.html
type ComputePipelineCreateInfo C.struct_VkComputePipelineCreateInfo

// SizeofComputePipelineCreateInfo is the memory size of a ComputePipelineCreateInfo
var SizeofComputePipelineCreateInfo int = int(unsafe.Sizeof(ComputePipelineCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ComputePipelineCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ComputePipelineCreateInfo) AsCPtr() *ComputePipelineCreateInfo {
	clone := (*ComputePipelineCreateInfo)(newCBlock(C.ulong(SizeofComputePipelineCreateInfo)))
	*clone = x
	return clone
}

// ComputePipelineCreateInfoFreeCSlice releases the memory allocated by ComputePipelineCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ComputePipelineCreateInfoFreeCSlice(x []ComputePipelineCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ComputePipelineCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ComputePipelineCreateInfoFreeCSlice must be called on the returned slice.
func ComputePipelineCreateInfoMakeCSlice(x ...ComputePipelineCreateInfo) []ComputePipelineCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofComputePipelineCreateInfo * len(x)
	dst := unsafe.Slice((*ComputePipelineCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkComputePipelineCreateInfo
func (x ComputePipelineCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ComputePipelineCreateInfo) WithDefaultSType() ComputePipelineCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComputePipelineCreateInfo) WithSType(y StructureType) ComputePipelineCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkComputePipelineCreateInfo
func (x ComputePipelineCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComputePipelineCreateInfo) WithPNext(y unsafe.Pointer) ComputePipelineCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkComputePipelineCreateInfo
func (x ComputePipelineCreateInfo) Flags() PipelineCreateFlags {
	ptr := /* typedef */ (*PipelineCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComputePipelineCreateInfo) WithFlags(y PipelineCreateFlags) ComputePipelineCreateInfo {
	x.flags = *(/* typedef */ (*C.VkPipelineCreateFlags)(&y))
	return x
}

// Stage returns the value of stage from VkComputePipelineCreateInfo
func (x ComputePipelineCreateInfo) Stage() PipelineShaderStageCreateInfo {
	ptr := /* typedef */ (*PipelineShaderStageCreateInfo)(&x.stage) 
	return *ptr
}

// WithStage sets the value for the Stage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComputePipelineCreateInfo) WithStage(y PipelineShaderStageCreateInfo) ComputePipelineCreateInfo {
	x.stage = *(/* typedef */ (*C.struct_VkPipelineShaderStageCreateInfo)(&y))
	return x
}

// Layout returns the value of layout from VkComputePipelineCreateInfo
func (x ComputePipelineCreateInfo) Layout() PipelineLayout {
	ptr := /* handle */ (*PipelineLayout)(&x.layout) 
	return *ptr
}

// WithLayout sets the value for the Layout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComputePipelineCreateInfo) WithLayout(y PipelineLayout) ComputePipelineCreateInfo {
	x.layout = *(/* handle */ (*C.VkPipelineLayout)(&y))
	return x
}

// BasePipelineHandle returns the value of basePipelineHandle from VkComputePipelineCreateInfo
func (x ComputePipelineCreateInfo) BasePipelineHandle() Pipeline {
	ptr := /* handle */ (*Pipeline)(&x.basePipelineHandle) 
	return *ptr
}

// WithBasePipelineHandle sets the value for the BasePipelineHandle on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComputePipelineCreateInfo) WithBasePipelineHandle(y Pipeline) ComputePipelineCreateInfo {
	x.basePipelineHandle = *(/* handle */ (*C.VkPipeline)(&y))
	return x
}

// BasePipelineIndex returns the value of basePipelineIndex from VkComputePipelineCreateInfo
func (x ComputePipelineCreateInfo) BasePipelineIndex() int32 {
	ptr := func(x *C.int32_t) *int32 { /* Scalar */ c2g := int32(*x); return &c2g }(&x.basePipelineIndex) 
	return *ptr
}

// WithBasePipelineIndex sets the value for the BasePipelineIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ComputePipelineCreateInfo) WithBasePipelineIndex(y int32) ComputePipelineCreateInfo {
	x.basePipelineIndex = *(func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&y))
	return x
}

// FramebufferCreateInfo provides a go interface for VkFramebufferCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebufferCreateInfo.html
type FramebufferCreateInfo C.struct_VkFramebufferCreateInfo

// SizeofFramebufferCreateInfo is the memory size of a FramebufferCreateInfo
var SizeofFramebufferCreateInfo int = int(unsafe.Sizeof(FramebufferCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *FramebufferCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x FramebufferCreateInfo) AsCPtr() *FramebufferCreateInfo {
	clone := (*FramebufferCreateInfo)(newCBlock(C.ulong(SizeofFramebufferCreateInfo)))
	*clone = x
	return clone
}

// FramebufferCreateInfoFreeCSlice releases the memory allocated by FramebufferCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func FramebufferCreateInfoFreeCSlice(x []FramebufferCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// FramebufferCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. FramebufferCreateInfoFreeCSlice must be called on the returned slice.
func FramebufferCreateInfoMakeCSlice(x ...FramebufferCreateInfo) []FramebufferCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFramebufferCreateInfo * len(x)
	dst := unsafe.Slice((*FramebufferCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkFramebufferCreateInfo
func (x FramebufferCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x FramebufferCreateInfo) WithDefaultSType() FramebufferCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferCreateInfo) WithSType(y StructureType) FramebufferCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkFramebufferCreateInfo
func (x FramebufferCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferCreateInfo) WithPNext(y unsafe.Pointer) FramebufferCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkFramebufferCreateInfo
func (x FramebufferCreateInfo) Flags() FramebufferCreateFlags {
	ptr := /* typedef */ (*FramebufferCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferCreateInfo) WithFlags(y FramebufferCreateFlags) FramebufferCreateInfo {
	x.flags = *(/* typedef */ (*C.VkFramebufferCreateFlags)(&y))
	return x
}

// RenderPass returns the value of renderPass from VkFramebufferCreateInfo
func (x FramebufferCreateInfo) RenderPass() RenderPass {
	ptr := /* handle */ (*RenderPass)(&x.renderPass) 
	return *ptr
}

// WithRenderPass sets the value for the RenderPass on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferCreateInfo) WithRenderPass(y RenderPass) FramebufferCreateInfo {
	x.renderPass = *(/* handle */ (*C.VkRenderPass)(&y))
	return x
}

// AttachmentCount returns the value of attachmentCount from VkFramebufferCreateInfo
func (x FramebufferCreateInfo) AttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.attachmentCount) 
	return *ptr
}

// WithAttachmentCount sets the value for the AttachmentCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferCreateInfo) WithAttachmentCount(y uint32) FramebufferCreateInfo {
	x.attachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PAttachments returns the value of pAttachments from VkFramebufferCreateInfo
func (x FramebufferCreateInfo) PAttachments() []ImageView {
	ptr := func(x **C.VkImageView) *[]ImageView { /* Slice */ slc := unsafe.Slice((*ImageView)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pAttachments) 
	return *ptr
}

// WithPAttachments sets the value for the PAttachments on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines AttachmentCount as the length of this field.
// AttachmentCount is updated with the length of the new value.
func (x FramebufferCreateInfo) WithPAttachments(y []ImageView) FramebufferCreateInfo {
	x.pAttachments = *(func(x *[]ImageView) **C.VkImageView { /* Slice */ if len(*x) > 0 { slc := (*C.VkImageView)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkImageView)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithAttachmentCount(uint32(len(y)))
}

// Width returns the value of width from VkFramebufferCreateInfo
func (x FramebufferCreateInfo) Width() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.width) 
	return *ptr
}

// WithWidth sets the value for the Width on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferCreateInfo) WithWidth(y uint32) FramebufferCreateInfo {
	x.width = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// Height returns the value of height from VkFramebufferCreateInfo
func (x FramebufferCreateInfo) Height() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.height) 
	return *ptr
}

// WithHeight sets the value for the Height on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferCreateInfo) WithHeight(y uint32) FramebufferCreateInfo {
	x.height = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// Layers returns the value of layers from VkFramebufferCreateInfo
func (x FramebufferCreateInfo) Layers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.layers) 
	return *ptr
}

// WithLayers sets the value for the Layers on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferCreateInfo) WithLayers(y uint32) FramebufferCreateInfo {
	x.layers = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// DispatchIndirectCommand provides a go interface for VkDispatchIndirectCommand.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDispatchIndirectCommand.html
type DispatchIndirectCommand C.struct_VkDispatchIndirectCommand

// SizeofDispatchIndirectCommand is the memory size of a DispatchIndirectCommand
var SizeofDispatchIndirectCommand int = int(unsafe.Sizeof(DispatchIndirectCommand{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DispatchIndirectCommand) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DispatchIndirectCommand) AsCPtr() *DispatchIndirectCommand {
	clone := (*DispatchIndirectCommand)(newCBlock(C.ulong(SizeofDispatchIndirectCommand)))
	*clone = x
	return clone
}

// DispatchIndirectCommandFreeCSlice releases the memory allocated by DispatchIndirectCommandMakeCSlice.
// It does not free pointers stored inside the slice.
func DispatchIndirectCommandFreeCSlice(x []DispatchIndirectCommand) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DispatchIndirectCommandMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DispatchIndirectCommandFreeCSlice must be called on the returned slice.
func DispatchIndirectCommandMakeCSlice(x ...DispatchIndirectCommand) []DispatchIndirectCommand {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDispatchIndirectCommand * len(x)
	dst := unsafe.Slice((*DispatchIndirectCommand)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// X returns the value of x from VkDispatchIndirectCommand
func (x DispatchIndirectCommand) X() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.x) 
	return *ptr
}

// WithX sets the value for the X on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DispatchIndirectCommand) WithX(y uint32) DispatchIndirectCommand {
	x.x = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// Y returns the value of y from VkDispatchIndirectCommand
func (x DispatchIndirectCommand) Y() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.y) 
	return *ptr
}

// WithY sets the value for the Y on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DispatchIndirectCommand) WithY(y uint32) DispatchIndirectCommand {
	x.y = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// Z returns the value of z from VkDispatchIndirectCommand
func (x DispatchIndirectCommand) Z() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.z) 
	return *ptr
}

// WithZ sets the value for the Z on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DispatchIndirectCommand) WithZ(y uint32) DispatchIndirectCommand {
	x.z = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// DrawIndexedIndirectCommand provides a go interface for VkDrawIndexedIndirectCommand.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrawIndexedIndirectCommand.html
type DrawIndexedIndirectCommand C.struct_VkDrawIndexedIndirectCommand

// SizeofDrawIndexedIndirectCommand is the memory size of a DrawIndexedIndirectCommand
var SizeofDrawIndexedIndirectCommand int = int(unsafe.Sizeof(DrawIndexedIndirectCommand{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DrawIndexedIndirectCommand) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DrawIndexedIndirectCommand) AsCPtr() *DrawIndexedIndirectCommand {
	clone := (*DrawIndexedIndirectCommand)(newCBlock(C.ulong(SizeofDrawIndexedIndirectCommand)))
	*clone = x
	return clone
}

// DrawIndexedIndirectCommandFreeCSlice releases the memory allocated by DrawIndexedIndirectCommandMakeCSlice.
// It does not free pointers stored inside the slice.
func DrawIndexedIndirectCommandFreeCSlice(x []DrawIndexedIndirectCommand) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DrawIndexedIndirectCommandMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DrawIndexedIndirectCommandFreeCSlice must be called on the returned slice.
func DrawIndexedIndirectCommandMakeCSlice(x ...DrawIndexedIndirectCommand) []DrawIndexedIndirectCommand {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDrawIndexedIndirectCommand * len(x)
	dst := unsafe.Slice((*DrawIndexedIndirectCommand)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// IndexCount returns the value of indexCount from VkDrawIndexedIndirectCommand
func (x DrawIndexedIndirectCommand) IndexCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.indexCount) 
	return *ptr
}

// WithIndexCount sets the value for the IndexCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DrawIndexedIndirectCommand) WithIndexCount(y uint32) DrawIndexedIndirectCommand {
	x.indexCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// InstanceCount returns the value of instanceCount from VkDrawIndexedIndirectCommand
func (x DrawIndexedIndirectCommand) InstanceCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.instanceCount) 
	return *ptr
}

// WithInstanceCount sets the value for the InstanceCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DrawIndexedIndirectCommand) WithInstanceCount(y uint32) DrawIndexedIndirectCommand {
	x.instanceCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// FirstIndex returns the value of firstIndex from VkDrawIndexedIndirectCommand
func (x DrawIndexedIndirectCommand) FirstIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.firstIndex) 
	return *ptr
}

// WithFirstIndex sets the value for the FirstIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DrawIndexedIndirectCommand) WithFirstIndex(y uint32) DrawIndexedIndirectCommand {
	x.firstIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// VertexOffset returns the value of vertexOffset from VkDrawIndexedIndirectCommand
func (x DrawIndexedIndirectCommand) VertexOffset() int32 {
	ptr := func(x *C.int32_t) *int32 { /* Scalar */ c2g := int32(*x); return &c2g }(&x.vertexOffset) 
	return *ptr
}

// WithVertexOffset sets the value for the VertexOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DrawIndexedIndirectCommand) WithVertexOffset(y int32) DrawIndexedIndirectCommand {
	x.vertexOffset = *(func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&y))
	return x
}

// FirstInstance returns the value of firstInstance from VkDrawIndexedIndirectCommand
func (x DrawIndexedIndirectCommand) FirstInstance() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.firstInstance) 
	return *ptr
}

// WithFirstInstance sets the value for the FirstInstance on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DrawIndexedIndirectCommand) WithFirstInstance(y uint32) DrawIndexedIndirectCommand {
	x.firstInstance = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// SubmitInfo provides a go interface for VkSubmitInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubmitInfo.html
type SubmitInfo C.struct_VkSubmitInfo

// SizeofSubmitInfo is the memory size of a SubmitInfo
var SizeofSubmitInfo int = int(unsafe.Sizeof(SubmitInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubmitInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubmitInfo) AsCPtr() *SubmitInfo {
	clone := (*SubmitInfo)(newCBlock(C.ulong(SizeofSubmitInfo)))
	*clone = x
	return clone
}

// SubmitInfoFreeCSlice releases the memory allocated by SubmitInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SubmitInfoFreeCSlice(x []SubmitInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubmitInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubmitInfoFreeCSlice must be called on the returned slice.
func SubmitInfoMakeCSlice(x ...SubmitInfo) []SubmitInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubmitInfo * len(x)
	dst := unsafe.Slice((*SubmitInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSubmitInfo
func (x SubmitInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SubmitInfo) WithDefaultSType() SubmitInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SUBMIT_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubmitInfo) WithSType(y StructureType) SubmitInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkSubmitInfo
func (x SubmitInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubmitInfo) WithPNext(y unsafe.Pointer) SubmitInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// WaitSemaphoreCount returns the value of waitSemaphoreCount from VkSubmitInfo
func (x SubmitInfo) WaitSemaphoreCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.waitSemaphoreCount) 
	return *ptr
}

// WithWaitSemaphoreCount sets the value for the WaitSemaphoreCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubmitInfo) WithWaitSemaphoreCount(y uint32) SubmitInfo {
	x.waitSemaphoreCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PWaitSemaphores returns the value of pWaitSemaphores from VkSubmitInfo
func (x SubmitInfo) PWaitSemaphores() []Semaphore {
	ptr := func(x **C.VkSemaphore) *[]Semaphore { /* Slice */ slc := unsafe.Slice((*Semaphore)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pWaitSemaphores) 
	return *ptr
}

// WithPWaitSemaphores sets the value for the PWaitSemaphores on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines WaitSemaphoreCount as the length of this field.
// WaitSemaphoreCount is updated with the length of the new value.
func (x SubmitInfo) WithPWaitSemaphores(y []Semaphore) SubmitInfo {
	x.pWaitSemaphores = *(func(x *[]Semaphore) **C.VkSemaphore { /* Slice */ if len(*x) > 0 { slc := (*C.VkSemaphore)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkSemaphore)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithWaitSemaphoreCount(uint32(len(y)))
}

// PWaitDstStageMask returns the value of pWaitDstStageMask from VkSubmitInfo
func (x SubmitInfo) PWaitDstStageMask() []PipelineStageFlags {
	ptr := func(x **C.VkPipelineStageFlags) *[]PipelineStageFlags { /* Slice */ slc := unsafe.Slice((*PipelineStageFlags)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pWaitDstStageMask) 
	return *ptr
}

// WithPWaitDstStageMask sets the value for the PWaitDstStageMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines WaitSemaphoreCount as the length of this field.
// WaitSemaphoreCount is updated with the length of the new value.
func (x SubmitInfo) WithPWaitDstStageMask(y []PipelineStageFlags) SubmitInfo {
	x.pWaitDstStageMask = *(func(x *[]PipelineStageFlags) **C.VkPipelineStageFlags { /* Slice */ if len(*x) > 0 { slc := (*C.VkPipelineStageFlags)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkPipelineStageFlags)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithWaitSemaphoreCount(uint32(len(y)))
}

// CommandBufferCount returns the value of commandBufferCount from VkSubmitInfo
func (x SubmitInfo) CommandBufferCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.commandBufferCount) 
	return *ptr
}

// WithCommandBufferCount sets the value for the CommandBufferCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubmitInfo) WithCommandBufferCount(y uint32) SubmitInfo {
	x.commandBufferCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PCommandBuffers returns the value of pCommandBuffers from VkSubmitInfo
func (x SubmitInfo) PCommandBuffers() []CommandBuffer {
	ptr := func(x **C.VkCommandBuffer) *[]CommandBuffer { /* Slice */ slc := unsafe.Slice((*CommandBuffer)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pCommandBuffers) 
	return *ptr
}

// WithPCommandBuffers sets the value for the PCommandBuffers on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines CommandBufferCount as the length of this field.
// CommandBufferCount is updated with the length of the new value.
func (x SubmitInfo) WithPCommandBuffers(y []CommandBuffer) SubmitInfo {
	x.pCommandBuffers = *(func(x *[]CommandBuffer) **C.VkCommandBuffer { /* Slice */ if len(*x) > 0 { slc := (*C.VkCommandBuffer)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkCommandBuffer)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithCommandBufferCount(uint32(len(y)))
}

// SignalSemaphoreCount returns the value of signalSemaphoreCount from VkSubmitInfo
func (x SubmitInfo) SignalSemaphoreCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.signalSemaphoreCount) 
	return *ptr
}

// WithSignalSemaphoreCount sets the value for the SignalSemaphoreCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubmitInfo) WithSignalSemaphoreCount(y uint32) SubmitInfo {
	x.signalSemaphoreCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PSignalSemaphores returns the value of pSignalSemaphores from VkSubmitInfo
func (x SubmitInfo) PSignalSemaphores() []Semaphore {
	ptr := func(x **C.VkSemaphore) *[]Semaphore { /* Slice */ slc := unsafe.Slice((*Semaphore)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pSignalSemaphores) 
	return *ptr
}

// WithPSignalSemaphores sets the value for the PSignalSemaphores on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines SignalSemaphoreCount as the length of this field.
// SignalSemaphoreCount is updated with the length of the new value.
func (x SubmitInfo) WithPSignalSemaphores(y []Semaphore) SubmitInfo {
	x.pSignalSemaphores = *(func(x *[]Semaphore) **C.VkSemaphore { /* Slice */ if len(*x) > 0 { slc := (*C.VkSemaphore)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkSemaphore)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithSignalSemaphoreCount(uint32(len(y)))
}

// GraphicsPipelineCreateInfo provides a go interface for VkGraphicsPipelineCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkGraphicsPipelineCreateInfo.html
type GraphicsPipelineCreateInfo C.struct_VkGraphicsPipelineCreateInfo

// SizeofGraphicsPipelineCreateInfo is the memory size of a GraphicsPipelineCreateInfo
var SizeofGraphicsPipelineCreateInfo int = int(unsafe.Sizeof(GraphicsPipelineCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *GraphicsPipelineCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x GraphicsPipelineCreateInfo) AsCPtr() *GraphicsPipelineCreateInfo {
	clone := (*GraphicsPipelineCreateInfo)(newCBlock(C.ulong(SizeofGraphicsPipelineCreateInfo)))
	*clone = x
	return clone
}

// GraphicsPipelineCreateInfoFreeCSlice releases the memory allocated by GraphicsPipelineCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func GraphicsPipelineCreateInfoFreeCSlice(x []GraphicsPipelineCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// GraphicsPipelineCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. GraphicsPipelineCreateInfoFreeCSlice must be called on the returned slice.
func GraphicsPipelineCreateInfoMakeCSlice(x ...GraphicsPipelineCreateInfo) []GraphicsPipelineCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofGraphicsPipelineCreateInfo * len(x)
	dst := unsafe.Slice((*GraphicsPipelineCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x GraphicsPipelineCreateInfo) WithDefaultSType() GraphicsPipelineCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithSType(y StructureType) GraphicsPipelineCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPNext(y unsafe.Pointer) GraphicsPipelineCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) Flags() PipelineCreateFlags {
	ptr := /* typedef */ (*PipelineCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithFlags(y PipelineCreateFlags) GraphicsPipelineCreateInfo {
	x.flags = *(/* typedef */ (*C.VkPipelineCreateFlags)(&y))
	return x
}

// StageCount returns the value of stageCount from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) StageCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.stageCount) 
	return *ptr
}

// WithStageCount sets the value for the StageCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithStageCount(y uint32) GraphicsPipelineCreateInfo {
	x.stageCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PStages returns the value of pStages from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PStages() []PipelineShaderStageCreateInfo {
	ptr := func(x **C.struct_VkPipelineShaderStageCreateInfo) *[]PipelineShaderStageCreateInfo { /* Slice */ slc := unsafe.Slice((*PipelineShaderStageCreateInfo)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pStages) 
	return *ptr
}

// WithPStages sets the value for the PStages on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines StageCount as the length of this field.
// StageCount is updated with the length of the new value.
func (x GraphicsPipelineCreateInfo) WithPStages(y []PipelineShaderStageCreateInfo) GraphicsPipelineCreateInfo {
	x.pStages = *(func(x *[]PipelineShaderStageCreateInfo) **C.struct_VkPipelineShaderStageCreateInfo { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkPipelineShaderStageCreateInfo)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkPipelineShaderStageCreateInfo)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithStageCount(uint32(len(y)))
}

// PVertexInputState returns the value of pVertexInputState from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PVertexInputState() *PipelineVertexInputStateCreateInfo {
	ptr := func(x **C.struct_VkPipelineVertexInputStateCreateInfo) **PipelineVertexInputStateCreateInfo { /* Pointer */ c2g := (*PipelineVertexInputStateCreateInfo)(*x); return &c2g }(&x.pVertexInputState) 
	return *ptr
}

// WithPVertexInputState sets the value for the PVertexInputState on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPVertexInputState(y *PipelineVertexInputStateCreateInfo) GraphicsPipelineCreateInfo {
	x.pVertexInputState = *(func(x **PipelineVertexInputStateCreateInfo) **C.struct_VkPipelineVertexInputStateCreateInfo { /* Pointer */ g2c := (*C.struct_VkPipelineVertexInputStateCreateInfo)(*x); return &g2c }(&y))
	return x
}

// PInputAssemblyState returns the value of pInputAssemblyState from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PInputAssemblyState() *PipelineInputAssemblyStateCreateInfo {
	ptr := func(x **C.struct_VkPipelineInputAssemblyStateCreateInfo) **PipelineInputAssemblyStateCreateInfo { /* Pointer */ c2g := (*PipelineInputAssemblyStateCreateInfo)(*x); return &c2g }(&x.pInputAssemblyState) 
	return *ptr
}

// WithPInputAssemblyState sets the value for the PInputAssemblyState on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPInputAssemblyState(y *PipelineInputAssemblyStateCreateInfo) GraphicsPipelineCreateInfo {
	x.pInputAssemblyState = *(func(x **PipelineInputAssemblyStateCreateInfo) **C.struct_VkPipelineInputAssemblyStateCreateInfo { /* Pointer */ g2c := (*C.struct_VkPipelineInputAssemblyStateCreateInfo)(*x); return &g2c }(&y))
	return x
}

// PTessellationState returns the value of pTessellationState from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PTessellationState() *PipelineTessellationStateCreateInfo {
	ptr := func(x **C.struct_VkPipelineTessellationStateCreateInfo) **PipelineTessellationStateCreateInfo { /* Pointer */ c2g := (*PipelineTessellationStateCreateInfo)(*x); return &c2g }(&x.pTessellationState) 
	return *ptr
}

// WithPTessellationState sets the value for the PTessellationState on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPTessellationState(y *PipelineTessellationStateCreateInfo) GraphicsPipelineCreateInfo {
	x.pTessellationState = *(func(x **PipelineTessellationStateCreateInfo) **C.struct_VkPipelineTessellationStateCreateInfo { /* Pointer */ g2c := (*C.struct_VkPipelineTessellationStateCreateInfo)(*x); return &g2c }(&y))
	return x
}

// PViewportState returns the value of pViewportState from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PViewportState() *PipelineViewportStateCreateInfo {
	ptr := func(x **C.struct_VkPipelineViewportStateCreateInfo) **PipelineViewportStateCreateInfo { /* Pointer */ c2g := (*PipelineViewportStateCreateInfo)(*x); return &c2g }(&x.pViewportState) 
	return *ptr
}

// WithPViewportState sets the value for the PViewportState on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPViewportState(y *PipelineViewportStateCreateInfo) GraphicsPipelineCreateInfo {
	x.pViewportState = *(func(x **PipelineViewportStateCreateInfo) **C.struct_VkPipelineViewportStateCreateInfo { /* Pointer */ g2c := (*C.struct_VkPipelineViewportStateCreateInfo)(*x); return &g2c }(&y))
	return x
}

// PRasterizationState returns the value of pRasterizationState from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PRasterizationState() *PipelineRasterizationStateCreateInfo {
	ptr := func(x **C.struct_VkPipelineRasterizationStateCreateInfo) **PipelineRasterizationStateCreateInfo { /* Pointer */ c2g := (*PipelineRasterizationStateCreateInfo)(*x); return &c2g }(&x.pRasterizationState) 
	return *ptr
}

// WithPRasterizationState sets the value for the PRasterizationState on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPRasterizationState(y *PipelineRasterizationStateCreateInfo) GraphicsPipelineCreateInfo {
	x.pRasterizationState = *(func(x **PipelineRasterizationStateCreateInfo) **C.struct_VkPipelineRasterizationStateCreateInfo { /* Pointer */ g2c := (*C.struct_VkPipelineRasterizationStateCreateInfo)(*x); return &g2c }(&y))
	return x
}

// PMultisampleState returns the value of pMultisampleState from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PMultisampleState() *PipelineMultisampleStateCreateInfo {
	ptr := func(x **C.struct_VkPipelineMultisampleStateCreateInfo) **PipelineMultisampleStateCreateInfo { /* Pointer */ c2g := (*PipelineMultisampleStateCreateInfo)(*x); return &c2g }(&x.pMultisampleState) 
	return *ptr
}

// WithPMultisampleState sets the value for the PMultisampleState on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPMultisampleState(y *PipelineMultisampleStateCreateInfo) GraphicsPipelineCreateInfo {
	x.pMultisampleState = *(func(x **PipelineMultisampleStateCreateInfo) **C.struct_VkPipelineMultisampleStateCreateInfo { /* Pointer */ g2c := (*C.struct_VkPipelineMultisampleStateCreateInfo)(*x); return &g2c }(&y))
	return x
}

// PDepthStencilState returns the value of pDepthStencilState from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PDepthStencilState() *PipelineDepthStencilStateCreateInfo {
	ptr := func(x **C.struct_VkPipelineDepthStencilStateCreateInfo) **PipelineDepthStencilStateCreateInfo { /* Pointer */ c2g := (*PipelineDepthStencilStateCreateInfo)(*x); return &c2g }(&x.pDepthStencilState) 
	return *ptr
}

// WithPDepthStencilState sets the value for the PDepthStencilState on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPDepthStencilState(y *PipelineDepthStencilStateCreateInfo) GraphicsPipelineCreateInfo {
	x.pDepthStencilState = *(func(x **PipelineDepthStencilStateCreateInfo) **C.struct_VkPipelineDepthStencilStateCreateInfo { /* Pointer */ g2c := (*C.struct_VkPipelineDepthStencilStateCreateInfo)(*x); return &g2c }(&y))
	return x
}

// PColorBlendState returns the value of pColorBlendState from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PColorBlendState() *PipelineColorBlendStateCreateInfo {
	ptr := func(x **C.struct_VkPipelineColorBlendStateCreateInfo) **PipelineColorBlendStateCreateInfo { /* Pointer */ c2g := (*PipelineColorBlendStateCreateInfo)(*x); return &c2g }(&x.pColorBlendState) 
	return *ptr
}

// WithPColorBlendState sets the value for the PColorBlendState on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPColorBlendState(y *PipelineColorBlendStateCreateInfo) GraphicsPipelineCreateInfo {
	x.pColorBlendState = *(func(x **PipelineColorBlendStateCreateInfo) **C.struct_VkPipelineColorBlendStateCreateInfo { /* Pointer */ g2c := (*C.struct_VkPipelineColorBlendStateCreateInfo)(*x); return &g2c }(&y))
	return x
}

// PDynamicState returns the value of pDynamicState from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) PDynamicState() *PipelineDynamicStateCreateInfo {
	ptr := func(x **C.struct_VkPipelineDynamicStateCreateInfo) **PipelineDynamicStateCreateInfo { /* Pointer */ c2g := (*PipelineDynamicStateCreateInfo)(*x); return &c2g }(&x.pDynamicState) 
	return *ptr
}

// WithPDynamicState sets the value for the PDynamicState on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithPDynamicState(y *PipelineDynamicStateCreateInfo) GraphicsPipelineCreateInfo {
	x.pDynamicState = *(func(x **PipelineDynamicStateCreateInfo) **C.struct_VkPipelineDynamicStateCreateInfo { /* Pointer */ g2c := (*C.struct_VkPipelineDynamicStateCreateInfo)(*x); return &g2c }(&y))
	return x
}

// Layout returns the value of layout from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) Layout() PipelineLayout {
	ptr := /* handle */ (*PipelineLayout)(&x.layout) 
	return *ptr
}

// WithLayout sets the value for the Layout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithLayout(y PipelineLayout) GraphicsPipelineCreateInfo {
	x.layout = *(/* handle */ (*C.VkPipelineLayout)(&y))
	return x
}

// RenderPass returns the value of renderPass from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) RenderPass() RenderPass {
	ptr := /* handle */ (*RenderPass)(&x.renderPass) 
	return *ptr
}

// WithRenderPass sets the value for the RenderPass on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithRenderPass(y RenderPass) GraphicsPipelineCreateInfo {
	x.renderPass = *(/* handle */ (*C.VkRenderPass)(&y))
	return x
}

// Subpass returns the value of subpass from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) Subpass() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.subpass) 
	return *ptr
}

// WithSubpass sets the value for the Subpass on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithSubpass(y uint32) GraphicsPipelineCreateInfo {
	x.subpass = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// BasePipelineHandle returns the value of basePipelineHandle from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) BasePipelineHandle() Pipeline {
	ptr := /* handle */ (*Pipeline)(&x.basePipelineHandle) 
	return *ptr
}

// WithBasePipelineHandle sets the value for the BasePipelineHandle on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithBasePipelineHandle(y Pipeline) GraphicsPipelineCreateInfo {
	x.basePipelineHandle = *(/* handle */ (*C.VkPipeline)(&y))
	return x
}

// BasePipelineIndex returns the value of basePipelineIndex from VkGraphicsPipelineCreateInfo
func (x GraphicsPipelineCreateInfo) BasePipelineIndex() int32 {
	ptr := func(x *C.int32_t) *int32 { /* Scalar */ c2g := int32(*x); return &c2g }(&x.basePipelineIndex) 
	return *ptr
}

// WithBasePipelineIndex sets the value for the BasePipelineIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x GraphicsPipelineCreateInfo) WithBasePipelineIndex(y int32) GraphicsPipelineCreateInfo {
	x.basePipelineIndex = *(func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&y))
	return x
}

// DrawIndirectCommand provides a go interface for VkDrawIndirectCommand.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDrawIndirectCommand.html
type DrawIndirectCommand C.struct_VkDrawIndirectCommand

// SizeofDrawIndirectCommand is the memory size of a DrawIndirectCommand
var SizeofDrawIndirectCommand int = int(unsafe.Sizeof(DrawIndirectCommand{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DrawIndirectCommand) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DrawIndirectCommand) AsCPtr() *DrawIndirectCommand {
	clone := (*DrawIndirectCommand)(newCBlock(C.ulong(SizeofDrawIndirectCommand)))
	*clone = x
	return clone
}

// DrawIndirectCommandFreeCSlice releases the memory allocated by DrawIndirectCommandMakeCSlice.
// It does not free pointers stored inside the slice.
func DrawIndirectCommandFreeCSlice(x []DrawIndirectCommand) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DrawIndirectCommandMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DrawIndirectCommandFreeCSlice must be called on the returned slice.
func DrawIndirectCommandMakeCSlice(x ...DrawIndirectCommand) []DrawIndirectCommand {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDrawIndirectCommand * len(x)
	dst := unsafe.Slice((*DrawIndirectCommand)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// VertexCount returns the value of vertexCount from VkDrawIndirectCommand
func (x DrawIndirectCommand) VertexCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.vertexCount) 
	return *ptr
}

// WithVertexCount sets the value for the VertexCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DrawIndirectCommand) WithVertexCount(y uint32) DrawIndirectCommand {
	x.vertexCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// InstanceCount returns the value of instanceCount from VkDrawIndirectCommand
func (x DrawIndirectCommand) InstanceCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.instanceCount) 
	return *ptr
}

// WithInstanceCount sets the value for the InstanceCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DrawIndirectCommand) WithInstanceCount(y uint32) DrawIndirectCommand {
	x.instanceCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// FirstVertex returns the value of firstVertex from VkDrawIndirectCommand
func (x DrawIndirectCommand) FirstVertex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.firstVertex) 
	return *ptr
}

// WithFirstVertex sets the value for the FirstVertex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DrawIndirectCommand) WithFirstVertex(y uint32) DrawIndirectCommand {
	x.firstVertex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// FirstInstance returns the value of firstInstance from VkDrawIndirectCommand
func (x DrawIndirectCommand) FirstInstance() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.firstInstance) 
	return *ptr
}

// WithFirstInstance sets the value for the FirstInstance on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DrawIndirectCommand) WithFirstInstance(y uint32) DrawIndirectCommand {
	x.firstInstance = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// ImageMemoryBarrier provides a go interface for VkImageMemoryBarrier.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageMemoryBarrier.html
type ImageMemoryBarrier C.struct_VkImageMemoryBarrier

// SizeofImageMemoryBarrier is the memory size of a ImageMemoryBarrier
var SizeofImageMemoryBarrier int = int(unsafe.Sizeof(ImageMemoryBarrier{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageMemoryBarrier) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageMemoryBarrier) AsCPtr() *ImageMemoryBarrier {
	clone := (*ImageMemoryBarrier)(newCBlock(C.ulong(SizeofImageMemoryBarrier)))
	*clone = x
	return clone
}

// ImageMemoryBarrierFreeCSlice releases the memory allocated by ImageMemoryBarrierMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageMemoryBarrierFreeCSlice(x []ImageMemoryBarrier) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageMemoryBarrierMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageMemoryBarrierFreeCSlice must be called on the returned slice.
func ImageMemoryBarrierMakeCSlice(x ...ImageMemoryBarrier) []ImageMemoryBarrier {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageMemoryBarrier * len(x)
	dst := unsafe.Slice((*ImageMemoryBarrier)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageMemoryBarrier
func (x ImageMemoryBarrier) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ImageMemoryBarrier) WithDefaultSType() ImageMemoryBarrier {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithSType(y StructureType) ImageMemoryBarrier {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkImageMemoryBarrier
func (x ImageMemoryBarrier) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithPNext(y unsafe.Pointer) ImageMemoryBarrier {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SrcAccessMask returns the value of srcAccessMask from VkImageMemoryBarrier
func (x ImageMemoryBarrier) SrcAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.srcAccessMask) 
	return *ptr
}

// WithSrcAccessMask sets the value for the SrcAccessMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithSrcAccessMask(y AccessFlags) ImageMemoryBarrier {
	x.srcAccessMask = *(/* typedef */ (*C.VkAccessFlags)(&y))
	return x
}

// DstAccessMask returns the value of dstAccessMask from VkImageMemoryBarrier
func (x ImageMemoryBarrier) DstAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.dstAccessMask) 
	return *ptr
}

// WithDstAccessMask sets the value for the DstAccessMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithDstAccessMask(y AccessFlags) ImageMemoryBarrier {
	x.dstAccessMask = *(/* typedef */ (*C.VkAccessFlags)(&y))
	return x
}

// OldLayout returns the value of oldLayout from VkImageMemoryBarrier
func (x ImageMemoryBarrier) OldLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.oldLayout) 
	return *ptr
}

// WithOldLayout sets the value for the OldLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithOldLayout(y ImageLayout) ImageMemoryBarrier {
	x.oldLayout = *(/* typedef */ (*C.VkImageLayout)(&y))
	return x
}

// NewLayout returns the value of newLayout from VkImageMemoryBarrier
func (x ImageMemoryBarrier) NewLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.newLayout) 
	return *ptr
}

// WithNewLayout sets the value for the NewLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithNewLayout(y ImageLayout) ImageMemoryBarrier {
	x.newLayout = *(/* typedef */ (*C.VkImageLayout)(&y))
	return x
}

// SrcQueueFamilyIndex returns the value of srcQueueFamilyIndex from VkImageMemoryBarrier
func (x ImageMemoryBarrier) SrcQueueFamilyIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.srcQueueFamilyIndex) 
	return *ptr
}

// WithSrcQueueFamilyIndex sets the value for the SrcQueueFamilyIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithSrcQueueFamilyIndex(y uint32) ImageMemoryBarrier {
	x.srcQueueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// DstQueueFamilyIndex returns the value of dstQueueFamilyIndex from VkImageMemoryBarrier
func (x ImageMemoryBarrier) DstQueueFamilyIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dstQueueFamilyIndex) 
	return *ptr
}

// WithDstQueueFamilyIndex sets the value for the DstQueueFamilyIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithDstQueueFamilyIndex(y uint32) ImageMemoryBarrier {
	x.dstQueueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// Image returns the value of image from VkImageMemoryBarrier
func (x ImageMemoryBarrier) Image() Image {
	ptr := /* handle */ (*Image)(&x.image) 
	return *ptr
}

// WithImage sets the value for the Image on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithImage(y Image) ImageMemoryBarrier {
	x.image = *(/* handle */ (*C.VkImage)(&y))
	return x
}

// SubresourceRange returns the value of subresourceRange from VkImageMemoryBarrier
func (x ImageMemoryBarrier) SubresourceRange() ImageSubresourceRange {
	ptr := /* typedef */ (*ImageSubresourceRange)(&x.subresourceRange) 
	return *ptr
}

// WithSubresourceRange sets the value for the SubresourceRange on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier) WithSubresourceRange(y ImageSubresourceRange) ImageMemoryBarrier {
	x.subresourceRange = *(/* typedef */ (*C.struct_VkImageSubresourceRange)(&y))
	return x
}

// PipelineColorBlendAttachmentState provides a go interface for VkPipelineColorBlendAttachmentState.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineColorBlendAttachmentState.html
type PipelineColorBlendAttachmentState C.struct_VkPipelineColorBlendAttachmentState

// SizeofPipelineColorBlendAttachmentState is the memory size of a PipelineColorBlendAttachmentState
var SizeofPipelineColorBlendAttachmentState int = int(unsafe.Sizeof(PipelineColorBlendAttachmentState{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineColorBlendAttachmentState) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineColorBlendAttachmentState) AsCPtr() *PipelineColorBlendAttachmentState {
	clone := (*PipelineColorBlendAttachmentState)(newCBlock(C.ulong(SizeofPipelineColorBlendAttachmentState)))
	*clone = x
	return clone
}

// PipelineColorBlendAttachmentStateFreeCSlice releases the memory allocated by PipelineColorBlendAttachmentStateMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineColorBlendAttachmentStateFreeCSlice(x []PipelineColorBlendAttachmentState) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineColorBlendAttachmentStateMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineColorBlendAttachmentStateFreeCSlice must be called on the returned slice.
func PipelineColorBlendAttachmentStateMakeCSlice(x ...PipelineColorBlendAttachmentState) []PipelineColorBlendAttachmentState {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineColorBlendAttachmentState * len(x)
	dst := unsafe.Slice((*PipelineColorBlendAttachmentState)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// BlendEnable returns the value of blendEnable from VkPipelineColorBlendAttachmentState
func (x PipelineColorBlendAttachmentState) BlendEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.blendEnable) 
	return *ptr
}

// WithBlendEnable sets the value for the BlendEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendAttachmentState) WithBlendEnable(y Bool32) PipelineColorBlendAttachmentState {
	x.blendEnable = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// SrcColorBlendFactor returns the value of srcColorBlendFactor from VkPipelineColorBlendAttachmentState
func (x PipelineColorBlendAttachmentState) SrcColorBlendFactor() BlendFactor {
	ptr := /* typedef */ (*BlendFactor)(&x.srcColorBlendFactor) 
	return *ptr
}

// WithSrcColorBlendFactor sets the value for the SrcColorBlendFactor on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendAttachmentState) WithSrcColorBlendFactor(y BlendFactor) PipelineColorBlendAttachmentState {
	x.srcColorBlendFactor = *(/* typedef */ (*C.VkBlendFactor)(&y))
	return x
}

// DstColorBlendFactor returns the value of dstColorBlendFactor from VkPipelineColorBlendAttachmentState
func (x PipelineColorBlendAttachmentState) DstColorBlendFactor() BlendFactor {
	ptr := /* typedef */ (*BlendFactor)(&x.dstColorBlendFactor) 
	return *ptr
}

// WithDstColorBlendFactor sets the value for the DstColorBlendFactor on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendAttachmentState) WithDstColorBlendFactor(y BlendFactor) PipelineColorBlendAttachmentState {
	x.dstColorBlendFactor = *(/* typedef */ (*C.VkBlendFactor)(&y))
	return x
}

// ColorBlendOp returns the value of colorBlendOp from VkPipelineColorBlendAttachmentState
func (x PipelineColorBlendAttachmentState) ColorBlendOp() BlendOp {
	ptr := /* typedef */ (*BlendOp)(&x.colorBlendOp) 
	return *ptr
}

// WithColorBlendOp sets the value for the ColorBlendOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendAttachmentState) WithColorBlendOp(y BlendOp) PipelineColorBlendAttachmentState {
	x.colorBlendOp = *(/* typedef */ (*C.VkBlendOp)(&y))
	return x
}

// SrcAlphaBlendFactor returns the value of srcAlphaBlendFactor from VkPipelineColorBlendAttachmentState
func (x PipelineColorBlendAttachmentState) SrcAlphaBlendFactor() BlendFactor {
	ptr := /* typedef */ (*BlendFactor)(&x.srcAlphaBlendFactor) 
	return *ptr
}

// WithSrcAlphaBlendFactor sets the value for the SrcAlphaBlendFactor on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendAttachmentState) WithSrcAlphaBlendFactor(y BlendFactor) PipelineColorBlendAttachmentState {
	x.srcAlphaBlendFactor = *(/* typedef */ (*C.VkBlendFactor)(&y))
	return x
}

// DstAlphaBlendFactor returns the value of dstAlphaBlendFactor from VkPipelineColorBlendAttachmentState
func (x PipelineColorBlendAttachmentState) DstAlphaBlendFactor() BlendFactor {
	ptr := /* typedef */ (*BlendFactor)(&x.dstAlphaBlendFactor) 
	return *ptr
}

// WithDstAlphaBlendFactor sets the value for the DstAlphaBlendFactor on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendAttachmentState) WithDstAlphaBlendFactor(y BlendFactor) PipelineColorBlendAttachmentState {
	x.dstAlphaBlendFactor = *(/* typedef */ (*C.VkBlendFactor)(&y))
	return x
}

// AlphaBlendOp returns the value of alphaBlendOp from VkPipelineColorBlendAttachmentState
func (x PipelineColorBlendAttachmentState) AlphaBlendOp() BlendOp {
	ptr := /* typedef */ (*BlendOp)(&x.alphaBlendOp) 
	return *ptr
}

// WithAlphaBlendOp sets the value for the AlphaBlendOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendAttachmentState) WithAlphaBlendOp(y BlendOp) PipelineColorBlendAttachmentState {
	x.alphaBlendOp = *(/* typedef */ (*C.VkBlendOp)(&y))
	return x
}

// ColorWriteMask returns the value of colorWriteMask from VkPipelineColorBlendAttachmentState
func (x PipelineColorBlendAttachmentState) ColorWriteMask() ColorComponentFlags {
	ptr := /* typedef */ (*ColorComponentFlags)(&x.colorWriteMask) 
	return *ptr
}

// WithColorWriteMask sets the value for the ColorWriteMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendAttachmentState) WithColorWriteMask(y ColorComponentFlags) PipelineColorBlendAttachmentState {
	x.colorWriteMask = *(/* typedef */ (*C.VkColorComponentFlags)(&y))
	return x
}

// MemoryBarrier provides a go interface for VkMemoryBarrier.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryBarrier.html
type MemoryBarrier C.struct_VkMemoryBarrier

// SizeofMemoryBarrier is the memory size of a MemoryBarrier
var SizeofMemoryBarrier int = int(unsafe.Sizeof(MemoryBarrier{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryBarrier) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryBarrier) AsCPtr() *MemoryBarrier {
	clone := (*MemoryBarrier)(newCBlock(C.ulong(SizeofMemoryBarrier)))
	*clone = x
	return clone
}

// MemoryBarrierFreeCSlice releases the memory allocated by MemoryBarrierMakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryBarrierFreeCSlice(x []MemoryBarrier) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryBarrierMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryBarrierFreeCSlice must be called on the returned slice.
func MemoryBarrierMakeCSlice(x ...MemoryBarrier) []MemoryBarrier {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryBarrier * len(x)
	dst := unsafe.Slice((*MemoryBarrier)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkMemoryBarrier
func (x MemoryBarrier) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x MemoryBarrier) WithDefaultSType() MemoryBarrier {
	return x.WithSType(VK_STRUCTURE_TYPE_MEMORY_BARRIER)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryBarrier) WithSType(y StructureType) MemoryBarrier {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkMemoryBarrier
func (x MemoryBarrier) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryBarrier) WithPNext(y unsafe.Pointer) MemoryBarrier {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SrcAccessMask returns the value of srcAccessMask from VkMemoryBarrier
func (x MemoryBarrier) SrcAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.srcAccessMask) 
	return *ptr
}

// WithSrcAccessMask sets the value for the SrcAccessMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryBarrier) WithSrcAccessMask(y AccessFlags) MemoryBarrier {
	x.srcAccessMask = *(/* typedef */ (*C.VkAccessFlags)(&y))
	return x
}

// DstAccessMask returns the value of dstAccessMask from VkMemoryBarrier
func (x MemoryBarrier) DstAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.dstAccessMask) 
	return *ptr
}

// WithDstAccessMask sets the value for the DstAccessMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryBarrier) WithDstAccessMask(y AccessFlags) MemoryBarrier {
	x.dstAccessMask = *(/* typedef */ (*C.VkAccessFlags)(&y))
	return x
}

// PipelineColorBlendStateCreateInfo provides a go interface for VkPipelineColorBlendStateCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineColorBlendStateCreateInfo.html
type PipelineColorBlendStateCreateInfo C.struct_VkPipelineColorBlendStateCreateInfo

// SizeofPipelineColorBlendStateCreateInfo is the memory size of a PipelineColorBlendStateCreateInfo
var SizeofPipelineColorBlendStateCreateInfo int = int(unsafe.Sizeof(PipelineColorBlendStateCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineColorBlendStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineColorBlendStateCreateInfo) AsCPtr() *PipelineColorBlendStateCreateInfo {
	clone := (*PipelineColorBlendStateCreateInfo)(newCBlock(C.ulong(SizeofPipelineColorBlendStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineColorBlendStateCreateInfoFreeCSlice releases the memory allocated by PipelineColorBlendStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineColorBlendStateCreateInfoFreeCSlice(x []PipelineColorBlendStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineColorBlendStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineColorBlendStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineColorBlendStateCreateInfoMakeCSlice(x ...PipelineColorBlendStateCreateInfo) []PipelineColorBlendStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineColorBlendStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineColorBlendStateCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineColorBlendStateCreateInfo
func (x PipelineColorBlendStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineColorBlendStateCreateInfo) WithDefaultSType() PipelineColorBlendStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendStateCreateInfo) WithSType(y StructureType) PipelineColorBlendStateCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPipelineColorBlendStateCreateInfo
func (x PipelineColorBlendStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineColorBlendStateCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkPipelineColorBlendStateCreateInfo
func (x PipelineColorBlendStateCreateInfo) Flags() PipelineColorBlendStateCreateFlags {
	ptr := /* typedef */ (*PipelineColorBlendStateCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendStateCreateInfo) WithFlags(y PipelineColorBlendStateCreateFlags) PipelineColorBlendStateCreateInfo {
	x.flags = *(/* typedef */ (*C.VkPipelineColorBlendStateCreateFlags)(&y))
	return x
}

// LogicOpEnable returns the value of logicOpEnable from VkPipelineColorBlendStateCreateInfo
func (x PipelineColorBlendStateCreateInfo) LogicOpEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.logicOpEnable) 
	return *ptr
}

// WithLogicOpEnable sets the value for the LogicOpEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendStateCreateInfo) WithLogicOpEnable(y Bool32) PipelineColorBlendStateCreateInfo {
	x.logicOpEnable = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// LogicOp returns the value of logicOp from VkPipelineColorBlendStateCreateInfo
func (x PipelineColorBlendStateCreateInfo) LogicOp() LogicOp {
	ptr := /* typedef */ (*LogicOp)(&x.logicOp) 
	return *ptr
}

// WithLogicOp sets the value for the LogicOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendStateCreateInfo) WithLogicOp(y LogicOp) PipelineColorBlendStateCreateInfo {
	x.logicOp = *(/* typedef */ (*C.VkLogicOp)(&y))
	return x
}

// AttachmentCount returns the value of attachmentCount from VkPipelineColorBlendStateCreateInfo
func (x PipelineColorBlendStateCreateInfo) AttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.attachmentCount) 
	return *ptr
}

// WithAttachmentCount sets the value for the AttachmentCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendStateCreateInfo) WithAttachmentCount(y uint32) PipelineColorBlendStateCreateInfo {
	x.attachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PAttachments returns the value of pAttachments from VkPipelineColorBlendStateCreateInfo
func (x PipelineColorBlendStateCreateInfo) PAttachments() []PipelineColorBlendAttachmentState {
	ptr := func(x **C.struct_VkPipelineColorBlendAttachmentState) *[]PipelineColorBlendAttachmentState { /* Slice */ slc := unsafe.Slice((*PipelineColorBlendAttachmentState)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pAttachments) 
	return *ptr
}

// WithPAttachments sets the value for the PAttachments on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines AttachmentCount as the length of this field.
// AttachmentCount is updated with the length of the new value.
func (x PipelineColorBlendStateCreateInfo) WithPAttachments(y []PipelineColorBlendAttachmentState) PipelineColorBlendStateCreateInfo {
	x.pAttachments = *(func(x *[]PipelineColorBlendAttachmentState) **C.struct_VkPipelineColorBlendAttachmentState { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkPipelineColorBlendAttachmentState)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkPipelineColorBlendAttachmentState)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithAttachmentCount(uint32(len(y)))
}

// BlendConstants returns the value of blendConstants from VkPipelineColorBlendStateCreateInfo
func (x PipelineColorBlendStateCreateInfo) BlendConstants() []float32 {
	ptr := func(x *[4]C.float) *[]float32 { /* Array */ slc := unsafe.Slice((*float32)(unsafe.Pointer(x)), 4); return &slc }(&x.blendConstants) 
	return *ptr
}

// WithBlendConstants sets the value for the BlendConstants on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineColorBlendStateCreateInfo) WithBlendConstants(y []float32) PipelineColorBlendStateCreateInfo {
	ptr := func(x *[]float32) **C.float { /* Array */ if len(*x) > 0 { slc := (*C.float)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.float)(unsafe.Pointer((&ptr))) }(&y)
	copy(x.blendConstants[:], unsafe.Slice(*ptr, len(y)))
	return x
}

// AttachmentReference provides a go interface for VkAttachmentReference.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentReference.html
type AttachmentReference C.struct_VkAttachmentReference

// SizeofAttachmentReference is the memory size of a AttachmentReference
var SizeofAttachmentReference int = int(unsafe.Sizeof(AttachmentReference{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *AttachmentReference) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x AttachmentReference) AsCPtr() *AttachmentReference {
	clone := (*AttachmentReference)(newCBlock(C.ulong(SizeofAttachmentReference)))
	*clone = x
	return clone
}

// AttachmentReferenceFreeCSlice releases the memory allocated by AttachmentReferenceMakeCSlice.
// It does not free pointers stored inside the slice.
func AttachmentReferenceFreeCSlice(x []AttachmentReference) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// AttachmentReferenceMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. AttachmentReferenceFreeCSlice must be called on the returned slice.
func AttachmentReferenceMakeCSlice(x ...AttachmentReference) []AttachmentReference {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAttachmentReference * len(x)
	dst := unsafe.Slice((*AttachmentReference)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Attachment returns the value of attachment from VkAttachmentReference
func (x AttachmentReference) Attachment() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.attachment) 
	return *ptr
}

// WithAttachment sets the value for the Attachment on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReference) WithAttachment(y uint32) AttachmentReference {
	x.attachment = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// Layout returns the value of layout from VkAttachmentReference
func (x AttachmentReference) Layout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.layout) 
	return *ptr
}

// WithLayout sets the value for the Layout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReference) WithLayout(y ImageLayout) AttachmentReference {
	x.layout = *(/* typedef */ (*C.VkImageLayout)(&y))
	return x
}

// LayerProperties provides a go interface for VkLayerProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkLayerProperties.html
type LayerProperties C.struct_VkLayerProperties

// SizeofLayerProperties is the memory size of a LayerProperties
var SizeofLayerProperties int = int(unsafe.Sizeof(LayerProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *LayerProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x LayerProperties) AsCPtr() *LayerProperties {
	clone := (*LayerProperties)(newCBlock(C.ulong(SizeofLayerProperties)))
	*clone = x
	return clone
}

// LayerPropertiesFreeCSlice releases the memory allocated by LayerPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func LayerPropertiesFreeCSlice(x []LayerProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// LayerPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. LayerPropertiesFreeCSlice must be called on the returned slice.
func LayerPropertiesMakeCSlice(x ...LayerProperties) []LayerProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofLayerProperties * len(x)
	dst := unsafe.Slice((*LayerProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// LayerName returns the value of layerName from VkLayerProperties
func (x LayerProperties) LayerName() []byte {
	ptr := func(x *[VK_MAX_EXTENSION_NAME_SIZE]C.char) *[]byte { /* Array */ slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_EXTENSION_NAME_SIZE); return &slc }(&x.layerName) 
	return *ptr
}

// SpecVersion returns the value of specVersion from VkLayerProperties
func (x LayerProperties) SpecVersion() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.specVersion) 
	return *ptr
}

// ImplementationVersion returns the value of implementationVersion from VkLayerProperties
func (x LayerProperties) ImplementationVersion() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.implementationVersion) 
	return *ptr
}

// Description returns the value of description from VkLayerProperties
func (x LayerProperties) Description() []byte {
	ptr := func(x *[VK_MAX_DESCRIPTION_SIZE]C.char) *[]byte { /* Array */ slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_DESCRIPTION_SIZE); return &slc }(&x.description) 
	return *ptr
}

// Extent3D provides a go interface for VkExtent3D.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExtent3D.html
type Extent3D C.struct_VkExtent3D

// SizeofExtent3D is the memory size of a Extent3D
var SizeofExtent3D int = int(unsafe.Sizeof(Extent3D{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *Extent3D) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x Extent3D) AsCPtr() *Extent3D {
	clone := (*Extent3D)(newCBlock(C.ulong(SizeofExtent3D)))
	*clone = x
	return clone
}

// Extent3DFreeCSlice releases the memory allocated by Extent3DMakeCSlice.
// It does not free pointers stored inside the slice.
func Extent3DFreeCSlice(x []Extent3D) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// Extent3DMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. Extent3DFreeCSlice must be called on the returned slice.
func Extent3DMakeCSlice(x ...Extent3D) []Extent3D {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExtent3D * len(x)
	dst := unsafe.Slice((*Extent3D)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Width returns the value of width from VkExtent3D
func (x Extent3D) Width() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.width) 
	return *ptr
}

// WithWidth sets the value for the Width on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Extent3D) WithWidth(y uint32) Extent3D {
	x.width = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// Height returns the value of height from VkExtent3D
func (x Extent3D) Height() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.height) 
	return *ptr
}

// WithHeight sets the value for the Height on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Extent3D) WithHeight(y uint32) Extent3D {
	x.height = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// Depth returns the value of depth from VkExtent3D
func (x Extent3D) Depth() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.depth) 
	return *ptr
}

// WithDepth sets the value for the Depth on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Extent3D) WithDepth(y uint32) Extent3D {
	x.depth = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PipelineDepthStencilStateCreateInfo provides a go interface for VkPipelineDepthStencilStateCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineDepthStencilStateCreateInfo.html
type PipelineDepthStencilStateCreateInfo C.struct_VkPipelineDepthStencilStateCreateInfo

// SizeofPipelineDepthStencilStateCreateInfo is the memory size of a PipelineDepthStencilStateCreateInfo
var SizeofPipelineDepthStencilStateCreateInfo int = int(unsafe.Sizeof(PipelineDepthStencilStateCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineDepthStencilStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineDepthStencilStateCreateInfo) AsCPtr() *PipelineDepthStencilStateCreateInfo {
	clone := (*PipelineDepthStencilStateCreateInfo)(newCBlock(C.ulong(SizeofPipelineDepthStencilStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineDepthStencilStateCreateInfoFreeCSlice releases the memory allocated by PipelineDepthStencilStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineDepthStencilStateCreateInfoFreeCSlice(x []PipelineDepthStencilStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineDepthStencilStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineDepthStencilStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineDepthStencilStateCreateInfoMakeCSlice(x ...PipelineDepthStencilStateCreateInfo) []PipelineDepthStencilStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineDepthStencilStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineDepthStencilStateCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineDepthStencilStateCreateInfo) WithDefaultSType() PipelineDepthStencilStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithSType(y StructureType) PipelineDepthStencilStateCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineDepthStencilStateCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) Flags() PipelineDepthStencilStateCreateFlags {
	ptr := /* typedef */ (*PipelineDepthStencilStateCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithFlags(y PipelineDepthStencilStateCreateFlags) PipelineDepthStencilStateCreateInfo {
	x.flags = *(/* typedef */ (*C.VkPipelineDepthStencilStateCreateFlags)(&y))
	return x
}

// DepthTestEnable returns the value of depthTestEnable from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) DepthTestEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.depthTestEnable) 
	return *ptr
}

// WithDepthTestEnable sets the value for the DepthTestEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithDepthTestEnable(y Bool32) PipelineDepthStencilStateCreateInfo {
	x.depthTestEnable = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DepthWriteEnable returns the value of depthWriteEnable from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) DepthWriteEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.depthWriteEnable) 
	return *ptr
}

// WithDepthWriteEnable sets the value for the DepthWriteEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithDepthWriteEnable(y Bool32) PipelineDepthStencilStateCreateInfo {
	x.depthWriteEnable = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DepthCompareOp returns the value of depthCompareOp from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) DepthCompareOp() CompareOp {
	ptr := /* typedef */ (*CompareOp)(&x.depthCompareOp) 
	return *ptr
}

// WithDepthCompareOp sets the value for the DepthCompareOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithDepthCompareOp(y CompareOp) PipelineDepthStencilStateCreateInfo {
	x.depthCompareOp = *(/* typedef */ (*C.VkCompareOp)(&y))
	return x
}

// DepthBoundsTestEnable returns the value of depthBoundsTestEnable from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) DepthBoundsTestEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.depthBoundsTestEnable) 
	return *ptr
}

// WithDepthBoundsTestEnable sets the value for the DepthBoundsTestEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithDepthBoundsTestEnable(y Bool32) PipelineDepthStencilStateCreateInfo {
	x.depthBoundsTestEnable = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// StencilTestEnable returns the value of stencilTestEnable from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) StencilTestEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.stencilTestEnable) 
	return *ptr
}

// WithStencilTestEnable sets the value for the StencilTestEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithStencilTestEnable(y Bool32) PipelineDepthStencilStateCreateInfo {
	x.stencilTestEnable = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// Front returns the value of front from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) Front() StencilOpState {
	ptr := /* typedef */ (*StencilOpState)(&x.front) 
	return *ptr
}

// WithFront sets the value for the Front on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithFront(y StencilOpState) PipelineDepthStencilStateCreateInfo {
	x.front = *(/* typedef */ (*C.struct_VkStencilOpState)(&y))
	return x
}

// Back returns the value of back from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) Back() StencilOpState {
	ptr := /* typedef */ (*StencilOpState)(&x.back) 
	return *ptr
}

// WithBack sets the value for the Back on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithBack(y StencilOpState) PipelineDepthStencilStateCreateInfo {
	x.back = *(/* typedef */ (*C.struct_VkStencilOpState)(&y))
	return x
}

// MinDepthBounds returns the value of minDepthBounds from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) MinDepthBounds() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.minDepthBounds) 
	return *ptr
}

// WithMinDepthBounds sets the value for the MinDepthBounds on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithMinDepthBounds(y float32) PipelineDepthStencilStateCreateInfo {
	x.minDepthBounds = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}

// MaxDepthBounds returns the value of maxDepthBounds from VkPipelineDepthStencilStateCreateInfo
func (x PipelineDepthStencilStateCreateInfo) MaxDepthBounds() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.maxDepthBounds) 
	return *ptr
}

// WithMaxDepthBounds sets the value for the MaxDepthBounds on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDepthStencilStateCreateInfo) WithMaxDepthBounds(y float32) PipelineDepthStencilStateCreateInfo {
	x.maxDepthBounds = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}

// WriteDescriptorSet provides a go interface for VkWriteDescriptorSet.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWriteDescriptorSet.html
type WriteDescriptorSet C.struct_VkWriteDescriptorSet

// SizeofWriteDescriptorSet is the memory size of a WriteDescriptorSet
var SizeofWriteDescriptorSet int = int(unsafe.Sizeof(WriteDescriptorSet{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *WriteDescriptorSet) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x WriteDescriptorSet) AsCPtr() *WriteDescriptorSet {
	clone := (*WriteDescriptorSet)(newCBlock(C.ulong(SizeofWriteDescriptorSet)))
	*clone = x
	return clone
}

// WriteDescriptorSetFreeCSlice releases the memory allocated by WriteDescriptorSetMakeCSlice.
// It does not free pointers stored inside the slice.
func WriteDescriptorSetFreeCSlice(x []WriteDescriptorSet) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// WriteDescriptorSetMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. WriteDescriptorSetFreeCSlice must be called on the returned slice.
func WriteDescriptorSetMakeCSlice(x ...WriteDescriptorSet) []WriteDescriptorSet {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofWriteDescriptorSet * len(x)
	dst := unsafe.Slice((*WriteDescriptorSet)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkWriteDescriptorSet
func (x WriteDescriptorSet) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x WriteDescriptorSet) WithDefaultSType() WriteDescriptorSet {
	return x.WithSType(VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSet) WithSType(y StructureType) WriteDescriptorSet {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkWriteDescriptorSet
func (x WriteDescriptorSet) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSet) WithPNext(y unsafe.Pointer) WriteDescriptorSet {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// DstSet returns the value of dstSet from VkWriteDescriptorSet
func (x WriteDescriptorSet) DstSet() DescriptorSet {
	ptr := /* handle */ (*DescriptorSet)(&x.dstSet) 
	return *ptr
}

// WithDstSet sets the value for the DstSet on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSet) WithDstSet(y DescriptorSet) WriteDescriptorSet {
	x.dstSet = *(/* handle */ (*C.VkDescriptorSet)(&y))
	return x
}

// DstBinding returns the value of dstBinding from VkWriteDescriptorSet
func (x WriteDescriptorSet) DstBinding() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dstBinding) 
	return *ptr
}

// WithDstBinding sets the value for the DstBinding on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSet) WithDstBinding(y uint32) WriteDescriptorSet {
	x.dstBinding = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// DstArrayElement returns the value of dstArrayElement from VkWriteDescriptorSet
func (x WriteDescriptorSet) DstArrayElement() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dstArrayElement) 
	return *ptr
}

// WithDstArrayElement sets the value for the DstArrayElement on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSet) WithDstArrayElement(y uint32) WriteDescriptorSet {
	x.dstArrayElement = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// DescriptorCount returns the value of descriptorCount from VkWriteDescriptorSet
func (x WriteDescriptorSet) DescriptorCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.descriptorCount) 
	return *ptr
}

// WithDescriptorCount sets the value for the DescriptorCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSet) WithDescriptorCount(y uint32) WriteDescriptorSet {
	x.descriptorCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// DescriptorType returns the value of descriptorType from VkWriteDescriptorSet
func (x WriteDescriptorSet) DescriptorType() DescriptorType {
	ptr := /* typedef */ (*DescriptorType)(&x.descriptorType) 
	return *ptr
}

// WithDescriptorType sets the value for the DescriptorType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSet) WithDescriptorType(y DescriptorType) WriteDescriptorSet {
	x.descriptorType = *(/* typedef */ (*C.VkDescriptorType)(&y))
	return x
}

// PImageInfo returns the value of pImageInfo from VkWriteDescriptorSet
func (x WriteDescriptorSet) PImageInfo() []DescriptorImageInfo {
	ptr := func(x **C.struct_VkDescriptorImageInfo) *[]DescriptorImageInfo { /* Slice */ slc := unsafe.Slice((*DescriptorImageInfo)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pImageInfo) 
	return *ptr
}

// WithPImageInfo sets the value for the PImageInfo on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines DescriptorCount as the length of this field.
// DescriptorCount is updated with the length of the new value.
func (x WriteDescriptorSet) WithPImageInfo(y []DescriptorImageInfo) WriteDescriptorSet {
	x.pImageInfo = *(func(x *[]DescriptorImageInfo) **C.struct_VkDescriptorImageInfo { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkDescriptorImageInfo)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkDescriptorImageInfo)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithDescriptorCount(uint32(len(y)))
}

// PBufferInfo returns the value of pBufferInfo from VkWriteDescriptorSet
func (x WriteDescriptorSet) PBufferInfo() []DescriptorBufferInfo {
	ptr := func(x **C.struct_VkDescriptorBufferInfo) *[]DescriptorBufferInfo { /* Slice */ slc := unsafe.Slice((*DescriptorBufferInfo)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pBufferInfo) 
	return *ptr
}

// WithPBufferInfo sets the value for the PBufferInfo on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines DescriptorCount as the length of this field.
// DescriptorCount is updated with the length of the new value.
func (x WriteDescriptorSet) WithPBufferInfo(y []DescriptorBufferInfo) WriteDescriptorSet {
	x.pBufferInfo = *(func(x *[]DescriptorBufferInfo) **C.struct_VkDescriptorBufferInfo { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkDescriptorBufferInfo)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkDescriptorBufferInfo)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithDescriptorCount(uint32(len(y)))
}

// PTexelBufferView returns the value of pTexelBufferView from VkWriteDescriptorSet
func (x WriteDescriptorSet) PTexelBufferView() []BufferView {
	ptr := func(x **C.VkBufferView) *[]BufferView { /* Slice */ slc := unsafe.Slice((*BufferView)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pTexelBufferView) 
	return *ptr
}

// WithPTexelBufferView sets the value for the PTexelBufferView on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines DescriptorCount as the length of this field.
// DescriptorCount is updated with the length of the new value.
func (x WriteDescriptorSet) WithPTexelBufferView(y []BufferView) WriteDescriptorSet {
	x.pTexelBufferView = *(func(x *[]BufferView) **C.VkBufferView { /* Slice */ if len(*x) > 0 { slc := (*C.VkBufferView)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkBufferView)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithDescriptorCount(uint32(len(y)))
}

// PipelineDynamicStateCreateInfo provides a go interface for VkPipelineDynamicStateCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineDynamicStateCreateInfo.html
type PipelineDynamicStateCreateInfo C.struct_VkPipelineDynamicStateCreateInfo

// SizeofPipelineDynamicStateCreateInfo is the memory size of a PipelineDynamicStateCreateInfo
var SizeofPipelineDynamicStateCreateInfo int = int(unsafe.Sizeof(PipelineDynamicStateCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineDynamicStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineDynamicStateCreateInfo) AsCPtr() *PipelineDynamicStateCreateInfo {
	clone := (*PipelineDynamicStateCreateInfo)(newCBlock(C.ulong(SizeofPipelineDynamicStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineDynamicStateCreateInfoFreeCSlice releases the memory allocated by PipelineDynamicStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineDynamicStateCreateInfoFreeCSlice(x []PipelineDynamicStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineDynamicStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineDynamicStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineDynamicStateCreateInfoMakeCSlice(x ...PipelineDynamicStateCreateInfo) []PipelineDynamicStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineDynamicStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineDynamicStateCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineDynamicStateCreateInfo
func (x PipelineDynamicStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineDynamicStateCreateInfo) WithDefaultSType() PipelineDynamicStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDynamicStateCreateInfo) WithSType(y StructureType) PipelineDynamicStateCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPipelineDynamicStateCreateInfo
func (x PipelineDynamicStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDynamicStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineDynamicStateCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkPipelineDynamicStateCreateInfo
func (x PipelineDynamicStateCreateInfo) Flags() PipelineDynamicStateCreateFlags {
	ptr := /* typedef */ (*PipelineDynamicStateCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDynamicStateCreateInfo) WithFlags(y PipelineDynamicStateCreateFlags) PipelineDynamicStateCreateInfo {
	x.flags = *(/* typedef */ (*C.VkPipelineDynamicStateCreateFlags)(&y))
	return x
}

// DynamicStateCount returns the value of dynamicStateCount from VkPipelineDynamicStateCreateInfo
func (x PipelineDynamicStateCreateInfo) DynamicStateCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dynamicStateCount) 
	return *ptr
}

// WithDynamicStateCount sets the value for the DynamicStateCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineDynamicStateCreateInfo) WithDynamicStateCount(y uint32) PipelineDynamicStateCreateInfo {
	x.dynamicStateCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PDynamicStates returns the value of pDynamicStates from VkPipelineDynamicStateCreateInfo
func (x PipelineDynamicStateCreateInfo) PDynamicStates() []DynamicState {
	ptr := func(x **C.VkDynamicState) *[]DynamicState { /* Slice */ slc := unsafe.Slice((*DynamicState)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pDynamicStates) 
	return *ptr
}

// WithPDynamicStates sets the value for the PDynamicStates on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines DynamicStateCount as the length of this field.
// DynamicStateCount is updated with the length of the new value.
func (x PipelineDynamicStateCreateInfo) WithPDynamicStates(y []DynamicState) PipelineDynamicStateCreateInfo {
	x.pDynamicStates = *(func(x *[]DynamicState) **C.VkDynamicState { /* Slice */ if len(*x) > 0 { slc := (*C.VkDynamicState)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkDynamicState)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithDynamicStateCount(uint32(len(y)))
}

// ExtensionProperties provides a go interface for VkExtensionProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExtensionProperties.html
type ExtensionProperties C.struct_VkExtensionProperties

// SizeofExtensionProperties is the memory size of a ExtensionProperties
var SizeofExtensionProperties int = int(unsafe.Sizeof(ExtensionProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExtensionProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExtensionProperties) AsCPtr() *ExtensionProperties {
	clone := (*ExtensionProperties)(newCBlock(C.ulong(SizeofExtensionProperties)))
	*clone = x
	return clone
}

// ExtensionPropertiesFreeCSlice releases the memory allocated by ExtensionPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func ExtensionPropertiesFreeCSlice(x []ExtensionProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExtensionPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExtensionPropertiesFreeCSlice must be called on the returned slice.
func ExtensionPropertiesMakeCSlice(x ...ExtensionProperties) []ExtensionProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExtensionProperties * len(x)
	dst := unsafe.Slice((*ExtensionProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// ExtensionName returns the value of extensionName from VkExtensionProperties
func (x ExtensionProperties) ExtensionName() []byte {
	ptr := func(x *[VK_MAX_EXTENSION_NAME_SIZE]C.char) *[]byte { /* Array */ slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_EXTENSION_NAME_SIZE); return &slc }(&x.extensionName) 
	return *ptr
}

// SpecVersion returns the value of specVersion from VkExtensionProperties
func (x ExtensionProperties) SpecVersion() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.specVersion) 
	return *ptr
}

// PipelineInputAssemblyStateCreateInfo provides a go interface for VkPipelineInputAssemblyStateCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineInputAssemblyStateCreateInfo.html
type PipelineInputAssemblyStateCreateInfo C.struct_VkPipelineInputAssemblyStateCreateInfo

// SizeofPipelineInputAssemblyStateCreateInfo is the memory size of a PipelineInputAssemblyStateCreateInfo
var SizeofPipelineInputAssemblyStateCreateInfo int = int(unsafe.Sizeof(PipelineInputAssemblyStateCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineInputAssemblyStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineInputAssemblyStateCreateInfo) AsCPtr() *PipelineInputAssemblyStateCreateInfo {
	clone := (*PipelineInputAssemblyStateCreateInfo)(newCBlock(C.ulong(SizeofPipelineInputAssemblyStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineInputAssemblyStateCreateInfoFreeCSlice releases the memory allocated by PipelineInputAssemblyStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineInputAssemblyStateCreateInfoFreeCSlice(x []PipelineInputAssemblyStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineInputAssemblyStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineInputAssemblyStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineInputAssemblyStateCreateInfoMakeCSlice(x ...PipelineInputAssemblyStateCreateInfo) []PipelineInputAssemblyStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineInputAssemblyStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineInputAssemblyStateCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineInputAssemblyStateCreateInfo
func (x PipelineInputAssemblyStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineInputAssemblyStateCreateInfo) WithDefaultSType() PipelineInputAssemblyStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineInputAssemblyStateCreateInfo) WithSType(y StructureType) PipelineInputAssemblyStateCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPipelineInputAssemblyStateCreateInfo
func (x PipelineInputAssemblyStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineInputAssemblyStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineInputAssemblyStateCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkPipelineInputAssemblyStateCreateInfo
func (x PipelineInputAssemblyStateCreateInfo) Flags() PipelineInputAssemblyStateCreateFlags {
	ptr := /* typedef */ (*PipelineInputAssemblyStateCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineInputAssemblyStateCreateInfo) WithFlags(y PipelineInputAssemblyStateCreateFlags) PipelineInputAssemblyStateCreateInfo {
	x.flags = *(/* typedef */ (*C.VkPipelineInputAssemblyStateCreateFlags)(&y))
	return x
}

// Topology returns the value of topology from VkPipelineInputAssemblyStateCreateInfo
func (x PipelineInputAssemblyStateCreateInfo) Topology() PrimitiveTopology {
	ptr := /* typedef */ (*PrimitiveTopology)(&x.topology) 
	return *ptr
}

// WithTopology sets the value for the Topology on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineInputAssemblyStateCreateInfo) WithTopology(y PrimitiveTopology) PipelineInputAssemblyStateCreateInfo {
	x.topology = *(/* typedef */ (*C.VkPrimitiveTopology)(&y))
	return x
}

// PrimitiveRestartEnable returns the value of primitiveRestartEnable from VkPipelineInputAssemblyStateCreateInfo
func (x PipelineInputAssemblyStateCreateInfo) PrimitiveRestartEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.primitiveRestartEnable) 
	return *ptr
}

// WithPrimitiveRestartEnable sets the value for the PrimitiveRestartEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineInputAssemblyStateCreateInfo) WithPrimitiveRestartEnable(y Bool32) PipelineInputAssemblyStateCreateInfo {
	x.primitiveRestartEnable = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DescriptorSetLayoutCreateInfo provides a go interface for VkDescriptorSetLayoutCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutCreateInfo.html
type DescriptorSetLayoutCreateInfo C.struct_VkDescriptorSetLayoutCreateInfo

// SizeofDescriptorSetLayoutCreateInfo is the memory size of a DescriptorSetLayoutCreateInfo
var SizeofDescriptorSetLayoutCreateInfo int = int(unsafe.Sizeof(DescriptorSetLayoutCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorSetLayoutCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorSetLayoutCreateInfo) AsCPtr() *DescriptorSetLayoutCreateInfo {
	clone := (*DescriptorSetLayoutCreateInfo)(newCBlock(C.ulong(SizeofDescriptorSetLayoutCreateInfo)))
	*clone = x
	return clone
}

// DescriptorSetLayoutCreateInfoFreeCSlice releases the memory allocated by DescriptorSetLayoutCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorSetLayoutCreateInfoFreeCSlice(x []DescriptorSetLayoutCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorSetLayoutCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorSetLayoutCreateInfoFreeCSlice must be called on the returned slice.
func DescriptorSetLayoutCreateInfoMakeCSlice(x ...DescriptorSetLayoutCreateInfo) []DescriptorSetLayoutCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetLayoutCreateInfo * len(x)
	dst := unsafe.Slice((*DescriptorSetLayoutCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDescriptorSetLayoutCreateInfo
func (x DescriptorSetLayoutCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DescriptorSetLayoutCreateInfo) WithDefaultSType() DescriptorSetLayoutCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutCreateInfo) WithSType(y StructureType) DescriptorSetLayoutCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDescriptorSetLayoutCreateInfo
func (x DescriptorSetLayoutCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutCreateInfo) WithPNext(y unsafe.Pointer) DescriptorSetLayoutCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkDescriptorSetLayoutCreateInfo
func (x DescriptorSetLayoutCreateInfo) Flags() DescriptorSetLayoutCreateFlags {
	ptr := /* typedef */ (*DescriptorSetLayoutCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutCreateInfo) WithFlags(y DescriptorSetLayoutCreateFlags) DescriptorSetLayoutCreateInfo {
	x.flags = *(/* typedef */ (*C.VkDescriptorSetLayoutCreateFlags)(&y))
	return x
}

// BindingCount returns the value of bindingCount from VkDescriptorSetLayoutCreateInfo
func (x DescriptorSetLayoutCreateInfo) BindingCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.bindingCount) 
	return *ptr
}

// WithBindingCount sets the value for the BindingCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutCreateInfo) WithBindingCount(y uint32) DescriptorSetLayoutCreateInfo {
	x.bindingCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PBindings returns the value of pBindings from VkDescriptorSetLayoutCreateInfo
func (x DescriptorSetLayoutCreateInfo) PBindings() []DescriptorSetLayoutBinding {
	ptr := func(x **C.struct_VkDescriptorSetLayoutBinding) *[]DescriptorSetLayoutBinding { /* Slice */ slc := unsafe.Slice((*DescriptorSetLayoutBinding)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pBindings) 
	return *ptr
}

// WithPBindings sets the value for the PBindings on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines BindingCount as the length of this field.
// BindingCount is updated with the length of the new value.
func (x DescriptorSetLayoutCreateInfo) WithPBindings(y []DescriptorSetLayoutBinding) DescriptorSetLayoutCreateInfo {
	x.pBindings = *(func(x *[]DescriptorSetLayoutBinding) **C.struct_VkDescriptorSetLayoutBinding { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkDescriptorSetLayoutBinding)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkDescriptorSetLayoutBinding)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithBindingCount(uint32(len(y)))
}

// DescriptorSetLayoutBinding provides a go interface for VkDescriptorSetLayoutBinding.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutBinding.html
type DescriptorSetLayoutBinding C.struct_VkDescriptorSetLayoutBinding

// SizeofDescriptorSetLayoutBinding is the memory size of a DescriptorSetLayoutBinding
var SizeofDescriptorSetLayoutBinding int = int(unsafe.Sizeof(DescriptorSetLayoutBinding{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorSetLayoutBinding) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorSetLayoutBinding) AsCPtr() *DescriptorSetLayoutBinding {
	clone := (*DescriptorSetLayoutBinding)(newCBlock(C.ulong(SizeofDescriptorSetLayoutBinding)))
	*clone = x
	return clone
}

// DescriptorSetLayoutBindingFreeCSlice releases the memory allocated by DescriptorSetLayoutBindingMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorSetLayoutBindingFreeCSlice(x []DescriptorSetLayoutBinding) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorSetLayoutBindingMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorSetLayoutBindingFreeCSlice must be called on the returned slice.
func DescriptorSetLayoutBindingMakeCSlice(x ...DescriptorSetLayoutBinding) []DescriptorSetLayoutBinding {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetLayoutBinding * len(x)
	dst := unsafe.Slice((*DescriptorSetLayoutBinding)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Binding returns the value of binding from VkDescriptorSetLayoutBinding
func (x DescriptorSetLayoutBinding) Binding() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.binding) 
	return *ptr
}

// WithBinding sets the value for the Binding on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutBinding) WithBinding(y uint32) DescriptorSetLayoutBinding {
	x.binding = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// DescriptorType returns the value of descriptorType from VkDescriptorSetLayoutBinding
func (x DescriptorSetLayoutBinding) DescriptorType() DescriptorType {
	ptr := /* typedef */ (*DescriptorType)(&x.descriptorType) 
	return *ptr
}

// WithDescriptorType sets the value for the DescriptorType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutBinding) WithDescriptorType(y DescriptorType) DescriptorSetLayoutBinding {
	x.descriptorType = *(/* typedef */ (*C.VkDescriptorType)(&y))
	return x
}

// DescriptorCount returns the value of descriptorCount from VkDescriptorSetLayoutBinding
func (x DescriptorSetLayoutBinding) DescriptorCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.descriptorCount) 
	return *ptr
}

// WithDescriptorCount sets the value for the DescriptorCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutBinding) WithDescriptorCount(y uint32) DescriptorSetLayoutBinding {
	x.descriptorCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// StageFlags returns the value of stageFlags from VkDescriptorSetLayoutBinding
func (x DescriptorSetLayoutBinding) StageFlags() ShaderStageFlags {
	ptr := /* typedef */ (*ShaderStageFlags)(&x.stageFlags) 
	return *ptr
}

// WithStageFlags sets the value for the StageFlags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutBinding) WithStageFlags(y ShaderStageFlags) DescriptorSetLayoutBinding {
	x.stageFlags = *(/* typedef */ (*C.VkShaderStageFlags)(&y))
	return x
}

// PImmutableSamplers returns the value of pImmutableSamplers from VkDescriptorSetLayoutBinding
func (x DescriptorSetLayoutBinding) PImmutableSamplers() []Sampler {
	ptr := func(x **C.VkSampler) *[]Sampler { /* Slice */ slc := unsafe.Slice((*Sampler)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pImmutableSamplers) 
	return *ptr
}

// WithPImmutableSamplers sets the value for the PImmutableSamplers on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines DescriptorCount as the length of this field.
// DescriptorCount is updated with the length of the new value.
func (x DescriptorSetLayoutBinding) WithPImmutableSamplers(y []Sampler) DescriptorSetLayoutBinding {
	x.pImmutableSamplers = *(func(x *[]Sampler) **C.VkSampler { /* Slice */ if len(*x) > 0 { slc := (*C.VkSampler)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkSampler)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithDescriptorCount(uint32(len(y)))
}

// PipelineMultisampleStateCreateInfo provides a go interface for VkPipelineMultisampleStateCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineMultisampleStateCreateInfo.html
type PipelineMultisampleStateCreateInfo C.struct_VkPipelineMultisampleStateCreateInfo

// SizeofPipelineMultisampleStateCreateInfo is the memory size of a PipelineMultisampleStateCreateInfo
var SizeofPipelineMultisampleStateCreateInfo int = int(unsafe.Sizeof(PipelineMultisampleStateCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineMultisampleStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineMultisampleStateCreateInfo) AsCPtr() *PipelineMultisampleStateCreateInfo {
	clone := (*PipelineMultisampleStateCreateInfo)(newCBlock(C.ulong(SizeofPipelineMultisampleStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineMultisampleStateCreateInfoFreeCSlice releases the memory allocated by PipelineMultisampleStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineMultisampleStateCreateInfoFreeCSlice(x []PipelineMultisampleStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineMultisampleStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineMultisampleStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineMultisampleStateCreateInfoMakeCSlice(x ...PipelineMultisampleStateCreateInfo) []PipelineMultisampleStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineMultisampleStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineMultisampleStateCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineMultisampleStateCreateInfo
func (x PipelineMultisampleStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineMultisampleStateCreateInfo) WithDefaultSType() PipelineMultisampleStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineMultisampleStateCreateInfo) WithSType(y StructureType) PipelineMultisampleStateCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPipelineMultisampleStateCreateInfo
func (x PipelineMultisampleStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineMultisampleStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineMultisampleStateCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkPipelineMultisampleStateCreateInfo
func (x PipelineMultisampleStateCreateInfo) Flags() PipelineMultisampleStateCreateFlags {
	ptr := /* typedef */ (*PipelineMultisampleStateCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineMultisampleStateCreateInfo) WithFlags(y PipelineMultisampleStateCreateFlags) PipelineMultisampleStateCreateInfo {
	x.flags = *(/* typedef */ (*C.VkPipelineMultisampleStateCreateFlags)(&y))
	return x
}

// RasterizationSamples returns the value of rasterizationSamples from VkPipelineMultisampleStateCreateInfo
func (x PipelineMultisampleStateCreateInfo) RasterizationSamples() SampleCountFlagBits {
	ptr := /* typedef */ (*SampleCountFlagBits)(&x.rasterizationSamples) 
	return *ptr
}

// WithRasterizationSamples sets the value for the RasterizationSamples on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineMultisampleStateCreateInfo) WithRasterizationSamples(y SampleCountFlagBits) PipelineMultisampleStateCreateInfo {
	x.rasterizationSamples = *(/* typedef */ (*C.VkSampleCountFlagBits)(&y))
	return x
}

// SampleShadingEnable returns the value of sampleShadingEnable from VkPipelineMultisampleStateCreateInfo
func (x PipelineMultisampleStateCreateInfo) SampleShadingEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sampleShadingEnable) 
	return *ptr
}

// WithSampleShadingEnable sets the value for the SampleShadingEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineMultisampleStateCreateInfo) WithSampleShadingEnable(y Bool32) PipelineMultisampleStateCreateInfo {
	x.sampleShadingEnable = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// MinSampleShading returns the value of minSampleShading from VkPipelineMultisampleStateCreateInfo
func (x PipelineMultisampleStateCreateInfo) MinSampleShading() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.minSampleShading) 
	return *ptr
}

// WithMinSampleShading sets the value for the MinSampleShading on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineMultisampleStateCreateInfo) WithMinSampleShading(y float32) PipelineMultisampleStateCreateInfo {
	x.minSampleShading = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}

// PSampleMask returns the value of pSampleMask from VkPipelineMultisampleStateCreateInfo
func (x PipelineMultisampleStateCreateInfo) PSampleMask() []SampleMask {
	ptr := func(x **C.VkSampleMask) *[]SampleMask { /* Slice */ slc := unsafe.Slice((*SampleMask)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pSampleMask) 
	return *ptr
}

// WithPSampleMask sets the value for the PSampleMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineMultisampleStateCreateInfo) WithPSampleMask(y []SampleMask) PipelineMultisampleStateCreateInfo {
	x.pSampleMask = *(func(x *[]SampleMask) **C.VkSampleMask { /* Slice */ if len(*x) > 0 { slc := (*C.VkSampleMask)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkSampleMask)(unsafe.Pointer((&ptr))) }(&y))
	return x
}

// AlphaToCoverageEnable returns the value of alphaToCoverageEnable from VkPipelineMultisampleStateCreateInfo
func (x PipelineMultisampleStateCreateInfo) AlphaToCoverageEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.alphaToCoverageEnable) 
	return *ptr
}

// WithAlphaToCoverageEnable sets the value for the AlphaToCoverageEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineMultisampleStateCreateInfo) WithAlphaToCoverageEnable(y Bool32) PipelineMultisampleStateCreateInfo {
	x.alphaToCoverageEnable = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// AlphaToOneEnable returns the value of alphaToOneEnable from VkPipelineMultisampleStateCreateInfo
func (x PipelineMultisampleStateCreateInfo) AlphaToOneEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.alphaToOneEnable) 
	return *ptr
}

// WithAlphaToOneEnable sets the value for the AlphaToOneEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineMultisampleStateCreateInfo) WithAlphaToOneEnable(y Bool32) PipelineMultisampleStateCreateInfo {
	x.alphaToOneEnable = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DeviceQueueCreateInfo provides a go interface for VkDeviceQueueCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueCreateInfo.html
type DeviceQueueCreateInfo C.struct_VkDeviceQueueCreateInfo

// SizeofDeviceQueueCreateInfo is the memory size of a DeviceQueueCreateInfo
var SizeofDeviceQueueCreateInfo int = int(unsafe.Sizeof(DeviceQueueCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceQueueCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceQueueCreateInfo) AsCPtr() *DeviceQueueCreateInfo {
	clone := (*DeviceQueueCreateInfo)(newCBlock(C.ulong(SizeofDeviceQueueCreateInfo)))
	*clone = x
	return clone
}

// DeviceQueueCreateInfoFreeCSlice releases the memory allocated by DeviceQueueCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceQueueCreateInfoFreeCSlice(x []DeviceQueueCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceQueueCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceQueueCreateInfoFreeCSlice must be called on the returned slice.
func DeviceQueueCreateInfoMakeCSlice(x ...DeviceQueueCreateInfo) []DeviceQueueCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceQueueCreateInfo * len(x)
	dst := unsafe.Slice((*DeviceQueueCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceQueueCreateInfo
func (x DeviceQueueCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DeviceQueueCreateInfo) WithDefaultSType() DeviceQueueCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueCreateInfo) WithSType(y StructureType) DeviceQueueCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDeviceQueueCreateInfo
func (x DeviceQueueCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueCreateInfo) WithPNext(y unsafe.Pointer) DeviceQueueCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkDeviceQueueCreateInfo
func (x DeviceQueueCreateInfo) Flags() DeviceQueueCreateFlags {
	ptr := /* typedef */ (*DeviceQueueCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueCreateInfo) WithFlags(y DeviceQueueCreateFlags) DeviceQueueCreateInfo {
	x.flags = *(/* typedef */ (*C.VkDeviceQueueCreateFlags)(&y))
	return x
}

// QueueFamilyIndex returns the value of queueFamilyIndex from VkDeviceQueueCreateInfo
func (x DeviceQueueCreateInfo) QueueFamilyIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.queueFamilyIndex) 
	return *ptr
}

// WithQueueFamilyIndex sets the value for the QueueFamilyIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueCreateInfo) WithQueueFamilyIndex(y uint32) DeviceQueueCreateInfo {
	x.queueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// QueueCount returns the value of queueCount from VkDeviceQueueCreateInfo
func (x DeviceQueueCreateInfo) QueueCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.queueCount) 
	return *ptr
}

// WithQueueCount sets the value for the QueueCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueCreateInfo) WithQueueCount(y uint32) DeviceQueueCreateInfo {
	x.queueCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PQueuePriorities returns the value of pQueuePriorities from VkDeviceQueueCreateInfo
func (x DeviceQueueCreateInfo) PQueuePriorities() []float32 {
	ptr := func(x **C.float) *[]float32 { /* Slice */ slc := unsafe.Slice((*float32)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pQueuePriorities) 
	return *ptr
}

// WithPQueuePriorities sets the value for the PQueuePriorities on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines QueueCount as the length of this field.
// QueueCount is updated with the length of the new value.
func (x DeviceQueueCreateInfo) WithPQueuePriorities(y []float32) DeviceQueueCreateInfo {
	x.pQueuePriorities = *(func(x *[]float32) **C.float { /* Slice */ if len(*x) > 0 { slc := (*C.float)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.float)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithQueueCount(uint32(len(y)))
}

// PipelineRasterizationStateCreateInfo provides a go interface for VkPipelineRasterizationStateCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRasterizationStateCreateInfo.html
type PipelineRasterizationStateCreateInfo C.struct_VkPipelineRasterizationStateCreateInfo

// SizeofPipelineRasterizationStateCreateInfo is the memory size of a PipelineRasterizationStateCreateInfo
var SizeofPipelineRasterizationStateCreateInfo int = int(unsafe.Sizeof(PipelineRasterizationStateCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineRasterizationStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineRasterizationStateCreateInfo) AsCPtr() *PipelineRasterizationStateCreateInfo {
	clone := (*PipelineRasterizationStateCreateInfo)(newCBlock(C.ulong(SizeofPipelineRasterizationStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineRasterizationStateCreateInfoFreeCSlice releases the memory allocated by PipelineRasterizationStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineRasterizationStateCreateInfoFreeCSlice(x []PipelineRasterizationStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineRasterizationStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineRasterizationStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineRasterizationStateCreateInfoMakeCSlice(x ...PipelineRasterizationStateCreateInfo) []PipelineRasterizationStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineRasterizationStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineRasterizationStateCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineRasterizationStateCreateInfo) WithDefaultSType() PipelineRasterizationStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithSType(y StructureType) PipelineRasterizationStateCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineRasterizationStateCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) Flags() PipelineRasterizationStateCreateFlags {
	ptr := /* typedef */ (*PipelineRasterizationStateCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithFlags(y PipelineRasterizationStateCreateFlags) PipelineRasterizationStateCreateInfo {
	x.flags = *(/* typedef */ (*C.VkPipelineRasterizationStateCreateFlags)(&y))
	return x
}

// DepthClampEnable returns the value of depthClampEnable from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) DepthClampEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.depthClampEnable) 
	return *ptr
}

// WithDepthClampEnable sets the value for the DepthClampEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithDepthClampEnable(y Bool32) PipelineRasterizationStateCreateInfo {
	x.depthClampEnable = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// RasterizerDiscardEnable returns the value of rasterizerDiscardEnable from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) RasterizerDiscardEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.rasterizerDiscardEnable) 
	return *ptr
}

// WithRasterizerDiscardEnable sets the value for the RasterizerDiscardEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithRasterizerDiscardEnable(y Bool32) PipelineRasterizationStateCreateInfo {
	x.rasterizerDiscardEnable = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// PolygonMode returns the value of polygonMode from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) PolygonMode() PolygonMode {
	ptr := /* typedef */ (*PolygonMode)(&x.polygonMode) 
	return *ptr
}

// WithPolygonMode sets the value for the PolygonMode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithPolygonMode(y PolygonMode) PipelineRasterizationStateCreateInfo {
	x.polygonMode = *(/* typedef */ (*C.VkPolygonMode)(&y))
	return x
}

// CullMode returns the value of cullMode from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) CullMode() CullModeFlags {
	ptr := /* typedef */ (*CullModeFlags)(&x.cullMode) 
	return *ptr
}

// WithCullMode sets the value for the CullMode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithCullMode(y CullModeFlags) PipelineRasterizationStateCreateInfo {
	x.cullMode = *(/* typedef */ (*C.VkCullModeFlags)(&y))
	return x
}

// FrontFace returns the value of frontFace from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) FrontFace() FrontFace {
	ptr := /* typedef */ (*FrontFace)(&x.frontFace) 
	return *ptr
}

// WithFrontFace sets the value for the FrontFace on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithFrontFace(y FrontFace) PipelineRasterizationStateCreateInfo {
	x.frontFace = *(/* typedef */ (*C.VkFrontFace)(&y))
	return x
}

// DepthBiasEnable returns the value of depthBiasEnable from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) DepthBiasEnable() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.depthBiasEnable) 
	return *ptr
}

// WithDepthBiasEnable sets the value for the DepthBiasEnable on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithDepthBiasEnable(y Bool32) PipelineRasterizationStateCreateInfo {
	x.depthBiasEnable = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DepthBiasConstantFactor returns the value of depthBiasConstantFactor from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) DepthBiasConstantFactor() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.depthBiasConstantFactor) 
	return *ptr
}

// WithDepthBiasConstantFactor sets the value for the DepthBiasConstantFactor on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithDepthBiasConstantFactor(y float32) PipelineRasterizationStateCreateInfo {
	x.depthBiasConstantFactor = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}

// DepthBiasClamp returns the value of depthBiasClamp from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) DepthBiasClamp() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.depthBiasClamp) 
	return *ptr
}

// WithDepthBiasClamp sets the value for the DepthBiasClamp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithDepthBiasClamp(y float32) PipelineRasterizationStateCreateInfo {
	x.depthBiasClamp = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}

// DepthBiasSlopeFactor returns the value of depthBiasSlopeFactor from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) DepthBiasSlopeFactor() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.depthBiasSlopeFactor) 
	return *ptr
}

// WithDepthBiasSlopeFactor sets the value for the DepthBiasSlopeFactor on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithDepthBiasSlopeFactor(y float32) PipelineRasterizationStateCreateInfo {
	x.depthBiasSlopeFactor = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}

// LineWidth returns the value of lineWidth from VkPipelineRasterizationStateCreateInfo
func (x PipelineRasterizationStateCreateInfo) LineWidth() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.lineWidth) 
	return *ptr
}

// WithLineWidth sets the value for the LineWidth on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRasterizationStateCreateInfo) WithLineWidth(y float32) PipelineRasterizationStateCreateInfo {
	x.lineWidth = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}

// DeviceCreateInfo provides a go interface for VkDeviceCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceCreateInfo.html
type DeviceCreateInfo C.struct_VkDeviceCreateInfo

// SizeofDeviceCreateInfo is the memory size of a DeviceCreateInfo
var SizeofDeviceCreateInfo int = int(unsafe.Sizeof(DeviceCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceCreateInfo) AsCPtr() *DeviceCreateInfo {
	clone := (*DeviceCreateInfo)(newCBlock(C.ulong(SizeofDeviceCreateInfo)))
	*clone = x
	return clone
}

// DeviceCreateInfoFreeCSlice releases the memory allocated by DeviceCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceCreateInfoFreeCSlice(x []DeviceCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceCreateInfoFreeCSlice must be called on the returned slice.
func DeviceCreateInfoMakeCSlice(x ...DeviceCreateInfo) []DeviceCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceCreateInfo * len(x)
	dst := unsafe.Slice((*DeviceCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceCreateInfo
func (x DeviceCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DeviceCreateInfo) WithDefaultSType() DeviceCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceCreateInfo) WithSType(y StructureType) DeviceCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDeviceCreateInfo
func (x DeviceCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceCreateInfo) WithPNext(y unsafe.Pointer) DeviceCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkDeviceCreateInfo
func (x DeviceCreateInfo) Flags() DeviceCreateFlags {
	ptr := /* typedef */ (*DeviceCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceCreateInfo) WithFlags(y DeviceCreateFlags) DeviceCreateInfo {
	x.flags = *(/* typedef */ (*C.VkDeviceCreateFlags)(&y))
	return x
}

// QueueCreateInfoCount returns the value of queueCreateInfoCount from VkDeviceCreateInfo
func (x DeviceCreateInfo) QueueCreateInfoCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.queueCreateInfoCount) 
	return *ptr
}

// WithQueueCreateInfoCount sets the value for the QueueCreateInfoCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceCreateInfo) WithQueueCreateInfoCount(y uint32) DeviceCreateInfo {
	x.queueCreateInfoCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PQueueCreateInfos returns the value of pQueueCreateInfos from VkDeviceCreateInfo
func (x DeviceCreateInfo) PQueueCreateInfos() []DeviceQueueCreateInfo {
	ptr := func(x **C.struct_VkDeviceQueueCreateInfo) *[]DeviceQueueCreateInfo { /* Slice */ slc := unsafe.Slice((*DeviceQueueCreateInfo)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pQueueCreateInfos) 
	return *ptr
}

// WithPQueueCreateInfos sets the value for the PQueueCreateInfos on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines QueueCreateInfoCount as the length of this field.
// QueueCreateInfoCount is updated with the length of the new value.
func (x DeviceCreateInfo) WithPQueueCreateInfos(y []DeviceQueueCreateInfo) DeviceCreateInfo {
	x.pQueueCreateInfos = *(func(x *[]DeviceQueueCreateInfo) **C.struct_VkDeviceQueueCreateInfo { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkDeviceQueueCreateInfo)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkDeviceQueueCreateInfo)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithQueueCreateInfoCount(uint32(len(y)))
}

// EnabledLayerCount returns the value of enabledLayerCount from VkDeviceCreateInfo
func (x DeviceCreateInfo) EnabledLayerCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.enabledLayerCount) 
	return *ptr
}

// WithEnabledLayerCount sets the value for the EnabledLayerCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceCreateInfo) WithEnabledLayerCount(y uint32) DeviceCreateInfo {
	x.enabledLayerCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PpEnabledLayerNames returns the value of ppEnabledLayerNames from VkDeviceCreateInfo
func (x DeviceCreateInfo) PpEnabledLayerNames() []*byte {
	ptr := func(x ***C.char) *[]*byte { /* Slice */ slc := unsafe.Slice((**byte)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.ppEnabledLayerNames) 
	return *ptr
}

// WithPpEnabledLayerNames sets the value for the PpEnabledLayerNames on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceCreateInfo) WithPpEnabledLayerNames(y []*byte) DeviceCreateInfo {
	x.ppEnabledLayerNames = *(func(x *[]*byte) ***C.char { /* Slice */ if len(*x) > 0 { slc := (**C.char)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (***C.char)(unsafe.Pointer((&ptr))) }(&y))
	return x
}

// EnabledExtensionCount returns the value of enabledExtensionCount from VkDeviceCreateInfo
func (x DeviceCreateInfo) EnabledExtensionCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.enabledExtensionCount) 
	return *ptr
}

// WithEnabledExtensionCount sets the value for the EnabledExtensionCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceCreateInfo) WithEnabledExtensionCount(y uint32) DeviceCreateInfo {
	x.enabledExtensionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PpEnabledExtensionNames returns the value of ppEnabledExtensionNames from VkDeviceCreateInfo
func (x DeviceCreateInfo) PpEnabledExtensionNames() []*byte {
	ptr := func(x ***C.char) *[]*byte { /* Slice */ slc := unsafe.Slice((**byte)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.ppEnabledExtensionNames) 
	return *ptr
}

// WithPpEnabledExtensionNames sets the value for the PpEnabledExtensionNames on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceCreateInfo) WithPpEnabledExtensionNames(y []*byte) DeviceCreateInfo {
	x.ppEnabledExtensionNames = *(func(x *[]*byte) ***C.char { /* Slice */ if len(*x) > 0 { slc := (**C.char)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (***C.char)(unsafe.Pointer((&ptr))) }(&y))
	return x
}

// PEnabledFeatures returns the value of pEnabledFeatures from VkDeviceCreateInfo
func (x DeviceCreateInfo) PEnabledFeatures() *PhysicalDeviceFeatures {
	ptr := func(x **C.struct_VkPhysicalDeviceFeatures) **PhysicalDeviceFeatures { /* Pointer */ c2g := (*PhysicalDeviceFeatures)(*x); return &c2g }(&x.pEnabledFeatures) 
	return *ptr
}

// WithPEnabledFeatures sets the value for the PEnabledFeatures on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceCreateInfo) WithPEnabledFeatures(y *PhysicalDeviceFeatures) DeviceCreateInfo {
	x.pEnabledFeatures = *(func(x **PhysicalDeviceFeatures) **C.struct_VkPhysicalDeviceFeatures { /* Pointer */ g2c := (*C.struct_VkPhysicalDeviceFeatures)(*x); return &g2c }(&y))
	return x
}

// DescriptorSetAllocateInfo provides a go interface for VkDescriptorSetAllocateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetAllocateInfo.html
type DescriptorSetAllocateInfo C.struct_VkDescriptorSetAllocateInfo

// SizeofDescriptorSetAllocateInfo is the memory size of a DescriptorSetAllocateInfo
var SizeofDescriptorSetAllocateInfo int = int(unsafe.Sizeof(DescriptorSetAllocateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorSetAllocateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorSetAllocateInfo) AsCPtr() *DescriptorSetAllocateInfo {
	clone := (*DescriptorSetAllocateInfo)(newCBlock(C.ulong(SizeofDescriptorSetAllocateInfo)))
	*clone = x
	return clone
}

// DescriptorSetAllocateInfoFreeCSlice releases the memory allocated by DescriptorSetAllocateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorSetAllocateInfoFreeCSlice(x []DescriptorSetAllocateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorSetAllocateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorSetAllocateInfoFreeCSlice must be called on the returned slice.
func DescriptorSetAllocateInfoMakeCSlice(x ...DescriptorSetAllocateInfo) []DescriptorSetAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetAllocateInfo * len(x)
	dst := unsafe.Slice((*DescriptorSetAllocateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDescriptorSetAllocateInfo
func (x DescriptorSetAllocateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DescriptorSetAllocateInfo) WithDefaultSType() DescriptorSetAllocateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetAllocateInfo) WithSType(y StructureType) DescriptorSetAllocateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDescriptorSetAllocateInfo
func (x DescriptorSetAllocateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetAllocateInfo) WithPNext(y unsafe.Pointer) DescriptorSetAllocateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// DescriptorPool returns the value of descriptorPool from VkDescriptorSetAllocateInfo
func (x DescriptorSetAllocateInfo) DescriptorPool() DescriptorPool {
	ptr := /* handle */ (*DescriptorPool)(&x.descriptorPool) 
	return *ptr
}

// WithDescriptorPool sets the value for the DescriptorPool on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetAllocateInfo) WithDescriptorPool(y DescriptorPool) DescriptorSetAllocateInfo {
	x.descriptorPool = *(/* handle */ (*C.VkDescriptorPool)(&y))
	return x
}

// DescriptorSetCount returns the value of descriptorSetCount from VkDescriptorSetAllocateInfo
func (x DescriptorSetAllocateInfo) DescriptorSetCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.descriptorSetCount) 
	return *ptr
}

// WithDescriptorSetCount sets the value for the DescriptorSetCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetAllocateInfo) WithDescriptorSetCount(y uint32) DescriptorSetAllocateInfo {
	x.descriptorSetCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PSetLayouts returns the value of pSetLayouts from VkDescriptorSetAllocateInfo
func (x DescriptorSetAllocateInfo) PSetLayouts() []DescriptorSetLayout {
	ptr := func(x **C.VkDescriptorSetLayout) *[]DescriptorSetLayout { /* Slice */ slc := unsafe.Slice((*DescriptorSetLayout)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pSetLayouts) 
	return *ptr
}

// WithPSetLayouts sets the value for the PSetLayouts on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines DescriptorSetCount as the length of this field.
// DescriptorSetCount is updated with the length of the new value.
func (x DescriptorSetAllocateInfo) WithPSetLayouts(y []DescriptorSetLayout) DescriptorSetAllocateInfo {
	x.pSetLayouts = *(func(x *[]DescriptorSetLayout) **C.VkDescriptorSetLayout { /* Slice */ if len(*x) > 0 { slc := (*C.VkDescriptorSetLayout)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkDescriptorSetLayout)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithDescriptorSetCount(uint32(len(y)))
}

// PipelineShaderStageCreateInfo provides a go interface for VkPipelineShaderStageCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageCreateInfo.html
type PipelineShaderStageCreateInfo C.struct_VkPipelineShaderStageCreateInfo

// SizeofPipelineShaderStageCreateInfo is the memory size of a PipelineShaderStageCreateInfo
var SizeofPipelineShaderStageCreateInfo int = int(unsafe.Sizeof(PipelineShaderStageCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineShaderStageCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineShaderStageCreateInfo) AsCPtr() *PipelineShaderStageCreateInfo {
	clone := (*PipelineShaderStageCreateInfo)(newCBlock(C.ulong(SizeofPipelineShaderStageCreateInfo)))
	*clone = x
	return clone
}

// PipelineShaderStageCreateInfoFreeCSlice releases the memory allocated by PipelineShaderStageCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineShaderStageCreateInfoFreeCSlice(x []PipelineShaderStageCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineShaderStageCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineShaderStageCreateInfoFreeCSlice must be called on the returned slice.
func PipelineShaderStageCreateInfoMakeCSlice(x ...PipelineShaderStageCreateInfo) []PipelineShaderStageCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineShaderStageCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineShaderStageCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineShaderStageCreateInfo
func (x PipelineShaderStageCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineShaderStageCreateInfo) WithDefaultSType() PipelineShaderStageCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineShaderStageCreateInfo) WithSType(y StructureType) PipelineShaderStageCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPipelineShaderStageCreateInfo
func (x PipelineShaderStageCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineShaderStageCreateInfo) WithPNext(y unsafe.Pointer) PipelineShaderStageCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkPipelineShaderStageCreateInfo
func (x PipelineShaderStageCreateInfo) Flags() PipelineShaderStageCreateFlags {
	ptr := /* typedef */ (*PipelineShaderStageCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineShaderStageCreateInfo) WithFlags(y PipelineShaderStageCreateFlags) PipelineShaderStageCreateInfo {
	x.flags = *(/* typedef */ (*C.VkPipelineShaderStageCreateFlags)(&y))
	return x
}

// Stage returns the value of stage from VkPipelineShaderStageCreateInfo
func (x PipelineShaderStageCreateInfo) Stage() ShaderStageFlagBits {
	ptr := /* typedef */ (*ShaderStageFlagBits)(&x.stage) 
	return *ptr
}

// WithStage sets the value for the Stage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineShaderStageCreateInfo) WithStage(y ShaderStageFlagBits) PipelineShaderStageCreateInfo {
	x.stage = *(/* typedef */ (*C.VkShaderStageFlagBits)(&y))
	return x
}

// Module returns the value of module from VkPipelineShaderStageCreateInfo
func (x PipelineShaderStageCreateInfo) Module() ShaderModule {
	ptr := /* handle */ (*ShaderModule)(&x.module) 
	return *ptr
}

// WithModule sets the value for the Module on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineShaderStageCreateInfo) WithModule(y ShaderModule) PipelineShaderStageCreateInfo {
	x.module = *(/* handle */ (*C.VkShaderModule)(&y))
	return x
}

// PName returns the value of pName from VkPipelineShaderStageCreateInfo
func (x PipelineShaderStageCreateInfo) PName() *byte {
	ptr := func(x **C.char) **byte { /* Pointer */ return (**byte)(unsafe.Pointer(x)) }(&x.pName) 
	return *ptr
}

// WithPName sets the value for the PName on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineShaderStageCreateInfo) WithPName(y *byte) PipelineShaderStageCreateInfo {
	x.pName = *(func(x **byte) **C.char { /* Pointer */ return (**C.char)(unsafe.Pointer(x)) }(&y))
	return x
}

// PSpecializationInfo returns the value of pSpecializationInfo from VkPipelineShaderStageCreateInfo
func (x PipelineShaderStageCreateInfo) PSpecializationInfo() *SpecializationInfo {
	ptr := func(x **C.struct_VkSpecializationInfo) **SpecializationInfo { /* Pointer */ c2g := (*SpecializationInfo)(*x); return &c2g }(&x.pSpecializationInfo) 
	return *ptr
}

// WithPSpecializationInfo sets the value for the PSpecializationInfo on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineShaderStageCreateInfo) WithPSpecializationInfo(y *SpecializationInfo) PipelineShaderStageCreateInfo {
	x.pSpecializationInfo = *(func(x **SpecializationInfo) **C.struct_VkSpecializationInfo { /* Pointer */ g2c := (*C.struct_VkSpecializationInfo)(*x); return &g2c }(&y))
	return x
}

// DescriptorPoolSize provides a go interface for VkDescriptorPoolSize.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolSize.html
type DescriptorPoolSize C.struct_VkDescriptorPoolSize

// SizeofDescriptorPoolSize is the memory size of a DescriptorPoolSize
var SizeofDescriptorPoolSize int = int(unsafe.Sizeof(DescriptorPoolSize{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorPoolSize) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorPoolSize) AsCPtr() *DescriptorPoolSize {
	clone := (*DescriptorPoolSize)(newCBlock(C.ulong(SizeofDescriptorPoolSize)))
	*clone = x
	return clone
}

// DescriptorPoolSizeFreeCSlice releases the memory allocated by DescriptorPoolSizeMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorPoolSizeFreeCSlice(x []DescriptorPoolSize) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorPoolSizeMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorPoolSizeFreeCSlice must be called on the returned slice.
func DescriptorPoolSizeMakeCSlice(x ...DescriptorPoolSize) []DescriptorPoolSize {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorPoolSize * len(x)
	dst := unsafe.Slice((*DescriptorPoolSize)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Type_ returns the value of type from VkDescriptorPoolSize
func (x DescriptorPoolSize) Type_() DescriptorType {
	ptr := /* typedef */ (*DescriptorType)(&x._type) 
	return *ptr
}

// WithType_ sets the value for the Type_ on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorPoolSize) WithType_(y DescriptorType) DescriptorPoolSize {
	x._type = *(/* typedef */ (*C.VkDescriptorType)(&y))
	return x
}

// DescriptorCount returns the value of descriptorCount from VkDescriptorPoolSize
func (x DescriptorPoolSize) DescriptorCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.descriptorCount) 
	return *ptr
}

// WithDescriptorCount sets the value for the DescriptorCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorPoolSize) WithDescriptorCount(y uint32) DescriptorPoolSize {
	x.descriptorCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PipelineTessellationStateCreateInfo provides a go interface for VkPipelineTessellationStateCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineTessellationStateCreateInfo.html
type PipelineTessellationStateCreateInfo C.struct_VkPipelineTessellationStateCreateInfo

// SizeofPipelineTessellationStateCreateInfo is the memory size of a PipelineTessellationStateCreateInfo
var SizeofPipelineTessellationStateCreateInfo int = int(unsafe.Sizeof(PipelineTessellationStateCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineTessellationStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineTessellationStateCreateInfo) AsCPtr() *PipelineTessellationStateCreateInfo {
	clone := (*PipelineTessellationStateCreateInfo)(newCBlock(C.ulong(SizeofPipelineTessellationStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineTessellationStateCreateInfoFreeCSlice releases the memory allocated by PipelineTessellationStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineTessellationStateCreateInfoFreeCSlice(x []PipelineTessellationStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineTessellationStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineTessellationStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineTessellationStateCreateInfoMakeCSlice(x ...PipelineTessellationStateCreateInfo) []PipelineTessellationStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineTessellationStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineTessellationStateCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineTessellationStateCreateInfo
func (x PipelineTessellationStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineTessellationStateCreateInfo) WithDefaultSType() PipelineTessellationStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineTessellationStateCreateInfo) WithSType(y StructureType) PipelineTessellationStateCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPipelineTessellationStateCreateInfo
func (x PipelineTessellationStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineTessellationStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineTessellationStateCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkPipelineTessellationStateCreateInfo
func (x PipelineTessellationStateCreateInfo) Flags() PipelineTessellationStateCreateFlags {
	ptr := /* typedef */ (*PipelineTessellationStateCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineTessellationStateCreateInfo) WithFlags(y PipelineTessellationStateCreateFlags) PipelineTessellationStateCreateInfo {
	x.flags = *(/* typedef */ (*C.VkPipelineTessellationStateCreateFlags)(&y))
	return x
}

// PatchControlPoints returns the value of patchControlPoints from VkPipelineTessellationStateCreateInfo
func (x PipelineTessellationStateCreateInfo) PatchControlPoints() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.patchControlPoints) 
	return *ptr
}

// WithPatchControlPoints sets the value for the PatchControlPoints on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineTessellationStateCreateInfo) WithPatchControlPoints(y uint32) PipelineTessellationStateCreateInfo {
	x.patchControlPoints = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// Extent2D provides a go interface for VkExtent2D.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExtent2D.html
type Extent2D C.struct_VkExtent2D

// SizeofExtent2D is the memory size of a Extent2D
var SizeofExtent2D int = int(unsafe.Sizeof(Extent2D{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *Extent2D) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x Extent2D) AsCPtr() *Extent2D {
	clone := (*Extent2D)(newCBlock(C.ulong(SizeofExtent2D)))
	*clone = x
	return clone
}

// Extent2DFreeCSlice releases the memory allocated by Extent2DMakeCSlice.
// It does not free pointers stored inside the slice.
func Extent2DFreeCSlice(x []Extent2D) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// Extent2DMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. Extent2DFreeCSlice must be called on the returned slice.
func Extent2DMakeCSlice(x ...Extent2D) []Extent2D {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExtent2D * len(x)
	dst := unsafe.Slice((*Extent2D)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Width returns the value of width from VkExtent2D
func (x Extent2D) Width() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.width) 
	return *ptr
}

// WithWidth sets the value for the Width on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Extent2D) WithWidth(y uint32) Extent2D {
	x.width = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// Height returns the value of height from VkExtent2D
func (x Extent2D) Height() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.height) 
	return *ptr
}

// WithHeight sets the value for the Height on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Extent2D) WithHeight(y uint32) Extent2D {
	x.height = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PipelineVertexInputStateCreateInfo provides a go interface for VkPipelineVertexInputStateCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineVertexInputStateCreateInfo.html
type PipelineVertexInputStateCreateInfo C.struct_VkPipelineVertexInputStateCreateInfo

// SizeofPipelineVertexInputStateCreateInfo is the memory size of a PipelineVertexInputStateCreateInfo
var SizeofPipelineVertexInputStateCreateInfo int = int(unsafe.Sizeof(PipelineVertexInputStateCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineVertexInputStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineVertexInputStateCreateInfo) AsCPtr() *PipelineVertexInputStateCreateInfo {
	clone := (*PipelineVertexInputStateCreateInfo)(newCBlock(C.ulong(SizeofPipelineVertexInputStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineVertexInputStateCreateInfoFreeCSlice releases the memory allocated by PipelineVertexInputStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineVertexInputStateCreateInfoFreeCSlice(x []PipelineVertexInputStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineVertexInputStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineVertexInputStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineVertexInputStateCreateInfoMakeCSlice(x ...PipelineVertexInputStateCreateInfo) []PipelineVertexInputStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineVertexInputStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineVertexInputStateCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineVertexInputStateCreateInfo
func (x PipelineVertexInputStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineVertexInputStateCreateInfo) WithDefaultSType() PipelineVertexInputStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineVertexInputStateCreateInfo) WithSType(y StructureType) PipelineVertexInputStateCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPipelineVertexInputStateCreateInfo
func (x PipelineVertexInputStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineVertexInputStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineVertexInputStateCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkPipelineVertexInputStateCreateInfo
func (x PipelineVertexInputStateCreateInfo) Flags() PipelineVertexInputStateCreateFlags {
	ptr := /* typedef */ (*PipelineVertexInputStateCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineVertexInputStateCreateInfo) WithFlags(y PipelineVertexInputStateCreateFlags) PipelineVertexInputStateCreateInfo {
	x.flags = *(/* typedef */ (*C.VkPipelineVertexInputStateCreateFlags)(&y))
	return x
}

// VertexBindingDescriptionCount returns the value of vertexBindingDescriptionCount from VkPipelineVertexInputStateCreateInfo
func (x PipelineVertexInputStateCreateInfo) VertexBindingDescriptionCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.vertexBindingDescriptionCount) 
	return *ptr
}

// WithVertexBindingDescriptionCount sets the value for the VertexBindingDescriptionCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineVertexInputStateCreateInfo) WithVertexBindingDescriptionCount(y uint32) PipelineVertexInputStateCreateInfo {
	x.vertexBindingDescriptionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PVertexBindingDescriptions returns the value of pVertexBindingDescriptions from VkPipelineVertexInputStateCreateInfo
func (x PipelineVertexInputStateCreateInfo) PVertexBindingDescriptions() []VertexInputBindingDescription {
	ptr := func(x **C.struct_VkVertexInputBindingDescription) *[]VertexInputBindingDescription { /* Slice */ slc := unsafe.Slice((*VertexInputBindingDescription)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pVertexBindingDescriptions) 
	return *ptr
}

// WithPVertexBindingDescriptions sets the value for the PVertexBindingDescriptions on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines VertexBindingDescriptionCount as the length of this field.
// VertexBindingDescriptionCount is updated with the length of the new value.
func (x PipelineVertexInputStateCreateInfo) WithPVertexBindingDescriptions(y []VertexInputBindingDescription) PipelineVertexInputStateCreateInfo {
	x.pVertexBindingDescriptions = *(func(x *[]VertexInputBindingDescription) **C.struct_VkVertexInputBindingDescription { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkVertexInputBindingDescription)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkVertexInputBindingDescription)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithVertexBindingDescriptionCount(uint32(len(y)))
}

// VertexAttributeDescriptionCount returns the value of vertexAttributeDescriptionCount from VkPipelineVertexInputStateCreateInfo
func (x PipelineVertexInputStateCreateInfo) VertexAttributeDescriptionCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.vertexAttributeDescriptionCount) 
	return *ptr
}

// WithVertexAttributeDescriptionCount sets the value for the VertexAttributeDescriptionCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineVertexInputStateCreateInfo) WithVertexAttributeDescriptionCount(y uint32) PipelineVertexInputStateCreateInfo {
	x.vertexAttributeDescriptionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PVertexAttributeDescriptions returns the value of pVertexAttributeDescriptions from VkPipelineVertexInputStateCreateInfo
func (x PipelineVertexInputStateCreateInfo) PVertexAttributeDescriptions() []VertexInputAttributeDescription {
	ptr := func(x **C.struct_VkVertexInputAttributeDescription) *[]VertexInputAttributeDescription { /* Slice */ slc := unsafe.Slice((*VertexInputAttributeDescription)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pVertexAttributeDescriptions) 
	return *ptr
}

// WithPVertexAttributeDescriptions sets the value for the PVertexAttributeDescriptions on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines VertexAttributeDescriptionCount as the length of this field.
// VertexAttributeDescriptionCount is updated with the length of the new value.
func (x PipelineVertexInputStateCreateInfo) WithPVertexAttributeDescriptions(y []VertexInputAttributeDescription) PipelineVertexInputStateCreateInfo {
	x.pVertexAttributeDescriptions = *(func(x *[]VertexInputAttributeDescription) **C.struct_VkVertexInputAttributeDescription { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkVertexInputAttributeDescription)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkVertexInputAttributeDescription)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithVertexAttributeDescriptionCount(uint32(len(y)))
}

// DescriptorPoolCreateInfo provides a go interface for VkDescriptorPoolCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolCreateInfo.html
type DescriptorPoolCreateInfo C.struct_VkDescriptorPoolCreateInfo

// SizeofDescriptorPoolCreateInfo is the memory size of a DescriptorPoolCreateInfo
var SizeofDescriptorPoolCreateInfo int = int(unsafe.Sizeof(DescriptorPoolCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorPoolCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorPoolCreateInfo) AsCPtr() *DescriptorPoolCreateInfo {
	clone := (*DescriptorPoolCreateInfo)(newCBlock(C.ulong(SizeofDescriptorPoolCreateInfo)))
	*clone = x
	return clone
}

// DescriptorPoolCreateInfoFreeCSlice releases the memory allocated by DescriptorPoolCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorPoolCreateInfoFreeCSlice(x []DescriptorPoolCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorPoolCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorPoolCreateInfoFreeCSlice must be called on the returned slice.
func DescriptorPoolCreateInfoMakeCSlice(x ...DescriptorPoolCreateInfo) []DescriptorPoolCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorPoolCreateInfo * len(x)
	dst := unsafe.Slice((*DescriptorPoolCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDescriptorPoolCreateInfo
func (x DescriptorPoolCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DescriptorPoolCreateInfo) WithDefaultSType() DescriptorPoolCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorPoolCreateInfo) WithSType(y StructureType) DescriptorPoolCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDescriptorPoolCreateInfo
func (x DescriptorPoolCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorPoolCreateInfo) WithPNext(y unsafe.Pointer) DescriptorPoolCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkDescriptorPoolCreateInfo
func (x DescriptorPoolCreateInfo) Flags() DescriptorPoolCreateFlags {
	ptr := /* typedef */ (*DescriptorPoolCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorPoolCreateInfo) WithFlags(y DescriptorPoolCreateFlags) DescriptorPoolCreateInfo {
	x.flags = *(/* typedef */ (*C.VkDescriptorPoolCreateFlags)(&y))
	return x
}

// MaxSets returns the value of maxSets from VkDescriptorPoolCreateInfo
func (x DescriptorPoolCreateInfo) MaxSets() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxSets) 
	return *ptr
}

// WithMaxSets sets the value for the MaxSets on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorPoolCreateInfo) WithMaxSets(y uint32) DescriptorPoolCreateInfo {
	x.maxSets = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PoolSizeCount returns the value of poolSizeCount from VkDescriptorPoolCreateInfo
func (x DescriptorPoolCreateInfo) PoolSizeCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.poolSizeCount) 
	return *ptr
}

// WithPoolSizeCount sets the value for the PoolSizeCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorPoolCreateInfo) WithPoolSizeCount(y uint32) DescriptorPoolCreateInfo {
	x.poolSizeCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PPoolSizes returns the value of pPoolSizes from VkDescriptorPoolCreateInfo
func (x DescriptorPoolCreateInfo) PPoolSizes() []DescriptorPoolSize {
	ptr := func(x **C.struct_VkDescriptorPoolSize) *[]DescriptorPoolSize { /* Slice */ slc := unsafe.Slice((*DescriptorPoolSize)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pPoolSizes) 
	return *ptr
}

// WithPPoolSizes sets the value for the PPoolSizes on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines PoolSizeCount as the length of this field.
// PoolSizeCount is updated with the length of the new value.
func (x DescriptorPoolCreateInfo) WithPPoolSizes(y []DescriptorPoolSize) DescriptorPoolCreateInfo {
	x.pPoolSizes = *(func(x *[]DescriptorPoolSize) **C.struct_VkDescriptorPoolSize { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkDescriptorPoolSize)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkDescriptorPoolSize)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithPoolSizeCount(uint32(len(y)))
}

// PipelineViewportStateCreateInfo provides a go interface for VkPipelineViewportStateCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineViewportStateCreateInfo.html
type PipelineViewportStateCreateInfo C.struct_VkPipelineViewportStateCreateInfo

// SizeofPipelineViewportStateCreateInfo is the memory size of a PipelineViewportStateCreateInfo
var SizeofPipelineViewportStateCreateInfo int = int(unsafe.Sizeof(PipelineViewportStateCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineViewportStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineViewportStateCreateInfo) AsCPtr() *PipelineViewportStateCreateInfo {
	clone := (*PipelineViewportStateCreateInfo)(newCBlock(C.ulong(SizeofPipelineViewportStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineViewportStateCreateInfoFreeCSlice releases the memory allocated by PipelineViewportStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineViewportStateCreateInfoFreeCSlice(x []PipelineViewportStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineViewportStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineViewportStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineViewportStateCreateInfoMakeCSlice(x ...PipelineViewportStateCreateInfo) []PipelineViewportStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineViewportStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineViewportStateCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineViewportStateCreateInfo
func (x PipelineViewportStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineViewportStateCreateInfo) WithDefaultSType() PipelineViewportStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineViewportStateCreateInfo) WithSType(y StructureType) PipelineViewportStateCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPipelineViewportStateCreateInfo
func (x PipelineViewportStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineViewportStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineViewportStateCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkPipelineViewportStateCreateInfo
func (x PipelineViewportStateCreateInfo) Flags() PipelineViewportStateCreateFlags {
	ptr := /* typedef */ (*PipelineViewportStateCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineViewportStateCreateInfo) WithFlags(y PipelineViewportStateCreateFlags) PipelineViewportStateCreateInfo {
	x.flags = *(/* typedef */ (*C.VkPipelineViewportStateCreateFlags)(&y))
	return x
}

// ViewportCount returns the value of viewportCount from VkPipelineViewportStateCreateInfo
func (x PipelineViewportStateCreateInfo) ViewportCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.viewportCount) 
	return *ptr
}

// WithViewportCount sets the value for the ViewportCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineViewportStateCreateInfo) WithViewportCount(y uint32) PipelineViewportStateCreateInfo {
	x.viewportCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PViewports returns the value of pViewports from VkPipelineViewportStateCreateInfo
func (x PipelineViewportStateCreateInfo) PViewports() []Viewport {
	ptr := func(x **C.struct_VkViewport) *[]Viewport { /* Slice */ slc := unsafe.Slice((*Viewport)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pViewports) 
	return *ptr
}

// WithPViewports sets the value for the PViewports on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines ViewportCount as the length of this field.
// ViewportCount is updated with the length of the new value.
func (x PipelineViewportStateCreateInfo) WithPViewports(y []Viewport) PipelineViewportStateCreateInfo {
	x.pViewports = *(func(x *[]Viewport) **C.struct_VkViewport { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkViewport)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkViewport)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithViewportCount(uint32(len(y)))
}

// ScissorCount returns the value of scissorCount from VkPipelineViewportStateCreateInfo
func (x PipelineViewportStateCreateInfo) ScissorCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.scissorCount) 
	return *ptr
}

// WithScissorCount sets the value for the ScissorCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineViewportStateCreateInfo) WithScissorCount(y uint32) PipelineViewportStateCreateInfo {
	x.scissorCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PScissors returns the value of pScissors from VkPipelineViewportStateCreateInfo
func (x PipelineViewportStateCreateInfo) PScissors() []Rect2D {
	ptr := func(x **C.struct_VkRect2D) *[]Rect2D { /* Slice */ slc := unsafe.Slice((*Rect2D)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pScissors) 
	return *ptr
}

// WithPScissors sets the value for the PScissors on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines ScissorCount as the length of this field.
// ScissorCount is updated with the length of the new value.
func (x PipelineViewportStateCreateInfo) WithPScissors(y []Rect2D) PipelineViewportStateCreateInfo {
	x.pScissors = *(func(x *[]Rect2D) **C.struct_VkRect2D { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkRect2D)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkRect2D)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithScissorCount(uint32(len(y)))
}

// QueueFamilyProperties provides a go interface for VkQueueFamilyProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFamilyProperties.html
type QueueFamilyProperties C.struct_VkQueueFamilyProperties

// SizeofQueueFamilyProperties is the memory size of a QueueFamilyProperties
var SizeofQueueFamilyProperties int = int(unsafe.Sizeof(QueueFamilyProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *QueueFamilyProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x QueueFamilyProperties) AsCPtr() *QueueFamilyProperties {
	clone := (*QueueFamilyProperties)(newCBlock(C.ulong(SizeofQueueFamilyProperties)))
	*clone = x
	return clone
}

// QueueFamilyPropertiesFreeCSlice releases the memory allocated by QueueFamilyPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func QueueFamilyPropertiesFreeCSlice(x []QueueFamilyProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// QueueFamilyPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. QueueFamilyPropertiesFreeCSlice must be called on the returned slice.
func QueueFamilyPropertiesMakeCSlice(x ...QueueFamilyProperties) []QueueFamilyProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofQueueFamilyProperties * len(x)
	dst := unsafe.Slice((*QueueFamilyProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// QueueFlags returns the value of queueFlags from VkQueueFamilyProperties
func (x QueueFamilyProperties) QueueFlags() QueueFlags {
	ptr := /* typedef */ (*QueueFlags)(&x.queueFlags) 
	return *ptr
}

// QueueCount returns the value of queueCount from VkQueueFamilyProperties
func (x QueueFamilyProperties) QueueCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.queueCount) 
	return *ptr
}

// TimestampValidBits returns the value of timestampValidBits from VkQueueFamilyProperties
func (x QueueFamilyProperties) TimestampValidBits() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.timestampValidBits) 
	return *ptr
}

// MinImageTransferGranularity returns the value of minImageTransferGranularity from VkQueueFamilyProperties
func (x QueueFamilyProperties) MinImageTransferGranularity() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.minImageTransferGranularity) 
	return *ptr
}

// PhysicalDeviceSparseProperties provides a go interface for VkPhysicalDeviceSparseProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSparseProperties.html
type PhysicalDeviceSparseProperties C.struct_VkPhysicalDeviceSparseProperties

// SizeofPhysicalDeviceSparseProperties is the memory size of a PhysicalDeviceSparseProperties
var SizeofPhysicalDeviceSparseProperties int = int(unsafe.Sizeof(PhysicalDeviceSparseProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceSparseProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceSparseProperties) AsCPtr() *PhysicalDeviceSparseProperties {
	clone := (*PhysicalDeviceSparseProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceSparseProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceSparsePropertiesFreeCSlice releases the memory allocated by PhysicalDeviceSparsePropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceSparsePropertiesFreeCSlice(x []PhysicalDeviceSparseProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceSparsePropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceSparsePropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceSparsePropertiesMakeCSlice(x ...PhysicalDeviceSparseProperties) []PhysicalDeviceSparseProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSparseProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceSparseProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// ResidencyStandard2DBlockShape returns the value of residencyStandard2DBlockShape from VkPhysicalDeviceSparseProperties
func (x PhysicalDeviceSparseProperties) ResidencyStandard2DBlockShape() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.residencyStandard2DBlockShape) 
	return *ptr
}

// ResidencyStandard2DMultisampleBlockShape returns the value of residencyStandard2DMultisampleBlockShape from VkPhysicalDeviceSparseProperties
func (x PhysicalDeviceSparseProperties) ResidencyStandard2DMultisampleBlockShape() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.residencyStandard2DMultisampleBlockShape) 
	return *ptr
}

// ResidencyStandard3DBlockShape returns the value of residencyStandard3DBlockShape from VkPhysicalDeviceSparseProperties
func (x PhysicalDeviceSparseProperties) ResidencyStandard3DBlockShape() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.residencyStandard3DBlockShape) 
	return *ptr
}

// ResidencyAlignedMipSize returns the value of residencyAlignedMipSize from VkPhysicalDeviceSparseProperties
func (x PhysicalDeviceSparseProperties) ResidencyAlignedMipSize() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.residencyAlignedMipSize) 
	return *ptr
}

// ResidencyNonResidentStrict returns the value of residencyNonResidentStrict from VkPhysicalDeviceSparseProperties
func (x PhysicalDeviceSparseProperties) ResidencyNonResidentStrict() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.residencyNonResidentStrict) 
	return *ptr
}

// PhysicalDeviceProperties provides a go interface for VkPhysicalDeviceProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProperties.html
type PhysicalDeviceProperties C.struct_VkPhysicalDeviceProperties

// SizeofPhysicalDeviceProperties is the memory size of a PhysicalDeviceProperties
var SizeofPhysicalDeviceProperties int = int(unsafe.Sizeof(PhysicalDeviceProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceProperties) AsCPtr() *PhysicalDeviceProperties {
	clone := (*PhysicalDeviceProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceProperties)))
	*clone = x
	return clone
}

// PhysicalDevicePropertiesFreeCSlice releases the memory allocated by PhysicalDevicePropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDevicePropertiesFreeCSlice(x []PhysicalDeviceProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDevicePropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDevicePropertiesFreeCSlice must be called on the returned slice.
func PhysicalDevicePropertiesMakeCSlice(x ...PhysicalDeviceProperties) []PhysicalDeviceProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// ApiVersion returns the value of apiVersion from VkPhysicalDeviceProperties
func (x PhysicalDeviceProperties) ApiVersion() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.apiVersion) 
	return *ptr
}

// DriverVersion returns the value of driverVersion from VkPhysicalDeviceProperties
func (x PhysicalDeviceProperties) DriverVersion() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.driverVersion) 
	return *ptr
}

// VendorID returns the value of vendorID from VkPhysicalDeviceProperties
func (x PhysicalDeviceProperties) VendorID() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.vendorID) 
	return *ptr
}

// DeviceID returns the value of deviceID from VkPhysicalDeviceProperties
func (x PhysicalDeviceProperties) DeviceID() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.deviceID) 
	return *ptr
}

// DeviceType returns the value of deviceType from VkPhysicalDeviceProperties
func (x PhysicalDeviceProperties) DeviceType() PhysicalDeviceType {
	ptr := /* typedef */ (*PhysicalDeviceType)(&x.deviceType) 
	return *ptr
}

// DeviceName returns the value of deviceName from VkPhysicalDeviceProperties
func (x PhysicalDeviceProperties) DeviceName() []byte {
	ptr := func(x *[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE]C.char) *[]byte { /* Array */ slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_PHYSICAL_DEVICE_NAME_SIZE); return &slc }(&x.deviceName) 
	return *ptr
}

// PipelineCacheUUID returns the value of pipelineCacheUUID from VkPhysicalDeviceProperties
func (x PhysicalDeviceProperties) PipelineCacheUUID() []byte {
	ptr := func(x *[VK_UUID_SIZE]C.uint8_t) *[]byte { /* Array */ slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_UUID_SIZE); return &slc }(&x.pipelineCacheUUID) 
	return *ptr
}

// Limits returns the value of limits from VkPhysicalDeviceProperties
func (x PhysicalDeviceProperties) Limits() PhysicalDeviceLimits {
	ptr := /* typedef */ (*PhysicalDeviceLimits)(&x.limits) 
	return *ptr
}

// SparseProperties returns the value of sparseProperties from VkPhysicalDeviceProperties
func (x PhysicalDeviceProperties) SparseProperties() PhysicalDeviceSparseProperties {
	ptr := /* typedef */ (*PhysicalDeviceSparseProperties)(&x.sparseProperties) 
	return *ptr
}

// PhysicalDeviceMemoryProperties provides a go interface for VkPhysicalDeviceMemoryProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryProperties.html
type PhysicalDeviceMemoryProperties C.struct_VkPhysicalDeviceMemoryProperties

// SizeofPhysicalDeviceMemoryProperties is the memory size of a PhysicalDeviceMemoryProperties
var SizeofPhysicalDeviceMemoryProperties int = int(unsafe.Sizeof(PhysicalDeviceMemoryProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceMemoryProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceMemoryProperties) AsCPtr() *PhysicalDeviceMemoryProperties {
	clone := (*PhysicalDeviceMemoryProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceMemoryProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceMemoryPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceMemoryPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceMemoryPropertiesFreeCSlice(x []PhysicalDeviceMemoryProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceMemoryPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceMemoryPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceMemoryPropertiesMakeCSlice(x ...PhysicalDeviceMemoryProperties) []PhysicalDeviceMemoryProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceMemoryProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceMemoryProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// MemoryTypeCount returns the value of memoryTypeCount from VkPhysicalDeviceMemoryProperties
func (x PhysicalDeviceMemoryProperties) MemoryTypeCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.memoryTypeCount) 
	return *ptr
}

// MemoryTypes returns the value of memoryTypes from VkPhysicalDeviceMemoryProperties
func (x PhysicalDeviceMemoryProperties) MemoryTypes() []MemoryType {
	ptr := func(x *[VK_MAX_MEMORY_TYPES]C.struct_VkMemoryType) *[]MemoryType { /* Array */ slc := unsafe.Slice((*MemoryType)(unsafe.Pointer(x)), VK_MAX_MEMORY_TYPES); return &slc }(&x.memoryTypes) 
	return *ptr
}

// MemoryHeapCount returns the value of memoryHeapCount from VkPhysicalDeviceMemoryProperties
func (x PhysicalDeviceMemoryProperties) MemoryHeapCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.memoryHeapCount) 
	return *ptr
}

// MemoryHeaps returns the value of memoryHeaps from VkPhysicalDeviceMemoryProperties
func (x PhysicalDeviceMemoryProperties) MemoryHeaps() []MemoryHeap {
	ptr := func(x *[VK_MAX_MEMORY_HEAPS]C.struct_VkMemoryHeap) *[]MemoryHeap { /* Array */ slc := unsafe.Slice((*MemoryHeap)(unsafe.Pointer(x)), VK_MAX_MEMORY_HEAPS); return &slc }(&x.memoryHeaps) 
	return *ptr
}

// PhysicalDeviceLimits provides a go interface for VkPhysicalDeviceLimits.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLimits.html
type PhysicalDeviceLimits C.struct_VkPhysicalDeviceLimits

// SizeofPhysicalDeviceLimits is the memory size of a PhysicalDeviceLimits
var SizeofPhysicalDeviceLimits int = int(unsafe.Sizeof(PhysicalDeviceLimits{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceLimits) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceLimits) AsCPtr() *PhysicalDeviceLimits {
	clone := (*PhysicalDeviceLimits)(newCBlock(C.ulong(SizeofPhysicalDeviceLimits)))
	*clone = x
	return clone
}

// PhysicalDeviceLimitsFreeCSlice releases the memory allocated by PhysicalDeviceLimitsMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceLimitsFreeCSlice(x []PhysicalDeviceLimits) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceLimitsMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceLimitsFreeCSlice must be called on the returned slice.
func PhysicalDeviceLimitsMakeCSlice(x ...PhysicalDeviceLimits) []PhysicalDeviceLimits {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceLimits * len(x)
	dst := unsafe.Slice((*PhysicalDeviceLimits)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// MaxImageDimension1D returns the value of maxImageDimension1D from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxImageDimension1D() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxImageDimension1D) 
	return *ptr
}

// MaxImageDimension2D returns the value of maxImageDimension2D from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxImageDimension2D() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxImageDimension2D) 
	return *ptr
}

// MaxImageDimension3D returns the value of maxImageDimension3D from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxImageDimension3D() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxImageDimension3D) 
	return *ptr
}

// MaxImageDimensionCube returns the value of maxImageDimensionCube from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxImageDimensionCube() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxImageDimensionCube) 
	return *ptr
}

// MaxImageArrayLayers returns the value of maxImageArrayLayers from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxImageArrayLayers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxImageArrayLayers) 
	return *ptr
}

// MaxTexelBufferElements returns the value of maxTexelBufferElements from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTexelBufferElements() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxTexelBufferElements) 
	return *ptr
}

// MaxUniformBufferRange returns the value of maxUniformBufferRange from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxUniformBufferRange() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxUniformBufferRange) 
	return *ptr
}

// MaxStorageBufferRange returns the value of maxStorageBufferRange from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxStorageBufferRange() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxStorageBufferRange) 
	return *ptr
}

// MaxPushConstantsSize returns the value of maxPushConstantsSize from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxPushConstantsSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPushConstantsSize) 
	return *ptr
}

// MaxMemoryAllocationCount returns the value of maxMemoryAllocationCount from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxMemoryAllocationCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxMemoryAllocationCount) 
	return *ptr
}

// MaxSamplerAllocationCount returns the value of maxSamplerAllocationCount from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxSamplerAllocationCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxSamplerAllocationCount) 
	return *ptr
}

// BufferImageGranularity returns the value of bufferImageGranularity from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) BufferImageGranularity() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.bufferImageGranularity) 
	return *ptr
}

// SparseAddressSpaceSize returns the value of sparseAddressSpaceSize from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) SparseAddressSpaceSize() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.sparseAddressSpaceSize) 
	return *ptr
}

// MaxBoundDescriptorSets returns the value of maxBoundDescriptorSets from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxBoundDescriptorSets() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxBoundDescriptorSets) 
	return *ptr
}

// MaxPerStageDescriptorSamplers returns the value of maxPerStageDescriptorSamplers from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxPerStageDescriptorSamplers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorSamplers) 
	return *ptr
}

// MaxPerStageDescriptorUniformBuffers returns the value of maxPerStageDescriptorUniformBuffers from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxPerStageDescriptorUniformBuffers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUniformBuffers) 
	return *ptr
}

// MaxPerStageDescriptorStorageBuffers returns the value of maxPerStageDescriptorStorageBuffers from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxPerStageDescriptorStorageBuffers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorStorageBuffers) 
	return *ptr
}

// MaxPerStageDescriptorSampledImages returns the value of maxPerStageDescriptorSampledImages from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxPerStageDescriptorSampledImages() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorSampledImages) 
	return *ptr
}

// MaxPerStageDescriptorStorageImages returns the value of maxPerStageDescriptorStorageImages from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxPerStageDescriptorStorageImages() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorStorageImages) 
	return *ptr
}

// MaxPerStageDescriptorInputAttachments returns the value of maxPerStageDescriptorInputAttachments from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxPerStageDescriptorInputAttachments() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorInputAttachments) 
	return *ptr
}

// MaxPerStageResources returns the value of maxPerStageResources from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxPerStageResources() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageResources) 
	return *ptr
}

// MaxDescriptorSetSamplers returns the value of maxDescriptorSetSamplers from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDescriptorSetSamplers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetSamplers) 
	return *ptr
}

// MaxDescriptorSetUniformBuffers returns the value of maxDescriptorSetUniformBuffers from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDescriptorSetUniformBuffers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUniformBuffers) 
	return *ptr
}

// MaxDescriptorSetUniformBuffersDynamic returns the value of maxDescriptorSetUniformBuffersDynamic from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDescriptorSetUniformBuffersDynamic() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUniformBuffersDynamic) 
	return *ptr
}

// MaxDescriptorSetStorageBuffers returns the value of maxDescriptorSetStorageBuffers from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDescriptorSetStorageBuffers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetStorageBuffers) 
	return *ptr
}

// MaxDescriptorSetStorageBuffersDynamic returns the value of maxDescriptorSetStorageBuffersDynamic from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDescriptorSetStorageBuffersDynamic() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetStorageBuffersDynamic) 
	return *ptr
}

// MaxDescriptorSetSampledImages returns the value of maxDescriptorSetSampledImages from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDescriptorSetSampledImages() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetSampledImages) 
	return *ptr
}

// MaxDescriptorSetStorageImages returns the value of maxDescriptorSetStorageImages from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDescriptorSetStorageImages() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetStorageImages) 
	return *ptr
}

// MaxDescriptorSetInputAttachments returns the value of maxDescriptorSetInputAttachments from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDescriptorSetInputAttachments() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetInputAttachments) 
	return *ptr
}

// MaxVertexInputAttributes returns the value of maxVertexInputAttributes from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxVertexInputAttributes() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxVertexInputAttributes) 
	return *ptr
}

// MaxVertexInputBindings returns the value of maxVertexInputBindings from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxVertexInputBindings() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxVertexInputBindings) 
	return *ptr
}

// MaxVertexInputAttributeOffset returns the value of maxVertexInputAttributeOffset from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxVertexInputAttributeOffset() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxVertexInputAttributeOffset) 
	return *ptr
}

// MaxVertexInputBindingStride returns the value of maxVertexInputBindingStride from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxVertexInputBindingStride() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxVertexInputBindingStride) 
	return *ptr
}

// MaxVertexOutputComponents returns the value of maxVertexOutputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxVertexOutputComponents() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxVertexOutputComponents) 
	return *ptr
}

// MaxTessellationGenerationLevel returns the value of maxTessellationGenerationLevel from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTessellationGenerationLevel() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxTessellationGenerationLevel) 
	return *ptr
}

// MaxTessellationPatchSize returns the value of maxTessellationPatchSize from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTessellationPatchSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxTessellationPatchSize) 
	return *ptr
}

// MaxTessellationControlPerVertexInputComponents returns the value of maxTessellationControlPerVertexInputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTessellationControlPerVertexInputComponents() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxTessellationControlPerVertexInputComponents) 
	return *ptr
}

// MaxTessellationControlPerVertexOutputComponents returns the value of maxTessellationControlPerVertexOutputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTessellationControlPerVertexOutputComponents() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxTessellationControlPerVertexOutputComponents) 
	return *ptr
}

// MaxTessellationControlPerPatchOutputComponents returns the value of maxTessellationControlPerPatchOutputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTessellationControlPerPatchOutputComponents() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxTessellationControlPerPatchOutputComponents) 
	return *ptr
}

// MaxTessellationControlTotalOutputComponents returns the value of maxTessellationControlTotalOutputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTessellationControlTotalOutputComponents() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxTessellationControlTotalOutputComponents) 
	return *ptr
}

// MaxTessellationEvaluationInputComponents returns the value of maxTessellationEvaluationInputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTessellationEvaluationInputComponents() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxTessellationEvaluationInputComponents) 
	return *ptr
}

// MaxTessellationEvaluationOutputComponents returns the value of maxTessellationEvaluationOutputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTessellationEvaluationOutputComponents() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxTessellationEvaluationOutputComponents) 
	return *ptr
}

// MaxGeometryShaderInvocations returns the value of maxGeometryShaderInvocations from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxGeometryShaderInvocations() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxGeometryShaderInvocations) 
	return *ptr
}

// MaxGeometryInputComponents returns the value of maxGeometryInputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxGeometryInputComponents() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxGeometryInputComponents) 
	return *ptr
}

// MaxGeometryOutputComponents returns the value of maxGeometryOutputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxGeometryOutputComponents() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxGeometryOutputComponents) 
	return *ptr
}

// MaxGeometryOutputVertices returns the value of maxGeometryOutputVertices from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxGeometryOutputVertices() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxGeometryOutputVertices) 
	return *ptr
}

// MaxGeometryTotalOutputComponents returns the value of maxGeometryTotalOutputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxGeometryTotalOutputComponents() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxGeometryTotalOutputComponents) 
	return *ptr
}

// MaxFragmentInputComponents returns the value of maxFragmentInputComponents from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxFragmentInputComponents() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxFragmentInputComponents) 
	return *ptr
}

// MaxFragmentOutputAttachments returns the value of maxFragmentOutputAttachments from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxFragmentOutputAttachments() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxFragmentOutputAttachments) 
	return *ptr
}

// MaxFragmentDualSrcAttachments returns the value of maxFragmentDualSrcAttachments from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxFragmentDualSrcAttachments() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxFragmentDualSrcAttachments) 
	return *ptr
}

// MaxFragmentCombinedOutputResources returns the value of maxFragmentCombinedOutputResources from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxFragmentCombinedOutputResources() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxFragmentCombinedOutputResources) 
	return *ptr
}

// MaxComputeSharedMemorySize returns the value of maxComputeSharedMemorySize from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxComputeSharedMemorySize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxComputeSharedMemorySize) 
	return *ptr
}

// MaxComputeWorkGroupCount returns the value of maxComputeWorkGroupCount from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxComputeWorkGroupCount() []uint32 {
	ptr := func(x *[3]C.uint32_t) *[]uint32 { /* Array */ slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), 3); return &slc }(&x.maxComputeWorkGroupCount) 
	return *ptr
}

// MaxComputeWorkGroupInvocations returns the value of maxComputeWorkGroupInvocations from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxComputeWorkGroupInvocations() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxComputeWorkGroupInvocations) 
	return *ptr
}

// MaxComputeWorkGroupSize returns the value of maxComputeWorkGroupSize from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxComputeWorkGroupSize() []uint32 {
	ptr := func(x *[3]C.uint32_t) *[]uint32 { /* Array */ slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), 3); return &slc }(&x.maxComputeWorkGroupSize) 
	return *ptr
}

// SubPixelPrecisionBits returns the value of subPixelPrecisionBits from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) SubPixelPrecisionBits() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.subPixelPrecisionBits) 
	return *ptr
}

// SubTexelPrecisionBits returns the value of subTexelPrecisionBits from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) SubTexelPrecisionBits() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.subTexelPrecisionBits) 
	return *ptr
}

// MipmapPrecisionBits returns the value of mipmapPrecisionBits from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MipmapPrecisionBits() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.mipmapPrecisionBits) 
	return *ptr
}

// MaxDrawIndexedIndexValue returns the value of maxDrawIndexedIndexValue from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDrawIndexedIndexValue() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDrawIndexedIndexValue) 
	return *ptr
}

// MaxDrawIndirectCount returns the value of maxDrawIndirectCount from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxDrawIndirectCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDrawIndirectCount) 
	return *ptr
}

// MaxSamplerLodBias returns the value of maxSamplerLodBias from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxSamplerLodBias() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.maxSamplerLodBias) 
	return *ptr
}

// MaxSamplerAnisotropy returns the value of maxSamplerAnisotropy from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxSamplerAnisotropy() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.maxSamplerAnisotropy) 
	return *ptr
}

// MaxViewports returns the value of maxViewports from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxViewports() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxViewports) 
	return *ptr
}

// MaxViewportDimensions returns the value of maxViewportDimensions from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxViewportDimensions() []uint32 {
	ptr := func(x *[2]C.uint32_t) *[]uint32 { /* Array */ slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), 2); return &slc }(&x.maxViewportDimensions) 
	return *ptr
}

// ViewportBoundsRange returns the value of viewportBoundsRange from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) ViewportBoundsRange() []float32 {
	ptr := func(x *[2]C.float) *[]float32 { /* Array */ slc := unsafe.Slice((*float32)(unsafe.Pointer(x)), 2); return &slc }(&x.viewportBoundsRange) 
	return *ptr
}

// ViewportSubPixelBits returns the value of viewportSubPixelBits from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) ViewportSubPixelBits() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.viewportSubPixelBits) 
	return *ptr
}

// MinMemoryMapAlignment returns the value of minMemoryMapAlignment from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MinMemoryMapAlignment() uint64 {
	ptr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.minMemoryMapAlignment) 
	return *ptr
}

// MinTexelBufferOffsetAlignment returns the value of minTexelBufferOffsetAlignment from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MinTexelBufferOffsetAlignment() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.minTexelBufferOffsetAlignment) 
	return *ptr
}

// MinUniformBufferOffsetAlignment returns the value of minUniformBufferOffsetAlignment from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MinUniformBufferOffsetAlignment() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.minUniformBufferOffsetAlignment) 
	return *ptr
}

// MinStorageBufferOffsetAlignment returns the value of minStorageBufferOffsetAlignment from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MinStorageBufferOffsetAlignment() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.minStorageBufferOffsetAlignment) 
	return *ptr
}

// MinTexelOffset returns the value of minTexelOffset from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MinTexelOffset() int32 {
	ptr := func(x *C.int32_t) *int32 { /* Scalar */ c2g := int32(*x); return &c2g }(&x.minTexelOffset) 
	return *ptr
}

// MaxTexelOffset returns the value of maxTexelOffset from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTexelOffset() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxTexelOffset) 
	return *ptr
}

// MinTexelGatherOffset returns the value of minTexelGatherOffset from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MinTexelGatherOffset() int32 {
	ptr := func(x *C.int32_t) *int32 { /* Scalar */ c2g := int32(*x); return &c2g }(&x.minTexelGatherOffset) 
	return *ptr
}

// MaxTexelGatherOffset returns the value of maxTexelGatherOffset from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxTexelGatherOffset() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxTexelGatherOffset) 
	return *ptr
}

// MinInterpolationOffset returns the value of minInterpolationOffset from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MinInterpolationOffset() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.minInterpolationOffset) 
	return *ptr
}

// MaxInterpolationOffset returns the value of maxInterpolationOffset from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxInterpolationOffset() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.maxInterpolationOffset) 
	return *ptr
}

// SubPixelInterpolationOffsetBits returns the value of subPixelInterpolationOffsetBits from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) SubPixelInterpolationOffsetBits() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.subPixelInterpolationOffsetBits) 
	return *ptr
}

// MaxFramebufferWidth returns the value of maxFramebufferWidth from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxFramebufferWidth() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxFramebufferWidth) 
	return *ptr
}

// MaxFramebufferHeight returns the value of maxFramebufferHeight from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxFramebufferHeight() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxFramebufferHeight) 
	return *ptr
}

// MaxFramebufferLayers returns the value of maxFramebufferLayers from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxFramebufferLayers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxFramebufferLayers) 
	return *ptr
}

// FramebufferColorSampleCounts returns the value of framebufferColorSampleCounts from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) FramebufferColorSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.framebufferColorSampleCounts) 
	return *ptr
}

// FramebufferDepthSampleCounts returns the value of framebufferDepthSampleCounts from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) FramebufferDepthSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.framebufferDepthSampleCounts) 
	return *ptr
}

// FramebufferStencilSampleCounts returns the value of framebufferStencilSampleCounts from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) FramebufferStencilSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.framebufferStencilSampleCounts) 
	return *ptr
}

// FramebufferNoAttachmentsSampleCounts returns the value of framebufferNoAttachmentsSampleCounts from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) FramebufferNoAttachmentsSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.framebufferNoAttachmentsSampleCounts) 
	return *ptr
}

// MaxColorAttachments returns the value of maxColorAttachments from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxColorAttachments() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxColorAttachments) 
	return *ptr
}

// SampledImageColorSampleCounts returns the value of sampledImageColorSampleCounts from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) SampledImageColorSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.sampledImageColorSampleCounts) 
	return *ptr
}

// SampledImageIntegerSampleCounts returns the value of sampledImageIntegerSampleCounts from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) SampledImageIntegerSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.sampledImageIntegerSampleCounts) 
	return *ptr
}

// SampledImageDepthSampleCounts returns the value of sampledImageDepthSampleCounts from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) SampledImageDepthSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.sampledImageDepthSampleCounts) 
	return *ptr
}

// SampledImageStencilSampleCounts returns the value of sampledImageStencilSampleCounts from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) SampledImageStencilSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.sampledImageStencilSampleCounts) 
	return *ptr
}

// StorageImageSampleCounts returns the value of storageImageSampleCounts from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) StorageImageSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.storageImageSampleCounts) 
	return *ptr
}

// MaxSampleMaskWords returns the value of maxSampleMaskWords from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxSampleMaskWords() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxSampleMaskWords) 
	return *ptr
}

// TimestampComputeAndGraphics returns the value of timestampComputeAndGraphics from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) TimestampComputeAndGraphics() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.timestampComputeAndGraphics) 
	return *ptr
}

// TimestampPeriod returns the value of timestampPeriod from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) TimestampPeriod() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.timestampPeriod) 
	return *ptr
}

// MaxClipDistances returns the value of maxClipDistances from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxClipDistances() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxClipDistances) 
	return *ptr
}

// MaxCullDistances returns the value of maxCullDistances from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxCullDistances() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxCullDistances) 
	return *ptr
}

// MaxCombinedClipAndCullDistances returns the value of maxCombinedClipAndCullDistances from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) MaxCombinedClipAndCullDistances() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxCombinedClipAndCullDistances) 
	return *ptr
}

// DiscreteQueuePriorities returns the value of discreteQueuePriorities from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) DiscreteQueuePriorities() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.discreteQueuePriorities) 
	return *ptr
}

// PointSizeRange returns the value of pointSizeRange from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) PointSizeRange() []float32 {
	ptr := func(x *[2]C.float) *[]float32 { /* Array */ slc := unsafe.Slice((*float32)(unsafe.Pointer(x)), 2); return &slc }(&x.pointSizeRange) 
	return *ptr
}

// LineWidthRange returns the value of lineWidthRange from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) LineWidthRange() []float32 {
	ptr := func(x *[2]C.float) *[]float32 { /* Array */ slc := unsafe.Slice((*float32)(unsafe.Pointer(x)), 2); return &slc }(&x.lineWidthRange) 
	return *ptr
}

// PointSizeGranularity returns the value of pointSizeGranularity from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) PointSizeGranularity() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.pointSizeGranularity) 
	return *ptr
}

// LineWidthGranularity returns the value of lineWidthGranularity from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) LineWidthGranularity() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.lineWidthGranularity) 
	return *ptr
}

// StrictLines returns the value of strictLines from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) StrictLines() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.strictLines) 
	return *ptr
}

// StandardSampleLocations returns the value of standardSampleLocations from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) StandardSampleLocations() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.standardSampleLocations) 
	return *ptr
}

// OptimalBufferCopyOffsetAlignment returns the value of optimalBufferCopyOffsetAlignment from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) OptimalBufferCopyOffsetAlignment() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.optimalBufferCopyOffsetAlignment) 
	return *ptr
}

// OptimalBufferCopyRowPitchAlignment returns the value of optimalBufferCopyRowPitchAlignment from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) OptimalBufferCopyRowPitchAlignment() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.optimalBufferCopyRowPitchAlignment) 
	return *ptr
}

// NonCoherentAtomSize returns the value of nonCoherentAtomSize from VkPhysicalDeviceLimits
func (x PhysicalDeviceLimits) NonCoherentAtomSize() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.nonCoherentAtomSize) 
	return *ptr
}

// SpecializationInfo provides a go interface for VkSpecializationInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSpecializationInfo.html
type SpecializationInfo C.struct_VkSpecializationInfo

// SizeofSpecializationInfo is the memory size of a SpecializationInfo
var SizeofSpecializationInfo int = int(unsafe.Sizeof(SpecializationInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SpecializationInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SpecializationInfo) AsCPtr() *SpecializationInfo {
	clone := (*SpecializationInfo)(newCBlock(C.ulong(SizeofSpecializationInfo)))
	*clone = x
	return clone
}

// SpecializationInfoFreeCSlice releases the memory allocated by SpecializationInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SpecializationInfoFreeCSlice(x []SpecializationInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SpecializationInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SpecializationInfoFreeCSlice must be called on the returned slice.
func SpecializationInfoMakeCSlice(x ...SpecializationInfo) []SpecializationInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSpecializationInfo * len(x)
	dst := unsafe.Slice((*SpecializationInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// MapEntryCount returns the value of mapEntryCount from VkSpecializationInfo
func (x SpecializationInfo) MapEntryCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.mapEntryCount) 
	return *ptr
}

// WithMapEntryCount sets the value for the MapEntryCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SpecializationInfo) WithMapEntryCount(y uint32) SpecializationInfo {
	x.mapEntryCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PMapEntries returns the value of pMapEntries from VkSpecializationInfo
func (x SpecializationInfo) PMapEntries() []SpecializationMapEntry {
	ptr := func(x **C.struct_VkSpecializationMapEntry) *[]SpecializationMapEntry { /* Slice */ slc := unsafe.Slice((*SpecializationMapEntry)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pMapEntries) 
	return *ptr
}

// WithPMapEntries sets the value for the PMapEntries on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines MapEntryCount as the length of this field.
// MapEntryCount is updated with the length of the new value.
func (x SpecializationInfo) WithPMapEntries(y []SpecializationMapEntry) SpecializationInfo {
	x.pMapEntries = *(func(x *[]SpecializationMapEntry) **C.struct_VkSpecializationMapEntry { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkSpecializationMapEntry)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkSpecializationMapEntry)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithMapEntryCount(uint32(len(y)))
}

// DataSize returns the value of dataSize from VkSpecializationInfo
func (x SpecializationInfo) DataSize() uint64 {
	ptr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.dataSize) 
	return *ptr
}

// WithDataSize sets the value for the DataSize on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SpecializationInfo) WithDataSize(y uint64) SpecializationInfo {
	x.dataSize = *(func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&y))
	return x
}

// PData returns the value of pData from VkSpecializationInfo
func (x SpecializationInfo) PData() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pData) 
	return *ptr
}

// WithPData sets the value for the PData on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SpecializationInfo) WithPData(y unsafe.Pointer) SpecializationInfo {
	x.pData = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SpecializationMapEntry provides a go interface for VkSpecializationMapEntry.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSpecializationMapEntry.html
type SpecializationMapEntry C.struct_VkSpecializationMapEntry

// SizeofSpecializationMapEntry is the memory size of a SpecializationMapEntry
var SizeofSpecializationMapEntry int = int(unsafe.Sizeof(SpecializationMapEntry{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SpecializationMapEntry) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SpecializationMapEntry) AsCPtr() *SpecializationMapEntry {
	clone := (*SpecializationMapEntry)(newCBlock(C.ulong(SizeofSpecializationMapEntry)))
	*clone = x
	return clone
}

// SpecializationMapEntryFreeCSlice releases the memory allocated by SpecializationMapEntryMakeCSlice.
// It does not free pointers stored inside the slice.
func SpecializationMapEntryFreeCSlice(x []SpecializationMapEntry) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SpecializationMapEntryMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SpecializationMapEntryFreeCSlice must be called on the returned slice.
func SpecializationMapEntryMakeCSlice(x ...SpecializationMapEntry) []SpecializationMapEntry {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSpecializationMapEntry * len(x)
	dst := unsafe.Slice((*SpecializationMapEntry)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// ConstantID returns the value of constantID from VkSpecializationMapEntry
func (x SpecializationMapEntry) ConstantID() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.constantID) 
	return *ptr
}

// WithConstantID sets the value for the ConstantID on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SpecializationMapEntry) WithConstantID(y uint32) SpecializationMapEntry {
	x.constantID = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// Offset returns the value of offset from VkSpecializationMapEntry
func (x SpecializationMapEntry) Offset() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.offset) 
	return *ptr
}

// WithOffset sets the value for the Offset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SpecializationMapEntry) WithOffset(y uint32) SpecializationMapEntry {
	x.offset = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// Size returns the value of size from VkSpecializationMapEntry
func (x SpecializationMapEntry) Size() uint64 {
	ptr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.size) 
	return *ptr
}

// WithSize sets the value for the Size on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SpecializationMapEntry) WithSize(y uint64) SpecializationMapEntry {
	x.size = *(func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&y))
	return x
}

// PhysicalDeviceFeatures provides a go interface for VkPhysicalDeviceFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html
type PhysicalDeviceFeatures C.struct_VkPhysicalDeviceFeatures

// SizeofPhysicalDeviceFeatures is the memory size of a PhysicalDeviceFeatures
var SizeofPhysicalDeviceFeatures int = int(unsafe.Sizeof(PhysicalDeviceFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceFeatures) AsCPtr() *PhysicalDeviceFeatures {
	clone := (*PhysicalDeviceFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceFeaturesFreeCSlice(x []PhysicalDeviceFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceFeaturesMakeCSlice(x ...PhysicalDeviceFeatures) []PhysicalDeviceFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// RobustBufferAccess returns the value of robustBufferAccess from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) RobustBufferAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.robustBufferAccess) 
	return *ptr
}

// WithRobustBufferAccess sets the value for the RobustBufferAccess on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithRobustBufferAccess(y Bool32) PhysicalDeviceFeatures {
	x.robustBufferAccess = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// FullDrawIndexUint32 returns the value of fullDrawIndexUint32 from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) FullDrawIndexUint32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.fullDrawIndexUint32) 
	return *ptr
}

// WithFullDrawIndexUint32 sets the value for the FullDrawIndexUint32 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithFullDrawIndexUint32(y Bool32) PhysicalDeviceFeatures {
	x.fullDrawIndexUint32 = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ImageCubeArray returns the value of imageCubeArray from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ImageCubeArray() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.imageCubeArray) 
	return *ptr
}

// WithImageCubeArray sets the value for the ImageCubeArray on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithImageCubeArray(y Bool32) PhysicalDeviceFeatures {
	x.imageCubeArray = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// IndependentBlend returns the value of independentBlend from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) IndependentBlend() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.independentBlend) 
	return *ptr
}

// WithIndependentBlend sets the value for the IndependentBlend on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithIndependentBlend(y Bool32) PhysicalDeviceFeatures {
	x.independentBlend = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// GeometryShader returns the value of geometryShader from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) GeometryShader() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.geometryShader) 
	return *ptr
}

// WithGeometryShader sets the value for the GeometryShader on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithGeometryShader(y Bool32) PhysicalDeviceFeatures {
	x.geometryShader = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// TessellationShader returns the value of tessellationShader from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) TessellationShader() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.tessellationShader) 
	return *ptr
}

// WithTessellationShader sets the value for the TessellationShader on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithTessellationShader(y Bool32) PhysicalDeviceFeatures {
	x.tessellationShader = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// SampleRateShading returns the value of sampleRateShading from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SampleRateShading() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sampleRateShading) 
	return *ptr
}

// WithSampleRateShading sets the value for the SampleRateShading on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSampleRateShading(y Bool32) PhysicalDeviceFeatures {
	x.sampleRateShading = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DualSrcBlend returns the value of dualSrcBlend from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) DualSrcBlend() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.dualSrcBlend) 
	return *ptr
}

// WithDualSrcBlend sets the value for the DualSrcBlend on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithDualSrcBlend(y Bool32) PhysicalDeviceFeatures {
	x.dualSrcBlend = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// LogicOp returns the value of logicOp from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) LogicOp() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.logicOp) 
	return *ptr
}

// WithLogicOp sets the value for the LogicOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithLogicOp(y Bool32) PhysicalDeviceFeatures {
	x.logicOp = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// MultiDrawIndirect returns the value of multiDrawIndirect from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) MultiDrawIndirect() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.multiDrawIndirect) 
	return *ptr
}

// WithMultiDrawIndirect sets the value for the MultiDrawIndirect on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithMultiDrawIndirect(y Bool32) PhysicalDeviceFeatures {
	x.multiDrawIndirect = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DrawIndirectFirstInstance returns the value of drawIndirectFirstInstance from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) DrawIndirectFirstInstance() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.drawIndirectFirstInstance) 
	return *ptr
}

// WithDrawIndirectFirstInstance sets the value for the DrawIndirectFirstInstance on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithDrawIndirectFirstInstance(y Bool32) PhysicalDeviceFeatures {
	x.drawIndirectFirstInstance = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DepthClamp returns the value of depthClamp from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) DepthClamp() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.depthClamp) 
	return *ptr
}

// WithDepthClamp sets the value for the DepthClamp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithDepthClamp(y Bool32) PhysicalDeviceFeatures {
	x.depthClamp = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DepthBiasClamp returns the value of depthBiasClamp from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) DepthBiasClamp() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.depthBiasClamp) 
	return *ptr
}

// WithDepthBiasClamp sets the value for the DepthBiasClamp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithDepthBiasClamp(y Bool32) PhysicalDeviceFeatures {
	x.depthBiasClamp = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// FillModeNonSolid returns the value of fillModeNonSolid from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) FillModeNonSolid() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.fillModeNonSolid) 
	return *ptr
}

// WithFillModeNonSolid sets the value for the FillModeNonSolid on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithFillModeNonSolid(y Bool32) PhysicalDeviceFeatures {
	x.fillModeNonSolid = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DepthBounds returns the value of depthBounds from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) DepthBounds() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.depthBounds) 
	return *ptr
}

// WithDepthBounds sets the value for the DepthBounds on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithDepthBounds(y Bool32) PhysicalDeviceFeatures {
	x.depthBounds = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// WideLines returns the value of wideLines from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) WideLines() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.wideLines) 
	return *ptr
}

// WithWideLines sets the value for the WideLines on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithWideLines(y Bool32) PhysicalDeviceFeatures {
	x.wideLines = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// LargePoints returns the value of largePoints from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) LargePoints() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.largePoints) 
	return *ptr
}

// WithLargePoints sets the value for the LargePoints on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithLargePoints(y Bool32) PhysicalDeviceFeatures {
	x.largePoints = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// AlphaToOne returns the value of alphaToOne from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) AlphaToOne() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.alphaToOne) 
	return *ptr
}

// WithAlphaToOne sets the value for the AlphaToOne on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithAlphaToOne(y Bool32) PhysicalDeviceFeatures {
	x.alphaToOne = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// MultiViewport returns the value of multiViewport from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) MultiViewport() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.multiViewport) 
	return *ptr
}

// WithMultiViewport sets the value for the MultiViewport on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithMultiViewport(y Bool32) PhysicalDeviceFeatures {
	x.multiViewport = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// SamplerAnisotropy returns the value of samplerAnisotropy from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SamplerAnisotropy() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.samplerAnisotropy) 
	return *ptr
}

// WithSamplerAnisotropy sets the value for the SamplerAnisotropy on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSamplerAnisotropy(y Bool32) PhysicalDeviceFeatures {
	x.samplerAnisotropy = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// TextureCompressionETC2 returns the value of textureCompressionETC2 from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) TextureCompressionETC2() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.textureCompressionETC2) 
	return *ptr
}

// WithTextureCompressionETC2 sets the value for the TextureCompressionETC2 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithTextureCompressionETC2(y Bool32) PhysicalDeviceFeatures {
	x.textureCompressionETC2 = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// TextureCompressionASTC_LDR returns the value of textureCompressionASTC_LDR from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) TextureCompressionASTC_LDR() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.textureCompressionASTC_LDR) 
	return *ptr
}

// WithTextureCompressionASTC_LDR sets the value for the TextureCompressionASTC_LDR on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithTextureCompressionASTC_LDR(y Bool32) PhysicalDeviceFeatures {
	x.textureCompressionASTC_LDR = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// TextureCompressionBC returns the value of textureCompressionBC from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) TextureCompressionBC() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.textureCompressionBC) 
	return *ptr
}

// WithTextureCompressionBC sets the value for the TextureCompressionBC on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithTextureCompressionBC(y Bool32) PhysicalDeviceFeatures {
	x.textureCompressionBC = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// OcclusionQueryPrecise returns the value of occlusionQueryPrecise from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) OcclusionQueryPrecise() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.occlusionQueryPrecise) 
	return *ptr
}

// WithOcclusionQueryPrecise sets the value for the OcclusionQueryPrecise on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithOcclusionQueryPrecise(y Bool32) PhysicalDeviceFeatures {
	x.occlusionQueryPrecise = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// PipelineStatisticsQuery returns the value of pipelineStatisticsQuery from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) PipelineStatisticsQuery() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.pipelineStatisticsQuery) 
	return *ptr
}

// WithPipelineStatisticsQuery sets the value for the PipelineStatisticsQuery on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithPipelineStatisticsQuery(y Bool32) PhysicalDeviceFeatures {
	x.pipelineStatisticsQuery = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// VertexPipelineStoresAndAtomics returns the value of vertexPipelineStoresAndAtomics from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) VertexPipelineStoresAndAtomics() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.vertexPipelineStoresAndAtomics) 
	return *ptr
}

// WithVertexPipelineStoresAndAtomics sets the value for the VertexPipelineStoresAndAtomics on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithVertexPipelineStoresAndAtomics(y Bool32) PhysicalDeviceFeatures {
	x.vertexPipelineStoresAndAtomics = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// FragmentStoresAndAtomics returns the value of fragmentStoresAndAtomics from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) FragmentStoresAndAtomics() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.fragmentStoresAndAtomics) 
	return *ptr
}

// WithFragmentStoresAndAtomics sets the value for the FragmentStoresAndAtomics on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithFragmentStoresAndAtomics(y Bool32) PhysicalDeviceFeatures {
	x.fragmentStoresAndAtomics = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderTessellationAndGeometryPointSize returns the value of shaderTessellationAndGeometryPointSize from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderTessellationAndGeometryPointSize() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderTessellationAndGeometryPointSize) 
	return *ptr
}

// WithShaderTessellationAndGeometryPointSize sets the value for the ShaderTessellationAndGeometryPointSize on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderTessellationAndGeometryPointSize(y Bool32) PhysicalDeviceFeatures {
	x.shaderTessellationAndGeometryPointSize = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderImageGatherExtended returns the value of shaderImageGatherExtended from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderImageGatherExtended() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderImageGatherExtended) 
	return *ptr
}

// WithShaderImageGatherExtended sets the value for the ShaderImageGatherExtended on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderImageGatherExtended(y Bool32) PhysicalDeviceFeatures {
	x.shaderImageGatherExtended = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderStorageImageExtendedFormats returns the value of shaderStorageImageExtendedFormats from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderStorageImageExtendedFormats() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageImageExtendedFormats) 
	return *ptr
}

// WithShaderStorageImageExtendedFormats sets the value for the ShaderStorageImageExtendedFormats on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderStorageImageExtendedFormats(y Bool32) PhysicalDeviceFeatures {
	x.shaderStorageImageExtendedFormats = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderStorageImageMultisample returns the value of shaderStorageImageMultisample from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderStorageImageMultisample() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageImageMultisample) 
	return *ptr
}

// WithShaderStorageImageMultisample sets the value for the ShaderStorageImageMultisample on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderStorageImageMultisample(y Bool32) PhysicalDeviceFeatures {
	x.shaderStorageImageMultisample = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderStorageImageReadWithoutFormat returns the value of shaderStorageImageReadWithoutFormat from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderStorageImageReadWithoutFormat() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageImageReadWithoutFormat) 
	return *ptr
}

// WithShaderStorageImageReadWithoutFormat sets the value for the ShaderStorageImageReadWithoutFormat on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderStorageImageReadWithoutFormat(y Bool32) PhysicalDeviceFeatures {
	x.shaderStorageImageReadWithoutFormat = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderStorageImageWriteWithoutFormat returns the value of shaderStorageImageWriteWithoutFormat from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderStorageImageWriteWithoutFormat() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageImageWriteWithoutFormat) 
	return *ptr
}

// WithShaderStorageImageWriteWithoutFormat sets the value for the ShaderStorageImageWriteWithoutFormat on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderStorageImageWriteWithoutFormat(y Bool32) PhysicalDeviceFeatures {
	x.shaderStorageImageWriteWithoutFormat = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderUniformBufferArrayDynamicIndexing returns the value of shaderUniformBufferArrayDynamicIndexing from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderUniformBufferArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderUniformBufferArrayDynamicIndexing) 
	return *ptr
}

// WithShaderUniformBufferArrayDynamicIndexing sets the value for the ShaderUniformBufferArrayDynamicIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderUniformBufferArrayDynamicIndexing(y Bool32) PhysicalDeviceFeatures {
	x.shaderUniformBufferArrayDynamicIndexing = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderSampledImageArrayDynamicIndexing returns the value of shaderSampledImageArrayDynamicIndexing from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderSampledImageArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSampledImageArrayDynamicIndexing) 
	return *ptr
}

// WithShaderSampledImageArrayDynamicIndexing sets the value for the ShaderSampledImageArrayDynamicIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderSampledImageArrayDynamicIndexing(y Bool32) PhysicalDeviceFeatures {
	x.shaderSampledImageArrayDynamicIndexing = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderStorageBufferArrayDynamicIndexing returns the value of shaderStorageBufferArrayDynamicIndexing from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderStorageBufferArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageBufferArrayDynamicIndexing) 
	return *ptr
}

// WithShaderStorageBufferArrayDynamicIndexing sets the value for the ShaderStorageBufferArrayDynamicIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderStorageBufferArrayDynamicIndexing(y Bool32) PhysicalDeviceFeatures {
	x.shaderStorageBufferArrayDynamicIndexing = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderStorageImageArrayDynamicIndexing returns the value of shaderStorageImageArrayDynamicIndexing from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderStorageImageArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageImageArrayDynamicIndexing) 
	return *ptr
}

// WithShaderStorageImageArrayDynamicIndexing sets the value for the ShaderStorageImageArrayDynamicIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderStorageImageArrayDynamicIndexing(y Bool32) PhysicalDeviceFeatures {
	x.shaderStorageImageArrayDynamicIndexing = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderClipDistance returns the value of shaderClipDistance from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderClipDistance() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderClipDistance) 
	return *ptr
}

// WithShaderClipDistance sets the value for the ShaderClipDistance on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderClipDistance(y Bool32) PhysicalDeviceFeatures {
	x.shaderClipDistance = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderCullDistance returns the value of shaderCullDistance from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderCullDistance() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderCullDistance) 
	return *ptr
}

// WithShaderCullDistance sets the value for the ShaderCullDistance on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderCullDistance(y Bool32) PhysicalDeviceFeatures {
	x.shaderCullDistance = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderFloat64 returns the value of shaderFloat64 from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderFloat64) 
	return *ptr
}

// WithShaderFloat64 sets the value for the ShaderFloat64 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderFloat64(y Bool32) PhysicalDeviceFeatures {
	x.shaderFloat64 = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderInt64 returns the value of shaderInt64 from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderInt64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInt64) 
	return *ptr
}

// WithShaderInt64 sets the value for the ShaderInt64 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderInt64(y Bool32) PhysicalDeviceFeatures {
	x.shaderInt64 = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderInt16 returns the value of shaderInt16 from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderInt16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInt16) 
	return *ptr
}

// WithShaderInt16 sets the value for the ShaderInt16 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderInt16(y Bool32) PhysicalDeviceFeatures {
	x.shaderInt16 = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderResourceResidency returns the value of shaderResourceResidency from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderResourceResidency() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderResourceResidency) 
	return *ptr
}

// WithShaderResourceResidency sets the value for the ShaderResourceResidency on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderResourceResidency(y Bool32) PhysicalDeviceFeatures {
	x.shaderResourceResidency = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderResourceMinLod returns the value of shaderResourceMinLod from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) ShaderResourceMinLod() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderResourceMinLod) 
	return *ptr
}

// WithShaderResourceMinLod sets the value for the ShaderResourceMinLod on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithShaderResourceMinLod(y Bool32) PhysicalDeviceFeatures {
	x.shaderResourceMinLod = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// SparseBinding returns the value of sparseBinding from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SparseBinding() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sparseBinding) 
	return *ptr
}

// WithSparseBinding sets the value for the SparseBinding on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSparseBinding(y Bool32) PhysicalDeviceFeatures {
	x.sparseBinding = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// SparseResidencyBuffer returns the value of sparseResidencyBuffer from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SparseResidencyBuffer() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sparseResidencyBuffer) 
	return *ptr
}

// WithSparseResidencyBuffer sets the value for the SparseResidencyBuffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSparseResidencyBuffer(y Bool32) PhysicalDeviceFeatures {
	x.sparseResidencyBuffer = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// SparseResidencyImage2D returns the value of sparseResidencyImage2D from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SparseResidencyImage2D() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sparseResidencyImage2D) 
	return *ptr
}

// WithSparseResidencyImage2D sets the value for the SparseResidencyImage2D on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSparseResidencyImage2D(y Bool32) PhysicalDeviceFeatures {
	x.sparseResidencyImage2D = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// SparseResidencyImage3D returns the value of sparseResidencyImage3D from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SparseResidencyImage3D() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sparseResidencyImage3D) 
	return *ptr
}

// WithSparseResidencyImage3D sets the value for the SparseResidencyImage3D on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSparseResidencyImage3D(y Bool32) PhysicalDeviceFeatures {
	x.sparseResidencyImage3D = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// SparseResidency2Samples returns the value of sparseResidency2Samples from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SparseResidency2Samples() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sparseResidency2Samples) 
	return *ptr
}

// WithSparseResidency2Samples sets the value for the SparseResidency2Samples on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSparseResidency2Samples(y Bool32) PhysicalDeviceFeatures {
	x.sparseResidency2Samples = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// SparseResidency4Samples returns the value of sparseResidency4Samples from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SparseResidency4Samples() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sparseResidency4Samples) 
	return *ptr
}

// WithSparseResidency4Samples sets the value for the SparseResidency4Samples on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSparseResidency4Samples(y Bool32) PhysicalDeviceFeatures {
	x.sparseResidency4Samples = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// SparseResidency8Samples returns the value of sparseResidency8Samples from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SparseResidency8Samples() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sparseResidency8Samples) 
	return *ptr
}

// WithSparseResidency8Samples sets the value for the SparseResidency8Samples on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSparseResidency8Samples(y Bool32) PhysicalDeviceFeatures {
	x.sparseResidency8Samples = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// SparseResidency16Samples returns the value of sparseResidency16Samples from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SparseResidency16Samples() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sparseResidency16Samples) 
	return *ptr
}

// WithSparseResidency16Samples sets the value for the SparseResidency16Samples on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSparseResidency16Samples(y Bool32) PhysicalDeviceFeatures {
	x.sparseResidency16Samples = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// SparseResidencyAliased returns the value of sparseResidencyAliased from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) SparseResidencyAliased() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.sparseResidencyAliased) 
	return *ptr
}

// WithSparseResidencyAliased sets the value for the SparseResidencyAliased on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithSparseResidencyAliased(y Bool32) PhysicalDeviceFeatures {
	x.sparseResidencyAliased = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// VariableMultisampleRate returns the value of variableMultisampleRate from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) VariableMultisampleRate() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.variableMultisampleRate) 
	return *ptr
}

// WithVariableMultisampleRate sets the value for the VariableMultisampleRate on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithVariableMultisampleRate(y Bool32) PhysicalDeviceFeatures {
	x.variableMultisampleRate = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// InheritedQueries returns the value of inheritedQueries from VkPhysicalDeviceFeatures
func (x PhysicalDeviceFeatures) InheritedQueries() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.inheritedQueries) 
	return *ptr
}

// WithInheritedQueries sets the value for the InheritedQueries on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures) WithInheritedQueries(y Bool32) PhysicalDeviceFeatures {
	x.inheritedQueries = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// StencilOpState provides a go interface for VkStencilOpState.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkStencilOpState.html
type StencilOpState C.struct_VkStencilOpState

// SizeofStencilOpState is the memory size of a StencilOpState
var SizeofStencilOpState int = int(unsafe.Sizeof(StencilOpState{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *StencilOpState) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x StencilOpState) AsCPtr() *StencilOpState {
	clone := (*StencilOpState)(newCBlock(C.ulong(SizeofStencilOpState)))
	*clone = x
	return clone
}

// StencilOpStateFreeCSlice releases the memory allocated by StencilOpStateMakeCSlice.
// It does not free pointers stored inside the slice.
func StencilOpStateFreeCSlice(x []StencilOpState) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// StencilOpStateMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. StencilOpStateFreeCSlice must be called on the returned slice.
func StencilOpStateMakeCSlice(x ...StencilOpState) []StencilOpState {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofStencilOpState * len(x)
	dst := unsafe.Slice((*StencilOpState)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// FailOp returns the value of failOp from VkStencilOpState
func (x StencilOpState) FailOp() StencilOp {
	ptr := /* typedef */ (*StencilOp)(&x.failOp) 
	return *ptr
}

// WithFailOp sets the value for the FailOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x StencilOpState) WithFailOp(y StencilOp) StencilOpState {
	x.failOp = *(/* typedef */ (*C.VkStencilOp)(&y))
	return x
}

// PassOp returns the value of passOp from VkStencilOpState
func (x StencilOpState) PassOp() StencilOp {
	ptr := /* typedef */ (*StencilOp)(&x.passOp) 
	return *ptr
}

// WithPassOp sets the value for the PassOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x StencilOpState) WithPassOp(y StencilOp) StencilOpState {
	x.passOp = *(/* typedef */ (*C.VkStencilOp)(&y))
	return x
}

// DepthFailOp returns the value of depthFailOp from VkStencilOpState
func (x StencilOpState) DepthFailOp() StencilOp {
	ptr := /* typedef */ (*StencilOp)(&x.depthFailOp) 
	return *ptr
}

// WithDepthFailOp sets the value for the DepthFailOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x StencilOpState) WithDepthFailOp(y StencilOp) StencilOpState {
	x.depthFailOp = *(/* typedef */ (*C.VkStencilOp)(&y))
	return x
}

// CompareOp returns the value of compareOp from VkStencilOpState
func (x StencilOpState) CompareOp() CompareOp {
	ptr := /* typedef */ (*CompareOp)(&x.compareOp) 
	return *ptr
}

// WithCompareOp sets the value for the CompareOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x StencilOpState) WithCompareOp(y CompareOp) StencilOpState {
	x.compareOp = *(/* typedef */ (*C.VkCompareOp)(&y))
	return x
}

// CompareMask returns the value of compareMask from VkStencilOpState
func (x StencilOpState) CompareMask() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.compareMask) 
	return *ptr
}

// WithCompareMask sets the value for the CompareMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x StencilOpState) WithCompareMask(y uint32) StencilOpState {
	x.compareMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// WriteMask returns the value of writeMask from VkStencilOpState
func (x StencilOpState) WriteMask() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.writeMask) 
	return *ptr
}

// WithWriteMask sets the value for the WriteMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x StencilOpState) WithWriteMask(y uint32) StencilOpState {
	x.writeMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// Reference returns the value of reference from VkStencilOpState
func (x StencilOpState) Reference() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.reference) 
	return *ptr
}

// WithReference sets the value for the Reference on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x StencilOpState) WithReference(y uint32) StencilOpState {
	x.reference = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// VertexInputAttributeDescription provides a go interface for VkVertexInputAttributeDescription.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVertexInputAttributeDescription.html
type VertexInputAttributeDescription C.struct_VkVertexInputAttributeDescription

// SizeofVertexInputAttributeDescription is the memory size of a VertexInputAttributeDescription
var SizeofVertexInputAttributeDescription int = int(unsafe.Sizeof(VertexInputAttributeDescription{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *VertexInputAttributeDescription) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x VertexInputAttributeDescription) AsCPtr() *VertexInputAttributeDescription {
	clone := (*VertexInputAttributeDescription)(newCBlock(C.ulong(SizeofVertexInputAttributeDescription)))
	*clone = x
	return clone
}

// VertexInputAttributeDescriptionFreeCSlice releases the memory allocated by VertexInputAttributeDescriptionMakeCSlice.
// It does not free pointers stored inside the slice.
func VertexInputAttributeDescriptionFreeCSlice(x []VertexInputAttributeDescription) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// VertexInputAttributeDescriptionMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. VertexInputAttributeDescriptionFreeCSlice must be called on the returned slice.
func VertexInputAttributeDescriptionMakeCSlice(x ...VertexInputAttributeDescription) []VertexInputAttributeDescription {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofVertexInputAttributeDescription * len(x)
	dst := unsafe.Slice((*VertexInputAttributeDescription)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Location returns the value of location from VkVertexInputAttributeDescription
func (x VertexInputAttributeDescription) Location() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.location) 
	return *ptr
}

// WithLocation sets the value for the Location on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x VertexInputAttributeDescription) WithLocation(y uint32) VertexInputAttributeDescription {
	x.location = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// Binding returns the value of binding from VkVertexInputAttributeDescription
func (x VertexInputAttributeDescription) Binding() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.binding) 
	return *ptr
}

// WithBinding sets the value for the Binding on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x VertexInputAttributeDescription) WithBinding(y uint32) VertexInputAttributeDescription {
	x.binding = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// Format returns the value of format from VkVertexInputAttributeDescription
func (x VertexInputAttributeDescription) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format) 
	return *ptr
}

// WithFormat sets the value for the Format on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x VertexInputAttributeDescription) WithFormat(y Format) VertexInputAttributeDescription {
	x.format = *(/* typedef */ (*C.VkFormat)(&y))
	return x
}

// Offset returns the value of offset from VkVertexInputAttributeDescription
func (x VertexInputAttributeDescription) Offset() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.offset) 
	return *ptr
}

// WithOffset sets the value for the Offset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x VertexInputAttributeDescription) WithOffset(y uint32) VertexInputAttributeDescription {
	x.offset = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// VertexInputBindingDescription provides a go interface for VkVertexInputBindingDescription.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkVertexInputBindingDescription.html
type VertexInputBindingDescription C.struct_VkVertexInputBindingDescription

// SizeofVertexInputBindingDescription is the memory size of a VertexInputBindingDescription
var SizeofVertexInputBindingDescription int = int(unsafe.Sizeof(VertexInputBindingDescription{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *VertexInputBindingDescription) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x VertexInputBindingDescription) AsCPtr() *VertexInputBindingDescription {
	clone := (*VertexInputBindingDescription)(newCBlock(C.ulong(SizeofVertexInputBindingDescription)))
	*clone = x
	return clone
}

// VertexInputBindingDescriptionFreeCSlice releases the memory allocated by VertexInputBindingDescriptionMakeCSlice.
// It does not free pointers stored inside the slice.
func VertexInputBindingDescriptionFreeCSlice(x []VertexInputBindingDescription) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// VertexInputBindingDescriptionMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. VertexInputBindingDescriptionFreeCSlice must be called on the returned slice.
func VertexInputBindingDescriptionMakeCSlice(x ...VertexInputBindingDescription) []VertexInputBindingDescription {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofVertexInputBindingDescription * len(x)
	dst := unsafe.Slice((*VertexInputBindingDescription)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Binding returns the value of binding from VkVertexInputBindingDescription
func (x VertexInputBindingDescription) Binding() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.binding) 
	return *ptr
}

// WithBinding sets the value for the Binding on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x VertexInputBindingDescription) WithBinding(y uint32) VertexInputBindingDescription {
	x.binding = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// Stride returns the value of stride from VkVertexInputBindingDescription
func (x VertexInputBindingDescription) Stride() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.stride) 
	return *ptr
}

// WithStride sets the value for the Stride on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x VertexInputBindingDescription) WithStride(y uint32) VertexInputBindingDescription {
	x.stride = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// InputRate returns the value of inputRate from VkVertexInputBindingDescription
func (x VertexInputBindingDescription) InputRate() VertexInputRate {
	ptr := /* typedef */ (*VertexInputRate)(&x.inputRate) 
	return *ptr
}

// WithInputRate sets the value for the InputRate on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x VertexInputBindingDescription) WithInputRate(y VertexInputRate) VertexInputBindingDescription {
	x.inputRate = *(/* typedef */ (*C.VkVertexInputRate)(&y))
	return x
}

// AttachmentDescription provides a go interface for VkAttachmentDescription.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentDescription.html
type AttachmentDescription C.struct_VkAttachmentDescription

// SizeofAttachmentDescription is the memory size of a AttachmentDescription
var SizeofAttachmentDescription int = int(unsafe.Sizeof(AttachmentDescription{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *AttachmentDescription) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x AttachmentDescription) AsCPtr() *AttachmentDescription {
	clone := (*AttachmentDescription)(newCBlock(C.ulong(SizeofAttachmentDescription)))
	*clone = x
	return clone
}

// AttachmentDescriptionFreeCSlice releases the memory allocated by AttachmentDescriptionMakeCSlice.
// It does not free pointers stored inside the slice.
func AttachmentDescriptionFreeCSlice(x []AttachmentDescription) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// AttachmentDescriptionMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. AttachmentDescriptionFreeCSlice must be called on the returned slice.
func AttachmentDescriptionMakeCSlice(x ...AttachmentDescription) []AttachmentDescription {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAttachmentDescription * len(x)
	dst := unsafe.Slice((*AttachmentDescription)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Flags returns the value of flags from VkAttachmentDescription
func (x AttachmentDescription) Flags() AttachmentDescriptionFlags {
	ptr := /* typedef */ (*AttachmentDescriptionFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription) WithFlags(y AttachmentDescriptionFlags) AttachmentDescription {
	x.flags = *(/* typedef */ (*C.VkAttachmentDescriptionFlags)(&y))
	return x
}

// Format returns the value of format from VkAttachmentDescription
func (x AttachmentDescription) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format) 
	return *ptr
}

// WithFormat sets the value for the Format on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription) WithFormat(y Format) AttachmentDescription {
	x.format = *(/* typedef */ (*C.VkFormat)(&y))
	return x
}

// Samples returns the value of samples from VkAttachmentDescription
func (x AttachmentDescription) Samples() SampleCountFlagBits {
	ptr := /* typedef */ (*SampleCountFlagBits)(&x.samples) 
	return *ptr
}

// WithSamples sets the value for the Samples on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription) WithSamples(y SampleCountFlagBits) AttachmentDescription {
	x.samples = *(/* typedef */ (*C.VkSampleCountFlagBits)(&y))
	return x
}

// LoadOp returns the value of loadOp from VkAttachmentDescription
func (x AttachmentDescription) LoadOp() AttachmentLoadOp {
	ptr := /* typedef */ (*AttachmentLoadOp)(&x.loadOp) 
	return *ptr
}

// WithLoadOp sets the value for the LoadOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription) WithLoadOp(y AttachmentLoadOp) AttachmentDescription {
	x.loadOp = *(/* typedef */ (*C.VkAttachmentLoadOp)(&y))
	return x
}

// StoreOp returns the value of storeOp from VkAttachmentDescription
func (x AttachmentDescription) StoreOp() AttachmentStoreOp {
	ptr := /* typedef */ (*AttachmentStoreOp)(&x.storeOp) 
	return *ptr
}

// WithStoreOp sets the value for the StoreOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription) WithStoreOp(y AttachmentStoreOp) AttachmentDescription {
	x.storeOp = *(/* typedef */ (*C.VkAttachmentStoreOp)(&y))
	return x
}

// StencilLoadOp returns the value of stencilLoadOp from VkAttachmentDescription
func (x AttachmentDescription) StencilLoadOp() AttachmentLoadOp {
	ptr := /* typedef */ (*AttachmentLoadOp)(&x.stencilLoadOp) 
	return *ptr
}

// WithStencilLoadOp sets the value for the StencilLoadOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription) WithStencilLoadOp(y AttachmentLoadOp) AttachmentDescription {
	x.stencilLoadOp = *(/* typedef */ (*C.VkAttachmentLoadOp)(&y))
	return x
}

// StencilStoreOp returns the value of stencilStoreOp from VkAttachmentDescription
func (x AttachmentDescription) StencilStoreOp() AttachmentStoreOp {
	ptr := /* typedef */ (*AttachmentStoreOp)(&x.stencilStoreOp) 
	return *ptr
}

// WithStencilStoreOp sets the value for the StencilStoreOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription) WithStencilStoreOp(y AttachmentStoreOp) AttachmentDescription {
	x.stencilStoreOp = *(/* typedef */ (*C.VkAttachmentStoreOp)(&y))
	return x
}

// InitialLayout returns the value of initialLayout from VkAttachmentDescription
func (x AttachmentDescription) InitialLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.initialLayout) 
	return *ptr
}

// WithInitialLayout sets the value for the InitialLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription) WithInitialLayout(y ImageLayout) AttachmentDescription {
	x.initialLayout = *(/* typedef */ (*C.VkImageLayout)(&y))
	return x
}

// FinalLayout returns the value of finalLayout from VkAttachmentDescription
func (x AttachmentDescription) FinalLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.finalLayout) 
	return *ptr
}

// WithFinalLayout sets the value for the FinalLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription) WithFinalLayout(y ImageLayout) AttachmentDescription {
	x.finalLayout = *(/* typedef */ (*C.VkImageLayout)(&y))
	return x
}

// Viewport provides a go interface for VkViewport.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkViewport.html
type Viewport C.struct_VkViewport

// SizeofViewport is the memory size of a Viewport
var SizeofViewport int = int(unsafe.Sizeof(Viewport{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *Viewport) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x Viewport) AsCPtr() *Viewport {
	clone := (*Viewport)(newCBlock(C.ulong(SizeofViewport)))
	*clone = x
	return clone
}

// ViewportFreeCSlice releases the memory allocated by ViewportMakeCSlice.
// It does not free pointers stored inside the slice.
func ViewportFreeCSlice(x []Viewport) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ViewportMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ViewportFreeCSlice must be called on the returned slice.
func ViewportMakeCSlice(x ...Viewport) []Viewport {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofViewport * len(x)
	dst := unsafe.Slice((*Viewport)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// X returns the value of x from VkViewport
func (x Viewport) X() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.x) 
	return *ptr
}

// WithX sets the value for the X on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Viewport) WithX(y float32) Viewport {
	x.x = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}

// Y returns the value of y from VkViewport
func (x Viewport) Y() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.y) 
	return *ptr
}

// WithY sets the value for the Y on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Viewport) WithY(y float32) Viewport {
	x.y = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}

// Width returns the value of width from VkViewport
func (x Viewport) Width() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.width) 
	return *ptr
}

// WithWidth sets the value for the Width on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Viewport) WithWidth(y float32) Viewport {
	x.width = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}

// Height returns the value of height from VkViewport
func (x Viewport) Height() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.height) 
	return *ptr
}

// WithHeight sets the value for the Height on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Viewport) WithHeight(y float32) Viewport {
	x.height = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}

// MinDepth returns the value of minDepth from VkViewport
func (x Viewport) MinDepth() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.minDepth) 
	return *ptr
}

// WithMinDepth sets the value for the MinDepth on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Viewport) WithMinDepth(y float32) Viewport {
	x.minDepth = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}

// MaxDepth returns the value of maxDepth from VkViewport
func (x Viewport) MaxDepth() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.maxDepth) 
	return *ptr
}

// WithMaxDepth sets the value for the MaxDepth on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x Viewport) WithMaxDepth(y float32) Viewport {
	x.maxDepth = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}

// ClearColorValue union
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearColorValue.html
type ClearColorValue C.VkClearColorValue

// ClearValue union
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkClearValue.html
type ClearValue C.VkClearValue

// SetEvent command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetEvent.html
func (x DeviceFacade)SetEvent(event Event, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkEvent)(&event)
	ret := C.vkSetEvent(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroyDescriptorPool command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDescriptorPool.html
func (x DeviceFacade)DestroyDescriptorPool(descriptorPool DescriptorPool, pAllocator *AllocationCallbacks, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDescriptorPool)(&descriptorPool)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	C.vkDestroyDescriptorPool(addrs, *p0, *p1, *p2)
	}

// ResetDescriptorPool command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetDescriptorPool.html
func (x DeviceFacade)ResetDescriptorPool(descriptorPool DescriptorPool, flags DescriptorPoolResetFlags, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDescriptorPool)(&descriptorPool)
	p2 := /* typedef */ (*C.VkDescriptorPoolResetFlags)(&flags)
	ret := C.vkResetDescriptorPool(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CreateDescriptorPool command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDescriptorPool.html
func (x DeviceFacade)CreateDescriptorPool(pCreateInfo *DescriptorPoolCreateInfo, pAllocator *AllocationCallbacks, pDescriptorPool *DescriptorPool, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DescriptorPoolCreateInfo) **C.struct_VkDescriptorPoolCreateInfo { /* Pointer */ g2c := (*C.struct_VkDescriptorPoolCreateInfo)(*x); return &g2c }(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p3 := func(x **DescriptorPool) **C.VkDescriptorPool { /* Pointer */ g2c := (*C.VkDescriptorPool)(*x); return &g2c }(&pDescriptorPool)
	ret := C.vkCreateDescriptorPool(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// FreeDescriptorSets command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFreeDescriptorSets.html
func (x DeviceFacade)FreeDescriptorSets(descriptorPool DescriptorPool, descriptorSetCount uint32, pDescriptorSets []DescriptorSet, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDescriptorPool)(&descriptorPool)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&descriptorSetCount)
	p3 := func(x *[]DescriptorSet) **C.VkDescriptorSet { /* Slice */ if len(*x) > 0 { slc := (*C.VkDescriptorSet)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkDescriptorSet)(unsafe.Pointer((&ptr))) }(&pDescriptorSets)
	ret := C.vkFreeDescriptorSets(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// UpdateDescriptorSets command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUpdateDescriptorSets.html
func (x DeviceFacade)UpdateDescriptorSets(descriptorWriteCount uint32, pDescriptorWrites []WriteDescriptorSet, descriptorCopyCount uint32, pDescriptorCopies []CopyDescriptorSet, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&descriptorWriteCount)
	p2 := func(x *[]WriteDescriptorSet) **C.struct_VkWriteDescriptorSet { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkWriteDescriptorSet)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkWriteDescriptorSet)(unsafe.Pointer((&ptr))) }(&pDescriptorWrites)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&descriptorCopyCount)
	p4 := func(x *[]CopyDescriptorSet) **C.struct_VkCopyDescriptorSet { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkCopyDescriptorSet)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkCopyDescriptorSet)(unsafe.Pointer((&ptr))) }(&pDescriptorCopies)
	C.vkUpdateDescriptorSets(addrs, *p0, *p1, *p2, *p3, *p4)
	}

// DestroyDescriptorSetLayout command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDescriptorSetLayout.html
func (x DeviceFacade)DestroyDescriptorSetLayout(descriptorSetLayout DescriptorSetLayout, pAllocator *AllocationCallbacks, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDescriptorSetLayout)(&descriptorSetLayout)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	C.vkDestroyDescriptorSetLayout(addrs, *p0, *p1, *p2)
	}

// CreateDescriptorSetLayout command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDescriptorSetLayout.html
func (x DeviceFacade)CreateDescriptorSetLayout(pCreateInfo *DescriptorSetLayoutCreateInfo, pAllocator *AllocationCallbacks, pSetLayout *DescriptorSetLayout, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DescriptorSetLayoutCreateInfo) **C.struct_VkDescriptorSetLayoutCreateInfo { /* Pointer */ g2c := (*C.struct_VkDescriptorSetLayoutCreateInfo)(*x); return &g2c }(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p3 := func(x **DescriptorSetLayout) **C.VkDescriptorSetLayout { /* Pointer */ g2c := (*C.VkDescriptorSetLayout)(*x); return &g2c }(&pSetLayout)
	ret := C.vkCreateDescriptorSetLayout(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroySampler command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySampler.html
func (x DeviceFacade)DestroySampler(sampler Sampler, pAllocator *AllocationCallbacks, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkSampler)(&sampler)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	C.vkDestroySampler(addrs, *p0, *p1, *p2)
	}

// CreateSampler command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSampler.html
func (x DeviceFacade)CreateSampler(pCreateInfo *SamplerCreateInfo, pAllocator *AllocationCallbacks, pSampler *Sampler, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **SamplerCreateInfo) **C.struct_VkSamplerCreateInfo { /* Pointer */ g2c := (*C.struct_VkSamplerCreateInfo)(*x); return &g2c }(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p3 := func(x **Sampler) **C.VkSampler { /* Pointer */ g2c := (*C.VkSampler)(*x); return &g2c }(&pSampler)
	ret := C.vkCreateSampler(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroyPipelineLayout command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPipelineLayout.html
func (x DeviceFacade)DestroyPipelineLayout(pipelineLayout PipelineLayout, pAllocator *AllocationCallbacks, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkPipelineLayout)(&pipelineLayout)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	C.vkDestroyPipelineLayout(addrs, *p0, *p1, *p2)
	}

// CreatePipelineLayout command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreatePipelineLayout.html
func (x DeviceFacade)CreatePipelineLayout(pCreateInfo *PipelineLayoutCreateInfo, pAllocator *AllocationCallbacks, pPipelineLayout *PipelineLayout, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **PipelineLayoutCreateInfo) **C.struct_VkPipelineLayoutCreateInfo { /* Pointer */ g2c := (*C.struct_VkPipelineLayoutCreateInfo)(*x); return &g2c }(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p3 := func(x **PipelineLayout) **C.VkPipelineLayout { /* Pointer */ g2c := (*C.VkPipelineLayout)(*x); return &g2c }(&pPipelineLayout)
	ret := C.vkCreatePipelineLayout(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// WaitForFences command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkWaitForFences.html
func (x DeviceFacade)WaitForFences(fenceCount uint32, pFences []Fence, waitAll Bool32, timeout uint64, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&fenceCount)
	p2 := func(x *[]Fence) **C.VkFence { /* Slice */ if len(*x) > 0 { slc := (*C.VkFence)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkFence)(unsafe.Pointer((&ptr))) }(&pFences)
	p3 := /* typedef */ (*C.VkBool32)(&waitAll)
	p4 := func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&timeout)
	ret := C.vkWaitForFences(addrs, *p0, *p1, *p2, *p3, *p4)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CreateDevice command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDevice.html
func (x PhysicalDeviceFacade)CreateDevice(pCreateInfo *DeviceCreateInfo, pAllocator *AllocationCallbacks, pDevice *Device, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **DeviceCreateInfo) **C.struct_VkDeviceCreateInfo { /* Pointer */ g2c := (*C.struct_VkDeviceCreateInfo)(*x); return &g2c }(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p3 := func(x **Device) **C.VkDevice { /* Pointer */ g2c := (*C.VkDevice)(*x); return &g2c }(&pDevice)
	ret := C.vkCreateDevice(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroyDevice command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDevice.html
func (x DeviceFacade)DestroyDevice(pAllocator *AllocationCallbacks, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	C.vkDestroyDevice(addrs, *p0, *p1)
	}

// GetDeviceProcAddr command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceProcAddr.html
func (x DeviceFacade)GetDeviceProcAddr(pName *byte, ) PFN_vkVoidFunction {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **byte) **C.char { /* Pointer */ return (**C.char)(unsafe.Pointer(x)) }(&pName)
	ret := C.vkGetDeviceProcAddr(addrs, *p0, *p1)
	retPtr := /* typedef */ (*PFN_vkVoidFunction)(&ret)
	return *retPtr
}

// CreateInstance command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateInstance.html
func CreateInstance(pCreateInfo *InstanceCreateInfo, pAllocator *AllocationCallbacks, pInstance *Instance, ) Result {
	addrs := &C.vksProcAddresses
	p0 := func(x **InstanceCreateInfo) **C.struct_VkInstanceCreateInfo { /* Pointer */ g2c := (*C.struct_VkInstanceCreateInfo)(*x); return &g2c }(&pCreateInfo)
	p1 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p2 := func(x **Instance) **C.VkInstance { /* Pointer */ g2c := (*C.VkInstance)(*x); return &g2c }(&pInstance)
	ret := C.vkCreateInstance(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetInstanceProcAddr command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetInstanceProcAddr.html
func GetInstanceProcAddr(instance Instance, pName *byte, ) PFN_vkVoidFunction {
	addrs := &C.vksProcAddresses
	p0 := /* handle */ (*C.VkInstance)(&instance)
	p1 := func(x **byte) **C.char { /* Pointer */ return (**C.char)(unsafe.Pointer(x)) }(&pName)
	ret := C.vkGetInstanceProcAddr(addrs, *p0, *p1)
	retPtr := /* typedef */ (*PFN_vkVoidFunction)(&ret)
	return *retPtr
}

// EnumerateInstanceExtensionProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html
func EnumerateInstanceExtensionProperties(pLayerName *byte, pPropertyCount *uint32, pProperties []ExtensionProperties, ) Result {
	addrs := &C.vksProcAddresses
	p0 := func(x **byte) **C.char { /* Pointer */ return (**C.char)(unsafe.Pointer(x)) }(&pLayerName)
	p1 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPropertyCount)
	p2 := func(x *[]ExtensionProperties) **C.struct_VkExtensionProperties { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkExtensionProperties)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkExtensionProperties)(unsafe.Pointer((&ptr))) }(&pProperties)
	ret := C.vkEnumerateInstanceExtensionProperties(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceMemoryProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceMemoryProperties.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceMemoryProperties(pMemoryProperties *PhysicalDeviceMemoryProperties, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceMemoryProperties) **C.struct_VkPhysicalDeviceMemoryProperties { /* Pointer */ g2c := (*C.struct_VkPhysicalDeviceMemoryProperties)(*x); return &g2c }(&pMemoryProperties)
	C.vkGetPhysicalDeviceMemoryProperties(addrs, *p0, *p1)
	}

// GetPhysicalDeviceQueueFamilyProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceQueueFamilyProperties.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceQueueFamilyProperties(pQueueFamilyPropertyCount *uint32, pQueueFamilyProperties []QueueFamilyProperties, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pQueueFamilyPropertyCount)
	p2 := func(x *[]QueueFamilyProperties) **C.struct_VkQueueFamilyProperties { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkQueueFamilyProperties)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkQueueFamilyProperties)(unsafe.Pointer((&ptr))) }(&pQueueFamilyProperties)
	C.vkGetPhysicalDeviceQueueFamilyProperties(addrs, *p0, *p1, *p2)
	}

// EnumerateDeviceExtensionProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateDeviceExtensionProperties.html
func (x PhysicalDeviceFacade)EnumerateDeviceExtensionProperties(pLayerName *byte, pPropertyCount *uint32, pProperties []ExtensionProperties, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **byte) **C.char { /* Pointer */ return (**C.char)(unsafe.Pointer(x)) }(&pLayerName)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPropertyCount)
	p3 := func(x *[]ExtensionProperties) **C.struct_VkExtensionProperties { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkExtensionProperties)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkExtensionProperties)(unsafe.Pointer((&ptr))) }(&pProperties)
	ret := C.vkEnumerateDeviceExtensionProperties(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceProperties.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceProperties(pProperties *PhysicalDeviceProperties, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceProperties) **C.struct_VkPhysicalDeviceProperties { /* Pointer */ g2c := (*C.struct_VkPhysicalDeviceProperties)(*x); return &g2c }(&pProperties)
	C.vkGetPhysicalDeviceProperties(addrs, *p0, *p1)
	}

// EnumerateInstanceLayerProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceLayerProperties.html
func EnumerateInstanceLayerProperties(pPropertyCount *uint32, pProperties []LayerProperties, ) Result {
	addrs := &C.vksProcAddresses
	p0 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPropertyCount)
	p1 := func(x *[]LayerProperties) **C.struct_VkLayerProperties { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkLayerProperties)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkLayerProperties)(unsafe.Pointer((&ptr))) }(&pProperties)
	ret := C.vkEnumerateInstanceLayerProperties(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CreateFramebuffer command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateFramebuffer.html
func (x DeviceFacade)CreateFramebuffer(pCreateInfo *FramebufferCreateInfo, pAllocator *AllocationCallbacks, pFramebuffer *Framebuffer, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **FramebufferCreateInfo) **C.struct_VkFramebufferCreateInfo { /* Pointer */ g2c := (*C.struct_VkFramebufferCreateInfo)(*x); return &g2c }(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p3 := func(x **Framebuffer) **C.VkFramebuffer { /* Pointer */ g2c := (*C.VkFramebuffer)(*x); return &g2c }(&pFramebuffer)
	ret := C.vkCreateFramebuffer(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroyFramebuffer command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyFramebuffer.html
func (x DeviceFacade)DestroyFramebuffer(framebuffer Framebuffer, pAllocator *AllocationCallbacks, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkFramebuffer)(&framebuffer)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	C.vkDestroyFramebuffer(addrs, *p0, *p1, *p2)
	}

// CreateRenderPass command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateRenderPass.html
func (x DeviceFacade)CreateRenderPass(pCreateInfo *RenderPassCreateInfo, pAllocator *AllocationCallbacks, pRenderPass *RenderPass, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **RenderPassCreateInfo) **C.struct_VkRenderPassCreateInfo { /* Pointer */ g2c := (*C.struct_VkRenderPassCreateInfo)(*x); return &g2c }(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p3 := func(x **RenderPass) **C.VkRenderPass { /* Pointer */ g2c := (*C.VkRenderPass)(*x); return &g2c }(&pRenderPass)
	ret := C.vkCreateRenderPass(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroyRenderPass command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyRenderPass.html
func (x DeviceFacade)DestroyRenderPass(renderPass RenderPass, pAllocator *AllocationCallbacks, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkRenderPass)(&renderPass)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	C.vkDestroyRenderPass(addrs, *p0, *p1, *p2)
	}

// GetRenderAreaGranularity command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetRenderAreaGranularity.html
func (x DeviceFacade)GetRenderAreaGranularity(renderPass RenderPass, pGranularity *Extent2D, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkRenderPass)(&renderPass)
	p2 := func(x **Extent2D) **C.struct_VkExtent2D { /* Pointer */ g2c := (*C.struct_VkExtent2D)(*x); return &g2c }(&pGranularity)
	C.vkGetRenderAreaGranularity(addrs, *p0, *p1, *p2)
	}

// GetPhysicalDeviceImageFormatProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceImageFormatProperties.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceImageFormatProperties(format Format, type_ ImageType, tiling ImageTiling, usage ImageUsageFlags, flags ImageCreateFlags, pImageFormatProperties *ImageFormatProperties, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* typedef */ (*C.VkFormat)(&format)
	p2 := /* typedef */ (*C.VkImageType)(&type_)
	p3 := /* typedef */ (*C.VkImageTiling)(&tiling)
	p4 := /* typedef */ (*C.VkImageUsageFlags)(&usage)
	p5 := /* typedef */ (*C.VkImageCreateFlags)(&flags)
	p6 := func(x **ImageFormatProperties) **C.struct_VkImageFormatProperties { /* Pointer */ g2c := (*C.struct_VkImageFormatProperties)(*x); return &g2c }(&pImageFormatProperties)
	ret := C.vkGetPhysicalDeviceImageFormatProperties(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceFormatProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFormatProperties.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceFormatProperties(format Format, pFormatProperties *FormatProperties, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* typedef */ (*C.VkFormat)(&format)
	p2 := func(x **FormatProperties) **C.struct_VkFormatProperties { /* Pointer */ g2c := (*C.struct_VkFormatProperties)(*x); return &g2c }(&pFormatProperties)
	C.vkGetPhysicalDeviceFormatProperties(addrs, *p0, *p1, *p2)
	}

// EnumerateDeviceLayerProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateDeviceLayerProperties.html
func (x PhysicalDeviceFacade)EnumerateDeviceLayerProperties(pPropertyCount *uint32, pProperties []LayerProperties, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPropertyCount)
	p2 := func(x *[]LayerProperties) **C.struct_VkLayerProperties { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkLayerProperties)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkLayerProperties)(unsafe.Pointer((&ptr))) }(&pProperties)
	ret := C.vkEnumerateDeviceLayerProperties(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceFeatures command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFeatures.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceFeatures(pFeatures *PhysicalDeviceFeatures, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceFeatures) **C.struct_VkPhysicalDeviceFeatures { /* Pointer */ g2c := (*C.struct_VkPhysicalDeviceFeatures)(*x); return &g2c }(&pFeatures)
	C.vkGetPhysicalDeviceFeatures(addrs, *p0, *p1)
	}

// EnumeratePhysicalDevices command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumeratePhysicalDevices.html
func (x InstanceFacade)EnumeratePhysicalDevices(pPhysicalDeviceCount *uint32, pPhysicalDevices []PhysicalDevice, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkInstance)(&x.H)
	p1 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPhysicalDeviceCount)
	p2 := func(x *[]PhysicalDevice) **C.VkPhysicalDevice { /* Slice */ if len(*x) > 0 { slc := (*C.VkPhysicalDevice)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkPhysicalDevice)(unsafe.Pointer((&ptr))) }(&pPhysicalDevices)
	ret := C.vkEnumeratePhysicalDevices(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroyInstance command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyInstance.html
func (x InstanceFacade)DestroyInstance(pAllocator *AllocationCallbacks, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkInstance)(&x.H)
	p1 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	C.vkDestroyInstance(addrs, *p0, *p1)
	}

// GetDeviceQueue command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceQueue.html
func (x DeviceFacade)GetDeviceQueue(queueFamilyIndex uint32, queueIndex uint32, pQueue *Queue, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&queueFamilyIndex)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&queueIndex)
	p3 := func(x **Queue) **C.VkQueue { /* Pointer */ g2c := (*C.VkQueue)(*x); return &g2c }(&pQueue)
	C.vkGetDeviceQueue(addrs, *p0, *p1, *p2, *p3)
	}

// AllocateDescriptorSets command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAllocateDescriptorSets.html
func (x DeviceFacade)AllocateDescriptorSets(pAllocateInfo *DescriptorSetAllocateInfo, pDescriptorSets []DescriptorSet, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DescriptorSetAllocateInfo) **C.struct_VkDescriptorSetAllocateInfo { /* Pointer */ g2c := (*C.struct_VkDescriptorSetAllocateInfo)(*x); return &g2c }(&pAllocateInfo)
	p2 := func(x *[]DescriptorSet) **C.VkDescriptorSet { /* Slice */ if len(*x) > 0 { slc := (*C.VkDescriptorSet)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkDescriptorSet)(unsafe.Pointer((&ptr))) }(&pDescriptorSets)
	ret := C.vkAllocateDescriptorSets(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// QueueSubmit command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueSubmit.html
func (x QueueFacade)QueueSubmit(submitCount uint32, pSubmits []SubmitInfo, fence Fence, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkQueue)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&submitCount)
	p2 := func(x *[]SubmitInfo) **C.struct_VkSubmitInfo { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkSubmitInfo)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkSubmitInfo)(unsafe.Pointer((&ptr))) }(&pSubmits)
	p3 := /* handle */ (*C.VkFence)(&fence)
	ret := C.vkQueueSubmit(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// QueueWaitIdle command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueWaitIdle.html
func (x QueueFacade)QueueWaitIdle() Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkQueue)(&x.H)
	ret := C.vkQueueWaitIdle(addrs, *p0)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DeviceWaitIdle command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDeviceWaitIdle.html
func (x DeviceFacade)DeviceWaitIdle() Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	ret := C.vkDeviceWaitIdle(addrs, *p0)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// AllocateMemory command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAllocateMemory.html
func (x DeviceFacade)AllocateMemory(pAllocateInfo *MemoryAllocateInfo, pAllocator *AllocationCallbacks, pMemory *DeviceMemory, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **MemoryAllocateInfo) **C.struct_VkMemoryAllocateInfo { /* Pointer */ g2c := (*C.struct_VkMemoryAllocateInfo)(*x); return &g2c }(&pAllocateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p3 := func(x **DeviceMemory) **C.VkDeviceMemory { /* Pointer */ g2c := (*C.VkDeviceMemory)(*x); return &g2c }(&pMemory)
	ret := C.vkAllocateMemory(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// FreeMemory command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFreeMemory.html
func (x DeviceFacade)FreeMemory(memory DeviceMemory, pAllocator *AllocationCallbacks, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDeviceMemory)(&memory)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	C.vkFreeMemory(addrs, *p0, *p1, *p2)
	}

// MapMemory command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkMapMemory.html
func (x DeviceFacade)MapMemory(memory DeviceMemory, offset DeviceSize, size DeviceSize, flags MemoryMapFlags, ppData *unsafe.Pointer, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDeviceMemory)(&memory)
	p2 := /* typedef */ (*C.VkDeviceSize)(&offset)
	p3 := /* typedef */ (*C.VkDeviceSize)(&size)
	p4 := /* typedef */ (*C.VkMemoryMapFlags)(&flags)
	p5 := func(x **unsafe.Pointer) **unsafe.Pointer { /* Pointer */ g2c := (*unsafe.Pointer)(*x); return &g2c }(&ppData)
	ret := C.vkMapMemory(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// UnmapMemory command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUnmapMemory.html
func (x DeviceFacade)UnmapMemory(memory DeviceMemory, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDeviceMemory)(&memory)
	C.vkUnmapMemory(addrs, *p0, *p1)
	}

// FlushMappedMemoryRanges command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFlushMappedMemoryRanges.html
func (x DeviceFacade)FlushMappedMemoryRanges(memoryRangeCount uint32, pMemoryRanges []MappedMemoryRange, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&memoryRangeCount)
	p2 := func(x *[]MappedMemoryRange) **C.struct_VkMappedMemoryRange { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkMappedMemoryRange)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkMappedMemoryRange)(unsafe.Pointer((&ptr))) }(&pMemoryRanges)
	ret := C.vkFlushMappedMemoryRanges(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// InvalidateMappedMemoryRanges command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkInvalidateMappedMemoryRanges.html
func (x DeviceFacade)InvalidateMappedMemoryRanges(memoryRangeCount uint32, pMemoryRanges []MappedMemoryRange, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&memoryRangeCount)
	p2 := func(x *[]MappedMemoryRange) **C.struct_VkMappedMemoryRange { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkMappedMemoryRange)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkMappedMemoryRange)(unsafe.Pointer((&ptr))) }(&pMemoryRanges)
	ret := C.vkInvalidateMappedMemoryRanges(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetDeviceMemoryCommitment command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceMemoryCommitment.html
func (x DeviceFacade)GetDeviceMemoryCommitment(memory DeviceMemory, pCommittedMemoryInBytes *DeviceSize, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDeviceMemory)(&memory)
	p2 := func(x **DeviceSize) **C.VkDeviceSize { /* Pointer */ g2c := (*C.VkDeviceSize)(*x); return &g2c }(&pCommittedMemoryInBytes)
	C.vkGetDeviceMemoryCommitment(addrs, *p0, *p1, *p2)
	}

// DestroyPipeline command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPipeline.html
func (x DeviceFacade)DestroyPipeline(pipeline Pipeline, pAllocator *AllocationCallbacks, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkPipeline)(&pipeline)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	C.vkDestroyPipeline(addrs, *p0, *p1, *p2)
	}

// CreateComputePipelines command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateComputePipelines.html
func (x DeviceFacade)CreateComputePipelines(pipelineCache PipelineCache, createInfoCount uint32, pCreateInfos []ComputePipelineCreateInfo, pAllocator *AllocationCallbacks, pPipelines []Pipeline, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkPipelineCache)(&pipelineCache)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&createInfoCount)
	p3 := func(x *[]ComputePipelineCreateInfo) **C.struct_VkComputePipelineCreateInfo { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkComputePipelineCreateInfo)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkComputePipelineCreateInfo)(unsafe.Pointer((&ptr))) }(&pCreateInfos)
	p4 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p5 := func(x *[]Pipeline) **C.VkPipeline { /* Slice */ if len(*x) > 0 { slc := (*C.VkPipeline)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkPipeline)(unsafe.Pointer((&ptr))) }(&pPipelines)
	ret := C.vkCreateComputePipelines(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CreateGraphicsPipelines command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateGraphicsPipelines.html
func (x DeviceFacade)CreateGraphicsPipelines(pipelineCache PipelineCache, createInfoCount uint32, pCreateInfos []GraphicsPipelineCreateInfo, pAllocator *AllocationCallbacks, pPipelines []Pipeline, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkPipelineCache)(&pipelineCache)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&createInfoCount)
	p3 := func(x *[]GraphicsPipelineCreateInfo) **C.struct_VkGraphicsPipelineCreateInfo { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkGraphicsPipelineCreateInfo)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkGraphicsPipelineCreateInfo)(unsafe.Pointer((&ptr))) }(&pCreateInfos)
	p4 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p5 := func(x *[]Pipeline) **C.VkPipeline { /* Slice */ if len(*x) > 0 { slc := (*C.VkPipeline)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkPipeline)(unsafe.Pointer((&ptr))) }(&pPipelines)
	ret := C.vkCreateGraphicsPipelines(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// BindBufferMemory command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindBufferMemory.html
func (x DeviceFacade)BindBufferMemory(buffer Buffer, memory DeviceMemory, memoryOffset DeviceSize, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&buffer)
	p2 := /* handle */ (*C.VkDeviceMemory)(&memory)
	p3 := /* typedef */ (*C.VkDeviceSize)(&memoryOffset)
	ret := C.vkBindBufferMemory(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// MergePipelineCaches command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkMergePipelineCaches.html
func (x DeviceFacade)MergePipelineCaches(dstCache PipelineCache, srcCacheCount uint32, pSrcCaches []PipelineCache, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkPipelineCache)(&dstCache)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&srcCacheCount)
	p3 := func(x *[]PipelineCache) **C.VkPipelineCache { /* Slice */ if len(*x) > 0 { slc := (*C.VkPipelineCache)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkPipelineCache)(unsafe.Pointer((&ptr))) }(&pSrcCaches)
	ret := C.vkMergePipelineCaches(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CreateCommandPool command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateCommandPool.html
func (x DeviceFacade)CreateCommandPool(pCreateInfo *CommandPoolCreateInfo, pAllocator *AllocationCallbacks, pCommandPool *CommandPool, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **CommandPoolCreateInfo) **C.struct_VkCommandPoolCreateInfo { /* Pointer */ g2c := (*C.struct_VkCommandPoolCreateInfo)(*x); return &g2c }(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p3 := func(x **CommandPool) **C.VkCommandPool { /* Pointer */ g2c := (*C.VkCommandPool)(*x); return &g2c }(&pCommandPool)
	ret := C.vkCreateCommandPool(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroyCommandPool command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyCommandPool.html
func (x DeviceFacade)DestroyCommandPool(commandPool CommandPool, pAllocator *AllocationCallbacks, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkCommandPool)(&commandPool)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	C.vkDestroyCommandPool(addrs, *p0, *p1, *p2)
	}

// ResetCommandPool command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetCommandPool.html
func (x DeviceFacade)ResetCommandPool(commandPool CommandPool, flags CommandPoolResetFlags, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkCommandPool)(&commandPool)
	p2 := /* typedef */ (*C.VkCommandPoolResetFlags)(&flags)
	ret := C.vkResetCommandPool(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPipelineCacheData command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelineCacheData.html
func (x DeviceFacade)GetPipelineCacheData(pipelineCache PipelineCache, pDataSize *uint64, pData unsafe.Pointer, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkPipelineCache)(&pipelineCache)
	p2 := func(x **uint64) **C.uint64_t { /* Pointer */ g2c := (*C.uint64_t)(*x); return &g2c }(&pDataSize)
	p3 := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&pData)
	ret := C.vkGetPipelineCacheData(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroyPipelineCache command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPipelineCache.html
func (x DeviceFacade)DestroyPipelineCache(pipelineCache PipelineCache, pAllocator *AllocationCallbacks, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkPipelineCache)(&pipelineCache)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	C.vkDestroyPipelineCache(addrs, *p0, *p1, *p2)
	}

// CreatePipelineCache command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreatePipelineCache.html
func (x DeviceFacade)CreatePipelineCache(pCreateInfo *PipelineCacheCreateInfo, pAllocator *AllocationCallbacks, pPipelineCache *PipelineCache, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **PipelineCacheCreateInfo) **C.struct_VkPipelineCacheCreateInfo { /* Pointer */ g2c := (*C.struct_VkPipelineCacheCreateInfo)(*x); return &g2c }(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p3 := func(x **PipelineCache) **C.VkPipelineCache { /* Pointer */ g2c := (*C.VkPipelineCache)(*x); return &g2c }(&pPipelineCache)
	ret := C.vkCreatePipelineCache(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// BindImageMemory command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindImageMemory.html
func (x DeviceFacade)BindImageMemory(image Image, memory DeviceMemory, memoryOffset DeviceSize, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&image)
	p2 := /* handle */ (*C.VkDeviceMemory)(&memory)
	p3 := /* typedef */ (*C.VkDeviceSize)(&memoryOffset)
	ret := C.vkBindImageMemory(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetBufferMemoryRequirements command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferMemoryRequirements.html
func (x DeviceFacade)GetBufferMemoryRequirements(buffer Buffer, pMemoryRequirements *MemoryRequirements, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&buffer)
	p2 := func(x **MemoryRequirements) **C.struct_VkMemoryRequirements { /* Pointer */ g2c := (*C.struct_VkMemoryRequirements)(*x); return &g2c }(&pMemoryRequirements)
	C.vkGetBufferMemoryRequirements(addrs, *p0, *p1, *p2)
	}

// DestroyShaderModule command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyShaderModule.html
func (x DeviceFacade)DestroyShaderModule(shaderModule ShaderModule, pAllocator *AllocationCallbacks, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkShaderModule)(&shaderModule)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	C.vkDestroyShaderModule(addrs, *p0, *p1, *p2)
	}

// AllocateCommandBuffers command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAllocateCommandBuffers.html
func (x DeviceFacade)AllocateCommandBuffers(pAllocateInfo *CommandBufferAllocateInfo, pCommandBuffers []CommandBuffer, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **CommandBufferAllocateInfo) **C.struct_VkCommandBufferAllocateInfo { /* Pointer */ g2c := (*C.struct_VkCommandBufferAllocateInfo)(*x); return &g2c }(&pAllocateInfo)
	p2 := func(x *[]CommandBuffer) **C.VkCommandBuffer { /* Slice */ if len(*x) > 0 { slc := (*C.VkCommandBuffer)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkCommandBuffer)(unsafe.Pointer((&ptr))) }(&pCommandBuffers)
	ret := C.vkAllocateCommandBuffers(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// FreeCommandBuffers command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFreeCommandBuffers.html
func (x DeviceFacade)FreeCommandBuffers(commandPool CommandPool, commandBufferCount uint32, pCommandBuffers []CommandBuffer, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkCommandPool)(&commandPool)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&commandBufferCount)
	p3 := func(x *[]CommandBuffer) **C.VkCommandBuffer { /* Slice */ if len(*x) > 0 { slc := (*C.VkCommandBuffer)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkCommandBuffer)(unsafe.Pointer((&ptr))) }(&pCommandBuffers)
	C.vkFreeCommandBuffers(addrs, *p0, *p1, *p2, *p3)
	}

// BeginCommandBuffer command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBeginCommandBuffer.html
func (x CommandBufferFacade)BeginCommandBuffer(pBeginInfo *CommandBufferBeginInfo, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **CommandBufferBeginInfo) **C.struct_VkCommandBufferBeginInfo { /* Pointer */ g2c := (*C.struct_VkCommandBufferBeginInfo)(*x); return &g2c }(&pBeginInfo)
	ret := C.vkBeginCommandBuffer(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// EndCommandBuffer command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEndCommandBuffer.html
func (x CommandBufferFacade)EndCommandBuffer() Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	ret := C.vkEndCommandBuffer(addrs, *p0)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// ResetCommandBuffer command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetCommandBuffer.html
func (x CommandBufferFacade)ResetCommandBuffer(flags CommandBufferResetFlags, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkCommandBufferResetFlags)(&flags)
	ret := C.vkResetCommandBuffer(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CreateShaderModule command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateShaderModule.html
func (x DeviceFacade)CreateShaderModule(pCreateInfo *ShaderModuleCreateInfo, pAllocator *AllocationCallbacks, pShaderModule *ShaderModule, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **ShaderModuleCreateInfo) **C.struct_VkShaderModuleCreateInfo { /* Pointer */ g2c := (*C.struct_VkShaderModuleCreateInfo)(*x); return &g2c }(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p3 := func(x **ShaderModule) **C.VkShaderModule { /* Pointer */ g2c := (*C.VkShaderModule)(*x); return &g2c }(&pShaderModule)
	ret := C.vkCreateShaderModule(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetImageMemoryRequirements command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageMemoryRequirements.html
func (x DeviceFacade)GetImageMemoryRequirements(image Image, pMemoryRequirements *MemoryRequirements, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&image)
	p2 := func(x **MemoryRequirements) **C.struct_VkMemoryRequirements { /* Pointer */ g2c := (*C.struct_VkMemoryRequirements)(*x); return &g2c }(&pMemoryRequirements)
	C.vkGetImageMemoryRequirements(addrs, *p0, *p1, *p2)
	}

// GetImageSparseMemoryRequirements command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageSparseMemoryRequirements.html
func (x DeviceFacade)GetImageSparseMemoryRequirements(image Image, pSparseMemoryRequirementCount *uint32, pSparseMemoryRequirements []SparseImageMemoryRequirements, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&image)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pSparseMemoryRequirementCount)
	p3 := func(x *[]SparseImageMemoryRequirements) **C.struct_VkSparseImageMemoryRequirements { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkSparseImageMemoryRequirements)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkSparseImageMemoryRequirements)(unsafe.Pointer((&ptr))) }(&pSparseMemoryRequirements)
	C.vkGetImageSparseMemoryRequirements(addrs, *p0, *p1, *p2, *p3)
	}

// GetPhysicalDeviceSparseImageFormatProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSparseImageFormatProperties.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceSparseImageFormatProperties(format Format, type_ ImageType, samples SampleCountFlagBits, usage ImageUsageFlags, tiling ImageTiling, pPropertyCount *uint32, pProperties []SparseImageFormatProperties, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* typedef */ (*C.VkFormat)(&format)
	p2 := /* typedef */ (*C.VkImageType)(&type_)
	p3 := /* typedef */ (*C.VkSampleCountFlagBits)(&samples)
	p4 := /* typedef */ (*C.VkImageUsageFlags)(&usage)
	p5 := /* typedef */ (*C.VkImageTiling)(&tiling)
	p6 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPropertyCount)
	p7 := func(x *[]SparseImageFormatProperties) **C.struct_VkSparseImageFormatProperties { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkSparseImageFormatProperties)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkSparseImageFormatProperties)(unsafe.Pointer((&ptr))) }(&pProperties)
	C.vkGetPhysicalDeviceSparseImageFormatProperties(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7)
	}

// CmdSetLineWidth command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetLineWidth.html
func (x CommandBufferFacade)CmdSetLineWidth(lineWidth float32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&lineWidth)
	C.vkCmdSetLineWidth(addrs, *p0, *p1)
	}

// QueueBindSparse command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueBindSparse.html
func (x QueueFacade)QueueBindSparse(bindInfoCount uint32, pBindInfo []BindSparseInfo, fence Fence, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkQueue)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&bindInfoCount)
	p2 := func(x *[]BindSparseInfo) **C.struct_VkBindSparseInfo { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkBindSparseInfo)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkBindSparseInfo)(unsafe.Pointer((&ptr))) }(&pBindInfo)
	p3 := /* handle */ (*C.VkFence)(&fence)
	ret := C.vkQueueBindSparse(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroyImageView command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyImageView.html
func (x DeviceFacade)DestroyImageView(imageView ImageView, pAllocator *AllocationCallbacks, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkImageView)(&imageView)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	C.vkDestroyImageView(addrs, *p0, *p1, *p2)
	}

// CreateImageView command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateImageView.html
func (x DeviceFacade)CreateImageView(pCreateInfo *ImageViewCreateInfo, pAllocator *AllocationCallbacks, pView *ImageView, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **ImageViewCreateInfo) **C.struct_VkImageViewCreateInfo { /* Pointer */ g2c := (*C.struct_VkImageViewCreateInfo)(*x); return &g2c }(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p3 := func(x **ImageView) **C.VkImageView { /* Pointer */ g2c := (*C.VkImageView)(*x); return &g2c }(&pView)
	ret := C.vkCreateImageView(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetImageSubresourceLayout command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageSubresourceLayout.html
func (x DeviceFacade)GetImageSubresourceLayout(image Image, pSubresource *ImageSubresource, pLayout *SubresourceLayout, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&image)
	p2 := func(x **ImageSubresource) **C.struct_VkImageSubresource { /* Pointer */ g2c := (*C.struct_VkImageSubresource)(*x); return &g2c }(&pSubresource)
	p3 := func(x **SubresourceLayout) **C.struct_VkSubresourceLayout { /* Pointer */ g2c := (*C.struct_VkSubresourceLayout)(*x); return &g2c }(&pLayout)
	C.vkGetImageSubresourceLayout(addrs, *p0, *p1, *p2, *p3)
	}

// DestroyImage command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyImage.html
func (x DeviceFacade)DestroyImage(image Image, pAllocator *AllocationCallbacks, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&image)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	C.vkDestroyImage(addrs, *p0, *p1, *p2)
	}

// CreateImage command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateImage.html
func (x DeviceFacade)CreateImage(pCreateInfo *ImageCreateInfo, pAllocator *AllocationCallbacks, pImage *Image, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **ImageCreateInfo) **C.struct_VkImageCreateInfo { /* Pointer */ g2c := (*C.struct_VkImageCreateInfo)(*x); return &g2c }(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p3 := func(x **Image) **C.VkImage { /* Pointer */ g2c := (*C.VkImage)(*x); return &g2c }(&pImage)
	ret := C.vkCreateImage(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CmdBindPipeline command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindPipeline.html
func (x CommandBufferFacade)CmdBindPipeline(pipelineBindPoint PipelineBindPoint, pipeline Pipeline, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkPipelineBindPoint)(&pipelineBindPoint)
	p2 := /* handle */ (*C.VkPipeline)(&pipeline)
	C.vkCmdBindPipeline(addrs, *p0, *p1, *p2)
	}

// CmdSetViewport command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewport.html
func (x CommandBufferFacade)CmdSetViewport(firstViewport uint32, viewportCount uint32, pViewports []Viewport, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&firstViewport)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&viewportCount)
	p3 := func(x *[]Viewport) **C.struct_VkViewport { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkViewport)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkViewport)(unsafe.Pointer((&ptr))) }(&pViewports)
	C.vkCmdSetViewport(addrs, *p0, *p1, *p2, *p3)
	}

// CmdSetScissor command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetScissor.html
func (x CommandBufferFacade)CmdSetScissor(firstScissor uint32, scissorCount uint32, pScissors []Rect2D, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&firstScissor)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&scissorCount)
	p3 := func(x *[]Rect2D) **C.struct_VkRect2D { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkRect2D)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkRect2D)(unsafe.Pointer((&ptr))) }(&pScissors)
	C.vkCmdSetScissor(addrs, *p0, *p1, *p2, *p3)
	}

// DestroyBufferView command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyBufferView.html
func (x DeviceFacade)DestroyBufferView(bufferView BufferView, pAllocator *AllocationCallbacks, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkBufferView)(&bufferView)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	C.vkDestroyBufferView(addrs, *p0, *p1, *p2)
	}

// CmdSetDepthBias command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBias.html
func (x CommandBufferFacade)CmdSetDepthBias(depthBiasConstantFactor float32, depthBiasClamp float32, depthBiasSlopeFactor float32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&depthBiasConstantFactor)
	p2 := func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&depthBiasClamp)
	p3 := func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&depthBiasSlopeFactor)
	C.vkCmdSetDepthBias(addrs, *p0, *p1, *p2, *p3)
	}

// CmdSetBlendConstants command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetBlendConstants.html
func (x CommandBufferFacade)CmdSetBlendConstants(blendConstants []float32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *[]float32) **C.float { /* Array */ if len(*x) > 0 { slc := (*C.float)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.float)(unsafe.Pointer((&ptr))) }(&blendConstants)
	C.vkCmdSetBlendConstants(addrs, *p0, *p1)
	}

// CmdSetDepthBounds command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBounds.html
func (x CommandBufferFacade)CmdSetDepthBounds(minDepthBounds float32, maxDepthBounds float32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&minDepthBounds)
	p2 := func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&maxDepthBounds)
	C.vkCmdSetDepthBounds(addrs, *p0, *p1, *p2)
	}

// CmdSetStencilCompareMask command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilCompareMask.html
func (x CommandBufferFacade)CmdSetStencilCompareMask(faceMask StencilFaceFlags, compareMask uint32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkStencilFaceFlags)(&faceMask)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&compareMask)
	C.vkCmdSetStencilCompareMask(addrs, *p0, *p1, *p2)
	}

// CmdSetStencilWriteMask command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilWriteMask.html
func (x CommandBufferFacade)CmdSetStencilWriteMask(faceMask StencilFaceFlags, writeMask uint32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkStencilFaceFlags)(&faceMask)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&writeMask)
	C.vkCmdSetStencilWriteMask(addrs, *p0, *p1, *p2)
	}

// CmdSetStencilReference command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilReference.html
func (x CommandBufferFacade)CmdSetStencilReference(faceMask StencilFaceFlags, reference uint32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkStencilFaceFlags)(&faceMask)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&reference)
	C.vkCmdSetStencilReference(addrs, *p0, *p1, *p2)
	}

// CmdBindDescriptorSets command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindDescriptorSets.html
func (x CommandBufferFacade)CmdBindDescriptorSets(pipelineBindPoint PipelineBindPoint, layout PipelineLayout, firstSet uint32, descriptorSetCount uint32, pDescriptorSets []DescriptorSet, dynamicOffsetCount uint32, pDynamicOffsets []uint32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkPipelineBindPoint)(&pipelineBindPoint)
	p2 := /* handle */ (*C.VkPipelineLayout)(&layout)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&firstSet)
	p4 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&descriptorSetCount)
	p5 := func(x *[]DescriptorSet) **C.VkDescriptorSet { /* Slice */ if len(*x) > 0 { slc := (*C.VkDescriptorSet)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkDescriptorSet)(unsafe.Pointer((&ptr))) }(&pDescriptorSets)
	p6 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&dynamicOffsetCount)
	p7 := func(x *[]uint32) **C.uint32_t { /* Slice */ if len(*x) > 0 { slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.uint32_t)(unsafe.Pointer((&ptr))) }(&pDynamicOffsets)
	C.vkCmdBindDescriptorSets(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7)
	}

// CmdBindIndexBuffer command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindIndexBuffer.html
func (x CommandBufferFacade)CmdBindIndexBuffer(buffer Buffer, offset DeviceSize, indexType IndexType, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&buffer)
	p2 := /* typedef */ (*C.VkDeviceSize)(&offset)
	p3 := /* typedef */ (*C.VkIndexType)(&indexType)
	C.vkCmdBindIndexBuffer(addrs, *p0, *p1, *p2, *p3)
	}

// CmdBindVertexBuffers command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindVertexBuffers.html
func (x CommandBufferFacade)CmdBindVertexBuffers(firstBinding uint32, bindingCount uint32, pBuffers []Buffer, pOffsets []DeviceSize, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&firstBinding)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&bindingCount)
	p3 := func(x *[]Buffer) **C.VkBuffer { /* Slice */ if len(*x) > 0 { slc := (*C.VkBuffer)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkBuffer)(unsafe.Pointer((&ptr))) }(&pBuffers)
	p4 := func(x *[]DeviceSize) **C.VkDeviceSize { /* Slice */ if len(*x) > 0 { slc := (*C.VkDeviceSize)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkDeviceSize)(unsafe.Pointer((&ptr))) }(&pOffsets)
	C.vkCmdBindVertexBuffers(addrs, *p0, *p1, *p2, *p3, *p4)
	}

// CmdDraw command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDraw.html
func (x CommandBufferFacade)CmdDraw(vertexCount uint32, instanceCount uint32, firstVertex uint32, firstInstance uint32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&vertexCount)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&instanceCount)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&firstVertex)
	p4 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&firstInstance)
	C.vkCmdDraw(addrs, *p0, *p1, *p2, *p3, *p4)
	}

// CmdDrawIndexed command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndexed.html
func (x CommandBufferFacade)CmdDrawIndexed(indexCount uint32, instanceCount uint32, firstIndex uint32, vertexOffset int32, firstInstance uint32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&indexCount)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&instanceCount)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&firstIndex)
	p4 := func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&vertexOffset)
	p5 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&firstInstance)
	C.vkCmdDrawIndexed(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
	}

// CmdDrawIndirect command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndirect.html
func (x CommandBufferFacade)CmdDrawIndirect(buffer Buffer, offset DeviceSize, drawCount uint32, stride uint32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&buffer)
	p2 := /* typedef */ (*C.VkDeviceSize)(&offset)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&drawCount)
	p4 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&stride)
	C.vkCmdDrawIndirect(addrs, *p0, *p1, *p2, *p3, *p4)
	}

// CmdDrawIndexedIndirect command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndexedIndirect.html
func (x CommandBufferFacade)CmdDrawIndexedIndirect(buffer Buffer, offset DeviceSize, drawCount uint32, stride uint32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&buffer)
	p2 := /* typedef */ (*C.VkDeviceSize)(&offset)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&drawCount)
	p4 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&stride)
	C.vkCmdDrawIndexedIndirect(addrs, *p0, *p1, *p2, *p3, *p4)
	}

// CmdDispatch command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDispatch.html
func (x CommandBufferFacade)CmdDispatch(groupCountX uint32, groupCountY uint32, groupCountZ uint32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&groupCountX)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&groupCountY)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&groupCountZ)
	C.vkCmdDispatch(addrs, *p0, *p1, *p2, *p3)
	}

// CmdDispatchIndirect command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDispatchIndirect.html
func (x CommandBufferFacade)CmdDispatchIndirect(buffer Buffer, offset DeviceSize, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&buffer)
	p2 := /* typedef */ (*C.VkDeviceSize)(&offset)
	C.vkCmdDispatchIndirect(addrs, *p0, *p1, *p2)
	}

// CmdCopyBuffer command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBuffer.html
func (x CommandBufferFacade)CmdCopyBuffer(srcBuffer Buffer, dstBuffer Buffer, regionCount uint32, pRegions []BufferCopy, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&srcBuffer)
	p2 := /* handle */ (*C.VkBuffer)(&dstBuffer)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&regionCount)
	p4 := func(x *[]BufferCopy) **C.struct_VkBufferCopy { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkBufferCopy)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkBufferCopy)(unsafe.Pointer((&ptr))) }(&pRegions)
	C.vkCmdCopyBuffer(addrs, *p0, *p1, *p2, *p3, *p4)
	}

// CmdCopyImage command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImage.html
func (x CommandBufferFacade)CmdCopyImage(srcImage Image, srcImageLayout ImageLayout, dstImage Image, dstImageLayout ImageLayout, regionCount uint32, pRegions []ImageCopy, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&srcImage)
	p2 := /* typedef */ (*C.VkImageLayout)(&srcImageLayout)
	p3 := /* handle */ (*C.VkImage)(&dstImage)
	p4 := /* typedef */ (*C.VkImageLayout)(&dstImageLayout)
	p5 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&regionCount)
	p6 := func(x *[]ImageCopy) **C.struct_VkImageCopy { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkImageCopy)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkImageCopy)(unsafe.Pointer((&ptr))) }(&pRegions)
	C.vkCmdCopyImage(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6)
	}

// CmdBlitImage command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBlitImage.html
func (x CommandBufferFacade)CmdBlitImage(srcImage Image, srcImageLayout ImageLayout, dstImage Image, dstImageLayout ImageLayout, regionCount uint32, pRegions []ImageBlit, filter Filter, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&srcImage)
	p2 := /* typedef */ (*C.VkImageLayout)(&srcImageLayout)
	p3 := /* handle */ (*C.VkImage)(&dstImage)
	p4 := /* typedef */ (*C.VkImageLayout)(&dstImageLayout)
	p5 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&regionCount)
	p6 := func(x *[]ImageBlit) **C.struct_VkImageBlit { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkImageBlit)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkImageBlit)(unsafe.Pointer((&ptr))) }(&pRegions)
	p7 := /* typedef */ (*C.VkFilter)(&filter)
	C.vkCmdBlitImage(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7)
	}

// CmdCopyBufferToImage command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBufferToImage.html
func (x CommandBufferFacade)CmdCopyBufferToImage(srcBuffer Buffer, dstImage Image, dstImageLayout ImageLayout, regionCount uint32, pRegions []BufferImageCopy, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&srcBuffer)
	p2 := /* handle */ (*C.VkImage)(&dstImage)
	p3 := /* typedef */ (*C.VkImageLayout)(&dstImageLayout)
	p4 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&regionCount)
	p5 := func(x *[]BufferImageCopy) **C.struct_VkBufferImageCopy { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkBufferImageCopy)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkBufferImageCopy)(unsafe.Pointer((&ptr))) }(&pRegions)
	C.vkCmdCopyBufferToImage(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
	}

// CmdCopyImageToBuffer command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImageToBuffer.html
func (x CommandBufferFacade)CmdCopyImageToBuffer(srcImage Image, srcImageLayout ImageLayout, dstBuffer Buffer, regionCount uint32, pRegions []BufferImageCopy, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&srcImage)
	p2 := /* typedef */ (*C.VkImageLayout)(&srcImageLayout)
	p3 := /* handle */ (*C.VkBuffer)(&dstBuffer)
	p4 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&regionCount)
	p5 := func(x *[]BufferImageCopy) **C.struct_VkBufferImageCopy { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkBufferImageCopy)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkBufferImageCopy)(unsafe.Pointer((&ptr))) }(&pRegions)
	C.vkCmdCopyImageToBuffer(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
	}

// CmdUpdateBuffer command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdUpdateBuffer.html
func (x CommandBufferFacade)CmdUpdateBuffer(dstBuffer Buffer, dstOffset DeviceSize, dataSize DeviceSize, pData unsafe.Pointer, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&dstBuffer)
	p2 := /* typedef */ (*C.VkDeviceSize)(&dstOffset)
	p3 := /* typedef */ (*C.VkDeviceSize)(&dataSize)
	p4 := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&pData)
	C.vkCmdUpdateBuffer(addrs, *p0, *p1, *p2, *p3, *p4)
	}

// CmdFillBuffer command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdFillBuffer.html
func (x CommandBufferFacade)CmdFillBuffer(dstBuffer Buffer, dstOffset DeviceSize, size DeviceSize, data uint32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&dstBuffer)
	p2 := /* typedef */ (*C.VkDeviceSize)(&dstOffset)
	p3 := /* typedef */ (*C.VkDeviceSize)(&size)
	p4 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&data)
	C.vkCmdFillBuffer(addrs, *p0, *p1, *p2, *p3, *p4)
	}

// CreateBufferView command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateBufferView.html
func (x DeviceFacade)CreateBufferView(pCreateInfo *BufferViewCreateInfo, pAllocator *AllocationCallbacks, pView *BufferView, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **BufferViewCreateInfo) **C.struct_VkBufferViewCreateInfo { /* Pointer */ g2c := (*C.struct_VkBufferViewCreateInfo)(*x); return &g2c }(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p3 := func(x **BufferView) **C.VkBufferView { /* Pointer */ g2c := (*C.VkBufferView)(*x); return &g2c }(&pView)
	ret := C.vkCreateBufferView(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CmdClearDepthStencilImage command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdClearDepthStencilImage.html
func (x CommandBufferFacade)CmdClearDepthStencilImage(image Image, imageLayout ImageLayout, pDepthStencil *ClearDepthStencilValue, rangeCount uint32, pRanges []ImageSubresourceRange, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&image)
	p2 := /* typedef */ (*C.VkImageLayout)(&imageLayout)
	p3 := func(x **ClearDepthStencilValue) **C.struct_VkClearDepthStencilValue { /* Pointer */ g2c := (*C.struct_VkClearDepthStencilValue)(*x); return &g2c }(&pDepthStencil)
	p4 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&rangeCount)
	p5 := func(x *[]ImageSubresourceRange) **C.struct_VkImageSubresourceRange { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkImageSubresourceRange)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkImageSubresourceRange)(unsafe.Pointer((&ptr))) }(&pRanges)
	C.vkCmdClearDepthStencilImage(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
	}

// CmdClearAttachments command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdClearAttachments.html
func (x CommandBufferFacade)CmdClearAttachments(attachmentCount uint32, pAttachments []ClearAttachment, rectCount uint32, pRects []ClearRect, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&attachmentCount)
	p2 := func(x *[]ClearAttachment) **C.struct_VkClearAttachment { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkClearAttachment)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkClearAttachment)(unsafe.Pointer((&ptr))) }(&pAttachments)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&rectCount)
	p4 := func(x *[]ClearRect) **C.struct_VkClearRect { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkClearRect)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkClearRect)(unsafe.Pointer((&ptr))) }(&pRects)
	C.vkCmdClearAttachments(addrs, *p0, *p1, *p2, *p3, *p4)
	}

// CmdResolveImage command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResolveImage.html
func (x CommandBufferFacade)CmdResolveImage(srcImage Image, srcImageLayout ImageLayout, dstImage Image, dstImageLayout ImageLayout, regionCount uint32, pRegions []ImageResolve, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&srcImage)
	p2 := /* typedef */ (*C.VkImageLayout)(&srcImageLayout)
	p3 := /* handle */ (*C.VkImage)(&dstImage)
	p4 := /* typedef */ (*C.VkImageLayout)(&dstImageLayout)
	p5 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&regionCount)
	p6 := func(x *[]ImageResolve) **C.struct_VkImageResolve { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkImageResolve)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkImageResolve)(unsafe.Pointer((&ptr))) }(&pRegions)
	C.vkCmdResolveImage(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6)
	}

// CmdSetEvent command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetEvent.html
func (x CommandBufferFacade)CmdSetEvent(event Event, stageMask PipelineStageFlags, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkEvent)(&event)
	p2 := /* typedef */ (*C.VkPipelineStageFlags)(&stageMask)
	C.vkCmdSetEvent(addrs, *p0, *p1, *p2)
	}

// CmdResetEvent command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResetEvent.html
func (x CommandBufferFacade)CmdResetEvent(event Event, stageMask PipelineStageFlags, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkEvent)(&event)
	p2 := /* typedef */ (*C.VkPipelineStageFlags)(&stageMask)
	C.vkCmdResetEvent(addrs, *p0, *p1, *p2)
	}

// CmdWaitEvents command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWaitEvents.html
func (x CommandBufferFacade)CmdWaitEvents(eventCount uint32, pEvents []Event, srcStageMask PipelineStageFlags, dstStageMask PipelineStageFlags, memoryBarrierCount uint32, pMemoryBarriers []MemoryBarrier, bufferMemoryBarrierCount uint32, pBufferMemoryBarriers []BufferMemoryBarrier, imageMemoryBarrierCount uint32, pImageMemoryBarriers []ImageMemoryBarrier, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&eventCount)
	p2 := func(x *[]Event) **C.VkEvent { /* Slice */ if len(*x) > 0 { slc := (*C.VkEvent)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkEvent)(unsafe.Pointer((&ptr))) }(&pEvents)
	p3 := /* typedef */ (*C.VkPipelineStageFlags)(&srcStageMask)
	p4 := /* typedef */ (*C.VkPipelineStageFlags)(&dstStageMask)
	p5 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&memoryBarrierCount)
	p6 := func(x *[]MemoryBarrier) **C.struct_VkMemoryBarrier { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkMemoryBarrier)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkMemoryBarrier)(unsafe.Pointer((&ptr))) }(&pMemoryBarriers)
	p7 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&bufferMemoryBarrierCount)
	p8 := func(x *[]BufferMemoryBarrier) **C.struct_VkBufferMemoryBarrier { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkBufferMemoryBarrier)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkBufferMemoryBarrier)(unsafe.Pointer((&ptr))) }(&pBufferMemoryBarriers)
	p9 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&imageMemoryBarrierCount)
	p10 := func(x *[]ImageMemoryBarrier) **C.struct_VkImageMemoryBarrier { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkImageMemoryBarrier)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkImageMemoryBarrier)(unsafe.Pointer((&ptr))) }(&pImageMemoryBarriers)
	C.vkCmdWaitEvents(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7, *p8, *p9, *p10)
	}

// CmdPipelineBarrier command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPipelineBarrier.html
func (x CommandBufferFacade)CmdPipelineBarrier(srcStageMask PipelineStageFlags, dstStageMask PipelineStageFlags, dependencyFlags DependencyFlags, memoryBarrierCount uint32, pMemoryBarriers []MemoryBarrier, bufferMemoryBarrierCount uint32, pBufferMemoryBarriers []BufferMemoryBarrier, imageMemoryBarrierCount uint32, pImageMemoryBarriers []ImageMemoryBarrier, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkPipelineStageFlags)(&srcStageMask)
	p2 := /* typedef */ (*C.VkPipelineStageFlags)(&dstStageMask)
	p3 := /* typedef */ (*C.VkDependencyFlags)(&dependencyFlags)
	p4 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&memoryBarrierCount)
	p5 := func(x *[]MemoryBarrier) **C.struct_VkMemoryBarrier { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkMemoryBarrier)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkMemoryBarrier)(unsafe.Pointer((&ptr))) }(&pMemoryBarriers)
	p6 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&bufferMemoryBarrierCount)
	p7 := func(x *[]BufferMemoryBarrier) **C.struct_VkBufferMemoryBarrier { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkBufferMemoryBarrier)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkBufferMemoryBarrier)(unsafe.Pointer((&ptr))) }(&pBufferMemoryBarriers)
	p8 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&imageMemoryBarrierCount)
	p9 := func(x *[]ImageMemoryBarrier) **C.struct_VkImageMemoryBarrier { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkImageMemoryBarrier)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkImageMemoryBarrier)(unsafe.Pointer((&ptr))) }(&pImageMemoryBarriers)
	C.vkCmdPipelineBarrier(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7, *p8, *p9)
	}

// CmdBeginQuery command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginQuery.html
func (x CommandBufferFacade)CmdBeginQuery(queryPool QueryPool, query uint32, flags QueryControlFlags, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkQueryPool)(&queryPool)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&query)
	p3 := /* typedef */ (*C.VkQueryControlFlags)(&flags)
	C.vkCmdBeginQuery(addrs, *p0, *p1, *p2, *p3)
	}

// CmdEndQuery command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndQuery.html
func (x CommandBufferFacade)CmdEndQuery(queryPool QueryPool, query uint32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkQueryPool)(&queryPool)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&query)
	C.vkCmdEndQuery(addrs, *p0, *p1, *p2)
	}

// CmdResetQueryPool command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResetQueryPool.html
func (x CommandBufferFacade)CmdResetQueryPool(queryPool QueryPool, firstQuery uint32, queryCount uint32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkQueryPool)(&queryPool)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&firstQuery)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&queryCount)
	C.vkCmdResetQueryPool(addrs, *p0, *p1, *p2, *p3)
	}

// CmdWriteTimestamp command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteTimestamp.html
func (x CommandBufferFacade)CmdWriteTimestamp(pipelineStage PipelineStageFlagBits, queryPool QueryPool, query uint32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkPipelineStageFlagBits)(&pipelineStage)
	p2 := /* handle */ (*C.VkQueryPool)(&queryPool)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&query)
	C.vkCmdWriteTimestamp(addrs, *p0, *p1, *p2, *p3)
	}

// CmdCopyQueryPoolResults command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyQueryPoolResults.html
func (x CommandBufferFacade)CmdCopyQueryPoolResults(queryPool QueryPool, firstQuery uint32, queryCount uint32, dstBuffer Buffer, dstOffset DeviceSize, stride DeviceSize, flags QueryResultFlags, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkQueryPool)(&queryPool)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&firstQuery)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&queryCount)
	p4 := /* handle */ (*C.VkBuffer)(&dstBuffer)
	p5 := /* typedef */ (*C.VkDeviceSize)(&dstOffset)
	p6 := /* typedef */ (*C.VkDeviceSize)(&stride)
	p7 := /* typedef */ (*C.VkQueryResultFlags)(&flags)
	C.vkCmdCopyQueryPoolResults(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7)
	}

// CmdPushConstants command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPushConstants.html
func (x CommandBufferFacade)CmdPushConstants(layout PipelineLayout, stageFlags ShaderStageFlags, offset uint32, size uint32, pValues unsafe.Pointer, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkPipelineLayout)(&layout)
	p2 := /* typedef */ (*C.VkShaderStageFlags)(&stageFlags)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&offset)
	p4 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&size)
	p5 := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&pValues)
	C.vkCmdPushConstants(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
	}

// CmdBeginRenderPass command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass.html
func (x CommandBufferFacade)CmdBeginRenderPass(pRenderPassBegin *RenderPassBeginInfo, contents SubpassContents, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **RenderPassBeginInfo) **C.struct_VkRenderPassBeginInfo { /* Pointer */ g2c := (*C.struct_VkRenderPassBeginInfo)(*x); return &g2c }(&pRenderPassBegin)
	p2 := /* typedef */ (*C.VkSubpassContents)(&contents)
	C.vkCmdBeginRenderPass(addrs, *p0, *p1, *p2)
	}

// CmdNextSubpass command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdNextSubpass.html
func (x CommandBufferFacade)CmdNextSubpass(contents SubpassContents, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkSubpassContents)(&contents)
	C.vkCmdNextSubpass(addrs, *p0, *p1)
	}

// CmdEndRenderPass command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndRenderPass.html
func (x CommandBufferFacade)CmdEndRenderPass() {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	C.vkCmdEndRenderPass(addrs, *p0)
	}

// CmdExecuteCommands command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdExecuteCommands.html
func (x CommandBufferFacade)CmdExecuteCommands(commandBufferCount uint32, pCommandBuffers []CommandBuffer, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&commandBufferCount)
	p2 := func(x *[]CommandBuffer) **C.VkCommandBuffer { /* Slice */ if len(*x) > 0 { slc := (*C.VkCommandBuffer)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkCommandBuffer)(unsafe.Pointer((&ptr))) }(&pCommandBuffers)
	C.vkCmdExecuteCommands(addrs, *p0, *p1, *p2)
	}

// CreateFence command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateFence.html
func (x DeviceFacade)CreateFence(pCreateInfo *FenceCreateInfo, pAllocator *AllocationCallbacks, pFence *Fence, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **FenceCreateInfo) **C.struct_VkFenceCreateInfo { /* Pointer */ g2c := (*C.struct_VkFenceCreateInfo)(*x); return &g2c }(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p3 := func(x **Fence) **C.VkFence { /* Pointer */ g2c := (*C.VkFence)(*x); return &g2c }(&pFence)
	ret := C.vkCreateFence(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroyBuffer command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyBuffer.html
func (x DeviceFacade)DestroyBuffer(buffer Buffer, pAllocator *AllocationCallbacks, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&buffer)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	C.vkDestroyBuffer(addrs, *p0, *p1, *p2)
	}

// CreateBuffer command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateBuffer.html
func (x DeviceFacade)CreateBuffer(pCreateInfo *BufferCreateInfo, pAllocator *AllocationCallbacks, pBuffer *Buffer, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **BufferCreateInfo) **C.struct_VkBufferCreateInfo { /* Pointer */ g2c := (*C.struct_VkBufferCreateInfo)(*x); return &g2c }(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p3 := func(x **Buffer) **C.VkBuffer { /* Pointer */ g2c := (*C.VkBuffer)(*x); return &g2c }(&pBuffer)
	ret := C.vkCreateBuffer(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroyFence command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyFence.html
func (x DeviceFacade)DestroyFence(fence Fence, pAllocator *AllocationCallbacks, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkFence)(&fence)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	C.vkDestroyFence(addrs, *p0, *p1, *p2)
	}

// ResetFences command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetFences.html
func (x DeviceFacade)ResetFences(fenceCount uint32, pFences []Fence, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&fenceCount)
	p2 := func(x *[]Fence) **C.VkFence { /* Slice */ if len(*x) > 0 { slc := (*C.VkFence)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkFence)(unsafe.Pointer((&ptr))) }(&pFences)
	ret := C.vkResetFences(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetFenceStatus command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetFenceStatus.html
func (x DeviceFacade)GetFenceStatus(fence Fence, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkFence)(&fence)
	ret := C.vkGetFenceStatus(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CreateSemaphore command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSemaphore.html
func (x DeviceFacade)CreateSemaphore(pCreateInfo *SemaphoreCreateInfo, pAllocator *AllocationCallbacks, pSemaphore *Semaphore, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **SemaphoreCreateInfo) **C.struct_VkSemaphoreCreateInfo { /* Pointer */ g2c := (*C.struct_VkSemaphoreCreateInfo)(*x); return &g2c }(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p3 := func(x **Semaphore) **C.VkSemaphore { /* Pointer */ g2c := (*C.VkSemaphore)(*x); return &g2c }(&pSemaphore)
	ret := C.vkCreateSemaphore(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroySemaphore command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySemaphore.html
func (x DeviceFacade)DestroySemaphore(semaphore Semaphore, pAllocator *AllocationCallbacks, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkSemaphore)(&semaphore)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	C.vkDestroySemaphore(addrs, *p0, *p1, *p2)
	}

// GetQueryPoolResults command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetQueryPoolResults.html
func (x DeviceFacade)GetQueryPoolResults(queryPool QueryPool, firstQuery uint32, queryCount uint32, dataSize uint64, pData unsafe.Pointer, stride DeviceSize, flags QueryResultFlags, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkQueryPool)(&queryPool)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&firstQuery)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&queryCount)
	p4 := func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&dataSize)
	p5 := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&pData)
	p6 := /* typedef */ (*C.VkDeviceSize)(&stride)
	p7 := /* typedef */ (*C.VkQueryResultFlags)(&flags)
	ret := C.vkGetQueryPoolResults(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroyQueryPool command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyQueryPool.html
func (x DeviceFacade)DestroyQueryPool(queryPool QueryPool, pAllocator *AllocationCallbacks, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkQueryPool)(&queryPool)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	C.vkDestroyQueryPool(addrs, *p0, *p1, *p2)
	}

// CreateQueryPool command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateQueryPool.html
func (x DeviceFacade)CreateQueryPool(pCreateInfo *QueryPoolCreateInfo, pAllocator *AllocationCallbacks, pQueryPool *QueryPool, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **QueryPoolCreateInfo) **C.struct_VkQueryPoolCreateInfo { /* Pointer */ g2c := (*C.struct_VkQueryPoolCreateInfo)(*x); return &g2c }(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p3 := func(x **QueryPool) **C.VkQueryPool { /* Pointer */ g2c := (*C.VkQueryPool)(*x); return &g2c }(&pQueryPool)
	ret := C.vkCreateQueryPool(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CreateEvent command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateEvent.html
func (x DeviceFacade)CreateEvent(pCreateInfo *EventCreateInfo, pAllocator *AllocationCallbacks, pEvent *Event, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **EventCreateInfo) **C.struct_VkEventCreateInfo { /* Pointer */ g2c := (*C.struct_VkEventCreateInfo)(*x); return &g2c }(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p3 := func(x **Event) **C.VkEvent { /* Pointer */ g2c := (*C.VkEvent)(*x); return &g2c }(&pEvent)
	ret := C.vkCreateEvent(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroyEvent command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyEvent.html
func (x DeviceFacade)DestroyEvent(event Event, pAllocator *AllocationCallbacks, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkEvent)(&event)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	C.vkDestroyEvent(addrs, *p0, *p1, *p2)
	}

// GetEventStatus command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetEventStatus.html
func (x DeviceFacade)GetEventStatus(event Event, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkEvent)(&event)
	ret := C.vkGetEventStatus(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// ResetEvent command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetEvent.html
func (x DeviceFacade)ResetEvent(event Event, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkEvent)(&event)
	ret := C.vkResetEvent(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CmdClearColorImage command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdClearColorImage.html
func (x CommandBufferFacade)CmdClearColorImage(image Image, imageLayout ImageLayout, pColor *ClearColorValue, rangeCount uint32, pRanges []ImageSubresourceRange, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkImage)(&image)
	p2 := /* typedef */ (*C.VkImageLayout)(&imageLayout)
	p3 := func(x **ClearColorValue) **C.VkClearColorValue { /* Pointer */ g2c := (*C.VkClearColorValue)(*x); return &g2c }(&pColor)
	p4 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&rangeCount)
	p5 := func(x *[]ImageSubresourceRange) **C.struct_VkImageSubresourceRange { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkImageSubresourceRange)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkImageSubresourceRange)(unsafe.Pointer((&ptr))) }(&pRanges)
	C.vkCmdClearColorImage(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
	}

// DescriptorUpdateTemplate is a Handle to a vulkan resource.
// DescriptorUpdateTemplate is a child of Device.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorUpdateTemplate.html
type DescriptorUpdateTemplate C.VkDescriptorUpdateTemplate

// NullDescriptorUpdateTemplate is a typed Null value for the DescriptorUpdateTemplate type.
var NullDescriptorUpdateTemplate DescriptorUpdateTemplate


// SamplerYcbcrConversion is a Handle to a vulkan resource.
// SamplerYcbcrConversion is a child of Device.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerYcbcrConversion.html
type SamplerYcbcrConversion C.VkSamplerYcbcrConversion

// NullSamplerYcbcrConversion is a typed Null value for the SamplerYcbcrConversion type.
var NullSamplerYcbcrConversion SamplerYcbcrConversion


// ExternalFenceHandleTypeFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalFenceHandleTypeFlagBits.html
type ExternalFenceHandleTypeFlagBits uint32

const (
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT ExternalFenceHandleTypeFlagBits = (1 << 0)
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT ExternalFenceHandleTypeFlagBits = (1 << 1)
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT ExternalFenceHandleTypeFlagBits = (1 << 2)
	VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT ExternalFenceHandleTypeFlagBits = (1 << 3)
)

var (
	reverseExternalFenceHandleTypeFlagBits map[ExternalFenceHandleTypeFlagBits]string = map[ExternalFenceHandleTypeFlagBits]string{ 
		VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT: "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT",
		VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT: "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT",
		VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT",
		VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT: "VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT",
	}
)
func (x ExternalFenceHandleTypeFlagBits) String() string {
	if s, ok := reverseExternalFenceHandleTypeFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ExternalFenceHandleTypeFlagBits=%d", x)
}

// SubgroupFeatureFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubgroupFeatureFlagBits.html
type SubgroupFeatureFlagBits uint32

const (
	VK_SUBGROUP_FEATURE_BASIC_BIT SubgroupFeatureFlagBits = (1 << 0)
	VK_SUBGROUP_FEATURE_VOTE_BIT SubgroupFeatureFlagBits = (1 << 1)
	VK_SUBGROUP_FEATURE_ARITHMETIC_BIT SubgroupFeatureFlagBits = (1 << 2)
	VK_SUBGROUP_FEATURE_BALLOT_BIT SubgroupFeatureFlagBits = (1 << 3)
	VK_SUBGROUP_FEATURE_SHUFFLE_BIT SubgroupFeatureFlagBits = (1 << 4)
	VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT SubgroupFeatureFlagBits = (1 << 5)
	VK_SUBGROUP_FEATURE_CLUSTERED_BIT SubgroupFeatureFlagBits = (1 << 6)
	VK_SUBGROUP_FEATURE_QUAD_BIT SubgroupFeatureFlagBits = (1 << 7)
)

var (
	reverseSubgroupFeatureFlagBits map[SubgroupFeatureFlagBits]string = map[SubgroupFeatureFlagBits]string{ 
		VK_SUBGROUP_FEATURE_BASIC_BIT: "VK_SUBGROUP_FEATURE_BASIC_BIT",
		VK_SUBGROUP_FEATURE_VOTE_BIT: "VK_SUBGROUP_FEATURE_VOTE_BIT",
		VK_SUBGROUP_FEATURE_ARITHMETIC_BIT: "VK_SUBGROUP_FEATURE_ARITHMETIC_BIT",
		VK_SUBGROUP_FEATURE_BALLOT_BIT: "VK_SUBGROUP_FEATURE_BALLOT_BIT",
		VK_SUBGROUP_FEATURE_SHUFFLE_BIT: "VK_SUBGROUP_FEATURE_SHUFFLE_BIT",
		VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT: "VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT",
		VK_SUBGROUP_FEATURE_CLUSTERED_BIT: "VK_SUBGROUP_FEATURE_CLUSTERED_BIT",
		VK_SUBGROUP_FEATURE_QUAD_BIT: "VK_SUBGROUP_FEATURE_QUAD_BIT",
	}
)
func (x SubgroupFeatureFlagBits) String() string {
	if s, ok := reverseSubgroupFeatureFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("SubgroupFeatureFlagBits=%d", x)
}

// ExternalMemoryHandleTypeFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalMemoryHandleTypeFlagBits.html
type ExternalMemoryHandleTypeFlagBits uint32

const (
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT ExternalMemoryHandleTypeFlagBits = (1 << 0)
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT ExternalMemoryHandleTypeFlagBits = (1 << 1)
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT ExternalMemoryHandleTypeFlagBits = (1 << 2)
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT ExternalMemoryHandleTypeFlagBits = (1 << 3)
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT ExternalMemoryHandleTypeFlagBits = (1 << 4)
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT ExternalMemoryHandleTypeFlagBits = (1 << 5)
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT ExternalMemoryHandleTypeFlagBits = (1 << 6)
)

var (
	reverseExternalMemoryHandleTypeFlagBits map[ExternalMemoryHandleTypeFlagBits]string = map[ExternalMemoryHandleTypeFlagBits]string{ 
		VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT: "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT",
		VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT: "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT",
		VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT",
		VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT: "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT",
		VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT: "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT",
		VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT: "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT",
		VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT: "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT",
	}
)
func (x ExternalMemoryHandleTypeFlagBits) String() string {
	if s, ok := reverseExternalMemoryHandleTypeFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ExternalMemoryHandleTypeFlagBits=%d", x)
}

// ExternalFenceFeatureFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalFenceFeatureFlagBits.html
type ExternalFenceFeatureFlagBits uint32

const (
	VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT ExternalFenceFeatureFlagBits = (1 << 0)
	VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT ExternalFenceFeatureFlagBits = (1 << 1)
)

var (
	reverseExternalFenceFeatureFlagBits map[ExternalFenceFeatureFlagBits]string = map[ExternalFenceFeatureFlagBits]string{ 
		VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT: "VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT",
		VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT: "VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT",
	}
)
func (x ExternalFenceFeatureFlagBits) String() string {
	if s, ok := reverseExternalFenceFeatureFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ExternalFenceFeatureFlagBits=%d", x)
}

// DescriptorUpdateTemplateType enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorUpdateTemplateType.html
type DescriptorUpdateTemplateType uint32

const (
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET DescriptorUpdateTemplateType = 0
)

var (
	reverseDescriptorUpdateTemplateType map[DescriptorUpdateTemplateType]string = map[DescriptorUpdateTemplateType]string{ 
		VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET: "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET",
	}
)
func (x DescriptorUpdateTemplateType) String() string {
	if s, ok := reverseDescriptorUpdateTemplateType[x]; ok {
		return s
	}
	return fmt.Sprintf("DescriptorUpdateTemplateType=%d", x)
}

// SamplerYcbcrRange enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerYcbcrRange.html
type SamplerYcbcrRange uint32

const (
	VK_SAMPLER_YCBCR_RANGE_ITU_FULL SamplerYcbcrRange = 0
	VK_SAMPLER_YCBCR_RANGE_ITU_NARROW SamplerYcbcrRange = 1
)

var (
	reverseSamplerYcbcrRange map[SamplerYcbcrRange]string = map[SamplerYcbcrRange]string{ 
		VK_SAMPLER_YCBCR_RANGE_ITU_FULL: "VK_SAMPLER_YCBCR_RANGE_ITU_FULL",
		VK_SAMPLER_YCBCR_RANGE_ITU_NARROW: "VK_SAMPLER_YCBCR_RANGE_ITU_NARROW",
	}
)
func (x SamplerYcbcrRange) String() string {
	if s, ok := reverseSamplerYcbcrRange[x]; ok {
		return s
	}
	return fmt.Sprintf("SamplerYcbcrRange=%d", x)
}

// ExternalSemaphoreHandleTypeFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalSemaphoreHandleTypeFlagBits.html
type ExternalSemaphoreHandleTypeFlagBits uint32

const (
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT ExternalSemaphoreHandleTypeFlagBits = (1 << 0)
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT ExternalSemaphoreHandleTypeFlagBits = (1 << 1)
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT ExternalSemaphoreHandleTypeFlagBits = (1 << 2)
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT ExternalSemaphoreHandleTypeFlagBits = (1 << 3)
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT ExternalSemaphoreHandleTypeFlagBits = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT ExternalSemaphoreHandleTypeFlagBits = (1 << 4)
)

var (
	reverseExternalSemaphoreHandleTypeFlagBits map[ExternalSemaphoreHandleTypeFlagBits]string = map[ExternalSemaphoreHandleTypeFlagBits]string{ 
		VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT: "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT",
		VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT: "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT",
		VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT",
		VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT: "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT",
		VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT: "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT",
	}
)
func (x ExternalSemaphoreHandleTypeFlagBits) String() string {
	if s, ok := reverseExternalSemaphoreHandleTypeFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ExternalSemaphoreHandleTypeFlagBits=%d", x)
}

// ChromaLocation enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkChromaLocation.html
type ChromaLocation uint32

const (
	VK_CHROMA_LOCATION_COSITED_EVEN ChromaLocation = 0
	VK_CHROMA_LOCATION_MIDPOINT ChromaLocation = 1
)

var (
	reverseChromaLocation map[ChromaLocation]string = map[ChromaLocation]string{ 
		VK_CHROMA_LOCATION_COSITED_EVEN: "VK_CHROMA_LOCATION_COSITED_EVEN",
		VK_CHROMA_LOCATION_MIDPOINT: "VK_CHROMA_LOCATION_MIDPOINT",
	}
)
func (x ChromaLocation) String() string {
	if s, ok := reverseChromaLocation[x]; ok {
		return s
	}
	return fmt.Sprintf("ChromaLocation=%d", x)
}

// SamplerYcbcrModelConversion enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerYcbcrModelConversion.html
type SamplerYcbcrModelConversion uint32

const (
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY SamplerYcbcrModelConversion = 0
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY SamplerYcbcrModelConversion = 1
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 SamplerYcbcrModelConversion = 2
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 SamplerYcbcrModelConversion = 3
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 SamplerYcbcrModelConversion = 4
)

var (
	reverseSamplerYcbcrModelConversion map[SamplerYcbcrModelConversion]string = map[SamplerYcbcrModelConversion]string{ 
		VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY: "VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY",
		VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY: "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY",
		VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709: "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709",
		VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601: "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601",
		VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020: "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020",
	}
)
func (x SamplerYcbcrModelConversion) String() string {
	if s, ok := reverseSamplerYcbcrModelConversion[x]; ok {
		return s
	}
	return fmt.Sprintf("SamplerYcbcrModelConversion=%d", x)
}

// FenceImportFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFenceImportFlagBits.html
type FenceImportFlagBits uint32

const (
	VK_FENCE_IMPORT_TEMPORARY_BIT FenceImportFlagBits = (1 << 0)
)

var (
	reverseFenceImportFlagBits map[FenceImportFlagBits]string = map[FenceImportFlagBits]string{ 
		VK_FENCE_IMPORT_TEMPORARY_BIT: "VK_FENCE_IMPORT_TEMPORARY_BIT",
	}
)
func (x FenceImportFlagBits) String() string {
	if s, ok := reverseFenceImportFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("FenceImportFlagBits=%d", x)
}

// PointClippingBehavior enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPointClippingBehavior.html
type PointClippingBehavior uint32

const (
	VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES PointClippingBehavior = 0
	VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY PointClippingBehavior = 1
)

var (
	reversePointClippingBehavior map[PointClippingBehavior]string = map[PointClippingBehavior]string{ 
		VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES: "VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES",
		VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY: "VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY",
	}
)
func (x PointClippingBehavior) String() string {
	if s, ok := reversePointClippingBehavior[x]; ok {
		return s
	}
	return fmt.Sprintf("PointClippingBehavior=%d", x)
}

// ExternalSemaphoreFeatureFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalSemaphoreFeatureFlagBits.html
type ExternalSemaphoreFeatureFlagBits uint32

const (
	VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT ExternalSemaphoreFeatureFlagBits = (1 << 0)
	VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT ExternalSemaphoreFeatureFlagBits = (1 << 1)
)

var (
	reverseExternalSemaphoreFeatureFlagBits map[ExternalSemaphoreFeatureFlagBits]string = map[ExternalSemaphoreFeatureFlagBits]string{ 
		VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT: "VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT",
		VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT: "VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT",
	}
)
func (x ExternalSemaphoreFeatureFlagBits) String() string {
	if s, ok := reverseExternalSemaphoreFeatureFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ExternalSemaphoreFeatureFlagBits=%d", x)
}

// TessellationDomainOrigin enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkTessellationDomainOrigin.html
type TessellationDomainOrigin uint32

const (
	VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT TessellationDomainOrigin = 0
	VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT TessellationDomainOrigin = 1
)

var (
	reverseTessellationDomainOrigin map[TessellationDomainOrigin]string = map[TessellationDomainOrigin]string{ 
		VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT: "VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT",
		VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT: "VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT",
	}
)
func (x TessellationDomainOrigin) String() string {
	if s, ok := reverseTessellationDomainOrigin[x]; ok {
		return s
	}
	return fmt.Sprintf("TessellationDomainOrigin=%d", x)
}

// ExternalMemoryFeatureFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalMemoryFeatureFlagBits.html
type ExternalMemoryFeatureFlagBits uint32

const (
	VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT ExternalMemoryFeatureFlagBits = (1 << 0)
	VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT ExternalMemoryFeatureFlagBits = (1 << 1)
	VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT ExternalMemoryFeatureFlagBits = (1 << 2)
)

var (
	reverseExternalMemoryFeatureFlagBits map[ExternalMemoryFeatureFlagBits]string = map[ExternalMemoryFeatureFlagBits]string{ 
		VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT: "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT",
		VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT: "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT",
		VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT: "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT",
	}
)
func (x ExternalMemoryFeatureFlagBits) String() string {
	if s, ok := reverseExternalMemoryFeatureFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ExternalMemoryFeatureFlagBits=%d", x)
}

// PeerMemoryFeatureFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPeerMemoryFeatureFlagBits.html
type PeerMemoryFeatureFlagBits uint32

const (
	VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT PeerMemoryFeatureFlagBits = (1 << 0)
	VK_PEER_MEMORY_FEATURE_COPY_DST_BIT PeerMemoryFeatureFlagBits = (1 << 1)
	VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT PeerMemoryFeatureFlagBits = (1 << 2)
	VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT PeerMemoryFeatureFlagBits = (1 << 3)
)

var (
	reversePeerMemoryFeatureFlagBits map[PeerMemoryFeatureFlagBits]string = map[PeerMemoryFeatureFlagBits]string{ 
		VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT: "VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT",
		VK_PEER_MEMORY_FEATURE_COPY_DST_BIT: "VK_PEER_MEMORY_FEATURE_COPY_DST_BIT",
		VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT: "VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT",
		VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT: "VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT",
	}
)
func (x PeerMemoryFeatureFlagBits) String() string {
	if s, ok := reversePeerMemoryFeatureFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("PeerMemoryFeatureFlagBits=%d", x)
}

// MemoryAllocateFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryAllocateFlagBits.html
type MemoryAllocateFlagBits uint32

const (
	VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT MemoryAllocateFlagBits = (1 << 0)
	VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT MemoryAllocateFlagBits = (1 << 1)
	VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT MemoryAllocateFlagBits = (1 << 2)
)

var (
	reverseMemoryAllocateFlagBits map[MemoryAllocateFlagBits]string = map[MemoryAllocateFlagBits]string{ 
		VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT: "VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT",
		VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT: "VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT",
		VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT: "VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT",
	}
)
func (x MemoryAllocateFlagBits) String() string {
	if s, ok := reverseMemoryAllocateFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("MemoryAllocateFlagBits=%d", x)
}

// SemaphoreImportFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreImportFlagBits.html
type SemaphoreImportFlagBits uint32

const (
	VK_SEMAPHORE_IMPORT_TEMPORARY_BIT SemaphoreImportFlagBits = (1 << 0)
)

var (
	reverseSemaphoreImportFlagBits map[SemaphoreImportFlagBits]string = map[SemaphoreImportFlagBits]string{ 
		VK_SEMAPHORE_IMPORT_TEMPORARY_BIT: "VK_SEMAPHORE_IMPORT_TEMPORARY_BIT",
	}
)
func (x SemaphoreImportFlagBits) String() string {
	if s, ok := reverseSemaphoreImportFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("SemaphoreImportFlagBits=%d", x)
}

// MemoryAllocateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryAllocateFlags.html
type MemoryAllocateFlags Flags

// PeerMemoryFeatureFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPeerMemoryFeatureFlags.html
type PeerMemoryFeatureFlags Flags

// ExternalFenceHandleTypeFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalFenceHandleTypeFlags.html
type ExternalFenceHandleTypeFlags Flags

// CommandPoolTrimFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandPoolTrimFlags.html
type CommandPoolTrimFlags Flags

// ExternalFenceFeatureFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalFenceFeatureFlags.html
type ExternalFenceFeatureFlags Flags

// DescriptorUpdateTemplateCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorUpdateTemplateCreateFlags.html
type DescriptorUpdateTemplateCreateFlags Flags

// ExternalSemaphoreFeatureFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalSemaphoreFeatureFlags.html
type ExternalSemaphoreFeatureFlags Flags

// ExternalMemoryHandleTypeFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalMemoryHandleTypeFlags.html
type ExternalMemoryHandleTypeFlags Flags

// FenceImportFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFenceImportFlags.html
type FenceImportFlags Flags

// SubgroupFeatureFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubgroupFeatureFlags.html
type SubgroupFeatureFlags Flags

// ExternalSemaphoreHandleTypeFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalSemaphoreHandleTypeFlags.html
type ExternalSemaphoreHandleTypeFlags Flags

// ExternalMemoryFeatureFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalMemoryFeatureFlags.html
type ExternalMemoryFeatureFlags Flags

// SemaphoreImportFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreImportFlags.html
type SemaphoreImportFlags Flags

// PhysicalDeviceMemoryProperties2 provides a go interface for VkPhysicalDeviceMemoryProperties2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryProperties2.html
type PhysicalDeviceMemoryProperties2 C.struct_VkPhysicalDeviceMemoryProperties2

// SizeofPhysicalDeviceMemoryProperties2 is the memory size of a PhysicalDeviceMemoryProperties2
var SizeofPhysicalDeviceMemoryProperties2 int = int(unsafe.Sizeof(PhysicalDeviceMemoryProperties2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceMemoryProperties2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceMemoryProperties2) AsCPtr() *PhysicalDeviceMemoryProperties2 {
	clone := (*PhysicalDeviceMemoryProperties2)(newCBlock(C.ulong(SizeofPhysicalDeviceMemoryProperties2)))
	*clone = x
	return clone
}

// PhysicalDeviceMemoryProperties2FreeCSlice releases the memory allocated by PhysicalDeviceMemoryProperties2MakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceMemoryProperties2FreeCSlice(x []PhysicalDeviceMemoryProperties2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceMemoryProperties2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceMemoryProperties2FreeCSlice must be called on the returned slice.
func PhysicalDeviceMemoryProperties2MakeCSlice(x ...PhysicalDeviceMemoryProperties2) []PhysicalDeviceMemoryProperties2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceMemoryProperties2 * len(x)
	dst := unsafe.Slice((*PhysicalDeviceMemoryProperties2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceMemoryProperties2
func (x PhysicalDeviceMemoryProperties2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceMemoryProperties2) WithDefaultSType() PhysicalDeviceMemoryProperties2 {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMemoryProperties2) WithSType(y StructureType) PhysicalDeviceMemoryProperties2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceMemoryProperties2
func (x PhysicalDeviceMemoryProperties2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMemoryProperties2) WithPNext(y unsafe.Pointer) PhysicalDeviceMemoryProperties2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// MemoryProperties returns the value of memoryProperties from VkPhysicalDeviceMemoryProperties2
func (x PhysicalDeviceMemoryProperties2) MemoryProperties() PhysicalDeviceMemoryProperties {
	ptr := /* typedef */ (*PhysicalDeviceMemoryProperties)(&x.memoryProperties) 
	return *ptr
}

// ImageMemoryRequirementsInfo2 provides a go interface for VkImageMemoryRequirementsInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageMemoryRequirementsInfo2.html
type ImageMemoryRequirementsInfo2 C.struct_VkImageMemoryRequirementsInfo2

// SizeofImageMemoryRequirementsInfo2 is the memory size of a ImageMemoryRequirementsInfo2
var SizeofImageMemoryRequirementsInfo2 int = int(unsafe.Sizeof(ImageMemoryRequirementsInfo2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageMemoryRequirementsInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageMemoryRequirementsInfo2) AsCPtr() *ImageMemoryRequirementsInfo2 {
	clone := (*ImageMemoryRequirementsInfo2)(newCBlock(C.ulong(SizeofImageMemoryRequirementsInfo2)))
	*clone = x
	return clone
}

// ImageMemoryRequirementsInfo2FreeCSlice releases the memory allocated by ImageMemoryRequirementsInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func ImageMemoryRequirementsInfo2FreeCSlice(x []ImageMemoryRequirementsInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageMemoryRequirementsInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageMemoryRequirementsInfo2FreeCSlice must be called on the returned slice.
func ImageMemoryRequirementsInfo2MakeCSlice(x ...ImageMemoryRequirementsInfo2) []ImageMemoryRequirementsInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageMemoryRequirementsInfo2 * len(x)
	dst := unsafe.Slice((*ImageMemoryRequirementsInfo2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageMemoryRequirementsInfo2
func (x ImageMemoryRequirementsInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ImageMemoryRequirementsInfo2) WithDefaultSType() ImageMemoryRequirementsInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryRequirementsInfo2) WithSType(y StructureType) ImageMemoryRequirementsInfo2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkImageMemoryRequirementsInfo2
func (x ImageMemoryRequirementsInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryRequirementsInfo2) WithPNext(y unsafe.Pointer) ImageMemoryRequirementsInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Image returns the value of image from VkImageMemoryRequirementsInfo2
func (x ImageMemoryRequirementsInfo2) Image() Image {
	ptr := /* handle */ (*Image)(&x.image) 
	return *ptr
}

// WithImage sets the value for the Image on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryRequirementsInfo2) WithImage(y Image) ImageMemoryRequirementsInfo2 {
	x.image = *(/* handle */ (*C.VkImage)(&y))
	return x
}

// ImageSparseMemoryRequirementsInfo2 provides a go interface for VkImageSparseMemoryRequirementsInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSparseMemoryRequirementsInfo2.html
type ImageSparseMemoryRequirementsInfo2 C.struct_VkImageSparseMemoryRequirementsInfo2

// SizeofImageSparseMemoryRequirementsInfo2 is the memory size of a ImageSparseMemoryRequirementsInfo2
var SizeofImageSparseMemoryRequirementsInfo2 int = int(unsafe.Sizeof(ImageSparseMemoryRequirementsInfo2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageSparseMemoryRequirementsInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageSparseMemoryRequirementsInfo2) AsCPtr() *ImageSparseMemoryRequirementsInfo2 {
	clone := (*ImageSparseMemoryRequirementsInfo2)(newCBlock(C.ulong(SizeofImageSparseMemoryRequirementsInfo2)))
	*clone = x
	return clone
}

// ImageSparseMemoryRequirementsInfo2FreeCSlice releases the memory allocated by ImageSparseMemoryRequirementsInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func ImageSparseMemoryRequirementsInfo2FreeCSlice(x []ImageSparseMemoryRequirementsInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageSparseMemoryRequirementsInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageSparseMemoryRequirementsInfo2FreeCSlice must be called on the returned slice.
func ImageSparseMemoryRequirementsInfo2MakeCSlice(x ...ImageSparseMemoryRequirementsInfo2) []ImageSparseMemoryRequirementsInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageSparseMemoryRequirementsInfo2 * len(x)
	dst := unsafe.Slice((*ImageSparseMemoryRequirementsInfo2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageSparseMemoryRequirementsInfo2
func (x ImageSparseMemoryRequirementsInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ImageSparseMemoryRequirementsInfo2) WithDefaultSType() ImageSparseMemoryRequirementsInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSparseMemoryRequirementsInfo2) WithSType(y StructureType) ImageSparseMemoryRequirementsInfo2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkImageSparseMemoryRequirementsInfo2
func (x ImageSparseMemoryRequirementsInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSparseMemoryRequirementsInfo2) WithPNext(y unsafe.Pointer) ImageSparseMemoryRequirementsInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Image returns the value of image from VkImageSparseMemoryRequirementsInfo2
func (x ImageSparseMemoryRequirementsInfo2) Image() Image {
	ptr := /* handle */ (*Image)(&x.image) 
	return *ptr
}

// WithImage sets the value for the Image on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSparseMemoryRequirementsInfo2) WithImage(y Image) ImageSparseMemoryRequirementsInfo2 {
	x.image = *(/* handle */ (*C.VkImage)(&y))
	return x
}

// MemoryRequirements2 provides a go interface for VkMemoryRequirements2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryRequirements2.html
type MemoryRequirements2 C.struct_VkMemoryRequirements2

// SizeofMemoryRequirements2 is the memory size of a MemoryRequirements2
var SizeofMemoryRequirements2 int = int(unsafe.Sizeof(MemoryRequirements2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryRequirements2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryRequirements2) AsCPtr() *MemoryRequirements2 {
	clone := (*MemoryRequirements2)(newCBlock(C.ulong(SizeofMemoryRequirements2)))
	*clone = x
	return clone
}

// MemoryRequirements2FreeCSlice releases the memory allocated by MemoryRequirements2MakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryRequirements2FreeCSlice(x []MemoryRequirements2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryRequirements2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryRequirements2FreeCSlice must be called on the returned slice.
func MemoryRequirements2MakeCSlice(x ...MemoryRequirements2) []MemoryRequirements2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryRequirements2 * len(x)
	dst := unsafe.Slice((*MemoryRequirements2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkMemoryRequirements2
func (x MemoryRequirements2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x MemoryRequirements2) WithDefaultSType() MemoryRequirements2 {
	return x.WithSType(VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryRequirements2) WithSType(y StructureType) MemoryRequirements2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkMemoryRequirements2
func (x MemoryRequirements2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryRequirements2) WithPNext(y unsafe.Pointer) MemoryRequirements2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// MemoryRequirements returns the value of memoryRequirements from VkMemoryRequirements2
func (x MemoryRequirements2) MemoryRequirements() MemoryRequirements {
	ptr := /* typedef */ (*MemoryRequirements)(&x.memoryRequirements) 
	return *ptr
}

// SparseImageMemoryRequirements2 provides a go interface for VkSparseImageMemoryRequirements2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageMemoryRequirements2.html
type SparseImageMemoryRequirements2 C.struct_VkSparseImageMemoryRequirements2

// SizeofSparseImageMemoryRequirements2 is the memory size of a SparseImageMemoryRequirements2
var SizeofSparseImageMemoryRequirements2 int = int(unsafe.Sizeof(SparseImageMemoryRequirements2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SparseImageMemoryRequirements2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SparseImageMemoryRequirements2) AsCPtr() *SparseImageMemoryRequirements2 {
	clone := (*SparseImageMemoryRequirements2)(newCBlock(C.ulong(SizeofSparseImageMemoryRequirements2)))
	*clone = x
	return clone
}

// SparseImageMemoryRequirements2FreeCSlice releases the memory allocated by SparseImageMemoryRequirements2MakeCSlice.
// It does not free pointers stored inside the slice.
func SparseImageMemoryRequirements2FreeCSlice(x []SparseImageMemoryRequirements2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SparseImageMemoryRequirements2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SparseImageMemoryRequirements2FreeCSlice must be called on the returned slice.
func SparseImageMemoryRequirements2MakeCSlice(x ...SparseImageMemoryRequirements2) []SparseImageMemoryRequirements2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageMemoryRequirements2 * len(x)
	dst := unsafe.Slice((*SparseImageMemoryRequirements2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSparseImageMemoryRequirements2
func (x SparseImageMemoryRequirements2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SparseImageMemoryRequirements2) WithDefaultSType() SparseImageMemoryRequirements2 {
	return x.WithSType(VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryRequirements2) WithSType(y StructureType) SparseImageMemoryRequirements2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkSparseImageMemoryRequirements2
func (x SparseImageMemoryRequirements2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageMemoryRequirements2) WithPNext(y unsafe.Pointer) SparseImageMemoryRequirements2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// MemoryRequirements returns the value of memoryRequirements from VkSparseImageMemoryRequirements2
func (x SparseImageMemoryRequirements2) MemoryRequirements() SparseImageMemoryRequirements {
	ptr := /* typedef */ (*SparseImageMemoryRequirements)(&x.memoryRequirements) 
	return *ptr
}

// BufferMemoryRequirementsInfo2 provides a go interface for VkBufferMemoryRequirementsInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferMemoryRequirementsInfo2.html
type BufferMemoryRequirementsInfo2 C.struct_VkBufferMemoryRequirementsInfo2

// SizeofBufferMemoryRequirementsInfo2 is the memory size of a BufferMemoryRequirementsInfo2
var SizeofBufferMemoryRequirementsInfo2 int = int(unsafe.Sizeof(BufferMemoryRequirementsInfo2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferMemoryRequirementsInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferMemoryRequirementsInfo2) AsCPtr() *BufferMemoryRequirementsInfo2 {
	clone := (*BufferMemoryRequirementsInfo2)(newCBlock(C.ulong(SizeofBufferMemoryRequirementsInfo2)))
	*clone = x
	return clone
}

// BufferMemoryRequirementsInfo2FreeCSlice releases the memory allocated by BufferMemoryRequirementsInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func BufferMemoryRequirementsInfo2FreeCSlice(x []BufferMemoryRequirementsInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferMemoryRequirementsInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferMemoryRequirementsInfo2FreeCSlice must be called on the returned slice.
func BufferMemoryRequirementsInfo2MakeCSlice(x ...BufferMemoryRequirementsInfo2) []BufferMemoryRequirementsInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferMemoryRequirementsInfo2 * len(x)
	dst := unsafe.Slice((*BufferMemoryRequirementsInfo2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBufferMemoryRequirementsInfo2
func (x BufferMemoryRequirementsInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BufferMemoryRequirementsInfo2) WithDefaultSType() BufferMemoryRequirementsInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryRequirementsInfo2) WithSType(y StructureType) BufferMemoryRequirementsInfo2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkBufferMemoryRequirementsInfo2
func (x BufferMemoryRequirementsInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryRequirementsInfo2) WithPNext(y unsafe.Pointer) BufferMemoryRequirementsInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Buffer returns the value of buffer from VkBufferMemoryRequirementsInfo2
func (x BufferMemoryRequirementsInfo2) Buffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.buffer) 
	return *ptr
}

// WithBuffer sets the value for the Buffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryRequirementsInfo2) WithBuffer(y Buffer) BufferMemoryRequirementsInfo2 {
	x.buffer = *(/* handle */ (*C.VkBuffer)(&y))
	return x
}

// ExportFenceCreateInfo provides a go interface for VkExportFenceCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportFenceCreateInfo.html
type ExportFenceCreateInfo C.struct_VkExportFenceCreateInfo

// SizeofExportFenceCreateInfo is the memory size of a ExportFenceCreateInfo
var SizeofExportFenceCreateInfo int = int(unsafe.Sizeof(ExportFenceCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExportFenceCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExportFenceCreateInfo) AsCPtr() *ExportFenceCreateInfo {
	clone := (*ExportFenceCreateInfo)(newCBlock(C.ulong(SizeofExportFenceCreateInfo)))
	*clone = x
	return clone
}

// ExportFenceCreateInfoFreeCSlice releases the memory allocated by ExportFenceCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ExportFenceCreateInfoFreeCSlice(x []ExportFenceCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExportFenceCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExportFenceCreateInfoFreeCSlice must be called on the returned slice.
func ExportFenceCreateInfoMakeCSlice(x ...ExportFenceCreateInfo) []ExportFenceCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExportFenceCreateInfo * len(x)
	dst := unsafe.Slice((*ExportFenceCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkExportFenceCreateInfo
func (x ExportFenceCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ExportFenceCreateInfo) WithDefaultSType() ExportFenceCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExportFenceCreateInfo) WithSType(y StructureType) ExportFenceCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkExportFenceCreateInfo
func (x ExportFenceCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExportFenceCreateInfo) WithPNext(y unsafe.Pointer) ExportFenceCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// HandleTypes returns the value of handleTypes from VkExportFenceCreateInfo
func (x ExportFenceCreateInfo) HandleTypes() ExternalFenceHandleTypeFlags {
	ptr := /* typedef */ (*ExternalFenceHandleTypeFlags)(&x.handleTypes) 
	return *ptr
}

// WithHandleTypes sets the value for the HandleTypes on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExportFenceCreateInfo) WithHandleTypes(y ExternalFenceHandleTypeFlags) ExportFenceCreateInfo {
	x.handleTypes = *(/* typedef */ (*C.VkExternalFenceHandleTypeFlags)(&y))
	return x
}

// ExportSemaphoreCreateInfo provides a go interface for VkExportSemaphoreCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportSemaphoreCreateInfo.html
type ExportSemaphoreCreateInfo C.struct_VkExportSemaphoreCreateInfo

// SizeofExportSemaphoreCreateInfo is the memory size of a ExportSemaphoreCreateInfo
var SizeofExportSemaphoreCreateInfo int = int(unsafe.Sizeof(ExportSemaphoreCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExportSemaphoreCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExportSemaphoreCreateInfo) AsCPtr() *ExportSemaphoreCreateInfo {
	clone := (*ExportSemaphoreCreateInfo)(newCBlock(C.ulong(SizeofExportSemaphoreCreateInfo)))
	*clone = x
	return clone
}

// ExportSemaphoreCreateInfoFreeCSlice releases the memory allocated by ExportSemaphoreCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ExportSemaphoreCreateInfoFreeCSlice(x []ExportSemaphoreCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExportSemaphoreCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExportSemaphoreCreateInfoFreeCSlice must be called on the returned slice.
func ExportSemaphoreCreateInfoMakeCSlice(x ...ExportSemaphoreCreateInfo) []ExportSemaphoreCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExportSemaphoreCreateInfo * len(x)
	dst := unsafe.Slice((*ExportSemaphoreCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkExportSemaphoreCreateInfo
func (x ExportSemaphoreCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ExportSemaphoreCreateInfo) WithDefaultSType() ExportSemaphoreCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExportSemaphoreCreateInfo) WithSType(y StructureType) ExportSemaphoreCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkExportSemaphoreCreateInfo
func (x ExportSemaphoreCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExportSemaphoreCreateInfo) WithPNext(y unsafe.Pointer) ExportSemaphoreCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// HandleTypes returns the value of handleTypes from VkExportSemaphoreCreateInfo
func (x ExportSemaphoreCreateInfo) HandleTypes() ExternalSemaphoreHandleTypeFlags {
	ptr := /* typedef */ (*ExternalSemaphoreHandleTypeFlags)(&x.handleTypes) 
	return *ptr
}

// WithHandleTypes sets the value for the HandleTypes on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExportSemaphoreCreateInfo) WithHandleTypes(y ExternalSemaphoreHandleTypeFlags) ExportSemaphoreCreateInfo {
	x.handleTypes = *(/* typedef */ (*C.VkExternalSemaphoreHandleTypeFlags)(&y))
	return x
}

// DeviceGroupDeviceCreateInfo provides a go interface for VkDeviceGroupDeviceCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupDeviceCreateInfo.html
type DeviceGroupDeviceCreateInfo C.struct_VkDeviceGroupDeviceCreateInfo

// SizeofDeviceGroupDeviceCreateInfo is the memory size of a DeviceGroupDeviceCreateInfo
var SizeofDeviceGroupDeviceCreateInfo int = int(unsafe.Sizeof(DeviceGroupDeviceCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceGroupDeviceCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceGroupDeviceCreateInfo) AsCPtr() *DeviceGroupDeviceCreateInfo {
	clone := (*DeviceGroupDeviceCreateInfo)(newCBlock(C.ulong(SizeofDeviceGroupDeviceCreateInfo)))
	*clone = x
	return clone
}

// DeviceGroupDeviceCreateInfoFreeCSlice releases the memory allocated by DeviceGroupDeviceCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceGroupDeviceCreateInfoFreeCSlice(x []DeviceGroupDeviceCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceGroupDeviceCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceGroupDeviceCreateInfoFreeCSlice must be called on the returned slice.
func DeviceGroupDeviceCreateInfoMakeCSlice(x ...DeviceGroupDeviceCreateInfo) []DeviceGroupDeviceCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupDeviceCreateInfo * len(x)
	dst := unsafe.Slice((*DeviceGroupDeviceCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceGroupDeviceCreateInfo
func (x DeviceGroupDeviceCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DeviceGroupDeviceCreateInfo) WithDefaultSType() DeviceGroupDeviceCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupDeviceCreateInfo) WithSType(y StructureType) DeviceGroupDeviceCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDeviceGroupDeviceCreateInfo
func (x DeviceGroupDeviceCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupDeviceCreateInfo) WithPNext(y unsafe.Pointer) DeviceGroupDeviceCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// PhysicalDeviceCount returns the value of physicalDeviceCount from VkDeviceGroupDeviceCreateInfo
func (x DeviceGroupDeviceCreateInfo) PhysicalDeviceCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.physicalDeviceCount) 
	return *ptr
}

// WithPhysicalDeviceCount sets the value for the PhysicalDeviceCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupDeviceCreateInfo) WithPhysicalDeviceCount(y uint32) DeviceGroupDeviceCreateInfo {
	x.physicalDeviceCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PPhysicalDevices returns the value of pPhysicalDevices from VkDeviceGroupDeviceCreateInfo
func (x DeviceGroupDeviceCreateInfo) PPhysicalDevices() []PhysicalDevice {
	ptr := func(x **C.VkPhysicalDevice) *[]PhysicalDevice { /* Slice */ slc := unsafe.Slice((*PhysicalDevice)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pPhysicalDevices) 
	return *ptr
}

// WithPPhysicalDevices sets the value for the PPhysicalDevices on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines PhysicalDeviceCount as the length of this field.
// PhysicalDeviceCount is updated with the length of the new value.
func (x DeviceGroupDeviceCreateInfo) WithPPhysicalDevices(y []PhysicalDevice) DeviceGroupDeviceCreateInfo {
	x.pPhysicalDevices = *(func(x *[]PhysicalDevice) **C.VkPhysicalDevice { /* Slice */ if len(*x) > 0 { slc := (*C.VkPhysicalDevice)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkPhysicalDevice)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithPhysicalDeviceCount(uint32(len(y)))
}

// ExternalFenceProperties provides a go interface for VkExternalFenceProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalFenceProperties.html
type ExternalFenceProperties C.struct_VkExternalFenceProperties

// SizeofExternalFenceProperties is the memory size of a ExternalFenceProperties
var SizeofExternalFenceProperties int = int(unsafe.Sizeof(ExternalFenceProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExternalFenceProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExternalFenceProperties) AsCPtr() *ExternalFenceProperties {
	clone := (*ExternalFenceProperties)(newCBlock(C.ulong(SizeofExternalFenceProperties)))
	*clone = x
	return clone
}

// ExternalFencePropertiesFreeCSlice releases the memory allocated by ExternalFencePropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func ExternalFencePropertiesFreeCSlice(x []ExternalFenceProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExternalFencePropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExternalFencePropertiesFreeCSlice must be called on the returned slice.
func ExternalFencePropertiesMakeCSlice(x ...ExternalFenceProperties) []ExternalFenceProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalFenceProperties * len(x)
	dst := unsafe.Slice((*ExternalFenceProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkExternalFenceProperties
func (x ExternalFenceProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ExternalFenceProperties) WithDefaultSType() ExternalFenceProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalFenceProperties) WithSType(y StructureType) ExternalFenceProperties {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkExternalFenceProperties
func (x ExternalFenceProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalFenceProperties) WithPNext(y unsafe.Pointer) ExternalFenceProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// ExportFromImportedHandleTypes returns the value of exportFromImportedHandleTypes from VkExternalFenceProperties
func (x ExternalFenceProperties) ExportFromImportedHandleTypes() ExternalFenceHandleTypeFlags {
	ptr := /* typedef */ (*ExternalFenceHandleTypeFlags)(&x.exportFromImportedHandleTypes) 
	return *ptr
}

// CompatibleHandleTypes returns the value of compatibleHandleTypes from VkExternalFenceProperties
func (x ExternalFenceProperties) CompatibleHandleTypes() ExternalFenceHandleTypeFlags {
	ptr := /* typedef */ (*ExternalFenceHandleTypeFlags)(&x.compatibleHandleTypes) 
	return *ptr
}

// ExternalFenceFeatures returns the value of externalFenceFeatures from VkExternalFenceProperties
func (x ExternalFenceProperties) ExternalFenceFeatures() ExternalFenceFeatureFlags {
	ptr := /* typedef */ (*ExternalFenceFeatureFlags)(&x.externalFenceFeatures) 
	return *ptr
}

// PhysicalDeviceExternalFenceInfo provides a go interface for VkPhysicalDeviceExternalFenceInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalFenceInfo.html
type PhysicalDeviceExternalFenceInfo C.struct_VkPhysicalDeviceExternalFenceInfo

// SizeofPhysicalDeviceExternalFenceInfo is the memory size of a PhysicalDeviceExternalFenceInfo
var SizeofPhysicalDeviceExternalFenceInfo int = int(unsafe.Sizeof(PhysicalDeviceExternalFenceInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceExternalFenceInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceExternalFenceInfo) AsCPtr() *PhysicalDeviceExternalFenceInfo {
	clone := (*PhysicalDeviceExternalFenceInfo)(newCBlock(C.ulong(SizeofPhysicalDeviceExternalFenceInfo)))
	*clone = x
	return clone
}

// PhysicalDeviceExternalFenceInfoFreeCSlice releases the memory allocated by PhysicalDeviceExternalFenceInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceExternalFenceInfoFreeCSlice(x []PhysicalDeviceExternalFenceInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceExternalFenceInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceExternalFenceInfoFreeCSlice must be called on the returned slice.
func PhysicalDeviceExternalFenceInfoMakeCSlice(x ...PhysicalDeviceExternalFenceInfo) []PhysicalDeviceExternalFenceInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceExternalFenceInfo * len(x)
	dst := unsafe.Slice((*PhysicalDeviceExternalFenceInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceExternalFenceInfo
func (x PhysicalDeviceExternalFenceInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceExternalFenceInfo) WithDefaultSType() PhysicalDeviceExternalFenceInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalFenceInfo) WithSType(y StructureType) PhysicalDeviceExternalFenceInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceExternalFenceInfo
func (x PhysicalDeviceExternalFenceInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalFenceInfo) WithPNext(y unsafe.Pointer) PhysicalDeviceExternalFenceInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// HandleType returns the value of handleType from VkPhysicalDeviceExternalFenceInfo
func (x PhysicalDeviceExternalFenceInfo) HandleType() ExternalFenceHandleTypeFlagBits {
	ptr := /* typedef */ (*ExternalFenceHandleTypeFlagBits)(&x.handleType) 
	return *ptr
}

// WithHandleType sets the value for the HandleType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalFenceInfo) WithHandleType(y ExternalFenceHandleTypeFlagBits) PhysicalDeviceExternalFenceInfo {
	x.handleType = *(/* typedef */ (*C.VkExternalFenceHandleTypeFlagBits)(&y))
	return x
}

// PhysicalDeviceGroupProperties provides a go interface for VkPhysicalDeviceGroupProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceGroupProperties.html
type PhysicalDeviceGroupProperties C.struct_VkPhysicalDeviceGroupProperties

// SizeofPhysicalDeviceGroupProperties is the memory size of a PhysicalDeviceGroupProperties
var SizeofPhysicalDeviceGroupProperties int = int(unsafe.Sizeof(PhysicalDeviceGroupProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceGroupProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceGroupProperties) AsCPtr() *PhysicalDeviceGroupProperties {
	clone := (*PhysicalDeviceGroupProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceGroupProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceGroupPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceGroupPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceGroupPropertiesFreeCSlice(x []PhysicalDeviceGroupProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceGroupPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceGroupPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceGroupPropertiesMakeCSlice(x ...PhysicalDeviceGroupProperties) []PhysicalDeviceGroupProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceGroupProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceGroupProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceGroupProperties
func (x PhysicalDeviceGroupProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceGroupProperties) WithDefaultSType() PhysicalDeviceGroupProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceGroupProperties) WithSType(y StructureType) PhysicalDeviceGroupProperties {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceGroupProperties
func (x PhysicalDeviceGroupProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceGroupProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceGroupProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// PhysicalDeviceCount returns the value of physicalDeviceCount from VkPhysicalDeviceGroupProperties
func (x PhysicalDeviceGroupProperties) PhysicalDeviceCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.physicalDeviceCount) 
	return *ptr
}

// PhysicalDevices returns the value of physicalDevices from VkPhysicalDeviceGroupProperties
func (x PhysicalDeviceGroupProperties) PhysicalDevices() []PhysicalDevice {
	ptr := func(x *[VK_MAX_DEVICE_GROUP_SIZE]C.VkPhysicalDevice) *[]PhysicalDevice { /* Array */ slc := unsafe.Slice((*PhysicalDevice)(unsafe.Pointer(x)), VK_MAX_DEVICE_GROUP_SIZE); return &slc }(&x.physicalDevices) 
	return *ptr
}

// SubsetAllocation returns the value of subsetAllocation from VkPhysicalDeviceGroupProperties
func (x PhysicalDeviceGroupProperties) SubsetAllocation() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.subsetAllocation) 
	return *ptr
}

// PhysicalDeviceFeatures2 provides a go interface for VkPhysicalDeviceFeatures2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures2.html
type PhysicalDeviceFeatures2 C.struct_VkPhysicalDeviceFeatures2

// SizeofPhysicalDeviceFeatures2 is the memory size of a PhysicalDeviceFeatures2
var SizeofPhysicalDeviceFeatures2 int = int(unsafe.Sizeof(PhysicalDeviceFeatures2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceFeatures2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceFeatures2) AsCPtr() *PhysicalDeviceFeatures2 {
	clone := (*PhysicalDeviceFeatures2)(newCBlock(C.ulong(SizeofPhysicalDeviceFeatures2)))
	*clone = x
	return clone
}

// PhysicalDeviceFeatures2FreeCSlice releases the memory allocated by PhysicalDeviceFeatures2MakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceFeatures2FreeCSlice(x []PhysicalDeviceFeatures2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceFeatures2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceFeatures2FreeCSlice must be called on the returned slice.
func PhysicalDeviceFeatures2MakeCSlice(x ...PhysicalDeviceFeatures2) []PhysicalDeviceFeatures2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceFeatures2 * len(x)
	dst := unsafe.Slice((*PhysicalDeviceFeatures2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceFeatures2
func (x PhysicalDeviceFeatures2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceFeatures2) WithDefaultSType() PhysicalDeviceFeatures2 {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures2) WithSType(y StructureType) PhysicalDeviceFeatures2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceFeatures2
func (x PhysicalDeviceFeatures2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures2) WithPNext(y unsafe.Pointer) PhysicalDeviceFeatures2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Features returns the value of features from VkPhysicalDeviceFeatures2
func (x PhysicalDeviceFeatures2) Features() PhysicalDeviceFeatures {
	ptr := /* typedef */ (*PhysicalDeviceFeatures)(&x.features) 
	return *ptr
}

// WithFeatures sets the value for the Features on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFeatures2) WithFeatures(y PhysicalDeviceFeatures) PhysicalDeviceFeatures2 {
	x.features = *(/* typedef */ (*C.struct_VkPhysicalDeviceFeatures)(&y))
	return x
}

// PhysicalDeviceProperties2 provides a go interface for VkPhysicalDeviceProperties2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProperties2.html
type PhysicalDeviceProperties2 C.struct_VkPhysicalDeviceProperties2

// SizeofPhysicalDeviceProperties2 is the memory size of a PhysicalDeviceProperties2
var SizeofPhysicalDeviceProperties2 int = int(unsafe.Sizeof(PhysicalDeviceProperties2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceProperties2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceProperties2) AsCPtr() *PhysicalDeviceProperties2 {
	clone := (*PhysicalDeviceProperties2)(newCBlock(C.ulong(SizeofPhysicalDeviceProperties2)))
	*clone = x
	return clone
}

// PhysicalDeviceProperties2FreeCSlice releases the memory allocated by PhysicalDeviceProperties2MakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceProperties2FreeCSlice(x []PhysicalDeviceProperties2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceProperties2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceProperties2FreeCSlice must be called on the returned slice.
func PhysicalDeviceProperties2MakeCSlice(x ...PhysicalDeviceProperties2) []PhysicalDeviceProperties2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceProperties2 * len(x)
	dst := unsafe.Slice((*PhysicalDeviceProperties2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceProperties2
func (x PhysicalDeviceProperties2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceProperties2) WithDefaultSType() PhysicalDeviceProperties2 {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceProperties2) WithSType(y StructureType) PhysicalDeviceProperties2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceProperties2
func (x PhysicalDeviceProperties2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceProperties2) WithPNext(y unsafe.Pointer) PhysicalDeviceProperties2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Properties returns the value of properties from VkPhysicalDeviceProperties2
func (x PhysicalDeviceProperties2) Properties() PhysicalDeviceProperties {
	ptr := /* typedef */ (*PhysicalDeviceProperties)(&x.properties) 
	return *ptr
}

// FormatProperties2 provides a go interface for VkFormatProperties2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatProperties2.html
type FormatProperties2 C.struct_VkFormatProperties2

// SizeofFormatProperties2 is the memory size of a FormatProperties2
var SizeofFormatProperties2 int = int(unsafe.Sizeof(FormatProperties2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *FormatProperties2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x FormatProperties2) AsCPtr() *FormatProperties2 {
	clone := (*FormatProperties2)(newCBlock(C.ulong(SizeofFormatProperties2)))
	*clone = x
	return clone
}

// FormatProperties2FreeCSlice releases the memory allocated by FormatProperties2MakeCSlice.
// It does not free pointers stored inside the slice.
func FormatProperties2FreeCSlice(x []FormatProperties2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// FormatProperties2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. FormatProperties2FreeCSlice must be called on the returned slice.
func FormatProperties2MakeCSlice(x ...FormatProperties2) []FormatProperties2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFormatProperties2 * len(x)
	dst := unsafe.Slice((*FormatProperties2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkFormatProperties2
func (x FormatProperties2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x FormatProperties2) WithDefaultSType() FormatProperties2 {
	return x.WithSType(VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FormatProperties2) WithSType(y StructureType) FormatProperties2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkFormatProperties2
func (x FormatProperties2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FormatProperties2) WithPNext(y unsafe.Pointer) FormatProperties2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// FormatProperties returns the value of formatProperties from VkFormatProperties2
func (x FormatProperties2) FormatProperties() FormatProperties {
	ptr := /* typedef */ (*FormatProperties)(&x.formatProperties) 
	return *ptr
}

// ImageFormatProperties2 provides a go interface for VkImageFormatProperties2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageFormatProperties2.html
type ImageFormatProperties2 C.struct_VkImageFormatProperties2

// SizeofImageFormatProperties2 is the memory size of a ImageFormatProperties2
var SizeofImageFormatProperties2 int = int(unsafe.Sizeof(ImageFormatProperties2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageFormatProperties2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageFormatProperties2) AsCPtr() *ImageFormatProperties2 {
	clone := (*ImageFormatProperties2)(newCBlock(C.ulong(SizeofImageFormatProperties2)))
	*clone = x
	return clone
}

// ImageFormatProperties2FreeCSlice releases the memory allocated by ImageFormatProperties2MakeCSlice.
// It does not free pointers stored inside the slice.
func ImageFormatProperties2FreeCSlice(x []ImageFormatProperties2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageFormatProperties2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageFormatProperties2FreeCSlice must be called on the returned slice.
func ImageFormatProperties2MakeCSlice(x ...ImageFormatProperties2) []ImageFormatProperties2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageFormatProperties2 * len(x)
	dst := unsafe.Slice((*ImageFormatProperties2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageFormatProperties2
func (x ImageFormatProperties2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ImageFormatProperties2) WithDefaultSType() ImageFormatProperties2 {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageFormatProperties2) WithSType(y StructureType) ImageFormatProperties2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkImageFormatProperties2
func (x ImageFormatProperties2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageFormatProperties2) WithPNext(y unsafe.Pointer) ImageFormatProperties2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// ImageFormatProperties returns the value of imageFormatProperties from VkImageFormatProperties2
func (x ImageFormatProperties2) ImageFormatProperties() ImageFormatProperties {
	ptr := /* typedef */ (*ImageFormatProperties)(&x.imageFormatProperties) 
	return *ptr
}

// PhysicalDeviceImageFormatInfo2 provides a go interface for VkPhysicalDeviceImageFormatInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageFormatInfo2.html
type PhysicalDeviceImageFormatInfo2 C.struct_VkPhysicalDeviceImageFormatInfo2

// SizeofPhysicalDeviceImageFormatInfo2 is the memory size of a PhysicalDeviceImageFormatInfo2
var SizeofPhysicalDeviceImageFormatInfo2 int = int(unsafe.Sizeof(PhysicalDeviceImageFormatInfo2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceImageFormatInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceImageFormatInfo2) AsCPtr() *PhysicalDeviceImageFormatInfo2 {
	clone := (*PhysicalDeviceImageFormatInfo2)(newCBlock(C.ulong(SizeofPhysicalDeviceImageFormatInfo2)))
	*clone = x
	return clone
}

// PhysicalDeviceImageFormatInfo2FreeCSlice releases the memory allocated by PhysicalDeviceImageFormatInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceImageFormatInfo2FreeCSlice(x []PhysicalDeviceImageFormatInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceImageFormatInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceImageFormatInfo2FreeCSlice must be called on the returned slice.
func PhysicalDeviceImageFormatInfo2MakeCSlice(x ...PhysicalDeviceImageFormatInfo2) []PhysicalDeviceImageFormatInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceImageFormatInfo2 * len(x)
	dst := unsafe.Slice((*PhysicalDeviceImageFormatInfo2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceImageFormatInfo2
func (x PhysicalDeviceImageFormatInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceImageFormatInfo2) WithDefaultSType() PhysicalDeviceImageFormatInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImageFormatInfo2) WithSType(y StructureType) PhysicalDeviceImageFormatInfo2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceImageFormatInfo2
func (x PhysicalDeviceImageFormatInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImageFormatInfo2) WithPNext(y unsafe.Pointer) PhysicalDeviceImageFormatInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Format returns the value of format from VkPhysicalDeviceImageFormatInfo2
func (x PhysicalDeviceImageFormatInfo2) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format) 
	return *ptr
}

// WithFormat sets the value for the Format on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImageFormatInfo2) WithFormat(y Format) PhysicalDeviceImageFormatInfo2 {
	x.format = *(/* typedef */ (*C.VkFormat)(&y))
	return x
}

// Type_ returns the value of type from VkPhysicalDeviceImageFormatInfo2
func (x PhysicalDeviceImageFormatInfo2) Type_() ImageType {
	ptr := /* typedef */ (*ImageType)(&x._type) 
	return *ptr
}

// WithType_ sets the value for the Type_ on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImageFormatInfo2) WithType_(y ImageType) PhysicalDeviceImageFormatInfo2 {
	x._type = *(/* typedef */ (*C.VkImageType)(&y))
	return x
}

// Tiling returns the value of tiling from VkPhysicalDeviceImageFormatInfo2
func (x PhysicalDeviceImageFormatInfo2) Tiling() ImageTiling {
	ptr := /* typedef */ (*ImageTiling)(&x.tiling) 
	return *ptr
}

// WithTiling sets the value for the Tiling on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImageFormatInfo2) WithTiling(y ImageTiling) PhysicalDeviceImageFormatInfo2 {
	x.tiling = *(/* typedef */ (*C.VkImageTiling)(&y))
	return x
}

// Usage returns the value of usage from VkPhysicalDeviceImageFormatInfo2
func (x PhysicalDeviceImageFormatInfo2) Usage() ImageUsageFlags {
	ptr := /* typedef */ (*ImageUsageFlags)(&x.usage) 
	return *ptr
}

// WithUsage sets the value for the Usage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImageFormatInfo2) WithUsage(y ImageUsageFlags) PhysicalDeviceImageFormatInfo2 {
	x.usage = *(/* typedef */ (*C.VkImageUsageFlags)(&y))
	return x
}

// Flags returns the value of flags from VkPhysicalDeviceImageFormatInfo2
func (x PhysicalDeviceImageFormatInfo2) Flags() ImageCreateFlags {
	ptr := /* typedef */ (*ImageCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImageFormatInfo2) WithFlags(y ImageCreateFlags) PhysicalDeviceImageFormatInfo2 {
	x.flags = *(/* typedef */ (*C.VkImageCreateFlags)(&y))
	return x
}

// QueueFamilyProperties2 provides a go interface for VkQueueFamilyProperties2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkQueueFamilyProperties2.html
type QueueFamilyProperties2 C.struct_VkQueueFamilyProperties2

// SizeofQueueFamilyProperties2 is the memory size of a QueueFamilyProperties2
var SizeofQueueFamilyProperties2 int = int(unsafe.Sizeof(QueueFamilyProperties2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *QueueFamilyProperties2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x QueueFamilyProperties2) AsCPtr() *QueueFamilyProperties2 {
	clone := (*QueueFamilyProperties2)(newCBlock(C.ulong(SizeofQueueFamilyProperties2)))
	*clone = x
	return clone
}

// QueueFamilyProperties2FreeCSlice releases the memory allocated by QueueFamilyProperties2MakeCSlice.
// It does not free pointers stored inside the slice.
func QueueFamilyProperties2FreeCSlice(x []QueueFamilyProperties2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// QueueFamilyProperties2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. QueueFamilyProperties2FreeCSlice must be called on the returned slice.
func QueueFamilyProperties2MakeCSlice(x ...QueueFamilyProperties2) []QueueFamilyProperties2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofQueueFamilyProperties2 * len(x)
	dst := unsafe.Slice((*QueueFamilyProperties2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkQueueFamilyProperties2
func (x QueueFamilyProperties2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x QueueFamilyProperties2) WithDefaultSType() QueueFamilyProperties2 {
	return x.WithSType(VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x QueueFamilyProperties2) WithSType(y StructureType) QueueFamilyProperties2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkQueueFamilyProperties2
func (x QueueFamilyProperties2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x QueueFamilyProperties2) WithPNext(y unsafe.Pointer) QueueFamilyProperties2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// QueueFamilyProperties returns the value of queueFamilyProperties from VkQueueFamilyProperties2
func (x QueueFamilyProperties2) QueueFamilyProperties() QueueFamilyProperties {
	ptr := /* typedef */ (*QueueFamilyProperties)(&x.queueFamilyProperties) 
	return *ptr
}

// BindImageMemoryDeviceGroupInfo provides a go interface for VkBindImageMemoryDeviceGroupInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindImageMemoryDeviceGroupInfo.html
type BindImageMemoryDeviceGroupInfo C.struct_VkBindImageMemoryDeviceGroupInfo

// SizeofBindImageMemoryDeviceGroupInfo is the memory size of a BindImageMemoryDeviceGroupInfo
var SizeofBindImageMemoryDeviceGroupInfo int = int(unsafe.Sizeof(BindImageMemoryDeviceGroupInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BindImageMemoryDeviceGroupInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BindImageMemoryDeviceGroupInfo) AsCPtr() *BindImageMemoryDeviceGroupInfo {
	clone := (*BindImageMemoryDeviceGroupInfo)(newCBlock(C.ulong(SizeofBindImageMemoryDeviceGroupInfo)))
	*clone = x
	return clone
}

// BindImageMemoryDeviceGroupInfoFreeCSlice releases the memory allocated by BindImageMemoryDeviceGroupInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BindImageMemoryDeviceGroupInfoFreeCSlice(x []BindImageMemoryDeviceGroupInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BindImageMemoryDeviceGroupInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BindImageMemoryDeviceGroupInfoFreeCSlice must be called on the returned slice.
func BindImageMemoryDeviceGroupInfoMakeCSlice(x ...BindImageMemoryDeviceGroupInfo) []BindImageMemoryDeviceGroupInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindImageMemoryDeviceGroupInfo * len(x)
	dst := unsafe.Slice((*BindImageMemoryDeviceGroupInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBindImageMemoryDeviceGroupInfo
func (x BindImageMemoryDeviceGroupInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BindImageMemoryDeviceGroupInfo) WithDefaultSType() BindImageMemoryDeviceGroupInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemoryDeviceGroupInfo) WithSType(y StructureType) BindImageMemoryDeviceGroupInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkBindImageMemoryDeviceGroupInfo
func (x BindImageMemoryDeviceGroupInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemoryDeviceGroupInfo) WithPNext(y unsafe.Pointer) BindImageMemoryDeviceGroupInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// DeviceIndexCount returns the value of deviceIndexCount from VkBindImageMemoryDeviceGroupInfo
func (x BindImageMemoryDeviceGroupInfo) DeviceIndexCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.deviceIndexCount) 
	return *ptr
}

// WithDeviceIndexCount sets the value for the DeviceIndexCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemoryDeviceGroupInfo) WithDeviceIndexCount(y uint32) BindImageMemoryDeviceGroupInfo {
	x.deviceIndexCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PDeviceIndices returns the value of pDeviceIndices from VkBindImageMemoryDeviceGroupInfo
func (x BindImageMemoryDeviceGroupInfo) PDeviceIndices() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */ slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pDeviceIndices) 
	return *ptr
}

// WithPDeviceIndices sets the value for the PDeviceIndices on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines DeviceIndexCount as the length of this field.
// DeviceIndexCount is updated with the length of the new value.
func (x BindImageMemoryDeviceGroupInfo) WithPDeviceIndices(y []uint32) BindImageMemoryDeviceGroupInfo {
	x.pDeviceIndices = *(func(x *[]uint32) **C.uint32_t { /* Slice */ if len(*x) > 0 { slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.uint32_t)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithDeviceIndexCount(uint32(len(y)))
}

// SplitInstanceBindRegionCount returns the value of splitInstanceBindRegionCount from VkBindImageMemoryDeviceGroupInfo
func (x BindImageMemoryDeviceGroupInfo) SplitInstanceBindRegionCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.splitInstanceBindRegionCount) 
	return *ptr
}

// WithSplitInstanceBindRegionCount sets the value for the SplitInstanceBindRegionCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemoryDeviceGroupInfo) WithSplitInstanceBindRegionCount(y uint32) BindImageMemoryDeviceGroupInfo {
	x.splitInstanceBindRegionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PSplitInstanceBindRegions returns the value of pSplitInstanceBindRegions from VkBindImageMemoryDeviceGroupInfo
func (x BindImageMemoryDeviceGroupInfo) PSplitInstanceBindRegions() []Rect2D {
	ptr := func(x **C.struct_VkRect2D) *[]Rect2D { /* Slice */ slc := unsafe.Slice((*Rect2D)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pSplitInstanceBindRegions) 
	return *ptr
}

// WithPSplitInstanceBindRegions sets the value for the PSplitInstanceBindRegions on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines SplitInstanceBindRegionCount as the length of this field.
// SplitInstanceBindRegionCount is updated with the length of the new value.
func (x BindImageMemoryDeviceGroupInfo) WithPSplitInstanceBindRegions(y []Rect2D) BindImageMemoryDeviceGroupInfo {
	x.pSplitInstanceBindRegions = *(func(x *[]Rect2D) **C.struct_VkRect2D { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkRect2D)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkRect2D)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithSplitInstanceBindRegionCount(uint32(len(y)))
}

// SparseImageFormatProperties2 provides a go interface for VkSparseImageFormatProperties2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSparseImageFormatProperties2.html
type SparseImageFormatProperties2 C.struct_VkSparseImageFormatProperties2

// SizeofSparseImageFormatProperties2 is the memory size of a SparseImageFormatProperties2
var SizeofSparseImageFormatProperties2 int = int(unsafe.Sizeof(SparseImageFormatProperties2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SparseImageFormatProperties2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SparseImageFormatProperties2) AsCPtr() *SparseImageFormatProperties2 {
	clone := (*SparseImageFormatProperties2)(newCBlock(C.ulong(SizeofSparseImageFormatProperties2)))
	*clone = x
	return clone
}

// SparseImageFormatProperties2FreeCSlice releases the memory allocated by SparseImageFormatProperties2MakeCSlice.
// It does not free pointers stored inside the slice.
func SparseImageFormatProperties2FreeCSlice(x []SparseImageFormatProperties2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SparseImageFormatProperties2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SparseImageFormatProperties2FreeCSlice must be called on the returned slice.
func SparseImageFormatProperties2MakeCSlice(x ...SparseImageFormatProperties2) []SparseImageFormatProperties2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSparseImageFormatProperties2 * len(x)
	dst := unsafe.Slice((*SparseImageFormatProperties2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSparseImageFormatProperties2
func (x SparseImageFormatProperties2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SparseImageFormatProperties2) WithDefaultSType() SparseImageFormatProperties2 {
	return x.WithSType(VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageFormatProperties2) WithSType(y StructureType) SparseImageFormatProperties2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkSparseImageFormatProperties2
func (x SparseImageFormatProperties2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SparseImageFormatProperties2) WithPNext(y unsafe.Pointer) SparseImageFormatProperties2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Properties returns the value of properties from VkSparseImageFormatProperties2
func (x SparseImageFormatProperties2) Properties() SparseImageFormatProperties {
	ptr := /* typedef */ (*SparseImageFormatProperties)(&x.properties) 
	return *ptr
}

// PhysicalDeviceSparseImageFormatInfo2 provides a go interface for VkPhysicalDeviceSparseImageFormatInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSparseImageFormatInfo2.html
type PhysicalDeviceSparseImageFormatInfo2 C.struct_VkPhysicalDeviceSparseImageFormatInfo2

// SizeofPhysicalDeviceSparseImageFormatInfo2 is the memory size of a PhysicalDeviceSparseImageFormatInfo2
var SizeofPhysicalDeviceSparseImageFormatInfo2 int = int(unsafe.Sizeof(PhysicalDeviceSparseImageFormatInfo2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceSparseImageFormatInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceSparseImageFormatInfo2) AsCPtr() *PhysicalDeviceSparseImageFormatInfo2 {
	clone := (*PhysicalDeviceSparseImageFormatInfo2)(newCBlock(C.ulong(SizeofPhysicalDeviceSparseImageFormatInfo2)))
	*clone = x
	return clone
}

// PhysicalDeviceSparseImageFormatInfo2FreeCSlice releases the memory allocated by PhysicalDeviceSparseImageFormatInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceSparseImageFormatInfo2FreeCSlice(x []PhysicalDeviceSparseImageFormatInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceSparseImageFormatInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceSparseImageFormatInfo2FreeCSlice must be called on the returned slice.
func PhysicalDeviceSparseImageFormatInfo2MakeCSlice(x ...PhysicalDeviceSparseImageFormatInfo2) []PhysicalDeviceSparseImageFormatInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSparseImageFormatInfo2 * len(x)
	dst := unsafe.Slice((*PhysicalDeviceSparseImageFormatInfo2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceSparseImageFormatInfo2
func (x PhysicalDeviceSparseImageFormatInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceSparseImageFormatInfo2) WithDefaultSType() PhysicalDeviceSparseImageFormatInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSparseImageFormatInfo2) WithSType(y StructureType) PhysicalDeviceSparseImageFormatInfo2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceSparseImageFormatInfo2
func (x PhysicalDeviceSparseImageFormatInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSparseImageFormatInfo2) WithPNext(y unsafe.Pointer) PhysicalDeviceSparseImageFormatInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Format returns the value of format from VkPhysicalDeviceSparseImageFormatInfo2
func (x PhysicalDeviceSparseImageFormatInfo2) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format) 
	return *ptr
}

// WithFormat sets the value for the Format on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSparseImageFormatInfo2) WithFormat(y Format) PhysicalDeviceSparseImageFormatInfo2 {
	x.format = *(/* typedef */ (*C.VkFormat)(&y))
	return x
}

// Type_ returns the value of type from VkPhysicalDeviceSparseImageFormatInfo2
func (x PhysicalDeviceSparseImageFormatInfo2) Type_() ImageType {
	ptr := /* typedef */ (*ImageType)(&x._type) 
	return *ptr
}

// WithType_ sets the value for the Type_ on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSparseImageFormatInfo2) WithType_(y ImageType) PhysicalDeviceSparseImageFormatInfo2 {
	x._type = *(/* typedef */ (*C.VkImageType)(&y))
	return x
}

// Samples returns the value of samples from VkPhysicalDeviceSparseImageFormatInfo2
func (x PhysicalDeviceSparseImageFormatInfo2) Samples() SampleCountFlagBits {
	ptr := /* typedef */ (*SampleCountFlagBits)(&x.samples) 
	return *ptr
}

// WithSamples sets the value for the Samples on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSparseImageFormatInfo2) WithSamples(y SampleCountFlagBits) PhysicalDeviceSparseImageFormatInfo2 {
	x.samples = *(/* typedef */ (*C.VkSampleCountFlagBits)(&y))
	return x
}

// Usage returns the value of usage from VkPhysicalDeviceSparseImageFormatInfo2
func (x PhysicalDeviceSparseImageFormatInfo2) Usage() ImageUsageFlags {
	ptr := /* typedef */ (*ImageUsageFlags)(&x.usage) 
	return *ptr
}

// WithUsage sets the value for the Usage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSparseImageFormatInfo2) WithUsage(y ImageUsageFlags) PhysicalDeviceSparseImageFormatInfo2 {
	x.usage = *(/* typedef */ (*C.VkImageUsageFlags)(&y))
	return x
}

// Tiling returns the value of tiling from VkPhysicalDeviceSparseImageFormatInfo2
func (x PhysicalDeviceSparseImageFormatInfo2) Tiling() ImageTiling {
	ptr := /* typedef */ (*ImageTiling)(&x.tiling) 
	return *ptr
}

// WithTiling sets the value for the Tiling on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSparseImageFormatInfo2) WithTiling(y ImageTiling) PhysicalDeviceSparseImageFormatInfo2 {
	x.tiling = *(/* typedef */ (*C.VkImageTiling)(&y))
	return x
}

// BindBufferMemoryDeviceGroupInfo provides a go interface for VkBindBufferMemoryDeviceGroupInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindBufferMemoryDeviceGroupInfo.html
type BindBufferMemoryDeviceGroupInfo C.struct_VkBindBufferMemoryDeviceGroupInfo

// SizeofBindBufferMemoryDeviceGroupInfo is the memory size of a BindBufferMemoryDeviceGroupInfo
var SizeofBindBufferMemoryDeviceGroupInfo int = int(unsafe.Sizeof(BindBufferMemoryDeviceGroupInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BindBufferMemoryDeviceGroupInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BindBufferMemoryDeviceGroupInfo) AsCPtr() *BindBufferMemoryDeviceGroupInfo {
	clone := (*BindBufferMemoryDeviceGroupInfo)(newCBlock(C.ulong(SizeofBindBufferMemoryDeviceGroupInfo)))
	*clone = x
	return clone
}

// BindBufferMemoryDeviceGroupInfoFreeCSlice releases the memory allocated by BindBufferMemoryDeviceGroupInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BindBufferMemoryDeviceGroupInfoFreeCSlice(x []BindBufferMemoryDeviceGroupInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BindBufferMemoryDeviceGroupInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BindBufferMemoryDeviceGroupInfoFreeCSlice must be called on the returned slice.
func BindBufferMemoryDeviceGroupInfoMakeCSlice(x ...BindBufferMemoryDeviceGroupInfo) []BindBufferMemoryDeviceGroupInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindBufferMemoryDeviceGroupInfo * len(x)
	dst := unsafe.Slice((*BindBufferMemoryDeviceGroupInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBindBufferMemoryDeviceGroupInfo
func (x BindBufferMemoryDeviceGroupInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BindBufferMemoryDeviceGroupInfo) WithDefaultSType() BindBufferMemoryDeviceGroupInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindBufferMemoryDeviceGroupInfo) WithSType(y StructureType) BindBufferMemoryDeviceGroupInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkBindBufferMemoryDeviceGroupInfo
func (x BindBufferMemoryDeviceGroupInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindBufferMemoryDeviceGroupInfo) WithPNext(y unsafe.Pointer) BindBufferMemoryDeviceGroupInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// DeviceIndexCount returns the value of deviceIndexCount from VkBindBufferMemoryDeviceGroupInfo
func (x BindBufferMemoryDeviceGroupInfo) DeviceIndexCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.deviceIndexCount) 
	return *ptr
}

// WithDeviceIndexCount sets the value for the DeviceIndexCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindBufferMemoryDeviceGroupInfo) WithDeviceIndexCount(y uint32) BindBufferMemoryDeviceGroupInfo {
	x.deviceIndexCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PDeviceIndices returns the value of pDeviceIndices from VkBindBufferMemoryDeviceGroupInfo
func (x BindBufferMemoryDeviceGroupInfo) PDeviceIndices() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */ slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pDeviceIndices) 
	return *ptr
}

// WithPDeviceIndices sets the value for the PDeviceIndices on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines DeviceIndexCount as the length of this field.
// DeviceIndexCount is updated with the length of the new value.
func (x BindBufferMemoryDeviceGroupInfo) WithPDeviceIndices(y []uint32) BindBufferMemoryDeviceGroupInfo {
	x.pDeviceIndices = *(func(x *[]uint32) **C.uint32_t { /* Slice */ if len(*x) > 0 { slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.uint32_t)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithDeviceIndexCount(uint32(len(y)))
}

// DeviceGroupBindSparseInfo provides a go interface for VkDeviceGroupBindSparseInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupBindSparseInfo.html
type DeviceGroupBindSparseInfo C.struct_VkDeviceGroupBindSparseInfo

// SizeofDeviceGroupBindSparseInfo is the memory size of a DeviceGroupBindSparseInfo
var SizeofDeviceGroupBindSparseInfo int = int(unsafe.Sizeof(DeviceGroupBindSparseInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceGroupBindSparseInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceGroupBindSparseInfo) AsCPtr() *DeviceGroupBindSparseInfo {
	clone := (*DeviceGroupBindSparseInfo)(newCBlock(C.ulong(SizeofDeviceGroupBindSparseInfo)))
	*clone = x
	return clone
}

// DeviceGroupBindSparseInfoFreeCSlice releases the memory allocated by DeviceGroupBindSparseInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceGroupBindSparseInfoFreeCSlice(x []DeviceGroupBindSparseInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceGroupBindSparseInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceGroupBindSparseInfoFreeCSlice must be called on the returned slice.
func DeviceGroupBindSparseInfoMakeCSlice(x ...DeviceGroupBindSparseInfo) []DeviceGroupBindSparseInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupBindSparseInfo * len(x)
	dst := unsafe.Slice((*DeviceGroupBindSparseInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceGroupBindSparseInfo
func (x DeviceGroupBindSparseInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DeviceGroupBindSparseInfo) WithDefaultSType() DeviceGroupBindSparseInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupBindSparseInfo) WithSType(y StructureType) DeviceGroupBindSparseInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDeviceGroupBindSparseInfo
func (x DeviceGroupBindSparseInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupBindSparseInfo) WithPNext(y unsafe.Pointer) DeviceGroupBindSparseInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// ResourceDeviceIndex returns the value of resourceDeviceIndex from VkDeviceGroupBindSparseInfo
func (x DeviceGroupBindSparseInfo) ResourceDeviceIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.resourceDeviceIndex) 
	return *ptr
}

// WithResourceDeviceIndex sets the value for the ResourceDeviceIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupBindSparseInfo) WithResourceDeviceIndex(y uint32) DeviceGroupBindSparseInfo {
	x.resourceDeviceIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// MemoryDeviceIndex returns the value of memoryDeviceIndex from VkDeviceGroupBindSparseInfo
func (x DeviceGroupBindSparseInfo) MemoryDeviceIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.memoryDeviceIndex) 
	return *ptr
}

// WithMemoryDeviceIndex sets the value for the MemoryDeviceIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupBindSparseInfo) WithMemoryDeviceIndex(y uint32) DeviceGroupBindSparseInfo {
	x.memoryDeviceIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PhysicalDevicePointClippingProperties provides a go interface for VkPhysicalDevicePointClippingProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePointClippingProperties.html
type PhysicalDevicePointClippingProperties C.struct_VkPhysicalDevicePointClippingProperties

// SizeofPhysicalDevicePointClippingProperties is the memory size of a PhysicalDevicePointClippingProperties
var SizeofPhysicalDevicePointClippingProperties int = int(unsafe.Sizeof(PhysicalDevicePointClippingProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDevicePointClippingProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDevicePointClippingProperties) AsCPtr() *PhysicalDevicePointClippingProperties {
	clone := (*PhysicalDevicePointClippingProperties)(newCBlock(C.ulong(SizeofPhysicalDevicePointClippingProperties)))
	*clone = x
	return clone
}

// PhysicalDevicePointClippingPropertiesFreeCSlice releases the memory allocated by PhysicalDevicePointClippingPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDevicePointClippingPropertiesFreeCSlice(x []PhysicalDevicePointClippingProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDevicePointClippingPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDevicePointClippingPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDevicePointClippingPropertiesMakeCSlice(x ...PhysicalDevicePointClippingProperties) []PhysicalDevicePointClippingProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDevicePointClippingProperties * len(x)
	dst := unsafe.Slice((*PhysicalDevicePointClippingProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDevicePointClippingProperties
func (x PhysicalDevicePointClippingProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDevicePointClippingProperties) WithDefaultSType() PhysicalDevicePointClippingProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePointClippingProperties) WithSType(y StructureType) PhysicalDevicePointClippingProperties {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDevicePointClippingProperties
func (x PhysicalDevicePointClippingProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePointClippingProperties) WithPNext(y unsafe.Pointer) PhysicalDevicePointClippingProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// PointClippingBehavior returns the value of pointClippingBehavior from VkPhysicalDevicePointClippingProperties
func (x PhysicalDevicePointClippingProperties) PointClippingBehavior() PointClippingBehavior {
	ptr := /* typedef */ (*PointClippingBehavior)(&x.pointClippingBehavior) 
	return *ptr
}

// DeviceGroupSubmitInfo provides a go interface for VkDeviceGroupSubmitInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupSubmitInfo.html
type DeviceGroupSubmitInfo C.struct_VkDeviceGroupSubmitInfo

// SizeofDeviceGroupSubmitInfo is the memory size of a DeviceGroupSubmitInfo
var SizeofDeviceGroupSubmitInfo int = int(unsafe.Sizeof(DeviceGroupSubmitInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceGroupSubmitInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceGroupSubmitInfo) AsCPtr() *DeviceGroupSubmitInfo {
	clone := (*DeviceGroupSubmitInfo)(newCBlock(C.ulong(SizeofDeviceGroupSubmitInfo)))
	*clone = x
	return clone
}

// DeviceGroupSubmitInfoFreeCSlice releases the memory allocated by DeviceGroupSubmitInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceGroupSubmitInfoFreeCSlice(x []DeviceGroupSubmitInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceGroupSubmitInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceGroupSubmitInfoFreeCSlice must be called on the returned slice.
func DeviceGroupSubmitInfoMakeCSlice(x ...DeviceGroupSubmitInfo) []DeviceGroupSubmitInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupSubmitInfo * len(x)
	dst := unsafe.Slice((*DeviceGroupSubmitInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceGroupSubmitInfo
func (x DeviceGroupSubmitInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DeviceGroupSubmitInfo) WithDefaultSType() DeviceGroupSubmitInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupSubmitInfo) WithSType(y StructureType) DeviceGroupSubmitInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDeviceGroupSubmitInfo
func (x DeviceGroupSubmitInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupSubmitInfo) WithPNext(y unsafe.Pointer) DeviceGroupSubmitInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// WaitSemaphoreCount returns the value of waitSemaphoreCount from VkDeviceGroupSubmitInfo
func (x DeviceGroupSubmitInfo) WaitSemaphoreCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.waitSemaphoreCount) 
	return *ptr
}

// WithWaitSemaphoreCount sets the value for the WaitSemaphoreCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupSubmitInfo) WithWaitSemaphoreCount(y uint32) DeviceGroupSubmitInfo {
	x.waitSemaphoreCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PWaitSemaphoreDeviceIndices returns the value of pWaitSemaphoreDeviceIndices from VkDeviceGroupSubmitInfo
func (x DeviceGroupSubmitInfo) PWaitSemaphoreDeviceIndices() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */ slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pWaitSemaphoreDeviceIndices) 
	return *ptr
}

// WithPWaitSemaphoreDeviceIndices sets the value for the PWaitSemaphoreDeviceIndices on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines WaitSemaphoreCount as the length of this field.
// WaitSemaphoreCount is updated with the length of the new value.
func (x DeviceGroupSubmitInfo) WithPWaitSemaphoreDeviceIndices(y []uint32) DeviceGroupSubmitInfo {
	x.pWaitSemaphoreDeviceIndices = *(func(x *[]uint32) **C.uint32_t { /* Slice */ if len(*x) > 0 { slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.uint32_t)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithWaitSemaphoreCount(uint32(len(y)))
}

// CommandBufferCount returns the value of commandBufferCount from VkDeviceGroupSubmitInfo
func (x DeviceGroupSubmitInfo) CommandBufferCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.commandBufferCount) 
	return *ptr
}

// WithCommandBufferCount sets the value for the CommandBufferCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupSubmitInfo) WithCommandBufferCount(y uint32) DeviceGroupSubmitInfo {
	x.commandBufferCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PCommandBufferDeviceMasks returns the value of pCommandBufferDeviceMasks from VkDeviceGroupSubmitInfo
func (x DeviceGroupSubmitInfo) PCommandBufferDeviceMasks() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */ slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pCommandBufferDeviceMasks) 
	return *ptr
}

// WithPCommandBufferDeviceMasks sets the value for the PCommandBufferDeviceMasks on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines CommandBufferCount as the length of this field.
// CommandBufferCount is updated with the length of the new value.
func (x DeviceGroupSubmitInfo) WithPCommandBufferDeviceMasks(y []uint32) DeviceGroupSubmitInfo {
	x.pCommandBufferDeviceMasks = *(func(x *[]uint32) **C.uint32_t { /* Slice */ if len(*x) > 0 { slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.uint32_t)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithCommandBufferCount(uint32(len(y)))
}

// SignalSemaphoreCount returns the value of signalSemaphoreCount from VkDeviceGroupSubmitInfo
func (x DeviceGroupSubmitInfo) SignalSemaphoreCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.signalSemaphoreCount) 
	return *ptr
}

// WithSignalSemaphoreCount sets the value for the SignalSemaphoreCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupSubmitInfo) WithSignalSemaphoreCount(y uint32) DeviceGroupSubmitInfo {
	x.signalSemaphoreCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PSignalSemaphoreDeviceIndices returns the value of pSignalSemaphoreDeviceIndices from VkDeviceGroupSubmitInfo
func (x DeviceGroupSubmitInfo) PSignalSemaphoreDeviceIndices() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */ slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pSignalSemaphoreDeviceIndices) 
	return *ptr
}

// WithPSignalSemaphoreDeviceIndices sets the value for the PSignalSemaphoreDeviceIndices on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines SignalSemaphoreCount as the length of this field.
// SignalSemaphoreCount is updated with the length of the new value.
func (x DeviceGroupSubmitInfo) WithPSignalSemaphoreDeviceIndices(y []uint32) DeviceGroupSubmitInfo {
	x.pSignalSemaphoreDeviceIndices = *(func(x *[]uint32) **C.uint32_t { /* Slice */ if len(*x) > 0 { slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.uint32_t)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithSignalSemaphoreCount(uint32(len(y)))
}

// RenderPassInputAttachmentAspectCreateInfo provides a go interface for VkRenderPassInputAttachmentAspectCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassInputAttachmentAspectCreateInfo.html
type RenderPassInputAttachmentAspectCreateInfo C.struct_VkRenderPassInputAttachmentAspectCreateInfo

// SizeofRenderPassInputAttachmentAspectCreateInfo is the memory size of a RenderPassInputAttachmentAspectCreateInfo
var SizeofRenderPassInputAttachmentAspectCreateInfo int = int(unsafe.Sizeof(RenderPassInputAttachmentAspectCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *RenderPassInputAttachmentAspectCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x RenderPassInputAttachmentAspectCreateInfo) AsCPtr() *RenderPassInputAttachmentAspectCreateInfo {
	clone := (*RenderPassInputAttachmentAspectCreateInfo)(newCBlock(C.ulong(SizeofRenderPassInputAttachmentAspectCreateInfo)))
	*clone = x
	return clone
}

// RenderPassInputAttachmentAspectCreateInfoFreeCSlice releases the memory allocated by RenderPassInputAttachmentAspectCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func RenderPassInputAttachmentAspectCreateInfoFreeCSlice(x []RenderPassInputAttachmentAspectCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// RenderPassInputAttachmentAspectCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. RenderPassInputAttachmentAspectCreateInfoFreeCSlice must be called on the returned slice.
func RenderPassInputAttachmentAspectCreateInfoMakeCSlice(x ...RenderPassInputAttachmentAspectCreateInfo) []RenderPassInputAttachmentAspectCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderPassInputAttachmentAspectCreateInfo * len(x)
	dst := unsafe.Slice((*RenderPassInputAttachmentAspectCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkRenderPassInputAttachmentAspectCreateInfo
func (x RenderPassInputAttachmentAspectCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x RenderPassInputAttachmentAspectCreateInfo) WithDefaultSType() RenderPassInputAttachmentAspectCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassInputAttachmentAspectCreateInfo) WithSType(y StructureType) RenderPassInputAttachmentAspectCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkRenderPassInputAttachmentAspectCreateInfo
func (x RenderPassInputAttachmentAspectCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassInputAttachmentAspectCreateInfo) WithPNext(y unsafe.Pointer) RenderPassInputAttachmentAspectCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// AspectReferenceCount returns the value of aspectReferenceCount from VkRenderPassInputAttachmentAspectCreateInfo
func (x RenderPassInputAttachmentAspectCreateInfo) AspectReferenceCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.aspectReferenceCount) 
	return *ptr
}

// WithAspectReferenceCount sets the value for the AspectReferenceCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassInputAttachmentAspectCreateInfo) WithAspectReferenceCount(y uint32) RenderPassInputAttachmentAspectCreateInfo {
	x.aspectReferenceCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PAspectReferences returns the value of pAspectReferences from VkRenderPassInputAttachmentAspectCreateInfo
func (x RenderPassInputAttachmentAspectCreateInfo) PAspectReferences() []InputAttachmentAspectReference {
	ptr := func(x **C.struct_VkInputAttachmentAspectReference) *[]InputAttachmentAspectReference { /* Slice */ slc := unsafe.Slice((*InputAttachmentAspectReference)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pAspectReferences) 
	return *ptr
}

// WithPAspectReferences sets the value for the PAspectReferences on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines AspectReferenceCount as the length of this field.
// AspectReferenceCount is updated with the length of the new value.
func (x RenderPassInputAttachmentAspectCreateInfo) WithPAspectReferences(y []InputAttachmentAspectReference) RenderPassInputAttachmentAspectCreateInfo {
	x.pAspectReferences = *(func(x *[]InputAttachmentAspectReference) **C.struct_VkInputAttachmentAspectReference { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkInputAttachmentAspectReference)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkInputAttachmentAspectReference)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithAspectReferenceCount(uint32(len(y)))
}

// InputAttachmentAspectReference provides a go interface for VkInputAttachmentAspectReference.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkInputAttachmentAspectReference.html
type InputAttachmentAspectReference C.struct_VkInputAttachmentAspectReference

// SizeofInputAttachmentAspectReference is the memory size of a InputAttachmentAspectReference
var SizeofInputAttachmentAspectReference int = int(unsafe.Sizeof(InputAttachmentAspectReference{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *InputAttachmentAspectReference) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x InputAttachmentAspectReference) AsCPtr() *InputAttachmentAspectReference {
	clone := (*InputAttachmentAspectReference)(newCBlock(C.ulong(SizeofInputAttachmentAspectReference)))
	*clone = x
	return clone
}

// InputAttachmentAspectReferenceFreeCSlice releases the memory allocated by InputAttachmentAspectReferenceMakeCSlice.
// It does not free pointers stored inside the slice.
func InputAttachmentAspectReferenceFreeCSlice(x []InputAttachmentAspectReference) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// InputAttachmentAspectReferenceMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. InputAttachmentAspectReferenceFreeCSlice must be called on the returned slice.
func InputAttachmentAspectReferenceMakeCSlice(x ...InputAttachmentAspectReference) []InputAttachmentAspectReference {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofInputAttachmentAspectReference * len(x)
	dst := unsafe.Slice((*InputAttachmentAspectReference)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Subpass returns the value of subpass from VkInputAttachmentAspectReference
func (x InputAttachmentAspectReference) Subpass() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.subpass) 
	return *ptr
}

// WithSubpass sets the value for the Subpass on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InputAttachmentAspectReference) WithSubpass(y uint32) InputAttachmentAspectReference {
	x.subpass = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// InputAttachmentIndex returns the value of inputAttachmentIndex from VkInputAttachmentAspectReference
func (x InputAttachmentAspectReference) InputAttachmentIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.inputAttachmentIndex) 
	return *ptr
}

// WithInputAttachmentIndex sets the value for the InputAttachmentIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InputAttachmentAspectReference) WithInputAttachmentIndex(y uint32) InputAttachmentAspectReference {
	x.inputAttachmentIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// AspectMask returns the value of aspectMask from VkInputAttachmentAspectReference
func (x InputAttachmentAspectReference) AspectMask() ImageAspectFlags {
	ptr := /* typedef */ (*ImageAspectFlags)(&x.aspectMask) 
	return *ptr
}

// WithAspectMask sets the value for the AspectMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x InputAttachmentAspectReference) WithAspectMask(y ImageAspectFlags) InputAttachmentAspectReference {
	x.aspectMask = *(/* typedef */ (*C.VkImageAspectFlags)(&y))
	return x
}

// ImageViewUsageCreateInfo provides a go interface for VkImageViewUsageCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageViewUsageCreateInfo.html
type ImageViewUsageCreateInfo C.struct_VkImageViewUsageCreateInfo

// SizeofImageViewUsageCreateInfo is the memory size of a ImageViewUsageCreateInfo
var SizeofImageViewUsageCreateInfo int = int(unsafe.Sizeof(ImageViewUsageCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageViewUsageCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageViewUsageCreateInfo) AsCPtr() *ImageViewUsageCreateInfo {
	clone := (*ImageViewUsageCreateInfo)(newCBlock(C.ulong(SizeofImageViewUsageCreateInfo)))
	*clone = x
	return clone
}

// ImageViewUsageCreateInfoFreeCSlice releases the memory allocated by ImageViewUsageCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageViewUsageCreateInfoFreeCSlice(x []ImageViewUsageCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageViewUsageCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageViewUsageCreateInfoFreeCSlice must be called on the returned slice.
func ImageViewUsageCreateInfoMakeCSlice(x ...ImageViewUsageCreateInfo) []ImageViewUsageCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageViewUsageCreateInfo * len(x)
	dst := unsafe.Slice((*ImageViewUsageCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageViewUsageCreateInfo
func (x ImageViewUsageCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ImageViewUsageCreateInfo) WithDefaultSType() ImageViewUsageCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewUsageCreateInfo) WithSType(y StructureType) ImageViewUsageCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkImageViewUsageCreateInfo
func (x ImageViewUsageCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewUsageCreateInfo) WithPNext(y unsafe.Pointer) ImageViewUsageCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Usage returns the value of usage from VkImageViewUsageCreateInfo
func (x ImageViewUsageCreateInfo) Usage() ImageUsageFlags {
	ptr := /* typedef */ (*ImageUsageFlags)(&x.usage) 
	return *ptr
}

// WithUsage sets the value for the Usage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageViewUsageCreateInfo) WithUsage(y ImageUsageFlags) ImageViewUsageCreateInfo {
	x.usage = *(/* typedef */ (*C.VkImageUsageFlags)(&y))
	return x
}

// DeviceGroupCommandBufferBeginInfo provides a go interface for VkDeviceGroupCommandBufferBeginInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupCommandBufferBeginInfo.html
type DeviceGroupCommandBufferBeginInfo C.struct_VkDeviceGroupCommandBufferBeginInfo

// SizeofDeviceGroupCommandBufferBeginInfo is the memory size of a DeviceGroupCommandBufferBeginInfo
var SizeofDeviceGroupCommandBufferBeginInfo int = int(unsafe.Sizeof(DeviceGroupCommandBufferBeginInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceGroupCommandBufferBeginInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceGroupCommandBufferBeginInfo) AsCPtr() *DeviceGroupCommandBufferBeginInfo {
	clone := (*DeviceGroupCommandBufferBeginInfo)(newCBlock(C.ulong(SizeofDeviceGroupCommandBufferBeginInfo)))
	*clone = x
	return clone
}

// DeviceGroupCommandBufferBeginInfoFreeCSlice releases the memory allocated by DeviceGroupCommandBufferBeginInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceGroupCommandBufferBeginInfoFreeCSlice(x []DeviceGroupCommandBufferBeginInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceGroupCommandBufferBeginInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceGroupCommandBufferBeginInfoFreeCSlice must be called on the returned slice.
func DeviceGroupCommandBufferBeginInfoMakeCSlice(x ...DeviceGroupCommandBufferBeginInfo) []DeviceGroupCommandBufferBeginInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupCommandBufferBeginInfo * len(x)
	dst := unsafe.Slice((*DeviceGroupCommandBufferBeginInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceGroupCommandBufferBeginInfo
func (x DeviceGroupCommandBufferBeginInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DeviceGroupCommandBufferBeginInfo) WithDefaultSType() DeviceGroupCommandBufferBeginInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupCommandBufferBeginInfo) WithSType(y StructureType) DeviceGroupCommandBufferBeginInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDeviceGroupCommandBufferBeginInfo
func (x DeviceGroupCommandBufferBeginInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupCommandBufferBeginInfo) WithPNext(y unsafe.Pointer) DeviceGroupCommandBufferBeginInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// DeviceMask returns the value of deviceMask from VkDeviceGroupCommandBufferBeginInfo
func (x DeviceGroupCommandBufferBeginInfo) DeviceMask() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.deviceMask) 
	return *ptr
}

// WithDeviceMask sets the value for the DeviceMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupCommandBufferBeginInfo) WithDeviceMask(y uint32) DeviceGroupCommandBufferBeginInfo {
	x.deviceMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PipelineTessellationDomainOriginStateCreateInfo provides a go interface for VkPipelineTessellationDomainOriginStateCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineTessellationDomainOriginStateCreateInfo.html
type PipelineTessellationDomainOriginStateCreateInfo C.struct_VkPipelineTessellationDomainOriginStateCreateInfo

// SizeofPipelineTessellationDomainOriginStateCreateInfo is the memory size of a PipelineTessellationDomainOriginStateCreateInfo
var SizeofPipelineTessellationDomainOriginStateCreateInfo int = int(unsafe.Sizeof(PipelineTessellationDomainOriginStateCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineTessellationDomainOriginStateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineTessellationDomainOriginStateCreateInfo) AsCPtr() *PipelineTessellationDomainOriginStateCreateInfo {
	clone := (*PipelineTessellationDomainOriginStateCreateInfo)(newCBlock(C.ulong(SizeofPipelineTessellationDomainOriginStateCreateInfo)))
	*clone = x
	return clone
}

// PipelineTessellationDomainOriginStateCreateInfoFreeCSlice releases the memory allocated by PipelineTessellationDomainOriginStateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineTessellationDomainOriginStateCreateInfoFreeCSlice(x []PipelineTessellationDomainOriginStateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineTessellationDomainOriginStateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineTessellationDomainOriginStateCreateInfoFreeCSlice must be called on the returned slice.
func PipelineTessellationDomainOriginStateCreateInfoMakeCSlice(x ...PipelineTessellationDomainOriginStateCreateInfo) []PipelineTessellationDomainOriginStateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineTessellationDomainOriginStateCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineTessellationDomainOriginStateCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineTessellationDomainOriginStateCreateInfo
func (x PipelineTessellationDomainOriginStateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineTessellationDomainOriginStateCreateInfo) WithDefaultSType() PipelineTessellationDomainOriginStateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineTessellationDomainOriginStateCreateInfo) WithSType(y StructureType) PipelineTessellationDomainOriginStateCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPipelineTessellationDomainOriginStateCreateInfo
func (x PipelineTessellationDomainOriginStateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineTessellationDomainOriginStateCreateInfo) WithPNext(y unsafe.Pointer) PipelineTessellationDomainOriginStateCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// DomainOrigin returns the value of domainOrigin from VkPipelineTessellationDomainOriginStateCreateInfo
func (x PipelineTessellationDomainOriginStateCreateInfo) DomainOrigin() TessellationDomainOrigin {
	ptr := /* typedef */ (*TessellationDomainOrigin)(&x.domainOrigin) 
	return *ptr
}

// WithDomainOrigin sets the value for the DomainOrigin on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineTessellationDomainOriginStateCreateInfo) WithDomainOrigin(y TessellationDomainOrigin) PipelineTessellationDomainOriginStateCreateInfo {
	x.domainOrigin = *(/* typedef */ (*C.VkTessellationDomainOrigin)(&y))
	return x
}

// RenderPassMultiviewCreateInfo provides a go interface for VkRenderPassMultiviewCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassMultiviewCreateInfo.html
type RenderPassMultiviewCreateInfo C.struct_VkRenderPassMultiviewCreateInfo

// SizeofRenderPassMultiviewCreateInfo is the memory size of a RenderPassMultiviewCreateInfo
var SizeofRenderPassMultiviewCreateInfo int = int(unsafe.Sizeof(RenderPassMultiviewCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *RenderPassMultiviewCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x RenderPassMultiviewCreateInfo) AsCPtr() *RenderPassMultiviewCreateInfo {
	clone := (*RenderPassMultiviewCreateInfo)(newCBlock(C.ulong(SizeofRenderPassMultiviewCreateInfo)))
	*clone = x
	return clone
}

// RenderPassMultiviewCreateInfoFreeCSlice releases the memory allocated by RenderPassMultiviewCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func RenderPassMultiviewCreateInfoFreeCSlice(x []RenderPassMultiviewCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// RenderPassMultiviewCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. RenderPassMultiviewCreateInfoFreeCSlice must be called on the returned slice.
func RenderPassMultiviewCreateInfoMakeCSlice(x ...RenderPassMultiviewCreateInfo) []RenderPassMultiviewCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderPassMultiviewCreateInfo * len(x)
	dst := unsafe.Slice((*RenderPassMultiviewCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkRenderPassMultiviewCreateInfo
func (x RenderPassMultiviewCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x RenderPassMultiviewCreateInfo) WithDefaultSType() RenderPassMultiviewCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassMultiviewCreateInfo) WithSType(y StructureType) RenderPassMultiviewCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkRenderPassMultiviewCreateInfo
func (x RenderPassMultiviewCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassMultiviewCreateInfo) WithPNext(y unsafe.Pointer) RenderPassMultiviewCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SubpassCount returns the value of subpassCount from VkRenderPassMultiviewCreateInfo
func (x RenderPassMultiviewCreateInfo) SubpassCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.subpassCount) 
	return *ptr
}

// WithSubpassCount sets the value for the SubpassCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassMultiviewCreateInfo) WithSubpassCount(y uint32) RenderPassMultiviewCreateInfo {
	x.subpassCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PViewMasks returns the value of pViewMasks from VkRenderPassMultiviewCreateInfo
func (x RenderPassMultiviewCreateInfo) PViewMasks() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */ slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pViewMasks) 
	return *ptr
}

// WithPViewMasks sets the value for the PViewMasks on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines SubpassCount as the length of this field.
// SubpassCount is updated with the length of the new value.
func (x RenderPassMultiviewCreateInfo) WithPViewMasks(y []uint32) RenderPassMultiviewCreateInfo {
	x.pViewMasks = *(func(x *[]uint32) **C.uint32_t { /* Slice */ if len(*x) > 0 { slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.uint32_t)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithSubpassCount(uint32(len(y)))
}

// DependencyCount returns the value of dependencyCount from VkRenderPassMultiviewCreateInfo
func (x RenderPassMultiviewCreateInfo) DependencyCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dependencyCount) 
	return *ptr
}

// WithDependencyCount sets the value for the DependencyCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassMultiviewCreateInfo) WithDependencyCount(y uint32) RenderPassMultiviewCreateInfo {
	x.dependencyCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PViewOffsets returns the value of pViewOffsets from VkRenderPassMultiviewCreateInfo
func (x RenderPassMultiviewCreateInfo) PViewOffsets() []int32 {
	ptr := func(x **C.int32_t) *[]int32 { /* Slice */ slc := unsafe.Slice((*int32)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pViewOffsets) 
	return *ptr
}

// WithPViewOffsets sets the value for the PViewOffsets on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines DependencyCount as the length of this field.
// DependencyCount is updated with the length of the new value.
func (x RenderPassMultiviewCreateInfo) WithPViewOffsets(y []int32) RenderPassMultiviewCreateInfo {
	x.pViewOffsets = *(func(x *[]int32) **C.int32_t { /* Slice */ if len(*x) > 0 { slc := (*C.int32_t)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.int32_t)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithDependencyCount(uint32(len(y)))
}

// CorrelationMaskCount returns the value of correlationMaskCount from VkRenderPassMultiviewCreateInfo
func (x RenderPassMultiviewCreateInfo) CorrelationMaskCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.correlationMaskCount) 
	return *ptr
}

// WithCorrelationMaskCount sets the value for the CorrelationMaskCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassMultiviewCreateInfo) WithCorrelationMaskCount(y uint32) RenderPassMultiviewCreateInfo {
	x.correlationMaskCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PCorrelationMasks returns the value of pCorrelationMasks from VkRenderPassMultiviewCreateInfo
func (x RenderPassMultiviewCreateInfo) PCorrelationMasks() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */ slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pCorrelationMasks) 
	return *ptr
}

// WithPCorrelationMasks sets the value for the PCorrelationMasks on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines CorrelationMaskCount as the length of this field.
// CorrelationMaskCount is updated with the length of the new value.
func (x RenderPassMultiviewCreateInfo) WithPCorrelationMasks(y []uint32) RenderPassMultiviewCreateInfo {
	x.pCorrelationMasks = *(func(x *[]uint32) **C.uint32_t { /* Slice */ if len(*x) > 0 { slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.uint32_t)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithCorrelationMaskCount(uint32(len(y)))
}

// PhysicalDeviceMultiviewFeatures provides a go interface for VkPhysicalDeviceMultiviewFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultiviewFeatures.html
type PhysicalDeviceMultiviewFeatures C.struct_VkPhysicalDeviceMultiviewFeatures

// SizeofPhysicalDeviceMultiviewFeatures is the memory size of a PhysicalDeviceMultiviewFeatures
var SizeofPhysicalDeviceMultiviewFeatures int = int(unsafe.Sizeof(PhysicalDeviceMultiviewFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceMultiviewFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceMultiviewFeatures) AsCPtr() *PhysicalDeviceMultiviewFeatures {
	clone := (*PhysicalDeviceMultiviewFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceMultiviewFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceMultiviewFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceMultiviewFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceMultiviewFeaturesFreeCSlice(x []PhysicalDeviceMultiviewFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceMultiviewFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceMultiviewFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceMultiviewFeaturesMakeCSlice(x ...PhysicalDeviceMultiviewFeatures) []PhysicalDeviceMultiviewFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceMultiviewFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceMultiviewFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceMultiviewFeatures
func (x PhysicalDeviceMultiviewFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceMultiviewFeatures) WithDefaultSType() PhysicalDeviceMultiviewFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMultiviewFeatures) WithSType(y StructureType) PhysicalDeviceMultiviewFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceMultiviewFeatures
func (x PhysicalDeviceMultiviewFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMultiviewFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceMultiviewFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Multiview returns the value of multiview from VkPhysicalDeviceMultiviewFeatures
func (x PhysicalDeviceMultiviewFeatures) Multiview() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.multiview) 
	return *ptr
}

// WithMultiview sets the value for the Multiview on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMultiviewFeatures) WithMultiview(y Bool32) PhysicalDeviceMultiviewFeatures {
	x.multiview = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// MultiviewGeometryShader returns the value of multiviewGeometryShader from VkPhysicalDeviceMultiviewFeatures
func (x PhysicalDeviceMultiviewFeatures) MultiviewGeometryShader() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.multiviewGeometryShader) 
	return *ptr
}

// WithMultiviewGeometryShader sets the value for the MultiviewGeometryShader on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMultiviewFeatures) WithMultiviewGeometryShader(y Bool32) PhysicalDeviceMultiviewFeatures {
	x.multiviewGeometryShader = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// MultiviewTessellationShader returns the value of multiviewTessellationShader from VkPhysicalDeviceMultiviewFeatures
func (x PhysicalDeviceMultiviewFeatures) MultiviewTessellationShader() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.multiviewTessellationShader) 
	return *ptr
}

// WithMultiviewTessellationShader sets the value for the MultiviewTessellationShader on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMultiviewFeatures) WithMultiviewTessellationShader(y Bool32) PhysicalDeviceMultiviewFeatures {
	x.multiviewTessellationShader = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// PhysicalDeviceMultiviewProperties provides a go interface for VkPhysicalDeviceMultiviewProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultiviewProperties.html
type PhysicalDeviceMultiviewProperties C.struct_VkPhysicalDeviceMultiviewProperties

// SizeofPhysicalDeviceMultiviewProperties is the memory size of a PhysicalDeviceMultiviewProperties
var SizeofPhysicalDeviceMultiviewProperties int = int(unsafe.Sizeof(PhysicalDeviceMultiviewProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceMultiviewProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceMultiviewProperties) AsCPtr() *PhysicalDeviceMultiviewProperties {
	clone := (*PhysicalDeviceMultiviewProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceMultiviewProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceMultiviewPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceMultiviewPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceMultiviewPropertiesFreeCSlice(x []PhysicalDeviceMultiviewProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceMultiviewPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceMultiviewPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceMultiviewPropertiesMakeCSlice(x ...PhysicalDeviceMultiviewProperties) []PhysicalDeviceMultiviewProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceMultiviewProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceMultiviewProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceMultiviewProperties
func (x PhysicalDeviceMultiviewProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceMultiviewProperties) WithDefaultSType() PhysicalDeviceMultiviewProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMultiviewProperties) WithSType(y StructureType) PhysicalDeviceMultiviewProperties {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceMultiviewProperties
func (x PhysicalDeviceMultiviewProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMultiviewProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceMultiviewProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// MaxMultiviewViewCount returns the value of maxMultiviewViewCount from VkPhysicalDeviceMultiviewProperties
func (x PhysicalDeviceMultiviewProperties) MaxMultiviewViewCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxMultiviewViewCount) 
	return *ptr
}

// MaxMultiviewInstanceIndex returns the value of maxMultiviewInstanceIndex from VkPhysicalDeviceMultiviewProperties
func (x PhysicalDeviceMultiviewProperties) MaxMultiviewInstanceIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxMultiviewInstanceIndex) 
	return *ptr
}

//PhysicalDeviceVariablePointerFeatures is an alias to PhysicalDeviceVariablePointersFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVariablePointerFeatures.html
//
// Deprecated: Most Aliases in the Vulkan spec are for compatibility purposes as extensions get
// promoted to features. If possible, update code to use the promoted name: PhysicalDeviceVariablePointersFeatures.
type PhysicalDeviceVariablePointerFeatures = PhysicalDeviceVariablePointersFeatures
// DeviceGroupRenderPassBeginInfo provides a go interface for VkDeviceGroupRenderPassBeginInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupRenderPassBeginInfo.html
type DeviceGroupRenderPassBeginInfo C.struct_VkDeviceGroupRenderPassBeginInfo

// SizeofDeviceGroupRenderPassBeginInfo is the memory size of a DeviceGroupRenderPassBeginInfo
var SizeofDeviceGroupRenderPassBeginInfo int = int(unsafe.Sizeof(DeviceGroupRenderPassBeginInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceGroupRenderPassBeginInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceGroupRenderPassBeginInfo) AsCPtr() *DeviceGroupRenderPassBeginInfo {
	clone := (*DeviceGroupRenderPassBeginInfo)(newCBlock(C.ulong(SizeofDeviceGroupRenderPassBeginInfo)))
	*clone = x
	return clone
}

// DeviceGroupRenderPassBeginInfoFreeCSlice releases the memory allocated by DeviceGroupRenderPassBeginInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceGroupRenderPassBeginInfoFreeCSlice(x []DeviceGroupRenderPassBeginInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceGroupRenderPassBeginInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceGroupRenderPassBeginInfoFreeCSlice must be called on the returned slice.
func DeviceGroupRenderPassBeginInfoMakeCSlice(x ...DeviceGroupRenderPassBeginInfo) []DeviceGroupRenderPassBeginInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupRenderPassBeginInfo * len(x)
	dst := unsafe.Slice((*DeviceGroupRenderPassBeginInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceGroupRenderPassBeginInfo
func (x DeviceGroupRenderPassBeginInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DeviceGroupRenderPassBeginInfo) WithDefaultSType() DeviceGroupRenderPassBeginInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupRenderPassBeginInfo) WithSType(y StructureType) DeviceGroupRenderPassBeginInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDeviceGroupRenderPassBeginInfo
func (x DeviceGroupRenderPassBeginInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupRenderPassBeginInfo) WithPNext(y unsafe.Pointer) DeviceGroupRenderPassBeginInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// DeviceMask returns the value of deviceMask from VkDeviceGroupRenderPassBeginInfo
func (x DeviceGroupRenderPassBeginInfo) DeviceMask() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.deviceMask) 
	return *ptr
}

// WithDeviceMask sets the value for the DeviceMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupRenderPassBeginInfo) WithDeviceMask(y uint32) DeviceGroupRenderPassBeginInfo {
	x.deviceMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// DeviceRenderAreaCount returns the value of deviceRenderAreaCount from VkDeviceGroupRenderPassBeginInfo
func (x DeviceGroupRenderPassBeginInfo) DeviceRenderAreaCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.deviceRenderAreaCount) 
	return *ptr
}

// WithDeviceRenderAreaCount sets the value for the DeviceRenderAreaCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupRenderPassBeginInfo) WithDeviceRenderAreaCount(y uint32) DeviceGroupRenderPassBeginInfo {
	x.deviceRenderAreaCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PDeviceRenderAreas returns the value of pDeviceRenderAreas from VkDeviceGroupRenderPassBeginInfo
func (x DeviceGroupRenderPassBeginInfo) PDeviceRenderAreas() []Rect2D {
	ptr := func(x **C.struct_VkRect2D) *[]Rect2D { /* Slice */ slc := unsafe.Slice((*Rect2D)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pDeviceRenderAreas) 
	return *ptr
}

// WithPDeviceRenderAreas sets the value for the PDeviceRenderAreas on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines DeviceRenderAreaCount as the length of this field.
// DeviceRenderAreaCount is updated with the length of the new value.
func (x DeviceGroupRenderPassBeginInfo) WithPDeviceRenderAreas(y []Rect2D) DeviceGroupRenderPassBeginInfo {
	x.pDeviceRenderAreas = *(func(x *[]Rect2D) **C.struct_VkRect2D { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkRect2D)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkRect2D)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithDeviceRenderAreaCount(uint32(len(y)))
}

// MemoryAllocateFlagsInfo provides a go interface for VkMemoryAllocateFlagsInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryAllocateFlagsInfo.html
type MemoryAllocateFlagsInfo C.struct_VkMemoryAllocateFlagsInfo

// SizeofMemoryAllocateFlagsInfo is the memory size of a MemoryAllocateFlagsInfo
var SizeofMemoryAllocateFlagsInfo int = int(unsafe.Sizeof(MemoryAllocateFlagsInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryAllocateFlagsInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryAllocateFlagsInfo) AsCPtr() *MemoryAllocateFlagsInfo {
	clone := (*MemoryAllocateFlagsInfo)(newCBlock(C.ulong(SizeofMemoryAllocateFlagsInfo)))
	*clone = x
	return clone
}

// MemoryAllocateFlagsInfoFreeCSlice releases the memory allocated by MemoryAllocateFlagsInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryAllocateFlagsInfoFreeCSlice(x []MemoryAllocateFlagsInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryAllocateFlagsInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryAllocateFlagsInfoFreeCSlice must be called on the returned slice.
func MemoryAllocateFlagsInfoMakeCSlice(x ...MemoryAllocateFlagsInfo) []MemoryAllocateFlagsInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryAllocateFlagsInfo * len(x)
	dst := unsafe.Slice((*MemoryAllocateFlagsInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkMemoryAllocateFlagsInfo
func (x MemoryAllocateFlagsInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x MemoryAllocateFlagsInfo) WithDefaultSType() MemoryAllocateFlagsInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryAllocateFlagsInfo) WithSType(y StructureType) MemoryAllocateFlagsInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkMemoryAllocateFlagsInfo
func (x MemoryAllocateFlagsInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryAllocateFlagsInfo) WithPNext(y unsafe.Pointer) MemoryAllocateFlagsInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkMemoryAllocateFlagsInfo
func (x MemoryAllocateFlagsInfo) Flags() MemoryAllocateFlags {
	ptr := /* typedef */ (*MemoryAllocateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryAllocateFlagsInfo) WithFlags(y MemoryAllocateFlags) MemoryAllocateFlagsInfo {
	x.flags = *(/* typedef */ (*C.VkMemoryAllocateFlags)(&y))
	return x
}

// DeviceMask returns the value of deviceMask from VkMemoryAllocateFlagsInfo
func (x MemoryAllocateFlagsInfo) DeviceMask() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.deviceMask) 
	return *ptr
}

// WithDeviceMask sets the value for the DeviceMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryAllocateFlagsInfo) WithDeviceMask(y uint32) MemoryAllocateFlagsInfo {
	x.deviceMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PhysicalDeviceProtectedMemoryFeatures provides a go interface for VkPhysicalDeviceProtectedMemoryFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProtectedMemoryFeatures.html
type PhysicalDeviceProtectedMemoryFeatures C.struct_VkPhysicalDeviceProtectedMemoryFeatures

// SizeofPhysicalDeviceProtectedMemoryFeatures is the memory size of a PhysicalDeviceProtectedMemoryFeatures
var SizeofPhysicalDeviceProtectedMemoryFeatures int = int(unsafe.Sizeof(PhysicalDeviceProtectedMemoryFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceProtectedMemoryFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceProtectedMemoryFeatures) AsCPtr() *PhysicalDeviceProtectedMemoryFeatures {
	clone := (*PhysicalDeviceProtectedMemoryFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceProtectedMemoryFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceProtectedMemoryFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceProtectedMemoryFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceProtectedMemoryFeaturesFreeCSlice(x []PhysicalDeviceProtectedMemoryFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceProtectedMemoryFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceProtectedMemoryFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceProtectedMemoryFeaturesMakeCSlice(x ...PhysicalDeviceProtectedMemoryFeatures) []PhysicalDeviceProtectedMemoryFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceProtectedMemoryFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceProtectedMemoryFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceProtectedMemoryFeatures
func (x PhysicalDeviceProtectedMemoryFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceProtectedMemoryFeatures) WithDefaultSType() PhysicalDeviceProtectedMemoryFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceProtectedMemoryFeatures) WithSType(y StructureType) PhysicalDeviceProtectedMemoryFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceProtectedMemoryFeatures
func (x PhysicalDeviceProtectedMemoryFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceProtectedMemoryFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceProtectedMemoryFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// ProtectedMemory returns the value of protectedMemory from VkPhysicalDeviceProtectedMemoryFeatures
func (x PhysicalDeviceProtectedMemoryFeatures) ProtectedMemory() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.protectedMemory) 
	return *ptr
}

// WithProtectedMemory sets the value for the ProtectedMemory on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceProtectedMemoryFeatures) WithProtectedMemory(y Bool32) PhysicalDeviceProtectedMemoryFeatures {
	x.protectedMemory = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// PhysicalDeviceProtectedMemoryProperties provides a go interface for VkPhysicalDeviceProtectedMemoryProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProtectedMemoryProperties.html
type PhysicalDeviceProtectedMemoryProperties C.struct_VkPhysicalDeviceProtectedMemoryProperties

// SizeofPhysicalDeviceProtectedMemoryProperties is the memory size of a PhysicalDeviceProtectedMemoryProperties
var SizeofPhysicalDeviceProtectedMemoryProperties int = int(unsafe.Sizeof(PhysicalDeviceProtectedMemoryProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceProtectedMemoryProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceProtectedMemoryProperties) AsCPtr() *PhysicalDeviceProtectedMemoryProperties {
	clone := (*PhysicalDeviceProtectedMemoryProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceProtectedMemoryProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceProtectedMemoryPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceProtectedMemoryPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceProtectedMemoryPropertiesFreeCSlice(x []PhysicalDeviceProtectedMemoryProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceProtectedMemoryPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceProtectedMemoryPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceProtectedMemoryPropertiesMakeCSlice(x ...PhysicalDeviceProtectedMemoryProperties) []PhysicalDeviceProtectedMemoryProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceProtectedMemoryProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceProtectedMemoryProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceProtectedMemoryProperties
func (x PhysicalDeviceProtectedMemoryProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceProtectedMemoryProperties) WithDefaultSType() PhysicalDeviceProtectedMemoryProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceProtectedMemoryProperties) WithSType(y StructureType) PhysicalDeviceProtectedMemoryProperties {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceProtectedMemoryProperties
func (x PhysicalDeviceProtectedMemoryProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceProtectedMemoryProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceProtectedMemoryProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// ProtectedNoFault returns the value of protectedNoFault from VkPhysicalDeviceProtectedMemoryProperties
func (x PhysicalDeviceProtectedMemoryProperties) ProtectedNoFault() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.protectedNoFault) 
	return *ptr
}

// DeviceQueueInfo2 provides a go interface for VkDeviceQueueInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceQueueInfo2.html
type DeviceQueueInfo2 C.struct_VkDeviceQueueInfo2

// SizeofDeviceQueueInfo2 is the memory size of a DeviceQueueInfo2
var SizeofDeviceQueueInfo2 int = int(unsafe.Sizeof(DeviceQueueInfo2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceQueueInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceQueueInfo2) AsCPtr() *DeviceQueueInfo2 {
	clone := (*DeviceQueueInfo2)(newCBlock(C.ulong(SizeofDeviceQueueInfo2)))
	*clone = x
	return clone
}

// DeviceQueueInfo2FreeCSlice releases the memory allocated by DeviceQueueInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceQueueInfo2FreeCSlice(x []DeviceQueueInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceQueueInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceQueueInfo2FreeCSlice must be called on the returned slice.
func DeviceQueueInfo2MakeCSlice(x ...DeviceQueueInfo2) []DeviceQueueInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceQueueInfo2 * len(x)
	dst := unsafe.Slice((*DeviceQueueInfo2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceQueueInfo2
func (x DeviceQueueInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DeviceQueueInfo2) WithDefaultSType() DeviceQueueInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueInfo2) WithSType(y StructureType) DeviceQueueInfo2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDeviceQueueInfo2
func (x DeviceQueueInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueInfo2) WithPNext(y unsafe.Pointer) DeviceQueueInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkDeviceQueueInfo2
func (x DeviceQueueInfo2) Flags() DeviceQueueCreateFlags {
	ptr := /* typedef */ (*DeviceQueueCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueInfo2) WithFlags(y DeviceQueueCreateFlags) DeviceQueueInfo2 {
	x.flags = *(/* typedef */ (*C.VkDeviceQueueCreateFlags)(&y))
	return x
}

// QueueFamilyIndex returns the value of queueFamilyIndex from VkDeviceQueueInfo2
func (x DeviceQueueInfo2) QueueFamilyIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.queueFamilyIndex) 
	return *ptr
}

// WithQueueFamilyIndex sets the value for the QueueFamilyIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueInfo2) WithQueueFamilyIndex(y uint32) DeviceQueueInfo2 {
	x.queueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// QueueIndex returns the value of queueIndex from VkDeviceQueueInfo2
func (x DeviceQueueInfo2) QueueIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.queueIndex) 
	return *ptr
}

// WithQueueIndex sets the value for the QueueIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceQueueInfo2) WithQueueIndex(y uint32) DeviceQueueInfo2 {
	x.queueIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// ProtectedSubmitInfo provides a go interface for VkProtectedSubmitInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkProtectedSubmitInfo.html
type ProtectedSubmitInfo C.struct_VkProtectedSubmitInfo

// SizeofProtectedSubmitInfo is the memory size of a ProtectedSubmitInfo
var SizeofProtectedSubmitInfo int = int(unsafe.Sizeof(ProtectedSubmitInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ProtectedSubmitInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ProtectedSubmitInfo) AsCPtr() *ProtectedSubmitInfo {
	clone := (*ProtectedSubmitInfo)(newCBlock(C.ulong(SizeofProtectedSubmitInfo)))
	*clone = x
	return clone
}

// ProtectedSubmitInfoFreeCSlice releases the memory allocated by ProtectedSubmitInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ProtectedSubmitInfoFreeCSlice(x []ProtectedSubmitInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ProtectedSubmitInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ProtectedSubmitInfoFreeCSlice must be called on the returned slice.
func ProtectedSubmitInfoMakeCSlice(x ...ProtectedSubmitInfo) []ProtectedSubmitInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofProtectedSubmitInfo * len(x)
	dst := unsafe.Slice((*ProtectedSubmitInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkProtectedSubmitInfo
func (x ProtectedSubmitInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ProtectedSubmitInfo) WithDefaultSType() ProtectedSubmitInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ProtectedSubmitInfo) WithSType(y StructureType) ProtectedSubmitInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkProtectedSubmitInfo
func (x ProtectedSubmitInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ProtectedSubmitInfo) WithPNext(y unsafe.Pointer) ProtectedSubmitInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// ProtectedSubmit returns the value of protectedSubmit from VkProtectedSubmitInfo
func (x ProtectedSubmitInfo) ProtectedSubmit() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.protectedSubmit) 
	return *ptr
}

// WithProtectedSubmit sets the value for the ProtectedSubmit on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ProtectedSubmitInfo) WithProtectedSubmit(y Bool32) ProtectedSubmitInfo {
	x.protectedSubmit = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// PhysicalDeviceExternalSemaphoreInfo provides a go interface for VkPhysicalDeviceExternalSemaphoreInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalSemaphoreInfo.html
type PhysicalDeviceExternalSemaphoreInfo C.struct_VkPhysicalDeviceExternalSemaphoreInfo

// SizeofPhysicalDeviceExternalSemaphoreInfo is the memory size of a PhysicalDeviceExternalSemaphoreInfo
var SizeofPhysicalDeviceExternalSemaphoreInfo int = int(unsafe.Sizeof(PhysicalDeviceExternalSemaphoreInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceExternalSemaphoreInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceExternalSemaphoreInfo) AsCPtr() *PhysicalDeviceExternalSemaphoreInfo {
	clone := (*PhysicalDeviceExternalSemaphoreInfo)(newCBlock(C.ulong(SizeofPhysicalDeviceExternalSemaphoreInfo)))
	*clone = x
	return clone
}

// PhysicalDeviceExternalSemaphoreInfoFreeCSlice releases the memory allocated by PhysicalDeviceExternalSemaphoreInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceExternalSemaphoreInfoFreeCSlice(x []PhysicalDeviceExternalSemaphoreInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceExternalSemaphoreInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceExternalSemaphoreInfoFreeCSlice must be called on the returned slice.
func PhysicalDeviceExternalSemaphoreInfoMakeCSlice(x ...PhysicalDeviceExternalSemaphoreInfo) []PhysicalDeviceExternalSemaphoreInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceExternalSemaphoreInfo * len(x)
	dst := unsafe.Slice((*PhysicalDeviceExternalSemaphoreInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceExternalSemaphoreInfo
func (x PhysicalDeviceExternalSemaphoreInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceExternalSemaphoreInfo) WithDefaultSType() PhysicalDeviceExternalSemaphoreInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalSemaphoreInfo) WithSType(y StructureType) PhysicalDeviceExternalSemaphoreInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceExternalSemaphoreInfo
func (x PhysicalDeviceExternalSemaphoreInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalSemaphoreInfo) WithPNext(y unsafe.Pointer) PhysicalDeviceExternalSemaphoreInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// HandleType returns the value of handleType from VkPhysicalDeviceExternalSemaphoreInfo
func (x PhysicalDeviceExternalSemaphoreInfo) HandleType() ExternalSemaphoreHandleTypeFlagBits {
	ptr := /* typedef */ (*ExternalSemaphoreHandleTypeFlagBits)(&x.handleType) 
	return *ptr
}

// WithHandleType sets the value for the HandleType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalSemaphoreInfo) WithHandleType(y ExternalSemaphoreHandleTypeFlagBits) PhysicalDeviceExternalSemaphoreInfo {
	x.handleType = *(/* typedef */ (*C.VkExternalSemaphoreHandleTypeFlagBits)(&y))
	return x
}

// ExportMemoryAllocateInfo provides a go interface for VkExportMemoryAllocateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExportMemoryAllocateInfo.html
type ExportMemoryAllocateInfo C.struct_VkExportMemoryAllocateInfo

// SizeofExportMemoryAllocateInfo is the memory size of a ExportMemoryAllocateInfo
var SizeofExportMemoryAllocateInfo int = int(unsafe.Sizeof(ExportMemoryAllocateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExportMemoryAllocateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExportMemoryAllocateInfo) AsCPtr() *ExportMemoryAllocateInfo {
	clone := (*ExportMemoryAllocateInfo)(newCBlock(C.ulong(SizeofExportMemoryAllocateInfo)))
	*clone = x
	return clone
}

// ExportMemoryAllocateInfoFreeCSlice releases the memory allocated by ExportMemoryAllocateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ExportMemoryAllocateInfoFreeCSlice(x []ExportMemoryAllocateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExportMemoryAllocateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExportMemoryAllocateInfoFreeCSlice must be called on the returned slice.
func ExportMemoryAllocateInfoMakeCSlice(x ...ExportMemoryAllocateInfo) []ExportMemoryAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExportMemoryAllocateInfo * len(x)
	dst := unsafe.Slice((*ExportMemoryAllocateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkExportMemoryAllocateInfo
func (x ExportMemoryAllocateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ExportMemoryAllocateInfo) WithDefaultSType() ExportMemoryAllocateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExportMemoryAllocateInfo) WithSType(y StructureType) ExportMemoryAllocateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkExportMemoryAllocateInfo
func (x ExportMemoryAllocateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExportMemoryAllocateInfo) WithPNext(y unsafe.Pointer) ExportMemoryAllocateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// HandleTypes returns the value of handleTypes from VkExportMemoryAllocateInfo
func (x ExportMemoryAllocateInfo) HandleTypes() ExternalMemoryHandleTypeFlags {
	ptr := /* typedef */ (*ExternalMemoryHandleTypeFlags)(&x.handleTypes) 
	return *ptr
}

// WithHandleTypes sets the value for the HandleTypes on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExportMemoryAllocateInfo) WithHandleTypes(y ExternalMemoryHandleTypeFlags) ExportMemoryAllocateInfo {
	x.handleTypes = *(/* typedef */ (*C.VkExternalMemoryHandleTypeFlags)(&y))
	return x
}

// SamplerYcbcrConversionCreateInfo provides a go interface for VkSamplerYcbcrConversionCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerYcbcrConversionCreateInfo.html
type SamplerYcbcrConversionCreateInfo C.struct_VkSamplerYcbcrConversionCreateInfo

// SizeofSamplerYcbcrConversionCreateInfo is the memory size of a SamplerYcbcrConversionCreateInfo
var SizeofSamplerYcbcrConversionCreateInfo int = int(unsafe.Sizeof(SamplerYcbcrConversionCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SamplerYcbcrConversionCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SamplerYcbcrConversionCreateInfo) AsCPtr() *SamplerYcbcrConversionCreateInfo {
	clone := (*SamplerYcbcrConversionCreateInfo)(newCBlock(C.ulong(SizeofSamplerYcbcrConversionCreateInfo)))
	*clone = x
	return clone
}

// SamplerYcbcrConversionCreateInfoFreeCSlice releases the memory allocated by SamplerYcbcrConversionCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SamplerYcbcrConversionCreateInfoFreeCSlice(x []SamplerYcbcrConversionCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SamplerYcbcrConversionCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SamplerYcbcrConversionCreateInfoFreeCSlice must be called on the returned slice.
func SamplerYcbcrConversionCreateInfoMakeCSlice(x ...SamplerYcbcrConversionCreateInfo) []SamplerYcbcrConversionCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSamplerYcbcrConversionCreateInfo * len(x)
	dst := unsafe.Slice((*SamplerYcbcrConversionCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SamplerYcbcrConversionCreateInfo) WithDefaultSType() SamplerYcbcrConversionCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithSType(y StructureType) SamplerYcbcrConversionCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithPNext(y unsafe.Pointer) SamplerYcbcrConversionCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Format returns the value of format from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format) 
	return *ptr
}

// WithFormat sets the value for the Format on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithFormat(y Format) SamplerYcbcrConversionCreateInfo {
	x.format = *(/* typedef */ (*C.VkFormat)(&y))
	return x
}

// YcbcrModel returns the value of ycbcrModel from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) YcbcrModel() SamplerYcbcrModelConversion {
	ptr := /* typedef */ (*SamplerYcbcrModelConversion)(&x.ycbcrModel) 
	return *ptr
}

// WithYcbcrModel sets the value for the YcbcrModel on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithYcbcrModel(y SamplerYcbcrModelConversion) SamplerYcbcrConversionCreateInfo {
	x.ycbcrModel = *(/* typedef */ (*C.VkSamplerYcbcrModelConversion)(&y))
	return x
}

// YcbcrRange returns the value of ycbcrRange from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) YcbcrRange() SamplerYcbcrRange {
	ptr := /* typedef */ (*SamplerYcbcrRange)(&x.ycbcrRange) 
	return *ptr
}

// WithYcbcrRange sets the value for the YcbcrRange on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithYcbcrRange(y SamplerYcbcrRange) SamplerYcbcrConversionCreateInfo {
	x.ycbcrRange = *(/* typedef */ (*C.VkSamplerYcbcrRange)(&y))
	return x
}

// Components returns the value of components from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) Components() ComponentMapping {
	ptr := /* typedef */ (*ComponentMapping)(&x.components) 
	return *ptr
}

// WithComponents sets the value for the Components on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithComponents(y ComponentMapping) SamplerYcbcrConversionCreateInfo {
	x.components = *(/* typedef */ (*C.struct_VkComponentMapping)(&y))
	return x
}

// XChromaOffset returns the value of xChromaOffset from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) XChromaOffset() ChromaLocation {
	ptr := /* typedef */ (*ChromaLocation)(&x.xChromaOffset) 
	return *ptr
}

// WithXChromaOffset sets the value for the XChromaOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithXChromaOffset(y ChromaLocation) SamplerYcbcrConversionCreateInfo {
	x.xChromaOffset = *(/* typedef */ (*C.VkChromaLocation)(&y))
	return x
}

// YChromaOffset returns the value of yChromaOffset from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) YChromaOffset() ChromaLocation {
	ptr := /* typedef */ (*ChromaLocation)(&x.yChromaOffset) 
	return *ptr
}

// WithYChromaOffset sets the value for the YChromaOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithYChromaOffset(y ChromaLocation) SamplerYcbcrConversionCreateInfo {
	x.yChromaOffset = *(/* typedef */ (*C.VkChromaLocation)(&y))
	return x
}

// ChromaFilter returns the value of chromaFilter from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) ChromaFilter() Filter {
	ptr := /* typedef */ (*Filter)(&x.chromaFilter) 
	return *ptr
}

// WithChromaFilter sets the value for the ChromaFilter on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithChromaFilter(y Filter) SamplerYcbcrConversionCreateInfo {
	x.chromaFilter = *(/* typedef */ (*C.VkFilter)(&y))
	return x
}

// ForceExplicitReconstruction returns the value of forceExplicitReconstruction from VkSamplerYcbcrConversionCreateInfo
func (x SamplerYcbcrConversionCreateInfo) ForceExplicitReconstruction() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.forceExplicitReconstruction) 
	return *ptr
}

// WithForceExplicitReconstruction sets the value for the ForceExplicitReconstruction on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionCreateInfo) WithForceExplicitReconstruction(y Bool32) SamplerYcbcrConversionCreateInfo {
	x.forceExplicitReconstruction = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// SamplerYcbcrConversionInfo provides a go interface for VkSamplerYcbcrConversionInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerYcbcrConversionInfo.html
type SamplerYcbcrConversionInfo C.struct_VkSamplerYcbcrConversionInfo

// SizeofSamplerYcbcrConversionInfo is the memory size of a SamplerYcbcrConversionInfo
var SizeofSamplerYcbcrConversionInfo int = int(unsafe.Sizeof(SamplerYcbcrConversionInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SamplerYcbcrConversionInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SamplerYcbcrConversionInfo) AsCPtr() *SamplerYcbcrConversionInfo {
	clone := (*SamplerYcbcrConversionInfo)(newCBlock(C.ulong(SizeofSamplerYcbcrConversionInfo)))
	*clone = x
	return clone
}

// SamplerYcbcrConversionInfoFreeCSlice releases the memory allocated by SamplerYcbcrConversionInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SamplerYcbcrConversionInfoFreeCSlice(x []SamplerYcbcrConversionInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SamplerYcbcrConversionInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SamplerYcbcrConversionInfoFreeCSlice must be called on the returned slice.
func SamplerYcbcrConversionInfoMakeCSlice(x ...SamplerYcbcrConversionInfo) []SamplerYcbcrConversionInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSamplerYcbcrConversionInfo * len(x)
	dst := unsafe.Slice((*SamplerYcbcrConversionInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSamplerYcbcrConversionInfo
func (x SamplerYcbcrConversionInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SamplerYcbcrConversionInfo) WithDefaultSType() SamplerYcbcrConversionInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionInfo) WithSType(y StructureType) SamplerYcbcrConversionInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkSamplerYcbcrConversionInfo
func (x SamplerYcbcrConversionInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionInfo) WithPNext(y unsafe.Pointer) SamplerYcbcrConversionInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Conversion returns the value of conversion from VkSamplerYcbcrConversionInfo
func (x SamplerYcbcrConversionInfo) Conversion() SamplerYcbcrConversion {
	ptr := /* handle */ (*SamplerYcbcrConversion)(&x.conversion) 
	return *ptr
}

// WithConversion sets the value for the Conversion on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionInfo) WithConversion(y SamplerYcbcrConversion) SamplerYcbcrConversionInfo {
	x.conversion = *(/* handle */ (*C.VkSamplerYcbcrConversion)(&y))
	return x
}

// BindImagePlaneMemoryInfo provides a go interface for VkBindImagePlaneMemoryInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindImagePlaneMemoryInfo.html
type BindImagePlaneMemoryInfo C.struct_VkBindImagePlaneMemoryInfo

// SizeofBindImagePlaneMemoryInfo is the memory size of a BindImagePlaneMemoryInfo
var SizeofBindImagePlaneMemoryInfo int = int(unsafe.Sizeof(BindImagePlaneMemoryInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BindImagePlaneMemoryInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BindImagePlaneMemoryInfo) AsCPtr() *BindImagePlaneMemoryInfo {
	clone := (*BindImagePlaneMemoryInfo)(newCBlock(C.ulong(SizeofBindImagePlaneMemoryInfo)))
	*clone = x
	return clone
}

// BindImagePlaneMemoryInfoFreeCSlice releases the memory allocated by BindImagePlaneMemoryInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BindImagePlaneMemoryInfoFreeCSlice(x []BindImagePlaneMemoryInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BindImagePlaneMemoryInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BindImagePlaneMemoryInfoFreeCSlice must be called on the returned slice.
func BindImagePlaneMemoryInfoMakeCSlice(x ...BindImagePlaneMemoryInfo) []BindImagePlaneMemoryInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindImagePlaneMemoryInfo * len(x)
	dst := unsafe.Slice((*BindImagePlaneMemoryInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBindImagePlaneMemoryInfo
func (x BindImagePlaneMemoryInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BindImagePlaneMemoryInfo) WithDefaultSType() BindImagePlaneMemoryInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImagePlaneMemoryInfo) WithSType(y StructureType) BindImagePlaneMemoryInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkBindImagePlaneMemoryInfo
func (x BindImagePlaneMemoryInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImagePlaneMemoryInfo) WithPNext(y unsafe.Pointer) BindImagePlaneMemoryInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// PlaneAspect returns the value of planeAspect from VkBindImagePlaneMemoryInfo
func (x BindImagePlaneMemoryInfo) PlaneAspect() ImageAspectFlagBits {
	ptr := /* typedef */ (*ImageAspectFlagBits)(&x.planeAspect) 
	return *ptr
}

// WithPlaneAspect sets the value for the PlaneAspect on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImagePlaneMemoryInfo) WithPlaneAspect(y ImageAspectFlagBits) BindImagePlaneMemoryInfo {
	x.planeAspect = *(/* typedef */ (*C.VkImageAspectFlagBits)(&y))
	return x
}

// ImagePlaneMemoryRequirementsInfo provides a go interface for VkImagePlaneMemoryRequirementsInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImagePlaneMemoryRequirementsInfo.html
type ImagePlaneMemoryRequirementsInfo C.struct_VkImagePlaneMemoryRequirementsInfo

// SizeofImagePlaneMemoryRequirementsInfo is the memory size of a ImagePlaneMemoryRequirementsInfo
var SizeofImagePlaneMemoryRequirementsInfo int = int(unsafe.Sizeof(ImagePlaneMemoryRequirementsInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImagePlaneMemoryRequirementsInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImagePlaneMemoryRequirementsInfo) AsCPtr() *ImagePlaneMemoryRequirementsInfo {
	clone := (*ImagePlaneMemoryRequirementsInfo)(newCBlock(C.ulong(SizeofImagePlaneMemoryRequirementsInfo)))
	*clone = x
	return clone
}

// ImagePlaneMemoryRequirementsInfoFreeCSlice releases the memory allocated by ImagePlaneMemoryRequirementsInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ImagePlaneMemoryRequirementsInfoFreeCSlice(x []ImagePlaneMemoryRequirementsInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImagePlaneMemoryRequirementsInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImagePlaneMemoryRequirementsInfoFreeCSlice must be called on the returned slice.
func ImagePlaneMemoryRequirementsInfoMakeCSlice(x ...ImagePlaneMemoryRequirementsInfo) []ImagePlaneMemoryRequirementsInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImagePlaneMemoryRequirementsInfo * len(x)
	dst := unsafe.Slice((*ImagePlaneMemoryRequirementsInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImagePlaneMemoryRequirementsInfo
func (x ImagePlaneMemoryRequirementsInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ImagePlaneMemoryRequirementsInfo) WithDefaultSType() ImagePlaneMemoryRequirementsInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImagePlaneMemoryRequirementsInfo) WithSType(y StructureType) ImagePlaneMemoryRequirementsInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkImagePlaneMemoryRequirementsInfo
func (x ImagePlaneMemoryRequirementsInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImagePlaneMemoryRequirementsInfo) WithPNext(y unsafe.Pointer) ImagePlaneMemoryRequirementsInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// PlaneAspect returns the value of planeAspect from VkImagePlaneMemoryRequirementsInfo
func (x ImagePlaneMemoryRequirementsInfo) PlaneAspect() ImageAspectFlagBits {
	ptr := /* typedef */ (*ImageAspectFlagBits)(&x.planeAspect) 
	return *ptr
}

// WithPlaneAspect sets the value for the PlaneAspect on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImagePlaneMemoryRequirementsInfo) WithPlaneAspect(y ImageAspectFlagBits) ImagePlaneMemoryRequirementsInfo {
	x.planeAspect = *(/* typedef */ (*C.VkImageAspectFlagBits)(&y))
	return x
}

// PhysicalDeviceSamplerYcbcrConversionFeatures provides a go interface for VkPhysicalDeviceSamplerYcbcrConversionFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSamplerYcbcrConversionFeatures.html
type PhysicalDeviceSamplerYcbcrConversionFeatures C.struct_VkPhysicalDeviceSamplerYcbcrConversionFeatures

// SizeofPhysicalDeviceSamplerYcbcrConversionFeatures is the memory size of a PhysicalDeviceSamplerYcbcrConversionFeatures
var SizeofPhysicalDeviceSamplerYcbcrConversionFeatures int = int(unsafe.Sizeof(PhysicalDeviceSamplerYcbcrConversionFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceSamplerYcbcrConversionFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) AsCPtr() *PhysicalDeviceSamplerYcbcrConversionFeatures {
	clone := (*PhysicalDeviceSamplerYcbcrConversionFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceSamplerYcbcrConversionFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceSamplerYcbcrConversionFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceSamplerYcbcrConversionFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceSamplerYcbcrConversionFeaturesFreeCSlice(x []PhysicalDeviceSamplerYcbcrConversionFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceSamplerYcbcrConversionFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceSamplerYcbcrConversionFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceSamplerYcbcrConversionFeaturesMakeCSlice(x ...PhysicalDeviceSamplerYcbcrConversionFeatures) []PhysicalDeviceSamplerYcbcrConversionFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSamplerYcbcrConversionFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceSamplerYcbcrConversionFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceSamplerYcbcrConversionFeatures
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) WithDefaultSType() PhysicalDeviceSamplerYcbcrConversionFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) WithSType(y StructureType) PhysicalDeviceSamplerYcbcrConversionFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceSamplerYcbcrConversionFeatures
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceSamplerYcbcrConversionFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SamplerYcbcrConversion returns the value of samplerYcbcrConversion from VkPhysicalDeviceSamplerYcbcrConversionFeatures
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) SamplerYcbcrConversion() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.samplerYcbcrConversion) 
	return *ptr
}

// WithSamplerYcbcrConversion sets the value for the SamplerYcbcrConversion on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) WithSamplerYcbcrConversion(y Bool32) PhysicalDeviceSamplerYcbcrConversionFeatures {
	x.samplerYcbcrConversion = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// SamplerYcbcrConversionImageFormatProperties provides a go interface for VkSamplerYcbcrConversionImageFormatProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerYcbcrConversionImageFormatProperties.html
type SamplerYcbcrConversionImageFormatProperties C.struct_VkSamplerYcbcrConversionImageFormatProperties

// SizeofSamplerYcbcrConversionImageFormatProperties is the memory size of a SamplerYcbcrConversionImageFormatProperties
var SizeofSamplerYcbcrConversionImageFormatProperties int = int(unsafe.Sizeof(SamplerYcbcrConversionImageFormatProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SamplerYcbcrConversionImageFormatProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SamplerYcbcrConversionImageFormatProperties) AsCPtr() *SamplerYcbcrConversionImageFormatProperties {
	clone := (*SamplerYcbcrConversionImageFormatProperties)(newCBlock(C.ulong(SizeofSamplerYcbcrConversionImageFormatProperties)))
	*clone = x
	return clone
}

// SamplerYcbcrConversionImageFormatPropertiesFreeCSlice releases the memory allocated by SamplerYcbcrConversionImageFormatPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func SamplerYcbcrConversionImageFormatPropertiesFreeCSlice(x []SamplerYcbcrConversionImageFormatProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SamplerYcbcrConversionImageFormatPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SamplerYcbcrConversionImageFormatPropertiesFreeCSlice must be called on the returned slice.
func SamplerYcbcrConversionImageFormatPropertiesMakeCSlice(x ...SamplerYcbcrConversionImageFormatProperties) []SamplerYcbcrConversionImageFormatProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSamplerYcbcrConversionImageFormatProperties * len(x)
	dst := unsafe.Slice((*SamplerYcbcrConversionImageFormatProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSamplerYcbcrConversionImageFormatProperties
func (x SamplerYcbcrConversionImageFormatProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SamplerYcbcrConversionImageFormatProperties) WithDefaultSType() SamplerYcbcrConversionImageFormatProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionImageFormatProperties) WithSType(y StructureType) SamplerYcbcrConversionImageFormatProperties {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkSamplerYcbcrConversionImageFormatProperties
func (x SamplerYcbcrConversionImageFormatProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerYcbcrConversionImageFormatProperties) WithPNext(y unsafe.Pointer) SamplerYcbcrConversionImageFormatProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// CombinedImageSamplerDescriptorCount returns the value of combinedImageSamplerDescriptorCount from VkSamplerYcbcrConversionImageFormatProperties
func (x SamplerYcbcrConversionImageFormatProperties) CombinedImageSamplerDescriptorCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.combinedImageSamplerDescriptorCount) 
	return *ptr
}

// ExternalSemaphoreProperties provides a go interface for VkExternalSemaphoreProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalSemaphoreProperties.html
type ExternalSemaphoreProperties C.struct_VkExternalSemaphoreProperties

// SizeofExternalSemaphoreProperties is the memory size of a ExternalSemaphoreProperties
var SizeofExternalSemaphoreProperties int = int(unsafe.Sizeof(ExternalSemaphoreProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExternalSemaphoreProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExternalSemaphoreProperties) AsCPtr() *ExternalSemaphoreProperties {
	clone := (*ExternalSemaphoreProperties)(newCBlock(C.ulong(SizeofExternalSemaphoreProperties)))
	*clone = x
	return clone
}

// ExternalSemaphorePropertiesFreeCSlice releases the memory allocated by ExternalSemaphorePropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func ExternalSemaphorePropertiesFreeCSlice(x []ExternalSemaphoreProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExternalSemaphorePropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExternalSemaphorePropertiesFreeCSlice must be called on the returned slice.
func ExternalSemaphorePropertiesMakeCSlice(x ...ExternalSemaphoreProperties) []ExternalSemaphoreProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalSemaphoreProperties * len(x)
	dst := unsafe.Slice((*ExternalSemaphoreProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkExternalSemaphoreProperties
func (x ExternalSemaphoreProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ExternalSemaphoreProperties) WithDefaultSType() ExternalSemaphoreProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalSemaphoreProperties) WithSType(y StructureType) ExternalSemaphoreProperties {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkExternalSemaphoreProperties
func (x ExternalSemaphoreProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalSemaphoreProperties) WithPNext(y unsafe.Pointer) ExternalSemaphoreProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// ExportFromImportedHandleTypes returns the value of exportFromImportedHandleTypes from VkExternalSemaphoreProperties
func (x ExternalSemaphoreProperties) ExportFromImportedHandleTypes() ExternalSemaphoreHandleTypeFlags {
	ptr := /* typedef */ (*ExternalSemaphoreHandleTypeFlags)(&x.exportFromImportedHandleTypes) 
	return *ptr
}

// CompatibleHandleTypes returns the value of compatibleHandleTypes from VkExternalSemaphoreProperties
func (x ExternalSemaphoreProperties) CompatibleHandleTypes() ExternalSemaphoreHandleTypeFlags {
	ptr := /* typedef */ (*ExternalSemaphoreHandleTypeFlags)(&x.compatibleHandleTypes) 
	return *ptr
}

// ExternalSemaphoreFeatures returns the value of externalSemaphoreFeatures from VkExternalSemaphoreProperties
func (x ExternalSemaphoreProperties) ExternalSemaphoreFeatures() ExternalSemaphoreFeatureFlags {
	ptr := /* typedef */ (*ExternalSemaphoreFeatureFlags)(&x.externalSemaphoreFeatures) 
	return *ptr
}

// MemoryDedicatedAllocateInfo provides a go interface for VkMemoryDedicatedAllocateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryDedicatedAllocateInfo.html
type MemoryDedicatedAllocateInfo C.struct_VkMemoryDedicatedAllocateInfo

// SizeofMemoryDedicatedAllocateInfo is the memory size of a MemoryDedicatedAllocateInfo
var SizeofMemoryDedicatedAllocateInfo int = int(unsafe.Sizeof(MemoryDedicatedAllocateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryDedicatedAllocateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryDedicatedAllocateInfo) AsCPtr() *MemoryDedicatedAllocateInfo {
	clone := (*MemoryDedicatedAllocateInfo)(newCBlock(C.ulong(SizeofMemoryDedicatedAllocateInfo)))
	*clone = x
	return clone
}

// MemoryDedicatedAllocateInfoFreeCSlice releases the memory allocated by MemoryDedicatedAllocateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryDedicatedAllocateInfoFreeCSlice(x []MemoryDedicatedAllocateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryDedicatedAllocateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryDedicatedAllocateInfoFreeCSlice must be called on the returned slice.
func MemoryDedicatedAllocateInfoMakeCSlice(x ...MemoryDedicatedAllocateInfo) []MemoryDedicatedAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryDedicatedAllocateInfo * len(x)
	dst := unsafe.Slice((*MemoryDedicatedAllocateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkMemoryDedicatedAllocateInfo
func (x MemoryDedicatedAllocateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x MemoryDedicatedAllocateInfo) WithDefaultSType() MemoryDedicatedAllocateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryDedicatedAllocateInfo) WithSType(y StructureType) MemoryDedicatedAllocateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkMemoryDedicatedAllocateInfo
func (x MemoryDedicatedAllocateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryDedicatedAllocateInfo) WithPNext(y unsafe.Pointer) MemoryDedicatedAllocateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Image returns the value of image from VkMemoryDedicatedAllocateInfo
func (x MemoryDedicatedAllocateInfo) Image() Image {
	ptr := /* handle */ (*Image)(&x.image) 
	return *ptr
}

// WithImage sets the value for the Image on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryDedicatedAllocateInfo) WithImage(y Image) MemoryDedicatedAllocateInfo {
	x.image = *(/* handle */ (*C.VkImage)(&y))
	return x
}

// Buffer returns the value of buffer from VkMemoryDedicatedAllocateInfo
func (x MemoryDedicatedAllocateInfo) Buffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.buffer) 
	return *ptr
}

// WithBuffer sets the value for the Buffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryDedicatedAllocateInfo) WithBuffer(y Buffer) MemoryDedicatedAllocateInfo {
	x.buffer = *(/* handle */ (*C.VkBuffer)(&y))
	return x
}

// PhysicalDeviceVariablePointersFeatures provides a go interface for VkPhysicalDeviceVariablePointersFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVariablePointersFeatures.html
type PhysicalDeviceVariablePointersFeatures C.struct_VkPhysicalDeviceVariablePointersFeatures

// SizeofPhysicalDeviceVariablePointersFeatures is the memory size of a PhysicalDeviceVariablePointersFeatures
var SizeofPhysicalDeviceVariablePointersFeatures int = int(unsafe.Sizeof(PhysicalDeviceVariablePointersFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceVariablePointersFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceVariablePointersFeatures) AsCPtr() *PhysicalDeviceVariablePointersFeatures {
	clone := (*PhysicalDeviceVariablePointersFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceVariablePointersFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceVariablePointersFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceVariablePointersFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceVariablePointersFeaturesFreeCSlice(x []PhysicalDeviceVariablePointersFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceVariablePointersFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceVariablePointersFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceVariablePointersFeaturesMakeCSlice(x ...PhysicalDeviceVariablePointersFeatures) []PhysicalDeviceVariablePointersFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVariablePointersFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceVariablePointersFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceVariablePointersFeatures
func (x PhysicalDeviceVariablePointersFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceVariablePointersFeatures) WithDefaultSType() PhysicalDeviceVariablePointersFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVariablePointersFeatures) WithSType(y StructureType) PhysicalDeviceVariablePointersFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceVariablePointersFeatures
func (x PhysicalDeviceVariablePointersFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVariablePointersFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceVariablePointersFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// VariablePointersStorageBuffer returns the value of variablePointersStorageBuffer from VkPhysicalDeviceVariablePointersFeatures
func (x PhysicalDeviceVariablePointersFeatures) VariablePointersStorageBuffer() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.variablePointersStorageBuffer) 
	return *ptr
}

// WithVariablePointersStorageBuffer sets the value for the VariablePointersStorageBuffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVariablePointersFeatures) WithVariablePointersStorageBuffer(y Bool32) PhysicalDeviceVariablePointersFeatures {
	x.variablePointersStorageBuffer = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// VariablePointers returns the value of variablePointers from VkPhysicalDeviceVariablePointersFeatures
func (x PhysicalDeviceVariablePointersFeatures) VariablePointers() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.variablePointers) 
	return *ptr
}

// WithVariablePointers sets the value for the VariablePointers on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVariablePointersFeatures) WithVariablePointers(y Bool32) PhysicalDeviceVariablePointersFeatures {
	x.variablePointers = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// MemoryDedicatedRequirements provides a go interface for VkMemoryDedicatedRequirements.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryDedicatedRequirements.html
type MemoryDedicatedRequirements C.struct_VkMemoryDedicatedRequirements

// SizeofMemoryDedicatedRequirements is the memory size of a MemoryDedicatedRequirements
var SizeofMemoryDedicatedRequirements int = int(unsafe.Sizeof(MemoryDedicatedRequirements{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryDedicatedRequirements) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryDedicatedRequirements) AsCPtr() *MemoryDedicatedRequirements {
	clone := (*MemoryDedicatedRequirements)(newCBlock(C.ulong(SizeofMemoryDedicatedRequirements)))
	*clone = x
	return clone
}

// MemoryDedicatedRequirementsFreeCSlice releases the memory allocated by MemoryDedicatedRequirementsMakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryDedicatedRequirementsFreeCSlice(x []MemoryDedicatedRequirements) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryDedicatedRequirementsMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryDedicatedRequirementsFreeCSlice must be called on the returned slice.
func MemoryDedicatedRequirementsMakeCSlice(x ...MemoryDedicatedRequirements) []MemoryDedicatedRequirements {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryDedicatedRequirements * len(x)
	dst := unsafe.Slice((*MemoryDedicatedRequirements)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkMemoryDedicatedRequirements
func (x MemoryDedicatedRequirements) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x MemoryDedicatedRequirements) WithDefaultSType() MemoryDedicatedRequirements {
	return x.WithSType(VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryDedicatedRequirements) WithSType(y StructureType) MemoryDedicatedRequirements {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkMemoryDedicatedRequirements
func (x MemoryDedicatedRequirements) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryDedicatedRequirements) WithPNext(y unsafe.Pointer) MemoryDedicatedRequirements {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// PrefersDedicatedAllocation returns the value of prefersDedicatedAllocation from VkMemoryDedicatedRequirements
func (x MemoryDedicatedRequirements) PrefersDedicatedAllocation() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.prefersDedicatedAllocation) 
	return *ptr
}

// RequiresDedicatedAllocation returns the value of requiresDedicatedAllocation from VkMemoryDedicatedRequirements
func (x MemoryDedicatedRequirements) RequiresDedicatedAllocation() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.requiresDedicatedAllocation) 
	return *ptr
}

// ExternalMemoryBufferCreateInfo provides a go interface for VkExternalMemoryBufferCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalMemoryBufferCreateInfo.html
type ExternalMemoryBufferCreateInfo C.struct_VkExternalMemoryBufferCreateInfo

// SizeofExternalMemoryBufferCreateInfo is the memory size of a ExternalMemoryBufferCreateInfo
var SizeofExternalMemoryBufferCreateInfo int = int(unsafe.Sizeof(ExternalMemoryBufferCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExternalMemoryBufferCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExternalMemoryBufferCreateInfo) AsCPtr() *ExternalMemoryBufferCreateInfo {
	clone := (*ExternalMemoryBufferCreateInfo)(newCBlock(C.ulong(SizeofExternalMemoryBufferCreateInfo)))
	*clone = x
	return clone
}

// ExternalMemoryBufferCreateInfoFreeCSlice releases the memory allocated by ExternalMemoryBufferCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ExternalMemoryBufferCreateInfoFreeCSlice(x []ExternalMemoryBufferCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExternalMemoryBufferCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExternalMemoryBufferCreateInfoFreeCSlice must be called on the returned slice.
func ExternalMemoryBufferCreateInfoMakeCSlice(x ...ExternalMemoryBufferCreateInfo) []ExternalMemoryBufferCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalMemoryBufferCreateInfo * len(x)
	dst := unsafe.Slice((*ExternalMemoryBufferCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkExternalMemoryBufferCreateInfo
func (x ExternalMemoryBufferCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ExternalMemoryBufferCreateInfo) WithDefaultSType() ExternalMemoryBufferCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalMemoryBufferCreateInfo) WithSType(y StructureType) ExternalMemoryBufferCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkExternalMemoryBufferCreateInfo
func (x ExternalMemoryBufferCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalMemoryBufferCreateInfo) WithPNext(y unsafe.Pointer) ExternalMemoryBufferCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// HandleTypes returns the value of handleTypes from VkExternalMemoryBufferCreateInfo
func (x ExternalMemoryBufferCreateInfo) HandleTypes() ExternalMemoryHandleTypeFlags {
	ptr := /* typedef */ (*ExternalMemoryHandleTypeFlags)(&x.handleTypes) 
	return *ptr
}

// WithHandleTypes sets the value for the HandleTypes on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalMemoryBufferCreateInfo) WithHandleTypes(y ExternalMemoryHandleTypeFlags) ExternalMemoryBufferCreateInfo {
	x.handleTypes = *(/* typedef */ (*C.VkExternalMemoryHandleTypeFlags)(&y))
	return x
}

// ExternalMemoryImageCreateInfo provides a go interface for VkExternalMemoryImageCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalMemoryImageCreateInfo.html
type ExternalMemoryImageCreateInfo C.struct_VkExternalMemoryImageCreateInfo

// SizeofExternalMemoryImageCreateInfo is the memory size of a ExternalMemoryImageCreateInfo
var SizeofExternalMemoryImageCreateInfo int = int(unsafe.Sizeof(ExternalMemoryImageCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExternalMemoryImageCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExternalMemoryImageCreateInfo) AsCPtr() *ExternalMemoryImageCreateInfo {
	clone := (*ExternalMemoryImageCreateInfo)(newCBlock(C.ulong(SizeofExternalMemoryImageCreateInfo)))
	*clone = x
	return clone
}

// ExternalMemoryImageCreateInfoFreeCSlice releases the memory allocated by ExternalMemoryImageCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ExternalMemoryImageCreateInfoFreeCSlice(x []ExternalMemoryImageCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExternalMemoryImageCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExternalMemoryImageCreateInfoFreeCSlice must be called on the returned slice.
func ExternalMemoryImageCreateInfoMakeCSlice(x ...ExternalMemoryImageCreateInfo) []ExternalMemoryImageCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalMemoryImageCreateInfo * len(x)
	dst := unsafe.Slice((*ExternalMemoryImageCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkExternalMemoryImageCreateInfo
func (x ExternalMemoryImageCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ExternalMemoryImageCreateInfo) WithDefaultSType() ExternalMemoryImageCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalMemoryImageCreateInfo) WithSType(y StructureType) ExternalMemoryImageCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkExternalMemoryImageCreateInfo
func (x ExternalMemoryImageCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalMemoryImageCreateInfo) WithPNext(y unsafe.Pointer) ExternalMemoryImageCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// HandleTypes returns the value of handleTypes from VkExternalMemoryImageCreateInfo
func (x ExternalMemoryImageCreateInfo) HandleTypes() ExternalMemoryHandleTypeFlags {
	ptr := /* typedef */ (*ExternalMemoryHandleTypeFlags)(&x.handleTypes) 
	return *ptr
}

// WithHandleTypes sets the value for the HandleTypes on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalMemoryImageCreateInfo) WithHandleTypes(y ExternalMemoryHandleTypeFlags) ExternalMemoryImageCreateInfo {
	x.handleTypes = *(/* typedef */ (*C.VkExternalMemoryHandleTypeFlags)(&y))
	return x
}

// PhysicalDeviceIDProperties provides a go interface for VkPhysicalDeviceIDProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceIDProperties.html
type PhysicalDeviceIDProperties C.struct_VkPhysicalDeviceIDProperties

// SizeofPhysicalDeviceIDProperties is the memory size of a PhysicalDeviceIDProperties
var SizeofPhysicalDeviceIDProperties int = int(unsafe.Sizeof(PhysicalDeviceIDProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceIDProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceIDProperties) AsCPtr() *PhysicalDeviceIDProperties {
	clone := (*PhysicalDeviceIDProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceIDProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceIDPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceIDPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceIDPropertiesFreeCSlice(x []PhysicalDeviceIDProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceIDPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceIDPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceIDPropertiesMakeCSlice(x ...PhysicalDeviceIDProperties) []PhysicalDeviceIDProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceIDProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceIDProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceIDProperties
func (x PhysicalDeviceIDProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceIDProperties) WithDefaultSType() PhysicalDeviceIDProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceIDProperties) WithSType(y StructureType) PhysicalDeviceIDProperties {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceIDProperties
func (x PhysicalDeviceIDProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceIDProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceIDProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// DeviceUUID returns the value of deviceUUID from VkPhysicalDeviceIDProperties
func (x PhysicalDeviceIDProperties) DeviceUUID() []byte {
	ptr := func(x *[VK_UUID_SIZE]C.uint8_t) *[]byte { /* Array */ slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_UUID_SIZE); return &slc }(&x.deviceUUID) 
	return *ptr
}

// DriverUUID returns the value of driverUUID from VkPhysicalDeviceIDProperties
func (x PhysicalDeviceIDProperties) DriverUUID() []byte {
	ptr := func(x *[VK_UUID_SIZE]C.uint8_t) *[]byte { /* Array */ slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_UUID_SIZE); return &slc }(&x.driverUUID) 
	return *ptr
}

// DeviceLUID returns the value of deviceLUID from VkPhysicalDeviceIDProperties
func (x PhysicalDeviceIDProperties) DeviceLUID() []byte {
	ptr := func(x *[VK_LUID_SIZE]C.uint8_t) *[]byte { /* Array */ slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_LUID_SIZE); return &slc }(&x.deviceLUID) 
	return *ptr
}

// DeviceNodeMask returns the value of deviceNodeMask from VkPhysicalDeviceIDProperties
func (x PhysicalDeviceIDProperties) DeviceNodeMask() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.deviceNodeMask) 
	return *ptr
}

// DeviceLUIDValid returns the value of deviceLUIDValid from VkPhysicalDeviceIDProperties
func (x PhysicalDeviceIDProperties) DeviceLUIDValid() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.deviceLUIDValid) 
	return *ptr
}

// PhysicalDevice16BitStorageFeatures provides a go interface for VkPhysicalDevice16BitStorageFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice16BitStorageFeatures.html
type PhysicalDevice16BitStorageFeatures C.struct_VkPhysicalDevice16BitStorageFeatures

// SizeofPhysicalDevice16BitStorageFeatures is the memory size of a PhysicalDevice16BitStorageFeatures
var SizeofPhysicalDevice16BitStorageFeatures int = int(unsafe.Sizeof(PhysicalDevice16BitStorageFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDevice16BitStorageFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDevice16BitStorageFeatures) AsCPtr() *PhysicalDevice16BitStorageFeatures {
	clone := (*PhysicalDevice16BitStorageFeatures)(newCBlock(C.ulong(SizeofPhysicalDevice16BitStorageFeatures)))
	*clone = x
	return clone
}

// PhysicalDevice16BitStorageFeaturesFreeCSlice releases the memory allocated by PhysicalDevice16BitStorageFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDevice16BitStorageFeaturesFreeCSlice(x []PhysicalDevice16BitStorageFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDevice16BitStorageFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDevice16BitStorageFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDevice16BitStorageFeaturesMakeCSlice(x ...PhysicalDevice16BitStorageFeatures) []PhysicalDevice16BitStorageFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDevice16BitStorageFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDevice16BitStorageFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDevice16BitStorageFeatures
func (x PhysicalDevice16BitStorageFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDevice16BitStorageFeatures) WithDefaultSType() PhysicalDevice16BitStorageFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice16BitStorageFeatures) WithSType(y StructureType) PhysicalDevice16BitStorageFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDevice16BitStorageFeatures
func (x PhysicalDevice16BitStorageFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice16BitStorageFeatures) WithPNext(y unsafe.Pointer) PhysicalDevice16BitStorageFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// StorageBuffer16BitAccess returns the value of storageBuffer16BitAccess from VkPhysicalDevice16BitStorageFeatures
func (x PhysicalDevice16BitStorageFeatures) StorageBuffer16BitAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storageBuffer16BitAccess) 
	return *ptr
}

// WithStorageBuffer16BitAccess sets the value for the StorageBuffer16BitAccess on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice16BitStorageFeatures) WithStorageBuffer16BitAccess(y Bool32) PhysicalDevice16BitStorageFeatures {
	x.storageBuffer16BitAccess = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// UniformAndStorageBuffer16BitAccess returns the value of uniformAndStorageBuffer16BitAccess from VkPhysicalDevice16BitStorageFeatures
func (x PhysicalDevice16BitStorageFeatures) UniformAndStorageBuffer16BitAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.uniformAndStorageBuffer16BitAccess) 
	return *ptr
}

// WithUniformAndStorageBuffer16BitAccess sets the value for the UniformAndStorageBuffer16BitAccess on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice16BitStorageFeatures) WithUniformAndStorageBuffer16BitAccess(y Bool32) PhysicalDevice16BitStorageFeatures {
	x.uniformAndStorageBuffer16BitAccess = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// StoragePushConstant16 returns the value of storagePushConstant16 from VkPhysicalDevice16BitStorageFeatures
func (x PhysicalDevice16BitStorageFeatures) StoragePushConstant16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storagePushConstant16) 
	return *ptr
}

// WithStoragePushConstant16 sets the value for the StoragePushConstant16 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice16BitStorageFeatures) WithStoragePushConstant16(y Bool32) PhysicalDevice16BitStorageFeatures {
	x.storagePushConstant16 = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// StorageInputOutput16 returns the value of storageInputOutput16 from VkPhysicalDevice16BitStorageFeatures
func (x PhysicalDevice16BitStorageFeatures) StorageInputOutput16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storageInputOutput16) 
	return *ptr
}

// WithStorageInputOutput16 sets the value for the StorageInputOutput16 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice16BitStorageFeatures) WithStorageInputOutput16(y Bool32) PhysicalDevice16BitStorageFeatures {
	x.storageInputOutput16 = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// BindImageMemoryInfo provides a go interface for VkBindImageMemoryInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindImageMemoryInfo.html
type BindImageMemoryInfo C.struct_VkBindImageMemoryInfo

// SizeofBindImageMemoryInfo is the memory size of a BindImageMemoryInfo
var SizeofBindImageMemoryInfo int = int(unsafe.Sizeof(BindImageMemoryInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BindImageMemoryInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BindImageMemoryInfo) AsCPtr() *BindImageMemoryInfo {
	clone := (*BindImageMemoryInfo)(newCBlock(C.ulong(SizeofBindImageMemoryInfo)))
	*clone = x
	return clone
}

// BindImageMemoryInfoFreeCSlice releases the memory allocated by BindImageMemoryInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BindImageMemoryInfoFreeCSlice(x []BindImageMemoryInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BindImageMemoryInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BindImageMemoryInfoFreeCSlice must be called on the returned slice.
func BindImageMemoryInfoMakeCSlice(x ...BindImageMemoryInfo) []BindImageMemoryInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindImageMemoryInfo * len(x)
	dst := unsafe.Slice((*BindImageMemoryInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBindImageMemoryInfo
func (x BindImageMemoryInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BindImageMemoryInfo) WithDefaultSType() BindImageMemoryInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemoryInfo) WithSType(y StructureType) BindImageMemoryInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkBindImageMemoryInfo
func (x BindImageMemoryInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemoryInfo) WithPNext(y unsafe.Pointer) BindImageMemoryInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Image returns the value of image from VkBindImageMemoryInfo
func (x BindImageMemoryInfo) Image() Image {
	ptr := /* handle */ (*Image)(&x.image) 
	return *ptr
}

// WithImage sets the value for the Image on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemoryInfo) WithImage(y Image) BindImageMemoryInfo {
	x.image = *(/* handle */ (*C.VkImage)(&y))
	return x
}

// Memory returns the value of memory from VkBindImageMemoryInfo
func (x BindImageMemoryInfo) Memory() DeviceMemory {
	ptr := /* handle */ (*DeviceMemory)(&x.memory) 
	return *ptr
}

// WithMemory sets the value for the Memory on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemoryInfo) WithMemory(y DeviceMemory) BindImageMemoryInfo {
	x.memory = *(/* handle */ (*C.VkDeviceMemory)(&y))
	return x
}

// MemoryOffset returns the value of memoryOffset from VkBindImageMemoryInfo
func (x BindImageMemoryInfo) MemoryOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.memoryOffset) 
	return *ptr
}

// WithMemoryOffset sets the value for the MemoryOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemoryInfo) WithMemoryOffset(y DeviceSize) BindImageMemoryInfo {
	x.memoryOffset = *(/* typedef */ (*C.VkDeviceSize)(&y))
	return x
}

// BindBufferMemoryInfo provides a go interface for VkBindBufferMemoryInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindBufferMemoryInfo.html
type BindBufferMemoryInfo C.struct_VkBindBufferMemoryInfo

// SizeofBindBufferMemoryInfo is the memory size of a BindBufferMemoryInfo
var SizeofBindBufferMemoryInfo int = int(unsafe.Sizeof(BindBufferMemoryInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BindBufferMemoryInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BindBufferMemoryInfo) AsCPtr() *BindBufferMemoryInfo {
	clone := (*BindBufferMemoryInfo)(newCBlock(C.ulong(SizeofBindBufferMemoryInfo)))
	*clone = x
	return clone
}

// BindBufferMemoryInfoFreeCSlice releases the memory allocated by BindBufferMemoryInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BindBufferMemoryInfoFreeCSlice(x []BindBufferMemoryInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BindBufferMemoryInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BindBufferMemoryInfoFreeCSlice must be called on the returned slice.
func BindBufferMemoryInfoMakeCSlice(x ...BindBufferMemoryInfo) []BindBufferMemoryInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindBufferMemoryInfo * len(x)
	dst := unsafe.Slice((*BindBufferMemoryInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBindBufferMemoryInfo
func (x BindBufferMemoryInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BindBufferMemoryInfo) WithDefaultSType() BindBufferMemoryInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindBufferMemoryInfo) WithSType(y StructureType) BindBufferMemoryInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkBindBufferMemoryInfo
func (x BindBufferMemoryInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindBufferMemoryInfo) WithPNext(y unsafe.Pointer) BindBufferMemoryInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Buffer returns the value of buffer from VkBindBufferMemoryInfo
func (x BindBufferMemoryInfo) Buffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.buffer) 
	return *ptr
}

// WithBuffer sets the value for the Buffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindBufferMemoryInfo) WithBuffer(y Buffer) BindBufferMemoryInfo {
	x.buffer = *(/* handle */ (*C.VkBuffer)(&y))
	return x
}

// Memory returns the value of memory from VkBindBufferMemoryInfo
func (x BindBufferMemoryInfo) Memory() DeviceMemory {
	ptr := /* handle */ (*DeviceMemory)(&x.memory) 
	return *ptr
}

// WithMemory sets the value for the Memory on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindBufferMemoryInfo) WithMemory(y DeviceMemory) BindBufferMemoryInfo {
	x.memory = *(/* handle */ (*C.VkDeviceMemory)(&y))
	return x
}

// MemoryOffset returns the value of memoryOffset from VkBindBufferMemoryInfo
func (x BindBufferMemoryInfo) MemoryOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.memoryOffset) 
	return *ptr
}

// WithMemoryOffset sets the value for the MemoryOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindBufferMemoryInfo) WithMemoryOffset(y DeviceSize) BindBufferMemoryInfo {
	x.memoryOffset = *(/* typedef */ (*C.VkDeviceSize)(&y))
	return x
}

// DescriptorUpdateTemplateEntry provides a go interface for VkDescriptorUpdateTemplateEntry.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorUpdateTemplateEntry.html
type DescriptorUpdateTemplateEntry C.struct_VkDescriptorUpdateTemplateEntry

// SizeofDescriptorUpdateTemplateEntry is the memory size of a DescriptorUpdateTemplateEntry
var SizeofDescriptorUpdateTemplateEntry int = int(unsafe.Sizeof(DescriptorUpdateTemplateEntry{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorUpdateTemplateEntry) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorUpdateTemplateEntry) AsCPtr() *DescriptorUpdateTemplateEntry {
	clone := (*DescriptorUpdateTemplateEntry)(newCBlock(C.ulong(SizeofDescriptorUpdateTemplateEntry)))
	*clone = x
	return clone
}

// DescriptorUpdateTemplateEntryFreeCSlice releases the memory allocated by DescriptorUpdateTemplateEntryMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorUpdateTemplateEntryFreeCSlice(x []DescriptorUpdateTemplateEntry) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorUpdateTemplateEntryMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorUpdateTemplateEntryFreeCSlice must be called on the returned slice.
func DescriptorUpdateTemplateEntryMakeCSlice(x ...DescriptorUpdateTemplateEntry) []DescriptorUpdateTemplateEntry {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorUpdateTemplateEntry * len(x)
	dst := unsafe.Slice((*DescriptorUpdateTemplateEntry)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// DstBinding returns the value of dstBinding from VkDescriptorUpdateTemplateEntry
func (x DescriptorUpdateTemplateEntry) DstBinding() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dstBinding) 
	return *ptr
}

// WithDstBinding sets the value for the DstBinding on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateEntry) WithDstBinding(y uint32) DescriptorUpdateTemplateEntry {
	x.dstBinding = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// DstArrayElement returns the value of dstArrayElement from VkDescriptorUpdateTemplateEntry
func (x DescriptorUpdateTemplateEntry) DstArrayElement() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dstArrayElement) 
	return *ptr
}

// WithDstArrayElement sets the value for the DstArrayElement on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateEntry) WithDstArrayElement(y uint32) DescriptorUpdateTemplateEntry {
	x.dstArrayElement = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// DescriptorCount returns the value of descriptorCount from VkDescriptorUpdateTemplateEntry
func (x DescriptorUpdateTemplateEntry) DescriptorCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.descriptorCount) 
	return *ptr
}

// WithDescriptorCount sets the value for the DescriptorCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateEntry) WithDescriptorCount(y uint32) DescriptorUpdateTemplateEntry {
	x.descriptorCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// DescriptorType returns the value of descriptorType from VkDescriptorUpdateTemplateEntry
func (x DescriptorUpdateTemplateEntry) DescriptorType() DescriptorType {
	ptr := /* typedef */ (*DescriptorType)(&x.descriptorType) 
	return *ptr
}

// WithDescriptorType sets the value for the DescriptorType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateEntry) WithDescriptorType(y DescriptorType) DescriptorUpdateTemplateEntry {
	x.descriptorType = *(/* typedef */ (*C.VkDescriptorType)(&y))
	return x
}

// Offset returns the value of offset from VkDescriptorUpdateTemplateEntry
func (x DescriptorUpdateTemplateEntry) Offset() uint64 {
	ptr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.offset) 
	return *ptr
}

// WithOffset sets the value for the Offset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateEntry) WithOffset(y uint64) DescriptorUpdateTemplateEntry {
	x.offset = *(func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&y))
	return x
}

// Stride returns the value of stride from VkDescriptorUpdateTemplateEntry
func (x DescriptorUpdateTemplateEntry) Stride() uint64 {
	ptr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.stride) 
	return *ptr
}

// WithStride sets the value for the Stride on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateEntry) WithStride(y uint64) DescriptorUpdateTemplateEntry {
	x.stride = *(func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&y))
	return x
}

// DescriptorUpdateTemplateCreateInfo provides a go interface for VkDescriptorUpdateTemplateCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorUpdateTemplateCreateInfo.html
type DescriptorUpdateTemplateCreateInfo C.struct_VkDescriptorUpdateTemplateCreateInfo

// SizeofDescriptorUpdateTemplateCreateInfo is the memory size of a DescriptorUpdateTemplateCreateInfo
var SizeofDescriptorUpdateTemplateCreateInfo int = int(unsafe.Sizeof(DescriptorUpdateTemplateCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorUpdateTemplateCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorUpdateTemplateCreateInfo) AsCPtr() *DescriptorUpdateTemplateCreateInfo {
	clone := (*DescriptorUpdateTemplateCreateInfo)(newCBlock(C.ulong(SizeofDescriptorUpdateTemplateCreateInfo)))
	*clone = x
	return clone
}

// DescriptorUpdateTemplateCreateInfoFreeCSlice releases the memory allocated by DescriptorUpdateTemplateCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorUpdateTemplateCreateInfoFreeCSlice(x []DescriptorUpdateTemplateCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorUpdateTemplateCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorUpdateTemplateCreateInfoFreeCSlice must be called on the returned slice.
func DescriptorUpdateTemplateCreateInfoMakeCSlice(x ...DescriptorUpdateTemplateCreateInfo) []DescriptorUpdateTemplateCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorUpdateTemplateCreateInfo * len(x)
	dst := unsafe.Slice((*DescriptorUpdateTemplateCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DescriptorUpdateTemplateCreateInfo) WithDefaultSType() DescriptorUpdateTemplateCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateCreateInfo) WithSType(y StructureType) DescriptorUpdateTemplateCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateCreateInfo) WithPNext(y unsafe.Pointer) DescriptorUpdateTemplateCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) Flags() DescriptorUpdateTemplateCreateFlags {
	ptr := /* typedef */ (*DescriptorUpdateTemplateCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateCreateInfo) WithFlags(y DescriptorUpdateTemplateCreateFlags) DescriptorUpdateTemplateCreateInfo {
	x.flags = *(/* typedef */ (*C.VkDescriptorUpdateTemplateCreateFlags)(&y))
	return x
}

// DescriptorUpdateEntryCount returns the value of descriptorUpdateEntryCount from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) DescriptorUpdateEntryCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.descriptorUpdateEntryCount) 
	return *ptr
}

// WithDescriptorUpdateEntryCount sets the value for the DescriptorUpdateEntryCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateCreateInfo) WithDescriptorUpdateEntryCount(y uint32) DescriptorUpdateTemplateCreateInfo {
	x.descriptorUpdateEntryCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PDescriptorUpdateEntries returns the value of pDescriptorUpdateEntries from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) PDescriptorUpdateEntries() []DescriptorUpdateTemplateEntry {
	ptr := func(x **C.struct_VkDescriptorUpdateTemplateEntry) *[]DescriptorUpdateTemplateEntry { /* Slice */ slc := unsafe.Slice((*DescriptorUpdateTemplateEntry)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pDescriptorUpdateEntries) 
	return *ptr
}

// WithPDescriptorUpdateEntries sets the value for the PDescriptorUpdateEntries on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines DescriptorUpdateEntryCount as the length of this field.
// DescriptorUpdateEntryCount is updated with the length of the new value.
func (x DescriptorUpdateTemplateCreateInfo) WithPDescriptorUpdateEntries(y []DescriptorUpdateTemplateEntry) DescriptorUpdateTemplateCreateInfo {
	x.pDescriptorUpdateEntries = *(func(x *[]DescriptorUpdateTemplateEntry) **C.struct_VkDescriptorUpdateTemplateEntry { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkDescriptorUpdateTemplateEntry)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkDescriptorUpdateTemplateEntry)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithDescriptorUpdateEntryCount(uint32(len(y)))
}

// TemplateType returns the value of templateType from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) TemplateType() DescriptorUpdateTemplateType {
	ptr := /* typedef */ (*DescriptorUpdateTemplateType)(&x.templateType) 
	return *ptr
}

// WithTemplateType sets the value for the TemplateType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateCreateInfo) WithTemplateType(y DescriptorUpdateTemplateType) DescriptorUpdateTemplateCreateInfo {
	x.templateType = *(/* typedef */ (*C.VkDescriptorUpdateTemplateType)(&y))
	return x
}

// DescriptorSetLayout returns the value of descriptorSetLayout from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) DescriptorSetLayout() DescriptorSetLayout {
	ptr := /* handle */ (*DescriptorSetLayout)(&x.descriptorSetLayout) 
	return *ptr
}

// WithDescriptorSetLayout sets the value for the DescriptorSetLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateCreateInfo) WithDescriptorSetLayout(y DescriptorSetLayout) DescriptorUpdateTemplateCreateInfo {
	x.descriptorSetLayout = *(/* handle */ (*C.VkDescriptorSetLayout)(&y))
	return x
}

// PipelineBindPoint returns the value of pipelineBindPoint from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) PipelineBindPoint() PipelineBindPoint {
	ptr := /* typedef */ (*PipelineBindPoint)(&x.pipelineBindPoint) 
	return *ptr
}

// WithPipelineBindPoint sets the value for the PipelineBindPoint on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateCreateInfo) WithPipelineBindPoint(y PipelineBindPoint) DescriptorUpdateTemplateCreateInfo {
	x.pipelineBindPoint = *(/* typedef */ (*C.VkPipelineBindPoint)(&y))
	return x
}

// PipelineLayout returns the value of pipelineLayout from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) PipelineLayout() PipelineLayout {
	ptr := /* handle */ (*PipelineLayout)(&x.pipelineLayout) 
	return *ptr
}

// WithPipelineLayout sets the value for the PipelineLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateCreateInfo) WithPipelineLayout(y PipelineLayout) DescriptorUpdateTemplateCreateInfo {
	x.pipelineLayout = *(/* handle */ (*C.VkPipelineLayout)(&y))
	return x
}

// Set returns the value of set from VkDescriptorUpdateTemplateCreateInfo
func (x DescriptorUpdateTemplateCreateInfo) Set() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.set) 
	return *ptr
}

// WithSet sets the value for the Set on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorUpdateTemplateCreateInfo) WithSet(y uint32) DescriptorUpdateTemplateCreateInfo {
	x.set = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// ExternalBufferProperties provides a go interface for VkExternalBufferProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalBufferProperties.html
type ExternalBufferProperties C.struct_VkExternalBufferProperties

// SizeofExternalBufferProperties is the memory size of a ExternalBufferProperties
var SizeofExternalBufferProperties int = int(unsafe.Sizeof(ExternalBufferProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExternalBufferProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExternalBufferProperties) AsCPtr() *ExternalBufferProperties {
	clone := (*ExternalBufferProperties)(newCBlock(C.ulong(SizeofExternalBufferProperties)))
	*clone = x
	return clone
}

// ExternalBufferPropertiesFreeCSlice releases the memory allocated by ExternalBufferPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func ExternalBufferPropertiesFreeCSlice(x []ExternalBufferProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExternalBufferPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExternalBufferPropertiesFreeCSlice must be called on the returned slice.
func ExternalBufferPropertiesMakeCSlice(x ...ExternalBufferProperties) []ExternalBufferProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalBufferProperties * len(x)
	dst := unsafe.Slice((*ExternalBufferProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkExternalBufferProperties
func (x ExternalBufferProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ExternalBufferProperties) WithDefaultSType() ExternalBufferProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalBufferProperties) WithSType(y StructureType) ExternalBufferProperties {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkExternalBufferProperties
func (x ExternalBufferProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalBufferProperties) WithPNext(y unsafe.Pointer) ExternalBufferProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// ExternalMemoryProperties returns the value of externalMemoryProperties from VkExternalBufferProperties
func (x ExternalBufferProperties) ExternalMemoryProperties() ExternalMemoryProperties {
	ptr := /* typedef */ (*ExternalMemoryProperties)(&x.externalMemoryProperties) 
	return *ptr
}

// PhysicalDeviceMaintenance3Properties provides a go interface for VkPhysicalDeviceMaintenance3Properties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance3Properties.html
type PhysicalDeviceMaintenance3Properties C.struct_VkPhysicalDeviceMaintenance3Properties

// SizeofPhysicalDeviceMaintenance3Properties is the memory size of a PhysicalDeviceMaintenance3Properties
var SizeofPhysicalDeviceMaintenance3Properties int = int(unsafe.Sizeof(PhysicalDeviceMaintenance3Properties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceMaintenance3Properties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceMaintenance3Properties) AsCPtr() *PhysicalDeviceMaintenance3Properties {
	clone := (*PhysicalDeviceMaintenance3Properties)(newCBlock(C.ulong(SizeofPhysicalDeviceMaintenance3Properties)))
	*clone = x
	return clone
}

// PhysicalDeviceMaintenance3PropertiesFreeCSlice releases the memory allocated by PhysicalDeviceMaintenance3PropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceMaintenance3PropertiesFreeCSlice(x []PhysicalDeviceMaintenance3Properties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceMaintenance3PropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceMaintenance3PropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceMaintenance3PropertiesMakeCSlice(x ...PhysicalDeviceMaintenance3Properties) []PhysicalDeviceMaintenance3Properties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceMaintenance3Properties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceMaintenance3Properties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceMaintenance3Properties
func (x PhysicalDeviceMaintenance3Properties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceMaintenance3Properties) WithDefaultSType() PhysicalDeviceMaintenance3Properties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMaintenance3Properties) WithSType(y StructureType) PhysicalDeviceMaintenance3Properties {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceMaintenance3Properties
func (x PhysicalDeviceMaintenance3Properties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMaintenance3Properties) WithPNext(y unsafe.Pointer) PhysicalDeviceMaintenance3Properties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// MaxPerSetDescriptors returns the value of maxPerSetDescriptors from VkPhysicalDeviceMaintenance3Properties
func (x PhysicalDeviceMaintenance3Properties) MaxPerSetDescriptors() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerSetDescriptors) 
	return *ptr
}

// MaxMemoryAllocationSize returns the value of maxMemoryAllocationSize from VkPhysicalDeviceMaintenance3Properties
func (x PhysicalDeviceMaintenance3Properties) MaxMemoryAllocationSize() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.maxMemoryAllocationSize) 
	return *ptr
}

// DescriptorSetLayoutSupport provides a go interface for VkDescriptorSetLayoutSupport.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutSupport.html
type DescriptorSetLayoutSupport C.struct_VkDescriptorSetLayoutSupport

// SizeofDescriptorSetLayoutSupport is the memory size of a DescriptorSetLayoutSupport
var SizeofDescriptorSetLayoutSupport int = int(unsafe.Sizeof(DescriptorSetLayoutSupport{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorSetLayoutSupport) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorSetLayoutSupport) AsCPtr() *DescriptorSetLayoutSupport {
	clone := (*DescriptorSetLayoutSupport)(newCBlock(C.ulong(SizeofDescriptorSetLayoutSupport)))
	*clone = x
	return clone
}

// DescriptorSetLayoutSupportFreeCSlice releases the memory allocated by DescriptorSetLayoutSupportMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorSetLayoutSupportFreeCSlice(x []DescriptorSetLayoutSupport) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorSetLayoutSupportMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorSetLayoutSupportFreeCSlice must be called on the returned slice.
func DescriptorSetLayoutSupportMakeCSlice(x ...DescriptorSetLayoutSupport) []DescriptorSetLayoutSupport {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetLayoutSupport * len(x)
	dst := unsafe.Slice((*DescriptorSetLayoutSupport)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDescriptorSetLayoutSupport
func (x DescriptorSetLayoutSupport) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DescriptorSetLayoutSupport) WithDefaultSType() DescriptorSetLayoutSupport {
	return x.WithSType(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutSupport) WithSType(y StructureType) DescriptorSetLayoutSupport {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDescriptorSetLayoutSupport
func (x DescriptorSetLayoutSupport) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutSupport) WithPNext(y unsafe.Pointer) DescriptorSetLayoutSupport {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Supported returns the value of supported from VkDescriptorSetLayoutSupport
func (x DescriptorSetLayoutSupport) Supported() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.supported) 
	return *ptr
}

// PhysicalDeviceSubgroupProperties provides a go interface for VkPhysicalDeviceSubgroupProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubgroupProperties.html
type PhysicalDeviceSubgroupProperties C.struct_VkPhysicalDeviceSubgroupProperties

// SizeofPhysicalDeviceSubgroupProperties is the memory size of a PhysicalDeviceSubgroupProperties
var SizeofPhysicalDeviceSubgroupProperties int = int(unsafe.Sizeof(PhysicalDeviceSubgroupProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceSubgroupProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceSubgroupProperties) AsCPtr() *PhysicalDeviceSubgroupProperties {
	clone := (*PhysicalDeviceSubgroupProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceSubgroupProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceSubgroupPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceSubgroupPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceSubgroupPropertiesFreeCSlice(x []PhysicalDeviceSubgroupProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceSubgroupPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceSubgroupPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceSubgroupPropertiesMakeCSlice(x ...PhysicalDeviceSubgroupProperties) []PhysicalDeviceSubgroupProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSubgroupProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceSubgroupProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceSubgroupProperties
func (x PhysicalDeviceSubgroupProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceSubgroupProperties) WithDefaultSType() PhysicalDeviceSubgroupProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSubgroupProperties) WithSType(y StructureType) PhysicalDeviceSubgroupProperties {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceSubgroupProperties
func (x PhysicalDeviceSubgroupProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSubgroupProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceSubgroupProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SubgroupSize returns the value of subgroupSize from VkPhysicalDeviceSubgroupProperties
func (x PhysicalDeviceSubgroupProperties) SubgroupSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.subgroupSize) 
	return *ptr
}

// SupportedStages returns the value of supportedStages from VkPhysicalDeviceSubgroupProperties
func (x PhysicalDeviceSubgroupProperties) SupportedStages() ShaderStageFlags {
	ptr := /* typedef */ (*ShaderStageFlags)(&x.supportedStages) 
	return *ptr
}

// SupportedOperations returns the value of supportedOperations from VkPhysicalDeviceSubgroupProperties
func (x PhysicalDeviceSubgroupProperties) SupportedOperations() SubgroupFeatureFlags {
	ptr := /* typedef */ (*SubgroupFeatureFlags)(&x.supportedOperations) 
	return *ptr
}

// QuadOperationsInAllStages returns the value of quadOperationsInAllStages from VkPhysicalDeviceSubgroupProperties
func (x PhysicalDeviceSubgroupProperties) QuadOperationsInAllStages() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.quadOperationsInAllStages) 
	return *ptr
}

//PhysicalDeviceShaderDrawParameterFeatures is an alias to PhysicalDeviceShaderDrawParametersFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderDrawParameterFeatures.html
//
// Deprecated: Most Aliases in the Vulkan spec are for compatibility purposes as extensions get
// promoted to features. If possible, update code to use the promoted name: PhysicalDeviceShaderDrawParametersFeatures.
type PhysicalDeviceShaderDrawParameterFeatures = PhysicalDeviceShaderDrawParametersFeatures
// ExternalMemoryProperties provides a go interface for VkExternalMemoryProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalMemoryProperties.html
type ExternalMemoryProperties C.struct_VkExternalMemoryProperties

// SizeofExternalMemoryProperties is the memory size of a ExternalMemoryProperties
var SizeofExternalMemoryProperties int = int(unsafe.Sizeof(ExternalMemoryProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExternalMemoryProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExternalMemoryProperties) AsCPtr() *ExternalMemoryProperties {
	clone := (*ExternalMemoryProperties)(newCBlock(C.ulong(SizeofExternalMemoryProperties)))
	*clone = x
	return clone
}

// ExternalMemoryPropertiesFreeCSlice releases the memory allocated by ExternalMemoryPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func ExternalMemoryPropertiesFreeCSlice(x []ExternalMemoryProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExternalMemoryPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExternalMemoryPropertiesFreeCSlice must be called on the returned slice.
func ExternalMemoryPropertiesMakeCSlice(x ...ExternalMemoryProperties) []ExternalMemoryProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalMemoryProperties * len(x)
	dst := unsafe.Slice((*ExternalMemoryProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// ExternalMemoryFeatures returns the value of externalMemoryFeatures from VkExternalMemoryProperties
func (x ExternalMemoryProperties) ExternalMemoryFeatures() ExternalMemoryFeatureFlags {
	ptr := /* typedef */ (*ExternalMemoryFeatureFlags)(&x.externalMemoryFeatures) 
	return *ptr
}

// ExportFromImportedHandleTypes returns the value of exportFromImportedHandleTypes from VkExternalMemoryProperties
func (x ExternalMemoryProperties) ExportFromImportedHandleTypes() ExternalMemoryHandleTypeFlags {
	ptr := /* typedef */ (*ExternalMemoryHandleTypeFlags)(&x.exportFromImportedHandleTypes) 
	return *ptr
}

// CompatibleHandleTypes returns the value of compatibleHandleTypes from VkExternalMemoryProperties
func (x ExternalMemoryProperties) CompatibleHandleTypes() ExternalMemoryHandleTypeFlags {
	ptr := /* typedef */ (*ExternalMemoryHandleTypeFlags)(&x.compatibleHandleTypes) 
	return *ptr
}

// PhysicalDeviceExternalImageFormatInfo provides a go interface for VkPhysicalDeviceExternalImageFormatInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalImageFormatInfo.html
type PhysicalDeviceExternalImageFormatInfo C.struct_VkPhysicalDeviceExternalImageFormatInfo

// SizeofPhysicalDeviceExternalImageFormatInfo is the memory size of a PhysicalDeviceExternalImageFormatInfo
var SizeofPhysicalDeviceExternalImageFormatInfo int = int(unsafe.Sizeof(PhysicalDeviceExternalImageFormatInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceExternalImageFormatInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceExternalImageFormatInfo) AsCPtr() *PhysicalDeviceExternalImageFormatInfo {
	clone := (*PhysicalDeviceExternalImageFormatInfo)(newCBlock(C.ulong(SizeofPhysicalDeviceExternalImageFormatInfo)))
	*clone = x
	return clone
}

// PhysicalDeviceExternalImageFormatInfoFreeCSlice releases the memory allocated by PhysicalDeviceExternalImageFormatInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceExternalImageFormatInfoFreeCSlice(x []PhysicalDeviceExternalImageFormatInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceExternalImageFormatInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceExternalImageFormatInfoFreeCSlice must be called on the returned slice.
func PhysicalDeviceExternalImageFormatInfoMakeCSlice(x ...PhysicalDeviceExternalImageFormatInfo) []PhysicalDeviceExternalImageFormatInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceExternalImageFormatInfo * len(x)
	dst := unsafe.Slice((*PhysicalDeviceExternalImageFormatInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceExternalImageFormatInfo
func (x PhysicalDeviceExternalImageFormatInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceExternalImageFormatInfo) WithDefaultSType() PhysicalDeviceExternalImageFormatInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalImageFormatInfo) WithSType(y StructureType) PhysicalDeviceExternalImageFormatInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceExternalImageFormatInfo
func (x PhysicalDeviceExternalImageFormatInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalImageFormatInfo) WithPNext(y unsafe.Pointer) PhysicalDeviceExternalImageFormatInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// HandleType returns the value of handleType from VkPhysicalDeviceExternalImageFormatInfo
func (x PhysicalDeviceExternalImageFormatInfo) HandleType() ExternalMemoryHandleTypeFlagBits {
	ptr := /* typedef */ (*ExternalMemoryHandleTypeFlagBits)(&x.handleType) 
	return *ptr
}

// WithHandleType sets the value for the HandleType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalImageFormatInfo) WithHandleType(y ExternalMemoryHandleTypeFlagBits) PhysicalDeviceExternalImageFormatInfo {
	x.handleType = *(/* typedef */ (*C.VkExternalMemoryHandleTypeFlagBits)(&y))
	return x
}

// ExternalImageFormatProperties provides a go interface for VkExternalImageFormatProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkExternalImageFormatProperties.html
type ExternalImageFormatProperties C.struct_VkExternalImageFormatProperties

// SizeofExternalImageFormatProperties is the memory size of a ExternalImageFormatProperties
var SizeofExternalImageFormatProperties int = int(unsafe.Sizeof(ExternalImageFormatProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ExternalImageFormatProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ExternalImageFormatProperties) AsCPtr() *ExternalImageFormatProperties {
	clone := (*ExternalImageFormatProperties)(newCBlock(C.ulong(SizeofExternalImageFormatProperties)))
	*clone = x
	return clone
}

// ExternalImageFormatPropertiesFreeCSlice releases the memory allocated by ExternalImageFormatPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func ExternalImageFormatPropertiesFreeCSlice(x []ExternalImageFormatProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ExternalImageFormatPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ExternalImageFormatPropertiesFreeCSlice must be called on the returned slice.
func ExternalImageFormatPropertiesMakeCSlice(x ...ExternalImageFormatProperties) []ExternalImageFormatProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofExternalImageFormatProperties * len(x)
	dst := unsafe.Slice((*ExternalImageFormatProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkExternalImageFormatProperties
func (x ExternalImageFormatProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ExternalImageFormatProperties) WithDefaultSType() ExternalImageFormatProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalImageFormatProperties) WithSType(y StructureType) ExternalImageFormatProperties {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkExternalImageFormatProperties
func (x ExternalImageFormatProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ExternalImageFormatProperties) WithPNext(y unsafe.Pointer) ExternalImageFormatProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// ExternalMemoryProperties returns the value of externalMemoryProperties from VkExternalImageFormatProperties
func (x ExternalImageFormatProperties) ExternalMemoryProperties() ExternalMemoryProperties {
	ptr := /* typedef */ (*ExternalMemoryProperties)(&x.externalMemoryProperties) 
	return *ptr
}

// PhysicalDeviceExternalBufferInfo provides a go interface for VkPhysicalDeviceExternalBufferInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalBufferInfo.html
type PhysicalDeviceExternalBufferInfo C.struct_VkPhysicalDeviceExternalBufferInfo

// SizeofPhysicalDeviceExternalBufferInfo is the memory size of a PhysicalDeviceExternalBufferInfo
var SizeofPhysicalDeviceExternalBufferInfo int = int(unsafe.Sizeof(PhysicalDeviceExternalBufferInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceExternalBufferInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceExternalBufferInfo) AsCPtr() *PhysicalDeviceExternalBufferInfo {
	clone := (*PhysicalDeviceExternalBufferInfo)(newCBlock(C.ulong(SizeofPhysicalDeviceExternalBufferInfo)))
	*clone = x
	return clone
}

// PhysicalDeviceExternalBufferInfoFreeCSlice releases the memory allocated by PhysicalDeviceExternalBufferInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceExternalBufferInfoFreeCSlice(x []PhysicalDeviceExternalBufferInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceExternalBufferInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceExternalBufferInfoFreeCSlice must be called on the returned slice.
func PhysicalDeviceExternalBufferInfoMakeCSlice(x ...PhysicalDeviceExternalBufferInfo) []PhysicalDeviceExternalBufferInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceExternalBufferInfo * len(x)
	dst := unsafe.Slice((*PhysicalDeviceExternalBufferInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceExternalBufferInfo
func (x PhysicalDeviceExternalBufferInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceExternalBufferInfo) WithDefaultSType() PhysicalDeviceExternalBufferInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalBufferInfo) WithSType(y StructureType) PhysicalDeviceExternalBufferInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceExternalBufferInfo
func (x PhysicalDeviceExternalBufferInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalBufferInfo) WithPNext(y unsafe.Pointer) PhysicalDeviceExternalBufferInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkPhysicalDeviceExternalBufferInfo
func (x PhysicalDeviceExternalBufferInfo) Flags() BufferCreateFlags {
	ptr := /* typedef */ (*BufferCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalBufferInfo) WithFlags(y BufferCreateFlags) PhysicalDeviceExternalBufferInfo {
	x.flags = *(/* typedef */ (*C.VkBufferCreateFlags)(&y))
	return x
}

// Usage returns the value of usage from VkPhysicalDeviceExternalBufferInfo
func (x PhysicalDeviceExternalBufferInfo) Usage() BufferUsageFlags {
	ptr := /* typedef */ (*BufferUsageFlags)(&x.usage) 
	return *ptr
}

// WithUsage sets the value for the Usage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalBufferInfo) WithUsage(y BufferUsageFlags) PhysicalDeviceExternalBufferInfo {
	x.usage = *(/* typedef */ (*C.VkBufferUsageFlags)(&y))
	return x
}

// HandleType returns the value of handleType from VkPhysicalDeviceExternalBufferInfo
func (x PhysicalDeviceExternalBufferInfo) HandleType() ExternalMemoryHandleTypeFlagBits {
	ptr := /* typedef */ (*ExternalMemoryHandleTypeFlagBits)(&x.handleType) 
	return *ptr
}

// WithHandleType sets the value for the HandleType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceExternalBufferInfo) WithHandleType(y ExternalMemoryHandleTypeFlagBits) PhysicalDeviceExternalBufferInfo {
	x.handleType = *(/* typedef */ (*C.VkExternalMemoryHandleTypeFlagBits)(&y))
	return x
}

// PhysicalDeviceShaderDrawParametersFeatures provides a go interface for VkPhysicalDeviceShaderDrawParametersFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderDrawParametersFeatures.html
type PhysicalDeviceShaderDrawParametersFeatures C.struct_VkPhysicalDeviceShaderDrawParametersFeatures

// SizeofPhysicalDeviceShaderDrawParametersFeatures is the memory size of a PhysicalDeviceShaderDrawParametersFeatures
var SizeofPhysicalDeviceShaderDrawParametersFeatures int = int(unsafe.Sizeof(PhysicalDeviceShaderDrawParametersFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceShaderDrawParametersFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceShaderDrawParametersFeatures) AsCPtr() *PhysicalDeviceShaderDrawParametersFeatures {
	clone := (*PhysicalDeviceShaderDrawParametersFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceShaderDrawParametersFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceShaderDrawParametersFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceShaderDrawParametersFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceShaderDrawParametersFeaturesFreeCSlice(x []PhysicalDeviceShaderDrawParametersFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceShaderDrawParametersFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceShaderDrawParametersFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceShaderDrawParametersFeaturesMakeCSlice(x ...PhysicalDeviceShaderDrawParametersFeatures) []PhysicalDeviceShaderDrawParametersFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderDrawParametersFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceShaderDrawParametersFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceShaderDrawParametersFeatures
func (x PhysicalDeviceShaderDrawParametersFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceShaderDrawParametersFeatures) WithDefaultSType() PhysicalDeviceShaderDrawParametersFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderDrawParametersFeatures) WithSType(y StructureType) PhysicalDeviceShaderDrawParametersFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceShaderDrawParametersFeatures
func (x PhysicalDeviceShaderDrawParametersFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderDrawParametersFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceShaderDrawParametersFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// ShaderDrawParameters returns the value of shaderDrawParameters from VkPhysicalDeviceShaderDrawParametersFeatures
func (x PhysicalDeviceShaderDrawParametersFeatures) ShaderDrawParameters() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDrawParameters) 
	return *ptr
}

// WithShaderDrawParameters sets the value for the ShaderDrawParameters on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderDrawParametersFeatures) WithShaderDrawParameters(y Bool32) PhysicalDeviceShaderDrawParametersFeatures {
	x.shaderDrawParameters = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// UpdateDescriptorSetWithTemplate command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUpdateDescriptorSetWithTemplate.html
func (x DeviceFacade)UpdateDescriptorSetWithTemplate(descriptorSet DescriptorSet, descriptorUpdateTemplate DescriptorUpdateTemplate, pData unsafe.Pointer, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDescriptorSet)(&descriptorSet)
	p2 := /* handle */ (*C.VkDescriptorUpdateTemplate)(&descriptorUpdateTemplate)
	p3 := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&pData)
	C.vkUpdateDescriptorSetWithTemplate(addrs, *p0, *p1, *p2, *p3)
	}

// DestroySamplerYcbcrConversion command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySamplerYcbcrConversion.html
func (x DeviceFacade)DestroySamplerYcbcrConversion(ycbcrConversion SamplerYcbcrConversion, pAllocator *AllocationCallbacks, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkSamplerYcbcrConversion)(&ycbcrConversion)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	C.vkDestroySamplerYcbcrConversion(addrs, *p0, *p1, *p2)
	}

// CreateDescriptorUpdateTemplate command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDescriptorUpdateTemplate.html
func (x DeviceFacade)CreateDescriptorUpdateTemplate(pCreateInfo *DescriptorUpdateTemplateCreateInfo, pAllocator *AllocationCallbacks, pDescriptorUpdateTemplate *DescriptorUpdateTemplate, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DescriptorUpdateTemplateCreateInfo) **C.struct_VkDescriptorUpdateTemplateCreateInfo { /* Pointer */ g2c := (*C.struct_VkDescriptorUpdateTemplateCreateInfo)(*x); return &g2c }(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p3 := func(x **DescriptorUpdateTemplate) **C.VkDescriptorUpdateTemplate { /* Pointer */ g2c := (*C.VkDescriptorUpdateTemplate)(*x); return &g2c }(&pDescriptorUpdateTemplate)
	ret := C.vkCreateDescriptorUpdateTemplate(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceExternalFenceProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalFenceProperties.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceExternalFenceProperties(pExternalFenceInfo *PhysicalDeviceExternalFenceInfo, pExternalFenceProperties *ExternalFenceProperties, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceExternalFenceInfo) **C.struct_VkPhysicalDeviceExternalFenceInfo { /* Pointer */ g2c := (*C.struct_VkPhysicalDeviceExternalFenceInfo)(*x); return &g2c }(&pExternalFenceInfo)
	p2 := func(x **ExternalFenceProperties) **C.struct_VkExternalFenceProperties { /* Pointer */ g2c := (*C.struct_VkExternalFenceProperties)(*x); return &g2c }(&pExternalFenceProperties)
	C.vkGetPhysicalDeviceExternalFenceProperties(addrs, *p0, *p1, *p2)
	}

// CreateSamplerYcbcrConversion command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSamplerYcbcrConversion.html
func (x DeviceFacade)CreateSamplerYcbcrConversion(pCreateInfo *SamplerYcbcrConversionCreateInfo, pAllocator *AllocationCallbacks, pYcbcrConversion *SamplerYcbcrConversion, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **SamplerYcbcrConversionCreateInfo) **C.struct_VkSamplerYcbcrConversionCreateInfo { /* Pointer */ g2c := (*C.struct_VkSamplerYcbcrConversionCreateInfo)(*x); return &g2c }(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p3 := func(x **SamplerYcbcrConversion) **C.VkSamplerYcbcrConversion { /* Pointer */ g2c := (*C.VkSamplerYcbcrConversion)(*x); return &g2c }(&pYcbcrConversion)
	ret := C.vkCreateSamplerYcbcrConversion(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetDeviceQueue2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceQueue2.html
func (x DeviceFacade)GetDeviceQueue2(pQueueInfo *DeviceQueueInfo2, pQueue *Queue, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DeviceQueueInfo2) **C.struct_VkDeviceQueueInfo2 { /* Pointer */ g2c := (*C.struct_VkDeviceQueueInfo2)(*x); return &g2c }(&pQueueInfo)
	p2 := func(x **Queue) **C.VkQueue { /* Pointer */ g2c := (*C.VkQueue)(*x); return &g2c }(&pQueue)
	C.vkGetDeviceQueue2(addrs, *p0, *p1, *p2)
	}

// TrimCommandPool command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkTrimCommandPool.html
func (x DeviceFacade)TrimCommandPool(commandPool CommandPool, flags CommandPoolTrimFlags, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkCommandPool)(&commandPool)
	p2 := /* typedef */ (*C.VkCommandPoolTrimFlags)(&flags)
	C.vkTrimCommandPool(addrs, *p0, *p1, *p2)
	}

// GetPhysicalDeviceSparseImageFormatProperties2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSparseImageFormatProperties2.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceSparseImageFormatProperties2(pFormatInfo *PhysicalDeviceSparseImageFormatInfo2, pPropertyCount *uint32, pProperties []SparseImageFormatProperties2, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceSparseImageFormatInfo2) **C.struct_VkPhysicalDeviceSparseImageFormatInfo2 { /* Pointer */ g2c := (*C.struct_VkPhysicalDeviceSparseImageFormatInfo2)(*x); return &g2c }(&pFormatInfo)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPropertyCount)
	p3 := func(x *[]SparseImageFormatProperties2) **C.struct_VkSparseImageFormatProperties2 { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkSparseImageFormatProperties2)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkSparseImageFormatProperties2)(unsafe.Pointer((&ptr))) }(&pProperties)
	C.vkGetPhysicalDeviceSparseImageFormatProperties2(addrs, *p0, *p1, *p2, *p3)
	}

// GetPhysicalDeviceMemoryProperties2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceMemoryProperties2.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceMemoryProperties2(pMemoryProperties *PhysicalDeviceMemoryProperties2, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceMemoryProperties2) **C.struct_VkPhysicalDeviceMemoryProperties2 { /* Pointer */ g2c := (*C.struct_VkPhysicalDeviceMemoryProperties2)(*x); return &g2c }(&pMemoryProperties)
	C.vkGetPhysicalDeviceMemoryProperties2(addrs, *p0, *p1)
	}

// GetPhysicalDeviceQueueFamilyProperties2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceQueueFamilyProperties2.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceQueueFamilyProperties2(pQueueFamilyPropertyCount *uint32, pQueueFamilyProperties []QueueFamilyProperties2, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pQueueFamilyPropertyCount)
	p2 := func(x *[]QueueFamilyProperties2) **C.struct_VkQueueFamilyProperties2 { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkQueueFamilyProperties2)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkQueueFamilyProperties2)(unsafe.Pointer((&ptr))) }(&pQueueFamilyProperties)
	C.vkGetPhysicalDeviceQueueFamilyProperties2(addrs, *p0, *p1, *p2)
	}

// GetPhysicalDeviceImageFormatProperties2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceImageFormatProperties2.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceImageFormatProperties2(pImageFormatInfo *PhysicalDeviceImageFormatInfo2, pImageFormatProperties *ImageFormatProperties2, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceImageFormatInfo2) **C.struct_VkPhysicalDeviceImageFormatInfo2 { /* Pointer */ g2c := (*C.struct_VkPhysicalDeviceImageFormatInfo2)(*x); return &g2c }(&pImageFormatInfo)
	p2 := func(x **ImageFormatProperties2) **C.struct_VkImageFormatProperties2 { /* Pointer */ g2c := (*C.struct_VkImageFormatProperties2)(*x); return &g2c }(&pImageFormatProperties)
	ret := C.vkGetPhysicalDeviceImageFormatProperties2(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceFormatProperties2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFormatProperties2.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceFormatProperties2(format Format, pFormatProperties *FormatProperties2, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* typedef */ (*C.VkFormat)(&format)
	p2 := func(x **FormatProperties2) **C.struct_VkFormatProperties2 { /* Pointer */ g2c := (*C.struct_VkFormatProperties2)(*x); return &g2c }(&pFormatProperties)
	C.vkGetPhysicalDeviceFormatProperties2(addrs, *p0, *p1, *p2)
	}

// GetPhysicalDeviceProperties2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceProperties2.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceProperties2(pProperties *PhysicalDeviceProperties2, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceProperties2) **C.struct_VkPhysicalDeviceProperties2 { /* Pointer */ g2c := (*C.struct_VkPhysicalDeviceProperties2)(*x); return &g2c }(&pProperties)
	C.vkGetPhysicalDeviceProperties2(addrs, *p0, *p1)
	}

// GetPhysicalDeviceFeatures2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFeatures2.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceFeatures2(pFeatures *PhysicalDeviceFeatures2, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceFeatures2) **C.struct_VkPhysicalDeviceFeatures2 { /* Pointer */ g2c := (*C.struct_VkPhysicalDeviceFeatures2)(*x); return &g2c }(&pFeatures)
	C.vkGetPhysicalDeviceFeatures2(addrs, *p0, *p1)
	}

// GetImageSparseMemoryRequirements2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageSparseMemoryRequirements2.html
func (x DeviceFacade)GetImageSparseMemoryRequirements2(pInfo *ImageSparseMemoryRequirementsInfo2, pSparseMemoryRequirementCount *uint32, pSparseMemoryRequirements []SparseImageMemoryRequirements2, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **ImageSparseMemoryRequirementsInfo2) **C.struct_VkImageSparseMemoryRequirementsInfo2 { /* Pointer */ g2c := (*C.struct_VkImageSparseMemoryRequirementsInfo2)(*x); return &g2c }(&pInfo)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pSparseMemoryRequirementCount)
	p3 := func(x *[]SparseImageMemoryRequirements2) **C.struct_VkSparseImageMemoryRequirements2 { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkSparseImageMemoryRequirements2)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkSparseImageMemoryRequirements2)(unsafe.Pointer((&ptr))) }(&pSparseMemoryRequirements)
	C.vkGetImageSparseMemoryRequirements2(addrs, *p0, *p1, *p2, *p3)
	}

// GetBufferMemoryRequirements2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferMemoryRequirements2.html
func (x DeviceFacade)GetBufferMemoryRequirements2(pInfo *BufferMemoryRequirementsInfo2, pMemoryRequirements *MemoryRequirements2, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **BufferMemoryRequirementsInfo2) **C.struct_VkBufferMemoryRequirementsInfo2 { /* Pointer */ g2c := (*C.struct_VkBufferMemoryRequirementsInfo2)(*x); return &g2c }(&pInfo)
	p2 := func(x **MemoryRequirements2) **C.struct_VkMemoryRequirements2 { /* Pointer */ g2c := (*C.struct_VkMemoryRequirements2)(*x); return &g2c }(&pMemoryRequirements)
	C.vkGetBufferMemoryRequirements2(addrs, *p0, *p1, *p2)
	}

// GetPhysicalDeviceExternalSemaphoreProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalSemaphoreProperties.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceExternalSemaphoreProperties(pExternalSemaphoreInfo *PhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties *ExternalSemaphoreProperties, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceExternalSemaphoreInfo) **C.struct_VkPhysicalDeviceExternalSemaphoreInfo { /* Pointer */ g2c := (*C.struct_VkPhysicalDeviceExternalSemaphoreInfo)(*x); return &g2c }(&pExternalSemaphoreInfo)
	p2 := func(x **ExternalSemaphoreProperties) **C.struct_VkExternalSemaphoreProperties { /* Pointer */ g2c := (*C.struct_VkExternalSemaphoreProperties)(*x); return &g2c }(&pExternalSemaphoreProperties)
	C.vkGetPhysicalDeviceExternalSemaphoreProperties(addrs, *p0, *p1, *p2)
	}

// GetImageMemoryRequirements2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageMemoryRequirements2.html
func (x DeviceFacade)GetImageMemoryRequirements2(pInfo *ImageMemoryRequirementsInfo2, pMemoryRequirements *MemoryRequirements2, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **ImageMemoryRequirementsInfo2) **C.struct_VkImageMemoryRequirementsInfo2 { /* Pointer */ g2c := (*C.struct_VkImageMemoryRequirementsInfo2)(*x); return &g2c }(&pInfo)
	p2 := func(x **MemoryRequirements2) **C.struct_VkMemoryRequirements2 { /* Pointer */ g2c := (*C.struct_VkMemoryRequirements2)(*x); return &g2c }(&pMemoryRequirements)
	C.vkGetImageMemoryRequirements2(addrs, *p0, *p1, *p2)
	}

// DestroyDescriptorUpdateTemplate command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDescriptorUpdateTemplate.html
func (x DeviceFacade)DestroyDescriptorUpdateTemplate(descriptorUpdateTemplate DescriptorUpdateTemplate, pAllocator *AllocationCallbacks, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkDescriptorUpdateTemplate)(&descriptorUpdateTemplate)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	C.vkDestroyDescriptorUpdateTemplate(addrs, *p0, *p1, *p2)
	}

// EnumeratePhysicalDeviceGroups command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumeratePhysicalDeviceGroups.html
func (x InstanceFacade)EnumeratePhysicalDeviceGroups(pPhysicalDeviceGroupCount *uint32, pPhysicalDeviceGroupProperties []PhysicalDeviceGroupProperties, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkInstance)(&x.H)
	p1 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPhysicalDeviceGroupCount)
	p2 := func(x *[]PhysicalDeviceGroupProperties) **C.struct_VkPhysicalDeviceGroupProperties { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkPhysicalDeviceGroupProperties)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkPhysicalDeviceGroupProperties)(unsafe.Pointer((&ptr))) }(&pPhysicalDeviceGroupProperties)
	ret := C.vkEnumeratePhysicalDeviceGroups(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CmdDispatchBase command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDispatchBase.html
func (x CommandBufferFacade)CmdDispatchBase(baseGroupX uint32, baseGroupY uint32, baseGroupZ uint32, groupCountX uint32, groupCountY uint32, groupCountZ uint32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&baseGroupX)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&baseGroupY)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&baseGroupZ)
	p4 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&groupCountX)
	p5 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&groupCountY)
	p6 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&groupCountZ)
	C.vkCmdDispatchBase(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6)
	}

// CmdSetDeviceMask command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDeviceMask.html
func (x CommandBufferFacade)CmdSetDeviceMask(deviceMask uint32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&deviceMask)
	C.vkCmdSetDeviceMask(addrs, *p0, *p1)
	}

// GetDeviceGroupPeerMemoryFeatures command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceGroupPeerMemoryFeatures.html
func (x DeviceFacade)GetDeviceGroupPeerMemoryFeatures(heapIndex uint32, localDeviceIndex uint32, remoteDeviceIndex uint32, pPeerMemoryFeatures *PeerMemoryFeatureFlags, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&heapIndex)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&localDeviceIndex)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&remoteDeviceIndex)
	p4 := func(x **PeerMemoryFeatureFlags) **C.VkPeerMemoryFeatureFlags { /* Pointer */ g2c := (*C.VkPeerMemoryFeatureFlags)(*x); return &g2c }(&pPeerMemoryFeatures)
	C.vkGetDeviceGroupPeerMemoryFeatures(addrs, *p0, *p1, *p2, *p3, *p4)
	}

// GetDescriptorSetLayoutSupport command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorSetLayoutSupport.html
func (x DeviceFacade)GetDescriptorSetLayoutSupport(pCreateInfo *DescriptorSetLayoutCreateInfo, pSupport *DescriptorSetLayoutSupport, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DescriptorSetLayoutCreateInfo) **C.struct_VkDescriptorSetLayoutCreateInfo { /* Pointer */ g2c := (*C.struct_VkDescriptorSetLayoutCreateInfo)(*x); return &g2c }(&pCreateInfo)
	p2 := func(x **DescriptorSetLayoutSupport) **C.struct_VkDescriptorSetLayoutSupport { /* Pointer */ g2c := (*C.struct_VkDescriptorSetLayoutSupport)(*x); return &g2c }(&pSupport)
	C.vkGetDescriptorSetLayoutSupport(addrs, *p0, *p1, *p2)
	}

// BindImageMemory2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindImageMemory2.html
func (x DeviceFacade)BindImageMemory2(bindInfoCount uint32, pBindInfos []BindImageMemoryInfo, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&bindInfoCount)
	p2 := func(x *[]BindImageMemoryInfo) **C.struct_VkBindImageMemoryInfo { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkBindImageMemoryInfo)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkBindImageMemoryInfo)(unsafe.Pointer((&ptr))) }(&pBindInfos)
	ret := C.vkBindImageMemory2(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// BindBufferMemory2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindBufferMemory2.html
func (x DeviceFacade)BindBufferMemory2(bindInfoCount uint32, pBindInfos []BindBufferMemoryInfo, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&bindInfoCount)
	p2 := func(x *[]BindBufferMemoryInfo) **C.struct_VkBindBufferMemoryInfo { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkBindBufferMemoryInfo)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkBindBufferMemoryInfo)(unsafe.Pointer((&ptr))) }(&pBindInfos)
	ret := C.vkBindBufferMemory2(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// EnumerateInstanceVersion command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceVersion.html
func EnumerateInstanceVersion(pApiVersion *uint32, ) Result {
	addrs := &C.vksProcAddresses
	p0 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pApiVersion)
	ret := C.vkEnumerateInstanceVersion(addrs, *p0)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceExternalBufferProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalBufferProperties.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceExternalBufferProperties(pExternalBufferInfo *PhysicalDeviceExternalBufferInfo, pExternalBufferProperties *ExternalBufferProperties, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceExternalBufferInfo) **C.struct_VkPhysicalDeviceExternalBufferInfo { /* Pointer */ g2c := (*C.struct_VkPhysicalDeviceExternalBufferInfo)(*x); return &g2c }(&pExternalBufferInfo)
	p2 := func(x **ExternalBufferProperties) **C.struct_VkExternalBufferProperties { /* Pointer */ g2c := (*C.struct_VkExternalBufferProperties)(*x); return &g2c }(&pExternalBufferProperties)
	C.vkGetPhysicalDeviceExternalBufferProperties(addrs, *p0, *p1, *p2)
	}

// DriverId enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDriverId.html
type DriverId uint32

const (
	VK_DRIVER_ID_AMD_PROPRIETARY DriverId = 1
	VK_DRIVER_ID_AMD_OPEN_SOURCE DriverId = 2
	VK_DRIVER_ID_MESA_RADV DriverId = 3
	VK_DRIVER_ID_NVIDIA_PROPRIETARY DriverId = 4
	VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS DriverId = 5
	VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA DriverId = 6
	VK_DRIVER_ID_IMAGINATION_PROPRIETARY DriverId = 7
	VK_DRIVER_ID_QUALCOMM_PROPRIETARY DriverId = 8
	VK_DRIVER_ID_ARM_PROPRIETARY DriverId = 9
	VK_DRIVER_ID_GOOGLE_SWIFTSHADER DriverId = 10
	VK_DRIVER_ID_GGP_PROPRIETARY DriverId = 11
	VK_DRIVER_ID_BROADCOM_PROPRIETARY DriverId = 12
	VK_DRIVER_ID_MESA_LLVMPIPE DriverId = 13
	VK_DRIVER_ID_MOLTENVK DriverId = 14
	VK_DRIVER_ID_COREAVI_PROPRIETARY DriverId = 15
	VK_DRIVER_ID_JUICE_PROPRIETARY DriverId = 16
	VK_DRIVER_ID_VERISILICON_PROPRIETARY DriverId = 17
	VK_DRIVER_ID_MESA_TURNIP DriverId = 18
	VK_DRIVER_ID_MESA_V3DV DriverId = 19
	VK_DRIVER_ID_MESA_PANVK DriverId = 20
	VK_DRIVER_ID_SAMSUNG_PROPRIETARY DriverId = 21
	VK_DRIVER_ID_MESA_VENUS DriverId = 22
	VK_DRIVER_ID_MESA_DOZEN DriverId = 23
)

var (
	reverseDriverId map[DriverId]string = map[DriverId]string{ 
		VK_DRIVER_ID_AMD_PROPRIETARY: "VK_DRIVER_ID_AMD_PROPRIETARY",
		VK_DRIVER_ID_AMD_OPEN_SOURCE: "VK_DRIVER_ID_AMD_OPEN_SOURCE",
		VK_DRIVER_ID_MESA_RADV: "VK_DRIVER_ID_MESA_RADV",
		VK_DRIVER_ID_NVIDIA_PROPRIETARY: "VK_DRIVER_ID_NVIDIA_PROPRIETARY",
		VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS: "VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS",
		VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA: "VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA",
		VK_DRIVER_ID_IMAGINATION_PROPRIETARY: "VK_DRIVER_ID_IMAGINATION_PROPRIETARY",
		VK_DRIVER_ID_QUALCOMM_PROPRIETARY: "VK_DRIVER_ID_QUALCOMM_PROPRIETARY",
		VK_DRIVER_ID_ARM_PROPRIETARY: "VK_DRIVER_ID_ARM_PROPRIETARY",
		VK_DRIVER_ID_GOOGLE_SWIFTSHADER: "VK_DRIVER_ID_GOOGLE_SWIFTSHADER",
		VK_DRIVER_ID_GGP_PROPRIETARY: "VK_DRIVER_ID_GGP_PROPRIETARY",
		VK_DRIVER_ID_BROADCOM_PROPRIETARY: "VK_DRIVER_ID_BROADCOM_PROPRIETARY",
		VK_DRIVER_ID_MESA_LLVMPIPE: "VK_DRIVER_ID_MESA_LLVMPIPE",
		VK_DRIVER_ID_MOLTENVK: "VK_DRIVER_ID_MOLTENVK",
		VK_DRIVER_ID_COREAVI_PROPRIETARY: "VK_DRIVER_ID_COREAVI_PROPRIETARY",
		VK_DRIVER_ID_JUICE_PROPRIETARY: "VK_DRIVER_ID_JUICE_PROPRIETARY",
		VK_DRIVER_ID_VERISILICON_PROPRIETARY: "VK_DRIVER_ID_VERISILICON_PROPRIETARY",
		VK_DRIVER_ID_MESA_TURNIP: "VK_DRIVER_ID_MESA_TURNIP",
		VK_DRIVER_ID_MESA_V3DV: "VK_DRIVER_ID_MESA_V3DV",
		VK_DRIVER_ID_MESA_PANVK: "VK_DRIVER_ID_MESA_PANVK",
		VK_DRIVER_ID_SAMSUNG_PROPRIETARY: "VK_DRIVER_ID_SAMSUNG_PROPRIETARY",
		VK_DRIVER_ID_MESA_VENUS: "VK_DRIVER_ID_MESA_VENUS",
		VK_DRIVER_ID_MESA_DOZEN: "VK_DRIVER_ID_MESA_DOZEN",
	}
)
func (x DriverId) String() string {
	if s, ok := reverseDriverId[x]; ok {
		return s
	}
	return fmt.Sprintf("DriverId=%d", x)
}

// SamplerReductionMode enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerReductionMode.html
type SamplerReductionMode uint32

const (
	VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE SamplerReductionMode = 0
	VK_SAMPLER_REDUCTION_MODE_MIN SamplerReductionMode = 1
	VK_SAMPLER_REDUCTION_MODE_MAX SamplerReductionMode = 2
)

var (
	reverseSamplerReductionMode map[SamplerReductionMode]string = map[SamplerReductionMode]string{ 
		VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE: "VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE",
		VK_SAMPLER_REDUCTION_MODE_MIN: "VK_SAMPLER_REDUCTION_MODE_MIN",
		VK_SAMPLER_REDUCTION_MODE_MAX: "VK_SAMPLER_REDUCTION_MODE_MAX",
	}
)
func (x SamplerReductionMode) String() string {
	if s, ok := reverseSamplerReductionMode[x]; ok {
		return s
	}
	return fmt.Sprintf("SamplerReductionMode=%d", x)
}

// SemaphoreWaitFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreWaitFlagBits.html
type SemaphoreWaitFlagBits uint32

const (
	VK_SEMAPHORE_WAIT_ANY_BIT SemaphoreWaitFlagBits = (1 << 0)
)

var (
	reverseSemaphoreWaitFlagBits map[SemaphoreWaitFlagBits]string = map[SemaphoreWaitFlagBits]string{ 
		VK_SEMAPHORE_WAIT_ANY_BIT: "VK_SEMAPHORE_WAIT_ANY_BIT",
	}
)
func (x SemaphoreWaitFlagBits) String() string {
	if s, ok := reverseSemaphoreWaitFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("SemaphoreWaitFlagBits=%d", x)
}

// DescriptorBindingFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorBindingFlagBits.html
type DescriptorBindingFlagBits uint32

const (
	VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT DescriptorBindingFlagBits = (1 << 0)
	VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT DescriptorBindingFlagBits = (1 << 1)
	VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT DescriptorBindingFlagBits = (1 << 2)
	VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT DescriptorBindingFlagBits = (1 << 3)
)

var (
	reverseDescriptorBindingFlagBits map[DescriptorBindingFlagBits]string = map[DescriptorBindingFlagBits]string{ 
		VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT: "VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT",
		VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT: "VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT",
		VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT: "VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT",
		VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT: "VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT",
	}
)
func (x DescriptorBindingFlagBits) String() string {
	if s, ok := reverseDescriptorBindingFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("DescriptorBindingFlagBits=%d", x)
}

// ResolveModeFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkResolveModeFlagBits.html
type ResolveModeFlagBits uint32

const (
	VK_RESOLVE_MODE_NONE ResolveModeFlagBits = 0
	VK_RESOLVE_MODE_SAMPLE_ZERO_BIT ResolveModeFlagBits = (1 << 0)
	VK_RESOLVE_MODE_AVERAGE_BIT ResolveModeFlagBits = (1 << 1)
	VK_RESOLVE_MODE_MIN_BIT ResolveModeFlagBits = (1 << 2)
	VK_RESOLVE_MODE_MAX_BIT ResolveModeFlagBits = (1 << 3)
)

var (
	reverseResolveModeFlagBits map[ResolveModeFlagBits]string = map[ResolveModeFlagBits]string{ 
		VK_RESOLVE_MODE_NONE: "VK_RESOLVE_MODE_NONE",
		VK_RESOLVE_MODE_SAMPLE_ZERO_BIT: "VK_RESOLVE_MODE_SAMPLE_ZERO_BIT",
		VK_RESOLVE_MODE_AVERAGE_BIT: "VK_RESOLVE_MODE_AVERAGE_BIT",
		VK_RESOLVE_MODE_MIN_BIT: "VK_RESOLVE_MODE_MIN_BIT",
		VK_RESOLVE_MODE_MAX_BIT: "VK_RESOLVE_MODE_MAX_BIT",
	}
)
func (x ResolveModeFlagBits) String() string {
	if s, ok := reverseResolveModeFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ResolveModeFlagBits=%d", x)
}

// ShaderFloatControlsIndependence enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkShaderFloatControlsIndependence.html
type ShaderFloatControlsIndependence uint32

const (
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY ShaderFloatControlsIndependence = 0
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL ShaderFloatControlsIndependence = 1
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE ShaderFloatControlsIndependence = 2
)

var (
	reverseShaderFloatControlsIndependence map[ShaderFloatControlsIndependence]string = map[ShaderFloatControlsIndependence]string{ 
		VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY: "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY",
		VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL: "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL",
		VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE: "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE",
	}
)
func (x ShaderFloatControlsIndependence) String() string {
	if s, ok := reverseShaderFloatControlsIndependence[x]; ok {
		return s
	}
	return fmt.Sprintf("ShaderFloatControlsIndependence=%d", x)
}

// SemaphoreType enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreType.html
type SemaphoreType uint32

const (
	VK_SEMAPHORE_TYPE_BINARY SemaphoreType = 0
	VK_SEMAPHORE_TYPE_TIMELINE SemaphoreType = 1
)

var (
	reverseSemaphoreType map[SemaphoreType]string = map[SemaphoreType]string{ 
		VK_SEMAPHORE_TYPE_BINARY: "VK_SEMAPHORE_TYPE_BINARY",
		VK_SEMAPHORE_TYPE_TIMELINE: "VK_SEMAPHORE_TYPE_TIMELINE",
	}
)
func (x SemaphoreType) String() string {
	if s, ok := reverseSemaphoreType[x]; ok {
		return s
	}
	return fmt.Sprintf("SemaphoreType=%d", x)
}

// DescriptorBindingFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorBindingFlags.html
type DescriptorBindingFlags Flags

// ResolveModeFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkResolveModeFlags.html
type ResolveModeFlags Flags

// SemaphoreWaitFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreWaitFlags.html
type SemaphoreWaitFlags Flags

// SubpassEndInfo provides a go interface for VkSubpassEndInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassEndInfo.html
type SubpassEndInfo C.struct_VkSubpassEndInfo

// SizeofSubpassEndInfo is the memory size of a SubpassEndInfo
var SizeofSubpassEndInfo int = int(unsafe.Sizeof(SubpassEndInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubpassEndInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubpassEndInfo) AsCPtr() *SubpassEndInfo {
	clone := (*SubpassEndInfo)(newCBlock(C.ulong(SizeofSubpassEndInfo)))
	*clone = x
	return clone
}

// SubpassEndInfoFreeCSlice releases the memory allocated by SubpassEndInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SubpassEndInfoFreeCSlice(x []SubpassEndInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubpassEndInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubpassEndInfoFreeCSlice must be called on the returned slice.
func SubpassEndInfoMakeCSlice(x ...SubpassEndInfo) []SubpassEndInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassEndInfo * len(x)
	dst := unsafe.Slice((*SubpassEndInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSubpassEndInfo
func (x SubpassEndInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SubpassEndInfo) WithDefaultSType() SubpassEndInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SUBPASS_END_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassEndInfo) WithSType(y StructureType) SubpassEndInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkSubpassEndInfo
func (x SubpassEndInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassEndInfo) WithPNext(y unsafe.Pointer) SubpassEndInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// RenderPassCreateInfo2 provides a go interface for VkRenderPassCreateInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassCreateInfo2.html
type RenderPassCreateInfo2 C.struct_VkRenderPassCreateInfo2

// SizeofRenderPassCreateInfo2 is the memory size of a RenderPassCreateInfo2
var SizeofRenderPassCreateInfo2 int = int(unsafe.Sizeof(RenderPassCreateInfo2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *RenderPassCreateInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x RenderPassCreateInfo2) AsCPtr() *RenderPassCreateInfo2 {
	clone := (*RenderPassCreateInfo2)(newCBlock(C.ulong(SizeofRenderPassCreateInfo2)))
	*clone = x
	return clone
}

// RenderPassCreateInfo2FreeCSlice releases the memory allocated by RenderPassCreateInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func RenderPassCreateInfo2FreeCSlice(x []RenderPassCreateInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// RenderPassCreateInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. RenderPassCreateInfo2FreeCSlice must be called on the returned slice.
func RenderPassCreateInfo2MakeCSlice(x ...RenderPassCreateInfo2) []RenderPassCreateInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderPassCreateInfo2 * len(x)
	dst := unsafe.Slice((*RenderPassCreateInfo2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x RenderPassCreateInfo2) WithDefaultSType() RenderPassCreateInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo2) WithSType(y StructureType) RenderPassCreateInfo2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo2) WithPNext(y unsafe.Pointer) RenderPassCreateInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) Flags() RenderPassCreateFlags {
	ptr := /* typedef */ (*RenderPassCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo2) WithFlags(y RenderPassCreateFlags) RenderPassCreateInfo2 {
	x.flags = *(/* typedef */ (*C.VkRenderPassCreateFlags)(&y))
	return x
}

// AttachmentCount returns the value of attachmentCount from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) AttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.attachmentCount) 
	return *ptr
}

// WithAttachmentCount sets the value for the AttachmentCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo2) WithAttachmentCount(y uint32) RenderPassCreateInfo2 {
	x.attachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PAttachments returns the value of pAttachments from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) PAttachments() []AttachmentDescription2 {
	ptr := func(x **C.struct_VkAttachmentDescription2) *[]AttachmentDescription2 { /* Slice */ slc := unsafe.Slice((*AttachmentDescription2)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pAttachments) 
	return *ptr
}

// WithPAttachments sets the value for the PAttachments on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines AttachmentCount as the length of this field.
// AttachmentCount is updated with the length of the new value.
func (x RenderPassCreateInfo2) WithPAttachments(y []AttachmentDescription2) RenderPassCreateInfo2 {
	x.pAttachments = *(func(x *[]AttachmentDescription2) **C.struct_VkAttachmentDescription2 { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkAttachmentDescription2)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkAttachmentDescription2)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithAttachmentCount(uint32(len(y)))
}

// SubpassCount returns the value of subpassCount from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) SubpassCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.subpassCount) 
	return *ptr
}

// WithSubpassCount sets the value for the SubpassCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo2) WithSubpassCount(y uint32) RenderPassCreateInfo2 {
	x.subpassCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PSubpasses returns the value of pSubpasses from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) PSubpasses() []SubpassDescription2 {
	ptr := func(x **C.struct_VkSubpassDescription2) *[]SubpassDescription2 { /* Slice */ slc := unsafe.Slice((*SubpassDescription2)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pSubpasses) 
	return *ptr
}

// WithPSubpasses sets the value for the PSubpasses on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines SubpassCount as the length of this field.
// SubpassCount is updated with the length of the new value.
func (x RenderPassCreateInfo2) WithPSubpasses(y []SubpassDescription2) RenderPassCreateInfo2 {
	x.pSubpasses = *(func(x *[]SubpassDescription2) **C.struct_VkSubpassDescription2 { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkSubpassDescription2)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkSubpassDescription2)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithSubpassCount(uint32(len(y)))
}

// DependencyCount returns the value of dependencyCount from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) DependencyCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dependencyCount) 
	return *ptr
}

// WithDependencyCount sets the value for the DependencyCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo2) WithDependencyCount(y uint32) RenderPassCreateInfo2 {
	x.dependencyCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PDependencies returns the value of pDependencies from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) PDependencies() []SubpassDependency2 {
	ptr := func(x **C.struct_VkSubpassDependency2) *[]SubpassDependency2 { /* Slice */ slc := unsafe.Slice((*SubpassDependency2)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pDependencies) 
	return *ptr
}

// WithPDependencies sets the value for the PDependencies on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines DependencyCount as the length of this field.
// DependencyCount is updated with the length of the new value.
func (x RenderPassCreateInfo2) WithPDependencies(y []SubpassDependency2) RenderPassCreateInfo2 {
	x.pDependencies = *(func(x *[]SubpassDependency2) **C.struct_VkSubpassDependency2 { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkSubpassDependency2)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkSubpassDependency2)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithDependencyCount(uint32(len(y)))
}

// CorrelatedViewMaskCount returns the value of correlatedViewMaskCount from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) CorrelatedViewMaskCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.correlatedViewMaskCount) 
	return *ptr
}

// WithCorrelatedViewMaskCount sets the value for the CorrelatedViewMaskCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassCreateInfo2) WithCorrelatedViewMaskCount(y uint32) RenderPassCreateInfo2 {
	x.correlatedViewMaskCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PCorrelatedViewMasks returns the value of pCorrelatedViewMasks from VkRenderPassCreateInfo2
func (x RenderPassCreateInfo2) PCorrelatedViewMasks() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */ slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pCorrelatedViewMasks) 
	return *ptr
}

// WithPCorrelatedViewMasks sets the value for the PCorrelatedViewMasks on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines CorrelatedViewMaskCount as the length of this field.
// CorrelatedViewMaskCount is updated with the length of the new value.
func (x RenderPassCreateInfo2) WithPCorrelatedViewMasks(y []uint32) RenderPassCreateInfo2 {
	x.pCorrelatedViewMasks = *(func(x *[]uint32) **C.uint32_t { /* Slice */ if len(*x) > 0 { slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.uint32_t)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithCorrelatedViewMaskCount(uint32(len(y)))
}

// AttachmentDescription2 provides a go interface for VkAttachmentDescription2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentDescription2.html
type AttachmentDescription2 C.struct_VkAttachmentDescription2

// SizeofAttachmentDescription2 is the memory size of a AttachmentDescription2
var SizeofAttachmentDescription2 int = int(unsafe.Sizeof(AttachmentDescription2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *AttachmentDescription2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x AttachmentDescription2) AsCPtr() *AttachmentDescription2 {
	clone := (*AttachmentDescription2)(newCBlock(C.ulong(SizeofAttachmentDescription2)))
	*clone = x
	return clone
}

// AttachmentDescription2FreeCSlice releases the memory allocated by AttachmentDescription2MakeCSlice.
// It does not free pointers stored inside the slice.
func AttachmentDescription2FreeCSlice(x []AttachmentDescription2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// AttachmentDescription2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. AttachmentDescription2FreeCSlice must be called on the returned slice.
func AttachmentDescription2MakeCSlice(x ...AttachmentDescription2) []AttachmentDescription2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAttachmentDescription2 * len(x)
	dst := unsafe.Slice((*AttachmentDescription2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkAttachmentDescription2
func (x AttachmentDescription2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x AttachmentDescription2) WithDefaultSType() AttachmentDescription2 {
	return x.WithSType(VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithSType(y StructureType) AttachmentDescription2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkAttachmentDescription2
func (x AttachmentDescription2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithPNext(y unsafe.Pointer) AttachmentDescription2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkAttachmentDescription2
func (x AttachmentDescription2) Flags() AttachmentDescriptionFlags {
	ptr := /* typedef */ (*AttachmentDescriptionFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithFlags(y AttachmentDescriptionFlags) AttachmentDescription2 {
	x.flags = *(/* typedef */ (*C.VkAttachmentDescriptionFlags)(&y))
	return x
}

// Format returns the value of format from VkAttachmentDescription2
func (x AttachmentDescription2) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format) 
	return *ptr
}

// WithFormat sets the value for the Format on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithFormat(y Format) AttachmentDescription2 {
	x.format = *(/* typedef */ (*C.VkFormat)(&y))
	return x
}

// Samples returns the value of samples from VkAttachmentDescription2
func (x AttachmentDescription2) Samples() SampleCountFlagBits {
	ptr := /* typedef */ (*SampleCountFlagBits)(&x.samples) 
	return *ptr
}

// WithSamples sets the value for the Samples on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithSamples(y SampleCountFlagBits) AttachmentDescription2 {
	x.samples = *(/* typedef */ (*C.VkSampleCountFlagBits)(&y))
	return x
}

// LoadOp returns the value of loadOp from VkAttachmentDescription2
func (x AttachmentDescription2) LoadOp() AttachmentLoadOp {
	ptr := /* typedef */ (*AttachmentLoadOp)(&x.loadOp) 
	return *ptr
}

// WithLoadOp sets the value for the LoadOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithLoadOp(y AttachmentLoadOp) AttachmentDescription2 {
	x.loadOp = *(/* typedef */ (*C.VkAttachmentLoadOp)(&y))
	return x
}

// StoreOp returns the value of storeOp from VkAttachmentDescription2
func (x AttachmentDescription2) StoreOp() AttachmentStoreOp {
	ptr := /* typedef */ (*AttachmentStoreOp)(&x.storeOp) 
	return *ptr
}

// WithStoreOp sets the value for the StoreOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithStoreOp(y AttachmentStoreOp) AttachmentDescription2 {
	x.storeOp = *(/* typedef */ (*C.VkAttachmentStoreOp)(&y))
	return x
}

// StencilLoadOp returns the value of stencilLoadOp from VkAttachmentDescription2
func (x AttachmentDescription2) StencilLoadOp() AttachmentLoadOp {
	ptr := /* typedef */ (*AttachmentLoadOp)(&x.stencilLoadOp) 
	return *ptr
}

// WithStencilLoadOp sets the value for the StencilLoadOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithStencilLoadOp(y AttachmentLoadOp) AttachmentDescription2 {
	x.stencilLoadOp = *(/* typedef */ (*C.VkAttachmentLoadOp)(&y))
	return x
}

// StencilStoreOp returns the value of stencilStoreOp from VkAttachmentDescription2
func (x AttachmentDescription2) StencilStoreOp() AttachmentStoreOp {
	ptr := /* typedef */ (*AttachmentStoreOp)(&x.stencilStoreOp) 
	return *ptr
}

// WithStencilStoreOp sets the value for the StencilStoreOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithStencilStoreOp(y AttachmentStoreOp) AttachmentDescription2 {
	x.stencilStoreOp = *(/* typedef */ (*C.VkAttachmentStoreOp)(&y))
	return x
}

// InitialLayout returns the value of initialLayout from VkAttachmentDescription2
func (x AttachmentDescription2) InitialLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.initialLayout) 
	return *ptr
}

// WithInitialLayout sets the value for the InitialLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithInitialLayout(y ImageLayout) AttachmentDescription2 {
	x.initialLayout = *(/* typedef */ (*C.VkImageLayout)(&y))
	return x
}

// FinalLayout returns the value of finalLayout from VkAttachmentDescription2
func (x AttachmentDescription2) FinalLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.finalLayout) 
	return *ptr
}

// WithFinalLayout sets the value for the FinalLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescription2) WithFinalLayout(y ImageLayout) AttachmentDescription2 {
	x.finalLayout = *(/* typedef */ (*C.VkImageLayout)(&y))
	return x
}

// AttachmentReference2 provides a go interface for VkAttachmentReference2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentReference2.html
type AttachmentReference2 C.struct_VkAttachmentReference2

// SizeofAttachmentReference2 is the memory size of a AttachmentReference2
var SizeofAttachmentReference2 int = int(unsafe.Sizeof(AttachmentReference2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *AttachmentReference2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x AttachmentReference2) AsCPtr() *AttachmentReference2 {
	clone := (*AttachmentReference2)(newCBlock(C.ulong(SizeofAttachmentReference2)))
	*clone = x
	return clone
}

// AttachmentReference2FreeCSlice releases the memory allocated by AttachmentReference2MakeCSlice.
// It does not free pointers stored inside the slice.
func AttachmentReference2FreeCSlice(x []AttachmentReference2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// AttachmentReference2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. AttachmentReference2FreeCSlice must be called on the returned slice.
func AttachmentReference2MakeCSlice(x ...AttachmentReference2) []AttachmentReference2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAttachmentReference2 * len(x)
	dst := unsafe.Slice((*AttachmentReference2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkAttachmentReference2
func (x AttachmentReference2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x AttachmentReference2) WithDefaultSType() AttachmentReference2 {
	return x.WithSType(VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReference2) WithSType(y StructureType) AttachmentReference2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkAttachmentReference2
func (x AttachmentReference2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReference2) WithPNext(y unsafe.Pointer) AttachmentReference2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Attachment returns the value of attachment from VkAttachmentReference2
func (x AttachmentReference2) Attachment() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.attachment) 
	return *ptr
}

// WithAttachment sets the value for the Attachment on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReference2) WithAttachment(y uint32) AttachmentReference2 {
	x.attachment = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// Layout returns the value of layout from VkAttachmentReference2
func (x AttachmentReference2) Layout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.layout) 
	return *ptr
}

// WithLayout sets the value for the Layout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReference2) WithLayout(y ImageLayout) AttachmentReference2 {
	x.layout = *(/* typedef */ (*C.VkImageLayout)(&y))
	return x
}

// AspectMask returns the value of aspectMask from VkAttachmentReference2
func (x AttachmentReference2) AspectMask() ImageAspectFlags {
	ptr := /* typedef */ (*ImageAspectFlags)(&x.aspectMask) 
	return *ptr
}

// WithAspectMask sets the value for the AspectMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReference2) WithAspectMask(y ImageAspectFlags) AttachmentReference2 {
	x.aspectMask = *(/* typedef */ (*C.VkImageAspectFlags)(&y))
	return x
}

// SubpassDescription2 provides a go interface for VkSubpassDescription2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDescription2.html
type SubpassDescription2 C.struct_VkSubpassDescription2

// SizeofSubpassDescription2 is the memory size of a SubpassDescription2
var SizeofSubpassDescription2 int = int(unsafe.Sizeof(SubpassDescription2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubpassDescription2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubpassDescription2) AsCPtr() *SubpassDescription2 {
	clone := (*SubpassDescription2)(newCBlock(C.ulong(SizeofSubpassDescription2)))
	*clone = x
	return clone
}

// SubpassDescription2FreeCSlice releases the memory allocated by SubpassDescription2MakeCSlice.
// It does not free pointers stored inside the slice.
func SubpassDescription2FreeCSlice(x []SubpassDescription2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubpassDescription2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubpassDescription2FreeCSlice must be called on the returned slice.
func SubpassDescription2MakeCSlice(x ...SubpassDescription2) []SubpassDescription2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassDescription2 * len(x)
	dst := unsafe.Slice((*SubpassDescription2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSubpassDescription2
func (x SubpassDescription2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SubpassDescription2) WithDefaultSType() SubpassDescription2 {
	return x.WithSType(VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription2) WithSType(y StructureType) SubpassDescription2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkSubpassDescription2
func (x SubpassDescription2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription2) WithPNext(y unsafe.Pointer) SubpassDescription2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkSubpassDescription2
func (x SubpassDescription2) Flags() SubpassDescriptionFlags {
	ptr := /* typedef */ (*SubpassDescriptionFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription2) WithFlags(y SubpassDescriptionFlags) SubpassDescription2 {
	x.flags = *(/* typedef */ (*C.VkSubpassDescriptionFlags)(&y))
	return x
}

// PipelineBindPoint returns the value of pipelineBindPoint from VkSubpassDescription2
func (x SubpassDescription2) PipelineBindPoint() PipelineBindPoint {
	ptr := /* typedef */ (*PipelineBindPoint)(&x.pipelineBindPoint) 
	return *ptr
}

// WithPipelineBindPoint sets the value for the PipelineBindPoint on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription2) WithPipelineBindPoint(y PipelineBindPoint) SubpassDescription2 {
	x.pipelineBindPoint = *(/* typedef */ (*C.VkPipelineBindPoint)(&y))
	return x
}

// ViewMask returns the value of viewMask from VkSubpassDescription2
func (x SubpassDescription2) ViewMask() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.viewMask) 
	return *ptr
}

// WithViewMask sets the value for the ViewMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription2) WithViewMask(y uint32) SubpassDescription2 {
	x.viewMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// InputAttachmentCount returns the value of inputAttachmentCount from VkSubpassDescription2
func (x SubpassDescription2) InputAttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.inputAttachmentCount) 
	return *ptr
}

// WithInputAttachmentCount sets the value for the InputAttachmentCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription2) WithInputAttachmentCount(y uint32) SubpassDescription2 {
	x.inputAttachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PInputAttachments returns the value of pInputAttachments from VkSubpassDescription2
func (x SubpassDescription2) PInputAttachments() []AttachmentReference2 {
	ptr := func(x **C.struct_VkAttachmentReference2) *[]AttachmentReference2 { /* Slice */ slc := unsafe.Slice((*AttachmentReference2)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pInputAttachments) 
	return *ptr
}

// WithPInputAttachments sets the value for the PInputAttachments on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines InputAttachmentCount as the length of this field.
// InputAttachmentCount is updated with the length of the new value.
func (x SubpassDescription2) WithPInputAttachments(y []AttachmentReference2) SubpassDescription2 {
	x.pInputAttachments = *(func(x *[]AttachmentReference2) **C.struct_VkAttachmentReference2 { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkAttachmentReference2)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkAttachmentReference2)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithInputAttachmentCount(uint32(len(y)))
}

// ColorAttachmentCount returns the value of colorAttachmentCount from VkSubpassDescription2
func (x SubpassDescription2) ColorAttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.colorAttachmentCount) 
	return *ptr
}

// WithColorAttachmentCount sets the value for the ColorAttachmentCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription2) WithColorAttachmentCount(y uint32) SubpassDescription2 {
	x.colorAttachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PColorAttachments returns the value of pColorAttachments from VkSubpassDescription2
func (x SubpassDescription2) PColorAttachments() []AttachmentReference2 {
	ptr := func(x **C.struct_VkAttachmentReference2) *[]AttachmentReference2 { /* Slice */ slc := unsafe.Slice((*AttachmentReference2)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pColorAttachments) 
	return *ptr
}

// WithPColorAttachments sets the value for the PColorAttachments on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines ColorAttachmentCount as the length of this field.
// ColorAttachmentCount is updated with the length of the new value.
func (x SubpassDescription2) WithPColorAttachments(y []AttachmentReference2) SubpassDescription2 {
	x.pColorAttachments = *(func(x *[]AttachmentReference2) **C.struct_VkAttachmentReference2 { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkAttachmentReference2)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkAttachmentReference2)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithColorAttachmentCount(uint32(len(y)))
}

// PResolveAttachments returns the value of pResolveAttachments from VkSubpassDescription2
func (x SubpassDescription2) PResolveAttachments() []AttachmentReference2 {
	ptr := func(x **C.struct_VkAttachmentReference2) *[]AttachmentReference2 { /* Slice */ slc := unsafe.Slice((*AttachmentReference2)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pResolveAttachments) 
	return *ptr
}

// WithPResolveAttachments sets the value for the PResolveAttachments on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines ColorAttachmentCount as the length of this field.
// ColorAttachmentCount is updated with the length of the new value.
func (x SubpassDescription2) WithPResolveAttachments(y []AttachmentReference2) SubpassDescription2 {
	x.pResolveAttachments = *(func(x *[]AttachmentReference2) **C.struct_VkAttachmentReference2 { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkAttachmentReference2)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkAttachmentReference2)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithColorAttachmentCount(uint32(len(y)))
}

// PDepthStencilAttachment returns the value of pDepthStencilAttachment from VkSubpassDescription2
func (x SubpassDescription2) PDepthStencilAttachment() *AttachmentReference2 {
	ptr := func(x **C.struct_VkAttachmentReference2) **AttachmentReference2 { /* Pointer */ c2g := (*AttachmentReference2)(*x); return &c2g }(&x.pDepthStencilAttachment) 
	return *ptr
}

// WithPDepthStencilAttachment sets the value for the PDepthStencilAttachment on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription2) WithPDepthStencilAttachment(y *AttachmentReference2) SubpassDescription2 {
	x.pDepthStencilAttachment = *(func(x **AttachmentReference2) **C.struct_VkAttachmentReference2 { /* Pointer */ g2c := (*C.struct_VkAttachmentReference2)(*x); return &g2c }(&y))
	return x
}

// PreserveAttachmentCount returns the value of preserveAttachmentCount from VkSubpassDescription2
func (x SubpassDescription2) PreserveAttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.preserveAttachmentCount) 
	return *ptr
}

// WithPreserveAttachmentCount sets the value for the PreserveAttachmentCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescription2) WithPreserveAttachmentCount(y uint32) SubpassDescription2 {
	x.preserveAttachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PPreserveAttachments returns the value of pPreserveAttachments from VkSubpassDescription2
func (x SubpassDescription2) PPreserveAttachments() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */ slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pPreserveAttachments) 
	return *ptr
}

// WithPPreserveAttachments sets the value for the PPreserveAttachments on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines PreserveAttachmentCount as the length of this field.
// PreserveAttachmentCount is updated with the length of the new value.
func (x SubpassDescription2) WithPPreserveAttachments(y []uint32) SubpassDescription2 {
	x.pPreserveAttachments = *(func(x *[]uint32) **C.uint32_t { /* Slice */ if len(*x) > 0 { slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.uint32_t)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithPreserveAttachmentCount(uint32(len(y)))
}

// SubpassDependency2 provides a go interface for VkSubpassDependency2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDependency2.html
type SubpassDependency2 C.struct_VkSubpassDependency2

// SizeofSubpassDependency2 is the memory size of a SubpassDependency2
var SizeofSubpassDependency2 int = int(unsafe.Sizeof(SubpassDependency2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubpassDependency2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubpassDependency2) AsCPtr() *SubpassDependency2 {
	clone := (*SubpassDependency2)(newCBlock(C.ulong(SizeofSubpassDependency2)))
	*clone = x
	return clone
}

// SubpassDependency2FreeCSlice releases the memory allocated by SubpassDependency2MakeCSlice.
// It does not free pointers stored inside the slice.
func SubpassDependency2FreeCSlice(x []SubpassDependency2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubpassDependency2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubpassDependency2FreeCSlice must be called on the returned slice.
func SubpassDependency2MakeCSlice(x ...SubpassDependency2) []SubpassDependency2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassDependency2 * len(x)
	dst := unsafe.Slice((*SubpassDependency2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSubpassDependency2
func (x SubpassDependency2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SubpassDependency2) WithDefaultSType() SubpassDependency2 {
	return x.WithSType(VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithSType(y StructureType) SubpassDependency2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkSubpassDependency2
func (x SubpassDependency2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithPNext(y unsafe.Pointer) SubpassDependency2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SrcSubpass returns the value of srcSubpass from VkSubpassDependency2
func (x SubpassDependency2) SrcSubpass() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.srcSubpass) 
	return *ptr
}

// WithSrcSubpass sets the value for the SrcSubpass on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithSrcSubpass(y uint32) SubpassDependency2 {
	x.srcSubpass = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// DstSubpass returns the value of dstSubpass from VkSubpassDependency2
func (x SubpassDependency2) DstSubpass() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dstSubpass) 
	return *ptr
}

// WithDstSubpass sets the value for the DstSubpass on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithDstSubpass(y uint32) SubpassDependency2 {
	x.dstSubpass = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// SrcStageMask returns the value of srcStageMask from VkSubpassDependency2
func (x SubpassDependency2) SrcStageMask() PipelineStageFlags {
	ptr := /* typedef */ (*PipelineStageFlags)(&x.srcStageMask) 
	return *ptr
}

// WithSrcStageMask sets the value for the SrcStageMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithSrcStageMask(y PipelineStageFlags) SubpassDependency2 {
	x.srcStageMask = *(/* typedef */ (*C.VkPipelineStageFlags)(&y))
	return x
}

// DstStageMask returns the value of dstStageMask from VkSubpassDependency2
func (x SubpassDependency2) DstStageMask() PipelineStageFlags {
	ptr := /* typedef */ (*PipelineStageFlags)(&x.dstStageMask) 
	return *ptr
}

// WithDstStageMask sets the value for the DstStageMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithDstStageMask(y PipelineStageFlags) SubpassDependency2 {
	x.dstStageMask = *(/* typedef */ (*C.VkPipelineStageFlags)(&y))
	return x
}

// SrcAccessMask returns the value of srcAccessMask from VkSubpassDependency2
func (x SubpassDependency2) SrcAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.srcAccessMask) 
	return *ptr
}

// WithSrcAccessMask sets the value for the SrcAccessMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithSrcAccessMask(y AccessFlags) SubpassDependency2 {
	x.srcAccessMask = *(/* typedef */ (*C.VkAccessFlags)(&y))
	return x
}

// DstAccessMask returns the value of dstAccessMask from VkSubpassDependency2
func (x SubpassDependency2) DstAccessMask() AccessFlags {
	ptr := /* typedef */ (*AccessFlags)(&x.dstAccessMask) 
	return *ptr
}

// WithDstAccessMask sets the value for the DstAccessMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithDstAccessMask(y AccessFlags) SubpassDependency2 {
	x.dstAccessMask = *(/* typedef */ (*C.VkAccessFlags)(&y))
	return x
}

// DependencyFlags returns the value of dependencyFlags from VkSubpassDependency2
func (x SubpassDependency2) DependencyFlags() DependencyFlags {
	ptr := /* typedef */ (*DependencyFlags)(&x.dependencyFlags) 
	return *ptr
}

// WithDependencyFlags sets the value for the DependencyFlags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithDependencyFlags(y DependencyFlags) SubpassDependency2 {
	x.dependencyFlags = *(/* typedef */ (*C.VkDependencyFlags)(&y))
	return x
}

// ViewOffset returns the value of viewOffset from VkSubpassDependency2
func (x SubpassDependency2) ViewOffset() int32 {
	ptr := func(x *C.int32_t) *int32 { /* Scalar */ c2g := int32(*x); return &c2g }(&x.viewOffset) 
	return *ptr
}

// WithViewOffset sets the value for the ViewOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDependency2) WithViewOffset(y int32) SubpassDependency2 {
	x.viewOffset = *(func(x *int32) *C.int32_t { /* Scalar */ g2c := C.int32_t(*x); return &g2c }(&y))
	return x
}

// SubpassBeginInfo provides a go interface for VkSubpassBeginInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassBeginInfo.html
type SubpassBeginInfo C.struct_VkSubpassBeginInfo

// SizeofSubpassBeginInfo is the memory size of a SubpassBeginInfo
var SizeofSubpassBeginInfo int = int(unsafe.Sizeof(SubpassBeginInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubpassBeginInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubpassBeginInfo) AsCPtr() *SubpassBeginInfo {
	clone := (*SubpassBeginInfo)(newCBlock(C.ulong(SizeofSubpassBeginInfo)))
	*clone = x
	return clone
}

// SubpassBeginInfoFreeCSlice releases the memory allocated by SubpassBeginInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SubpassBeginInfoFreeCSlice(x []SubpassBeginInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubpassBeginInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubpassBeginInfoFreeCSlice must be called on the returned slice.
func SubpassBeginInfoMakeCSlice(x ...SubpassBeginInfo) []SubpassBeginInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassBeginInfo * len(x)
	dst := unsafe.Slice((*SubpassBeginInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSubpassBeginInfo
func (x SubpassBeginInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SubpassBeginInfo) WithDefaultSType() SubpassBeginInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassBeginInfo) WithSType(y StructureType) SubpassBeginInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkSubpassBeginInfo
func (x SubpassBeginInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassBeginInfo) WithPNext(y unsafe.Pointer) SubpassBeginInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Contents returns the value of contents from VkSubpassBeginInfo
func (x SubpassBeginInfo) Contents() SubpassContents {
	ptr := /* typedef */ (*SubpassContents)(&x.contents) 
	return *ptr
}

// WithContents sets the value for the Contents on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassBeginInfo) WithContents(y SubpassContents) SubpassBeginInfo {
	x.contents = *(/* typedef */ (*C.VkSubpassContents)(&y))
	return x
}

// SemaphoreWaitInfo provides a go interface for VkSemaphoreWaitInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreWaitInfo.html
type SemaphoreWaitInfo C.struct_VkSemaphoreWaitInfo

// SizeofSemaphoreWaitInfo is the memory size of a SemaphoreWaitInfo
var SizeofSemaphoreWaitInfo int = int(unsafe.Sizeof(SemaphoreWaitInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SemaphoreWaitInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SemaphoreWaitInfo) AsCPtr() *SemaphoreWaitInfo {
	clone := (*SemaphoreWaitInfo)(newCBlock(C.ulong(SizeofSemaphoreWaitInfo)))
	*clone = x
	return clone
}

// SemaphoreWaitInfoFreeCSlice releases the memory allocated by SemaphoreWaitInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SemaphoreWaitInfoFreeCSlice(x []SemaphoreWaitInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SemaphoreWaitInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SemaphoreWaitInfoFreeCSlice must be called on the returned slice.
func SemaphoreWaitInfoMakeCSlice(x ...SemaphoreWaitInfo) []SemaphoreWaitInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSemaphoreWaitInfo * len(x)
	dst := unsafe.Slice((*SemaphoreWaitInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSemaphoreWaitInfo
func (x SemaphoreWaitInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SemaphoreWaitInfo) WithDefaultSType() SemaphoreWaitInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreWaitInfo) WithSType(y StructureType) SemaphoreWaitInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkSemaphoreWaitInfo
func (x SemaphoreWaitInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreWaitInfo) WithPNext(y unsafe.Pointer) SemaphoreWaitInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkSemaphoreWaitInfo
func (x SemaphoreWaitInfo) Flags() SemaphoreWaitFlags {
	ptr := /* typedef */ (*SemaphoreWaitFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreWaitInfo) WithFlags(y SemaphoreWaitFlags) SemaphoreWaitInfo {
	x.flags = *(/* typedef */ (*C.VkSemaphoreWaitFlags)(&y))
	return x
}

// SemaphoreCount returns the value of semaphoreCount from VkSemaphoreWaitInfo
func (x SemaphoreWaitInfo) SemaphoreCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.semaphoreCount) 
	return *ptr
}

// WithSemaphoreCount sets the value for the SemaphoreCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreWaitInfo) WithSemaphoreCount(y uint32) SemaphoreWaitInfo {
	x.semaphoreCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PSemaphores returns the value of pSemaphores from VkSemaphoreWaitInfo
func (x SemaphoreWaitInfo) PSemaphores() []Semaphore {
	ptr := func(x **C.VkSemaphore) *[]Semaphore { /* Slice */ slc := unsafe.Slice((*Semaphore)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pSemaphores) 
	return *ptr
}

// WithPSemaphores sets the value for the PSemaphores on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines SemaphoreCount as the length of this field.
// SemaphoreCount is updated with the length of the new value.
func (x SemaphoreWaitInfo) WithPSemaphores(y []Semaphore) SemaphoreWaitInfo {
	x.pSemaphores = *(func(x *[]Semaphore) **C.VkSemaphore { /* Slice */ if len(*x) > 0 { slc := (*C.VkSemaphore)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkSemaphore)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithSemaphoreCount(uint32(len(y)))
}

// PValues returns the value of pValues from VkSemaphoreWaitInfo
func (x SemaphoreWaitInfo) PValues() []uint64 {
	ptr := func(x **C.uint64_t) *[]uint64 { /* Slice */ slc := unsafe.Slice((*uint64)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pValues) 
	return *ptr
}

// WithPValues sets the value for the PValues on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines SemaphoreCount as the length of this field.
// SemaphoreCount is updated with the length of the new value.
func (x SemaphoreWaitInfo) WithPValues(y []uint64) SemaphoreWaitInfo {
	x.pValues = *(func(x *[]uint64) **C.uint64_t { /* Slice */ if len(*x) > 0 { slc := (*C.uint64_t)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.uint64_t)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithSemaphoreCount(uint32(len(y)))
}

// PhysicalDevice8BitStorageFeatures provides a go interface for VkPhysicalDevice8BitStorageFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice8BitStorageFeatures.html
type PhysicalDevice8BitStorageFeatures C.struct_VkPhysicalDevice8BitStorageFeatures

// SizeofPhysicalDevice8BitStorageFeatures is the memory size of a PhysicalDevice8BitStorageFeatures
var SizeofPhysicalDevice8BitStorageFeatures int = int(unsafe.Sizeof(PhysicalDevice8BitStorageFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDevice8BitStorageFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDevice8BitStorageFeatures) AsCPtr() *PhysicalDevice8BitStorageFeatures {
	clone := (*PhysicalDevice8BitStorageFeatures)(newCBlock(C.ulong(SizeofPhysicalDevice8BitStorageFeatures)))
	*clone = x
	return clone
}

// PhysicalDevice8BitStorageFeaturesFreeCSlice releases the memory allocated by PhysicalDevice8BitStorageFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDevice8BitStorageFeaturesFreeCSlice(x []PhysicalDevice8BitStorageFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDevice8BitStorageFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDevice8BitStorageFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDevice8BitStorageFeaturesMakeCSlice(x ...PhysicalDevice8BitStorageFeatures) []PhysicalDevice8BitStorageFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDevice8BitStorageFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDevice8BitStorageFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDevice8BitStorageFeatures
func (x PhysicalDevice8BitStorageFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDevice8BitStorageFeatures) WithDefaultSType() PhysicalDevice8BitStorageFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice8BitStorageFeatures) WithSType(y StructureType) PhysicalDevice8BitStorageFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDevice8BitStorageFeatures
func (x PhysicalDevice8BitStorageFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice8BitStorageFeatures) WithPNext(y unsafe.Pointer) PhysicalDevice8BitStorageFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// StorageBuffer8BitAccess returns the value of storageBuffer8BitAccess from VkPhysicalDevice8BitStorageFeatures
func (x PhysicalDevice8BitStorageFeatures) StorageBuffer8BitAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storageBuffer8BitAccess) 
	return *ptr
}

// WithStorageBuffer8BitAccess sets the value for the StorageBuffer8BitAccess on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice8BitStorageFeatures) WithStorageBuffer8BitAccess(y Bool32) PhysicalDevice8BitStorageFeatures {
	x.storageBuffer8BitAccess = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// UniformAndStorageBuffer8BitAccess returns the value of uniformAndStorageBuffer8BitAccess from VkPhysicalDevice8BitStorageFeatures
func (x PhysicalDevice8BitStorageFeatures) UniformAndStorageBuffer8BitAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.uniformAndStorageBuffer8BitAccess) 
	return *ptr
}

// WithUniformAndStorageBuffer8BitAccess sets the value for the UniformAndStorageBuffer8BitAccess on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice8BitStorageFeatures) WithUniformAndStorageBuffer8BitAccess(y Bool32) PhysicalDevice8BitStorageFeatures {
	x.uniformAndStorageBuffer8BitAccess = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// StoragePushConstant8 returns the value of storagePushConstant8 from VkPhysicalDevice8BitStorageFeatures
func (x PhysicalDevice8BitStorageFeatures) StoragePushConstant8() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storagePushConstant8) 
	return *ptr
}

// WithStoragePushConstant8 sets the value for the StoragePushConstant8 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevice8BitStorageFeatures) WithStoragePushConstant8(y Bool32) PhysicalDevice8BitStorageFeatures {
	x.storagePushConstant8 = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// SemaphoreSignalInfo provides a go interface for VkSemaphoreSignalInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreSignalInfo.html
type SemaphoreSignalInfo C.struct_VkSemaphoreSignalInfo

// SizeofSemaphoreSignalInfo is the memory size of a SemaphoreSignalInfo
var SizeofSemaphoreSignalInfo int = int(unsafe.Sizeof(SemaphoreSignalInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SemaphoreSignalInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SemaphoreSignalInfo) AsCPtr() *SemaphoreSignalInfo {
	clone := (*SemaphoreSignalInfo)(newCBlock(C.ulong(SizeofSemaphoreSignalInfo)))
	*clone = x
	return clone
}

// SemaphoreSignalInfoFreeCSlice releases the memory allocated by SemaphoreSignalInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SemaphoreSignalInfoFreeCSlice(x []SemaphoreSignalInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SemaphoreSignalInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SemaphoreSignalInfoFreeCSlice must be called on the returned slice.
func SemaphoreSignalInfoMakeCSlice(x ...SemaphoreSignalInfo) []SemaphoreSignalInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSemaphoreSignalInfo * len(x)
	dst := unsafe.Slice((*SemaphoreSignalInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSemaphoreSignalInfo
func (x SemaphoreSignalInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SemaphoreSignalInfo) WithDefaultSType() SemaphoreSignalInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreSignalInfo) WithSType(y StructureType) SemaphoreSignalInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkSemaphoreSignalInfo
func (x SemaphoreSignalInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreSignalInfo) WithPNext(y unsafe.Pointer) SemaphoreSignalInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Semaphore returns the value of semaphore from VkSemaphoreSignalInfo
func (x SemaphoreSignalInfo) Semaphore() Semaphore {
	ptr := /* handle */ (*Semaphore)(&x.semaphore) 
	return *ptr
}

// WithSemaphore sets the value for the Semaphore on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreSignalInfo) WithSemaphore(y Semaphore) SemaphoreSignalInfo {
	x.semaphore = *(/* handle */ (*C.VkSemaphore)(&y))
	return x
}

// Value returns the value of value from VkSemaphoreSignalInfo
func (x SemaphoreSignalInfo) Value() uint64 {
	ptr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.value) 
	return *ptr
}

// WithValue sets the value for the Value on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreSignalInfo) WithValue(y uint64) SemaphoreSignalInfo {
	x.value = *(func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&y))
	return x
}

// ConformanceVersion provides a go interface for VkConformanceVersion.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkConformanceVersion.html
type ConformanceVersion C.struct_VkConformanceVersion

// SizeofConformanceVersion is the memory size of a ConformanceVersion
var SizeofConformanceVersion int = int(unsafe.Sizeof(ConformanceVersion{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ConformanceVersion) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ConformanceVersion) AsCPtr() *ConformanceVersion {
	clone := (*ConformanceVersion)(newCBlock(C.ulong(SizeofConformanceVersion)))
	*clone = x
	return clone
}

// ConformanceVersionFreeCSlice releases the memory allocated by ConformanceVersionMakeCSlice.
// It does not free pointers stored inside the slice.
func ConformanceVersionFreeCSlice(x []ConformanceVersion) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ConformanceVersionMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ConformanceVersionFreeCSlice must be called on the returned slice.
func ConformanceVersionMakeCSlice(x ...ConformanceVersion) []ConformanceVersion {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofConformanceVersion * len(x)
	dst := unsafe.Slice((*ConformanceVersion)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Major returns the value of major from VkConformanceVersion
func (x ConformanceVersion) Major() byte {
	ptr := func(x *C.uint8_t) *byte { /* Scalar */ c2g := byte(*x); return &c2g }(&x.major) 
	return *ptr
}

// WithMajor sets the value for the Major on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ConformanceVersion) WithMajor(y byte) ConformanceVersion {
	x.major = *(func(x *byte) *C.uint8_t { /* Scalar */ g2c := C.uint8_t(*x); return &g2c }(&y))
	return x
}

// Minor returns the value of minor from VkConformanceVersion
func (x ConformanceVersion) Minor() byte {
	ptr := func(x *C.uint8_t) *byte { /* Scalar */ c2g := byte(*x); return &c2g }(&x.minor) 
	return *ptr
}

// WithMinor sets the value for the Minor on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ConformanceVersion) WithMinor(y byte) ConformanceVersion {
	x.minor = *(func(x *byte) *C.uint8_t { /* Scalar */ g2c := C.uint8_t(*x); return &g2c }(&y))
	return x
}

// Subminor returns the value of subminor from VkConformanceVersion
func (x ConformanceVersion) Subminor() byte {
	ptr := func(x *C.uint8_t) *byte { /* Scalar */ c2g := byte(*x); return &c2g }(&x.subminor) 
	return *ptr
}

// WithSubminor sets the value for the Subminor on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ConformanceVersion) WithSubminor(y byte) ConformanceVersion {
	x.subminor = *(func(x *byte) *C.uint8_t { /* Scalar */ g2c := C.uint8_t(*x); return &g2c }(&y))
	return x
}

// Patch returns the value of patch from VkConformanceVersion
func (x ConformanceVersion) Patch() byte {
	ptr := func(x *C.uint8_t) *byte { /* Scalar */ c2g := byte(*x); return &c2g }(&x.patch) 
	return *ptr
}

// WithPatch sets the value for the Patch on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ConformanceVersion) WithPatch(y byte) ConformanceVersion {
	x.patch = *(func(x *byte) *C.uint8_t { /* Scalar */ g2c := C.uint8_t(*x); return &g2c }(&y))
	return x
}

// PhysicalDeviceDriverProperties provides a go interface for VkPhysicalDeviceDriverProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDriverProperties.html
type PhysicalDeviceDriverProperties C.struct_VkPhysicalDeviceDriverProperties

// SizeofPhysicalDeviceDriverProperties is the memory size of a PhysicalDeviceDriverProperties
var SizeofPhysicalDeviceDriverProperties int = int(unsafe.Sizeof(PhysicalDeviceDriverProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceDriverProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceDriverProperties) AsCPtr() *PhysicalDeviceDriverProperties {
	clone := (*PhysicalDeviceDriverProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceDriverProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceDriverPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceDriverPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceDriverPropertiesFreeCSlice(x []PhysicalDeviceDriverProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceDriverPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceDriverPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceDriverPropertiesMakeCSlice(x ...PhysicalDeviceDriverProperties) []PhysicalDeviceDriverProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceDriverProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceDriverProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceDriverProperties
func (x PhysicalDeviceDriverProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceDriverProperties) WithDefaultSType() PhysicalDeviceDriverProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDriverProperties) WithSType(y StructureType) PhysicalDeviceDriverProperties {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceDriverProperties
func (x PhysicalDeviceDriverProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDriverProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceDriverProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// DriverID returns the value of driverID from VkPhysicalDeviceDriverProperties
func (x PhysicalDeviceDriverProperties) DriverID() DriverId {
	ptr := /* typedef */ (*DriverId)(&x.driverID) 
	return *ptr
}

// DriverName returns the value of driverName from VkPhysicalDeviceDriverProperties
func (x PhysicalDeviceDriverProperties) DriverName() []byte {
	ptr := func(x *[VK_MAX_DRIVER_NAME_SIZE]C.char) *[]byte { /* Array */ slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_DRIVER_NAME_SIZE); return &slc }(&x.driverName) 
	return *ptr
}

// DriverInfo returns the value of driverInfo from VkPhysicalDeviceDriverProperties
func (x PhysicalDeviceDriverProperties) DriverInfo() []byte {
	ptr := func(x *[VK_MAX_DRIVER_INFO_SIZE]C.char) *[]byte { /* Array */ slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_DRIVER_INFO_SIZE); return &slc }(&x.driverInfo) 
	return *ptr
}

// ConformanceVersion returns the value of conformanceVersion from VkPhysicalDeviceDriverProperties
func (x PhysicalDeviceDriverProperties) ConformanceVersion() ConformanceVersion {
	ptr := /* typedef */ (*ConformanceVersion)(&x.conformanceVersion) 
	return *ptr
}

// PhysicalDeviceBufferDeviceAddressFeatures provides a go interface for VkPhysicalDeviceBufferDeviceAddressFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceBufferDeviceAddressFeatures.html
type PhysicalDeviceBufferDeviceAddressFeatures C.struct_VkPhysicalDeviceBufferDeviceAddressFeatures

// SizeofPhysicalDeviceBufferDeviceAddressFeatures is the memory size of a PhysicalDeviceBufferDeviceAddressFeatures
var SizeofPhysicalDeviceBufferDeviceAddressFeatures int = int(unsafe.Sizeof(PhysicalDeviceBufferDeviceAddressFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceBufferDeviceAddressFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceBufferDeviceAddressFeatures) AsCPtr() *PhysicalDeviceBufferDeviceAddressFeatures {
	clone := (*PhysicalDeviceBufferDeviceAddressFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceBufferDeviceAddressFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceBufferDeviceAddressFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceBufferDeviceAddressFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceBufferDeviceAddressFeaturesFreeCSlice(x []PhysicalDeviceBufferDeviceAddressFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceBufferDeviceAddressFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceBufferDeviceAddressFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceBufferDeviceAddressFeaturesMakeCSlice(x ...PhysicalDeviceBufferDeviceAddressFeatures) []PhysicalDeviceBufferDeviceAddressFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceBufferDeviceAddressFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceBufferDeviceAddressFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceBufferDeviceAddressFeatures
func (x PhysicalDeviceBufferDeviceAddressFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceBufferDeviceAddressFeatures) WithDefaultSType() PhysicalDeviceBufferDeviceAddressFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceBufferDeviceAddressFeatures) WithSType(y StructureType) PhysicalDeviceBufferDeviceAddressFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceBufferDeviceAddressFeatures
func (x PhysicalDeviceBufferDeviceAddressFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceBufferDeviceAddressFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceBufferDeviceAddressFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// BufferDeviceAddress returns the value of bufferDeviceAddress from VkPhysicalDeviceBufferDeviceAddressFeatures
func (x PhysicalDeviceBufferDeviceAddressFeatures) BufferDeviceAddress() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.bufferDeviceAddress) 
	return *ptr
}

// WithBufferDeviceAddress sets the value for the BufferDeviceAddress on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceBufferDeviceAddressFeatures) WithBufferDeviceAddress(y Bool32) PhysicalDeviceBufferDeviceAddressFeatures {
	x.bufferDeviceAddress = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// BufferDeviceAddressCaptureReplay returns the value of bufferDeviceAddressCaptureReplay from VkPhysicalDeviceBufferDeviceAddressFeatures
func (x PhysicalDeviceBufferDeviceAddressFeatures) BufferDeviceAddressCaptureReplay() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.bufferDeviceAddressCaptureReplay) 
	return *ptr
}

// WithBufferDeviceAddressCaptureReplay sets the value for the BufferDeviceAddressCaptureReplay on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceBufferDeviceAddressFeatures) WithBufferDeviceAddressCaptureReplay(y Bool32) PhysicalDeviceBufferDeviceAddressFeatures {
	x.bufferDeviceAddressCaptureReplay = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// BufferDeviceAddressMultiDevice returns the value of bufferDeviceAddressMultiDevice from VkPhysicalDeviceBufferDeviceAddressFeatures
func (x PhysicalDeviceBufferDeviceAddressFeatures) BufferDeviceAddressMultiDevice() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.bufferDeviceAddressMultiDevice) 
	return *ptr
}

// WithBufferDeviceAddressMultiDevice sets the value for the BufferDeviceAddressMultiDevice on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceBufferDeviceAddressFeatures) WithBufferDeviceAddressMultiDevice(y Bool32) PhysicalDeviceBufferDeviceAddressFeatures {
	x.bufferDeviceAddressMultiDevice = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// BufferDeviceAddressInfo provides a go interface for VkBufferDeviceAddressInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferDeviceAddressInfo.html
type BufferDeviceAddressInfo C.struct_VkBufferDeviceAddressInfo

// SizeofBufferDeviceAddressInfo is the memory size of a BufferDeviceAddressInfo
var SizeofBufferDeviceAddressInfo int = int(unsafe.Sizeof(BufferDeviceAddressInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferDeviceAddressInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferDeviceAddressInfo) AsCPtr() *BufferDeviceAddressInfo {
	clone := (*BufferDeviceAddressInfo)(newCBlock(C.ulong(SizeofBufferDeviceAddressInfo)))
	*clone = x
	return clone
}

// BufferDeviceAddressInfoFreeCSlice releases the memory allocated by BufferDeviceAddressInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BufferDeviceAddressInfoFreeCSlice(x []BufferDeviceAddressInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferDeviceAddressInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferDeviceAddressInfoFreeCSlice must be called on the returned slice.
func BufferDeviceAddressInfoMakeCSlice(x ...BufferDeviceAddressInfo) []BufferDeviceAddressInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferDeviceAddressInfo * len(x)
	dst := unsafe.Slice((*BufferDeviceAddressInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBufferDeviceAddressInfo
func (x BufferDeviceAddressInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BufferDeviceAddressInfo) WithDefaultSType() BufferDeviceAddressInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferDeviceAddressInfo) WithSType(y StructureType) BufferDeviceAddressInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkBufferDeviceAddressInfo
func (x BufferDeviceAddressInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferDeviceAddressInfo) WithPNext(y unsafe.Pointer) BufferDeviceAddressInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Buffer returns the value of buffer from VkBufferDeviceAddressInfo
func (x BufferDeviceAddressInfo) Buffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.buffer) 
	return *ptr
}

// WithBuffer sets the value for the Buffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferDeviceAddressInfo) WithBuffer(y Buffer) BufferDeviceAddressInfo {
	x.buffer = *(/* handle */ (*C.VkBuffer)(&y))
	return x
}

// PhysicalDeviceShaderAtomicInt64Features provides a go interface for VkPhysicalDeviceShaderAtomicInt64Features.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicInt64Features.html
type PhysicalDeviceShaderAtomicInt64Features C.struct_VkPhysicalDeviceShaderAtomicInt64Features

// SizeofPhysicalDeviceShaderAtomicInt64Features is the memory size of a PhysicalDeviceShaderAtomicInt64Features
var SizeofPhysicalDeviceShaderAtomicInt64Features int = int(unsafe.Sizeof(PhysicalDeviceShaderAtomicInt64Features{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceShaderAtomicInt64Features) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceShaderAtomicInt64Features) AsCPtr() *PhysicalDeviceShaderAtomicInt64Features {
	clone := (*PhysicalDeviceShaderAtomicInt64Features)(newCBlock(C.ulong(SizeofPhysicalDeviceShaderAtomicInt64Features)))
	*clone = x
	return clone
}

// PhysicalDeviceShaderAtomicInt64FeaturesFreeCSlice releases the memory allocated by PhysicalDeviceShaderAtomicInt64FeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceShaderAtomicInt64FeaturesFreeCSlice(x []PhysicalDeviceShaderAtomicInt64Features) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceShaderAtomicInt64FeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceShaderAtomicInt64FeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceShaderAtomicInt64FeaturesMakeCSlice(x ...PhysicalDeviceShaderAtomicInt64Features) []PhysicalDeviceShaderAtomicInt64Features {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderAtomicInt64Features * len(x)
	dst := unsafe.Slice((*PhysicalDeviceShaderAtomicInt64Features)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceShaderAtomicInt64Features
func (x PhysicalDeviceShaderAtomicInt64Features) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceShaderAtomicInt64Features) WithDefaultSType() PhysicalDeviceShaderAtomicInt64Features {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderAtomicInt64Features) WithSType(y StructureType) PhysicalDeviceShaderAtomicInt64Features {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceShaderAtomicInt64Features
func (x PhysicalDeviceShaderAtomicInt64Features) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderAtomicInt64Features) WithPNext(y unsafe.Pointer) PhysicalDeviceShaderAtomicInt64Features {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// ShaderBufferInt64Atomics returns the value of shaderBufferInt64Atomics from VkPhysicalDeviceShaderAtomicInt64Features
func (x PhysicalDeviceShaderAtomicInt64Features) ShaderBufferInt64Atomics() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderBufferInt64Atomics) 
	return *ptr
}

// WithShaderBufferInt64Atomics sets the value for the ShaderBufferInt64Atomics on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderAtomicInt64Features) WithShaderBufferInt64Atomics(y Bool32) PhysicalDeviceShaderAtomicInt64Features {
	x.shaderBufferInt64Atomics = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderSharedInt64Atomics returns the value of shaderSharedInt64Atomics from VkPhysicalDeviceShaderAtomicInt64Features
func (x PhysicalDeviceShaderAtomicInt64Features) ShaderSharedInt64Atomics() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSharedInt64Atomics) 
	return *ptr
}

// WithShaderSharedInt64Atomics sets the value for the ShaderSharedInt64Atomics on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderAtomicInt64Features) WithShaderSharedInt64Atomics(y Bool32) PhysicalDeviceShaderAtomicInt64Features {
	x.shaderSharedInt64Atomics = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// PhysicalDeviceShaderFloat16Int8Features provides a go interface for VkPhysicalDeviceShaderFloat16Int8Features.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderFloat16Int8Features.html
type PhysicalDeviceShaderFloat16Int8Features C.struct_VkPhysicalDeviceShaderFloat16Int8Features

// SizeofPhysicalDeviceShaderFloat16Int8Features is the memory size of a PhysicalDeviceShaderFloat16Int8Features
var SizeofPhysicalDeviceShaderFloat16Int8Features int = int(unsafe.Sizeof(PhysicalDeviceShaderFloat16Int8Features{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceShaderFloat16Int8Features) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceShaderFloat16Int8Features) AsCPtr() *PhysicalDeviceShaderFloat16Int8Features {
	clone := (*PhysicalDeviceShaderFloat16Int8Features)(newCBlock(C.ulong(SizeofPhysicalDeviceShaderFloat16Int8Features)))
	*clone = x
	return clone
}

// PhysicalDeviceShaderFloat16Int8FeaturesFreeCSlice releases the memory allocated by PhysicalDeviceShaderFloat16Int8FeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceShaderFloat16Int8FeaturesFreeCSlice(x []PhysicalDeviceShaderFloat16Int8Features) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceShaderFloat16Int8FeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceShaderFloat16Int8FeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceShaderFloat16Int8FeaturesMakeCSlice(x ...PhysicalDeviceShaderFloat16Int8Features) []PhysicalDeviceShaderFloat16Int8Features {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderFloat16Int8Features * len(x)
	dst := unsafe.Slice((*PhysicalDeviceShaderFloat16Int8Features)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceShaderFloat16Int8Features
func (x PhysicalDeviceShaderFloat16Int8Features) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceShaderFloat16Int8Features) WithDefaultSType() PhysicalDeviceShaderFloat16Int8Features {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderFloat16Int8Features) WithSType(y StructureType) PhysicalDeviceShaderFloat16Int8Features {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceShaderFloat16Int8Features
func (x PhysicalDeviceShaderFloat16Int8Features) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderFloat16Int8Features) WithPNext(y unsafe.Pointer) PhysicalDeviceShaderFloat16Int8Features {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// ShaderFloat16 returns the value of shaderFloat16 from VkPhysicalDeviceShaderFloat16Int8Features
func (x PhysicalDeviceShaderFloat16Int8Features) ShaderFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderFloat16) 
	return *ptr
}

// WithShaderFloat16 sets the value for the ShaderFloat16 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderFloat16Int8Features) WithShaderFloat16(y Bool32) PhysicalDeviceShaderFloat16Int8Features {
	x.shaderFloat16 = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderInt8 returns the value of shaderInt8 from VkPhysicalDeviceShaderFloat16Int8Features
func (x PhysicalDeviceShaderFloat16Int8Features) ShaderInt8() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInt8) 
	return *ptr
}

// WithShaderInt8 sets the value for the ShaderInt8 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderFloat16Int8Features) WithShaderInt8(y Bool32) PhysicalDeviceShaderFloat16Int8Features {
	x.shaderInt8 = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// PhysicalDeviceFloatControlsProperties provides a go interface for VkPhysicalDeviceFloatControlsProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFloatControlsProperties.html
type PhysicalDeviceFloatControlsProperties C.struct_VkPhysicalDeviceFloatControlsProperties

// SizeofPhysicalDeviceFloatControlsProperties is the memory size of a PhysicalDeviceFloatControlsProperties
var SizeofPhysicalDeviceFloatControlsProperties int = int(unsafe.Sizeof(PhysicalDeviceFloatControlsProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceFloatControlsProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceFloatControlsProperties) AsCPtr() *PhysicalDeviceFloatControlsProperties {
	clone := (*PhysicalDeviceFloatControlsProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceFloatControlsProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceFloatControlsPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceFloatControlsPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceFloatControlsPropertiesFreeCSlice(x []PhysicalDeviceFloatControlsProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceFloatControlsPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceFloatControlsPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceFloatControlsPropertiesMakeCSlice(x ...PhysicalDeviceFloatControlsProperties) []PhysicalDeviceFloatControlsProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceFloatControlsProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceFloatControlsProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceFloatControlsProperties) WithDefaultSType() PhysicalDeviceFloatControlsProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFloatControlsProperties) WithSType(y StructureType) PhysicalDeviceFloatControlsProperties {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceFloatControlsProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceFloatControlsProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// DenormBehaviorIndependence returns the value of denormBehaviorIndependence from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) DenormBehaviorIndependence() ShaderFloatControlsIndependence {
	ptr := /* typedef */ (*ShaderFloatControlsIndependence)(&x.denormBehaviorIndependence) 
	return *ptr
}

// RoundingModeIndependence returns the value of roundingModeIndependence from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) RoundingModeIndependence() ShaderFloatControlsIndependence {
	ptr := /* typedef */ (*ShaderFloatControlsIndependence)(&x.roundingModeIndependence) 
	return *ptr
}

// ShaderSignedZeroInfNanPreserveFloat16 returns the value of shaderSignedZeroInfNanPreserveFloat16 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderSignedZeroInfNanPreserveFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSignedZeroInfNanPreserveFloat16) 
	return *ptr
}

// ShaderSignedZeroInfNanPreserveFloat32 returns the value of shaderSignedZeroInfNanPreserveFloat32 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderSignedZeroInfNanPreserveFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSignedZeroInfNanPreserveFloat32) 
	return *ptr
}

// ShaderSignedZeroInfNanPreserveFloat64 returns the value of shaderSignedZeroInfNanPreserveFloat64 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderSignedZeroInfNanPreserveFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSignedZeroInfNanPreserveFloat64) 
	return *ptr
}

// ShaderDenormPreserveFloat16 returns the value of shaderDenormPreserveFloat16 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderDenormPreserveFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormPreserveFloat16) 
	return *ptr
}

// ShaderDenormPreserveFloat32 returns the value of shaderDenormPreserveFloat32 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderDenormPreserveFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormPreserveFloat32) 
	return *ptr
}

// ShaderDenormPreserveFloat64 returns the value of shaderDenormPreserveFloat64 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderDenormPreserveFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormPreserveFloat64) 
	return *ptr
}

// ShaderDenormFlushToZeroFloat16 returns the value of shaderDenormFlushToZeroFloat16 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderDenormFlushToZeroFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormFlushToZeroFloat16) 
	return *ptr
}

// ShaderDenormFlushToZeroFloat32 returns the value of shaderDenormFlushToZeroFloat32 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderDenormFlushToZeroFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormFlushToZeroFloat32) 
	return *ptr
}

// ShaderDenormFlushToZeroFloat64 returns the value of shaderDenormFlushToZeroFloat64 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderDenormFlushToZeroFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormFlushToZeroFloat64) 
	return *ptr
}

// ShaderRoundingModeRTEFloat16 returns the value of shaderRoundingModeRTEFloat16 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderRoundingModeRTEFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTEFloat16) 
	return *ptr
}

// ShaderRoundingModeRTEFloat32 returns the value of shaderRoundingModeRTEFloat32 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderRoundingModeRTEFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTEFloat32) 
	return *ptr
}

// ShaderRoundingModeRTEFloat64 returns the value of shaderRoundingModeRTEFloat64 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderRoundingModeRTEFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTEFloat64) 
	return *ptr
}

// ShaderRoundingModeRTZFloat16 returns the value of shaderRoundingModeRTZFloat16 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderRoundingModeRTZFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTZFloat16) 
	return *ptr
}

// ShaderRoundingModeRTZFloat32 returns the value of shaderRoundingModeRTZFloat32 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderRoundingModeRTZFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTZFloat32) 
	return *ptr
}

// ShaderRoundingModeRTZFloat64 returns the value of shaderRoundingModeRTZFloat64 from VkPhysicalDeviceFloatControlsProperties
func (x PhysicalDeviceFloatControlsProperties) ShaderRoundingModeRTZFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTZFloat64) 
	return *ptr
}

// BufferOpaqueCaptureAddressCreateInfo provides a go interface for VkBufferOpaqueCaptureAddressCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferOpaqueCaptureAddressCreateInfo.html
type BufferOpaqueCaptureAddressCreateInfo C.struct_VkBufferOpaqueCaptureAddressCreateInfo

// SizeofBufferOpaqueCaptureAddressCreateInfo is the memory size of a BufferOpaqueCaptureAddressCreateInfo
var SizeofBufferOpaqueCaptureAddressCreateInfo int = int(unsafe.Sizeof(BufferOpaqueCaptureAddressCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferOpaqueCaptureAddressCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferOpaqueCaptureAddressCreateInfo) AsCPtr() *BufferOpaqueCaptureAddressCreateInfo {
	clone := (*BufferOpaqueCaptureAddressCreateInfo)(newCBlock(C.ulong(SizeofBufferOpaqueCaptureAddressCreateInfo)))
	*clone = x
	return clone
}

// BufferOpaqueCaptureAddressCreateInfoFreeCSlice releases the memory allocated by BufferOpaqueCaptureAddressCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func BufferOpaqueCaptureAddressCreateInfoFreeCSlice(x []BufferOpaqueCaptureAddressCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferOpaqueCaptureAddressCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferOpaqueCaptureAddressCreateInfoFreeCSlice must be called on the returned slice.
func BufferOpaqueCaptureAddressCreateInfoMakeCSlice(x ...BufferOpaqueCaptureAddressCreateInfo) []BufferOpaqueCaptureAddressCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferOpaqueCaptureAddressCreateInfo * len(x)
	dst := unsafe.Slice((*BufferOpaqueCaptureAddressCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBufferOpaqueCaptureAddressCreateInfo
func (x BufferOpaqueCaptureAddressCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BufferOpaqueCaptureAddressCreateInfo) WithDefaultSType() BufferOpaqueCaptureAddressCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferOpaqueCaptureAddressCreateInfo) WithSType(y StructureType) BufferOpaqueCaptureAddressCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkBufferOpaqueCaptureAddressCreateInfo
func (x BufferOpaqueCaptureAddressCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferOpaqueCaptureAddressCreateInfo) WithPNext(y unsafe.Pointer) BufferOpaqueCaptureAddressCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// OpaqueCaptureAddress returns the value of opaqueCaptureAddress from VkBufferOpaqueCaptureAddressCreateInfo
func (x BufferOpaqueCaptureAddressCreateInfo) OpaqueCaptureAddress() uint64 {
	ptr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.opaqueCaptureAddress) 
	return *ptr
}

// WithOpaqueCaptureAddress sets the value for the OpaqueCaptureAddress on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferOpaqueCaptureAddressCreateInfo) WithOpaqueCaptureAddress(y uint64) BufferOpaqueCaptureAddressCreateInfo {
	x.opaqueCaptureAddress = *(func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&y))
	return x
}

// MemoryOpaqueCaptureAddressAllocateInfo provides a go interface for VkMemoryOpaqueCaptureAddressAllocateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryOpaqueCaptureAddressAllocateInfo.html
type MemoryOpaqueCaptureAddressAllocateInfo C.struct_VkMemoryOpaqueCaptureAddressAllocateInfo

// SizeofMemoryOpaqueCaptureAddressAllocateInfo is the memory size of a MemoryOpaqueCaptureAddressAllocateInfo
var SizeofMemoryOpaqueCaptureAddressAllocateInfo int = int(unsafe.Sizeof(MemoryOpaqueCaptureAddressAllocateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryOpaqueCaptureAddressAllocateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryOpaqueCaptureAddressAllocateInfo) AsCPtr() *MemoryOpaqueCaptureAddressAllocateInfo {
	clone := (*MemoryOpaqueCaptureAddressAllocateInfo)(newCBlock(C.ulong(SizeofMemoryOpaqueCaptureAddressAllocateInfo)))
	*clone = x
	return clone
}

// MemoryOpaqueCaptureAddressAllocateInfoFreeCSlice releases the memory allocated by MemoryOpaqueCaptureAddressAllocateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryOpaqueCaptureAddressAllocateInfoFreeCSlice(x []MemoryOpaqueCaptureAddressAllocateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryOpaqueCaptureAddressAllocateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryOpaqueCaptureAddressAllocateInfoFreeCSlice must be called on the returned slice.
func MemoryOpaqueCaptureAddressAllocateInfoMakeCSlice(x ...MemoryOpaqueCaptureAddressAllocateInfo) []MemoryOpaqueCaptureAddressAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryOpaqueCaptureAddressAllocateInfo * len(x)
	dst := unsafe.Slice((*MemoryOpaqueCaptureAddressAllocateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkMemoryOpaqueCaptureAddressAllocateInfo
func (x MemoryOpaqueCaptureAddressAllocateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x MemoryOpaqueCaptureAddressAllocateInfo) WithDefaultSType() MemoryOpaqueCaptureAddressAllocateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryOpaqueCaptureAddressAllocateInfo) WithSType(y StructureType) MemoryOpaqueCaptureAddressAllocateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkMemoryOpaqueCaptureAddressAllocateInfo
func (x MemoryOpaqueCaptureAddressAllocateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryOpaqueCaptureAddressAllocateInfo) WithPNext(y unsafe.Pointer) MemoryOpaqueCaptureAddressAllocateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// OpaqueCaptureAddress returns the value of opaqueCaptureAddress from VkMemoryOpaqueCaptureAddressAllocateInfo
func (x MemoryOpaqueCaptureAddressAllocateInfo) OpaqueCaptureAddress() uint64 {
	ptr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.opaqueCaptureAddress) 
	return *ptr
}

// WithOpaqueCaptureAddress sets the value for the OpaqueCaptureAddress on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryOpaqueCaptureAddressAllocateInfo) WithOpaqueCaptureAddress(y uint64) MemoryOpaqueCaptureAddressAllocateInfo {
	x.opaqueCaptureAddress = *(func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&y))
	return x
}

// PhysicalDeviceDescriptorIndexingFeatures provides a go interface for VkPhysicalDeviceDescriptorIndexingFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDescriptorIndexingFeatures.html
type PhysicalDeviceDescriptorIndexingFeatures C.struct_VkPhysicalDeviceDescriptorIndexingFeatures

// SizeofPhysicalDeviceDescriptorIndexingFeatures is the memory size of a PhysicalDeviceDescriptorIndexingFeatures
var SizeofPhysicalDeviceDescriptorIndexingFeatures int = int(unsafe.Sizeof(PhysicalDeviceDescriptorIndexingFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceDescriptorIndexingFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceDescriptorIndexingFeatures) AsCPtr() *PhysicalDeviceDescriptorIndexingFeatures {
	clone := (*PhysicalDeviceDescriptorIndexingFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceDescriptorIndexingFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceDescriptorIndexingFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceDescriptorIndexingFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceDescriptorIndexingFeaturesFreeCSlice(x []PhysicalDeviceDescriptorIndexingFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceDescriptorIndexingFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceDescriptorIndexingFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceDescriptorIndexingFeaturesMakeCSlice(x ...PhysicalDeviceDescriptorIndexingFeatures) []PhysicalDeviceDescriptorIndexingFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceDescriptorIndexingFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceDescriptorIndexingFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDefaultSType() PhysicalDeviceDescriptorIndexingFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithSType(y StructureType) PhysicalDeviceDescriptorIndexingFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceDescriptorIndexingFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// ShaderInputAttachmentArrayDynamicIndexing returns the value of shaderInputAttachmentArrayDynamicIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderInputAttachmentArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInputAttachmentArrayDynamicIndexing) 
	return *ptr
}

// WithShaderInputAttachmentArrayDynamicIndexing sets the value for the ShaderInputAttachmentArrayDynamicIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderInputAttachmentArrayDynamicIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.shaderInputAttachmentArrayDynamicIndexing = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderUniformTexelBufferArrayDynamicIndexing returns the value of shaderUniformTexelBufferArrayDynamicIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderUniformTexelBufferArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderUniformTexelBufferArrayDynamicIndexing) 
	return *ptr
}

// WithShaderUniformTexelBufferArrayDynamicIndexing sets the value for the ShaderUniformTexelBufferArrayDynamicIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderUniformTexelBufferArrayDynamicIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.shaderUniformTexelBufferArrayDynamicIndexing = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderStorageTexelBufferArrayDynamicIndexing returns the value of shaderStorageTexelBufferArrayDynamicIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderStorageTexelBufferArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageTexelBufferArrayDynamicIndexing) 
	return *ptr
}

// WithShaderStorageTexelBufferArrayDynamicIndexing sets the value for the ShaderStorageTexelBufferArrayDynamicIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderStorageTexelBufferArrayDynamicIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.shaderStorageTexelBufferArrayDynamicIndexing = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderUniformBufferArrayNonUniformIndexing returns the value of shaderUniformBufferArrayNonUniformIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderUniformBufferArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderUniformBufferArrayNonUniformIndexing) 
	return *ptr
}

// WithShaderUniformBufferArrayNonUniformIndexing sets the value for the ShaderUniformBufferArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderUniformBufferArrayNonUniformIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.shaderUniformBufferArrayNonUniformIndexing = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderSampledImageArrayNonUniformIndexing returns the value of shaderSampledImageArrayNonUniformIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderSampledImageArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSampledImageArrayNonUniformIndexing) 
	return *ptr
}

// WithShaderSampledImageArrayNonUniformIndexing sets the value for the ShaderSampledImageArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderSampledImageArrayNonUniformIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.shaderSampledImageArrayNonUniformIndexing = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderStorageBufferArrayNonUniformIndexing returns the value of shaderStorageBufferArrayNonUniformIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderStorageBufferArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageBufferArrayNonUniformIndexing) 
	return *ptr
}

// WithShaderStorageBufferArrayNonUniformIndexing sets the value for the ShaderStorageBufferArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderStorageBufferArrayNonUniformIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.shaderStorageBufferArrayNonUniformIndexing = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderStorageImageArrayNonUniformIndexing returns the value of shaderStorageImageArrayNonUniformIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderStorageImageArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageImageArrayNonUniformIndexing) 
	return *ptr
}

// WithShaderStorageImageArrayNonUniformIndexing sets the value for the ShaderStorageImageArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderStorageImageArrayNonUniformIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.shaderStorageImageArrayNonUniformIndexing = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderInputAttachmentArrayNonUniformIndexing returns the value of shaderInputAttachmentArrayNonUniformIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderInputAttachmentArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInputAttachmentArrayNonUniformIndexing) 
	return *ptr
}

// WithShaderInputAttachmentArrayNonUniformIndexing sets the value for the ShaderInputAttachmentArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderInputAttachmentArrayNonUniformIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.shaderInputAttachmentArrayNonUniformIndexing = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderUniformTexelBufferArrayNonUniformIndexing returns the value of shaderUniformTexelBufferArrayNonUniformIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderUniformTexelBufferArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderUniformTexelBufferArrayNonUniformIndexing) 
	return *ptr
}

// WithShaderUniformTexelBufferArrayNonUniformIndexing sets the value for the ShaderUniformTexelBufferArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderUniformTexelBufferArrayNonUniformIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.shaderUniformTexelBufferArrayNonUniformIndexing = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderStorageTexelBufferArrayNonUniformIndexing returns the value of shaderStorageTexelBufferArrayNonUniformIndexing from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) ShaderStorageTexelBufferArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageTexelBufferArrayNonUniformIndexing) 
	return *ptr
}

// WithShaderStorageTexelBufferArrayNonUniformIndexing sets the value for the ShaderStorageTexelBufferArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithShaderStorageTexelBufferArrayNonUniformIndexing(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.shaderStorageTexelBufferArrayNonUniformIndexing = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DescriptorBindingUniformBufferUpdateAfterBind returns the value of descriptorBindingUniformBufferUpdateAfterBind from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) DescriptorBindingUniformBufferUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingUniformBufferUpdateAfterBind) 
	return *ptr
}

// WithDescriptorBindingUniformBufferUpdateAfterBind sets the value for the DescriptorBindingUniformBufferUpdateAfterBind on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDescriptorBindingUniformBufferUpdateAfterBind(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.descriptorBindingUniformBufferUpdateAfterBind = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DescriptorBindingSampledImageUpdateAfterBind returns the value of descriptorBindingSampledImageUpdateAfterBind from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) DescriptorBindingSampledImageUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingSampledImageUpdateAfterBind) 
	return *ptr
}

// WithDescriptorBindingSampledImageUpdateAfterBind sets the value for the DescriptorBindingSampledImageUpdateAfterBind on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDescriptorBindingSampledImageUpdateAfterBind(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.descriptorBindingSampledImageUpdateAfterBind = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DescriptorBindingStorageImageUpdateAfterBind returns the value of descriptorBindingStorageImageUpdateAfterBind from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) DescriptorBindingStorageImageUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingStorageImageUpdateAfterBind) 
	return *ptr
}

// WithDescriptorBindingStorageImageUpdateAfterBind sets the value for the DescriptorBindingStorageImageUpdateAfterBind on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDescriptorBindingStorageImageUpdateAfterBind(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.descriptorBindingStorageImageUpdateAfterBind = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DescriptorBindingStorageBufferUpdateAfterBind returns the value of descriptorBindingStorageBufferUpdateAfterBind from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) DescriptorBindingStorageBufferUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingStorageBufferUpdateAfterBind) 
	return *ptr
}

// WithDescriptorBindingStorageBufferUpdateAfterBind sets the value for the DescriptorBindingStorageBufferUpdateAfterBind on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDescriptorBindingStorageBufferUpdateAfterBind(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.descriptorBindingStorageBufferUpdateAfterBind = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DescriptorBindingUniformTexelBufferUpdateAfterBind returns the value of descriptorBindingUniformTexelBufferUpdateAfterBind from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) DescriptorBindingUniformTexelBufferUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingUniformTexelBufferUpdateAfterBind) 
	return *ptr
}

// WithDescriptorBindingUniformTexelBufferUpdateAfterBind sets the value for the DescriptorBindingUniformTexelBufferUpdateAfterBind on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDescriptorBindingUniformTexelBufferUpdateAfterBind(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.descriptorBindingUniformTexelBufferUpdateAfterBind = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DescriptorBindingStorageTexelBufferUpdateAfterBind returns the value of descriptorBindingStorageTexelBufferUpdateAfterBind from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) DescriptorBindingStorageTexelBufferUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingStorageTexelBufferUpdateAfterBind) 
	return *ptr
}

// WithDescriptorBindingStorageTexelBufferUpdateAfterBind sets the value for the DescriptorBindingStorageTexelBufferUpdateAfterBind on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDescriptorBindingStorageTexelBufferUpdateAfterBind(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.descriptorBindingStorageTexelBufferUpdateAfterBind = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DescriptorBindingUpdateUnusedWhilePending returns the value of descriptorBindingUpdateUnusedWhilePending from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) DescriptorBindingUpdateUnusedWhilePending() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingUpdateUnusedWhilePending) 
	return *ptr
}

// WithDescriptorBindingUpdateUnusedWhilePending sets the value for the DescriptorBindingUpdateUnusedWhilePending on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDescriptorBindingUpdateUnusedWhilePending(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.descriptorBindingUpdateUnusedWhilePending = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DescriptorBindingPartiallyBound returns the value of descriptorBindingPartiallyBound from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) DescriptorBindingPartiallyBound() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingPartiallyBound) 
	return *ptr
}

// WithDescriptorBindingPartiallyBound sets the value for the DescriptorBindingPartiallyBound on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDescriptorBindingPartiallyBound(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.descriptorBindingPartiallyBound = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DescriptorBindingVariableDescriptorCount returns the value of descriptorBindingVariableDescriptorCount from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) DescriptorBindingVariableDescriptorCount() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingVariableDescriptorCount) 
	return *ptr
}

// WithDescriptorBindingVariableDescriptorCount sets the value for the DescriptorBindingVariableDescriptorCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithDescriptorBindingVariableDescriptorCount(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.descriptorBindingVariableDescriptorCount = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// RuntimeDescriptorArray returns the value of runtimeDescriptorArray from VkPhysicalDeviceDescriptorIndexingFeatures
func (x PhysicalDeviceDescriptorIndexingFeatures) RuntimeDescriptorArray() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.runtimeDescriptorArray) 
	return *ptr
}

// WithRuntimeDescriptorArray sets the value for the RuntimeDescriptorArray on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingFeatures) WithRuntimeDescriptorArray(y Bool32) PhysicalDeviceDescriptorIndexingFeatures {
	x.runtimeDescriptorArray = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// PhysicalDeviceDescriptorIndexingProperties provides a go interface for VkPhysicalDeviceDescriptorIndexingProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDescriptorIndexingProperties.html
type PhysicalDeviceDescriptorIndexingProperties C.struct_VkPhysicalDeviceDescriptorIndexingProperties

// SizeofPhysicalDeviceDescriptorIndexingProperties is the memory size of a PhysicalDeviceDescriptorIndexingProperties
var SizeofPhysicalDeviceDescriptorIndexingProperties int = int(unsafe.Sizeof(PhysicalDeviceDescriptorIndexingProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceDescriptorIndexingProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceDescriptorIndexingProperties) AsCPtr() *PhysicalDeviceDescriptorIndexingProperties {
	clone := (*PhysicalDeviceDescriptorIndexingProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceDescriptorIndexingProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceDescriptorIndexingPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceDescriptorIndexingPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceDescriptorIndexingPropertiesFreeCSlice(x []PhysicalDeviceDescriptorIndexingProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceDescriptorIndexingPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceDescriptorIndexingPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceDescriptorIndexingPropertiesMakeCSlice(x ...PhysicalDeviceDescriptorIndexingProperties) []PhysicalDeviceDescriptorIndexingProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceDescriptorIndexingProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceDescriptorIndexingProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceDescriptorIndexingProperties) WithDefaultSType() PhysicalDeviceDescriptorIndexingProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingProperties) WithSType(y StructureType) PhysicalDeviceDescriptorIndexingProperties {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDescriptorIndexingProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceDescriptorIndexingProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// MaxUpdateAfterBindDescriptorsInAllPools returns the value of maxUpdateAfterBindDescriptorsInAllPools from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxUpdateAfterBindDescriptorsInAllPools() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxUpdateAfterBindDescriptorsInAllPools) 
	return *ptr
}

// ShaderUniformBufferArrayNonUniformIndexingNative returns the value of shaderUniformBufferArrayNonUniformIndexingNative from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) ShaderUniformBufferArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderUniformBufferArrayNonUniformIndexingNative) 
	return *ptr
}

// ShaderSampledImageArrayNonUniformIndexingNative returns the value of shaderSampledImageArrayNonUniformIndexingNative from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) ShaderSampledImageArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSampledImageArrayNonUniformIndexingNative) 
	return *ptr
}

// ShaderStorageBufferArrayNonUniformIndexingNative returns the value of shaderStorageBufferArrayNonUniformIndexingNative from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) ShaderStorageBufferArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageBufferArrayNonUniformIndexingNative) 
	return *ptr
}

// ShaderStorageImageArrayNonUniformIndexingNative returns the value of shaderStorageImageArrayNonUniformIndexingNative from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) ShaderStorageImageArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageImageArrayNonUniformIndexingNative) 
	return *ptr
}

// ShaderInputAttachmentArrayNonUniformIndexingNative returns the value of shaderInputAttachmentArrayNonUniformIndexingNative from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) ShaderInputAttachmentArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInputAttachmentArrayNonUniformIndexingNative) 
	return *ptr
}

// RobustBufferAccessUpdateAfterBind returns the value of robustBufferAccessUpdateAfterBind from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) RobustBufferAccessUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.robustBufferAccessUpdateAfterBind) 
	return *ptr
}

// QuadDivergentImplicitLod returns the value of quadDivergentImplicitLod from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) QuadDivergentImplicitLod() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.quadDivergentImplicitLod) 
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindSamplers returns the value of maxPerStageDescriptorUpdateAfterBindSamplers from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxPerStageDescriptorUpdateAfterBindSamplers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindSamplers) 
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindUniformBuffers returns the value of maxPerStageDescriptorUpdateAfterBindUniformBuffers from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxPerStageDescriptorUpdateAfterBindUniformBuffers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindUniformBuffers) 
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindStorageBuffers returns the value of maxPerStageDescriptorUpdateAfterBindStorageBuffers from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxPerStageDescriptorUpdateAfterBindStorageBuffers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindStorageBuffers) 
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindSampledImages returns the value of maxPerStageDescriptorUpdateAfterBindSampledImages from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxPerStageDescriptorUpdateAfterBindSampledImages() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindSampledImages) 
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindStorageImages returns the value of maxPerStageDescriptorUpdateAfterBindStorageImages from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxPerStageDescriptorUpdateAfterBindStorageImages() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindStorageImages) 
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindInputAttachments returns the value of maxPerStageDescriptorUpdateAfterBindInputAttachments from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxPerStageDescriptorUpdateAfterBindInputAttachments() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindInputAttachments) 
	return *ptr
}

// MaxPerStageUpdateAfterBindResources returns the value of maxPerStageUpdateAfterBindResources from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxPerStageUpdateAfterBindResources() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageUpdateAfterBindResources) 
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindSamplers returns the value of maxDescriptorSetUpdateAfterBindSamplers from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxDescriptorSetUpdateAfterBindSamplers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindSamplers) 
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindUniformBuffers returns the value of maxDescriptorSetUpdateAfterBindUniformBuffers from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxDescriptorSetUpdateAfterBindUniformBuffers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindUniformBuffers) 
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic returns the value of maxDescriptorSetUpdateAfterBindUniformBuffersDynamic from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic) 
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindStorageBuffers returns the value of maxDescriptorSetUpdateAfterBindStorageBuffers from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxDescriptorSetUpdateAfterBindStorageBuffers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindStorageBuffers) 
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic returns the value of maxDescriptorSetUpdateAfterBindStorageBuffersDynamic from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic) 
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindSampledImages returns the value of maxDescriptorSetUpdateAfterBindSampledImages from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxDescriptorSetUpdateAfterBindSampledImages() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindSampledImages) 
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindStorageImages returns the value of maxDescriptorSetUpdateAfterBindStorageImages from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxDescriptorSetUpdateAfterBindStorageImages() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindStorageImages) 
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindInputAttachments returns the value of maxDescriptorSetUpdateAfterBindInputAttachments from VkPhysicalDeviceDescriptorIndexingProperties
func (x PhysicalDeviceDescriptorIndexingProperties) MaxDescriptorSetUpdateAfterBindInputAttachments() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindInputAttachments) 
	return *ptr
}

// DescriptorSetVariableDescriptorCountAllocateInfo provides a go interface for VkDescriptorSetVariableDescriptorCountAllocateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetVariableDescriptorCountAllocateInfo.html
type DescriptorSetVariableDescriptorCountAllocateInfo C.struct_VkDescriptorSetVariableDescriptorCountAllocateInfo

// SizeofDescriptorSetVariableDescriptorCountAllocateInfo is the memory size of a DescriptorSetVariableDescriptorCountAllocateInfo
var SizeofDescriptorSetVariableDescriptorCountAllocateInfo int = int(unsafe.Sizeof(DescriptorSetVariableDescriptorCountAllocateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorSetVariableDescriptorCountAllocateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorSetVariableDescriptorCountAllocateInfo) AsCPtr() *DescriptorSetVariableDescriptorCountAllocateInfo {
	clone := (*DescriptorSetVariableDescriptorCountAllocateInfo)(newCBlock(C.ulong(SizeofDescriptorSetVariableDescriptorCountAllocateInfo)))
	*clone = x
	return clone
}

// DescriptorSetVariableDescriptorCountAllocateInfoFreeCSlice releases the memory allocated by DescriptorSetVariableDescriptorCountAllocateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorSetVariableDescriptorCountAllocateInfoFreeCSlice(x []DescriptorSetVariableDescriptorCountAllocateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorSetVariableDescriptorCountAllocateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorSetVariableDescriptorCountAllocateInfoFreeCSlice must be called on the returned slice.
func DescriptorSetVariableDescriptorCountAllocateInfoMakeCSlice(x ...DescriptorSetVariableDescriptorCountAllocateInfo) []DescriptorSetVariableDescriptorCountAllocateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetVariableDescriptorCountAllocateInfo * len(x)
	dst := unsafe.Slice((*DescriptorSetVariableDescriptorCountAllocateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDescriptorSetVariableDescriptorCountAllocateInfo
func (x DescriptorSetVariableDescriptorCountAllocateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DescriptorSetVariableDescriptorCountAllocateInfo) WithDefaultSType() DescriptorSetVariableDescriptorCountAllocateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetVariableDescriptorCountAllocateInfo) WithSType(y StructureType) DescriptorSetVariableDescriptorCountAllocateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDescriptorSetVariableDescriptorCountAllocateInfo
func (x DescriptorSetVariableDescriptorCountAllocateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetVariableDescriptorCountAllocateInfo) WithPNext(y unsafe.Pointer) DescriptorSetVariableDescriptorCountAllocateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// DescriptorSetCount returns the value of descriptorSetCount from VkDescriptorSetVariableDescriptorCountAllocateInfo
func (x DescriptorSetVariableDescriptorCountAllocateInfo) DescriptorSetCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.descriptorSetCount) 
	return *ptr
}

// WithDescriptorSetCount sets the value for the DescriptorSetCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetVariableDescriptorCountAllocateInfo) WithDescriptorSetCount(y uint32) DescriptorSetVariableDescriptorCountAllocateInfo {
	x.descriptorSetCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PDescriptorCounts returns the value of pDescriptorCounts from VkDescriptorSetVariableDescriptorCountAllocateInfo
func (x DescriptorSetVariableDescriptorCountAllocateInfo) PDescriptorCounts() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */ slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pDescriptorCounts) 
	return *ptr
}

// WithPDescriptorCounts sets the value for the PDescriptorCounts on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines DescriptorSetCount as the length of this field.
// DescriptorSetCount is updated with the length of the new value.
func (x DescriptorSetVariableDescriptorCountAllocateInfo) WithPDescriptorCounts(y []uint32) DescriptorSetVariableDescriptorCountAllocateInfo {
	x.pDescriptorCounts = *(func(x *[]uint32) **C.uint32_t { /* Slice */ if len(*x) > 0 { slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.uint32_t)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithDescriptorSetCount(uint32(len(y)))
}

// DescriptorSetVariableDescriptorCountLayoutSupport provides a go interface for VkDescriptorSetVariableDescriptorCountLayoutSupport.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetVariableDescriptorCountLayoutSupport.html
type DescriptorSetVariableDescriptorCountLayoutSupport C.struct_VkDescriptorSetVariableDescriptorCountLayoutSupport

// SizeofDescriptorSetVariableDescriptorCountLayoutSupport is the memory size of a DescriptorSetVariableDescriptorCountLayoutSupport
var SizeofDescriptorSetVariableDescriptorCountLayoutSupport int = int(unsafe.Sizeof(DescriptorSetVariableDescriptorCountLayoutSupport{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorSetVariableDescriptorCountLayoutSupport) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorSetVariableDescriptorCountLayoutSupport) AsCPtr() *DescriptorSetVariableDescriptorCountLayoutSupport {
	clone := (*DescriptorSetVariableDescriptorCountLayoutSupport)(newCBlock(C.ulong(SizeofDescriptorSetVariableDescriptorCountLayoutSupport)))
	*clone = x
	return clone
}

// DescriptorSetVariableDescriptorCountLayoutSupportFreeCSlice releases the memory allocated by DescriptorSetVariableDescriptorCountLayoutSupportMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorSetVariableDescriptorCountLayoutSupportFreeCSlice(x []DescriptorSetVariableDescriptorCountLayoutSupport) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorSetVariableDescriptorCountLayoutSupportMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorSetVariableDescriptorCountLayoutSupportFreeCSlice must be called on the returned slice.
func DescriptorSetVariableDescriptorCountLayoutSupportMakeCSlice(x ...DescriptorSetVariableDescriptorCountLayoutSupport) []DescriptorSetVariableDescriptorCountLayoutSupport {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetVariableDescriptorCountLayoutSupport * len(x)
	dst := unsafe.Slice((*DescriptorSetVariableDescriptorCountLayoutSupport)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDescriptorSetVariableDescriptorCountLayoutSupport
func (x DescriptorSetVariableDescriptorCountLayoutSupport) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DescriptorSetVariableDescriptorCountLayoutSupport) WithDefaultSType() DescriptorSetVariableDescriptorCountLayoutSupport {
	return x.WithSType(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetVariableDescriptorCountLayoutSupport) WithSType(y StructureType) DescriptorSetVariableDescriptorCountLayoutSupport {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDescriptorSetVariableDescriptorCountLayoutSupport
func (x DescriptorSetVariableDescriptorCountLayoutSupport) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetVariableDescriptorCountLayoutSupport) WithPNext(y unsafe.Pointer) DescriptorSetVariableDescriptorCountLayoutSupport {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// MaxVariableDescriptorCount returns the value of maxVariableDescriptorCount from VkDescriptorSetVariableDescriptorCountLayoutSupport
func (x DescriptorSetVariableDescriptorCountLayoutSupport) MaxVariableDescriptorCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxVariableDescriptorCount) 
	return *ptr
}

// ImageFormatListCreateInfo provides a go interface for VkImageFormatListCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageFormatListCreateInfo.html
type ImageFormatListCreateInfo C.struct_VkImageFormatListCreateInfo

// SizeofImageFormatListCreateInfo is the memory size of a ImageFormatListCreateInfo
var SizeofImageFormatListCreateInfo int = int(unsafe.Sizeof(ImageFormatListCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageFormatListCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageFormatListCreateInfo) AsCPtr() *ImageFormatListCreateInfo {
	clone := (*ImageFormatListCreateInfo)(newCBlock(C.ulong(SizeofImageFormatListCreateInfo)))
	*clone = x
	return clone
}

// ImageFormatListCreateInfoFreeCSlice releases the memory allocated by ImageFormatListCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageFormatListCreateInfoFreeCSlice(x []ImageFormatListCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageFormatListCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageFormatListCreateInfoFreeCSlice must be called on the returned slice.
func ImageFormatListCreateInfoMakeCSlice(x ...ImageFormatListCreateInfo) []ImageFormatListCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageFormatListCreateInfo * len(x)
	dst := unsafe.Slice((*ImageFormatListCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageFormatListCreateInfo
func (x ImageFormatListCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ImageFormatListCreateInfo) WithDefaultSType() ImageFormatListCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageFormatListCreateInfo) WithSType(y StructureType) ImageFormatListCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkImageFormatListCreateInfo
func (x ImageFormatListCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageFormatListCreateInfo) WithPNext(y unsafe.Pointer) ImageFormatListCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// ViewFormatCount returns the value of viewFormatCount from VkImageFormatListCreateInfo
func (x ImageFormatListCreateInfo) ViewFormatCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.viewFormatCount) 
	return *ptr
}

// WithViewFormatCount sets the value for the ViewFormatCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageFormatListCreateInfo) WithViewFormatCount(y uint32) ImageFormatListCreateInfo {
	x.viewFormatCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PViewFormats returns the value of pViewFormats from VkImageFormatListCreateInfo
func (x ImageFormatListCreateInfo) PViewFormats() []Format {
	ptr := func(x **C.VkFormat) *[]Format { /* Slice */ slc := unsafe.Slice((*Format)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pViewFormats) 
	return *ptr
}

// WithPViewFormats sets the value for the PViewFormats on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines ViewFormatCount as the length of this field.
// ViewFormatCount is updated with the length of the new value.
func (x ImageFormatListCreateInfo) WithPViewFormats(y []Format) ImageFormatListCreateInfo {
	x.pViewFormats = *(func(x *[]Format) **C.VkFormat { /* Slice */ if len(*x) > 0 { slc := (*C.VkFormat)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkFormat)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithViewFormatCount(uint32(len(y)))
}

// PhysicalDeviceVulkan12Properties provides a go interface for VkPhysicalDeviceVulkan12Properties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Properties.html
type PhysicalDeviceVulkan12Properties C.struct_VkPhysicalDeviceVulkan12Properties

// SizeofPhysicalDeviceVulkan12Properties is the memory size of a PhysicalDeviceVulkan12Properties
var SizeofPhysicalDeviceVulkan12Properties int = int(unsafe.Sizeof(PhysicalDeviceVulkan12Properties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceVulkan12Properties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceVulkan12Properties) AsCPtr() *PhysicalDeviceVulkan12Properties {
	clone := (*PhysicalDeviceVulkan12Properties)(newCBlock(C.ulong(SizeofPhysicalDeviceVulkan12Properties)))
	*clone = x
	return clone
}

// PhysicalDeviceVulkan12PropertiesFreeCSlice releases the memory allocated by PhysicalDeviceVulkan12PropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceVulkan12PropertiesFreeCSlice(x []PhysicalDeviceVulkan12Properties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceVulkan12PropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceVulkan12PropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceVulkan12PropertiesMakeCSlice(x ...PhysicalDeviceVulkan12Properties) []PhysicalDeviceVulkan12Properties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVulkan12Properties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceVulkan12Properties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceVulkan12Properties) WithDefaultSType() PhysicalDeviceVulkan12Properties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Properties) WithSType(y StructureType) PhysicalDeviceVulkan12Properties {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Properties) WithPNext(y unsafe.Pointer) PhysicalDeviceVulkan12Properties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// DriverID returns the value of driverID from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) DriverID() DriverId {
	ptr := /* typedef */ (*DriverId)(&x.driverID) 
	return *ptr
}

// DriverName returns the value of driverName from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) DriverName() []byte {
	ptr := func(x *[VK_MAX_DRIVER_NAME_SIZE]C.char) *[]byte { /* Array */ slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_DRIVER_NAME_SIZE); return &slc }(&x.driverName) 
	return *ptr
}

// DriverInfo returns the value of driverInfo from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) DriverInfo() []byte {
	ptr := func(x *[VK_MAX_DRIVER_INFO_SIZE]C.char) *[]byte { /* Array */ slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_DRIVER_INFO_SIZE); return &slc }(&x.driverInfo) 
	return *ptr
}

// ConformanceVersion returns the value of conformanceVersion from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ConformanceVersion() ConformanceVersion {
	ptr := /* typedef */ (*ConformanceVersion)(&x.conformanceVersion) 
	return *ptr
}

// DenormBehaviorIndependence returns the value of denormBehaviorIndependence from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) DenormBehaviorIndependence() ShaderFloatControlsIndependence {
	ptr := /* typedef */ (*ShaderFloatControlsIndependence)(&x.denormBehaviorIndependence) 
	return *ptr
}

// RoundingModeIndependence returns the value of roundingModeIndependence from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) RoundingModeIndependence() ShaderFloatControlsIndependence {
	ptr := /* typedef */ (*ShaderFloatControlsIndependence)(&x.roundingModeIndependence) 
	return *ptr
}

// ShaderSignedZeroInfNanPreserveFloat16 returns the value of shaderSignedZeroInfNanPreserveFloat16 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderSignedZeroInfNanPreserveFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSignedZeroInfNanPreserveFloat16) 
	return *ptr
}

// ShaderSignedZeroInfNanPreserveFloat32 returns the value of shaderSignedZeroInfNanPreserveFloat32 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderSignedZeroInfNanPreserveFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSignedZeroInfNanPreserveFloat32) 
	return *ptr
}

// ShaderSignedZeroInfNanPreserveFloat64 returns the value of shaderSignedZeroInfNanPreserveFloat64 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderSignedZeroInfNanPreserveFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSignedZeroInfNanPreserveFloat64) 
	return *ptr
}

// ShaderDenormPreserveFloat16 returns the value of shaderDenormPreserveFloat16 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderDenormPreserveFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormPreserveFloat16) 
	return *ptr
}

// ShaderDenormPreserveFloat32 returns the value of shaderDenormPreserveFloat32 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderDenormPreserveFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormPreserveFloat32) 
	return *ptr
}

// ShaderDenormPreserveFloat64 returns the value of shaderDenormPreserveFloat64 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderDenormPreserveFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormPreserveFloat64) 
	return *ptr
}

// ShaderDenormFlushToZeroFloat16 returns the value of shaderDenormFlushToZeroFloat16 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderDenormFlushToZeroFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormFlushToZeroFloat16) 
	return *ptr
}

// ShaderDenormFlushToZeroFloat32 returns the value of shaderDenormFlushToZeroFloat32 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderDenormFlushToZeroFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormFlushToZeroFloat32) 
	return *ptr
}

// ShaderDenormFlushToZeroFloat64 returns the value of shaderDenormFlushToZeroFloat64 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderDenormFlushToZeroFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDenormFlushToZeroFloat64) 
	return *ptr
}

// ShaderRoundingModeRTEFloat16 returns the value of shaderRoundingModeRTEFloat16 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderRoundingModeRTEFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTEFloat16) 
	return *ptr
}

// ShaderRoundingModeRTEFloat32 returns the value of shaderRoundingModeRTEFloat32 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderRoundingModeRTEFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTEFloat32) 
	return *ptr
}

// ShaderRoundingModeRTEFloat64 returns the value of shaderRoundingModeRTEFloat64 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderRoundingModeRTEFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTEFloat64) 
	return *ptr
}

// ShaderRoundingModeRTZFloat16 returns the value of shaderRoundingModeRTZFloat16 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderRoundingModeRTZFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTZFloat16) 
	return *ptr
}

// ShaderRoundingModeRTZFloat32 returns the value of shaderRoundingModeRTZFloat32 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderRoundingModeRTZFloat32() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTZFloat32) 
	return *ptr
}

// ShaderRoundingModeRTZFloat64 returns the value of shaderRoundingModeRTZFloat64 from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderRoundingModeRTZFloat64() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderRoundingModeRTZFloat64) 
	return *ptr
}

// MaxUpdateAfterBindDescriptorsInAllPools returns the value of maxUpdateAfterBindDescriptorsInAllPools from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxUpdateAfterBindDescriptorsInAllPools() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxUpdateAfterBindDescriptorsInAllPools) 
	return *ptr
}

// ShaderUniformBufferArrayNonUniformIndexingNative returns the value of shaderUniformBufferArrayNonUniformIndexingNative from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderUniformBufferArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderUniformBufferArrayNonUniformIndexingNative) 
	return *ptr
}

// ShaderSampledImageArrayNonUniformIndexingNative returns the value of shaderSampledImageArrayNonUniformIndexingNative from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderSampledImageArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSampledImageArrayNonUniformIndexingNative) 
	return *ptr
}

// ShaderStorageBufferArrayNonUniformIndexingNative returns the value of shaderStorageBufferArrayNonUniformIndexingNative from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderStorageBufferArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageBufferArrayNonUniformIndexingNative) 
	return *ptr
}

// ShaderStorageImageArrayNonUniformIndexingNative returns the value of shaderStorageImageArrayNonUniformIndexingNative from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderStorageImageArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageImageArrayNonUniformIndexingNative) 
	return *ptr
}

// ShaderInputAttachmentArrayNonUniformIndexingNative returns the value of shaderInputAttachmentArrayNonUniformIndexingNative from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) ShaderInputAttachmentArrayNonUniformIndexingNative() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInputAttachmentArrayNonUniformIndexingNative) 
	return *ptr
}

// RobustBufferAccessUpdateAfterBind returns the value of robustBufferAccessUpdateAfterBind from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) RobustBufferAccessUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.robustBufferAccessUpdateAfterBind) 
	return *ptr
}

// QuadDivergentImplicitLod returns the value of quadDivergentImplicitLod from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) QuadDivergentImplicitLod() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.quadDivergentImplicitLod) 
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindSamplers returns the value of maxPerStageDescriptorUpdateAfterBindSamplers from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxPerStageDescriptorUpdateAfterBindSamplers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindSamplers) 
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindUniformBuffers returns the value of maxPerStageDescriptorUpdateAfterBindUniformBuffers from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxPerStageDescriptorUpdateAfterBindUniformBuffers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindUniformBuffers) 
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindStorageBuffers returns the value of maxPerStageDescriptorUpdateAfterBindStorageBuffers from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxPerStageDescriptorUpdateAfterBindStorageBuffers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindStorageBuffers) 
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindSampledImages returns the value of maxPerStageDescriptorUpdateAfterBindSampledImages from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxPerStageDescriptorUpdateAfterBindSampledImages() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindSampledImages) 
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindStorageImages returns the value of maxPerStageDescriptorUpdateAfterBindStorageImages from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxPerStageDescriptorUpdateAfterBindStorageImages() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindStorageImages) 
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindInputAttachments returns the value of maxPerStageDescriptorUpdateAfterBindInputAttachments from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxPerStageDescriptorUpdateAfterBindInputAttachments() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindInputAttachments) 
	return *ptr
}

// MaxPerStageUpdateAfterBindResources returns the value of maxPerStageUpdateAfterBindResources from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxPerStageUpdateAfterBindResources() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageUpdateAfterBindResources) 
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindSamplers returns the value of maxDescriptorSetUpdateAfterBindSamplers from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxDescriptorSetUpdateAfterBindSamplers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindSamplers) 
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindUniformBuffers returns the value of maxDescriptorSetUpdateAfterBindUniformBuffers from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxDescriptorSetUpdateAfterBindUniformBuffers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindUniformBuffers) 
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic returns the value of maxDescriptorSetUpdateAfterBindUniformBuffersDynamic from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic) 
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindStorageBuffers returns the value of maxDescriptorSetUpdateAfterBindStorageBuffers from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxDescriptorSetUpdateAfterBindStorageBuffers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindStorageBuffers) 
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic returns the value of maxDescriptorSetUpdateAfterBindStorageBuffersDynamic from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic) 
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindSampledImages returns the value of maxDescriptorSetUpdateAfterBindSampledImages from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxDescriptorSetUpdateAfterBindSampledImages() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindSampledImages) 
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindStorageImages returns the value of maxDescriptorSetUpdateAfterBindStorageImages from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxDescriptorSetUpdateAfterBindStorageImages() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindStorageImages) 
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindInputAttachments returns the value of maxDescriptorSetUpdateAfterBindInputAttachments from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxDescriptorSetUpdateAfterBindInputAttachments() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindInputAttachments) 
	return *ptr
}

// SupportedDepthResolveModes returns the value of supportedDepthResolveModes from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) SupportedDepthResolveModes() ResolveModeFlags {
	ptr := /* typedef */ (*ResolveModeFlags)(&x.supportedDepthResolveModes) 
	return *ptr
}

// SupportedStencilResolveModes returns the value of supportedStencilResolveModes from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) SupportedStencilResolveModes() ResolveModeFlags {
	ptr := /* typedef */ (*ResolveModeFlags)(&x.supportedStencilResolveModes) 
	return *ptr
}

// IndependentResolveNone returns the value of independentResolveNone from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) IndependentResolveNone() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.independentResolveNone) 
	return *ptr
}

// IndependentResolve returns the value of independentResolve from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) IndependentResolve() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.independentResolve) 
	return *ptr
}

// FilterMinmaxSingleComponentFormats returns the value of filterMinmaxSingleComponentFormats from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) FilterMinmaxSingleComponentFormats() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.filterMinmaxSingleComponentFormats) 
	return *ptr
}

// FilterMinmaxImageComponentMapping returns the value of filterMinmaxImageComponentMapping from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) FilterMinmaxImageComponentMapping() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.filterMinmaxImageComponentMapping) 
	return *ptr
}

// MaxTimelineSemaphoreValueDifference returns the value of maxTimelineSemaphoreValueDifference from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) MaxTimelineSemaphoreValueDifference() uint64 {
	ptr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.maxTimelineSemaphoreValueDifference) 
	return *ptr
}

// FramebufferIntegerColorSampleCounts returns the value of framebufferIntegerColorSampleCounts from VkPhysicalDeviceVulkan12Properties
func (x PhysicalDeviceVulkan12Properties) FramebufferIntegerColorSampleCounts() SampleCountFlags {
	ptr := /* typedef */ (*SampleCountFlags)(&x.framebufferIntegerColorSampleCounts) 
	return *ptr
}

// SubpassDescriptionDepthStencilResolve provides a go interface for VkSubpassDescriptionDepthStencilResolve.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubpassDescriptionDepthStencilResolve.html
type SubpassDescriptionDepthStencilResolve C.struct_VkSubpassDescriptionDepthStencilResolve

// SizeofSubpassDescriptionDepthStencilResolve is the memory size of a SubpassDescriptionDepthStencilResolve
var SizeofSubpassDescriptionDepthStencilResolve int = int(unsafe.Sizeof(SubpassDescriptionDepthStencilResolve{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubpassDescriptionDepthStencilResolve) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubpassDescriptionDepthStencilResolve) AsCPtr() *SubpassDescriptionDepthStencilResolve {
	clone := (*SubpassDescriptionDepthStencilResolve)(newCBlock(C.ulong(SizeofSubpassDescriptionDepthStencilResolve)))
	*clone = x
	return clone
}

// SubpassDescriptionDepthStencilResolveFreeCSlice releases the memory allocated by SubpassDescriptionDepthStencilResolveMakeCSlice.
// It does not free pointers stored inside the slice.
func SubpassDescriptionDepthStencilResolveFreeCSlice(x []SubpassDescriptionDepthStencilResolve) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubpassDescriptionDepthStencilResolveMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubpassDescriptionDepthStencilResolveFreeCSlice must be called on the returned slice.
func SubpassDescriptionDepthStencilResolveMakeCSlice(x ...SubpassDescriptionDepthStencilResolve) []SubpassDescriptionDepthStencilResolve {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubpassDescriptionDepthStencilResolve * len(x)
	dst := unsafe.Slice((*SubpassDescriptionDepthStencilResolve)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSubpassDescriptionDepthStencilResolve
func (x SubpassDescriptionDepthStencilResolve) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SubpassDescriptionDepthStencilResolve) WithDefaultSType() SubpassDescriptionDepthStencilResolve {
	return x.WithSType(VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescriptionDepthStencilResolve) WithSType(y StructureType) SubpassDescriptionDepthStencilResolve {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkSubpassDescriptionDepthStencilResolve
func (x SubpassDescriptionDepthStencilResolve) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescriptionDepthStencilResolve) WithPNext(y unsafe.Pointer) SubpassDescriptionDepthStencilResolve {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// DepthResolveMode returns the value of depthResolveMode from VkSubpassDescriptionDepthStencilResolve
func (x SubpassDescriptionDepthStencilResolve) DepthResolveMode() ResolveModeFlagBits {
	ptr := /* typedef */ (*ResolveModeFlagBits)(&x.depthResolveMode) 
	return *ptr
}

// WithDepthResolveMode sets the value for the DepthResolveMode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescriptionDepthStencilResolve) WithDepthResolveMode(y ResolveModeFlagBits) SubpassDescriptionDepthStencilResolve {
	x.depthResolveMode = *(/* typedef */ (*C.VkResolveModeFlagBits)(&y))
	return x
}

// StencilResolveMode returns the value of stencilResolveMode from VkSubpassDescriptionDepthStencilResolve
func (x SubpassDescriptionDepthStencilResolve) StencilResolveMode() ResolveModeFlagBits {
	ptr := /* typedef */ (*ResolveModeFlagBits)(&x.stencilResolveMode) 
	return *ptr
}

// WithStencilResolveMode sets the value for the StencilResolveMode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescriptionDepthStencilResolve) WithStencilResolveMode(y ResolveModeFlagBits) SubpassDescriptionDepthStencilResolve {
	x.stencilResolveMode = *(/* typedef */ (*C.VkResolveModeFlagBits)(&y))
	return x
}

// PDepthStencilResolveAttachment returns the value of pDepthStencilResolveAttachment from VkSubpassDescriptionDepthStencilResolve
func (x SubpassDescriptionDepthStencilResolve) PDepthStencilResolveAttachment() *AttachmentReference2 {
	ptr := func(x **C.struct_VkAttachmentReference2) **AttachmentReference2 { /* Pointer */ c2g := (*AttachmentReference2)(*x); return &c2g }(&x.pDepthStencilResolveAttachment) 
	return *ptr
}

// WithPDepthStencilResolveAttachment sets the value for the PDepthStencilResolveAttachment on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubpassDescriptionDepthStencilResolve) WithPDepthStencilResolveAttachment(y *AttachmentReference2) SubpassDescriptionDepthStencilResolve {
	x.pDepthStencilResolveAttachment = *(func(x **AttachmentReference2) **C.struct_VkAttachmentReference2 { /* Pointer */ g2c := (*C.struct_VkAttachmentReference2)(*x); return &g2c }(&y))
	return x
}

// PhysicalDeviceDepthStencilResolveProperties provides a go interface for VkPhysicalDeviceDepthStencilResolveProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDepthStencilResolveProperties.html
type PhysicalDeviceDepthStencilResolveProperties C.struct_VkPhysicalDeviceDepthStencilResolveProperties

// SizeofPhysicalDeviceDepthStencilResolveProperties is the memory size of a PhysicalDeviceDepthStencilResolveProperties
var SizeofPhysicalDeviceDepthStencilResolveProperties int = int(unsafe.Sizeof(PhysicalDeviceDepthStencilResolveProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceDepthStencilResolveProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceDepthStencilResolveProperties) AsCPtr() *PhysicalDeviceDepthStencilResolveProperties {
	clone := (*PhysicalDeviceDepthStencilResolveProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceDepthStencilResolveProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceDepthStencilResolvePropertiesFreeCSlice releases the memory allocated by PhysicalDeviceDepthStencilResolvePropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceDepthStencilResolvePropertiesFreeCSlice(x []PhysicalDeviceDepthStencilResolveProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceDepthStencilResolvePropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceDepthStencilResolvePropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceDepthStencilResolvePropertiesMakeCSlice(x ...PhysicalDeviceDepthStencilResolveProperties) []PhysicalDeviceDepthStencilResolveProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceDepthStencilResolveProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceDepthStencilResolveProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceDepthStencilResolveProperties
func (x PhysicalDeviceDepthStencilResolveProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceDepthStencilResolveProperties) WithDefaultSType() PhysicalDeviceDepthStencilResolveProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDepthStencilResolveProperties) WithSType(y StructureType) PhysicalDeviceDepthStencilResolveProperties {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceDepthStencilResolveProperties
func (x PhysicalDeviceDepthStencilResolveProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDepthStencilResolveProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceDepthStencilResolveProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SupportedDepthResolveModes returns the value of supportedDepthResolveModes from VkPhysicalDeviceDepthStencilResolveProperties
func (x PhysicalDeviceDepthStencilResolveProperties) SupportedDepthResolveModes() ResolveModeFlags {
	ptr := /* typedef */ (*ResolveModeFlags)(&x.supportedDepthResolveModes) 
	return *ptr
}

// SupportedStencilResolveModes returns the value of supportedStencilResolveModes from VkPhysicalDeviceDepthStencilResolveProperties
func (x PhysicalDeviceDepthStencilResolveProperties) SupportedStencilResolveModes() ResolveModeFlags {
	ptr := /* typedef */ (*ResolveModeFlags)(&x.supportedStencilResolveModes) 
	return *ptr
}

// IndependentResolveNone returns the value of independentResolveNone from VkPhysicalDeviceDepthStencilResolveProperties
func (x PhysicalDeviceDepthStencilResolveProperties) IndependentResolveNone() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.independentResolveNone) 
	return *ptr
}

// IndependentResolve returns the value of independentResolve from VkPhysicalDeviceDepthStencilResolveProperties
func (x PhysicalDeviceDepthStencilResolveProperties) IndependentResolve() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.independentResolve) 
	return *ptr
}

// PhysicalDeviceVulkan12Features provides a go interface for VkPhysicalDeviceVulkan12Features.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html
type PhysicalDeviceVulkan12Features C.struct_VkPhysicalDeviceVulkan12Features

// SizeofPhysicalDeviceVulkan12Features is the memory size of a PhysicalDeviceVulkan12Features
var SizeofPhysicalDeviceVulkan12Features int = int(unsafe.Sizeof(PhysicalDeviceVulkan12Features{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceVulkan12Features) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceVulkan12Features) AsCPtr() *PhysicalDeviceVulkan12Features {
	clone := (*PhysicalDeviceVulkan12Features)(newCBlock(C.ulong(SizeofPhysicalDeviceVulkan12Features)))
	*clone = x
	return clone
}

// PhysicalDeviceVulkan12FeaturesFreeCSlice releases the memory allocated by PhysicalDeviceVulkan12FeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceVulkan12FeaturesFreeCSlice(x []PhysicalDeviceVulkan12Features) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceVulkan12FeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceVulkan12FeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceVulkan12FeaturesMakeCSlice(x ...PhysicalDeviceVulkan12Features) []PhysicalDeviceVulkan12Features {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVulkan12Features * len(x)
	dst := unsafe.Slice((*PhysicalDeviceVulkan12Features)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceVulkan12Features) WithDefaultSType() PhysicalDeviceVulkan12Features {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithSType(y StructureType) PhysicalDeviceVulkan12Features {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithPNext(y unsafe.Pointer) PhysicalDeviceVulkan12Features {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SamplerMirrorClampToEdge returns the value of samplerMirrorClampToEdge from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) SamplerMirrorClampToEdge() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.samplerMirrorClampToEdge) 
	return *ptr
}

// WithSamplerMirrorClampToEdge sets the value for the SamplerMirrorClampToEdge on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithSamplerMirrorClampToEdge(y Bool32) PhysicalDeviceVulkan12Features {
	x.samplerMirrorClampToEdge = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DrawIndirectCount returns the value of drawIndirectCount from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DrawIndirectCount() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.drawIndirectCount) 
	return *ptr
}

// WithDrawIndirectCount sets the value for the DrawIndirectCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDrawIndirectCount(y Bool32) PhysicalDeviceVulkan12Features {
	x.drawIndirectCount = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// StorageBuffer8BitAccess returns the value of storageBuffer8BitAccess from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) StorageBuffer8BitAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storageBuffer8BitAccess) 
	return *ptr
}

// WithStorageBuffer8BitAccess sets the value for the StorageBuffer8BitAccess on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithStorageBuffer8BitAccess(y Bool32) PhysicalDeviceVulkan12Features {
	x.storageBuffer8BitAccess = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// UniformAndStorageBuffer8BitAccess returns the value of uniformAndStorageBuffer8BitAccess from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) UniformAndStorageBuffer8BitAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.uniformAndStorageBuffer8BitAccess) 
	return *ptr
}

// WithUniformAndStorageBuffer8BitAccess sets the value for the UniformAndStorageBuffer8BitAccess on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithUniformAndStorageBuffer8BitAccess(y Bool32) PhysicalDeviceVulkan12Features {
	x.uniformAndStorageBuffer8BitAccess = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// StoragePushConstant8 returns the value of storagePushConstant8 from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) StoragePushConstant8() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storagePushConstant8) 
	return *ptr
}

// WithStoragePushConstant8 sets the value for the StoragePushConstant8 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithStoragePushConstant8(y Bool32) PhysicalDeviceVulkan12Features {
	x.storagePushConstant8 = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderBufferInt64Atomics returns the value of shaderBufferInt64Atomics from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderBufferInt64Atomics() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderBufferInt64Atomics) 
	return *ptr
}

// WithShaderBufferInt64Atomics sets the value for the ShaderBufferInt64Atomics on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderBufferInt64Atomics(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderBufferInt64Atomics = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderSharedInt64Atomics returns the value of shaderSharedInt64Atomics from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderSharedInt64Atomics() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSharedInt64Atomics) 
	return *ptr
}

// WithShaderSharedInt64Atomics sets the value for the ShaderSharedInt64Atomics on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderSharedInt64Atomics(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderSharedInt64Atomics = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderFloat16 returns the value of shaderFloat16 from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderFloat16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderFloat16) 
	return *ptr
}

// WithShaderFloat16 sets the value for the ShaderFloat16 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderFloat16(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderFloat16 = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderInt8 returns the value of shaderInt8 from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderInt8() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInt8) 
	return *ptr
}

// WithShaderInt8 sets the value for the ShaderInt8 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderInt8(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderInt8 = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DescriptorIndexing returns the value of descriptorIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorIndexing) 
	return *ptr
}

// WithDescriptorIndexing sets the value for the DescriptorIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	x.descriptorIndexing = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderInputAttachmentArrayDynamicIndexing returns the value of shaderInputAttachmentArrayDynamicIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderInputAttachmentArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInputAttachmentArrayDynamicIndexing) 
	return *ptr
}

// WithShaderInputAttachmentArrayDynamicIndexing sets the value for the ShaderInputAttachmentArrayDynamicIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderInputAttachmentArrayDynamicIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderInputAttachmentArrayDynamicIndexing = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderUniformTexelBufferArrayDynamicIndexing returns the value of shaderUniformTexelBufferArrayDynamicIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderUniformTexelBufferArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderUniformTexelBufferArrayDynamicIndexing) 
	return *ptr
}

// WithShaderUniformTexelBufferArrayDynamicIndexing sets the value for the ShaderUniformTexelBufferArrayDynamicIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderUniformTexelBufferArrayDynamicIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderUniformTexelBufferArrayDynamicIndexing = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderStorageTexelBufferArrayDynamicIndexing returns the value of shaderStorageTexelBufferArrayDynamicIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderStorageTexelBufferArrayDynamicIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageTexelBufferArrayDynamicIndexing) 
	return *ptr
}

// WithShaderStorageTexelBufferArrayDynamicIndexing sets the value for the ShaderStorageTexelBufferArrayDynamicIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderStorageTexelBufferArrayDynamicIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderStorageTexelBufferArrayDynamicIndexing = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderUniformBufferArrayNonUniformIndexing returns the value of shaderUniformBufferArrayNonUniformIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderUniformBufferArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderUniformBufferArrayNonUniformIndexing) 
	return *ptr
}

// WithShaderUniformBufferArrayNonUniformIndexing sets the value for the ShaderUniformBufferArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderUniformBufferArrayNonUniformIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderUniformBufferArrayNonUniformIndexing = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderSampledImageArrayNonUniformIndexing returns the value of shaderSampledImageArrayNonUniformIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderSampledImageArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSampledImageArrayNonUniformIndexing) 
	return *ptr
}

// WithShaderSampledImageArrayNonUniformIndexing sets the value for the ShaderSampledImageArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderSampledImageArrayNonUniformIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderSampledImageArrayNonUniformIndexing = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderStorageBufferArrayNonUniformIndexing returns the value of shaderStorageBufferArrayNonUniformIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderStorageBufferArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageBufferArrayNonUniformIndexing) 
	return *ptr
}

// WithShaderStorageBufferArrayNonUniformIndexing sets the value for the ShaderStorageBufferArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderStorageBufferArrayNonUniformIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderStorageBufferArrayNonUniformIndexing = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderStorageImageArrayNonUniformIndexing returns the value of shaderStorageImageArrayNonUniformIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderStorageImageArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageImageArrayNonUniformIndexing) 
	return *ptr
}

// WithShaderStorageImageArrayNonUniformIndexing sets the value for the ShaderStorageImageArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderStorageImageArrayNonUniformIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderStorageImageArrayNonUniformIndexing = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderInputAttachmentArrayNonUniformIndexing returns the value of shaderInputAttachmentArrayNonUniformIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderInputAttachmentArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderInputAttachmentArrayNonUniformIndexing) 
	return *ptr
}

// WithShaderInputAttachmentArrayNonUniformIndexing sets the value for the ShaderInputAttachmentArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderInputAttachmentArrayNonUniformIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderInputAttachmentArrayNonUniformIndexing = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderUniformTexelBufferArrayNonUniformIndexing returns the value of shaderUniformTexelBufferArrayNonUniformIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderUniformTexelBufferArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderUniformTexelBufferArrayNonUniformIndexing) 
	return *ptr
}

// WithShaderUniformTexelBufferArrayNonUniformIndexing sets the value for the ShaderUniformTexelBufferArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderUniformTexelBufferArrayNonUniformIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderUniformTexelBufferArrayNonUniformIndexing = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderStorageTexelBufferArrayNonUniformIndexing returns the value of shaderStorageTexelBufferArrayNonUniformIndexing from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderStorageTexelBufferArrayNonUniformIndexing() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderStorageTexelBufferArrayNonUniformIndexing) 
	return *ptr
}

// WithShaderStorageTexelBufferArrayNonUniformIndexing sets the value for the ShaderStorageTexelBufferArrayNonUniformIndexing on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderStorageTexelBufferArrayNonUniformIndexing(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderStorageTexelBufferArrayNonUniformIndexing = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DescriptorBindingUniformBufferUpdateAfterBind returns the value of descriptorBindingUniformBufferUpdateAfterBind from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorBindingUniformBufferUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingUniformBufferUpdateAfterBind) 
	return *ptr
}

// WithDescriptorBindingUniformBufferUpdateAfterBind sets the value for the DescriptorBindingUniformBufferUpdateAfterBind on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorBindingUniformBufferUpdateAfterBind(y Bool32) PhysicalDeviceVulkan12Features {
	x.descriptorBindingUniformBufferUpdateAfterBind = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DescriptorBindingSampledImageUpdateAfterBind returns the value of descriptorBindingSampledImageUpdateAfterBind from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorBindingSampledImageUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingSampledImageUpdateAfterBind) 
	return *ptr
}

// WithDescriptorBindingSampledImageUpdateAfterBind sets the value for the DescriptorBindingSampledImageUpdateAfterBind on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorBindingSampledImageUpdateAfterBind(y Bool32) PhysicalDeviceVulkan12Features {
	x.descriptorBindingSampledImageUpdateAfterBind = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DescriptorBindingStorageImageUpdateAfterBind returns the value of descriptorBindingStorageImageUpdateAfterBind from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorBindingStorageImageUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingStorageImageUpdateAfterBind) 
	return *ptr
}

// WithDescriptorBindingStorageImageUpdateAfterBind sets the value for the DescriptorBindingStorageImageUpdateAfterBind on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorBindingStorageImageUpdateAfterBind(y Bool32) PhysicalDeviceVulkan12Features {
	x.descriptorBindingStorageImageUpdateAfterBind = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DescriptorBindingStorageBufferUpdateAfterBind returns the value of descriptorBindingStorageBufferUpdateAfterBind from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorBindingStorageBufferUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingStorageBufferUpdateAfterBind) 
	return *ptr
}

// WithDescriptorBindingStorageBufferUpdateAfterBind sets the value for the DescriptorBindingStorageBufferUpdateAfterBind on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorBindingStorageBufferUpdateAfterBind(y Bool32) PhysicalDeviceVulkan12Features {
	x.descriptorBindingStorageBufferUpdateAfterBind = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DescriptorBindingUniformTexelBufferUpdateAfterBind returns the value of descriptorBindingUniformTexelBufferUpdateAfterBind from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorBindingUniformTexelBufferUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingUniformTexelBufferUpdateAfterBind) 
	return *ptr
}

// WithDescriptorBindingUniformTexelBufferUpdateAfterBind sets the value for the DescriptorBindingUniformTexelBufferUpdateAfterBind on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorBindingUniformTexelBufferUpdateAfterBind(y Bool32) PhysicalDeviceVulkan12Features {
	x.descriptorBindingUniformTexelBufferUpdateAfterBind = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DescriptorBindingStorageTexelBufferUpdateAfterBind returns the value of descriptorBindingStorageTexelBufferUpdateAfterBind from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorBindingStorageTexelBufferUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingStorageTexelBufferUpdateAfterBind) 
	return *ptr
}

// WithDescriptorBindingStorageTexelBufferUpdateAfterBind sets the value for the DescriptorBindingStorageTexelBufferUpdateAfterBind on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorBindingStorageTexelBufferUpdateAfterBind(y Bool32) PhysicalDeviceVulkan12Features {
	x.descriptorBindingStorageTexelBufferUpdateAfterBind = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DescriptorBindingUpdateUnusedWhilePending returns the value of descriptorBindingUpdateUnusedWhilePending from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorBindingUpdateUnusedWhilePending() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingUpdateUnusedWhilePending) 
	return *ptr
}

// WithDescriptorBindingUpdateUnusedWhilePending sets the value for the DescriptorBindingUpdateUnusedWhilePending on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorBindingUpdateUnusedWhilePending(y Bool32) PhysicalDeviceVulkan12Features {
	x.descriptorBindingUpdateUnusedWhilePending = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DescriptorBindingPartiallyBound returns the value of descriptorBindingPartiallyBound from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorBindingPartiallyBound() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingPartiallyBound) 
	return *ptr
}

// WithDescriptorBindingPartiallyBound sets the value for the DescriptorBindingPartiallyBound on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorBindingPartiallyBound(y Bool32) PhysicalDeviceVulkan12Features {
	x.descriptorBindingPartiallyBound = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DescriptorBindingVariableDescriptorCount returns the value of descriptorBindingVariableDescriptorCount from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) DescriptorBindingVariableDescriptorCount() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingVariableDescriptorCount) 
	return *ptr
}

// WithDescriptorBindingVariableDescriptorCount sets the value for the DescriptorBindingVariableDescriptorCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithDescriptorBindingVariableDescriptorCount(y Bool32) PhysicalDeviceVulkan12Features {
	x.descriptorBindingVariableDescriptorCount = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// RuntimeDescriptorArray returns the value of runtimeDescriptorArray from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) RuntimeDescriptorArray() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.runtimeDescriptorArray) 
	return *ptr
}

// WithRuntimeDescriptorArray sets the value for the RuntimeDescriptorArray on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithRuntimeDescriptorArray(y Bool32) PhysicalDeviceVulkan12Features {
	x.runtimeDescriptorArray = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// SamplerFilterMinmax returns the value of samplerFilterMinmax from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) SamplerFilterMinmax() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.samplerFilterMinmax) 
	return *ptr
}

// WithSamplerFilterMinmax sets the value for the SamplerFilterMinmax on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithSamplerFilterMinmax(y Bool32) PhysicalDeviceVulkan12Features {
	x.samplerFilterMinmax = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ScalarBlockLayout returns the value of scalarBlockLayout from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ScalarBlockLayout() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.scalarBlockLayout) 
	return *ptr
}

// WithScalarBlockLayout sets the value for the ScalarBlockLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithScalarBlockLayout(y Bool32) PhysicalDeviceVulkan12Features {
	x.scalarBlockLayout = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ImagelessFramebuffer returns the value of imagelessFramebuffer from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ImagelessFramebuffer() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.imagelessFramebuffer) 
	return *ptr
}

// WithImagelessFramebuffer sets the value for the ImagelessFramebuffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithImagelessFramebuffer(y Bool32) PhysicalDeviceVulkan12Features {
	x.imagelessFramebuffer = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// UniformBufferStandardLayout returns the value of uniformBufferStandardLayout from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) UniformBufferStandardLayout() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.uniformBufferStandardLayout) 
	return *ptr
}

// WithUniformBufferStandardLayout sets the value for the UniformBufferStandardLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithUniformBufferStandardLayout(y Bool32) PhysicalDeviceVulkan12Features {
	x.uniformBufferStandardLayout = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderSubgroupExtendedTypes returns the value of shaderSubgroupExtendedTypes from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderSubgroupExtendedTypes() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSubgroupExtendedTypes) 
	return *ptr
}

// WithShaderSubgroupExtendedTypes sets the value for the ShaderSubgroupExtendedTypes on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderSubgroupExtendedTypes(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderSubgroupExtendedTypes = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// SeparateDepthStencilLayouts returns the value of separateDepthStencilLayouts from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) SeparateDepthStencilLayouts() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.separateDepthStencilLayouts) 
	return *ptr
}

// WithSeparateDepthStencilLayouts sets the value for the SeparateDepthStencilLayouts on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithSeparateDepthStencilLayouts(y Bool32) PhysicalDeviceVulkan12Features {
	x.separateDepthStencilLayouts = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// HostQueryReset returns the value of hostQueryReset from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) HostQueryReset() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.hostQueryReset) 
	return *ptr
}

// WithHostQueryReset sets the value for the HostQueryReset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithHostQueryReset(y Bool32) PhysicalDeviceVulkan12Features {
	x.hostQueryReset = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// TimelineSemaphore returns the value of timelineSemaphore from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) TimelineSemaphore() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.timelineSemaphore) 
	return *ptr
}

// WithTimelineSemaphore sets the value for the TimelineSemaphore on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithTimelineSemaphore(y Bool32) PhysicalDeviceVulkan12Features {
	x.timelineSemaphore = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// BufferDeviceAddress returns the value of bufferDeviceAddress from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) BufferDeviceAddress() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.bufferDeviceAddress) 
	return *ptr
}

// WithBufferDeviceAddress sets the value for the BufferDeviceAddress on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithBufferDeviceAddress(y Bool32) PhysicalDeviceVulkan12Features {
	x.bufferDeviceAddress = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// BufferDeviceAddressCaptureReplay returns the value of bufferDeviceAddressCaptureReplay from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) BufferDeviceAddressCaptureReplay() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.bufferDeviceAddressCaptureReplay) 
	return *ptr
}

// WithBufferDeviceAddressCaptureReplay sets the value for the BufferDeviceAddressCaptureReplay on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithBufferDeviceAddressCaptureReplay(y Bool32) PhysicalDeviceVulkan12Features {
	x.bufferDeviceAddressCaptureReplay = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// BufferDeviceAddressMultiDevice returns the value of bufferDeviceAddressMultiDevice from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) BufferDeviceAddressMultiDevice() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.bufferDeviceAddressMultiDevice) 
	return *ptr
}

// WithBufferDeviceAddressMultiDevice sets the value for the BufferDeviceAddressMultiDevice on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithBufferDeviceAddressMultiDevice(y Bool32) PhysicalDeviceVulkan12Features {
	x.bufferDeviceAddressMultiDevice = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// VulkanMemoryModel returns the value of vulkanMemoryModel from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) VulkanMemoryModel() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.vulkanMemoryModel) 
	return *ptr
}

// WithVulkanMemoryModel sets the value for the VulkanMemoryModel on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithVulkanMemoryModel(y Bool32) PhysicalDeviceVulkan12Features {
	x.vulkanMemoryModel = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// VulkanMemoryModelDeviceScope returns the value of vulkanMemoryModelDeviceScope from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) VulkanMemoryModelDeviceScope() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.vulkanMemoryModelDeviceScope) 
	return *ptr
}

// WithVulkanMemoryModelDeviceScope sets the value for the VulkanMemoryModelDeviceScope on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithVulkanMemoryModelDeviceScope(y Bool32) PhysicalDeviceVulkan12Features {
	x.vulkanMemoryModelDeviceScope = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// VulkanMemoryModelAvailabilityVisibilityChains returns the value of vulkanMemoryModelAvailabilityVisibilityChains from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) VulkanMemoryModelAvailabilityVisibilityChains() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.vulkanMemoryModelAvailabilityVisibilityChains) 
	return *ptr
}

// WithVulkanMemoryModelAvailabilityVisibilityChains sets the value for the VulkanMemoryModelAvailabilityVisibilityChains on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithVulkanMemoryModelAvailabilityVisibilityChains(y Bool32) PhysicalDeviceVulkan12Features {
	x.vulkanMemoryModelAvailabilityVisibilityChains = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderOutputViewportIndex returns the value of shaderOutputViewportIndex from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderOutputViewportIndex() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderOutputViewportIndex) 
	return *ptr
}

// WithShaderOutputViewportIndex sets the value for the ShaderOutputViewportIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderOutputViewportIndex(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderOutputViewportIndex = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderOutputLayer returns the value of shaderOutputLayer from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) ShaderOutputLayer() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderOutputLayer) 
	return *ptr
}

// WithShaderOutputLayer sets the value for the ShaderOutputLayer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithShaderOutputLayer(y Bool32) PhysicalDeviceVulkan12Features {
	x.shaderOutputLayer = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// SubgroupBroadcastDynamicId returns the value of subgroupBroadcastDynamicId from VkPhysicalDeviceVulkan12Features
func (x PhysicalDeviceVulkan12Features) SubgroupBroadcastDynamicId() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.subgroupBroadcastDynamicId) 
	return *ptr
}

// WithSubgroupBroadcastDynamicId sets the value for the SubgroupBroadcastDynamicId on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan12Features) WithSubgroupBroadcastDynamicId(y Bool32) PhysicalDeviceVulkan12Features {
	x.subgroupBroadcastDynamicId = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// PhysicalDeviceVulkan11Properties provides a go interface for VkPhysicalDeviceVulkan11Properties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan11Properties.html
type PhysicalDeviceVulkan11Properties C.struct_VkPhysicalDeviceVulkan11Properties

// SizeofPhysicalDeviceVulkan11Properties is the memory size of a PhysicalDeviceVulkan11Properties
var SizeofPhysicalDeviceVulkan11Properties int = int(unsafe.Sizeof(PhysicalDeviceVulkan11Properties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceVulkan11Properties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceVulkan11Properties) AsCPtr() *PhysicalDeviceVulkan11Properties {
	clone := (*PhysicalDeviceVulkan11Properties)(newCBlock(C.ulong(SizeofPhysicalDeviceVulkan11Properties)))
	*clone = x
	return clone
}

// PhysicalDeviceVulkan11PropertiesFreeCSlice releases the memory allocated by PhysicalDeviceVulkan11PropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceVulkan11PropertiesFreeCSlice(x []PhysicalDeviceVulkan11Properties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceVulkan11PropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceVulkan11PropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceVulkan11PropertiesMakeCSlice(x ...PhysicalDeviceVulkan11Properties) []PhysicalDeviceVulkan11Properties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVulkan11Properties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceVulkan11Properties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceVulkan11Properties) WithDefaultSType() PhysicalDeviceVulkan11Properties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Properties) WithSType(y StructureType) PhysicalDeviceVulkan11Properties {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Properties) WithPNext(y unsafe.Pointer) PhysicalDeviceVulkan11Properties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// DeviceUUID returns the value of deviceUUID from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) DeviceUUID() []byte {
	ptr := func(x *[VK_UUID_SIZE]C.uint8_t) *[]byte { /* Array */ slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_UUID_SIZE); return &slc }(&x.deviceUUID) 
	return *ptr
}

// DriverUUID returns the value of driverUUID from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) DriverUUID() []byte {
	ptr := func(x *[VK_UUID_SIZE]C.uint8_t) *[]byte { /* Array */ slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_UUID_SIZE); return &slc }(&x.driverUUID) 
	return *ptr
}

// DeviceLUID returns the value of deviceLUID from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) DeviceLUID() []byte {
	ptr := func(x *[VK_LUID_SIZE]C.uint8_t) *[]byte { /* Array */ slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_LUID_SIZE); return &slc }(&x.deviceLUID) 
	return *ptr
}

// DeviceNodeMask returns the value of deviceNodeMask from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) DeviceNodeMask() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.deviceNodeMask) 
	return *ptr
}

// DeviceLUIDValid returns the value of deviceLUIDValid from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) DeviceLUIDValid() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.deviceLUIDValid) 
	return *ptr
}

// SubgroupSize returns the value of subgroupSize from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) SubgroupSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.subgroupSize) 
	return *ptr
}

// SubgroupSupportedStages returns the value of subgroupSupportedStages from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) SubgroupSupportedStages() ShaderStageFlags {
	ptr := /* typedef */ (*ShaderStageFlags)(&x.subgroupSupportedStages) 
	return *ptr
}

// SubgroupSupportedOperations returns the value of subgroupSupportedOperations from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) SubgroupSupportedOperations() SubgroupFeatureFlags {
	ptr := /* typedef */ (*SubgroupFeatureFlags)(&x.subgroupSupportedOperations) 
	return *ptr
}

// SubgroupQuadOperationsInAllStages returns the value of subgroupQuadOperationsInAllStages from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) SubgroupQuadOperationsInAllStages() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.subgroupQuadOperationsInAllStages) 
	return *ptr
}

// PointClippingBehavior returns the value of pointClippingBehavior from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) PointClippingBehavior() PointClippingBehavior {
	ptr := /* typedef */ (*PointClippingBehavior)(&x.pointClippingBehavior) 
	return *ptr
}

// MaxMultiviewViewCount returns the value of maxMultiviewViewCount from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) MaxMultiviewViewCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxMultiviewViewCount) 
	return *ptr
}

// MaxMultiviewInstanceIndex returns the value of maxMultiviewInstanceIndex from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) MaxMultiviewInstanceIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxMultiviewInstanceIndex) 
	return *ptr
}

// ProtectedNoFault returns the value of protectedNoFault from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) ProtectedNoFault() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.protectedNoFault) 
	return *ptr
}

// MaxPerSetDescriptors returns the value of maxPerSetDescriptors from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) MaxPerSetDescriptors() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerSetDescriptors) 
	return *ptr
}

// MaxMemoryAllocationSize returns the value of maxMemoryAllocationSize from VkPhysicalDeviceVulkan11Properties
func (x PhysicalDeviceVulkan11Properties) MaxMemoryAllocationSize() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.maxMemoryAllocationSize) 
	return *ptr
}

// PhysicalDeviceScalarBlockLayoutFeatures provides a go interface for VkPhysicalDeviceScalarBlockLayoutFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceScalarBlockLayoutFeatures.html
type PhysicalDeviceScalarBlockLayoutFeatures C.struct_VkPhysicalDeviceScalarBlockLayoutFeatures

// SizeofPhysicalDeviceScalarBlockLayoutFeatures is the memory size of a PhysicalDeviceScalarBlockLayoutFeatures
var SizeofPhysicalDeviceScalarBlockLayoutFeatures int = int(unsafe.Sizeof(PhysicalDeviceScalarBlockLayoutFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceScalarBlockLayoutFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceScalarBlockLayoutFeatures) AsCPtr() *PhysicalDeviceScalarBlockLayoutFeatures {
	clone := (*PhysicalDeviceScalarBlockLayoutFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceScalarBlockLayoutFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceScalarBlockLayoutFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceScalarBlockLayoutFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceScalarBlockLayoutFeaturesFreeCSlice(x []PhysicalDeviceScalarBlockLayoutFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceScalarBlockLayoutFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceScalarBlockLayoutFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceScalarBlockLayoutFeaturesMakeCSlice(x ...PhysicalDeviceScalarBlockLayoutFeatures) []PhysicalDeviceScalarBlockLayoutFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceScalarBlockLayoutFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceScalarBlockLayoutFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceScalarBlockLayoutFeatures
func (x PhysicalDeviceScalarBlockLayoutFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceScalarBlockLayoutFeatures) WithDefaultSType() PhysicalDeviceScalarBlockLayoutFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceScalarBlockLayoutFeatures) WithSType(y StructureType) PhysicalDeviceScalarBlockLayoutFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceScalarBlockLayoutFeatures
func (x PhysicalDeviceScalarBlockLayoutFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceScalarBlockLayoutFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceScalarBlockLayoutFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// ScalarBlockLayout returns the value of scalarBlockLayout from VkPhysicalDeviceScalarBlockLayoutFeatures
func (x PhysicalDeviceScalarBlockLayoutFeatures) ScalarBlockLayout() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.scalarBlockLayout) 
	return *ptr
}

// WithScalarBlockLayout sets the value for the ScalarBlockLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceScalarBlockLayoutFeatures) WithScalarBlockLayout(y Bool32) PhysicalDeviceScalarBlockLayoutFeatures {
	x.scalarBlockLayout = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ImageStencilUsageCreateInfo provides a go interface for VkImageStencilUsageCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageStencilUsageCreateInfo.html
type ImageStencilUsageCreateInfo C.struct_VkImageStencilUsageCreateInfo

// SizeofImageStencilUsageCreateInfo is the memory size of a ImageStencilUsageCreateInfo
var SizeofImageStencilUsageCreateInfo int = int(unsafe.Sizeof(ImageStencilUsageCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageStencilUsageCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageStencilUsageCreateInfo) AsCPtr() *ImageStencilUsageCreateInfo {
	clone := (*ImageStencilUsageCreateInfo)(newCBlock(C.ulong(SizeofImageStencilUsageCreateInfo)))
	*clone = x
	return clone
}

// ImageStencilUsageCreateInfoFreeCSlice releases the memory allocated by ImageStencilUsageCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageStencilUsageCreateInfoFreeCSlice(x []ImageStencilUsageCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageStencilUsageCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageStencilUsageCreateInfoFreeCSlice must be called on the returned slice.
func ImageStencilUsageCreateInfoMakeCSlice(x ...ImageStencilUsageCreateInfo) []ImageStencilUsageCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageStencilUsageCreateInfo * len(x)
	dst := unsafe.Slice((*ImageStencilUsageCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageStencilUsageCreateInfo
func (x ImageStencilUsageCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ImageStencilUsageCreateInfo) WithDefaultSType() ImageStencilUsageCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageStencilUsageCreateInfo) WithSType(y StructureType) ImageStencilUsageCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkImageStencilUsageCreateInfo
func (x ImageStencilUsageCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageStencilUsageCreateInfo) WithPNext(y unsafe.Pointer) ImageStencilUsageCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// StencilUsage returns the value of stencilUsage from VkImageStencilUsageCreateInfo
func (x ImageStencilUsageCreateInfo) StencilUsage() ImageUsageFlags {
	ptr := /* typedef */ (*ImageUsageFlags)(&x.stencilUsage) 
	return *ptr
}

// WithStencilUsage sets the value for the StencilUsage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageStencilUsageCreateInfo) WithStencilUsage(y ImageUsageFlags) ImageStencilUsageCreateInfo {
	x.stencilUsage = *(/* typedef */ (*C.VkImageUsageFlags)(&y))
	return x
}

// PhysicalDeviceVulkan11Features provides a go interface for VkPhysicalDeviceVulkan11Features.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan11Features.html
type PhysicalDeviceVulkan11Features C.struct_VkPhysicalDeviceVulkan11Features

// SizeofPhysicalDeviceVulkan11Features is the memory size of a PhysicalDeviceVulkan11Features
var SizeofPhysicalDeviceVulkan11Features int = int(unsafe.Sizeof(PhysicalDeviceVulkan11Features{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceVulkan11Features) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceVulkan11Features) AsCPtr() *PhysicalDeviceVulkan11Features {
	clone := (*PhysicalDeviceVulkan11Features)(newCBlock(C.ulong(SizeofPhysicalDeviceVulkan11Features)))
	*clone = x
	return clone
}

// PhysicalDeviceVulkan11FeaturesFreeCSlice releases the memory allocated by PhysicalDeviceVulkan11FeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceVulkan11FeaturesFreeCSlice(x []PhysicalDeviceVulkan11Features) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceVulkan11FeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceVulkan11FeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceVulkan11FeaturesMakeCSlice(x ...PhysicalDeviceVulkan11Features) []PhysicalDeviceVulkan11Features {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVulkan11Features * len(x)
	dst := unsafe.Slice((*PhysicalDeviceVulkan11Features)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceVulkan11Features) WithDefaultSType() PhysicalDeviceVulkan11Features {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithSType(y StructureType) PhysicalDeviceVulkan11Features {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithPNext(y unsafe.Pointer) PhysicalDeviceVulkan11Features {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// StorageBuffer16BitAccess returns the value of storageBuffer16BitAccess from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) StorageBuffer16BitAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storageBuffer16BitAccess) 
	return *ptr
}

// WithStorageBuffer16BitAccess sets the value for the StorageBuffer16BitAccess on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithStorageBuffer16BitAccess(y Bool32) PhysicalDeviceVulkan11Features {
	x.storageBuffer16BitAccess = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// UniformAndStorageBuffer16BitAccess returns the value of uniformAndStorageBuffer16BitAccess from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) UniformAndStorageBuffer16BitAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.uniformAndStorageBuffer16BitAccess) 
	return *ptr
}

// WithUniformAndStorageBuffer16BitAccess sets the value for the UniformAndStorageBuffer16BitAccess on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithUniformAndStorageBuffer16BitAccess(y Bool32) PhysicalDeviceVulkan11Features {
	x.uniformAndStorageBuffer16BitAccess = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// StoragePushConstant16 returns the value of storagePushConstant16 from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) StoragePushConstant16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storagePushConstant16) 
	return *ptr
}

// WithStoragePushConstant16 sets the value for the StoragePushConstant16 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithStoragePushConstant16(y Bool32) PhysicalDeviceVulkan11Features {
	x.storagePushConstant16 = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// StorageInputOutput16 returns the value of storageInputOutput16 from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) StorageInputOutput16() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storageInputOutput16) 
	return *ptr
}

// WithStorageInputOutput16 sets the value for the StorageInputOutput16 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithStorageInputOutput16(y Bool32) PhysicalDeviceVulkan11Features {
	x.storageInputOutput16 = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// Multiview returns the value of multiview from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) Multiview() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.multiview) 
	return *ptr
}

// WithMultiview sets the value for the Multiview on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithMultiview(y Bool32) PhysicalDeviceVulkan11Features {
	x.multiview = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// MultiviewGeometryShader returns the value of multiviewGeometryShader from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) MultiviewGeometryShader() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.multiviewGeometryShader) 
	return *ptr
}

// WithMultiviewGeometryShader sets the value for the MultiviewGeometryShader on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithMultiviewGeometryShader(y Bool32) PhysicalDeviceVulkan11Features {
	x.multiviewGeometryShader = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// MultiviewTessellationShader returns the value of multiviewTessellationShader from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) MultiviewTessellationShader() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.multiviewTessellationShader) 
	return *ptr
}

// WithMultiviewTessellationShader sets the value for the MultiviewTessellationShader on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithMultiviewTessellationShader(y Bool32) PhysicalDeviceVulkan11Features {
	x.multiviewTessellationShader = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// VariablePointersStorageBuffer returns the value of variablePointersStorageBuffer from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) VariablePointersStorageBuffer() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.variablePointersStorageBuffer) 
	return *ptr
}

// WithVariablePointersStorageBuffer sets the value for the VariablePointersStorageBuffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithVariablePointersStorageBuffer(y Bool32) PhysicalDeviceVulkan11Features {
	x.variablePointersStorageBuffer = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// VariablePointers returns the value of variablePointers from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) VariablePointers() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.variablePointers) 
	return *ptr
}

// WithVariablePointers sets the value for the VariablePointers on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithVariablePointers(y Bool32) PhysicalDeviceVulkan11Features {
	x.variablePointers = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ProtectedMemory returns the value of protectedMemory from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) ProtectedMemory() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.protectedMemory) 
	return *ptr
}

// WithProtectedMemory sets the value for the ProtectedMemory on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithProtectedMemory(y Bool32) PhysicalDeviceVulkan11Features {
	x.protectedMemory = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// SamplerYcbcrConversion returns the value of samplerYcbcrConversion from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) SamplerYcbcrConversion() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.samplerYcbcrConversion) 
	return *ptr
}

// WithSamplerYcbcrConversion sets the value for the SamplerYcbcrConversion on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithSamplerYcbcrConversion(y Bool32) PhysicalDeviceVulkan11Features {
	x.samplerYcbcrConversion = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderDrawParameters returns the value of shaderDrawParameters from VkPhysicalDeviceVulkan11Features
func (x PhysicalDeviceVulkan11Features) ShaderDrawParameters() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDrawParameters) 
	return *ptr
}

// WithShaderDrawParameters sets the value for the ShaderDrawParameters on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan11Features) WithShaderDrawParameters(y Bool32) PhysicalDeviceVulkan11Features {
	x.shaderDrawParameters = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// SamplerReductionModeCreateInfo provides a go interface for VkSamplerReductionModeCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSamplerReductionModeCreateInfo.html
type SamplerReductionModeCreateInfo C.struct_VkSamplerReductionModeCreateInfo

// SizeofSamplerReductionModeCreateInfo is the memory size of a SamplerReductionModeCreateInfo
var SizeofSamplerReductionModeCreateInfo int = int(unsafe.Sizeof(SamplerReductionModeCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SamplerReductionModeCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SamplerReductionModeCreateInfo) AsCPtr() *SamplerReductionModeCreateInfo {
	clone := (*SamplerReductionModeCreateInfo)(newCBlock(C.ulong(SizeofSamplerReductionModeCreateInfo)))
	*clone = x
	return clone
}

// SamplerReductionModeCreateInfoFreeCSlice releases the memory allocated by SamplerReductionModeCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SamplerReductionModeCreateInfoFreeCSlice(x []SamplerReductionModeCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SamplerReductionModeCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SamplerReductionModeCreateInfoFreeCSlice must be called on the returned slice.
func SamplerReductionModeCreateInfoMakeCSlice(x ...SamplerReductionModeCreateInfo) []SamplerReductionModeCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSamplerReductionModeCreateInfo * len(x)
	dst := unsafe.Slice((*SamplerReductionModeCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSamplerReductionModeCreateInfo
func (x SamplerReductionModeCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SamplerReductionModeCreateInfo) WithDefaultSType() SamplerReductionModeCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerReductionModeCreateInfo) WithSType(y StructureType) SamplerReductionModeCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkSamplerReductionModeCreateInfo
func (x SamplerReductionModeCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerReductionModeCreateInfo) WithPNext(y unsafe.Pointer) SamplerReductionModeCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// ReductionMode returns the value of reductionMode from VkSamplerReductionModeCreateInfo
func (x SamplerReductionModeCreateInfo) ReductionMode() SamplerReductionMode {
	ptr := /* typedef */ (*SamplerReductionMode)(&x.reductionMode) 
	return *ptr
}

// WithReductionMode sets the value for the ReductionMode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SamplerReductionModeCreateInfo) WithReductionMode(y SamplerReductionMode) SamplerReductionModeCreateInfo {
	x.reductionMode = *(/* typedef */ (*C.VkSamplerReductionMode)(&y))
	return x
}

// PhysicalDeviceSamplerFilterMinmaxProperties provides a go interface for VkPhysicalDeviceSamplerFilterMinmaxProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSamplerFilterMinmaxProperties.html
type PhysicalDeviceSamplerFilterMinmaxProperties C.struct_VkPhysicalDeviceSamplerFilterMinmaxProperties

// SizeofPhysicalDeviceSamplerFilterMinmaxProperties is the memory size of a PhysicalDeviceSamplerFilterMinmaxProperties
var SizeofPhysicalDeviceSamplerFilterMinmaxProperties int = int(unsafe.Sizeof(PhysicalDeviceSamplerFilterMinmaxProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceSamplerFilterMinmaxProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceSamplerFilterMinmaxProperties) AsCPtr() *PhysicalDeviceSamplerFilterMinmaxProperties {
	clone := (*PhysicalDeviceSamplerFilterMinmaxProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceSamplerFilterMinmaxProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceSamplerFilterMinmaxPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceSamplerFilterMinmaxPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceSamplerFilterMinmaxPropertiesFreeCSlice(x []PhysicalDeviceSamplerFilterMinmaxProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceSamplerFilterMinmaxPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceSamplerFilterMinmaxPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceSamplerFilterMinmaxPropertiesMakeCSlice(x ...PhysicalDeviceSamplerFilterMinmaxProperties) []PhysicalDeviceSamplerFilterMinmaxProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSamplerFilterMinmaxProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceSamplerFilterMinmaxProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceSamplerFilterMinmaxProperties
func (x PhysicalDeviceSamplerFilterMinmaxProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceSamplerFilterMinmaxProperties) WithDefaultSType() PhysicalDeviceSamplerFilterMinmaxProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSamplerFilterMinmaxProperties) WithSType(y StructureType) PhysicalDeviceSamplerFilterMinmaxProperties {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceSamplerFilterMinmaxProperties
func (x PhysicalDeviceSamplerFilterMinmaxProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSamplerFilterMinmaxProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceSamplerFilterMinmaxProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// FilterMinmaxSingleComponentFormats returns the value of filterMinmaxSingleComponentFormats from VkPhysicalDeviceSamplerFilterMinmaxProperties
func (x PhysicalDeviceSamplerFilterMinmaxProperties) FilterMinmaxSingleComponentFormats() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.filterMinmaxSingleComponentFormats) 
	return *ptr
}

// FilterMinmaxImageComponentMapping returns the value of filterMinmaxImageComponentMapping from VkPhysicalDeviceSamplerFilterMinmaxProperties
func (x PhysicalDeviceSamplerFilterMinmaxProperties) FilterMinmaxImageComponentMapping() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.filterMinmaxImageComponentMapping) 
	return *ptr
}

// PhysicalDeviceVulkanMemoryModelFeatures provides a go interface for VkPhysicalDeviceVulkanMemoryModelFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkanMemoryModelFeatures.html
type PhysicalDeviceVulkanMemoryModelFeatures C.struct_VkPhysicalDeviceVulkanMemoryModelFeatures

// SizeofPhysicalDeviceVulkanMemoryModelFeatures is the memory size of a PhysicalDeviceVulkanMemoryModelFeatures
var SizeofPhysicalDeviceVulkanMemoryModelFeatures int = int(unsafe.Sizeof(PhysicalDeviceVulkanMemoryModelFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceVulkanMemoryModelFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceVulkanMemoryModelFeatures) AsCPtr() *PhysicalDeviceVulkanMemoryModelFeatures {
	clone := (*PhysicalDeviceVulkanMemoryModelFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceVulkanMemoryModelFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceVulkanMemoryModelFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceVulkanMemoryModelFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceVulkanMemoryModelFeaturesFreeCSlice(x []PhysicalDeviceVulkanMemoryModelFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceVulkanMemoryModelFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceVulkanMemoryModelFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceVulkanMemoryModelFeaturesMakeCSlice(x ...PhysicalDeviceVulkanMemoryModelFeatures) []PhysicalDeviceVulkanMemoryModelFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVulkanMemoryModelFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceVulkanMemoryModelFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceVulkanMemoryModelFeatures
func (x PhysicalDeviceVulkanMemoryModelFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceVulkanMemoryModelFeatures) WithDefaultSType() PhysicalDeviceVulkanMemoryModelFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkanMemoryModelFeatures) WithSType(y StructureType) PhysicalDeviceVulkanMemoryModelFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceVulkanMemoryModelFeatures
func (x PhysicalDeviceVulkanMemoryModelFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkanMemoryModelFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceVulkanMemoryModelFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// VulkanMemoryModel returns the value of vulkanMemoryModel from VkPhysicalDeviceVulkanMemoryModelFeatures
func (x PhysicalDeviceVulkanMemoryModelFeatures) VulkanMemoryModel() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.vulkanMemoryModel) 
	return *ptr
}

// WithVulkanMemoryModel sets the value for the VulkanMemoryModel on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkanMemoryModelFeatures) WithVulkanMemoryModel(y Bool32) PhysicalDeviceVulkanMemoryModelFeatures {
	x.vulkanMemoryModel = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// VulkanMemoryModelDeviceScope returns the value of vulkanMemoryModelDeviceScope from VkPhysicalDeviceVulkanMemoryModelFeatures
func (x PhysicalDeviceVulkanMemoryModelFeatures) VulkanMemoryModelDeviceScope() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.vulkanMemoryModelDeviceScope) 
	return *ptr
}

// WithVulkanMemoryModelDeviceScope sets the value for the VulkanMemoryModelDeviceScope on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkanMemoryModelFeatures) WithVulkanMemoryModelDeviceScope(y Bool32) PhysicalDeviceVulkanMemoryModelFeatures {
	x.vulkanMemoryModelDeviceScope = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// VulkanMemoryModelAvailabilityVisibilityChains returns the value of vulkanMemoryModelAvailabilityVisibilityChains from VkPhysicalDeviceVulkanMemoryModelFeatures
func (x PhysicalDeviceVulkanMemoryModelFeatures) VulkanMemoryModelAvailabilityVisibilityChains() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.vulkanMemoryModelAvailabilityVisibilityChains) 
	return *ptr
}

// WithVulkanMemoryModelAvailabilityVisibilityChains sets the value for the VulkanMemoryModelAvailabilityVisibilityChains on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkanMemoryModelFeatures) WithVulkanMemoryModelAvailabilityVisibilityChains(y Bool32) PhysicalDeviceVulkanMemoryModelFeatures {
	x.vulkanMemoryModelAvailabilityVisibilityChains = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// PhysicalDeviceImagelessFramebufferFeatures provides a go interface for VkPhysicalDeviceImagelessFramebufferFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImagelessFramebufferFeatures.html
type PhysicalDeviceImagelessFramebufferFeatures C.struct_VkPhysicalDeviceImagelessFramebufferFeatures

// SizeofPhysicalDeviceImagelessFramebufferFeatures is the memory size of a PhysicalDeviceImagelessFramebufferFeatures
var SizeofPhysicalDeviceImagelessFramebufferFeatures int = int(unsafe.Sizeof(PhysicalDeviceImagelessFramebufferFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceImagelessFramebufferFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceImagelessFramebufferFeatures) AsCPtr() *PhysicalDeviceImagelessFramebufferFeatures {
	clone := (*PhysicalDeviceImagelessFramebufferFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceImagelessFramebufferFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceImagelessFramebufferFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceImagelessFramebufferFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceImagelessFramebufferFeaturesFreeCSlice(x []PhysicalDeviceImagelessFramebufferFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceImagelessFramebufferFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceImagelessFramebufferFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceImagelessFramebufferFeaturesMakeCSlice(x ...PhysicalDeviceImagelessFramebufferFeatures) []PhysicalDeviceImagelessFramebufferFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceImagelessFramebufferFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceImagelessFramebufferFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceImagelessFramebufferFeatures
func (x PhysicalDeviceImagelessFramebufferFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceImagelessFramebufferFeatures) WithDefaultSType() PhysicalDeviceImagelessFramebufferFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImagelessFramebufferFeatures) WithSType(y StructureType) PhysicalDeviceImagelessFramebufferFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceImagelessFramebufferFeatures
func (x PhysicalDeviceImagelessFramebufferFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImagelessFramebufferFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceImagelessFramebufferFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// ImagelessFramebuffer returns the value of imagelessFramebuffer from VkPhysicalDeviceImagelessFramebufferFeatures
func (x PhysicalDeviceImagelessFramebufferFeatures) ImagelessFramebuffer() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.imagelessFramebuffer) 
	return *ptr
}

// WithImagelessFramebuffer sets the value for the ImagelessFramebuffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImagelessFramebufferFeatures) WithImagelessFramebuffer(y Bool32) PhysicalDeviceImagelessFramebufferFeatures {
	x.imagelessFramebuffer = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// FramebufferAttachmentsCreateInfo provides a go interface for VkFramebufferAttachmentsCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebufferAttachmentsCreateInfo.html
type FramebufferAttachmentsCreateInfo C.struct_VkFramebufferAttachmentsCreateInfo

// SizeofFramebufferAttachmentsCreateInfo is the memory size of a FramebufferAttachmentsCreateInfo
var SizeofFramebufferAttachmentsCreateInfo int = int(unsafe.Sizeof(FramebufferAttachmentsCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *FramebufferAttachmentsCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x FramebufferAttachmentsCreateInfo) AsCPtr() *FramebufferAttachmentsCreateInfo {
	clone := (*FramebufferAttachmentsCreateInfo)(newCBlock(C.ulong(SizeofFramebufferAttachmentsCreateInfo)))
	*clone = x
	return clone
}

// FramebufferAttachmentsCreateInfoFreeCSlice releases the memory allocated by FramebufferAttachmentsCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func FramebufferAttachmentsCreateInfoFreeCSlice(x []FramebufferAttachmentsCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// FramebufferAttachmentsCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. FramebufferAttachmentsCreateInfoFreeCSlice must be called on the returned slice.
func FramebufferAttachmentsCreateInfoMakeCSlice(x ...FramebufferAttachmentsCreateInfo) []FramebufferAttachmentsCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFramebufferAttachmentsCreateInfo * len(x)
	dst := unsafe.Slice((*FramebufferAttachmentsCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkFramebufferAttachmentsCreateInfo
func (x FramebufferAttachmentsCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x FramebufferAttachmentsCreateInfo) WithDefaultSType() FramebufferAttachmentsCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentsCreateInfo) WithSType(y StructureType) FramebufferAttachmentsCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkFramebufferAttachmentsCreateInfo
func (x FramebufferAttachmentsCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentsCreateInfo) WithPNext(y unsafe.Pointer) FramebufferAttachmentsCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// AttachmentImageInfoCount returns the value of attachmentImageInfoCount from VkFramebufferAttachmentsCreateInfo
func (x FramebufferAttachmentsCreateInfo) AttachmentImageInfoCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.attachmentImageInfoCount) 
	return *ptr
}

// WithAttachmentImageInfoCount sets the value for the AttachmentImageInfoCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentsCreateInfo) WithAttachmentImageInfoCount(y uint32) FramebufferAttachmentsCreateInfo {
	x.attachmentImageInfoCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PAttachmentImageInfos returns the value of pAttachmentImageInfos from VkFramebufferAttachmentsCreateInfo
func (x FramebufferAttachmentsCreateInfo) PAttachmentImageInfos() []FramebufferAttachmentImageInfo {
	ptr := func(x **C.struct_VkFramebufferAttachmentImageInfo) *[]FramebufferAttachmentImageInfo { /* Slice */ slc := unsafe.Slice((*FramebufferAttachmentImageInfo)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pAttachmentImageInfos) 
	return *ptr
}

// WithPAttachmentImageInfos sets the value for the PAttachmentImageInfos on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines AttachmentImageInfoCount as the length of this field.
// AttachmentImageInfoCount is updated with the length of the new value.
func (x FramebufferAttachmentsCreateInfo) WithPAttachmentImageInfos(y []FramebufferAttachmentImageInfo) FramebufferAttachmentsCreateInfo {
	x.pAttachmentImageInfos = *(func(x *[]FramebufferAttachmentImageInfo) **C.struct_VkFramebufferAttachmentImageInfo { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkFramebufferAttachmentImageInfo)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkFramebufferAttachmentImageInfo)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithAttachmentImageInfoCount(uint32(len(y)))
}

// FramebufferAttachmentImageInfo provides a go interface for VkFramebufferAttachmentImageInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFramebufferAttachmentImageInfo.html
type FramebufferAttachmentImageInfo C.struct_VkFramebufferAttachmentImageInfo

// SizeofFramebufferAttachmentImageInfo is the memory size of a FramebufferAttachmentImageInfo
var SizeofFramebufferAttachmentImageInfo int = int(unsafe.Sizeof(FramebufferAttachmentImageInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *FramebufferAttachmentImageInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x FramebufferAttachmentImageInfo) AsCPtr() *FramebufferAttachmentImageInfo {
	clone := (*FramebufferAttachmentImageInfo)(newCBlock(C.ulong(SizeofFramebufferAttachmentImageInfo)))
	*clone = x
	return clone
}

// FramebufferAttachmentImageInfoFreeCSlice releases the memory allocated by FramebufferAttachmentImageInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func FramebufferAttachmentImageInfoFreeCSlice(x []FramebufferAttachmentImageInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// FramebufferAttachmentImageInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. FramebufferAttachmentImageInfoFreeCSlice must be called on the returned slice.
func FramebufferAttachmentImageInfoMakeCSlice(x ...FramebufferAttachmentImageInfo) []FramebufferAttachmentImageInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFramebufferAttachmentImageInfo * len(x)
	dst := unsafe.Slice((*FramebufferAttachmentImageInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkFramebufferAttachmentImageInfo
func (x FramebufferAttachmentImageInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x FramebufferAttachmentImageInfo) WithDefaultSType() FramebufferAttachmentImageInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentImageInfo) WithSType(y StructureType) FramebufferAttachmentImageInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkFramebufferAttachmentImageInfo
func (x FramebufferAttachmentImageInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentImageInfo) WithPNext(y unsafe.Pointer) FramebufferAttachmentImageInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkFramebufferAttachmentImageInfo
func (x FramebufferAttachmentImageInfo) Flags() ImageCreateFlags {
	ptr := /* typedef */ (*ImageCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentImageInfo) WithFlags(y ImageCreateFlags) FramebufferAttachmentImageInfo {
	x.flags = *(/* typedef */ (*C.VkImageCreateFlags)(&y))
	return x
}

// Usage returns the value of usage from VkFramebufferAttachmentImageInfo
func (x FramebufferAttachmentImageInfo) Usage() ImageUsageFlags {
	ptr := /* typedef */ (*ImageUsageFlags)(&x.usage) 
	return *ptr
}

// WithUsage sets the value for the Usage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentImageInfo) WithUsage(y ImageUsageFlags) FramebufferAttachmentImageInfo {
	x.usage = *(/* typedef */ (*C.VkImageUsageFlags)(&y))
	return x
}

// Width returns the value of width from VkFramebufferAttachmentImageInfo
func (x FramebufferAttachmentImageInfo) Width() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.width) 
	return *ptr
}

// WithWidth sets the value for the Width on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentImageInfo) WithWidth(y uint32) FramebufferAttachmentImageInfo {
	x.width = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// Height returns the value of height from VkFramebufferAttachmentImageInfo
func (x FramebufferAttachmentImageInfo) Height() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.height) 
	return *ptr
}

// WithHeight sets the value for the Height on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentImageInfo) WithHeight(y uint32) FramebufferAttachmentImageInfo {
	x.height = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// LayerCount returns the value of layerCount from VkFramebufferAttachmentImageInfo
func (x FramebufferAttachmentImageInfo) LayerCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.layerCount) 
	return *ptr
}

// WithLayerCount sets the value for the LayerCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentImageInfo) WithLayerCount(y uint32) FramebufferAttachmentImageInfo {
	x.layerCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// ViewFormatCount returns the value of viewFormatCount from VkFramebufferAttachmentImageInfo
func (x FramebufferAttachmentImageInfo) ViewFormatCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.viewFormatCount) 
	return *ptr
}

// WithViewFormatCount sets the value for the ViewFormatCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FramebufferAttachmentImageInfo) WithViewFormatCount(y uint32) FramebufferAttachmentImageInfo {
	x.viewFormatCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PViewFormats returns the value of pViewFormats from VkFramebufferAttachmentImageInfo
func (x FramebufferAttachmentImageInfo) PViewFormats() []Format {
	ptr := func(x **C.VkFormat) *[]Format { /* Slice */ slc := unsafe.Slice((*Format)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pViewFormats) 
	return *ptr
}

// WithPViewFormats sets the value for the PViewFormats on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines ViewFormatCount as the length of this field.
// ViewFormatCount is updated with the length of the new value.
func (x FramebufferAttachmentImageInfo) WithPViewFormats(y []Format) FramebufferAttachmentImageInfo {
	x.pViewFormats = *(func(x *[]Format) **C.VkFormat { /* Slice */ if len(*x) > 0 { slc := (*C.VkFormat)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkFormat)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithViewFormatCount(uint32(len(y)))
}

// RenderPassAttachmentBeginInfo provides a go interface for VkRenderPassAttachmentBeginInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderPassAttachmentBeginInfo.html
type RenderPassAttachmentBeginInfo C.struct_VkRenderPassAttachmentBeginInfo

// SizeofRenderPassAttachmentBeginInfo is the memory size of a RenderPassAttachmentBeginInfo
var SizeofRenderPassAttachmentBeginInfo int = int(unsafe.Sizeof(RenderPassAttachmentBeginInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *RenderPassAttachmentBeginInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x RenderPassAttachmentBeginInfo) AsCPtr() *RenderPassAttachmentBeginInfo {
	clone := (*RenderPassAttachmentBeginInfo)(newCBlock(C.ulong(SizeofRenderPassAttachmentBeginInfo)))
	*clone = x
	return clone
}

// RenderPassAttachmentBeginInfoFreeCSlice releases the memory allocated by RenderPassAttachmentBeginInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func RenderPassAttachmentBeginInfoFreeCSlice(x []RenderPassAttachmentBeginInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// RenderPassAttachmentBeginInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. RenderPassAttachmentBeginInfoFreeCSlice must be called on the returned slice.
func RenderPassAttachmentBeginInfoMakeCSlice(x ...RenderPassAttachmentBeginInfo) []RenderPassAttachmentBeginInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderPassAttachmentBeginInfo * len(x)
	dst := unsafe.Slice((*RenderPassAttachmentBeginInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkRenderPassAttachmentBeginInfo
func (x RenderPassAttachmentBeginInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x RenderPassAttachmentBeginInfo) WithDefaultSType() RenderPassAttachmentBeginInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassAttachmentBeginInfo) WithSType(y StructureType) RenderPassAttachmentBeginInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkRenderPassAttachmentBeginInfo
func (x RenderPassAttachmentBeginInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassAttachmentBeginInfo) WithPNext(y unsafe.Pointer) RenderPassAttachmentBeginInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// AttachmentCount returns the value of attachmentCount from VkRenderPassAttachmentBeginInfo
func (x RenderPassAttachmentBeginInfo) AttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.attachmentCount) 
	return *ptr
}

// WithAttachmentCount sets the value for the AttachmentCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderPassAttachmentBeginInfo) WithAttachmentCount(y uint32) RenderPassAttachmentBeginInfo {
	x.attachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PAttachments returns the value of pAttachments from VkRenderPassAttachmentBeginInfo
func (x RenderPassAttachmentBeginInfo) PAttachments() []ImageView {
	ptr := func(x **C.VkImageView) *[]ImageView { /* Slice */ slc := unsafe.Slice((*ImageView)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pAttachments) 
	return *ptr
}

// WithPAttachments sets the value for the PAttachments on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines AttachmentCount as the length of this field.
// AttachmentCount is updated with the length of the new value.
func (x RenderPassAttachmentBeginInfo) WithPAttachments(y []ImageView) RenderPassAttachmentBeginInfo {
	x.pAttachments = *(func(x *[]ImageView) **C.VkImageView { /* Slice */ if len(*x) > 0 { slc := (*C.VkImageView)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkImageView)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithAttachmentCount(uint32(len(y)))
}

// PhysicalDeviceUniformBufferStandardLayoutFeatures provides a go interface for VkPhysicalDeviceUniformBufferStandardLayoutFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceUniformBufferStandardLayoutFeatures.html
type PhysicalDeviceUniformBufferStandardLayoutFeatures C.struct_VkPhysicalDeviceUniformBufferStandardLayoutFeatures

// SizeofPhysicalDeviceUniformBufferStandardLayoutFeatures is the memory size of a PhysicalDeviceUniformBufferStandardLayoutFeatures
var SizeofPhysicalDeviceUniformBufferStandardLayoutFeatures int = int(unsafe.Sizeof(PhysicalDeviceUniformBufferStandardLayoutFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceUniformBufferStandardLayoutFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceUniformBufferStandardLayoutFeatures) AsCPtr() *PhysicalDeviceUniformBufferStandardLayoutFeatures {
	clone := (*PhysicalDeviceUniformBufferStandardLayoutFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceUniformBufferStandardLayoutFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceUniformBufferStandardLayoutFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceUniformBufferStandardLayoutFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceUniformBufferStandardLayoutFeaturesFreeCSlice(x []PhysicalDeviceUniformBufferStandardLayoutFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceUniformBufferStandardLayoutFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceUniformBufferStandardLayoutFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceUniformBufferStandardLayoutFeaturesMakeCSlice(x ...PhysicalDeviceUniformBufferStandardLayoutFeatures) []PhysicalDeviceUniformBufferStandardLayoutFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceUniformBufferStandardLayoutFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceUniformBufferStandardLayoutFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceUniformBufferStandardLayoutFeatures
func (x PhysicalDeviceUniformBufferStandardLayoutFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceUniformBufferStandardLayoutFeatures) WithDefaultSType() PhysicalDeviceUniformBufferStandardLayoutFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceUniformBufferStandardLayoutFeatures) WithSType(y StructureType) PhysicalDeviceUniformBufferStandardLayoutFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceUniformBufferStandardLayoutFeatures
func (x PhysicalDeviceUniformBufferStandardLayoutFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceUniformBufferStandardLayoutFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceUniformBufferStandardLayoutFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// UniformBufferStandardLayout returns the value of uniformBufferStandardLayout from VkPhysicalDeviceUniformBufferStandardLayoutFeatures
func (x PhysicalDeviceUniformBufferStandardLayoutFeatures) UniformBufferStandardLayout() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.uniformBufferStandardLayout) 
	return *ptr
}

// WithUniformBufferStandardLayout sets the value for the UniformBufferStandardLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceUniformBufferStandardLayoutFeatures) WithUniformBufferStandardLayout(y Bool32) PhysicalDeviceUniformBufferStandardLayoutFeatures {
	x.uniformBufferStandardLayout = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// PhysicalDeviceShaderSubgroupExtendedTypesFeatures provides a go interface for VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures.html
type PhysicalDeviceShaderSubgroupExtendedTypesFeatures C.struct_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures

// SizeofPhysicalDeviceShaderSubgroupExtendedTypesFeatures is the memory size of a PhysicalDeviceShaderSubgroupExtendedTypesFeatures
var SizeofPhysicalDeviceShaderSubgroupExtendedTypesFeatures int = int(unsafe.Sizeof(PhysicalDeviceShaderSubgroupExtendedTypesFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceShaderSubgroupExtendedTypesFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceShaderSubgroupExtendedTypesFeatures) AsCPtr() *PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
	clone := (*PhysicalDeviceShaderSubgroupExtendedTypesFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceShaderSubgroupExtendedTypesFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceShaderSubgroupExtendedTypesFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceShaderSubgroupExtendedTypesFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceShaderSubgroupExtendedTypesFeaturesFreeCSlice(x []PhysicalDeviceShaderSubgroupExtendedTypesFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceShaderSubgroupExtendedTypesFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceShaderSubgroupExtendedTypesFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceShaderSubgroupExtendedTypesFeaturesMakeCSlice(x ...PhysicalDeviceShaderSubgroupExtendedTypesFeatures) []PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderSubgroupExtendedTypesFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceShaderSubgroupExtendedTypesFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures
func (x PhysicalDeviceShaderSubgroupExtendedTypesFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceShaderSubgroupExtendedTypesFeatures) WithDefaultSType() PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderSubgroupExtendedTypesFeatures) WithSType(y StructureType) PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures
func (x PhysicalDeviceShaderSubgroupExtendedTypesFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderSubgroupExtendedTypesFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// ShaderSubgroupExtendedTypes returns the value of shaderSubgroupExtendedTypes from VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures
func (x PhysicalDeviceShaderSubgroupExtendedTypesFeatures) ShaderSubgroupExtendedTypes() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSubgroupExtendedTypes) 
	return *ptr
}

// WithShaderSubgroupExtendedTypes sets the value for the ShaderSubgroupExtendedTypes on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderSubgroupExtendedTypesFeatures) WithShaderSubgroupExtendedTypes(y Bool32) PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
	x.shaderSubgroupExtendedTypes = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// PhysicalDeviceSeparateDepthStencilLayoutsFeatures provides a go interface for VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures.html
type PhysicalDeviceSeparateDepthStencilLayoutsFeatures C.struct_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures

// SizeofPhysicalDeviceSeparateDepthStencilLayoutsFeatures is the memory size of a PhysicalDeviceSeparateDepthStencilLayoutsFeatures
var SizeofPhysicalDeviceSeparateDepthStencilLayoutsFeatures int = int(unsafe.Sizeof(PhysicalDeviceSeparateDepthStencilLayoutsFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceSeparateDepthStencilLayoutsFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceSeparateDepthStencilLayoutsFeatures) AsCPtr() *PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
	clone := (*PhysicalDeviceSeparateDepthStencilLayoutsFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceSeparateDepthStencilLayoutsFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceSeparateDepthStencilLayoutsFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceSeparateDepthStencilLayoutsFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceSeparateDepthStencilLayoutsFeaturesFreeCSlice(x []PhysicalDeviceSeparateDepthStencilLayoutsFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceSeparateDepthStencilLayoutsFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceSeparateDepthStencilLayoutsFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceSeparateDepthStencilLayoutsFeaturesMakeCSlice(x ...PhysicalDeviceSeparateDepthStencilLayoutsFeatures) []PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSeparateDepthStencilLayoutsFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceSeparateDepthStencilLayoutsFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures
func (x PhysicalDeviceSeparateDepthStencilLayoutsFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceSeparateDepthStencilLayoutsFeatures) WithDefaultSType() PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSeparateDepthStencilLayoutsFeatures) WithSType(y StructureType) PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures
func (x PhysicalDeviceSeparateDepthStencilLayoutsFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSeparateDepthStencilLayoutsFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SeparateDepthStencilLayouts returns the value of separateDepthStencilLayouts from VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures
func (x PhysicalDeviceSeparateDepthStencilLayoutsFeatures) SeparateDepthStencilLayouts() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.separateDepthStencilLayouts) 
	return *ptr
}

// WithSeparateDepthStencilLayouts sets the value for the SeparateDepthStencilLayouts on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSeparateDepthStencilLayoutsFeatures) WithSeparateDepthStencilLayouts(y Bool32) PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
	x.separateDepthStencilLayouts = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// AttachmentReferenceStencilLayout provides a go interface for VkAttachmentReferenceStencilLayout.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentReferenceStencilLayout.html
type AttachmentReferenceStencilLayout C.struct_VkAttachmentReferenceStencilLayout

// SizeofAttachmentReferenceStencilLayout is the memory size of a AttachmentReferenceStencilLayout
var SizeofAttachmentReferenceStencilLayout int = int(unsafe.Sizeof(AttachmentReferenceStencilLayout{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *AttachmentReferenceStencilLayout) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x AttachmentReferenceStencilLayout) AsCPtr() *AttachmentReferenceStencilLayout {
	clone := (*AttachmentReferenceStencilLayout)(newCBlock(C.ulong(SizeofAttachmentReferenceStencilLayout)))
	*clone = x
	return clone
}

// AttachmentReferenceStencilLayoutFreeCSlice releases the memory allocated by AttachmentReferenceStencilLayoutMakeCSlice.
// It does not free pointers stored inside the slice.
func AttachmentReferenceStencilLayoutFreeCSlice(x []AttachmentReferenceStencilLayout) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// AttachmentReferenceStencilLayoutMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. AttachmentReferenceStencilLayoutFreeCSlice must be called on the returned slice.
func AttachmentReferenceStencilLayoutMakeCSlice(x ...AttachmentReferenceStencilLayout) []AttachmentReferenceStencilLayout {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAttachmentReferenceStencilLayout * len(x)
	dst := unsafe.Slice((*AttachmentReferenceStencilLayout)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkAttachmentReferenceStencilLayout
func (x AttachmentReferenceStencilLayout) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x AttachmentReferenceStencilLayout) WithDefaultSType() AttachmentReferenceStencilLayout {
	return x.WithSType(VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReferenceStencilLayout) WithSType(y StructureType) AttachmentReferenceStencilLayout {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkAttachmentReferenceStencilLayout
func (x AttachmentReferenceStencilLayout) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReferenceStencilLayout) WithPNext(y unsafe.Pointer) AttachmentReferenceStencilLayout {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// StencilLayout returns the value of stencilLayout from VkAttachmentReferenceStencilLayout
func (x AttachmentReferenceStencilLayout) StencilLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.stencilLayout) 
	return *ptr
}

// WithStencilLayout sets the value for the StencilLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentReferenceStencilLayout) WithStencilLayout(y ImageLayout) AttachmentReferenceStencilLayout {
	x.stencilLayout = *(/* typedef */ (*C.VkImageLayout)(&y))
	return x
}

// AttachmentDescriptionStencilLayout provides a go interface for VkAttachmentDescriptionStencilLayout.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAttachmentDescriptionStencilLayout.html
type AttachmentDescriptionStencilLayout C.struct_VkAttachmentDescriptionStencilLayout

// SizeofAttachmentDescriptionStencilLayout is the memory size of a AttachmentDescriptionStencilLayout
var SizeofAttachmentDescriptionStencilLayout int = int(unsafe.Sizeof(AttachmentDescriptionStencilLayout{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *AttachmentDescriptionStencilLayout) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x AttachmentDescriptionStencilLayout) AsCPtr() *AttachmentDescriptionStencilLayout {
	clone := (*AttachmentDescriptionStencilLayout)(newCBlock(C.ulong(SizeofAttachmentDescriptionStencilLayout)))
	*clone = x
	return clone
}

// AttachmentDescriptionStencilLayoutFreeCSlice releases the memory allocated by AttachmentDescriptionStencilLayoutMakeCSlice.
// It does not free pointers stored inside the slice.
func AttachmentDescriptionStencilLayoutFreeCSlice(x []AttachmentDescriptionStencilLayout) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// AttachmentDescriptionStencilLayoutMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. AttachmentDescriptionStencilLayoutFreeCSlice must be called on the returned slice.
func AttachmentDescriptionStencilLayoutMakeCSlice(x ...AttachmentDescriptionStencilLayout) []AttachmentDescriptionStencilLayout {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAttachmentDescriptionStencilLayout * len(x)
	dst := unsafe.Slice((*AttachmentDescriptionStencilLayout)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkAttachmentDescriptionStencilLayout
func (x AttachmentDescriptionStencilLayout) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x AttachmentDescriptionStencilLayout) WithDefaultSType() AttachmentDescriptionStencilLayout {
	return x.WithSType(VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescriptionStencilLayout) WithSType(y StructureType) AttachmentDescriptionStencilLayout {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkAttachmentDescriptionStencilLayout
func (x AttachmentDescriptionStencilLayout) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescriptionStencilLayout) WithPNext(y unsafe.Pointer) AttachmentDescriptionStencilLayout {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// StencilInitialLayout returns the value of stencilInitialLayout from VkAttachmentDescriptionStencilLayout
func (x AttachmentDescriptionStencilLayout) StencilInitialLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.stencilInitialLayout) 
	return *ptr
}

// WithStencilInitialLayout sets the value for the StencilInitialLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescriptionStencilLayout) WithStencilInitialLayout(y ImageLayout) AttachmentDescriptionStencilLayout {
	x.stencilInitialLayout = *(/* typedef */ (*C.VkImageLayout)(&y))
	return x
}

// StencilFinalLayout returns the value of stencilFinalLayout from VkAttachmentDescriptionStencilLayout
func (x AttachmentDescriptionStencilLayout) StencilFinalLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.stencilFinalLayout) 
	return *ptr
}

// WithStencilFinalLayout sets the value for the StencilFinalLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AttachmentDescriptionStencilLayout) WithStencilFinalLayout(y ImageLayout) AttachmentDescriptionStencilLayout {
	x.stencilFinalLayout = *(/* typedef */ (*C.VkImageLayout)(&y))
	return x
}

// TimelineSemaphoreSubmitInfo provides a go interface for VkTimelineSemaphoreSubmitInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkTimelineSemaphoreSubmitInfo.html
type TimelineSemaphoreSubmitInfo C.struct_VkTimelineSemaphoreSubmitInfo

// SizeofTimelineSemaphoreSubmitInfo is the memory size of a TimelineSemaphoreSubmitInfo
var SizeofTimelineSemaphoreSubmitInfo int = int(unsafe.Sizeof(TimelineSemaphoreSubmitInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *TimelineSemaphoreSubmitInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x TimelineSemaphoreSubmitInfo) AsCPtr() *TimelineSemaphoreSubmitInfo {
	clone := (*TimelineSemaphoreSubmitInfo)(newCBlock(C.ulong(SizeofTimelineSemaphoreSubmitInfo)))
	*clone = x
	return clone
}

// TimelineSemaphoreSubmitInfoFreeCSlice releases the memory allocated by TimelineSemaphoreSubmitInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func TimelineSemaphoreSubmitInfoFreeCSlice(x []TimelineSemaphoreSubmitInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// TimelineSemaphoreSubmitInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. TimelineSemaphoreSubmitInfoFreeCSlice must be called on the returned slice.
func TimelineSemaphoreSubmitInfoMakeCSlice(x ...TimelineSemaphoreSubmitInfo) []TimelineSemaphoreSubmitInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofTimelineSemaphoreSubmitInfo * len(x)
	dst := unsafe.Slice((*TimelineSemaphoreSubmitInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkTimelineSemaphoreSubmitInfo
func (x TimelineSemaphoreSubmitInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x TimelineSemaphoreSubmitInfo) WithDefaultSType() TimelineSemaphoreSubmitInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x TimelineSemaphoreSubmitInfo) WithSType(y StructureType) TimelineSemaphoreSubmitInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkTimelineSemaphoreSubmitInfo
func (x TimelineSemaphoreSubmitInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x TimelineSemaphoreSubmitInfo) WithPNext(y unsafe.Pointer) TimelineSemaphoreSubmitInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// WaitSemaphoreValueCount returns the value of waitSemaphoreValueCount from VkTimelineSemaphoreSubmitInfo
func (x TimelineSemaphoreSubmitInfo) WaitSemaphoreValueCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.waitSemaphoreValueCount) 
	return *ptr
}

// WithWaitSemaphoreValueCount sets the value for the WaitSemaphoreValueCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x TimelineSemaphoreSubmitInfo) WithWaitSemaphoreValueCount(y uint32) TimelineSemaphoreSubmitInfo {
	x.waitSemaphoreValueCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PWaitSemaphoreValues returns the value of pWaitSemaphoreValues from VkTimelineSemaphoreSubmitInfo
func (x TimelineSemaphoreSubmitInfo) PWaitSemaphoreValues() []uint64 {
	ptr := func(x **C.uint64_t) *[]uint64 { /* Slice */ slc := unsafe.Slice((*uint64)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pWaitSemaphoreValues) 
	return *ptr
}

// WithPWaitSemaphoreValues sets the value for the PWaitSemaphoreValues on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines WaitSemaphoreValueCount as the length of this field.
// WaitSemaphoreValueCount is updated with the length of the new value.
func (x TimelineSemaphoreSubmitInfo) WithPWaitSemaphoreValues(y []uint64) TimelineSemaphoreSubmitInfo {
	x.pWaitSemaphoreValues = *(func(x *[]uint64) **C.uint64_t { /* Slice */ if len(*x) > 0 { slc := (*C.uint64_t)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.uint64_t)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithWaitSemaphoreValueCount(uint32(len(y)))
}

// SignalSemaphoreValueCount returns the value of signalSemaphoreValueCount from VkTimelineSemaphoreSubmitInfo
func (x TimelineSemaphoreSubmitInfo) SignalSemaphoreValueCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.signalSemaphoreValueCount) 
	return *ptr
}

// WithSignalSemaphoreValueCount sets the value for the SignalSemaphoreValueCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x TimelineSemaphoreSubmitInfo) WithSignalSemaphoreValueCount(y uint32) TimelineSemaphoreSubmitInfo {
	x.signalSemaphoreValueCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PSignalSemaphoreValues returns the value of pSignalSemaphoreValues from VkTimelineSemaphoreSubmitInfo
func (x TimelineSemaphoreSubmitInfo) PSignalSemaphoreValues() []uint64 {
	ptr := func(x **C.uint64_t) *[]uint64 { /* Slice */ slc := unsafe.Slice((*uint64)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pSignalSemaphoreValues) 
	return *ptr
}

// WithPSignalSemaphoreValues sets the value for the PSignalSemaphoreValues on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines SignalSemaphoreValueCount as the length of this field.
// SignalSemaphoreValueCount is updated with the length of the new value.
func (x TimelineSemaphoreSubmitInfo) WithPSignalSemaphoreValues(y []uint64) TimelineSemaphoreSubmitInfo {
	x.pSignalSemaphoreValues = *(func(x *[]uint64) **C.uint64_t { /* Slice */ if len(*x) > 0 { slc := (*C.uint64_t)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.uint64_t)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithSignalSemaphoreValueCount(uint32(len(y)))
}

// PhysicalDeviceHostQueryResetFeatures provides a go interface for VkPhysicalDeviceHostQueryResetFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceHostQueryResetFeatures.html
type PhysicalDeviceHostQueryResetFeatures C.struct_VkPhysicalDeviceHostQueryResetFeatures

// SizeofPhysicalDeviceHostQueryResetFeatures is the memory size of a PhysicalDeviceHostQueryResetFeatures
var SizeofPhysicalDeviceHostQueryResetFeatures int = int(unsafe.Sizeof(PhysicalDeviceHostQueryResetFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceHostQueryResetFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceHostQueryResetFeatures) AsCPtr() *PhysicalDeviceHostQueryResetFeatures {
	clone := (*PhysicalDeviceHostQueryResetFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceHostQueryResetFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceHostQueryResetFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceHostQueryResetFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceHostQueryResetFeaturesFreeCSlice(x []PhysicalDeviceHostQueryResetFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceHostQueryResetFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceHostQueryResetFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceHostQueryResetFeaturesMakeCSlice(x ...PhysicalDeviceHostQueryResetFeatures) []PhysicalDeviceHostQueryResetFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceHostQueryResetFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceHostQueryResetFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceHostQueryResetFeatures
func (x PhysicalDeviceHostQueryResetFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceHostQueryResetFeatures) WithDefaultSType() PhysicalDeviceHostQueryResetFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceHostQueryResetFeatures) WithSType(y StructureType) PhysicalDeviceHostQueryResetFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceHostQueryResetFeatures
func (x PhysicalDeviceHostQueryResetFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceHostQueryResetFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceHostQueryResetFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// HostQueryReset returns the value of hostQueryReset from VkPhysicalDeviceHostQueryResetFeatures
func (x PhysicalDeviceHostQueryResetFeatures) HostQueryReset() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.hostQueryReset) 
	return *ptr
}

// WithHostQueryReset sets the value for the HostQueryReset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceHostQueryResetFeatures) WithHostQueryReset(y Bool32) PhysicalDeviceHostQueryResetFeatures {
	x.hostQueryReset = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// SemaphoreTypeCreateInfo provides a go interface for VkSemaphoreTypeCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreTypeCreateInfo.html
type SemaphoreTypeCreateInfo C.struct_VkSemaphoreTypeCreateInfo

// SizeofSemaphoreTypeCreateInfo is the memory size of a SemaphoreTypeCreateInfo
var SizeofSemaphoreTypeCreateInfo int = int(unsafe.Sizeof(SemaphoreTypeCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SemaphoreTypeCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SemaphoreTypeCreateInfo) AsCPtr() *SemaphoreTypeCreateInfo {
	clone := (*SemaphoreTypeCreateInfo)(newCBlock(C.ulong(SizeofSemaphoreTypeCreateInfo)))
	*clone = x
	return clone
}

// SemaphoreTypeCreateInfoFreeCSlice releases the memory allocated by SemaphoreTypeCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SemaphoreTypeCreateInfoFreeCSlice(x []SemaphoreTypeCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SemaphoreTypeCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SemaphoreTypeCreateInfoFreeCSlice must be called on the returned slice.
func SemaphoreTypeCreateInfoMakeCSlice(x ...SemaphoreTypeCreateInfo) []SemaphoreTypeCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSemaphoreTypeCreateInfo * len(x)
	dst := unsafe.Slice((*SemaphoreTypeCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSemaphoreTypeCreateInfo
func (x SemaphoreTypeCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SemaphoreTypeCreateInfo) WithDefaultSType() SemaphoreTypeCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreTypeCreateInfo) WithSType(y StructureType) SemaphoreTypeCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkSemaphoreTypeCreateInfo
func (x SemaphoreTypeCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreTypeCreateInfo) WithPNext(y unsafe.Pointer) SemaphoreTypeCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SemaphoreType returns the value of semaphoreType from VkSemaphoreTypeCreateInfo
func (x SemaphoreTypeCreateInfo) SemaphoreType() SemaphoreType {
	ptr := /* typedef */ (*SemaphoreType)(&x.semaphoreType) 
	return *ptr
}

// WithSemaphoreType sets the value for the SemaphoreType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreTypeCreateInfo) WithSemaphoreType(y SemaphoreType) SemaphoreTypeCreateInfo {
	x.semaphoreType = *(/* typedef */ (*C.VkSemaphoreType)(&y))
	return x
}

// InitialValue returns the value of initialValue from VkSemaphoreTypeCreateInfo
func (x SemaphoreTypeCreateInfo) InitialValue() uint64 {
	ptr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.initialValue) 
	return *ptr
}

// WithInitialValue sets the value for the InitialValue on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreTypeCreateInfo) WithInitialValue(y uint64) SemaphoreTypeCreateInfo {
	x.initialValue = *(func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&y))
	return x
}

// PhysicalDeviceTimelineSemaphoreProperties provides a go interface for VkPhysicalDeviceTimelineSemaphoreProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTimelineSemaphoreProperties.html
type PhysicalDeviceTimelineSemaphoreProperties C.struct_VkPhysicalDeviceTimelineSemaphoreProperties

// SizeofPhysicalDeviceTimelineSemaphoreProperties is the memory size of a PhysicalDeviceTimelineSemaphoreProperties
var SizeofPhysicalDeviceTimelineSemaphoreProperties int = int(unsafe.Sizeof(PhysicalDeviceTimelineSemaphoreProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceTimelineSemaphoreProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceTimelineSemaphoreProperties) AsCPtr() *PhysicalDeviceTimelineSemaphoreProperties {
	clone := (*PhysicalDeviceTimelineSemaphoreProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceTimelineSemaphoreProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceTimelineSemaphorePropertiesFreeCSlice releases the memory allocated by PhysicalDeviceTimelineSemaphorePropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceTimelineSemaphorePropertiesFreeCSlice(x []PhysicalDeviceTimelineSemaphoreProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceTimelineSemaphorePropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceTimelineSemaphorePropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceTimelineSemaphorePropertiesMakeCSlice(x ...PhysicalDeviceTimelineSemaphoreProperties) []PhysicalDeviceTimelineSemaphoreProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceTimelineSemaphoreProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceTimelineSemaphoreProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceTimelineSemaphoreProperties
func (x PhysicalDeviceTimelineSemaphoreProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceTimelineSemaphoreProperties) WithDefaultSType() PhysicalDeviceTimelineSemaphoreProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceTimelineSemaphoreProperties) WithSType(y StructureType) PhysicalDeviceTimelineSemaphoreProperties {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceTimelineSemaphoreProperties
func (x PhysicalDeviceTimelineSemaphoreProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceTimelineSemaphoreProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceTimelineSemaphoreProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// MaxTimelineSemaphoreValueDifference returns the value of maxTimelineSemaphoreValueDifference from VkPhysicalDeviceTimelineSemaphoreProperties
func (x PhysicalDeviceTimelineSemaphoreProperties) MaxTimelineSemaphoreValueDifference() uint64 {
	ptr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.maxTimelineSemaphoreValueDifference) 
	return *ptr
}

// PhysicalDeviceTimelineSemaphoreFeatures provides a go interface for VkPhysicalDeviceTimelineSemaphoreFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTimelineSemaphoreFeatures.html
type PhysicalDeviceTimelineSemaphoreFeatures C.struct_VkPhysicalDeviceTimelineSemaphoreFeatures

// SizeofPhysicalDeviceTimelineSemaphoreFeatures is the memory size of a PhysicalDeviceTimelineSemaphoreFeatures
var SizeofPhysicalDeviceTimelineSemaphoreFeatures int = int(unsafe.Sizeof(PhysicalDeviceTimelineSemaphoreFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceTimelineSemaphoreFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceTimelineSemaphoreFeatures) AsCPtr() *PhysicalDeviceTimelineSemaphoreFeatures {
	clone := (*PhysicalDeviceTimelineSemaphoreFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceTimelineSemaphoreFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceTimelineSemaphoreFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceTimelineSemaphoreFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceTimelineSemaphoreFeaturesFreeCSlice(x []PhysicalDeviceTimelineSemaphoreFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceTimelineSemaphoreFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceTimelineSemaphoreFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceTimelineSemaphoreFeaturesMakeCSlice(x ...PhysicalDeviceTimelineSemaphoreFeatures) []PhysicalDeviceTimelineSemaphoreFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceTimelineSemaphoreFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceTimelineSemaphoreFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceTimelineSemaphoreFeatures
func (x PhysicalDeviceTimelineSemaphoreFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceTimelineSemaphoreFeatures) WithDefaultSType() PhysicalDeviceTimelineSemaphoreFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceTimelineSemaphoreFeatures) WithSType(y StructureType) PhysicalDeviceTimelineSemaphoreFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceTimelineSemaphoreFeatures
func (x PhysicalDeviceTimelineSemaphoreFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceTimelineSemaphoreFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceTimelineSemaphoreFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// TimelineSemaphore returns the value of timelineSemaphore from VkPhysicalDeviceTimelineSemaphoreFeatures
func (x PhysicalDeviceTimelineSemaphoreFeatures) TimelineSemaphore() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.timelineSemaphore) 
	return *ptr
}

// WithTimelineSemaphore sets the value for the TimelineSemaphore on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceTimelineSemaphoreFeatures) WithTimelineSemaphore(y Bool32) PhysicalDeviceTimelineSemaphoreFeatures {
	x.timelineSemaphore = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DescriptorSetLayoutBindingFlagsCreateInfo provides a go interface for VkDescriptorSetLayoutBindingFlagsCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorSetLayoutBindingFlagsCreateInfo.html
type DescriptorSetLayoutBindingFlagsCreateInfo C.struct_VkDescriptorSetLayoutBindingFlagsCreateInfo

// SizeofDescriptorSetLayoutBindingFlagsCreateInfo is the memory size of a DescriptorSetLayoutBindingFlagsCreateInfo
var SizeofDescriptorSetLayoutBindingFlagsCreateInfo int = int(unsafe.Sizeof(DescriptorSetLayoutBindingFlagsCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorSetLayoutBindingFlagsCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorSetLayoutBindingFlagsCreateInfo) AsCPtr() *DescriptorSetLayoutBindingFlagsCreateInfo {
	clone := (*DescriptorSetLayoutBindingFlagsCreateInfo)(newCBlock(C.ulong(SizeofDescriptorSetLayoutBindingFlagsCreateInfo)))
	*clone = x
	return clone
}

// DescriptorSetLayoutBindingFlagsCreateInfoFreeCSlice releases the memory allocated by DescriptorSetLayoutBindingFlagsCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorSetLayoutBindingFlagsCreateInfoFreeCSlice(x []DescriptorSetLayoutBindingFlagsCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorSetLayoutBindingFlagsCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorSetLayoutBindingFlagsCreateInfoFreeCSlice must be called on the returned slice.
func DescriptorSetLayoutBindingFlagsCreateInfoMakeCSlice(x ...DescriptorSetLayoutBindingFlagsCreateInfo) []DescriptorSetLayoutBindingFlagsCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorSetLayoutBindingFlagsCreateInfo * len(x)
	dst := unsafe.Slice((*DescriptorSetLayoutBindingFlagsCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDescriptorSetLayoutBindingFlagsCreateInfo
func (x DescriptorSetLayoutBindingFlagsCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DescriptorSetLayoutBindingFlagsCreateInfo) WithDefaultSType() DescriptorSetLayoutBindingFlagsCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutBindingFlagsCreateInfo) WithSType(y StructureType) DescriptorSetLayoutBindingFlagsCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDescriptorSetLayoutBindingFlagsCreateInfo
func (x DescriptorSetLayoutBindingFlagsCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutBindingFlagsCreateInfo) WithPNext(y unsafe.Pointer) DescriptorSetLayoutBindingFlagsCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// BindingCount returns the value of bindingCount from VkDescriptorSetLayoutBindingFlagsCreateInfo
func (x DescriptorSetLayoutBindingFlagsCreateInfo) BindingCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.bindingCount) 
	return *ptr
}

// WithBindingCount sets the value for the BindingCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorSetLayoutBindingFlagsCreateInfo) WithBindingCount(y uint32) DescriptorSetLayoutBindingFlagsCreateInfo {
	x.bindingCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PBindingFlags returns the value of pBindingFlags from VkDescriptorSetLayoutBindingFlagsCreateInfo
func (x DescriptorSetLayoutBindingFlagsCreateInfo) PBindingFlags() []DescriptorBindingFlags {
	ptr := func(x **C.VkDescriptorBindingFlags) *[]DescriptorBindingFlags { /* Slice */ slc := unsafe.Slice((*DescriptorBindingFlags)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pBindingFlags) 
	return *ptr
}

// WithPBindingFlags sets the value for the PBindingFlags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines BindingCount as the length of this field.
// BindingCount is updated with the length of the new value.
func (x DescriptorSetLayoutBindingFlagsCreateInfo) WithPBindingFlags(y []DescriptorBindingFlags) DescriptorSetLayoutBindingFlagsCreateInfo {
	x.pBindingFlags = *(func(x *[]DescriptorBindingFlags) **C.VkDescriptorBindingFlags { /* Slice */ if len(*x) > 0 { slc := (*C.VkDescriptorBindingFlags)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkDescriptorBindingFlags)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithBindingCount(uint32(len(y)))
}

// DeviceMemoryOpaqueCaptureAddressInfo provides a go interface for VkDeviceMemoryOpaqueCaptureAddressInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceMemoryOpaqueCaptureAddressInfo.html
type DeviceMemoryOpaqueCaptureAddressInfo C.struct_VkDeviceMemoryOpaqueCaptureAddressInfo

// SizeofDeviceMemoryOpaqueCaptureAddressInfo is the memory size of a DeviceMemoryOpaqueCaptureAddressInfo
var SizeofDeviceMemoryOpaqueCaptureAddressInfo int = int(unsafe.Sizeof(DeviceMemoryOpaqueCaptureAddressInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceMemoryOpaqueCaptureAddressInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceMemoryOpaqueCaptureAddressInfo) AsCPtr() *DeviceMemoryOpaqueCaptureAddressInfo {
	clone := (*DeviceMemoryOpaqueCaptureAddressInfo)(newCBlock(C.ulong(SizeofDeviceMemoryOpaqueCaptureAddressInfo)))
	*clone = x
	return clone
}

// DeviceMemoryOpaqueCaptureAddressInfoFreeCSlice releases the memory allocated by DeviceMemoryOpaqueCaptureAddressInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceMemoryOpaqueCaptureAddressInfoFreeCSlice(x []DeviceMemoryOpaqueCaptureAddressInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceMemoryOpaqueCaptureAddressInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceMemoryOpaqueCaptureAddressInfoFreeCSlice must be called on the returned slice.
func DeviceMemoryOpaqueCaptureAddressInfoMakeCSlice(x ...DeviceMemoryOpaqueCaptureAddressInfo) []DeviceMemoryOpaqueCaptureAddressInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceMemoryOpaqueCaptureAddressInfo * len(x)
	dst := unsafe.Slice((*DeviceMemoryOpaqueCaptureAddressInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceMemoryOpaqueCaptureAddressInfo
func (x DeviceMemoryOpaqueCaptureAddressInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DeviceMemoryOpaqueCaptureAddressInfo) WithDefaultSType() DeviceMemoryOpaqueCaptureAddressInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceMemoryOpaqueCaptureAddressInfo) WithSType(y StructureType) DeviceMemoryOpaqueCaptureAddressInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDeviceMemoryOpaqueCaptureAddressInfo
func (x DeviceMemoryOpaqueCaptureAddressInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceMemoryOpaqueCaptureAddressInfo) WithPNext(y unsafe.Pointer) DeviceMemoryOpaqueCaptureAddressInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Memory returns the value of memory from VkDeviceMemoryOpaqueCaptureAddressInfo
func (x DeviceMemoryOpaqueCaptureAddressInfo) Memory() DeviceMemory {
	ptr := /* handle */ (*DeviceMemory)(&x.memory) 
	return *ptr
}

// WithMemory sets the value for the Memory on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceMemoryOpaqueCaptureAddressInfo) WithMemory(y DeviceMemory) DeviceMemoryOpaqueCaptureAddressInfo {
	x.memory = *(/* handle */ (*C.VkDeviceMemory)(&y))
	return x
}

// WaitSemaphores command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkWaitSemaphores.html
func (x DeviceFacade)WaitSemaphores(pWaitInfo *SemaphoreWaitInfo, timeout uint64, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **SemaphoreWaitInfo) **C.struct_VkSemaphoreWaitInfo { /* Pointer */ g2c := (*C.struct_VkSemaphoreWaitInfo)(*x); return &g2c }(&pWaitInfo)
	p2 := func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&timeout)
	ret := C.vkWaitSemaphores(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// ResetQueryPool command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetQueryPool.html
func (x DeviceFacade)ResetQueryPool(queryPool QueryPool, firstQuery uint32, queryCount uint32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkQueryPool)(&queryPool)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&firstQuery)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&queryCount)
	C.vkResetQueryPool(addrs, *p0, *p1, *p2, *p3)
	}

// GetSemaphoreCounterValue command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSemaphoreCounterValue.html
func (x DeviceFacade)GetSemaphoreCounterValue(semaphore Semaphore, pValue *uint64, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkSemaphore)(&semaphore)
	p2 := func(x **uint64) **C.uint64_t { /* Pointer */ g2c := (*C.uint64_t)(*x); return &g2c }(&pValue)
	ret := C.vkGetSemaphoreCounterValue(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CmdBeginRenderPass2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass2.html
func (x CommandBufferFacade)CmdBeginRenderPass2(pRenderPassBegin *RenderPassBeginInfo, pSubpassBeginInfo *SubpassBeginInfo, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **RenderPassBeginInfo) **C.struct_VkRenderPassBeginInfo { /* Pointer */ g2c := (*C.struct_VkRenderPassBeginInfo)(*x); return &g2c }(&pRenderPassBegin)
	p2 := func(x **SubpassBeginInfo) **C.struct_VkSubpassBeginInfo { /* Pointer */ g2c := (*C.struct_VkSubpassBeginInfo)(*x); return &g2c }(&pSubpassBeginInfo)
	C.vkCmdBeginRenderPass2(addrs, *p0, *p1, *p2)
	}

// CmdEndRenderPass2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndRenderPass2.html
func (x CommandBufferFacade)CmdEndRenderPass2(pSubpassEndInfo *SubpassEndInfo, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **SubpassEndInfo) **C.struct_VkSubpassEndInfo { /* Pointer */ g2c := (*C.struct_VkSubpassEndInfo)(*x); return &g2c }(&pSubpassEndInfo)
	C.vkCmdEndRenderPass2(addrs, *p0, *p1)
	}

// GetBufferDeviceAddress command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferDeviceAddress.html
func (x DeviceFacade)GetBufferDeviceAddress(pInfo *BufferDeviceAddressInfo, ) DeviceAddress {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **BufferDeviceAddressInfo) **C.struct_VkBufferDeviceAddressInfo { /* Pointer */ g2c := (*C.struct_VkBufferDeviceAddressInfo)(*x); return &g2c }(&pInfo)
	ret := C.vkGetBufferDeviceAddress(addrs, *p0, *p1)
	retPtr := /* typedef */ (*DeviceAddress)(&ret)
	return *retPtr
}

// GetBufferOpaqueCaptureAddress command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferOpaqueCaptureAddress.html
func (x DeviceFacade)GetBufferOpaqueCaptureAddress(pInfo *BufferDeviceAddressInfo, ) uint64 {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **BufferDeviceAddressInfo) **C.struct_VkBufferDeviceAddressInfo { /* Pointer */ g2c := (*C.struct_VkBufferDeviceAddressInfo)(*x); return &g2c }(&pInfo)
	ret := C.vkGetBufferOpaqueCaptureAddress(addrs, *p0, *p1)
	retPtr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&ret)
	return *retPtr
}

// GetDeviceMemoryOpaqueCaptureAddress command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceMemoryOpaqueCaptureAddress.html
func (x DeviceFacade)GetDeviceMemoryOpaqueCaptureAddress(pInfo *DeviceMemoryOpaqueCaptureAddressInfo, ) uint64 {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DeviceMemoryOpaqueCaptureAddressInfo) **C.struct_VkDeviceMemoryOpaqueCaptureAddressInfo { /* Pointer */ g2c := (*C.struct_VkDeviceMemoryOpaqueCaptureAddressInfo)(*x); return &g2c }(&pInfo)
	ret := C.vkGetDeviceMemoryOpaqueCaptureAddress(addrs, *p0, *p1)
	retPtr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&ret)
	return *retPtr
}

// CmdNextSubpass2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdNextSubpass2.html
func (x CommandBufferFacade)CmdNextSubpass2(pSubpassBeginInfo *SubpassBeginInfo, pSubpassEndInfo *SubpassEndInfo, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **SubpassBeginInfo) **C.struct_VkSubpassBeginInfo { /* Pointer */ g2c := (*C.struct_VkSubpassBeginInfo)(*x); return &g2c }(&pSubpassBeginInfo)
	p2 := func(x **SubpassEndInfo) **C.struct_VkSubpassEndInfo { /* Pointer */ g2c := (*C.struct_VkSubpassEndInfo)(*x); return &g2c }(&pSubpassEndInfo)
	C.vkCmdNextSubpass2(addrs, *p0, *p1, *p2)
	}

// CreateRenderPass2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateRenderPass2.html
func (x DeviceFacade)CreateRenderPass2(pCreateInfo *RenderPassCreateInfo2, pAllocator *AllocationCallbacks, pRenderPass *RenderPass, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **RenderPassCreateInfo2) **C.struct_VkRenderPassCreateInfo2 { /* Pointer */ g2c := (*C.struct_VkRenderPassCreateInfo2)(*x); return &g2c }(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p3 := func(x **RenderPass) **C.VkRenderPass { /* Pointer */ g2c := (*C.VkRenderPass)(*x); return &g2c }(&pRenderPass)
	ret := C.vkCreateRenderPass2(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CmdDrawIndexedIndirectCount command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndexedIndirectCount.html
func (x CommandBufferFacade)CmdDrawIndexedIndirectCount(buffer Buffer, offset DeviceSize, countBuffer Buffer, countBufferOffset DeviceSize, maxDrawCount uint32, stride uint32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&buffer)
	p2 := /* typedef */ (*C.VkDeviceSize)(&offset)
	p3 := /* handle */ (*C.VkBuffer)(&countBuffer)
	p4 := /* typedef */ (*C.VkDeviceSize)(&countBufferOffset)
	p5 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&maxDrawCount)
	p6 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&stride)
	C.vkCmdDrawIndexedIndirectCount(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6)
	}

// CmdDrawIndirectCount command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndirectCount.html
func (x CommandBufferFacade)CmdDrawIndirectCount(buffer Buffer, offset DeviceSize, countBuffer Buffer, countBufferOffset DeviceSize, maxDrawCount uint32, stride uint32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkBuffer)(&buffer)
	p2 := /* typedef */ (*C.VkDeviceSize)(&offset)
	p3 := /* handle */ (*C.VkBuffer)(&countBuffer)
	p4 := /* typedef */ (*C.VkDeviceSize)(&countBufferOffset)
	p5 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&maxDrawCount)
	p6 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&stride)
	C.vkCmdDrawIndirectCount(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6)
	}

// SignalSemaphore command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSignalSemaphore.html
func (x DeviceFacade)SignalSemaphore(pSignalInfo *SemaphoreSignalInfo, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **SemaphoreSignalInfo) **C.struct_VkSemaphoreSignalInfo { /* Pointer */ g2c := (*C.struct_VkSemaphoreSignalInfo)(*x); return &g2c }(&pSignalInfo)
	ret := C.vkSignalSemaphore(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// Flags64 basetype
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFlags64.html
type Flags64 uint64

// PrivateDataSlot is a Handle to a vulkan resource.
// PrivateDataSlot is a child of Device.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPrivateDataSlot.html
type PrivateDataSlot C.VkPrivateDataSlot

// NullPrivateDataSlot is a typed Null value for the PrivateDataSlot type.
var NullPrivateDataSlot PrivateDataSlot


// SubmitFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubmitFlagBits.html
type SubmitFlagBits uint32

const (
	VK_SUBMIT_PROTECTED_BIT SubmitFlagBits = (1 << 0)
	VK_SUBMIT_PROTECTED_BIT_KHR SubmitFlagBits = VK_SUBMIT_PROTECTED_BIT
)

var (
	reverseSubmitFlagBits map[SubmitFlagBits]string = map[SubmitFlagBits]string{ 
		VK_SUBMIT_PROTECTED_BIT: "VK_SUBMIT_PROTECTED_BIT",
	}
)
func (x SubmitFlagBits) String() string {
	if s, ok := reverseSubmitFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("SubmitFlagBits=%d", x)
}

// AccessFlagBits2 enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccessFlagBits2.html
type AccessFlagBits2 uint64

const (
	VK_ACCESS_2_NONE AccessFlagBits2 = 0
	VK_ACCESS_2_NONE_KHR AccessFlagBits2 = VK_ACCESS_2_NONE
	VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT AccessFlagBits2 = (1 << 0)
	VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR AccessFlagBits2 = VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT
	VK_ACCESS_2_INDEX_READ_BIT AccessFlagBits2 = (1 << 1)
	VK_ACCESS_2_INDEX_READ_BIT_KHR AccessFlagBits2 = VK_ACCESS_2_INDEX_READ_BIT
	VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT AccessFlagBits2 = (1 << 2)
	VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR AccessFlagBits2 = VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT
	VK_ACCESS_2_UNIFORM_READ_BIT AccessFlagBits2 = (1 << 3)
	VK_ACCESS_2_UNIFORM_READ_BIT_KHR AccessFlagBits2 = VK_ACCESS_2_UNIFORM_READ_BIT
	VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT AccessFlagBits2 = (1 << 4)
	VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR AccessFlagBits2 = VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT
	VK_ACCESS_2_SHADER_READ_BIT AccessFlagBits2 = (1 << 5)
	VK_ACCESS_2_SHADER_READ_BIT_KHR AccessFlagBits2 = VK_ACCESS_2_SHADER_READ_BIT
	VK_ACCESS_2_SHADER_WRITE_BIT AccessFlagBits2 = (1 << 6)
	VK_ACCESS_2_SHADER_WRITE_BIT_KHR AccessFlagBits2 = VK_ACCESS_2_SHADER_WRITE_BIT
	VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT AccessFlagBits2 = (1 << 7)
	VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR AccessFlagBits2 = VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT
	VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT AccessFlagBits2 = (1 << 8)
	VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR AccessFlagBits2 = VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT
	VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT AccessFlagBits2 = (1 << 9)
	VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR AccessFlagBits2 = VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT
	VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT AccessFlagBits2 = (1 << 10)
	VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR AccessFlagBits2 = VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT
	VK_ACCESS_2_TRANSFER_READ_BIT AccessFlagBits2 = (1 << 11)
	VK_ACCESS_2_TRANSFER_READ_BIT_KHR AccessFlagBits2 = VK_ACCESS_2_TRANSFER_READ_BIT
	VK_ACCESS_2_TRANSFER_WRITE_BIT AccessFlagBits2 = (1 << 12)
	VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR AccessFlagBits2 = VK_ACCESS_2_TRANSFER_WRITE_BIT
	VK_ACCESS_2_HOST_READ_BIT AccessFlagBits2 = (1 << 13)
	VK_ACCESS_2_HOST_READ_BIT_KHR AccessFlagBits2 = VK_ACCESS_2_HOST_READ_BIT
	VK_ACCESS_2_HOST_WRITE_BIT AccessFlagBits2 = (1 << 14)
	VK_ACCESS_2_HOST_WRITE_BIT_KHR AccessFlagBits2 = VK_ACCESS_2_HOST_WRITE_BIT
	VK_ACCESS_2_MEMORY_READ_BIT AccessFlagBits2 = (1 << 15)
	VK_ACCESS_2_MEMORY_READ_BIT_KHR AccessFlagBits2 = VK_ACCESS_2_MEMORY_READ_BIT
	VK_ACCESS_2_MEMORY_WRITE_BIT AccessFlagBits2 = (1 << 16)
	VK_ACCESS_2_MEMORY_WRITE_BIT_KHR AccessFlagBits2 = VK_ACCESS_2_MEMORY_WRITE_BIT
	VK_ACCESS_2_SHADER_SAMPLED_READ_BIT AccessFlagBits2 = (1 << 32)
	VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR AccessFlagBits2 = VK_ACCESS_2_SHADER_SAMPLED_READ_BIT
	VK_ACCESS_2_SHADER_STORAGE_READ_BIT AccessFlagBits2 = (1 << 33)
	VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR AccessFlagBits2 = VK_ACCESS_2_SHADER_STORAGE_READ_BIT
	VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT AccessFlagBits2 = (1 << 34)
	VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR AccessFlagBits2 = VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT
)

var (
	reverseAccessFlagBits2 map[AccessFlagBits2]string = map[AccessFlagBits2]string{ 
		VK_ACCESS_2_NONE: "VK_ACCESS_2_NONE",
		VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT: "VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT",
		VK_ACCESS_2_INDEX_READ_BIT: "VK_ACCESS_2_INDEX_READ_BIT",
		VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT: "VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT",
		VK_ACCESS_2_UNIFORM_READ_BIT: "VK_ACCESS_2_UNIFORM_READ_BIT",
		VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT: "VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT",
		VK_ACCESS_2_SHADER_READ_BIT: "VK_ACCESS_2_SHADER_READ_BIT",
		VK_ACCESS_2_SHADER_WRITE_BIT: "VK_ACCESS_2_SHADER_WRITE_BIT",
		VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT: "VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT",
		VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT: "VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT",
		VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT: "VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT",
		VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT: "VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT",
		VK_ACCESS_2_TRANSFER_READ_BIT: "VK_ACCESS_2_TRANSFER_READ_BIT",
		VK_ACCESS_2_TRANSFER_WRITE_BIT: "VK_ACCESS_2_TRANSFER_WRITE_BIT",
		VK_ACCESS_2_HOST_READ_BIT: "VK_ACCESS_2_HOST_READ_BIT",
		VK_ACCESS_2_HOST_WRITE_BIT: "VK_ACCESS_2_HOST_WRITE_BIT",
		VK_ACCESS_2_MEMORY_READ_BIT: "VK_ACCESS_2_MEMORY_READ_BIT",
		VK_ACCESS_2_MEMORY_WRITE_BIT: "VK_ACCESS_2_MEMORY_WRITE_BIT",
		VK_ACCESS_2_SHADER_SAMPLED_READ_BIT: "VK_ACCESS_2_SHADER_SAMPLED_READ_BIT",
		VK_ACCESS_2_SHADER_STORAGE_READ_BIT: "VK_ACCESS_2_SHADER_STORAGE_READ_BIT",
		VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT: "VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT",
	}
)
func (x AccessFlagBits2) String() string {
	if s, ok := reverseAccessFlagBits2[x]; ok {
		return s
	}
	return fmt.Sprintf("AccessFlagBits2=%d", x)
}

// PipelineCreationFeedbackFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreationFeedbackFlagBits.html
type PipelineCreationFeedbackFlagBits uint32

const (
	VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT PipelineCreationFeedbackFlagBits = (1 << 0)
	VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT PipelineCreationFeedbackFlagBits = VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT
	VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT PipelineCreationFeedbackFlagBits = (1 << 1)
	VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT PipelineCreationFeedbackFlagBits = VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT
	VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT PipelineCreationFeedbackFlagBits = (1 << 2)
	VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT PipelineCreationFeedbackFlagBits = VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT
)

var (
	reversePipelineCreationFeedbackFlagBits map[PipelineCreationFeedbackFlagBits]string = map[PipelineCreationFeedbackFlagBits]string{ 
		VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT: "VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT",
		VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT: "VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT",
		VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT: "VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT",
	}
)
func (x PipelineCreationFeedbackFlagBits) String() string {
	if s, ok := reversePipelineCreationFeedbackFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("PipelineCreationFeedbackFlagBits=%d", x)
}

// RenderingFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingFlagBits.html
type RenderingFlagBits uint32

const (
	VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT RenderingFlagBits = (1 << 0)
	VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR RenderingFlagBits = VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT
	VK_RENDERING_SUSPENDING_BIT RenderingFlagBits = (1 << 1)
	VK_RENDERING_SUSPENDING_BIT_KHR RenderingFlagBits = VK_RENDERING_SUSPENDING_BIT
	VK_RENDERING_RESUMING_BIT RenderingFlagBits = (1 << 2)
	VK_RENDERING_RESUMING_BIT_KHR RenderingFlagBits = VK_RENDERING_RESUMING_BIT
)

var (
	reverseRenderingFlagBits map[RenderingFlagBits]string = map[RenderingFlagBits]string{ 
		VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT: "VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT",
		VK_RENDERING_SUSPENDING_BIT: "VK_RENDERING_SUSPENDING_BIT",
		VK_RENDERING_RESUMING_BIT: "VK_RENDERING_RESUMING_BIT",
	}
)
func (x RenderingFlagBits) String() string {
	if s, ok := reverseRenderingFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("RenderingFlagBits=%d", x)
}

// PipelineStageFlagBits2 enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineStageFlagBits2.html
type PipelineStageFlagBits2 uint64

const (
	VK_PIPELINE_STAGE_2_NONE PipelineStageFlagBits2 = 0
	VK_PIPELINE_STAGE_2_NONE_KHR PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_NONE
	VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT PipelineStageFlagBits2 = (1 << 0)
	VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT
	VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT PipelineStageFlagBits2 = (1 << 1)
	VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT
	VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT PipelineStageFlagBits2 = (1 << 2)
	VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT
	VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT PipelineStageFlagBits2 = (1 << 3)
	VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT
	VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT PipelineStageFlagBits2 = (1 << 4)
	VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT
	VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT PipelineStageFlagBits2 = (1 << 5)
	VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT
	VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT PipelineStageFlagBits2 = (1 << 6)
	VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT
	VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT PipelineStageFlagBits2 = (1 << 7)
	VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT
	VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT PipelineStageFlagBits2 = (1 << 8)
	VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT
	VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT PipelineStageFlagBits2 = (1 << 9)
	VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT
	VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT PipelineStageFlagBits2 = (1 << 10)
	VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT
	VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT PipelineStageFlagBits2 = (1 << 11)
	VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT
	VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT PipelineStageFlagBits2 = (1 << 12)
	VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT
	VK_PIPELINE_STAGE_2_TRANSFER_BIT PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR
	VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT
	VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT PipelineStageFlagBits2 = (1 << 13)
	VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT
	VK_PIPELINE_STAGE_2_HOST_BIT PipelineStageFlagBits2 = (1 << 14)
	VK_PIPELINE_STAGE_2_HOST_BIT_KHR PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_HOST_BIT
	VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT PipelineStageFlagBits2 = (1 << 15)
	VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT
	VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT PipelineStageFlagBits2 = (1 << 16)
	VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT
	VK_PIPELINE_STAGE_2_COPY_BIT PipelineStageFlagBits2 = (1 << 32)
	VK_PIPELINE_STAGE_2_COPY_BIT_KHR PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_COPY_BIT
	VK_PIPELINE_STAGE_2_RESOLVE_BIT PipelineStageFlagBits2 = (1 << 33)
	VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_RESOLVE_BIT
	VK_PIPELINE_STAGE_2_BLIT_BIT PipelineStageFlagBits2 = (1 << 34)
	VK_PIPELINE_STAGE_2_BLIT_BIT_KHR PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_BLIT_BIT
	VK_PIPELINE_STAGE_2_CLEAR_BIT PipelineStageFlagBits2 = (1 << 35)
	VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_CLEAR_BIT
	VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT PipelineStageFlagBits2 = (1 << 36)
	VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT
	VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT PipelineStageFlagBits2 = (1 << 37)
	VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT
	VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT PipelineStageFlagBits2 = (1 << 38)
	VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR PipelineStageFlagBits2 = VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT
)

var (
	reversePipelineStageFlagBits2 map[PipelineStageFlagBits2]string = map[PipelineStageFlagBits2]string{ 
		VK_PIPELINE_STAGE_2_NONE: "VK_PIPELINE_STAGE_2_NONE",
		VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT: "VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT",
		VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT: "VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT",
		VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT: "VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT",
		VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT: "VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT",
		VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT: "VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT",
		VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT: "VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT",
		VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT: "VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT",
		VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT: "VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT",
		VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT: "VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT",
		VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT: "VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT",
		VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT: "VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT",
		VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT: "VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT",
		VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT: "VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT",
		VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT: "VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT",
		VK_PIPELINE_STAGE_2_HOST_BIT: "VK_PIPELINE_STAGE_2_HOST_BIT",
		VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT: "VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT",
		VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT: "VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT",
		VK_PIPELINE_STAGE_2_COPY_BIT: "VK_PIPELINE_STAGE_2_COPY_BIT",
		VK_PIPELINE_STAGE_2_RESOLVE_BIT: "VK_PIPELINE_STAGE_2_RESOLVE_BIT",
		VK_PIPELINE_STAGE_2_BLIT_BIT: "VK_PIPELINE_STAGE_2_BLIT_BIT",
		VK_PIPELINE_STAGE_2_CLEAR_BIT: "VK_PIPELINE_STAGE_2_CLEAR_BIT",
		VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT: "VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT",
		VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT: "VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT",
		VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT: "VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT",
	}
)
func (x PipelineStageFlagBits2) String() string {
	if s, ok := reversePipelineStageFlagBits2[x]; ok {
		return s
	}
	return fmt.Sprintf("PipelineStageFlagBits2=%d", x)
}

// ToolPurposeFlagBits enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkToolPurposeFlagBits.html
type ToolPurposeFlagBits uint32

const (
	VK_TOOL_PURPOSE_VALIDATION_BIT ToolPurposeFlagBits = (1 << 0)
	VK_TOOL_PURPOSE_VALIDATION_BIT_EXT ToolPurposeFlagBits = VK_TOOL_PURPOSE_VALIDATION_BIT
	VK_TOOL_PURPOSE_PROFILING_BIT ToolPurposeFlagBits = (1 << 1)
	VK_TOOL_PURPOSE_PROFILING_BIT_EXT ToolPurposeFlagBits = VK_TOOL_PURPOSE_PROFILING_BIT
	VK_TOOL_PURPOSE_TRACING_BIT ToolPurposeFlagBits = (1 << 2)
	VK_TOOL_PURPOSE_TRACING_BIT_EXT ToolPurposeFlagBits = VK_TOOL_PURPOSE_TRACING_BIT
	VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT ToolPurposeFlagBits = (1 << 3)
	VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT ToolPurposeFlagBits = VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT
	VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT ToolPurposeFlagBits = (1 << 4)
	VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT ToolPurposeFlagBits = VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT
)

var (
	reverseToolPurposeFlagBits map[ToolPurposeFlagBits]string = map[ToolPurposeFlagBits]string{ 
		VK_TOOL_PURPOSE_VALIDATION_BIT: "VK_TOOL_PURPOSE_VALIDATION_BIT",
		VK_TOOL_PURPOSE_PROFILING_BIT: "VK_TOOL_PURPOSE_PROFILING_BIT",
		VK_TOOL_PURPOSE_TRACING_BIT: "VK_TOOL_PURPOSE_TRACING_BIT",
		VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT: "VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT",
		VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT: "VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT",
	}
)
func (x ToolPurposeFlagBits) String() string {
	if s, ok := reverseToolPurposeFlagBits[x]; ok {
		return s
	}
	return fmt.Sprintf("ToolPurposeFlagBits=%d", x)
}

// FormatFeatureFlagBits2 enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatFeatureFlagBits2.html
type FormatFeatureFlagBits2 uint64

const (
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT FormatFeatureFlagBits2 = (1 << 0)
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT
	VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT FormatFeatureFlagBits2 = (1 << 1)
	VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT
	VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT FormatFeatureFlagBits2 = (1 << 2)
	VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT
	VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT FormatFeatureFlagBits2 = (1 << 3)
	VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT
	VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT FormatFeatureFlagBits2 = (1 << 4)
	VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT
	VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT FormatFeatureFlagBits2 = (1 << 5)
	VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
	VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT FormatFeatureFlagBits2 = (1 << 6)
	VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT
	VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT FormatFeatureFlagBits2 = (1 << 7)
	VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT
	VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT FormatFeatureFlagBits2 = (1 << 8)
	VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT
	VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT FormatFeatureFlagBits2 = (1 << 9)
	VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT
	VK_FORMAT_FEATURE_2_BLIT_SRC_BIT FormatFeatureFlagBits2 = (1 << 10)
	VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_BLIT_SRC_BIT
	VK_FORMAT_FEATURE_2_BLIT_DST_BIT FormatFeatureFlagBits2 = (1 << 11)
	VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_BLIT_DST_BIT
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT FormatFeatureFlagBits2 = (1 << 12)
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT FormatFeatureFlagBits2 = (1 << 13)
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT
	VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT FormatFeatureFlagBits2 = (1 << 14)
	VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT
	VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT FormatFeatureFlagBits2 = (1 << 15)
	VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT FormatFeatureFlagBits2 = (1 << 16)
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT
	VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT FormatFeatureFlagBits2 = (1 << 17)
	VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT FormatFeatureFlagBits2 = (1 << 18)
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT FormatFeatureFlagBits2 = (1 << 19)
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT FormatFeatureFlagBits2 = (1 << 20)
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT FormatFeatureFlagBits2 = (1 << 21)
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT
	VK_FORMAT_FEATURE_2_DISJOINT_BIT FormatFeatureFlagBits2 = (1 << 22)
	VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_DISJOINT_BIT
	VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT FormatFeatureFlagBits2 = (1 << 23)
	VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT
	VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT FormatFeatureFlagBits2 = (1 << 31)
	VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
	VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT FormatFeatureFlagBits2 = (1 << 32)
	VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT FormatFeatureFlagBits2 = (1 << 33)
	VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR FormatFeatureFlagBits2 = VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT
)

var (
	reverseFormatFeatureFlagBits2 map[FormatFeatureFlagBits2]string = map[FormatFeatureFlagBits2]string{ 
		VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT: "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT",
		VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT: "VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT",
		VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT: "VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT",
		VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT: "VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT",
		VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT: "VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT",
		VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT: "VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT",
		VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT: "VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT",
		VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT: "VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT",
		VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT: "VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT",
		VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT: "VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT",
		VK_FORMAT_FEATURE_2_BLIT_SRC_BIT: "VK_FORMAT_FEATURE_2_BLIT_SRC_BIT",
		VK_FORMAT_FEATURE_2_BLIT_DST_BIT: "VK_FORMAT_FEATURE_2_BLIT_DST_BIT",
		VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT: "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT",
		VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT: "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT",
		VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT: "VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT",
		VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT: "VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT",
		VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT: "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT",
		VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT: "VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT",
		VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT: "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT",
		VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT: "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT",
		VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT: "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT",
		VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT: "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT",
		VK_FORMAT_FEATURE_2_DISJOINT_BIT: "VK_FORMAT_FEATURE_2_DISJOINT_BIT",
		VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT: "VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT",
		VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT: "VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT",
		VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT: "VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT",
		VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT: "VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT",
	}
)
func (x FormatFeatureFlagBits2) String() string {
	if s, ok := reverseFormatFeatureFlagBits2[x]; ok {
		return s
	}
	return fmt.Sprintf("FormatFeatureFlagBits2=%d", x)
}

// PipelineStageFlags2 bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineStageFlags2.html
type PipelineStageFlags2 Flags64

// ToolPurposeFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkToolPurposeFlags.html
type ToolPurposeFlags Flags

// AccessFlags2 bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAccessFlags2.html
type AccessFlags2 Flags64

// PipelineCreationFeedbackFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreationFeedbackFlags.html
type PipelineCreationFeedbackFlags Flags

// SubmitFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubmitFlags.html
type SubmitFlags Flags

// FormatFeatureFlags2 bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatFeatureFlags2.html
type FormatFeatureFlags2 Flags64

// PrivateDataSlotCreateFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPrivateDataSlotCreateFlags.html
type PrivateDataSlotCreateFlags Flags

// RenderingFlags bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingFlags.html
type RenderingFlags Flags

// DescriptorPoolInlineUniformBlockCreateInfo provides a go interface for VkDescriptorPoolInlineUniformBlockCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDescriptorPoolInlineUniformBlockCreateInfo.html
type DescriptorPoolInlineUniformBlockCreateInfo C.struct_VkDescriptorPoolInlineUniformBlockCreateInfo

// SizeofDescriptorPoolInlineUniformBlockCreateInfo is the memory size of a DescriptorPoolInlineUniformBlockCreateInfo
var SizeofDescriptorPoolInlineUniformBlockCreateInfo int = int(unsafe.Sizeof(DescriptorPoolInlineUniformBlockCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DescriptorPoolInlineUniformBlockCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DescriptorPoolInlineUniformBlockCreateInfo) AsCPtr() *DescriptorPoolInlineUniformBlockCreateInfo {
	clone := (*DescriptorPoolInlineUniformBlockCreateInfo)(newCBlock(C.ulong(SizeofDescriptorPoolInlineUniformBlockCreateInfo)))
	*clone = x
	return clone
}

// DescriptorPoolInlineUniformBlockCreateInfoFreeCSlice releases the memory allocated by DescriptorPoolInlineUniformBlockCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DescriptorPoolInlineUniformBlockCreateInfoFreeCSlice(x []DescriptorPoolInlineUniformBlockCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DescriptorPoolInlineUniformBlockCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DescriptorPoolInlineUniformBlockCreateInfoFreeCSlice must be called on the returned slice.
func DescriptorPoolInlineUniformBlockCreateInfoMakeCSlice(x ...DescriptorPoolInlineUniformBlockCreateInfo) []DescriptorPoolInlineUniformBlockCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDescriptorPoolInlineUniformBlockCreateInfo * len(x)
	dst := unsafe.Slice((*DescriptorPoolInlineUniformBlockCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDescriptorPoolInlineUniformBlockCreateInfo
func (x DescriptorPoolInlineUniformBlockCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DescriptorPoolInlineUniformBlockCreateInfo) WithDefaultSType() DescriptorPoolInlineUniformBlockCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorPoolInlineUniformBlockCreateInfo) WithSType(y StructureType) DescriptorPoolInlineUniformBlockCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDescriptorPoolInlineUniformBlockCreateInfo
func (x DescriptorPoolInlineUniformBlockCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorPoolInlineUniformBlockCreateInfo) WithPNext(y unsafe.Pointer) DescriptorPoolInlineUniformBlockCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// MaxInlineUniformBlockBindings returns the value of maxInlineUniformBlockBindings from VkDescriptorPoolInlineUniformBlockCreateInfo
func (x DescriptorPoolInlineUniformBlockCreateInfo) MaxInlineUniformBlockBindings() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxInlineUniformBlockBindings) 
	return *ptr
}

// WithMaxInlineUniformBlockBindings sets the value for the MaxInlineUniformBlockBindings on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DescriptorPoolInlineUniformBlockCreateInfo) WithMaxInlineUniformBlockBindings(y uint32) DescriptorPoolInlineUniformBlockCreateInfo {
	x.maxInlineUniformBlockBindings = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// DevicePrivateDataCreateInfo provides a go interface for VkDevicePrivateDataCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDevicePrivateDataCreateInfo.html
type DevicePrivateDataCreateInfo C.struct_VkDevicePrivateDataCreateInfo

// SizeofDevicePrivateDataCreateInfo is the memory size of a DevicePrivateDataCreateInfo
var SizeofDevicePrivateDataCreateInfo int = int(unsafe.Sizeof(DevicePrivateDataCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DevicePrivateDataCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DevicePrivateDataCreateInfo) AsCPtr() *DevicePrivateDataCreateInfo {
	clone := (*DevicePrivateDataCreateInfo)(newCBlock(C.ulong(SizeofDevicePrivateDataCreateInfo)))
	*clone = x
	return clone
}

// DevicePrivateDataCreateInfoFreeCSlice releases the memory allocated by DevicePrivateDataCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DevicePrivateDataCreateInfoFreeCSlice(x []DevicePrivateDataCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DevicePrivateDataCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DevicePrivateDataCreateInfoFreeCSlice must be called on the returned slice.
func DevicePrivateDataCreateInfoMakeCSlice(x ...DevicePrivateDataCreateInfo) []DevicePrivateDataCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDevicePrivateDataCreateInfo * len(x)
	dst := unsafe.Slice((*DevicePrivateDataCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDevicePrivateDataCreateInfo
func (x DevicePrivateDataCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DevicePrivateDataCreateInfo) WithDefaultSType() DevicePrivateDataCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DevicePrivateDataCreateInfo) WithSType(y StructureType) DevicePrivateDataCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDevicePrivateDataCreateInfo
func (x DevicePrivateDataCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DevicePrivateDataCreateInfo) WithPNext(y unsafe.Pointer) DevicePrivateDataCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// PrivateDataSlotRequestCount returns the value of privateDataSlotRequestCount from VkDevicePrivateDataCreateInfo
func (x DevicePrivateDataCreateInfo) PrivateDataSlotRequestCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.privateDataSlotRequestCount) 
	return *ptr
}

// WithPrivateDataSlotRequestCount sets the value for the PrivateDataSlotRequestCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DevicePrivateDataCreateInfo) WithPrivateDataSlotRequestCount(y uint32) DevicePrivateDataCreateInfo {
	x.privateDataSlotRequestCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PrivateDataSlotCreateInfo provides a go interface for VkPrivateDataSlotCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPrivateDataSlotCreateInfo.html
type PrivateDataSlotCreateInfo C.struct_VkPrivateDataSlotCreateInfo

// SizeofPrivateDataSlotCreateInfo is the memory size of a PrivateDataSlotCreateInfo
var SizeofPrivateDataSlotCreateInfo int = int(unsafe.Sizeof(PrivateDataSlotCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PrivateDataSlotCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PrivateDataSlotCreateInfo) AsCPtr() *PrivateDataSlotCreateInfo {
	clone := (*PrivateDataSlotCreateInfo)(newCBlock(C.ulong(SizeofPrivateDataSlotCreateInfo)))
	*clone = x
	return clone
}

// PrivateDataSlotCreateInfoFreeCSlice releases the memory allocated by PrivateDataSlotCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PrivateDataSlotCreateInfoFreeCSlice(x []PrivateDataSlotCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PrivateDataSlotCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PrivateDataSlotCreateInfoFreeCSlice must be called on the returned slice.
func PrivateDataSlotCreateInfoMakeCSlice(x ...PrivateDataSlotCreateInfo) []PrivateDataSlotCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPrivateDataSlotCreateInfo * len(x)
	dst := unsafe.Slice((*PrivateDataSlotCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPrivateDataSlotCreateInfo
func (x PrivateDataSlotCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PrivateDataSlotCreateInfo) WithDefaultSType() PrivateDataSlotCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PrivateDataSlotCreateInfo) WithSType(y StructureType) PrivateDataSlotCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPrivateDataSlotCreateInfo
func (x PrivateDataSlotCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PrivateDataSlotCreateInfo) WithPNext(y unsafe.Pointer) PrivateDataSlotCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkPrivateDataSlotCreateInfo
func (x PrivateDataSlotCreateInfo) Flags() PrivateDataSlotCreateFlags {
	ptr := /* typedef */ (*PrivateDataSlotCreateFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PrivateDataSlotCreateInfo) WithFlags(y PrivateDataSlotCreateFlags) PrivateDataSlotCreateInfo {
	x.flags = *(/* typedef */ (*C.VkPrivateDataSlotCreateFlags)(&y))
	return x
}

// PhysicalDevicePrivateDataFeatures provides a go interface for VkPhysicalDevicePrivateDataFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePrivateDataFeatures.html
type PhysicalDevicePrivateDataFeatures C.struct_VkPhysicalDevicePrivateDataFeatures

// SizeofPhysicalDevicePrivateDataFeatures is the memory size of a PhysicalDevicePrivateDataFeatures
var SizeofPhysicalDevicePrivateDataFeatures int = int(unsafe.Sizeof(PhysicalDevicePrivateDataFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDevicePrivateDataFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDevicePrivateDataFeatures) AsCPtr() *PhysicalDevicePrivateDataFeatures {
	clone := (*PhysicalDevicePrivateDataFeatures)(newCBlock(C.ulong(SizeofPhysicalDevicePrivateDataFeatures)))
	*clone = x
	return clone
}

// PhysicalDevicePrivateDataFeaturesFreeCSlice releases the memory allocated by PhysicalDevicePrivateDataFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDevicePrivateDataFeaturesFreeCSlice(x []PhysicalDevicePrivateDataFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDevicePrivateDataFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDevicePrivateDataFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDevicePrivateDataFeaturesMakeCSlice(x ...PhysicalDevicePrivateDataFeatures) []PhysicalDevicePrivateDataFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDevicePrivateDataFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDevicePrivateDataFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDevicePrivateDataFeatures
func (x PhysicalDevicePrivateDataFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDevicePrivateDataFeatures) WithDefaultSType() PhysicalDevicePrivateDataFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePrivateDataFeatures) WithSType(y StructureType) PhysicalDevicePrivateDataFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDevicePrivateDataFeatures
func (x PhysicalDevicePrivateDataFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePrivateDataFeatures) WithPNext(y unsafe.Pointer) PhysicalDevicePrivateDataFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// PrivateData returns the value of privateData from VkPhysicalDevicePrivateDataFeatures
func (x PhysicalDevicePrivateDataFeatures) PrivateData() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.privateData) 
	return *ptr
}

// WithPrivateData sets the value for the PrivateData on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePrivateDataFeatures) WithPrivateData(y Bool32) PhysicalDevicePrivateDataFeatures {
	x.privateData = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// FormatProperties3 provides a go interface for VkFormatProperties3.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatProperties3.html
type FormatProperties3 C.struct_VkFormatProperties3

// SizeofFormatProperties3 is the memory size of a FormatProperties3
var SizeofFormatProperties3 int = int(unsafe.Sizeof(FormatProperties3{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *FormatProperties3) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x FormatProperties3) AsCPtr() *FormatProperties3 {
	clone := (*FormatProperties3)(newCBlock(C.ulong(SizeofFormatProperties3)))
	*clone = x
	return clone
}

// FormatProperties3FreeCSlice releases the memory allocated by FormatProperties3MakeCSlice.
// It does not free pointers stored inside the slice.
func FormatProperties3FreeCSlice(x []FormatProperties3) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// FormatProperties3MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. FormatProperties3FreeCSlice must be called on the returned slice.
func FormatProperties3MakeCSlice(x ...FormatProperties3) []FormatProperties3 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofFormatProperties3 * len(x)
	dst := unsafe.Slice((*FormatProperties3)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkFormatProperties3
func (x FormatProperties3) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x FormatProperties3) WithDefaultSType() FormatProperties3 {
	return x.WithSType(VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FormatProperties3) WithSType(y StructureType) FormatProperties3 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkFormatProperties3
func (x FormatProperties3) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x FormatProperties3) WithPNext(y unsafe.Pointer) FormatProperties3 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// LinearTilingFeatures returns the value of linearTilingFeatures from VkFormatProperties3
func (x FormatProperties3) LinearTilingFeatures() FormatFeatureFlags2 {
	ptr := /* typedef */ (*FormatFeatureFlags2)(&x.linearTilingFeatures) 
	return *ptr
}

// OptimalTilingFeatures returns the value of optimalTilingFeatures from VkFormatProperties3
func (x FormatProperties3) OptimalTilingFeatures() FormatFeatureFlags2 {
	ptr := /* typedef */ (*FormatFeatureFlags2)(&x.optimalTilingFeatures) 
	return *ptr
}

// BufferFeatures returns the value of bufferFeatures from VkFormatProperties3
func (x FormatProperties3) BufferFeatures() FormatFeatureFlags2 {
	ptr := /* typedef */ (*FormatFeatureFlags2)(&x.bufferFeatures) 
	return *ptr
}

// PhysicalDevicePipelineCreationCacheControlFeatures provides a go interface for VkPhysicalDevicePipelineCreationCacheControlFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePipelineCreationCacheControlFeatures.html
type PhysicalDevicePipelineCreationCacheControlFeatures C.struct_VkPhysicalDevicePipelineCreationCacheControlFeatures

// SizeofPhysicalDevicePipelineCreationCacheControlFeatures is the memory size of a PhysicalDevicePipelineCreationCacheControlFeatures
var SizeofPhysicalDevicePipelineCreationCacheControlFeatures int = int(unsafe.Sizeof(PhysicalDevicePipelineCreationCacheControlFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDevicePipelineCreationCacheControlFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDevicePipelineCreationCacheControlFeatures) AsCPtr() *PhysicalDevicePipelineCreationCacheControlFeatures {
	clone := (*PhysicalDevicePipelineCreationCacheControlFeatures)(newCBlock(C.ulong(SizeofPhysicalDevicePipelineCreationCacheControlFeatures)))
	*clone = x
	return clone
}

// PhysicalDevicePipelineCreationCacheControlFeaturesFreeCSlice releases the memory allocated by PhysicalDevicePipelineCreationCacheControlFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDevicePipelineCreationCacheControlFeaturesFreeCSlice(x []PhysicalDevicePipelineCreationCacheControlFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDevicePipelineCreationCacheControlFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDevicePipelineCreationCacheControlFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDevicePipelineCreationCacheControlFeaturesMakeCSlice(x ...PhysicalDevicePipelineCreationCacheControlFeatures) []PhysicalDevicePipelineCreationCacheControlFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDevicePipelineCreationCacheControlFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDevicePipelineCreationCacheControlFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDevicePipelineCreationCacheControlFeatures
func (x PhysicalDevicePipelineCreationCacheControlFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDevicePipelineCreationCacheControlFeatures) WithDefaultSType() PhysicalDevicePipelineCreationCacheControlFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePipelineCreationCacheControlFeatures) WithSType(y StructureType) PhysicalDevicePipelineCreationCacheControlFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDevicePipelineCreationCacheControlFeatures
func (x PhysicalDevicePipelineCreationCacheControlFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePipelineCreationCacheControlFeatures) WithPNext(y unsafe.Pointer) PhysicalDevicePipelineCreationCacheControlFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// PipelineCreationCacheControl returns the value of pipelineCreationCacheControl from VkPhysicalDevicePipelineCreationCacheControlFeatures
func (x PhysicalDevicePipelineCreationCacheControlFeatures) PipelineCreationCacheControl() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.pipelineCreationCacheControl) 
	return *ptr
}

// WithPipelineCreationCacheControl sets the value for the PipelineCreationCacheControl on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePipelineCreationCacheControlFeatures) WithPipelineCreationCacheControl(y Bool32) PhysicalDevicePipelineCreationCacheControlFeatures {
	x.pipelineCreationCacheControl = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// PhysicalDeviceMaintenance4Features provides a go interface for VkPhysicalDeviceMaintenance4Features.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance4Features.html
type PhysicalDeviceMaintenance4Features C.struct_VkPhysicalDeviceMaintenance4Features

// SizeofPhysicalDeviceMaintenance4Features is the memory size of a PhysicalDeviceMaintenance4Features
var SizeofPhysicalDeviceMaintenance4Features int = int(unsafe.Sizeof(PhysicalDeviceMaintenance4Features{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceMaintenance4Features) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceMaintenance4Features) AsCPtr() *PhysicalDeviceMaintenance4Features {
	clone := (*PhysicalDeviceMaintenance4Features)(newCBlock(C.ulong(SizeofPhysicalDeviceMaintenance4Features)))
	*clone = x
	return clone
}

// PhysicalDeviceMaintenance4FeaturesFreeCSlice releases the memory allocated by PhysicalDeviceMaintenance4FeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceMaintenance4FeaturesFreeCSlice(x []PhysicalDeviceMaintenance4Features) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceMaintenance4FeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceMaintenance4FeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceMaintenance4FeaturesMakeCSlice(x ...PhysicalDeviceMaintenance4Features) []PhysicalDeviceMaintenance4Features {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceMaintenance4Features * len(x)
	dst := unsafe.Slice((*PhysicalDeviceMaintenance4Features)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceMaintenance4Features
func (x PhysicalDeviceMaintenance4Features) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceMaintenance4Features) WithDefaultSType() PhysicalDeviceMaintenance4Features {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMaintenance4Features) WithSType(y StructureType) PhysicalDeviceMaintenance4Features {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceMaintenance4Features
func (x PhysicalDeviceMaintenance4Features) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMaintenance4Features) WithPNext(y unsafe.Pointer) PhysicalDeviceMaintenance4Features {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Maintenance4 returns the value of maintenance4 from VkPhysicalDeviceMaintenance4Features
func (x PhysicalDeviceMaintenance4Features) Maintenance4() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.maintenance4) 
	return *ptr
}

// WithMaintenance4 sets the value for the Maintenance4 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMaintenance4Features) WithMaintenance4(y Bool32) PhysicalDeviceMaintenance4Features {
	x.maintenance4 = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// PhysicalDeviceTexelBufferAlignmentProperties provides a go interface for VkPhysicalDeviceTexelBufferAlignmentProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTexelBufferAlignmentProperties.html
type PhysicalDeviceTexelBufferAlignmentProperties C.struct_VkPhysicalDeviceTexelBufferAlignmentProperties

// SizeofPhysicalDeviceTexelBufferAlignmentProperties is the memory size of a PhysicalDeviceTexelBufferAlignmentProperties
var SizeofPhysicalDeviceTexelBufferAlignmentProperties int = int(unsafe.Sizeof(PhysicalDeviceTexelBufferAlignmentProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceTexelBufferAlignmentProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceTexelBufferAlignmentProperties) AsCPtr() *PhysicalDeviceTexelBufferAlignmentProperties {
	clone := (*PhysicalDeviceTexelBufferAlignmentProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceTexelBufferAlignmentProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceTexelBufferAlignmentPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceTexelBufferAlignmentPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceTexelBufferAlignmentPropertiesFreeCSlice(x []PhysicalDeviceTexelBufferAlignmentProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceTexelBufferAlignmentPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceTexelBufferAlignmentPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceTexelBufferAlignmentPropertiesMakeCSlice(x ...PhysicalDeviceTexelBufferAlignmentProperties) []PhysicalDeviceTexelBufferAlignmentProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceTexelBufferAlignmentProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceTexelBufferAlignmentProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceTexelBufferAlignmentProperties
func (x PhysicalDeviceTexelBufferAlignmentProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceTexelBufferAlignmentProperties) WithDefaultSType() PhysicalDeviceTexelBufferAlignmentProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceTexelBufferAlignmentProperties) WithSType(y StructureType) PhysicalDeviceTexelBufferAlignmentProperties {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceTexelBufferAlignmentProperties
func (x PhysicalDeviceTexelBufferAlignmentProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceTexelBufferAlignmentProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceTexelBufferAlignmentProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// StorageTexelBufferOffsetAlignmentBytes returns the value of storageTexelBufferOffsetAlignmentBytes from VkPhysicalDeviceTexelBufferAlignmentProperties
func (x PhysicalDeviceTexelBufferAlignmentProperties) StorageTexelBufferOffsetAlignmentBytes() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.storageTexelBufferOffsetAlignmentBytes) 
	return *ptr
}

// StorageTexelBufferOffsetSingleTexelAlignment returns the value of storageTexelBufferOffsetSingleTexelAlignment from VkPhysicalDeviceTexelBufferAlignmentProperties
func (x PhysicalDeviceTexelBufferAlignmentProperties) StorageTexelBufferOffsetSingleTexelAlignment() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storageTexelBufferOffsetSingleTexelAlignment) 
	return *ptr
}

// UniformTexelBufferOffsetAlignmentBytes returns the value of uniformTexelBufferOffsetAlignmentBytes from VkPhysicalDeviceTexelBufferAlignmentProperties
func (x PhysicalDeviceTexelBufferAlignmentProperties) UniformTexelBufferOffsetAlignmentBytes() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.uniformTexelBufferOffsetAlignmentBytes) 
	return *ptr
}

// UniformTexelBufferOffsetSingleTexelAlignment returns the value of uniformTexelBufferOffsetSingleTexelAlignment from VkPhysicalDeviceTexelBufferAlignmentProperties
func (x PhysicalDeviceTexelBufferAlignmentProperties) UniformTexelBufferOffsetSingleTexelAlignment() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.uniformTexelBufferOffsetSingleTexelAlignment) 
	return *ptr
}

// PhysicalDeviceMaintenance4Properties provides a go interface for VkPhysicalDeviceMaintenance4Properties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance4Properties.html
type PhysicalDeviceMaintenance4Properties C.struct_VkPhysicalDeviceMaintenance4Properties

// SizeofPhysicalDeviceMaintenance4Properties is the memory size of a PhysicalDeviceMaintenance4Properties
var SizeofPhysicalDeviceMaintenance4Properties int = int(unsafe.Sizeof(PhysicalDeviceMaintenance4Properties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceMaintenance4Properties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceMaintenance4Properties) AsCPtr() *PhysicalDeviceMaintenance4Properties {
	clone := (*PhysicalDeviceMaintenance4Properties)(newCBlock(C.ulong(SizeofPhysicalDeviceMaintenance4Properties)))
	*clone = x
	return clone
}

// PhysicalDeviceMaintenance4PropertiesFreeCSlice releases the memory allocated by PhysicalDeviceMaintenance4PropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceMaintenance4PropertiesFreeCSlice(x []PhysicalDeviceMaintenance4Properties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceMaintenance4PropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceMaintenance4PropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceMaintenance4PropertiesMakeCSlice(x ...PhysicalDeviceMaintenance4Properties) []PhysicalDeviceMaintenance4Properties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceMaintenance4Properties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceMaintenance4Properties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceMaintenance4Properties
func (x PhysicalDeviceMaintenance4Properties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceMaintenance4Properties) WithDefaultSType() PhysicalDeviceMaintenance4Properties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMaintenance4Properties) WithSType(y StructureType) PhysicalDeviceMaintenance4Properties {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceMaintenance4Properties
func (x PhysicalDeviceMaintenance4Properties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceMaintenance4Properties) WithPNext(y unsafe.Pointer) PhysicalDeviceMaintenance4Properties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// MaxBufferSize returns the value of maxBufferSize from VkPhysicalDeviceMaintenance4Properties
func (x PhysicalDeviceMaintenance4Properties) MaxBufferSize() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.maxBufferSize) 
	return *ptr
}

// PhysicalDeviceShaderIntegerDotProductFeatures provides a go interface for VkPhysicalDeviceShaderIntegerDotProductFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderIntegerDotProductFeatures.html
type PhysicalDeviceShaderIntegerDotProductFeatures C.struct_VkPhysicalDeviceShaderIntegerDotProductFeatures

// SizeofPhysicalDeviceShaderIntegerDotProductFeatures is the memory size of a PhysicalDeviceShaderIntegerDotProductFeatures
var SizeofPhysicalDeviceShaderIntegerDotProductFeatures int = int(unsafe.Sizeof(PhysicalDeviceShaderIntegerDotProductFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceShaderIntegerDotProductFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceShaderIntegerDotProductFeatures) AsCPtr() *PhysicalDeviceShaderIntegerDotProductFeatures {
	clone := (*PhysicalDeviceShaderIntegerDotProductFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceShaderIntegerDotProductFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceShaderIntegerDotProductFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceShaderIntegerDotProductFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceShaderIntegerDotProductFeaturesFreeCSlice(x []PhysicalDeviceShaderIntegerDotProductFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceShaderIntegerDotProductFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceShaderIntegerDotProductFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceShaderIntegerDotProductFeaturesMakeCSlice(x ...PhysicalDeviceShaderIntegerDotProductFeatures) []PhysicalDeviceShaderIntegerDotProductFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderIntegerDotProductFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceShaderIntegerDotProductFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceShaderIntegerDotProductFeatures
func (x PhysicalDeviceShaderIntegerDotProductFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceShaderIntegerDotProductFeatures) WithDefaultSType() PhysicalDeviceShaderIntegerDotProductFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderIntegerDotProductFeatures) WithSType(y StructureType) PhysicalDeviceShaderIntegerDotProductFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceShaderIntegerDotProductFeatures
func (x PhysicalDeviceShaderIntegerDotProductFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderIntegerDotProductFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceShaderIntegerDotProductFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// ShaderIntegerDotProduct returns the value of shaderIntegerDotProduct from VkPhysicalDeviceShaderIntegerDotProductFeatures
func (x PhysicalDeviceShaderIntegerDotProductFeatures) ShaderIntegerDotProduct() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderIntegerDotProduct) 
	return *ptr
}

// WithShaderIntegerDotProduct sets the value for the ShaderIntegerDotProduct on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderIntegerDotProductFeatures) WithShaderIntegerDotProduct(y Bool32) PhysicalDeviceShaderIntegerDotProductFeatures {
	x.shaderIntegerDotProduct = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// PhysicalDeviceToolProperties provides a go interface for VkPhysicalDeviceToolProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceToolProperties.html
type PhysicalDeviceToolProperties C.struct_VkPhysicalDeviceToolProperties

// SizeofPhysicalDeviceToolProperties is the memory size of a PhysicalDeviceToolProperties
var SizeofPhysicalDeviceToolProperties int = int(unsafe.Sizeof(PhysicalDeviceToolProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceToolProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceToolProperties) AsCPtr() *PhysicalDeviceToolProperties {
	clone := (*PhysicalDeviceToolProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceToolProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceToolPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceToolPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceToolPropertiesFreeCSlice(x []PhysicalDeviceToolProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceToolPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceToolPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceToolPropertiesMakeCSlice(x ...PhysicalDeviceToolProperties) []PhysicalDeviceToolProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceToolProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceToolProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceToolProperties
func (x PhysicalDeviceToolProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceToolProperties) WithDefaultSType() PhysicalDeviceToolProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceToolProperties) WithSType(y StructureType) PhysicalDeviceToolProperties {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceToolProperties
func (x PhysicalDeviceToolProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceToolProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceToolProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Name returns the value of name from VkPhysicalDeviceToolProperties
func (x PhysicalDeviceToolProperties) Name() []byte {
	ptr := func(x *[VK_MAX_EXTENSION_NAME_SIZE]C.char) *[]byte { /* Array */ slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_EXTENSION_NAME_SIZE); return &slc }(&x.name) 
	return *ptr
}

// Version returns the value of version from VkPhysicalDeviceToolProperties
func (x PhysicalDeviceToolProperties) Version() []byte {
	ptr := func(x *[VK_MAX_EXTENSION_NAME_SIZE]C.char) *[]byte { /* Array */ slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_EXTENSION_NAME_SIZE); return &slc }(&x.version) 
	return *ptr
}

// Purposes returns the value of purposes from VkPhysicalDeviceToolProperties
func (x PhysicalDeviceToolProperties) Purposes() ToolPurposeFlags {
	ptr := /* typedef */ (*ToolPurposeFlags)(&x.purposes) 
	return *ptr
}

// Description returns the value of description from VkPhysicalDeviceToolProperties
func (x PhysicalDeviceToolProperties) Description() []byte {
	ptr := func(x *[VK_MAX_DESCRIPTION_SIZE]C.char) *[]byte { /* Array */ slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_DESCRIPTION_SIZE); return &slc }(&x.description) 
	return *ptr
}

// Layer returns the value of layer from VkPhysicalDeviceToolProperties
func (x PhysicalDeviceToolProperties) Layer() []byte {
	ptr := func(x *[VK_MAX_EXTENSION_NAME_SIZE]C.char) *[]byte { /* Array */ slc := unsafe.Slice((*byte)(unsafe.Pointer(x)), VK_MAX_EXTENSION_NAME_SIZE); return &slc }(&x.layer) 
	return *ptr
}

// DeviceBufferMemoryRequirements provides a go interface for VkDeviceBufferMemoryRequirements.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceBufferMemoryRequirements.html
type DeviceBufferMemoryRequirements C.struct_VkDeviceBufferMemoryRequirements

// SizeofDeviceBufferMemoryRequirements is the memory size of a DeviceBufferMemoryRequirements
var SizeofDeviceBufferMemoryRequirements int = int(unsafe.Sizeof(DeviceBufferMemoryRequirements{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceBufferMemoryRequirements) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceBufferMemoryRequirements) AsCPtr() *DeviceBufferMemoryRequirements {
	clone := (*DeviceBufferMemoryRequirements)(newCBlock(C.ulong(SizeofDeviceBufferMemoryRequirements)))
	*clone = x
	return clone
}

// DeviceBufferMemoryRequirementsFreeCSlice releases the memory allocated by DeviceBufferMemoryRequirementsMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceBufferMemoryRequirementsFreeCSlice(x []DeviceBufferMemoryRequirements) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceBufferMemoryRequirementsMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceBufferMemoryRequirementsFreeCSlice must be called on the returned slice.
func DeviceBufferMemoryRequirementsMakeCSlice(x ...DeviceBufferMemoryRequirements) []DeviceBufferMemoryRequirements {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceBufferMemoryRequirements * len(x)
	dst := unsafe.Slice((*DeviceBufferMemoryRequirements)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceBufferMemoryRequirements
func (x DeviceBufferMemoryRequirements) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DeviceBufferMemoryRequirements) WithDefaultSType() DeviceBufferMemoryRequirements {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceBufferMemoryRequirements) WithSType(y StructureType) DeviceBufferMemoryRequirements {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDeviceBufferMemoryRequirements
func (x DeviceBufferMemoryRequirements) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceBufferMemoryRequirements) WithPNext(y unsafe.Pointer) DeviceBufferMemoryRequirements {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// PCreateInfo returns the value of pCreateInfo from VkDeviceBufferMemoryRequirements
func (x DeviceBufferMemoryRequirements) PCreateInfo() *BufferCreateInfo {
	ptr := func(x **C.struct_VkBufferCreateInfo) **BufferCreateInfo { /* Pointer */ c2g := (*BufferCreateInfo)(*x); return &c2g }(&x.pCreateInfo) 
	return *ptr
}

// WithPCreateInfo sets the value for the PCreateInfo on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceBufferMemoryRequirements) WithPCreateInfo(y *BufferCreateInfo) DeviceBufferMemoryRequirements {
	x.pCreateInfo = *(func(x **BufferCreateInfo) **C.struct_VkBufferCreateInfo { /* Pointer */ g2c := (*C.struct_VkBufferCreateInfo)(*x); return &g2c }(&y))
	return x
}

// PhysicalDeviceShaderTerminateInvocationFeatures provides a go interface for VkPhysicalDeviceShaderTerminateInvocationFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderTerminateInvocationFeatures.html
type PhysicalDeviceShaderTerminateInvocationFeatures C.struct_VkPhysicalDeviceShaderTerminateInvocationFeatures

// SizeofPhysicalDeviceShaderTerminateInvocationFeatures is the memory size of a PhysicalDeviceShaderTerminateInvocationFeatures
var SizeofPhysicalDeviceShaderTerminateInvocationFeatures int = int(unsafe.Sizeof(PhysicalDeviceShaderTerminateInvocationFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceShaderTerminateInvocationFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceShaderTerminateInvocationFeatures) AsCPtr() *PhysicalDeviceShaderTerminateInvocationFeatures {
	clone := (*PhysicalDeviceShaderTerminateInvocationFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceShaderTerminateInvocationFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceShaderTerminateInvocationFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceShaderTerminateInvocationFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceShaderTerminateInvocationFeaturesFreeCSlice(x []PhysicalDeviceShaderTerminateInvocationFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceShaderTerminateInvocationFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceShaderTerminateInvocationFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceShaderTerminateInvocationFeaturesMakeCSlice(x ...PhysicalDeviceShaderTerminateInvocationFeatures) []PhysicalDeviceShaderTerminateInvocationFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderTerminateInvocationFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceShaderTerminateInvocationFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceShaderTerminateInvocationFeatures
func (x PhysicalDeviceShaderTerminateInvocationFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceShaderTerminateInvocationFeatures) WithDefaultSType() PhysicalDeviceShaderTerminateInvocationFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderTerminateInvocationFeatures) WithSType(y StructureType) PhysicalDeviceShaderTerminateInvocationFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceShaderTerminateInvocationFeatures
func (x PhysicalDeviceShaderTerminateInvocationFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderTerminateInvocationFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceShaderTerminateInvocationFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// ShaderTerminateInvocation returns the value of shaderTerminateInvocation from VkPhysicalDeviceShaderTerminateInvocationFeatures
func (x PhysicalDeviceShaderTerminateInvocationFeatures) ShaderTerminateInvocation() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderTerminateInvocation) 
	return *ptr
}

// WithShaderTerminateInvocation sets the value for the ShaderTerminateInvocation on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderTerminateInvocationFeatures) WithShaderTerminateInvocation(y Bool32) PhysicalDeviceShaderTerminateInvocationFeatures {
	x.shaderTerminateInvocation = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// PipelineCreationFeedback provides a go interface for VkPipelineCreationFeedback.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreationFeedback.html
type PipelineCreationFeedback C.struct_VkPipelineCreationFeedback

// SizeofPipelineCreationFeedback is the memory size of a PipelineCreationFeedback
var SizeofPipelineCreationFeedback int = int(unsafe.Sizeof(PipelineCreationFeedback{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineCreationFeedback) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineCreationFeedback) AsCPtr() *PipelineCreationFeedback {
	clone := (*PipelineCreationFeedback)(newCBlock(C.ulong(SizeofPipelineCreationFeedback)))
	*clone = x
	return clone
}

// PipelineCreationFeedbackFreeCSlice releases the memory allocated by PipelineCreationFeedbackMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineCreationFeedbackFreeCSlice(x []PipelineCreationFeedback) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineCreationFeedbackMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineCreationFeedbackFreeCSlice must be called on the returned slice.
func PipelineCreationFeedbackMakeCSlice(x ...PipelineCreationFeedback) []PipelineCreationFeedback {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineCreationFeedback * len(x)
	dst := unsafe.Slice((*PipelineCreationFeedback)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Flags returns the value of flags from VkPipelineCreationFeedback
func (x PipelineCreationFeedback) Flags() PipelineCreationFeedbackFlags {
	ptr := /* typedef */ (*PipelineCreationFeedbackFlags)(&x.flags) 
	return *ptr
}

// Duration returns the value of duration from VkPipelineCreationFeedback
func (x PipelineCreationFeedback) Duration() uint64 {
	ptr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.duration) 
	return *ptr
}

// PipelineCreationFeedbackCreateInfo provides a go interface for VkPipelineCreationFeedbackCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineCreationFeedbackCreateInfo.html
type PipelineCreationFeedbackCreateInfo C.struct_VkPipelineCreationFeedbackCreateInfo

// SizeofPipelineCreationFeedbackCreateInfo is the memory size of a PipelineCreationFeedbackCreateInfo
var SizeofPipelineCreationFeedbackCreateInfo int = int(unsafe.Sizeof(PipelineCreationFeedbackCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineCreationFeedbackCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineCreationFeedbackCreateInfo) AsCPtr() *PipelineCreationFeedbackCreateInfo {
	clone := (*PipelineCreationFeedbackCreateInfo)(newCBlock(C.ulong(SizeofPipelineCreationFeedbackCreateInfo)))
	*clone = x
	return clone
}

// PipelineCreationFeedbackCreateInfoFreeCSlice releases the memory allocated by PipelineCreationFeedbackCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineCreationFeedbackCreateInfoFreeCSlice(x []PipelineCreationFeedbackCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineCreationFeedbackCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineCreationFeedbackCreateInfoFreeCSlice must be called on the returned slice.
func PipelineCreationFeedbackCreateInfoMakeCSlice(x ...PipelineCreationFeedbackCreateInfo) []PipelineCreationFeedbackCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineCreationFeedbackCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineCreationFeedbackCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineCreationFeedbackCreateInfo
func (x PipelineCreationFeedbackCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineCreationFeedbackCreateInfo) WithDefaultSType() PipelineCreationFeedbackCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCreationFeedbackCreateInfo) WithSType(y StructureType) PipelineCreationFeedbackCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPipelineCreationFeedbackCreateInfo
func (x PipelineCreationFeedbackCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCreationFeedbackCreateInfo) WithPNext(y unsafe.Pointer) PipelineCreationFeedbackCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// PPipelineCreationFeedback returns the value of pPipelineCreationFeedback from VkPipelineCreationFeedbackCreateInfo
func (x PipelineCreationFeedbackCreateInfo) PPipelineCreationFeedback() *PipelineCreationFeedback {
	ptr := func(x **C.struct_VkPipelineCreationFeedback) **PipelineCreationFeedback { /* Pointer */ c2g := (*PipelineCreationFeedback)(*x); return &c2g }(&x.pPipelineCreationFeedback) 
	return *ptr
}

// WithPPipelineCreationFeedback sets the value for the PPipelineCreationFeedback on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCreationFeedbackCreateInfo) WithPPipelineCreationFeedback(y *PipelineCreationFeedback) PipelineCreationFeedbackCreateInfo {
	x.pPipelineCreationFeedback = *(func(x **PipelineCreationFeedback) **C.struct_VkPipelineCreationFeedback { /* Pointer */ g2c := (*C.struct_VkPipelineCreationFeedback)(*x); return &g2c }(&y))
	return x
}

// PipelineStageCreationFeedbackCount returns the value of pipelineStageCreationFeedbackCount from VkPipelineCreationFeedbackCreateInfo
func (x PipelineCreationFeedbackCreateInfo) PipelineStageCreationFeedbackCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.pipelineStageCreationFeedbackCount) 
	return *ptr
}

// WithPipelineStageCreationFeedbackCount sets the value for the PipelineStageCreationFeedbackCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineCreationFeedbackCreateInfo) WithPipelineStageCreationFeedbackCount(y uint32) PipelineCreationFeedbackCreateInfo {
	x.pipelineStageCreationFeedbackCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PPipelineStageCreationFeedbacks returns the value of pPipelineStageCreationFeedbacks from VkPipelineCreationFeedbackCreateInfo
func (x PipelineCreationFeedbackCreateInfo) PPipelineStageCreationFeedbacks() []PipelineCreationFeedback {
	ptr := func(x **C.struct_VkPipelineCreationFeedback) *[]PipelineCreationFeedback { /* Slice */ slc := unsafe.Slice((*PipelineCreationFeedback)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pPipelineStageCreationFeedbacks) 
	return *ptr
}

// WithPPipelineStageCreationFeedbacks sets the value for the PPipelineStageCreationFeedbacks on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines PipelineStageCreationFeedbackCount as the length of this field.
// PipelineStageCreationFeedbackCount is updated with the length of the new value.
func (x PipelineCreationFeedbackCreateInfo) WithPPipelineStageCreationFeedbacks(y []PipelineCreationFeedback) PipelineCreationFeedbackCreateInfo {
	x.pPipelineStageCreationFeedbacks = *(func(x *[]PipelineCreationFeedback) **C.struct_VkPipelineCreationFeedback { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkPipelineCreationFeedback)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkPipelineCreationFeedback)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithPipelineStageCreationFeedbackCount(uint32(len(y)))
}

// PhysicalDeviceVulkan13Properties provides a go interface for VkPhysicalDeviceVulkan13Properties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Properties.html
type PhysicalDeviceVulkan13Properties C.struct_VkPhysicalDeviceVulkan13Properties

// SizeofPhysicalDeviceVulkan13Properties is the memory size of a PhysicalDeviceVulkan13Properties
var SizeofPhysicalDeviceVulkan13Properties int = int(unsafe.Sizeof(PhysicalDeviceVulkan13Properties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceVulkan13Properties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceVulkan13Properties) AsCPtr() *PhysicalDeviceVulkan13Properties {
	clone := (*PhysicalDeviceVulkan13Properties)(newCBlock(C.ulong(SizeofPhysicalDeviceVulkan13Properties)))
	*clone = x
	return clone
}

// PhysicalDeviceVulkan13PropertiesFreeCSlice releases the memory allocated by PhysicalDeviceVulkan13PropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceVulkan13PropertiesFreeCSlice(x []PhysicalDeviceVulkan13Properties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceVulkan13PropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceVulkan13PropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceVulkan13PropertiesMakeCSlice(x ...PhysicalDeviceVulkan13Properties) []PhysicalDeviceVulkan13Properties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVulkan13Properties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceVulkan13Properties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceVulkan13Properties) WithDefaultSType() PhysicalDeviceVulkan13Properties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Properties) WithSType(y StructureType) PhysicalDeviceVulkan13Properties {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Properties) WithPNext(y unsafe.Pointer) PhysicalDeviceVulkan13Properties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// MinSubgroupSize returns the value of minSubgroupSize from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) MinSubgroupSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.minSubgroupSize) 
	return *ptr
}

// MaxSubgroupSize returns the value of maxSubgroupSize from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) MaxSubgroupSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxSubgroupSize) 
	return *ptr
}

// MaxComputeWorkgroupSubgroups returns the value of maxComputeWorkgroupSubgroups from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) MaxComputeWorkgroupSubgroups() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxComputeWorkgroupSubgroups) 
	return *ptr
}

// RequiredSubgroupSizeStages returns the value of requiredSubgroupSizeStages from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) RequiredSubgroupSizeStages() ShaderStageFlags {
	ptr := /* typedef */ (*ShaderStageFlags)(&x.requiredSubgroupSizeStages) 
	return *ptr
}

// MaxInlineUniformBlockSize returns the value of maxInlineUniformBlockSize from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) MaxInlineUniformBlockSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxInlineUniformBlockSize) 
	return *ptr
}

// MaxPerStageDescriptorInlineUniformBlocks returns the value of maxPerStageDescriptorInlineUniformBlocks from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) MaxPerStageDescriptorInlineUniformBlocks() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorInlineUniformBlocks) 
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks returns the value of maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks) 
	return *ptr
}

// MaxDescriptorSetInlineUniformBlocks returns the value of maxDescriptorSetInlineUniformBlocks from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) MaxDescriptorSetInlineUniformBlocks() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetInlineUniformBlocks) 
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindInlineUniformBlocks returns the value of maxDescriptorSetUpdateAfterBindInlineUniformBlocks from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) MaxDescriptorSetUpdateAfterBindInlineUniformBlocks() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindInlineUniformBlocks) 
	return *ptr
}

// MaxInlineUniformTotalSize returns the value of maxInlineUniformTotalSize from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) MaxInlineUniformTotalSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxInlineUniformTotalSize) 
	return *ptr
}

// IntegerDotProduct8BitUnsignedAccelerated returns the value of integerDotProduct8BitUnsignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct8BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct8BitUnsignedAccelerated) 
	return *ptr
}

// IntegerDotProduct8BitSignedAccelerated returns the value of integerDotProduct8BitSignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct8BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct8BitSignedAccelerated) 
	return *ptr
}

// IntegerDotProduct8BitMixedSignednessAccelerated returns the value of integerDotProduct8BitMixedSignednessAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct8BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct8BitMixedSignednessAccelerated) 
	return *ptr
}

// IntegerDotProduct4x8BitPackedUnsignedAccelerated returns the value of integerDotProduct4x8BitPackedUnsignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct4x8BitPackedUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct4x8BitPackedUnsignedAccelerated) 
	return *ptr
}

// IntegerDotProduct4x8BitPackedSignedAccelerated returns the value of integerDotProduct4x8BitPackedSignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct4x8BitPackedSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct4x8BitPackedSignedAccelerated) 
	return *ptr
}

// IntegerDotProduct4x8BitPackedMixedSignednessAccelerated returns the value of integerDotProduct4x8BitPackedMixedSignednessAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct4x8BitPackedMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct4x8BitPackedMixedSignednessAccelerated) 
	return *ptr
}

// IntegerDotProduct16BitUnsignedAccelerated returns the value of integerDotProduct16BitUnsignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct16BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct16BitUnsignedAccelerated) 
	return *ptr
}

// IntegerDotProduct16BitSignedAccelerated returns the value of integerDotProduct16BitSignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct16BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct16BitSignedAccelerated) 
	return *ptr
}

// IntegerDotProduct16BitMixedSignednessAccelerated returns the value of integerDotProduct16BitMixedSignednessAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct16BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct16BitMixedSignednessAccelerated) 
	return *ptr
}

// IntegerDotProduct32BitUnsignedAccelerated returns the value of integerDotProduct32BitUnsignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct32BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct32BitUnsignedAccelerated) 
	return *ptr
}

// IntegerDotProduct32BitSignedAccelerated returns the value of integerDotProduct32BitSignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct32BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct32BitSignedAccelerated) 
	return *ptr
}

// IntegerDotProduct32BitMixedSignednessAccelerated returns the value of integerDotProduct32BitMixedSignednessAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct32BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct32BitMixedSignednessAccelerated) 
	return *ptr
}

// IntegerDotProduct64BitUnsignedAccelerated returns the value of integerDotProduct64BitUnsignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct64BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct64BitUnsignedAccelerated) 
	return *ptr
}

// IntegerDotProduct64BitSignedAccelerated returns the value of integerDotProduct64BitSignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct64BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct64BitSignedAccelerated) 
	return *ptr
}

// IntegerDotProduct64BitMixedSignednessAccelerated returns the value of integerDotProduct64BitMixedSignednessAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProduct64BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct64BitMixedSignednessAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating8BitUnsignedAccelerated returns the value of integerDotProductAccumulatingSaturating8BitUnsignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating8BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating8BitSignedAccelerated returns the value of integerDotProductAccumulatingSaturating8BitSignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating8BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating8BitSignedAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated returns the value of integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated returns the value of integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated returns the value of integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated returns the value of integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating16BitUnsignedAccelerated returns the value of integerDotProductAccumulatingSaturating16BitUnsignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating16BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating16BitSignedAccelerated returns the value of integerDotProductAccumulatingSaturating16BitSignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating16BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating16BitSignedAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated returns the value of integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating32BitUnsignedAccelerated returns the value of integerDotProductAccumulatingSaturating32BitUnsignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating32BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating32BitSignedAccelerated returns the value of integerDotProductAccumulatingSaturating32BitSignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating32BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating32BitSignedAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated returns the value of integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating64BitUnsignedAccelerated returns the value of integerDotProductAccumulatingSaturating64BitUnsignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating64BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating64BitSignedAccelerated returns the value of integerDotProductAccumulatingSaturating64BitSignedAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating64BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating64BitSignedAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated returns the value of integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) IntegerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated) 
	return *ptr
}

// StorageTexelBufferOffsetAlignmentBytes returns the value of storageTexelBufferOffsetAlignmentBytes from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) StorageTexelBufferOffsetAlignmentBytes() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.storageTexelBufferOffsetAlignmentBytes) 
	return *ptr
}

// StorageTexelBufferOffsetSingleTexelAlignment returns the value of storageTexelBufferOffsetSingleTexelAlignment from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) StorageTexelBufferOffsetSingleTexelAlignment() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.storageTexelBufferOffsetSingleTexelAlignment) 
	return *ptr
}

// UniformTexelBufferOffsetAlignmentBytes returns the value of uniformTexelBufferOffsetAlignmentBytes from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) UniformTexelBufferOffsetAlignmentBytes() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.uniformTexelBufferOffsetAlignmentBytes) 
	return *ptr
}

// UniformTexelBufferOffsetSingleTexelAlignment returns the value of uniformTexelBufferOffsetSingleTexelAlignment from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) UniformTexelBufferOffsetSingleTexelAlignment() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.uniformTexelBufferOffsetSingleTexelAlignment) 
	return *ptr
}

// MaxBufferSize returns the value of maxBufferSize from VkPhysicalDeviceVulkan13Properties
func (x PhysicalDeviceVulkan13Properties) MaxBufferSize() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.maxBufferSize) 
	return *ptr
}

// PhysicalDeviceShaderIntegerDotProductProperties provides a go interface for VkPhysicalDeviceShaderIntegerDotProductProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderIntegerDotProductProperties.html
type PhysicalDeviceShaderIntegerDotProductProperties C.struct_VkPhysicalDeviceShaderIntegerDotProductProperties

// SizeofPhysicalDeviceShaderIntegerDotProductProperties is the memory size of a PhysicalDeviceShaderIntegerDotProductProperties
var SizeofPhysicalDeviceShaderIntegerDotProductProperties int = int(unsafe.Sizeof(PhysicalDeviceShaderIntegerDotProductProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceShaderIntegerDotProductProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceShaderIntegerDotProductProperties) AsCPtr() *PhysicalDeviceShaderIntegerDotProductProperties {
	clone := (*PhysicalDeviceShaderIntegerDotProductProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceShaderIntegerDotProductProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceShaderIntegerDotProductPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceShaderIntegerDotProductPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceShaderIntegerDotProductPropertiesFreeCSlice(x []PhysicalDeviceShaderIntegerDotProductProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceShaderIntegerDotProductPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceShaderIntegerDotProductPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceShaderIntegerDotProductPropertiesMakeCSlice(x ...PhysicalDeviceShaderIntegerDotProductProperties) []PhysicalDeviceShaderIntegerDotProductProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderIntegerDotProductProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceShaderIntegerDotProductProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceShaderIntegerDotProductProperties) WithDefaultSType() PhysicalDeviceShaderIntegerDotProductProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderIntegerDotProductProperties) WithSType(y StructureType) PhysicalDeviceShaderIntegerDotProductProperties {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderIntegerDotProductProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceShaderIntegerDotProductProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// IntegerDotProduct8BitUnsignedAccelerated returns the value of integerDotProduct8BitUnsignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct8BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct8BitUnsignedAccelerated) 
	return *ptr
}

// IntegerDotProduct8BitSignedAccelerated returns the value of integerDotProduct8BitSignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct8BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct8BitSignedAccelerated) 
	return *ptr
}

// IntegerDotProduct8BitMixedSignednessAccelerated returns the value of integerDotProduct8BitMixedSignednessAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct8BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct8BitMixedSignednessAccelerated) 
	return *ptr
}

// IntegerDotProduct4x8BitPackedUnsignedAccelerated returns the value of integerDotProduct4x8BitPackedUnsignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct4x8BitPackedUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct4x8BitPackedUnsignedAccelerated) 
	return *ptr
}

// IntegerDotProduct4x8BitPackedSignedAccelerated returns the value of integerDotProduct4x8BitPackedSignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct4x8BitPackedSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct4x8BitPackedSignedAccelerated) 
	return *ptr
}

// IntegerDotProduct4x8BitPackedMixedSignednessAccelerated returns the value of integerDotProduct4x8BitPackedMixedSignednessAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct4x8BitPackedMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct4x8BitPackedMixedSignednessAccelerated) 
	return *ptr
}

// IntegerDotProduct16BitUnsignedAccelerated returns the value of integerDotProduct16BitUnsignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct16BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct16BitUnsignedAccelerated) 
	return *ptr
}

// IntegerDotProduct16BitSignedAccelerated returns the value of integerDotProduct16BitSignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct16BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct16BitSignedAccelerated) 
	return *ptr
}

// IntegerDotProduct16BitMixedSignednessAccelerated returns the value of integerDotProduct16BitMixedSignednessAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct16BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct16BitMixedSignednessAccelerated) 
	return *ptr
}

// IntegerDotProduct32BitUnsignedAccelerated returns the value of integerDotProduct32BitUnsignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct32BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct32BitUnsignedAccelerated) 
	return *ptr
}

// IntegerDotProduct32BitSignedAccelerated returns the value of integerDotProduct32BitSignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct32BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct32BitSignedAccelerated) 
	return *ptr
}

// IntegerDotProduct32BitMixedSignednessAccelerated returns the value of integerDotProduct32BitMixedSignednessAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct32BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct32BitMixedSignednessAccelerated) 
	return *ptr
}

// IntegerDotProduct64BitUnsignedAccelerated returns the value of integerDotProduct64BitUnsignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct64BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct64BitUnsignedAccelerated) 
	return *ptr
}

// IntegerDotProduct64BitSignedAccelerated returns the value of integerDotProduct64BitSignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct64BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct64BitSignedAccelerated) 
	return *ptr
}

// IntegerDotProduct64BitMixedSignednessAccelerated returns the value of integerDotProduct64BitMixedSignednessAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProduct64BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProduct64BitMixedSignednessAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating8BitUnsignedAccelerated returns the value of integerDotProductAccumulatingSaturating8BitUnsignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating8BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating8BitSignedAccelerated returns the value of integerDotProductAccumulatingSaturating8BitSignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating8BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating8BitSignedAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated returns the value of integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated returns the value of integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated returns the value of integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated returns the value of integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating16BitUnsignedAccelerated returns the value of integerDotProductAccumulatingSaturating16BitUnsignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating16BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating16BitSignedAccelerated returns the value of integerDotProductAccumulatingSaturating16BitSignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating16BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating16BitSignedAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated returns the value of integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating32BitUnsignedAccelerated returns the value of integerDotProductAccumulatingSaturating32BitUnsignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating32BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating32BitSignedAccelerated returns the value of integerDotProductAccumulatingSaturating32BitSignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating32BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating32BitSignedAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated returns the value of integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating64BitUnsignedAccelerated returns the value of integerDotProductAccumulatingSaturating64BitUnsignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating64BitUnsignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating64BitSignedAccelerated returns the value of integerDotProductAccumulatingSaturating64BitSignedAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating64BitSignedAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating64BitSignedAccelerated) 
	return *ptr
}

// IntegerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated returns the value of integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated from VkPhysicalDeviceShaderIntegerDotProductProperties
func (x PhysicalDeviceShaderIntegerDotProductProperties) IntegerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated) 
	return *ptr
}

// BufferMemoryBarrier2 provides a go interface for VkBufferMemoryBarrier2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferMemoryBarrier2.html
type BufferMemoryBarrier2 C.struct_VkBufferMemoryBarrier2

// SizeofBufferMemoryBarrier2 is the memory size of a BufferMemoryBarrier2
var SizeofBufferMemoryBarrier2 int = int(unsafe.Sizeof(BufferMemoryBarrier2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferMemoryBarrier2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferMemoryBarrier2) AsCPtr() *BufferMemoryBarrier2 {
	clone := (*BufferMemoryBarrier2)(newCBlock(C.ulong(SizeofBufferMemoryBarrier2)))
	*clone = x
	return clone
}

// BufferMemoryBarrier2FreeCSlice releases the memory allocated by BufferMemoryBarrier2MakeCSlice.
// It does not free pointers stored inside the slice.
func BufferMemoryBarrier2FreeCSlice(x []BufferMemoryBarrier2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferMemoryBarrier2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferMemoryBarrier2FreeCSlice must be called on the returned slice.
func BufferMemoryBarrier2MakeCSlice(x ...BufferMemoryBarrier2) []BufferMemoryBarrier2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferMemoryBarrier2 * len(x)
	dst := unsafe.Slice((*BufferMemoryBarrier2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBufferMemoryBarrier2
func (x BufferMemoryBarrier2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BufferMemoryBarrier2) WithDefaultSType() BufferMemoryBarrier2 {
	return x.WithSType(VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier2) WithSType(y StructureType) BufferMemoryBarrier2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkBufferMemoryBarrier2
func (x BufferMemoryBarrier2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier2) WithPNext(y unsafe.Pointer) BufferMemoryBarrier2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SrcStageMask returns the value of srcStageMask from VkBufferMemoryBarrier2
func (x BufferMemoryBarrier2) SrcStageMask() PipelineStageFlags2 {
	ptr := /* typedef */ (*PipelineStageFlags2)(&x.srcStageMask) 
	return *ptr
}

// WithSrcStageMask sets the value for the SrcStageMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier2) WithSrcStageMask(y PipelineStageFlags2) BufferMemoryBarrier2 {
	x.srcStageMask = *(/* typedef */ (*C.VkPipelineStageFlags2)(&y))
	return x
}

// SrcAccessMask returns the value of srcAccessMask from VkBufferMemoryBarrier2
func (x BufferMemoryBarrier2) SrcAccessMask() AccessFlags2 {
	ptr := /* typedef */ (*AccessFlags2)(&x.srcAccessMask) 
	return *ptr
}

// WithSrcAccessMask sets the value for the SrcAccessMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier2) WithSrcAccessMask(y AccessFlags2) BufferMemoryBarrier2 {
	x.srcAccessMask = *(/* typedef */ (*C.VkAccessFlags2)(&y))
	return x
}

// DstStageMask returns the value of dstStageMask from VkBufferMemoryBarrier2
func (x BufferMemoryBarrier2) DstStageMask() PipelineStageFlags2 {
	ptr := /* typedef */ (*PipelineStageFlags2)(&x.dstStageMask) 
	return *ptr
}

// WithDstStageMask sets the value for the DstStageMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier2) WithDstStageMask(y PipelineStageFlags2) BufferMemoryBarrier2 {
	x.dstStageMask = *(/* typedef */ (*C.VkPipelineStageFlags2)(&y))
	return x
}

// DstAccessMask returns the value of dstAccessMask from VkBufferMemoryBarrier2
func (x BufferMemoryBarrier2) DstAccessMask() AccessFlags2 {
	ptr := /* typedef */ (*AccessFlags2)(&x.dstAccessMask) 
	return *ptr
}

// WithDstAccessMask sets the value for the DstAccessMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier2) WithDstAccessMask(y AccessFlags2) BufferMemoryBarrier2 {
	x.dstAccessMask = *(/* typedef */ (*C.VkAccessFlags2)(&y))
	return x
}

// SrcQueueFamilyIndex returns the value of srcQueueFamilyIndex from VkBufferMemoryBarrier2
func (x BufferMemoryBarrier2) SrcQueueFamilyIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.srcQueueFamilyIndex) 
	return *ptr
}

// WithSrcQueueFamilyIndex sets the value for the SrcQueueFamilyIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier2) WithSrcQueueFamilyIndex(y uint32) BufferMemoryBarrier2 {
	x.srcQueueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// DstQueueFamilyIndex returns the value of dstQueueFamilyIndex from VkBufferMemoryBarrier2
func (x BufferMemoryBarrier2) DstQueueFamilyIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dstQueueFamilyIndex) 
	return *ptr
}

// WithDstQueueFamilyIndex sets the value for the DstQueueFamilyIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier2) WithDstQueueFamilyIndex(y uint32) BufferMemoryBarrier2 {
	x.dstQueueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// Buffer returns the value of buffer from VkBufferMemoryBarrier2
func (x BufferMemoryBarrier2) Buffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.buffer) 
	return *ptr
}

// WithBuffer sets the value for the Buffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier2) WithBuffer(y Buffer) BufferMemoryBarrier2 {
	x.buffer = *(/* handle */ (*C.VkBuffer)(&y))
	return x
}

// Offset returns the value of offset from VkBufferMemoryBarrier2
func (x BufferMemoryBarrier2) Offset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.offset) 
	return *ptr
}

// WithOffset sets the value for the Offset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier2) WithOffset(y DeviceSize) BufferMemoryBarrier2 {
	x.offset = *(/* typedef */ (*C.VkDeviceSize)(&y))
	return x
}

// Size returns the value of size from VkBufferMemoryBarrier2
func (x BufferMemoryBarrier2) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size) 
	return *ptr
}

// WithSize sets the value for the Size on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferMemoryBarrier2) WithSize(y DeviceSize) BufferMemoryBarrier2 {
	x.size = *(/* typedef */ (*C.VkDeviceSize)(&y))
	return x
}

// ImageMemoryBarrier2 provides a go interface for VkImageMemoryBarrier2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageMemoryBarrier2.html
type ImageMemoryBarrier2 C.struct_VkImageMemoryBarrier2

// SizeofImageMemoryBarrier2 is the memory size of a ImageMemoryBarrier2
var SizeofImageMemoryBarrier2 int = int(unsafe.Sizeof(ImageMemoryBarrier2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageMemoryBarrier2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageMemoryBarrier2) AsCPtr() *ImageMemoryBarrier2 {
	clone := (*ImageMemoryBarrier2)(newCBlock(C.ulong(SizeofImageMemoryBarrier2)))
	*clone = x
	return clone
}

// ImageMemoryBarrier2FreeCSlice releases the memory allocated by ImageMemoryBarrier2MakeCSlice.
// It does not free pointers stored inside the slice.
func ImageMemoryBarrier2FreeCSlice(x []ImageMemoryBarrier2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageMemoryBarrier2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageMemoryBarrier2FreeCSlice must be called on the returned slice.
func ImageMemoryBarrier2MakeCSlice(x ...ImageMemoryBarrier2) []ImageMemoryBarrier2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageMemoryBarrier2 * len(x)
	dst := unsafe.Slice((*ImageMemoryBarrier2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageMemoryBarrier2
func (x ImageMemoryBarrier2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ImageMemoryBarrier2) WithDefaultSType() ImageMemoryBarrier2 {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier2) WithSType(y StructureType) ImageMemoryBarrier2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkImageMemoryBarrier2
func (x ImageMemoryBarrier2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier2) WithPNext(y unsafe.Pointer) ImageMemoryBarrier2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SrcStageMask returns the value of srcStageMask from VkImageMemoryBarrier2
func (x ImageMemoryBarrier2) SrcStageMask() PipelineStageFlags2 {
	ptr := /* typedef */ (*PipelineStageFlags2)(&x.srcStageMask) 
	return *ptr
}

// WithSrcStageMask sets the value for the SrcStageMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier2) WithSrcStageMask(y PipelineStageFlags2) ImageMemoryBarrier2 {
	x.srcStageMask = *(/* typedef */ (*C.VkPipelineStageFlags2)(&y))
	return x
}

// SrcAccessMask returns the value of srcAccessMask from VkImageMemoryBarrier2
func (x ImageMemoryBarrier2) SrcAccessMask() AccessFlags2 {
	ptr := /* typedef */ (*AccessFlags2)(&x.srcAccessMask) 
	return *ptr
}

// WithSrcAccessMask sets the value for the SrcAccessMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier2) WithSrcAccessMask(y AccessFlags2) ImageMemoryBarrier2 {
	x.srcAccessMask = *(/* typedef */ (*C.VkAccessFlags2)(&y))
	return x
}

// DstStageMask returns the value of dstStageMask from VkImageMemoryBarrier2
func (x ImageMemoryBarrier2) DstStageMask() PipelineStageFlags2 {
	ptr := /* typedef */ (*PipelineStageFlags2)(&x.dstStageMask) 
	return *ptr
}

// WithDstStageMask sets the value for the DstStageMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier2) WithDstStageMask(y PipelineStageFlags2) ImageMemoryBarrier2 {
	x.dstStageMask = *(/* typedef */ (*C.VkPipelineStageFlags2)(&y))
	return x
}

// DstAccessMask returns the value of dstAccessMask from VkImageMemoryBarrier2
func (x ImageMemoryBarrier2) DstAccessMask() AccessFlags2 {
	ptr := /* typedef */ (*AccessFlags2)(&x.dstAccessMask) 
	return *ptr
}

// WithDstAccessMask sets the value for the DstAccessMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier2) WithDstAccessMask(y AccessFlags2) ImageMemoryBarrier2 {
	x.dstAccessMask = *(/* typedef */ (*C.VkAccessFlags2)(&y))
	return x
}

// OldLayout returns the value of oldLayout from VkImageMemoryBarrier2
func (x ImageMemoryBarrier2) OldLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.oldLayout) 
	return *ptr
}

// WithOldLayout sets the value for the OldLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier2) WithOldLayout(y ImageLayout) ImageMemoryBarrier2 {
	x.oldLayout = *(/* typedef */ (*C.VkImageLayout)(&y))
	return x
}

// NewLayout returns the value of newLayout from VkImageMemoryBarrier2
func (x ImageMemoryBarrier2) NewLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.newLayout) 
	return *ptr
}

// WithNewLayout sets the value for the NewLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier2) WithNewLayout(y ImageLayout) ImageMemoryBarrier2 {
	x.newLayout = *(/* typedef */ (*C.VkImageLayout)(&y))
	return x
}

// SrcQueueFamilyIndex returns the value of srcQueueFamilyIndex from VkImageMemoryBarrier2
func (x ImageMemoryBarrier2) SrcQueueFamilyIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.srcQueueFamilyIndex) 
	return *ptr
}

// WithSrcQueueFamilyIndex sets the value for the SrcQueueFamilyIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier2) WithSrcQueueFamilyIndex(y uint32) ImageMemoryBarrier2 {
	x.srcQueueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// DstQueueFamilyIndex returns the value of dstQueueFamilyIndex from VkImageMemoryBarrier2
func (x ImageMemoryBarrier2) DstQueueFamilyIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dstQueueFamilyIndex) 
	return *ptr
}

// WithDstQueueFamilyIndex sets the value for the DstQueueFamilyIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier2) WithDstQueueFamilyIndex(y uint32) ImageMemoryBarrier2 {
	x.dstQueueFamilyIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// Image returns the value of image from VkImageMemoryBarrier2
func (x ImageMemoryBarrier2) Image() Image {
	ptr := /* handle */ (*Image)(&x.image) 
	return *ptr
}

// WithImage sets the value for the Image on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier2) WithImage(y Image) ImageMemoryBarrier2 {
	x.image = *(/* handle */ (*C.VkImage)(&y))
	return x
}

// SubresourceRange returns the value of subresourceRange from VkImageMemoryBarrier2
func (x ImageMemoryBarrier2) SubresourceRange() ImageSubresourceRange {
	ptr := /* typedef */ (*ImageSubresourceRange)(&x.subresourceRange) 
	return *ptr
}

// WithSubresourceRange sets the value for the SubresourceRange on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageMemoryBarrier2) WithSubresourceRange(y ImageSubresourceRange) ImageMemoryBarrier2 {
	x.subresourceRange = *(/* typedef */ (*C.struct_VkImageSubresourceRange)(&y))
	return x
}

// DependencyInfo provides a go interface for VkDependencyInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDependencyInfo.html
type DependencyInfo C.struct_VkDependencyInfo

// SizeofDependencyInfo is the memory size of a DependencyInfo
var SizeofDependencyInfo int = int(unsafe.Sizeof(DependencyInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DependencyInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DependencyInfo) AsCPtr() *DependencyInfo {
	clone := (*DependencyInfo)(newCBlock(C.ulong(SizeofDependencyInfo)))
	*clone = x
	return clone
}

// DependencyInfoFreeCSlice releases the memory allocated by DependencyInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func DependencyInfoFreeCSlice(x []DependencyInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DependencyInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DependencyInfoFreeCSlice must be called on the returned slice.
func DependencyInfoMakeCSlice(x ...DependencyInfo) []DependencyInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDependencyInfo * len(x)
	dst := unsafe.Slice((*DependencyInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDependencyInfo
func (x DependencyInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DependencyInfo) WithDefaultSType() DependencyInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_DEPENDENCY_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DependencyInfo) WithSType(y StructureType) DependencyInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDependencyInfo
func (x DependencyInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DependencyInfo) WithPNext(y unsafe.Pointer) DependencyInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// DependencyFlags returns the value of dependencyFlags from VkDependencyInfo
func (x DependencyInfo) DependencyFlags() DependencyFlags {
	ptr := /* typedef */ (*DependencyFlags)(&x.dependencyFlags) 
	return *ptr
}

// WithDependencyFlags sets the value for the DependencyFlags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DependencyInfo) WithDependencyFlags(y DependencyFlags) DependencyInfo {
	x.dependencyFlags = *(/* typedef */ (*C.VkDependencyFlags)(&y))
	return x
}

// MemoryBarrierCount returns the value of memoryBarrierCount from VkDependencyInfo
func (x DependencyInfo) MemoryBarrierCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.memoryBarrierCount) 
	return *ptr
}

// WithMemoryBarrierCount sets the value for the MemoryBarrierCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DependencyInfo) WithMemoryBarrierCount(y uint32) DependencyInfo {
	x.memoryBarrierCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PMemoryBarriers returns the value of pMemoryBarriers from VkDependencyInfo
func (x DependencyInfo) PMemoryBarriers() []MemoryBarrier2 {
	ptr := func(x **C.struct_VkMemoryBarrier2) *[]MemoryBarrier2 { /* Slice */ slc := unsafe.Slice((*MemoryBarrier2)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pMemoryBarriers) 
	return *ptr
}

// WithPMemoryBarriers sets the value for the PMemoryBarriers on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines MemoryBarrierCount as the length of this field.
// MemoryBarrierCount is updated with the length of the new value.
func (x DependencyInfo) WithPMemoryBarriers(y []MemoryBarrier2) DependencyInfo {
	x.pMemoryBarriers = *(func(x *[]MemoryBarrier2) **C.struct_VkMemoryBarrier2 { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkMemoryBarrier2)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkMemoryBarrier2)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithMemoryBarrierCount(uint32(len(y)))
}

// BufferMemoryBarrierCount returns the value of bufferMemoryBarrierCount from VkDependencyInfo
func (x DependencyInfo) BufferMemoryBarrierCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.bufferMemoryBarrierCount) 
	return *ptr
}

// WithBufferMemoryBarrierCount sets the value for the BufferMemoryBarrierCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DependencyInfo) WithBufferMemoryBarrierCount(y uint32) DependencyInfo {
	x.bufferMemoryBarrierCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PBufferMemoryBarriers returns the value of pBufferMemoryBarriers from VkDependencyInfo
func (x DependencyInfo) PBufferMemoryBarriers() []BufferMemoryBarrier2 {
	ptr := func(x **C.struct_VkBufferMemoryBarrier2) *[]BufferMemoryBarrier2 { /* Slice */ slc := unsafe.Slice((*BufferMemoryBarrier2)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pBufferMemoryBarriers) 
	return *ptr
}

// WithPBufferMemoryBarriers sets the value for the PBufferMemoryBarriers on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines BufferMemoryBarrierCount as the length of this field.
// BufferMemoryBarrierCount is updated with the length of the new value.
func (x DependencyInfo) WithPBufferMemoryBarriers(y []BufferMemoryBarrier2) DependencyInfo {
	x.pBufferMemoryBarriers = *(func(x *[]BufferMemoryBarrier2) **C.struct_VkBufferMemoryBarrier2 { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkBufferMemoryBarrier2)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkBufferMemoryBarrier2)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithBufferMemoryBarrierCount(uint32(len(y)))
}

// ImageMemoryBarrierCount returns the value of imageMemoryBarrierCount from VkDependencyInfo
func (x DependencyInfo) ImageMemoryBarrierCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.imageMemoryBarrierCount) 
	return *ptr
}

// WithImageMemoryBarrierCount sets the value for the ImageMemoryBarrierCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DependencyInfo) WithImageMemoryBarrierCount(y uint32) DependencyInfo {
	x.imageMemoryBarrierCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PImageMemoryBarriers returns the value of pImageMemoryBarriers from VkDependencyInfo
func (x DependencyInfo) PImageMemoryBarriers() []ImageMemoryBarrier2 {
	ptr := func(x **C.struct_VkImageMemoryBarrier2) *[]ImageMemoryBarrier2 { /* Slice */ slc := unsafe.Slice((*ImageMemoryBarrier2)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pImageMemoryBarriers) 
	return *ptr
}

// WithPImageMemoryBarriers sets the value for the PImageMemoryBarriers on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines ImageMemoryBarrierCount as the length of this field.
// ImageMemoryBarrierCount is updated with the length of the new value.
func (x DependencyInfo) WithPImageMemoryBarriers(y []ImageMemoryBarrier2) DependencyInfo {
	x.pImageMemoryBarriers = *(func(x *[]ImageMemoryBarrier2) **C.struct_VkImageMemoryBarrier2 { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkImageMemoryBarrier2)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkImageMemoryBarrier2)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithImageMemoryBarrierCount(uint32(len(y)))
}

// SubmitInfo2 provides a go interface for VkSubmitInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSubmitInfo2.html
type SubmitInfo2 C.struct_VkSubmitInfo2

// SizeofSubmitInfo2 is the memory size of a SubmitInfo2
var SizeofSubmitInfo2 int = int(unsafe.Sizeof(SubmitInfo2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SubmitInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SubmitInfo2) AsCPtr() *SubmitInfo2 {
	clone := (*SubmitInfo2)(newCBlock(C.ulong(SizeofSubmitInfo2)))
	*clone = x
	return clone
}

// SubmitInfo2FreeCSlice releases the memory allocated by SubmitInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func SubmitInfo2FreeCSlice(x []SubmitInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SubmitInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SubmitInfo2FreeCSlice must be called on the returned slice.
func SubmitInfo2MakeCSlice(x ...SubmitInfo2) []SubmitInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSubmitInfo2 * len(x)
	dst := unsafe.Slice((*SubmitInfo2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSubmitInfo2
func (x SubmitInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SubmitInfo2) WithDefaultSType() SubmitInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_SUBMIT_INFO_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubmitInfo2) WithSType(y StructureType) SubmitInfo2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkSubmitInfo2
func (x SubmitInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubmitInfo2) WithPNext(y unsafe.Pointer) SubmitInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkSubmitInfo2
func (x SubmitInfo2) Flags() SubmitFlags {
	ptr := /* typedef */ (*SubmitFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubmitInfo2) WithFlags(y SubmitFlags) SubmitInfo2 {
	x.flags = *(/* typedef */ (*C.VkSubmitFlags)(&y))
	return x
}

// WaitSemaphoreInfoCount returns the value of waitSemaphoreInfoCount from VkSubmitInfo2
func (x SubmitInfo2) WaitSemaphoreInfoCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.waitSemaphoreInfoCount) 
	return *ptr
}

// WithWaitSemaphoreInfoCount sets the value for the WaitSemaphoreInfoCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubmitInfo2) WithWaitSemaphoreInfoCount(y uint32) SubmitInfo2 {
	x.waitSemaphoreInfoCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PWaitSemaphoreInfos returns the value of pWaitSemaphoreInfos from VkSubmitInfo2
func (x SubmitInfo2) PWaitSemaphoreInfos() []SemaphoreSubmitInfo {
	ptr := func(x **C.struct_VkSemaphoreSubmitInfo) *[]SemaphoreSubmitInfo { /* Slice */ slc := unsafe.Slice((*SemaphoreSubmitInfo)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pWaitSemaphoreInfos) 
	return *ptr
}

// WithPWaitSemaphoreInfos sets the value for the PWaitSemaphoreInfos on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines WaitSemaphoreInfoCount as the length of this field.
// WaitSemaphoreInfoCount is updated with the length of the new value.
func (x SubmitInfo2) WithPWaitSemaphoreInfos(y []SemaphoreSubmitInfo) SubmitInfo2 {
	x.pWaitSemaphoreInfos = *(func(x *[]SemaphoreSubmitInfo) **C.struct_VkSemaphoreSubmitInfo { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkSemaphoreSubmitInfo)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkSemaphoreSubmitInfo)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithWaitSemaphoreInfoCount(uint32(len(y)))
}

// CommandBufferInfoCount returns the value of commandBufferInfoCount from VkSubmitInfo2
func (x SubmitInfo2) CommandBufferInfoCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.commandBufferInfoCount) 
	return *ptr
}

// WithCommandBufferInfoCount sets the value for the CommandBufferInfoCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubmitInfo2) WithCommandBufferInfoCount(y uint32) SubmitInfo2 {
	x.commandBufferInfoCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PCommandBufferInfos returns the value of pCommandBufferInfos from VkSubmitInfo2
func (x SubmitInfo2) PCommandBufferInfos() []CommandBufferSubmitInfo {
	ptr := func(x **C.struct_VkCommandBufferSubmitInfo) *[]CommandBufferSubmitInfo { /* Slice */ slc := unsafe.Slice((*CommandBufferSubmitInfo)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pCommandBufferInfos) 
	return *ptr
}

// WithPCommandBufferInfos sets the value for the PCommandBufferInfos on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines CommandBufferInfoCount as the length of this field.
// CommandBufferInfoCount is updated with the length of the new value.
func (x SubmitInfo2) WithPCommandBufferInfos(y []CommandBufferSubmitInfo) SubmitInfo2 {
	x.pCommandBufferInfos = *(func(x *[]CommandBufferSubmitInfo) **C.struct_VkCommandBufferSubmitInfo { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkCommandBufferSubmitInfo)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkCommandBufferSubmitInfo)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithCommandBufferInfoCount(uint32(len(y)))
}

// SignalSemaphoreInfoCount returns the value of signalSemaphoreInfoCount from VkSubmitInfo2
func (x SubmitInfo2) SignalSemaphoreInfoCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.signalSemaphoreInfoCount) 
	return *ptr
}

// WithSignalSemaphoreInfoCount sets the value for the SignalSemaphoreInfoCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SubmitInfo2) WithSignalSemaphoreInfoCount(y uint32) SubmitInfo2 {
	x.signalSemaphoreInfoCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PSignalSemaphoreInfos returns the value of pSignalSemaphoreInfos from VkSubmitInfo2
func (x SubmitInfo2) PSignalSemaphoreInfos() []SemaphoreSubmitInfo {
	ptr := func(x **C.struct_VkSemaphoreSubmitInfo) *[]SemaphoreSubmitInfo { /* Slice */ slc := unsafe.Slice((*SemaphoreSubmitInfo)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pSignalSemaphoreInfos) 
	return *ptr
}

// WithPSignalSemaphoreInfos sets the value for the PSignalSemaphoreInfos on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines SignalSemaphoreInfoCount as the length of this field.
// SignalSemaphoreInfoCount is updated with the length of the new value.
func (x SubmitInfo2) WithPSignalSemaphoreInfos(y []SemaphoreSubmitInfo) SubmitInfo2 {
	x.pSignalSemaphoreInfos = *(func(x *[]SemaphoreSubmitInfo) **C.struct_VkSemaphoreSubmitInfo { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkSemaphoreSubmitInfo)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkSemaphoreSubmitInfo)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithSignalSemaphoreInfoCount(uint32(len(y)))
}

// SemaphoreSubmitInfo provides a go interface for VkSemaphoreSubmitInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSemaphoreSubmitInfo.html
type SemaphoreSubmitInfo C.struct_VkSemaphoreSubmitInfo

// SizeofSemaphoreSubmitInfo is the memory size of a SemaphoreSubmitInfo
var SizeofSemaphoreSubmitInfo int = int(unsafe.Sizeof(SemaphoreSubmitInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SemaphoreSubmitInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SemaphoreSubmitInfo) AsCPtr() *SemaphoreSubmitInfo {
	clone := (*SemaphoreSubmitInfo)(newCBlock(C.ulong(SizeofSemaphoreSubmitInfo)))
	*clone = x
	return clone
}

// SemaphoreSubmitInfoFreeCSlice releases the memory allocated by SemaphoreSubmitInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func SemaphoreSubmitInfoFreeCSlice(x []SemaphoreSubmitInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SemaphoreSubmitInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SemaphoreSubmitInfoFreeCSlice must be called on the returned slice.
func SemaphoreSubmitInfoMakeCSlice(x ...SemaphoreSubmitInfo) []SemaphoreSubmitInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSemaphoreSubmitInfo * len(x)
	dst := unsafe.Slice((*SemaphoreSubmitInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSemaphoreSubmitInfo
func (x SemaphoreSubmitInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SemaphoreSubmitInfo) WithDefaultSType() SemaphoreSubmitInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreSubmitInfo) WithSType(y StructureType) SemaphoreSubmitInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkSemaphoreSubmitInfo
func (x SemaphoreSubmitInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreSubmitInfo) WithPNext(y unsafe.Pointer) SemaphoreSubmitInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Semaphore returns the value of semaphore from VkSemaphoreSubmitInfo
func (x SemaphoreSubmitInfo) Semaphore() Semaphore {
	ptr := /* handle */ (*Semaphore)(&x.semaphore) 
	return *ptr
}

// WithSemaphore sets the value for the Semaphore on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreSubmitInfo) WithSemaphore(y Semaphore) SemaphoreSubmitInfo {
	x.semaphore = *(/* handle */ (*C.VkSemaphore)(&y))
	return x
}

// Value returns the value of value from VkSemaphoreSubmitInfo
func (x SemaphoreSubmitInfo) Value() uint64 {
	ptr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.value) 
	return *ptr
}

// WithValue sets the value for the Value on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreSubmitInfo) WithValue(y uint64) SemaphoreSubmitInfo {
	x.value = *(func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&y))
	return x
}

// StageMask returns the value of stageMask from VkSemaphoreSubmitInfo
func (x SemaphoreSubmitInfo) StageMask() PipelineStageFlags2 {
	ptr := /* typedef */ (*PipelineStageFlags2)(&x.stageMask) 
	return *ptr
}

// WithStageMask sets the value for the StageMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreSubmitInfo) WithStageMask(y PipelineStageFlags2) SemaphoreSubmitInfo {
	x.stageMask = *(/* typedef */ (*C.VkPipelineStageFlags2)(&y))
	return x
}

// DeviceIndex returns the value of deviceIndex from VkSemaphoreSubmitInfo
func (x SemaphoreSubmitInfo) DeviceIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.deviceIndex) 
	return *ptr
}

// WithDeviceIndex sets the value for the DeviceIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SemaphoreSubmitInfo) WithDeviceIndex(y uint32) SemaphoreSubmitInfo {
	x.deviceIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// CommandBufferSubmitInfo provides a go interface for VkCommandBufferSubmitInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferSubmitInfo.html
type CommandBufferSubmitInfo C.struct_VkCommandBufferSubmitInfo

// SizeofCommandBufferSubmitInfo is the memory size of a CommandBufferSubmitInfo
var SizeofCommandBufferSubmitInfo int = int(unsafe.Sizeof(CommandBufferSubmitInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *CommandBufferSubmitInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x CommandBufferSubmitInfo) AsCPtr() *CommandBufferSubmitInfo {
	clone := (*CommandBufferSubmitInfo)(newCBlock(C.ulong(SizeofCommandBufferSubmitInfo)))
	*clone = x
	return clone
}

// CommandBufferSubmitInfoFreeCSlice releases the memory allocated by CommandBufferSubmitInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func CommandBufferSubmitInfoFreeCSlice(x []CommandBufferSubmitInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// CommandBufferSubmitInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. CommandBufferSubmitInfoFreeCSlice must be called on the returned slice.
func CommandBufferSubmitInfoMakeCSlice(x ...CommandBufferSubmitInfo) []CommandBufferSubmitInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCommandBufferSubmitInfo * len(x)
	dst := unsafe.Slice((*CommandBufferSubmitInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkCommandBufferSubmitInfo
func (x CommandBufferSubmitInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x CommandBufferSubmitInfo) WithDefaultSType() CommandBufferSubmitInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferSubmitInfo) WithSType(y StructureType) CommandBufferSubmitInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkCommandBufferSubmitInfo
func (x CommandBufferSubmitInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferSubmitInfo) WithPNext(y unsafe.Pointer) CommandBufferSubmitInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// CommandBuffer returns the value of commandBuffer from VkCommandBufferSubmitInfo
func (x CommandBufferSubmitInfo) CommandBuffer() CommandBuffer {
	ptr := /* handle */ (*CommandBuffer)(&x.commandBuffer) 
	return *ptr
}

// WithCommandBuffer sets the value for the CommandBuffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferSubmitInfo) WithCommandBuffer(y CommandBuffer) CommandBufferSubmitInfo {
	x.commandBuffer = *(/* handle */ (*C.VkCommandBuffer)(&y))
	return x
}

// DeviceMask returns the value of deviceMask from VkCommandBufferSubmitInfo
func (x CommandBufferSubmitInfo) DeviceMask() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.deviceMask) 
	return *ptr
}

// WithDeviceMask sets the value for the DeviceMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferSubmitInfo) WithDeviceMask(y uint32) CommandBufferSubmitInfo {
	x.deviceMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PhysicalDeviceVulkan13Features provides a go interface for VkPhysicalDeviceVulkan13Features.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Features.html
type PhysicalDeviceVulkan13Features C.struct_VkPhysicalDeviceVulkan13Features

// SizeofPhysicalDeviceVulkan13Features is the memory size of a PhysicalDeviceVulkan13Features
var SizeofPhysicalDeviceVulkan13Features int = int(unsafe.Sizeof(PhysicalDeviceVulkan13Features{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceVulkan13Features) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceVulkan13Features) AsCPtr() *PhysicalDeviceVulkan13Features {
	clone := (*PhysicalDeviceVulkan13Features)(newCBlock(C.ulong(SizeofPhysicalDeviceVulkan13Features)))
	*clone = x
	return clone
}

// PhysicalDeviceVulkan13FeaturesFreeCSlice releases the memory allocated by PhysicalDeviceVulkan13FeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceVulkan13FeaturesFreeCSlice(x []PhysicalDeviceVulkan13Features) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceVulkan13FeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceVulkan13FeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceVulkan13FeaturesMakeCSlice(x ...PhysicalDeviceVulkan13Features) []PhysicalDeviceVulkan13Features {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceVulkan13Features * len(x)
	dst := unsafe.Slice((*PhysicalDeviceVulkan13Features)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceVulkan13Features) WithDefaultSType() PhysicalDeviceVulkan13Features {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithSType(y StructureType) PhysicalDeviceVulkan13Features {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithPNext(y unsafe.Pointer) PhysicalDeviceVulkan13Features {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// RobustImageAccess returns the value of robustImageAccess from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) RobustImageAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.robustImageAccess) 
	return *ptr
}

// WithRobustImageAccess sets the value for the RobustImageAccess on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithRobustImageAccess(y Bool32) PhysicalDeviceVulkan13Features {
	x.robustImageAccess = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// InlineUniformBlock returns the value of inlineUniformBlock from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) InlineUniformBlock() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.inlineUniformBlock) 
	return *ptr
}

// WithInlineUniformBlock sets the value for the InlineUniformBlock on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithInlineUniformBlock(y Bool32) PhysicalDeviceVulkan13Features {
	x.inlineUniformBlock = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DescriptorBindingInlineUniformBlockUpdateAfterBind returns the value of descriptorBindingInlineUniformBlockUpdateAfterBind from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) DescriptorBindingInlineUniformBlockUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingInlineUniformBlockUpdateAfterBind) 
	return *ptr
}

// WithDescriptorBindingInlineUniformBlockUpdateAfterBind sets the value for the DescriptorBindingInlineUniformBlockUpdateAfterBind on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithDescriptorBindingInlineUniformBlockUpdateAfterBind(y Bool32) PhysicalDeviceVulkan13Features {
	x.descriptorBindingInlineUniformBlockUpdateAfterBind = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// PipelineCreationCacheControl returns the value of pipelineCreationCacheControl from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) PipelineCreationCacheControl() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.pipelineCreationCacheControl) 
	return *ptr
}

// WithPipelineCreationCacheControl sets the value for the PipelineCreationCacheControl on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithPipelineCreationCacheControl(y Bool32) PhysicalDeviceVulkan13Features {
	x.pipelineCreationCacheControl = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// PrivateData returns the value of privateData from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) PrivateData() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.privateData) 
	return *ptr
}

// WithPrivateData sets the value for the PrivateData on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithPrivateData(y Bool32) PhysicalDeviceVulkan13Features {
	x.privateData = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderDemoteToHelperInvocation returns the value of shaderDemoteToHelperInvocation from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) ShaderDemoteToHelperInvocation() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDemoteToHelperInvocation) 
	return *ptr
}

// WithShaderDemoteToHelperInvocation sets the value for the ShaderDemoteToHelperInvocation on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithShaderDemoteToHelperInvocation(y Bool32) PhysicalDeviceVulkan13Features {
	x.shaderDemoteToHelperInvocation = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderTerminateInvocation returns the value of shaderTerminateInvocation from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) ShaderTerminateInvocation() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderTerminateInvocation) 
	return *ptr
}

// WithShaderTerminateInvocation sets the value for the ShaderTerminateInvocation on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithShaderTerminateInvocation(y Bool32) PhysicalDeviceVulkan13Features {
	x.shaderTerminateInvocation = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// SubgroupSizeControl returns the value of subgroupSizeControl from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) SubgroupSizeControl() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.subgroupSizeControl) 
	return *ptr
}

// WithSubgroupSizeControl sets the value for the SubgroupSizeControl on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithSubgroupSizeControl(y Bool32) PhysicalDeviceVulkan13Features {
	x.subgroupSizeControl = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ComputeFullSubgroups returns the value of computeFullSubgroups from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) ComputeFullSubgroups() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.computeFullSubgroups) 
	return *ptr
}

// WithComputeFullSubgroups sets the value for the ComputeFullSubgroups on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithComputeFullSubgroups(y Bool32) PhysicalDeviceVulkan13Features {
	x.computeFullSubgroups = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// Synchronization2 returns the value of synchronization2 from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) Synchronization2() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.synchronization2) 
	return *ptr
}

// WithSynchronization2 sets the value for the Synchronization2 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithSynchronization2(y Bool32) PhysicalDeviceVulkan13Features {
	x.synchronization2 = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// TextureCompressionASTC_HDR returns the value of textureCompressionASTC_HDR from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) TextureCompressionASTC_HDR() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.textureCompressionASTC_HDR) 
	return *ptr
}

// WithTextureCompressionASTC_HDR sets the value for the TextureCompressionASTC_HDR on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithTextureCompressionASTC_HDR(y Bool32) PhysicalDeviceVulkan13Features {
	x.textureCompressionASTC_HDR = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderZeroInitializeWorkgroupMemory returns the value of shaderZeroInitializeWorkgroupMemory from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) ShaderZeroInitializeWorkgroupMemory() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderZeroInitializeWorkgroupMemory) 
	return *ptr
}

// WithShaderZeroInitializeWorkgroupMemory sets the value for the ShaderZeroInitializeWorkgroupMemory on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithShaderZeroInitializeWorkgroupMemory(y Bool32) PhysicalDeviceVulkan13Features {
	x.shaderZeroInitializeWorkgroupMemory = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DynamicRendering returns the value of dynamicRendering from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) DynamicRendering() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.dynamicRendering) 
	return *ptr
}

// WithDynamicRendering sets the value for the DynamicRendering on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithDynamicRendering(y Bool32) PhysicalDeviceVulkan13Features {
	x.dynamicRendering = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderIntegerDotProduct returns the value of shaderIntegerDotProduct from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) ShaderIntegerDotProduct() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderIntegerDotProduct) 
	return *ptr
}

// WithShaderIntegerDotProduct sets the value for the ShaderIntegerDotProduct on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithShaderIntegerDotProduct(y Bool32) PhysicalDeviceVulkan13Features {
	x.shaderIntegerDotProduct = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// Maintenance4 returns the value of maintenance4 from VkPhysicalDeviceVulkan13Features
func (x PhysicalDeviceVulkan13Features) Maintenance4() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.maintenance4) 
	return *ptr
}

// WithMaintenance4 sets the value for the Maintenance4 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceVulkan13Features) WithMaintenance4(y Bool32) PhysicalDeviceVulkan13Features {
	x.maintenance4 = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// MemoryBarrier2 provides a go interface for VkMemoryBarrier2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkMemoryBarrier2.html
type MemoryBarrier2 C.struct_VkMemoryBarrier2

// SizeofMemoryBarrier2 is the memory size of a MemoryBarrier2
var SizeofMemoryBarrier2 int = int(unsafe.Sizeof(MemoryBarrier2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *MemoryBarrier2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x MemoryBarrier2) AsCPtr() *MemoryBarrier2 {
	clone := (*MemoryBarrier2)(newCBlock(C.ulong(SizeofMemoryBarrier2)))
	*clone = x
	return clone
}

// MemoryBarrier2FreeCSlice releases the memory allocated by MemoryBarrier2MakeCSlice.
// It does not free pointers stored inside the slice.
func MemoryBarrier2FreeCSlice(x []MemoryBarrier2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// MemoryBarrier2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. MemoryBarrier2FreeCSlice must be called on the returned slice.
func MemoryBarrier2MakeCSlice(x ...MemoryBarrier2) []MemoryBarrier2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofMemoryBarrier2 * len(x)
	dst := unsafe.Slice((*MemoryBarrier2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkMemoryBarrier2
func (x MemoryBarrier2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x MemoryBarrier2) WithDefaultSType() MemoryBarrier2 {
	return x.WithSType(VK_STRUCTURE_TYPE_MEMORY_BARRIER_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryBarrier2) WithSType(y StructureType) MemoryBarrier2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkMemoryBarrier2
func (x MemoryBarrier2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryBarrier2) WithPNext(y unsafe.Pointer) MemoryBarrier2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SrcStageMask returns the value of srcStageMask from VkMemoryBarrier2
func (x MemoryBarrier2) SrcStageMask() PipelineStageFlags2 {
	ptr := /* typedef */ (*PipelineStageFlags2)(&x.srcStageMask) 
	return *ptr
}

// WithSrcStageMask sets the value for the SrcStageMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryBarrier2) WithSrcStageMask(y PipelineStageFlags2) MemoryBarrier2 {
	x.srcStageMask = *(/* typedef */ (*C.VkPipelineStageFlags2)(&y))
	return x
}

// SrcAccessMask returns the value of srcAccessMask from VkMemoryBarrier2
func (x MemoryBarrier2) SrcAccessMask() AccessFlags2 {
	ptr := /* typedef */ (*AccessFlags2)(&x.srcAccessMask) 
	return *ptr
}

// WithSrcAccessMask sets the value for the SrcAccessMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryBarrier2) WithSrcAccessMask(y AccessFlags2) MemoryBarrier2 {
	x.srcAccessMask = *(/* typedef */ (*C.VkAccessFlags2)(&y))
	return x
}

// DstStageMask returns the value of dstStageMask from VkMemoryBarrier2
func (x MemoryBarrier2) DstStageMask() PipelineStageFlags2 {
	ptr := /* typedef */ (*PipelineStageFlags2)(&x.dstStageMask) 
	return *ptr
}

// WithDstStageMask sets the value for the DstStageMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryBarrier2) WithDstStageMask(y PipelineStageFlags2) MemoryBarrier2 {
	x.dstStageMask = *(/* typedef */ (*C.VkPipelineStageFlags2)(&y))
	return x
}

// DstAccessMask returns the value of dstAccessMask from VkMemoryBarrier2
func (x MemoryBarrier2) DstAccessMask() AccessFlags2 {
	ptr := /* typedef */ (*AccessFlags2)(&x.dstAccessMask) 
	return *ptr
}

// WithDstAccessMask sets the value for the DstAccessMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x MemoryBarrier2) WithDstAccessMask(y AccessFlags2) MemoryBarrier2 {
	x.dstAccessMask = *(/* typedef */ (*C.VkAccessFlags2)(&y))
	return x
}

// PhysicalDeviceSynchronization2Features provides a go interface for VkPhysicalDeviceSynchronization2Features.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSynchronization2Features.html
type PhysicalDeviceSynchronization2Features C.struct_VkPhysicalDeviceSynchronization2Features

// SizeofPhysicalDeviceSynchronization2Features is the memory size of a PhysicalDeviceSynchronization2Features
var SizeofPhysicalDeviceSynchronization2Features int = int(unsafe.Sizeof(PhysicalDeviceSynchronization2Features{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceSynchronization2Features) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceSynchronization2Features) AsCPtr() *PhysicalDeviceSynchronization2Features {
	clone := (*PhysicalDeviceSynchronization2Features)(newCBlock(C.ulong(SizeofPhysicalDeviceSynchronization2Features)))
	*clone = x
	return clone
}

// PhysicalDeviceSynchronization2FeaturesFreeCSlice releases the memory allocated by PhysicalDeviceSynchronization2FeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceSynchronization2FeaturesFreeCSlice(x []PhysicalDeviceSynchronization2Features) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceSynchronization2FeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceSynchronization2FeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceSynchronization2FeaturesMakeCSlice(x ...PhysicalDeviceSynchronization2Features) []PhysicalDeviceSynchronization2Features {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSynchronization2Features * len(x)
	dst := unsafe.Slice((*PhysicalDeviceSynchronization2Features)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceSynchronization2Features
func (x PhysicalDeviceSynchronization2Features) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceSynchronization2Features) WithDefaultSType() PhysicalDeviceSynchronization2Features {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSynchronization2Features) WithSType(y StructureType) PhysicalDeviceSynchronization2Features {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceSynchronization2Features
func (x PhysicalDeviceSynchronization2Features) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSynchronization2Features) WithPNext(y unsafe.Pointer) PhysicalDeviceSynchronization2Features {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Synchronization2 returns the value of synchronization2 from VkPhysicalDeviceSynchronization2Features
func (x PhysicalDeviceSynchronization2Features) Synchronization2() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.synchronization2) 
	return *ptr
}

// WithSynchronization2 sets the value for the Synchronization2 on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSynchronization2Features) WithSynchronization2(y Bool32) PhysicalDeviceSynchronization2Features {
	x.synchronization2 = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures provides a go interface for VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures.html
type PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures C.struct_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures

// SizeofPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures is the memory size of a PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures
var SizeofPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures int = int(unsafe.Sizeof(PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) AsCPtr() *PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
	clone := (*PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesFreeCSlice(x []PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesMakeCSlice(x ...PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) []PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures
func (x PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) WithDefaultSType() PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) WithSType(y StructureType) PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures
func (x PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// ShaderZeroInitializeWorkgroupMemory returns the value of shaderZeroInitializeWorkgroupMemory from VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures
func (x PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) ShaderZeroInitializeWorkgroupMemory() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderZeroInitializeWorkgroupMemory) 
	return *ptr
}

// WithShaderZeroInitializeWorkgroupMemory sets the value for the ShaderZeroInitializeWorkgroupMemory on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) WithShaderZeroInitializeWorkgroupMemory(y Bool32) PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
	x.shaderZeroInitializeWorkgroupMemory = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// PhysicalDeviceImageRobustnessFeatures provides a go interface for VkPhysicalDeviceImageRobustnessFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageRobustnessFeatures.html
type PhysicalDeviceImageRobustnessFeatures C.struct_VkPhysicalDeviceImageRobustnessFeatures

// SizeofPhysicalDeviceImageRobustnessFeatures is the memory size of a PhysicalDeviceImageRobustnessFeatures
var SizeofPhysicalDeviceImageRobustnessFeatures int = int(unsafe.Sizeof(PhysicalDeviceImageRobustnessFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceImageRobustnessFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceImageRobustnessFeatures) AsCPtr() *PhysicalDeviceImageRobustnessFeatures {
	clone := (*PhysicalDeviceImageRobustnessFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceImageRobustnessFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceImageRobustnessFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceImageRobustnessFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceImageRobustnessFeaturesFreeCSlice(x []PhysicalDeviceImageRobustnessFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceImageRobustnessFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceImageRobustnessFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceImageRobustnessFeaturesMakeCSlice(x ...PhysicalDeviceImageRobustnessFeatures) []PhysicalDeviceImageRobustnessFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceImageRobustnessFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceImageRobustnessFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceImageRobustnessFeatures
func (x PhysicalDeviceImageRobustnessFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceImageRobustnessFeatures) WithDefaultSType() PhysicalDeviceImageRobustnessFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImageRobustnessFeatures) WithSType(y StructureType) PhysicalDeviceImageRobustnessFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceImageRobustnessFeatures
func (x PhysicalDeviceImageRobustnessFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImageRobustnessFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceImageRobustnessFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// RobustImageAccess returns the value of robustImageAccess from VkPhysicalDeviceImageRobustnessFeatures
func (x PhysicalDeviceImageRobustnessFeatures) RobustImageAccess() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.robustImageAccess) 
	return *ptr
}

// WithRobustImageAccess sets the value for the RobustImageAccess on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceImageRobustnessFeatures) WithRobustImageAccess(y Bool32) PhysicalDeviceImageRobustnessFeatures {
	x.robustImageAccess = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// CommandBufferInheritanceRenderingInfo provides a go interface for VkCommandBufferInheritanceRenderingInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCommandBufferInheritanceRenderingInfo.html
type CommandBufferInheritanceRenderingInfo C.struct_VkCommandBufferInheritanceRenderingInfo

// SizeofCommandBufferInheritanceRenderingInfo is the memory size of a CommandBufferInheritanceRenderingInfo
var SizeofCommandBufferInheritanceRenderingInfo int = int(unsafe.Sizeof(CommandBufferInheritanceRenderingInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *CommandBufferInheritanceRenderingInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x CommandBufferInheritanceRenderingInfo) AsCPtr() *CommandBufferInheritanceRenderingInfo {
	clone := (*CommandBufferInheritanceRenderingInfo)(newCBlock(C.ulong(SizeofCommandBufferInheritanceRenderingInfo)))
	*clone = x
	return clone
}

// CommandBufferInheritanceRenderingInfoFreeCSlice releases the memory allocated by CommandBufferInheritanceRenderingInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func CommandBufferInheritanceRenderingInfoFreeCSlice(x []CommandBufferInheritanceRenderingInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// CommandBufferInheritanceRenderingInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. CommandBufferInheritanceRenderingInfoFreeCSlice must be called on the returned slice.
func CommandBufferInheritanceRenderingInfoMakeCSlice(x ...CommandBufferInheritanceRenderingInfo) []CommandBufferInheritanceRenderingInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCommandBufferInheritanceRenderingInfo * len(x)
	dst := unsafe.Slice((*CommandBufferInheritanceRenderingInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkCommandBufferInheritanceRenderingInfo
func (x CommandBufferInheritanceRenderingInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x CommandBufferInheritanceRenderingInfo) WithDefaultSType() CommandBufferInheritanceRenderingInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceRenderingInfo) WithSType(y StructureType) CommandBufferInheritanceRenderingInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkCommandBufferInheritanceRenderingInfo
func (x CommandBufferInheritanceRenderingInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceRenderingInfo) WithPNext(y unsafe.Pointer) CommandBufferInheritanceRenderingInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkCommandBufferInheritanceRenderingInfo
func (x CommandBufferInheritanceRenderingInfo) Flags() RenderingFlags {
	ptr := /* typedef */ (*RenderingFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceRenderingInfo) WithFlags(y RenderingFlags) CommandBufferInheritanceRenderingInfo {
	x.flags = *(/* typedef */ (*C.VkRenderingFlags)(&y))
	return x
}

// ViewMask returns the value of viewMask from VkCommandBufferInheritanceRenderingInfo
func (x CommandBufferInheritanceRenderingInfo) ViewMask() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.viewMask) 
	return *ptr
}

// WithViewMask sets the value for the ViewMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceRenderingInfo) WithViewMask(y uint32) CommandBufferInheritanceRenderingInfo {
	x.viewMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// ColorAttachmentCount returns the value of colorAttachmentCount from VkCommandBufferInheritanceRenderingInfo
func (x CommandBufferInheritanceRenderingInfo) ColorAttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.colorAttachmentCount) 
	return *ptr
}

// WithColorAttachmentCount sets the value for the ColorAttachmentCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceRenderingInfo) WithColorAttachmentCount(y uint32) CommandBufferInheritanceRenderingInfo {
	x.colorAttachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PColorAttachmentFormats returns the value of pColorAttachmentFormats from VkCommandBufferInheritanceRenderingInfo
func (x CommandBufferInheritanceRenderingInfo) PColorAttachmentFormats() []Format {
	ptr := func(x **C.VkFormat) *[]Format { /* Slice */ slc := unsafe.Slice((*Format)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pColorAttachmentFormats) 
	return *ptr
}

// WithPColorAttachmentFormats sets the value for the PColorAttachmentFormats on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines ColorAttachmentCount as the length of this field.
// ColorAttachmentCount is updated with the length of the new value.
func (x CommandBufferInheritanceRenderingInfo) WithPColorAttachmentFormats(y []Format) CommandBufferInheritanceRenderingInfo {
	x.pColorAttachmentFormats = *(func(x *[]Format) **C.VkFormat { /* Slice */ if len(*x) > 0 { slc := (*C.VkFormat)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkFormat)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithColorAttachmentCount(uint32(len(y)))
}

// DepthAttachmentFormat returns the value of depthAttachmentFormat from VkCommandBufferInheritanceRenderingInfo
func (x CommandBufferInheritanceRenderingInfo) DepthAttachmentFormat() Format {
	ptr := /* typedef */ (*Format)(&x.depthAttachmentFormat) 
	return *ptr
}

// WithDepthAttachmentFormat sets the value for the DepthAttachmentFormat on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceRenderingInfo) WithDepthAttachmentFormat(y Format) CommandBufferInheritanceRenderingInfo {
	x.depthAttachmentFormat = *(/* typedef */ (*C.VkFormat)(&y))
	return x
}

// StencilAttachmentFormat returns the value of stencilAttachmentFormat from VkCommandBufferInheritanceRenderingInfo
func (x CommandBufferInheritanceRenderingInfo) StencilAttachmentFormat() Format {
	ptr := /* typedef */ (*Format)(&x.stencilAttachmentFormat) 
	return *ptr
}

// WithStencilAttachmentFormat sets the value for the StencilAttachmentFormat on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceRenderingInfo) WithStencilAttachmentFormat(y Format) CommandBufferInheritanceRenderingInfo {
	x.stencilAttachmentFormat = *(/* typedef */ (*C.VkFormat)(&y))
	return x
}

// RasterizationSamples returns the value of rasterizationSamples from VkCommandBufferInheritanceRenderingInfo
func (x CommandBufferInheritanceRenderingInfo) RasterizationSamples() SampleCountFlagBits {
	ptr := /* typedef */ (*SampleCountFlagBits)(&x.rasterizationSamples) 
	return *ptr
}

// WithRasterizationSamples sets the value for the RasterizationSamples on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CommandBufferInheritanceRenderingInfo) WithRasterizationSamples(y SampleCountFlagBits) CommandBufferInheritanceRenderingInfo {
	x.rasterizationSamples = *(/* typedef */ (*C.VkSampleCountFlagBits)(&y))
	return x
}

// PhysicalDeviceDynamicRenderingFeatures provides a go interface for VkPhysicalDeviceDynamicRenderingFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDynamicRenderingFeatures.html
type PhysicalDeviceDynamicRenderingFeatures C.struct_VkPhysicalDeviceDynamicRenderingFeatures

// SizeofPhysicalDeviceDynamicRenderingFeatures is the memory size of a PhysicalDeviceDynamicRenderingFeatures
var SizeofPhysicalDeviceDynamicRenderingFeatures int = int(unsafe.Sizeof(PhysicalDeviceDynamicRenderingFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceDynamicRenderingFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceDynamicRenderingFeatures) AsCPtr() *PhysicalDeviceDynamicRenderingFeatures {
	clone := (*PhysicalDeviceDynamicRenderingFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceDynamicRenderingFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceDynamicRenderingFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceDynamicRenderingFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceDynamicRenderingFeaturesFreeCSlice(x []PhysicalDeviceDynamicRenderingFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceDynamicRenderingFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceDynamicRenderingFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceDynamicRenderingFeaturesMakeCSlice(x ...PhysicalDeviceDynamicRenderingFeatures) []PhysicalDeviceDynamicRenderingFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceDynamicRenderingFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceDynamicRenderingFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceDynamicRenderingFeatures
func (x PhysicalDeviceDynamicRenderingFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceDynamicRenderingFeatures) WithDefaultSType() PhysicalDeviceDynamicRenderingFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDynamicRenderingFeatures) WithSType(y StructureType) PhysicalDeviceDynamicRenderingFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceDynamicRenderingFeatures
func (x PhysicalDeviceDynamicRenderingFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDynamicRenderingFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceDynamicRenderingFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// DynamicRendering returns the value of dynamicRendering from VkPhysicalDeviceDynamicRenderingFeatures
func (x PhysicalDeviceDynamicRenderingFeatures) DynamicRendering() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.dynamicRendering) 
	return *ptr
}

// WithDynamicRendering sets the value for the DynamicRendering on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceDynamicRenderingFeatures) WithDynamicRendering(y Bool32) PhysicalDeviceDynamicRenderingFeatures {
	x.dynamicRendering = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// PipelineRenderingCreateInfo provides a go interface for VkPipelineRenderingCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineRenderingCreateInfo.html
type PipelineRenderingCreateInfo C.struct_VkPipelineRenderingCreateInfo

// SizeofPipelineRenderingCreateInfo is the memory size of a PipelineRenderingCreateInfo
var SizeofPipelineRenderingCreateInfo int = int(unsafe.Sizeof(PipelineRenderingCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineRenderingCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineRenderingCreateInfo) AsCPtr() *PipelineRenderingCreateInfo {
	clone := (*PipelineRenderingCreateInfo)(newCBlock(C.ulong(SizeofPipelineRenderingCreateInfo)))
	*clone = x
	return clone
}

// PipelineRenderingCreateInfoFreeCSlice releases the memory allocated by PipelineRenderingCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineRenderingCreateInfoFreeCSlice(x []PipelineRenderingCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineRenderingCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineRenderingCreateInfoFreeCSlice must be called on the returned slice.
func PipelineRenderingCreateInfoMakeCSlice(x ...PipelineRenderingCreateInfo) []PipelineRenderingCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineRenderingCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineRenderingCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineRenderingCreateInfo
func (x PipelineRenderingCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineRenderingCreateInfo) WithDefaultSType() PipelineRenderingCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRenderingCreateInfo) WithSType(y StructureType) PipelineRenderingCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPipelineRenderingCreateInfo
func (x PipelineRenderingCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRenderingCreateInfo) WithPNext(y unsafe.Pointer) PipelineRenderingCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// ViewMask returns the value of viewMask from VkPipelineRenderingCreateInfo
func (x PipelineRenderingCreateInfo) ViewMask() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.viewMask) 
	return *ptr
}

// WithViewMask sets the value for the ViewMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRenderingCreateInfo) WithViewMask(y uint32) PipelineRenderingCreateInfo {
	x.viewMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// ColorAttachmentCount returns the value of colorAttachmentCount from VkPipelineRenderingCreateInfo
func (x PipelineRenderingCreateInfo) ColorAttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.colorAttachmentCount) 
	return *ptr
}

// WithColorAttachmentCount sets the value for the ColorAttachmentCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRenderingCreateInfo) WithColorAttachmentCount(y uint32) PipelineRenderingCreateInfo {
	x.colorAttachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PColorAttachmentFormats returns the value of pColorAttachmentFormats from VkPipelineRenderingCreateInfo
func (x PipelineRenderingCreateInfo) PColorAttachmentFormats() []Format {
	ptr := func(x **C.VkFormat) *[]Format { /* Slice */ slc := unsafe.Slice((*Format)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pColorAttachmentFormats) 
	return *ptr
}

// WithPColorAttachmentFormats sets the value for the PColorAttachmentFormats on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines ColorAttachmentCount as the length of this field.
// ColorAttachmentCount is updated with the length of the new value.
func (x PipelineRenderingCreateInfo) WithPColorAttachmentFormats(y []Format) PipelineRenderingCreateInfo {
	x.pColorAttachmentFormats = *(func(x *[]Format) **C.VkFormat { /* Slice */ if len(*x) > 0 { slc := (*C.VkFormat)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkFormat)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithColorAttachmentCount(uint32(len(y)))
}

// DepthAttachmentFormat returns the value of depthAttachmentFormat from VkPipelineRenderingCreateInfo
func (x PipelineRenderingCreateInfo) DepthAttachmentFormat() Format {
	ptr := /* typedef */ (*Format)(&x.depthAttachmentFormat) 
	return *ptr
}

// WithDepthAttachmentFormat sets the value for the DepthAttachmentFormat on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRenderingCreateInfo) WithDepthAttachmentFormat(y Format) PipelineRenderingCreateInfo {
	x.depthAttachmentFormat = *(/* typedef */ (*C.VkFormat)(&y))
	return x
}

// StencilAttachmentFormat returns the value of stencilAttachmentFormat from VkPipelineRenderingCreateInfo
func (x PipelineRenderingCreateInfo) StencilAttachmentFormat() Format {
	ptr := /* typedef */ (*Format)(&x.stencilAttachmentFormat) 
	return *ptr
}

// WithStencilAttachmentFormat sets the value for the StencilAttachmentFormat on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineRenderingCreateInfo) WithStencilAttachmentFormat(y Format) PipelineRenderingCreateInfo {
	x.stencilAttachmentFormat = *(/* typedef */ (*C.VkFormat)(&y))
	return x
}

// RenderingAttachmentInfo provides a go interface for VkRenderingAttachmentInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingAttachmentInfo.html
type RenderingAttachmentInfo C.struct_VkRenderingAttachmentInfo

// SizeofRenderingAttachmentInfo is the memory size of a RenderingAttachmentInfo
var SizeofRenderingAttachmentInfo int = int(unsafe.Sizeof(RenderingAttachmentInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *RenderingAttachmentInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x RenderingAttachmentInfo) AsCPtr() *RenderingAttachmentInfo {
	clone := (*RenderingAttachmentInfo)(newCBlock(C.ulong(SizeofRenderingAttachmentInfo)))
	*clone = x
	return clone
}

// RenderingAttachmentInfoFreeCSlice releases the memory allocated by RenderingAttachmentInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func RenderingAttachmentInfoFreeCSlice(x []RenderingAttachmentInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// RenderingAttachmentInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. RenderingAttachmentInfoFreeCSlice must be called on the returned slice.
func RenderingAttachmentInfoMakeCSlice(x ...RenderingAttachmentInfo) []RenderingAttachmentInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderingAttachmentInfo * len(x)
	dst := unsafe.Slice((*RenderingAttachmentInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkRenderingAttachmentInfo
func (x RenderingAttachmentInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x RenderingAttachmentInfo) WithDefaultSType() RenderingAttachmentInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingAttachmentInfo) WithSType(y StructureType) RenderingAttachmentInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkRenderingAttachmentInfo
func (x RenderingAttachmentInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingAttachmentInfo) WithPNext(y unsafe.Pointer) RenderingAttachmentInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// ImageView returns the value of imageView from VkRenderingAttachmentInfo
func (x RenderingAttachmentInfo) ImageView() ImageView {
	ptr := /* handle */ (*ImageView)(&x.imageView) 
	return *ptr
}

// WithImageView sets the value for the ImageView on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingAttachmentInfo) WithImageView(y ImageView) RenderingAttachmentInfo {
	x.imageView = *(/* handle */ (*C.VkImageView)(&y))
	return x
}

// ImageLayout returns the value of imageLayout from VkRenderingAttachmentInfo
func (x RenderingAttachmentInfo) ImageLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.imageLayout) 
	return *ptr
}

// WithImageLayout sets the value for the ImageLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingAttachmentInfo) WithImageLayout(y ImageLayout) RenderingAttachmentInfo {
	x.imageLayout = *(/* typedef */ (*C.VkImageLayout)(&y))
	return x
}

// ResolveMode returns the value of resolveMode from VkRenderingAttachmentInfo
func (x RenderingAttachmentInfo) ResolveMode() ResolveModeFlagBits {
	ptr := /* typedef */ (*ResolveModeFlagBits)(&x.resolveMode) 
	return *ptr
}

// WithResolveMode sets the value for the ResolveMode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingAttachmentInfo) WithResolveMode(y ResolveModeFlagBits) RenderingAttachmentInfo {
	x.resolveMode = *(/* typedef */ (*C.VkResolveModeFlagBits)(&y))
	return x
}

// ResolveImageView returns the value of resolveImageView from VkRenderingAttachmentInfo
func (x RenderingAttachmentInfo) ResolveImageView() ImageView {
	ptr := /* handle */ (*ImageView)(&x.resolveImageView) 
	return *ptr
}

// WithResolveImageView sets the value for the ResolveImageView on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingAttachmentInfo) WithResolveImageView(y ImageView) RenderingAttachmentInfo {
	x.resolveImageView = *(/* handle */ (*C.VkImageView)(&y))
	return x
}

// ResolveImageLayout returns the value of resolveImageLayout from VkRenderingAttachmentInfo
func (x RenderingAttachmentInfo) ResolveImageLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.resolveImageLayout) 
	return *ptr
}

// WithResolveImageLayout sets the value for the ResolveImageLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingAttachmentInfo) WithResolveImageLayout(y ImageLayout) RenderingAttachmentInfo {
	x.resolveImageLayout = *(/* typedef */ (*C.VkImageLayout)(&y))
	return x
}

// LoadOp returns the value of loadOp from VkRenderingAttachmentInfo
func (x RenderingAttachmentInfo) LoadOp() AttachmentLoadOp {
	ptr := /* typedef */ (*AttachmentLoadOp)(&x.loadOp) 
	return *ptr
}

// WithLoadOp sets the value for the LoadOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingAttachmentInfo) WithLoadOp(y AttachmentLoadOp) RenderingAttachmentInfo {
	x.loadOp = *(/* typedef */ (*C.VkAttachmentLoadOp)(&y))
	return x
}

// StoreOp returns the value of storeOp from VkRenderingAttachmentInfo
func (x RenderingAttachmentInfo) StoreOp() AttachmentStoreOp {
	ptr := /* typedef */ (*AttachmentStoreOp)(&x.storeOp) 
	return *ptr
}

// WithStoreOp sets the value for the StoreOp on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingAttachmentInfo) WithStoreOp(y AttachmentStoreOp) RenderingAttachmentInfo {
	x.storeOp = *(/* typedef */ (*C.VkAttachmentStoreOp)(&y))
	return x
}

// ClearValue returns the value of clearValue from VkRenderingAttachmentInfo
func (x RenderingAttachmentInfo) ClearValue() ClearValue {
	ptr := /* typedef */ (*ClearValue)(&x.clearValue) 
	return *ptr
}

// WithClearValue sets the value for the ClearValue on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingAttachmentInfo) WithClearValue(y ClearValue) RenderingAttachmentInfo {
	x.clearValue = *(/* typedef */ (*C.VkClearValue)(&y))
	return x
}

// RenderingInfo provides a go interface for VkRenderingInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkRenderingInfo.html
type RenderingInfo C.struct_VkRenderingInfo

// SizeofRenderingInfo is the memory size of a RenderingInfo
var SizeofRenderingInfo int = int(unsafe.Sizeof(RenderingInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *RenderingInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x RenderingInfo) AsCPtr() *RenderingInfo {
	clone := (*RenderingInfo)(newCBlock(C.ulong(SizeofRenderingInfo)))
	*clone = x
	return clone
}

// RenderingInfoFreeCSlice releases the memory allocated by RenderingInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func RenderingInfoFreeCSlice(x []RenderingInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// RenderingInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. RenderingInfoFreeCSlice must be called on the returned slice.
func RenderingInfoMakeCSlice(x ...RenderingInfo) []RenderingInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofRenderingInfo * len(x)
	dst := unsafe.Slice((*RenderingInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkRenderingInfo
func (x RenderingInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x RenderingInfo) WithDefaultSType() RenderingInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_RENDERING_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingInfo) WithSType(y StructureType) RenderingInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkRenderingInfo
func (x RenderingInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingInfo) WithPNext(y unsafe.Pointer) RenderingInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkRenderingInfo
func (x RenderingInfo) Flags() RenderingFlags {
	ptr := /* typedef */ (*RenderingFlags)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingInfo) WithFlags(y RenderingFlags) RenderingInfo {
	x.flags = *(/* typedef */ (*C.VkRenderingFlags)(&y))
	return x
}

// RenderArea returns the value of renderArea from VkRenderingInfo
func (x RenderingInfo) RenderArea() Rect2D {
	ptr := /* typedef */ (*Rect2D)(&x.renderArea) 
	return *ptr
}

// WithRenderArea sets the value for the RenderArea on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingInfo) WithRenderArea(y Rect2D) RenderingInfo {
	x.renderArea = *(/* typedef */ (*C.struct_VkRect2D)(&y))
	return x
}

// LayerCount returns the value of layerCount from VkRenderingInfo
func (x RenderingInfo) LayerCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.layerCount) 
	return *ptr
}

// WithLayerCount sets the value for the LayerCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingInfo) WithLayerCount(y uint32) RenderingInfo {
	x.layerCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// ViewMask returns the value of viewMask from VkRenderingInfo
func (x RenderingInfo) ViewMask() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.viewMask) 
	return *ptr
}

// WithViewMask sets the value for the ViewMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingInfo) WithViewMask(y uint32) RenderingInfo {
	x.viewMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// ColorAttachmentCount returns the value of colorAttachmentCount from VkRenderingInfo
func (x RenderingInfo) ColorAttachmentCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.colorAttachmentCount) 
	return *ptr
}

// WithColorAttachmentCount sets the value for the ColorAttachmentCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingInfo) WithColorAttachmentCount(y uint32) RenderingInfo {
	x.colorAttachmentCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PColorAttachments returns the value of pColorAttachments from VkRenderingInfo
func (x RenderingInfo) PColorAttachments() []RenderingAttachmentInfo {
	ptr := func(x **C.struct_VkRenderingAttachmentInfo) *[]RenderingAttachmentInfo { /* Slice */ slc := unsafe.Slice((*RenderingAttachmentInfo)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pColorAttachments) 
	return *ptr
}

// WithPColorAttachments sets the value for the PColorAttachments on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines ColorAttachmentCount as the length of this field.
// ColorAttachmentCount is updated with the length of the new value.
func (x RenderingInfo) WithPColorAttachments(y []RenderingAttachmentInfo) RenderingInfo {
	x.pColorAttachments = *(func(x *[]RenderingAttachmentInfo) **C.struct_VkRenderingAttachmentInfo { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkRenderingAttachmentInfo)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkRenderingAttachmentInfo)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithColorAttachmentCount(uint32(len(y)))
}

// PDepthAttachment returns the value of pDepthAttachment from VkRenderingInfo
func (x RenderingInfo) PDepthAttachment() *RenderingAttachmentInfo {
	ptr := func(x **C.struct_VkRenderingAttachmentInfo) **RenderingAttachmentInfo { /* Pointer */ c2g := (*RenderingAttachmentInfo)(*x); return &c2g }(&x.pDepthAttachment) 
	return *ptr
}

// WithPDepthAttachment sets the value for the PDepthAttachment on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingInfo) WithPDepthAttachment(y *RenderingAttachmentInfo) RenderingInfo {
	x.pDepthAttachment = *(func(x **RenderingAttachmentInfo) **C.struct_VkRenderingAttachmentInfo { /* Pointer */ g2c := (*C.struct_VkRenderingAttachmentInfo)(*x); return &g2c }(&y))
	return x
}

// PStencilAttachment returns the value of pStencilAttachment from VkRenderingInfo
func (x RenderingInfo) PStencilAttachment() *RenderingAttachmentInfo {
	ptr := func(x **C.struct_VkRenderingAttachmentInfo) **RenderingAttachmentInfo { /* Pointer */ c2g := (*RenderingAttachmentInfo)(*x); return &c2g }(&x.pStencilAttachment) 
	return *ptr
}

// WithPStencilAttachment sets the value for the PStencilAttachment on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x RenderingInfo) WithPStencilAttachment(y *RenderingAttachmentInfo) RenderingInfo {
	x.pStencilAttachment = *(func(x **RenderingAttachmentInfo) **C.struct_VkRenderingAttachmentInfo { /* Pointer */ g2c := (*C.struct_VkRenderingAttachmentInfo)(*x); return &g2c }(&y))
	return x
}

// PhysicalDeviceTextureCompressionASTCHDRFeatures provides a go interface for VkPhysicalDeviceTextureCompressionASTCHDRFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTextureCompressionASTCHDRFeatures.html
type PhysicalDeviceTextureCompressionASTCHDRFeatures C.struct_VkPhysicalDeviceTextureCompressionASTCHDRFeatures

// SizeofPhysicalDeviceTextureCompressionASTCHDRFeatures is the memory size of a PhysicalDeviceTextureCompressionASTCHDRFeatures
var SizeofPhysicalDeviceTextureCompressionASTCHDRFeatures int = int(unsafe.Sizeof(PhysicalDeviceTextureCompressionASTCHDRFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceTextureCompressionASTCHDRFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceTextureCompressionASTCHDRFeatures) AsCPtr() *PhysicalDeviceTextureCompressionASTCHDRFeatures {
	clone := (*PhysicalDeviceTextureCompressionASTCHDRFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceTextureCompressionASTCHDRFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceTextureCompressionASTCHDRFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceTextureCompressionASTCHDRFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceTextureCompressionASTCHDRFeaturesFreeCSlice(x []PhysicalDeviceTextureCompressionASTCHDRFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceTextureCompressionASTCHDRFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceTextureCompressionASTCHDRFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceTextureCompressionASTCHDRFeaturesMakeCSlice(x ...PhysicalDeviceTextureCompressionASTCHDRFeatures) []PhysicalDeviceTextureCompressionASTCHDRFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceTextureCompressionASTCHDRFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceTextureCompressionASTCHDRFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceTextureCompressionASTCHDRFeatures
func (x PhysicalDeviceTextureCompressionASTCHDRFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceTextureCompressionASTCHDRFeatures) WithDefaultSType() PhysicalDeviceTextureCompressionASTCHDRFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceTextureCompressionASTCHDRFeatures) WithSType(y StructureType) PhysicalDeviceTextureCompressionASTCHDRFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceTextureCompressionASTCHDRFeatures
func (x PhysicalDeviceTextureCompressionASTCHDRFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceTextureCompressionASTCHDRFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceTextureCompressionASTCHDRFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// TextureCompressionASTC_HDR returns the value of textureCompressionASTC_HDR from VkPhysicalDeviceTextureCompressionASTCHDRFeatures
func (x PhysicalDeviceTextureCompressionASTCHDRFeatures) TextureCompressionASTC_HDR() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.textureCompressionASTC_HDR) 
	return *ptr
}

// WithTextureCompressionASTC_HDR sets the value for the TextureCompressionASTC_HDR on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceTextureCompressionASTCHDRFeatures) WithTextureCompressionASTC_HDR(y Bool32) PhysicalDeviceTextureCompressionASTCHDRFeatures {
	x.textureCompressionASTC_HDR = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// CopyBufferInfo2 provides a go interface for VkCopyBufferInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyBufferInfo2.html
type CopyBufferInfo2 C.struct_VkCopyBufferInfo2

// SizeofCopyBufferInfo2 is the memory size of a CopyBufferInfo2
var SizeofCopyBufferInfo2 int = int(unsafe.Sizeof(CopyBufferInfo2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *CopyBufferInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x CopyBufferInfo2) AsCPtr() *CopyBufferInfo2 {
	clone := (*CopyBufferInfo2)(newCBlock(C.ulong(SizeofCopyBufferInfo2)))
	*clone = x
	return clone
}

// CopyBufferInfo2FreeCSlice releases the memory allocated by CopyBufferInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func CopyBufferInfo2FreeCSlice(x []CopyBufferInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// CopyBufferInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. CopyBufferInfo2FreeCSlice must be called on the returned slice.
func CopyBufferInfo2MakeCSlice(x ...CopyBufferInfo2) []CopyBufferInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCopyBufferInfo2 * len(x)
	dst := unsafe.Slice((*CopyBufferInfo2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkCopyBufferInfo2
func (x CopyBufferInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x CopyBufferInfo2) WithDefaultSType() CopyBufferInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyBufferInfo2) WithSType(y StructureType) CopyBufferInfo2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkCopyBufferInfo2
func (x CopyBufferInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyBufferInfo2) WithPNext(y unsafe.Pointer) CopyBufferInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SrcBuffer returns the value of srcBuffer from VkCopyBufferInfo2
func (x CopyBufferInfo2) SrcBuffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.srcBuffer) 
	return *ptr
}

// WithSrcBuffer sets the value for the SrcBuffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyBufferInfo2) WithSrcBuffer(y Buffer) CopyBufferInfo2 {
	x.srcBuffer = *(/* handle */ (*C.VkBuffer)(&y))
	return x
}

// DstBuffer returns the value of dstBuffer from VkCopyBufferInfo2
func (x CopyBufferInfo2) DstBuffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.dstBuffer) 
	return *ptr
}

// WithDstBuffer sets the value for the DstBuffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyBufferInfo2) WithDstBuffer(y Buffer) CopyBufferInfo2 {
	x.dstBuffer = *(/* handle */ (*C.VkBuffer)(&y))
	return x
}

// RegionCount returns the value of regionCount from VkCopyBufferInfo2
func (x CopyBufferInfo2) RegionCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.regionCount) 
	return *ptr
}

// WithRegionCount sets the value for the RegionCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyBufferInfo2) WithRegionCount(y uint32) CopyBufferInfo2 {
	x.regionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PRegions returns the value of pRegions from VkCopyBufferInfo2
func (x CopyBufferInfo2) PRegions() []BufferCopy2 {
	ptr := func(x **C.struct_VkBufferCopy2) *[]BufferCopy2 { /* Slice */ slc := unsafe.Slice((*BufferCopy2)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pRegions) 
	return *ptr
}

// WithPRegions sets the value for the PRegions on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines RegionCount as the length of this field.
// RegionCount is updated with the length of the new value.
func (x CopyBufferInfo2) WithPRegions(y []BufferCopy2) CopyBufferInfo2 {
	x.pRegions = *(func(x *[]BufferCopy2) **C.struct_VkBufferCopy2 { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkBufferCopy2)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkBufferCopy2)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithRegionCount(uint32(len(y)))
}

// CopyImageInfo2 provides a go interface for VkCopyImageInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyImageInfo2.html
type CopyImageInfo2 C.struct_VkCopyImageInfo2

// SizeofCopyImageInfo2 is the memory size of a CopyImageInfo2
var SizeofCopyImageInfo2 int = int(unsafe.Sizeof(CopyImageInfo2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *CopyImageInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x CopyImageInfo2) AsCPtr() *CopyImageInfo2 {
	clone := (*CopyImageInfo2)(newCBlock(C.ulong(SizeofCopyImageInfo2)))
	*clone = x
	return clone
}

// CopyImageInfo2FreeCSlice releases the memory allocated by CopyImageInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func CopyImageInfo2FreeCSlice(x []CopyImageInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// CopyImageInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. CopyImageInfo2FreeCSlice must be called on the returned slice.
func CopyImageInfo2MakeCSlice(x ...CopyImageInfo2) []CopyImageInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCopyImageInfo2 * len(x)
	dst := unsafe.Slice((*CopyImageInfo2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkCopyImageInfo2
func (x CopyImageInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x CopyImageInfo2) WithDefaultSType() CopyImageInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyImageInfo2) WithSType(y StructureType) CopyImageInfo2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkCopyImageInfo2
func (x CopyImageInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyImageInfo2) WithPNext(y unsafe.Pointer) CopyImageInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SrcImage returns the value of srcImage from VkCopyImageInfo2
func (x CopyImageInfo2) SrcImage() Image {
	ptr := /* handle */ (*Image)(&x.srcImage) 
	return *ptr
}

// WithSrcImage sets the value for the SrcImage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyImageInfo2) WithSrcImage(y Image) CopyImageInfo2 {
	x.srcImage = *(/* handle */ (*C.VkImage)(&y))
	return x
}

// SrcImageLayout returns the value of srcImageLayout from VkCopyImageInfo2
func (x CopyImageInfo2) SrcImageLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.srcImageLayout) 
	return *ptr
}

// WithSrcImageLayout sets the value for the SrcImageLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyImageInfo2) WithSrcImageLayout(y ImageLayout) CopyImageInfo2 {
	x.srcImageLayout = *(/* typedef */ (*C.VkImageLayout)(&y))
	return x
}

// DstImage returns the value of dstImage from VkCopyImageInfo2
func (x CopyImageInfo2) DstImage() Image {
	ptr := /* handle */ (*Image)(&x.dstImage) 
	return *ptr
}

// WithDstImage sets the value for the DstImage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyImageInfo2) WithDstImage(y Image) CopyImageInfo2 {
	x.dstImage = *(/* handle */ (*C.VkImage)(&y))
	return x
}

// DstImageLayout returns the value of dstImageLayout from VkCopyImageInfo2
func (x CopyImageInfo2) DstImageLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.dstImageLayout) 
	return *ptr
}

// WithDstImageLayout sets the value for the DstImageLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyImageInfo2) WithDstImageLayout(y ImageLayout) CopyImageInfo2 {
	x.dstImageLayout = *(/* typedef */ (*C.VkImageLayout)(&y))
	return x
}

// RegionCount returns the value of regionCount from VkCopyImageInfo2
func (x CopyImageInfo2) RegionCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.regionCount) 
	return *ptr
}

// WithRegionCount sets the value for the RegionCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyImageInfo2) WithRegionCount(y uint32) CopyImageInfo2 {
	x.regionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PRegions returns the value of pRegions from VkCopyImageInfo2
func (x CopyImageInfo2) PRegions() []ImageCopy2 {
	ptr := func(x **C.struct_VkImageCopy2) *[]ImageCopy2 { /* Slice */ slc := unsafe.Slice((*ImageCopy2)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pRegions) 
	return *ptr
}

// WithPRegions sets the value for the PRegions on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines RegionCount as the length of this field.
// RegionCount is updated with the length of the new value.
func (x CopyImageInfo2) WithPRegions(y []ImageCopy2) CopyImageInfo2 {
	x.pRegions = *(func(x *[]ImageCopy2) **C.struct_VkImageCopy2 { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkImageCopy2)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkImageCopy2)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithRegionCount(uint32(len(y)))
}

// CopyBufferToImageInfo2 provides a go interface for VkCopyBufferToImageInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyBufferToImageInfo2.html
type CopyBufferToImageInfo2 C.struct_VkCopyBufferToImageInfo2

// SizeofCopyBufferToImageInfo2 is the memory size of a CopyBufferToImageInfo2
var SizeofCopyBufferToImageInfo2 int = int(unsafe.Sizeof(CopyBufferToImageInfo2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *CopyBufferToImageInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x CopyBufferToImageInfo2) AsCPtr() *CopyBufferToImageInfo2 {
	clone := (*CopyBufferToImageInfo2)(newCBlock(C.ulong(SizeofCopyBufferToImageInfo2)))
	*clone = x
	return clone
}

// CopyBufferToImageInfo2FreeCSlice releases the memory allocated by CopyBufferToImageInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func CopyBufferToImageInfo2FreeCSlice(x []CopyBufferToImageInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// CopyBufferToImageInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. CopyBufferToImageInfo2FreeCSlice must be called on the returned slice.
func CopyBufferToImageInfo2MakeCSlice(x ...CopyBufferToImageInfo2) []CopyBufferToImageInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCopyBufferToImageInfo2 * len(x)
	dst := unsafe.Slice((*CopyBufferToImageInfo2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkCopyBufferToImageInfo2
func (x CopyBufferToImageInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x CopyBufferToImageInfo2) WithDefaultSType() CopyBufferToImageInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyBufferToImageInfo2) WithSType(y StructureType) CopyBufferToImageInfo2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkCopyBufferToImageInfo2
func (x CopyBufferToImageInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyBufferToImageInfo2) WithPNext(y unsafe.Pointer) CopyBufferToImageInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SrcBuffer returns the value of srcBuffer from VkCopyBufferToImageInfo2
func (x CopyBufferToImageInfo2) SrcBuffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.srcBuffer) 
	return *ptr
}

// WithSrcBuffer sets the value for the SrcBuffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyBufferToImageInfo2) WithSrcBuffer(y Buffer) CopyBufferToImageInfo2 {
	x.srcBuffer = *(/* handle */ (*C.VkBuffer)(&y))
	return x
}

// DstImage returns the value of dstImage from VkCopyBufferToImageInfo2
func (x CopyBufferToImageInfo2) DstImage() Image {
	ptr := /* handle */ (*Image)(&x.dstImage) 
	return *ptr
}

// WithDstImage sets the value for the DstImage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyBufferToImageInfo2) WithDstImage(y Image) CopyBufferToImageInfo2 {
	x.dstImage = *(/* handle */ (*C.VkImage)(&y))
	return x
}

// DstImageLayout returns the value of dstImageLayout from VkCopyBufferToImageInfo2
func (x CopyBufferToImageInfo2) DstImageLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.dstImageLayout) 
	return *ptr
}

// WithDstImageLayout sets the value for the DstImageLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyBufferToImageInfo2) WithDstImageLayout(y ImageLayout) CopyBufferToImageInfo2 {
	x.dstImageLayout = *(/* typedef */ (*C.VkImageLayout)(&y))
	return x
}

// RegionCount returns the value of regionCount from VkCopyBufferToImageInfo2
func (x CopyBufferToImageInfo2) RegionCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.regionCount) 
	return *ptr
}

// WithRegionCount sets the value for the RegionCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyBufferToImageInfo2) WithRegionCount(y uint32) CopyBufferToImageInfo2 {
	x.regionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PRegions returns the value of pRegions from VkCopyBufferToImageInfo2
func (x CopyBufferToImageInfo2) PRegions() []BufferImageCopy2 {
	ptr := func(x **C.struct_VkBufferImageCopy2) *[]BufferImageCopy2 { /* Slice */ slc := unsafe.Slice((*BufferImageCopy2)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pRegions) 
	return *ptr
}

// WithPRegions sets the value for the PRegions on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines RegionCount as the length of this field.
// RegionCount is updated with the length of the new value.
func (x CopyBufferToImageInfo2) WithPRegions(y []BufferImageCopy2) CopyBufferToImageInfo2 {
	x.pRegions = *(func(x *[]BufferImageCopy2) **C.struct_VkBufferImageCopy2 { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkBufferImageCopy2)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkBufferImageCopy2)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithRegionCount(uint32(len(y)))
}

// CopyImageToBufferInfo2 provides a go interface for VkCopyImageToBufferInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCopyImageToBufferInfo2.html
type CopyImageToBufferInfo2 C.struct_VkCopyImageToBufferInfo2

// SizeofCopyImageToBufferInfo2 is the memory size of a CopyImageToBufferInfo2
var SizeofCopyImageToBufferInfo2 int = int(unsafe.Sizeof(CopyImageToBufferInfo2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *CopyImageToBufferInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x CopyImageToBufferInfo2) AsCPtr() *CopyImageToBufferInfo2 {
	clone := (*CopyImageToBufferInfo2)(newCBlock(C.ulong(SizeofCopyImageToBufferInfo2)))
	*clone = x
	return clone
}

// CopyImageToBufferInfo2FreeCSlice releases the memory allocated by CopyImageToBufferInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func CopyImageToBufferInfo2FreeCSlice(x []CopyImageToBufferInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// CopyImageToBufferInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. CopyImageToBufferInfo2FreeCSlice must be called on the returned slice.
func CopyImageToBufferInfo2MakeCSlice(x ...CopyImageToBufferInfo2) []CopyImageToBufferInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofCopyImageToBufferInfo2 * len(x)
	dst := unsafe.Slice((*CopyImageToBufferInfo2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkCopyImageToBufferInfo2
func (x CopyImageToBufferInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x CopyImageToBufferInfo2) WithDefaultSType() CopyImageToBufferInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyImageToBufferInfo2) WithSType(y StructureType) CopyImageToBufferInfo2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkCopyImageToBufferInfo2
func (x CopyImageToBufferInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyImageToBufferInfo2) WithPNext(y unsafe.Pointer) CopyImageToBufferInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SrcImage returns the value of srcImage from VkCopyImageToBufferInfo2
func (x CopyImageToBufferInfo2) SrcImage() Image {
	ptr := /* handle */ (*Image)(&x.srcImage) 
	return *ptr
}

// WithSrcImage sets the value for the SrcImage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyImageToBufferInfo2) WithSrcImage(y Image) CopyImageToBufferInfo2 {
	x.srcImage = *(/* handle */ (*C.VkImage)(&y))
	return x
}

// SrcImageLayout returns the value of srcImageLayout from VkCopyImageToBufferInfo2
func (x CopyImageToBufferInfo2) SrcImageLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.srcImageLayout) 
	return *ptr
}

// WithSrcImageLayout sets the value for the SrcImageLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyImageToBufferInfo2) WithSrcImageLayout(y ImageLayout) CopyImageToBufferInfo2 {
	x.srcImageLayout = *(/* typedef */ (*C.VkImageLayout)(&y))
	return x
}

// DstBuffer returns the value of dstBuffer from VkCopyImageToBufferInfo2
func (x CopyImageToBufferInfo2) DstBuffer() Buffer {
	ptr := /* handle */ (*Buffer)(&x.dstBuffer) 
	return *ptr
}

// WithDstBuffer sets the value for the DstBuffer on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyImageToBufferInfo2) WithDstBuffer(y Buffer) CopyImageToBufferInfo2 {
	x.dstBuffer = *(/* handle */ (*C.VkBuffer)(&y))
	return x
}

// RegionCount returns the value of regionCount from VkCopyImageToBufferInfo2
func (x CopyImageToBufferInfo2) RegionCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.regionCount) 
	return *ptr
}

// WithRegionCount sets the value for the RegionCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x CopyImageToBufferInfo2) WithRegionCount(y uint32) CopyImageToBufferInfo2 {
	x.regionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PRegions returns the value of pRegions from VkCopyImageToBufferInfo2
func (x CopyImageToBufferInfo2) PRegions() []BufferImageCopy2 {
	ptr := func(x **C.struct_VkBufferImageCopy2) *[]BufferImageCopy2 { /* Slice */ slc := unsafe.Slice((*BufferImageCopy2)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pRegions) 
	return *ptr
}

// WithPRegions sets the value for the PRegions on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines RegionCount as the length of this field.
// RegionCount is updated with the length of the new value.
func (x CopyImageToBufferInfo2) WithPRegions(y []BufferImageCopy2) CopyImageToBufferInfo2 {
	x.pRegions = *(func(x *[]BufferImageCopy2) **C.struct_VkBufferImageCopy2 { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkBufferImageCopy2)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkBufferImageCopy2)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithRegionCount(uint32(len(y)))
}

// BlitImageInfo2 provides a go interface for VkBlitImageInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBlitImageInfo2.html
type BlitImageInfo2 C.struct_VkBlitImageInfo2

// SizeofBlitImageInfo2 is the memory size of a BlitImageInfo2
var SizeofBlitImageInfo2 int = int(unsafe.Sizeof(BlitImageInfo2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BlitImageInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BlitImageInfo2) AsCPtr() *BlitImageInfo2 {
	clone := (*BlitImageInfo2)(newCBlock(C.ulong(SizeofBlitImageInfo2)))
	*clone = x
	return clone
}

// BlitImageInfo2FreeCSlice releases the memory allocated by BlitImageInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func BlitImageInfo2FreeCSlice(x []BlitImageInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BlitImageInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BlitImageInfo2FreeCSlice must be called on the returned slice.
func BlitImageInfo2MakeCSlice(x ...BlitImageInfo2) []BlitImageInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBlitImageInfo2 * len(x)
	dst := unsafe.Slice((*BlitImageInfo2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBlitImageInfo2
func (x BlitImageInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BlitImageInfo2) WithDefaultSType() BlitImageInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BlitImageInfo2) WithSType(y StructureType) BlitImageInfo2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkBlitImageInfo2
func (x BlitImageInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BlitImageInfo2) WithPNext(y unsafe.Pointer) BlitImageInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SrcImage returns the value of srcImage from VkBlitImageInfo2
func (x BlitImageInfo2) SrcImage() Image {
	ptr := /* handle */ (*Image)(&x.srcImage) 
	return *ptr
}

// WithSrcImage sets the value for the SrcImage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BlitImageInfo2) WithSrcImage(y Image) BlitImageInfo2 {
	x.srcImage = *(/* handle */ (*C.VkImage)(&y))
	return x
}

// SrcImageLayout returns the value of srcImageLayout from VkBlitImageInfo2
func (x BlitImageInfo2) SrcImageLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.srcImageLayout) 
	return *ptr
}

// WithSrcImageLayout sets the value for the SrcImageLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BlitImageInfo2) WithSrcImageLayout(y ImageLayout) BlitImageInfo2 {
	x.srcImageLayout = *(/* typedef */ (*C.VkImageLayout)(&y))
	return x
}

// DstImage returns the value of dstImage from VkBlitImageInfo2
func (x BlitImageInfo2) DstImage() Image {
	ptr := /* handle */ (*Image)(&x.dstImage) 
	return *ptr
}

// WithDstImage sets the value for the DstImage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BlitImageInfo2) WithDstImage(y Image) BlitImageInfo2 {
	x.dstImage = *(/* handle */ (*C.VkImage)(&y))
	return x
}

// DstImageLayout returns the value of dstImageLayout from VkBlitImageInfo2
func (x BlitImageInfo2) DstImageLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.dstImageLayout) 
	return *ptr
}

// WithDstImageLayout sets the value for the DstImageLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BlitImageInfo2) WithDstImageLayout(y ImageLayout) BlitImageInfo2 {
	x.dstImageLayout = *(/* typedef */ (*C.VkImageLayout)(&y))
	return x
}

// RegionCount returns the value of regionCount from VkBlitImageInfo2
func (x BlitImageInfo2) RegionCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.regionCount) 
	return *ptr
}

// WithRegionCount sets the value for the RegionCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BlitImageInfo2) WithRegionCount(y uint32) BlitImageInfo2 {
	x.regionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PRegions returns the value of pRegions from VkBlitImageInfo2
func (x BlitImageInfo2) PRegions() []ImageBlit2 {
	ptr := func(x **C.struct_VkImageBlit2) *[]ImageBlit2 { /* Slice */ slc := unsafe.Slice((*ImageBlit2)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pRegions) 
	return *ptr
}

// WithPRegions sets the value for the PRegions on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines RegionCount as the length of this field.
// RegionCount is updated with the length of the new value.
func (x BlitImageInfo2) WithPRegions(y []ImageBlit2) BlitImageInfo2 {
	x.pRegions = *(func(x *[]ImageBlit2) **C.struct_VkImageBlit2 { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkImageBlit2)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkImageBlit2)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithRegionCount(uint32(len(y)))
}

// Filter returns the value of filter from VkBlitImageInfo2
func (x BlitImageInfo2) Filter() Filter {
	ptr := /* typedef */ (*Filter)(&x.filter) 
	return *ptr
}

// WithFilter sets the value for the Filter on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BlitImageInfo2) WithFilter(y Filter) BlitImageInfo2 {
	x.filter = *(/* typedef */ (*C.VkFilter)(&y))
	return x
}

// ResolveImageInfo2 provides a go interface for VkResolveImageInfo2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkResolveImageInfo2.html
type ResolveImageInfo2 C.struct_VkResolveImageInfo2

// SizeofResolveImageInfo2 is the memory size of a ResolveImageInfo2
var SizeofResolveImageInfo2 int = int(unsafe.Sizeof(ResolveImageInfo2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ResolveImageInfo2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ResolveImageInfo2) AsCPtr() *ResolveImageInfo2 {
	clone := (*ResolveImageInfo2)(newCBlock(C.ulong(SizeofResolveImageInfo2)))
	*clone = x
	return clone
}

// ResolveImageInfo2FreeCSlice releases the memory allocated by ResolveImageInfo2MakeCSlice.
// It does not free pointers stored inside the slice.
func ResolveImageInfo2FreeCSlice(x []ResolveImageInfo2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ResolveImageInfo2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ResolveImageInfo2FreeCSlice must be called on the returned slice.
func ResolveImageInfo2MakeCSlice(x ...ResolveImageInfo2) []ResolveImageInfo2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofResolveImageInfo2 * len(x)
	dst := unsafe.Slice((*ResolveImageInfo2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkResolveImageInfo2
func (x ResolveImageInfo2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ResolveImageInfo2) WithDefaultSType() ResolveImageInfo2 {
	return x.WithSType(VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ResolveImageInfo2) WithSType(y StructureType) ResolveImageInfo2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkResolveImageInfo2
func (x ResolveImageInfo2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ResolveImageInfo2) WithPNext(y unsafe.Pointer) ResolveImageInfo2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SrcImage returns the value of srcImage from VkResolveImageInfo2
func (x ResolveImageInfo2) SrcImage() Image {
	ptr := /* handle */ (*Image)(&x.srcImage) 
	return *ptr
}

// WithSrcImage sets the value for the SrcImage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ResolveImageInfo2) WithSrcImage(y Image) ResolveImageInfo2 {
	x.srcImage = *(/* handle */ (*C.VkImage)(&y))
	return x
}

// SrcImageLayout returns the value of srcImageLayout from VkResolveImageInfo2
func (x ResolveImageInfo2) SrcImageLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.srcImageLayout) 
	return *ptr
}

// WithSrcImageLayout sets the value for the SrcImageLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ResolveImageInfo2) WithSrcImageLayout(y ImageLayout) ResolveImageInfo2 {
	x.srcImageLayout = *(/* typedef */ (*C.VkImageLayout)(&y))
	return x
}

// DstImage returns the value of dstImage from VkResolveImageInfo2
func (x ResolveImageInfo2) DstImage() Image {
	ptr := /* handle */ (*Image)(&x.dstImage) 
	return *ptr
}

// WithDstImage sets the value for the DstImage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ResolveImageInfo2) WithDstImage(y Image) ResolveImageInfo2 {
	x.dstImage = *(/* handle */ (*C.VkImage)(&y))
	return x
}

// DstImageLayout returns the value of dstImageLayout from VkResolveImageInfo2
func (x ResolveImageInfo2) DstImageLayout() ImageLayout {
	ptr := /* typedef */ (*ImageLayout)(&x.dstImageLayout) 
	return *ptr
}

// WithDstImageLayout sets the value for the DstImageLayout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ResolveImageInfo2) WithDstImageLayout(y ImageLayout) ResolveImageInfo2 {
	x.dstImageLayout = *(/* typedef */ (*C.VkImageLayout)(&y))
	return x
}

// RegionCount returns the value of regionCount from VkResolveImageInfo2
func (x ResolveImageInfo2) RegionCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.regionCount) 
	return *ptr
}

// WithRegionCount sets the value for the RegionCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ResolveImageInfo2) WithRegionCount(y uint32) ResolveImageInfo2 {
	x.regionCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PRegions returns the value of pRegions from VkResolveImageInfo2
func (x ResolveImageInfo2) PRegions() []ImageResolve2 {
	ptr := func(x **C.struct_VkImageResolve2) *[]ImageResolve2 { /* Slice */ slc := unsafe.Slice((*ImageResolve2)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pRegions) 
	return *ptr
}

// WithPRegions sets the value for the PRegions on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines RegionCount as the length of this field.
// RegionCount is updated with the length of the new value.
func (x ResolveImageInfo2) WithPRegions(y []ImageResolve2) ResolveImageInfo2 {
	x.pRegions = *(func(x *[]ImageResolve2) **C.struct_VkImageResolve2 { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkImageResolve2)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkImageResolve2)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithRegionCount(uint32(len(y)))
}

// BufferCopy2 provides a go interface for VkBufferCopy2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferCopy2.html
type BufferCopy2 C.struct_VkBufferCopy2

// SizeofBufferCopy2 is the memory size of a BufferCopy2
var SizeofBufferCopy2 int = int(unsafe.Sizeof(BufferCopy2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferCopy2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferCopy2) AsCPtr() *BufferCopy2 {
	clone := (*BufferCopy2)(newCBlock(C.ulong(SizeofBufferCopy2)))
	*clone = x
	return clone
}

// BufferCopy2FreeCSlice releases the memory allocated by BufferCopy2MakeCSlice.
// It does not free pointers stored inside the slice.
func BufferCopy2FreeCSlice(x []BufferCopy2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferCopy2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferCopy2FreeCSlice must be called on the returned slice.
func BufferCopy2MakeCSlice(x ...BufferCopy2) []BufferCopy2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferCopy2 * len(x)
	dst := unsafe.Slice((*BufferCopy2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBufferCopy2
func (x BufferCopy2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BufferCopy2) WithDefaultSType() BufferCopy2 {
	return x.WithSType(VK_STRUCTURE_TYPE_BUFFER_COPY_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCopy2) WithSType(y StructureType) BufferCopy2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkBufferCopy2
func (x BufferCopy2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCopy2) WithPNext(y unsafe.Pointer) BufferCopy2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SrcOffset returns the value of srcOffset from VkBufferCopy2
func (x BufferCopy2) SrcOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.srcOffset) 
	return *ptr
}

// WithSrcOffset sets the value for the SrcOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCopy2) WithSrcOffset(y DeviceSize) BufferCopy2 {
	x.srcOffset = *(/* typedef */ (*C.VkDeviceSize)(&y))
	return x
}

// DstOffset returns the value of dstOffset from VkBufferCopy2
func (x BufferCopy2) DstOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.dstOffset) 
	return *ptr
}

// WithDstOffset sets the value for the DstOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCopy2) WithDstOffset(y DeviceSize) BufferCopy2 {
	x.dstOffset = *(/* typedef */ (*C.VkDeviceSize)(&y))
	return x
}

// Size returns the value of size from VkBufferCopy2
func (x BufferCopy2) Size() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.size) 
	return *ptr
}

// WithSize sets the value for the Size on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferCopy2) WithSize(y DeviceSize) BufferCopy2 {
	x.size = *(/* typedef */ (*C.VkDeviceSize)(&y))
	return x
}

// ImageCopy2 provides a go interface for VkImageCopy2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageCopy2.html
type ImageCopy2 C.struct_VkImageCopy2

// SizeofImageCopy2 is the memory size of a ImageCopy2
var SizeofImageCopy2 int = int(unsafe.Sizeof(ImageCopy2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageCopy2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageCopy2) AsCPtr() *ImageCopy2 {
	clone := (*ImageCopy2)(newCBlock(C.ulong(SizeofImageCopy2)))
	*clone = x
	return clone
}

// ImageCopy2FreeCSlice releases the memory allocated by ImageCopy2MakeCSlice.
// It does not free pointers stored inside the slice.
func ImageCopy2FreeCSlice(x []ImageCopy2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageCopy2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageCopy2FreeCSlice must be called on the returned slice.
func ImageCopy2MakeCSlice(x ...ImageCopy2) []ImageCopy2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageCopy2 * len(x)
	dst := unsafe.Slice((*ImageCopy2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageCopy2
func (x ImageCopy2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ImageCopy2) WithDefaultSType() ImageCopy2 {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_COPY_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy2) WithSType(y StructureType) ImageCopy2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkImageCopy2
func (x ImageCopy2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy2) WithPNext(y unsafe.Pointer) ImageCopy2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SrcSubresource returns the value of srcSubresource from VkImageCopy2
func (x ImageCopy2) SrcSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.srcSubresource) 
	return *ptr
}

// WithSrcSubresource sets the value for the SrcSubresource on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy2) WithSrcSubresource(y ImageSubresourceLayers) ImageCopy2 {
	x.srcSubresource = *(/* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}

// SrcOffset returns the value of srcOffset from VkImageCopy2
func (x ImageCopy2) SrcOffset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.srcOffset) 
	return *ptr
}

// WithSrcOffset sets the value for the SrcOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy2) WithSrcOffset(y Offset3D) ImageCopy2 {
	x.srcOffset = *(/* typedef */ (*C.struct_VkOffset3D)(&y))
	return x
}

// DstSubresource returns the value of dstSubresource from VkImageCopy2
func (x ImageCopy2) DstSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.dstSubresource) 
	return *ptr
}

// WithDstSubresource sets the value for the DstSubresource on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy2) WithDstSubresource(y ImageSubresourceLayers) ImageCopy2 {
	x.dstSubresource = *(/* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}

// DstOffset returns the value of dstOffset from VkImageCopy2
func (x ImageCopy2) DstOffset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.dstOffset) 
	return *ptr
}

// WithDstOffset sets the value for the DstOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy2) WithDstOffset(y Offset3D) ImageCopy2 {
	x.dstOffset = *(/* typedef */ (*C.struct_VkOffset3D)(&y))
	return x
}

// Extent returns the value of extent from VkImageCopy2
func (x ImageCopy2) Extent() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.extent) 
	return *ptr
}

// WithExtent sets the value for the Extent on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageCopy2) WithExtent(y Extent3D) ImageCopy2 {
	x.extent = *(/* typedef */ (*C.struct_VkExtent3D)(&y))
	return x
}

// ImageBlit2 provides a go interface for VkImageBlit2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageBlit2.html
type ImageBlit2 C.struct_VkImageBlit2

// SizeofImageBlit2 is the memory size of a ImageBlit2
var SizeofImageBlit2 int = int(unsafe.Sizeof(ImageBlit2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageBlit2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageBlit2) AsCPtr() *ImageBlit2 {
	clone := (*ImageBlit2)(newCBlock(C.ulong(SizeofImageBlit2)))
	*clone = x
	return clone
}

// ImageBlit2FreeCSlice releases the memory allocated by ImageBlit2MakeCSlice.
// It does not free pointers stored inside the slice.
func ImageBlit2FreeCSlice(x []ImageBlit2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageBlit2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageBlit2FreeCSlice must be called on the returned slice.
func ImageBlit2MakeCSlice(x ...ImageBlit2) []ImageBlit2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageBlit2 * len(x)
	dst := unsafe.Slice((*ImageBlit2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageBlit2
func (x ImageBlit2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ImageBlit2) WithDefaultSType() ImageBlit2 {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_BLIT_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageBlit2) WithSType(y StructureType) ImageBlit2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkImageBlit2
func (x ImageBlit2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageBlit2) WithPNext(y unsafe.Pointer) ImageBlit2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SrcSubresource returns the value of srcSubresource from VkImageBlit2
func (x ImageBlit2) SrcSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.srcSubresource) 
	return *ptr
}

// WithSrcSubresource sets the value for the SrcSubresource on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageBlit2) WithSrcSubresource(y ImageSubresourceLayers) ImageBlit2 {
	x.srcSubresource = *(/* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}

// SrcOffsets returns the value of srcOffsets from VkImageBlit2
func (x ImageBlit2) SrcOffsets() []Offset3D {
	ptr := func(x *[2]C.struct_VkOffset3D) *[]Offset3D { /* Array */ slc := unsafe.Slice((*Offset3D)(unsafe.Pointer(x)), 2); return &slc }(&x.srcOffsets) 
	return *ptr
}

// WithSrcOffsets sets the value for the SrcOffsets on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageBlit2) WithSrcOffsets(y []Offset3D) ImageBlit2 {
	ptr := func(x *[]Offset3D) **C.struct_VkOffset3D { /* Array */ if len(*x) > 0 { slc := (*C.struct_VkOffset3D)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkOffset3D)(unsafe.Pointer((&ptr))) }(&y)
	copy(x.srcOffsets[:], unsafe.Slice(*ptr, len(y)))
	return x
}

// DstSubresource returns the value of dstSubresource from VkImageBlit2
func (x ImageBlit2) DstSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.dstSubresource) 
	return *ptr
}

// WithDstSubresource sets the value for the DstSubresource on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageBlit2) WithDstSubresource(y ImageSubresourceLayers) ImageBlit2 {
	x.dstSubresource = *(/* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}

// DstOffsets returns the value of dstOffsets from VkImageBlit2
func (x ImageBlit2) DstOffsets() []Offset3D {
	ptr := func(x *[2]C.struct_VkOffset3D) *[]Offset3D { /* Array */ slc := unsafe.Slice((*Offset3D)(unsafe.Pointer(x)), 2); return &slc }(&x.dstOffsets) 
	return *ptr
}

// WithDstOffsets sets the value for the DstOffsets on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageBlit2) WithDstOffsets(y []Offset3D) ImageBlit2 {
	ptr := func(x *[]Offset3D) **C.struct_VkOffset3D { /* Array */ if len(*x) > 0 { slc := (*C.struct_VkOffset3D)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkOffset3D)(unsafe.Pointer((&ptr))) }(&y)
	copy(x.dstOffsets[:], unsafe.Slice(*ptr, len(y)))
	return x
}

// BufferImageCopy2 provides a go interface for VkBufferImageCopy2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBufferImageCopy2.html
type BufferImageCopy2 C.struct_VkBufferImageCopy2

// SizeofBufferImageCopy2 is the memory size of a BufferImageCopy2
var SizeofBufferImageCopy2 int = int(unsafe.Sizeof(BufferImageCopy2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BufferImageCopy2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BufferImageCopy2) AsCPtr() *BufferImageCopy2 {
	clone := (*BufferImageCopy2)(newCBlock(C.ulong(SizeofBufferImageCopy2)))
	*clone = x
	return clone
}

// BufferImageCopy2FreeCSlice releases the memory allocated by BufferImageCopy2MakeCSlice.
// It does not free pointers stored inside the slice.
func BufferImageCopy2FreeCSlice(x []BufferImageCopy2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BufferImageCopy2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BufferImageCopy2FreeCSlice must be called on the returned slice.
func BufferImageCopy2MakeCSlice(x ...BufferImageCopy2) []BufferImageCopy2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBufferImageCopy2 * len(x)
	dst := unsafe.Slice((*BufferImageCopy2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBufferImageCopy2
func (x BufferImageCopy2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BufferImageCopy2) WithDefaultSType() BufferImageCopy2 {
	return x.WithSType(VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy2) WithSType(y StructureType) BufferImageCopy2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkBufferImageCopy2
func (x BufferImageCopy2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy2) WithPNext(y unsafe.Pointer) BufferImageCopy2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// BufferOffset returns the value of bufferOffset from VkBufferImageCopy2
func (x BufferImageCopy2) BufferOffset() DeviceSize {
	ptr := /* typedef */ (*DeviceSize)(&x.bufferOffset) 
	return *ptr
}

// WithBufferOffset sets the value for the BufferOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy2) WithBufferOffset(y DeviceSize) BufferImageCopy2 {
	x.bufferOffset = *(/* typedef */ (*C.VkDeviceSize)(&y))
	return x
}

// BufferRowLength returns the value of bufferRowLength from VkBufferImageCopy2
func (x BufferImageCopy2) BufferRowLength() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.bufferRowLength) 
	return *ptr
}

// WithBufferRowLength sets the value for the BufferRowLength on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy2) WithBufferRowLength(y uint32) BufferImageCopy2 {
	x.bufferRowLength = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// BufferImageHeight returns the value of bufferImageHeight from VkBufferImageCopy2
func (x BufferImageCopy2) BufferImageHeight() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.bufferImageHeight) 
	return *ptr
}

// WithBufferImageHeight sets the value for the BufferImageHeight on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy2) WithBufferImageHeight(y uint32) BufferImageCopy2 {
	x.bufferImageHeight = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// ImageSubresource returns the value of imageSubresource from VkBufferImageCopy2
func (x BufferImageCopy2) ImageSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.imageSubresource) 
	return *ptr
}

// WithImageSubresource sets the value for the ImageSubresource on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy2) WithImageSubresource(y ImageSubresourceLayers) BufferImageCopy2 {
	x.imageSubresource = *(/* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}

// ImageOffset returns the value of imageOffset from VkBufferImageCopy2
func (x BufferImageCopy2) ImageOffset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.imageOffset) 
	return *ptr
}

// WithImageOffset sets the value for the ImageOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy2) WithImageOffset(y Offset3D) BufferImageCopy2 {
	x.imageOffset = *(/* typedef */ (*C.struct_VkOffset3D)(&y))
	return x
}

// ImageExtent returns the value of imageExtent from VkBufferImageCopy2
func (x BufferImageCopy2) ImageExtent() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.imageExtent) 
	return *ptr
}

// WithImageExtent sets the value for the ImageExtent on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BufferImageCopy2) WithImageExtent(y Extent3D) BufferImageCopy2 {
	x.imageExtent = *(/* typedef */ (*C.struct_VkExtent3D)(&y))
	return x
}

// ImageResolve2 provides a go interface for VkImageResolve2.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageResolve2.html
type ImageResolve2 C.struct_VkImageResolve2

// SizeofImageResolve2 is the memory size of a ImageResolve2
var SizeofImageResolve2 int = int(unsafe.Sizeof(ImageResolve2{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageResolve2) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageResolve2) AsCPtr() *ImageResolve2 {
	clone := (*ImageResolve2)(newCBlock(C.ulong(SizeofImageResolve2)))
	*clone = x
	return clone
}

// ImageResolve2FreeCSlice releases the memory allocated by ImageResolve2MakeCSlice.
// It does not free pointers stored inside the slice.
func ImageResolve2FreeCSlice(x []ImageResolve2) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageResolve2MakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageResolve2FreeCSlice must be called on the returned slice.
func ImageResolve2MakeCSlice(x ...ImageResolve2) []ImageResolve2 {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageResolve2 * len(x)
	dst := unsafe.Slice((*ImageResolve2)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageResolve2
func (x ImageResolve2) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ImageResolve2) WithDefaultSType() ImageResolve2 {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve2) WithSType(y StructureType) ImageResolve2 {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkImageResolve2
func (x ImageResolve2) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve2) WithPNext(y unsafe.Pointer) ImageResolve2 {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SrcSubresource returns the value of srcSubresource from VkImageResolve2
func (x ImageResolve2) SrcSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.srcSubresource) 
	return *ptr
}

// WithSrcSubresource sets the value for the SrcSubresource on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve2) WithSrcSubresource(y ImageSubresourceLayers) ImageResolve2 {
	x.srcSubresource = *(/* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}

// SrcOffset returns the value of srcOffset from VkImageResolve2
func (x ImageResolve2) SrcOffset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.srcOffset) 
	return *ptr
}

// WithSrcOffset sets the value for the SrcOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve2) WithSrcOffset(y Offset3D) ImageResolve2 {
	x.srcOffset = *(/* typedef */ (*C.struct_VkOffset3D)(&y))
	return x
}

// DstSubresource returns the value of dstSubresource from VkImageResolve2
func (x ImageResolve2) DstSubresource() ImageSubresourceLayers {
	ptr := /* typedef */ (*ImageSubresourceLayers)(&x.dstSubresource) 
	return *ptr
}

// WithDstSubresource sets the value for the DstSubresource on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve2) WithDstSubresource(y ImageSubresourceLayers) ImageResolve2 {
	x.dstSubresource = *(/* typedef */ (*C.struct_VkImageSubresourceLayers)(&y))
	return x
}

// DstOffset returns the value of dstOffset from VkImageResolve2
func (x ImageResolve2) DstOffset() Offset3D {
	ptr := /* typedef */ (*Offset3D)(&x.dstOffset) 
	return *ptr
}

// WithDstOffset sets the value for the DstOffset on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve2) WithDstOffset(y Offset3D) ImageResolve2 {
	x.dstOffset = *(/* typedef */ (*C.struct_VkOffset3D)(&y))
	return x
}

// Extent returns the value of extent from VkImageResolve2
func (x ImageResolve2) Extent() Extent3D {
	ptr := /* typedef */ (*Extent3D)(&x.extent) 
	return *ptr
}

// WithExtent sets the value for the Extent on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageResolve2) WithExtent(y Extent3D) ImageResolve2 {
	x.extent = *(/* typedef */ (*C.struct_VkExtent3D)(&y))
	return x
}

// PhysicalDeviceSubgroupSizeControlFeatures provides a go interface for VkPhysicalDeviceSubgroupSizeControlFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubgroupSizeControlFeatures.html
type PhysicalDeviceSubgroupSizeControlFeatures C.struct_VkPhysicalDeviceSubgroupSizeControlFeatures

// SizeofPhysicalDeviceSubgroupSizeControlFeatures is the memory size of a PhysicalDeviceSubgroupSizeControlFeatures
var SizeofPhysicalDeviceSubgroupSizeControlFeatures int = int(unsafe.Sizeof(PhysicalDeviceSubgroupSizeControlFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceSubgroupSizeControlFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceSubgroupSizeControlFeatures) AsCPtr() *PhysicalDeviceSubgroupSizeControlFeatures {
	clone := (*PhysicalDeviceSubgroupSizeControlFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceSubgroupSizeControlFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceSubgroupSizeControlFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceSubgroupSizeControlFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceSubgroupSizeControlFeaturesFreeCSlice(x []PhysicalDeviceSubgroupSizeControlFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceSubgroupSizeControlFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceSubgroupSizeControlFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceSubgroupSizeControlFeaturesMakeCSlice(x ...PhysicalDeviceSubgroupSizeControlFeatures) []PhysicalDeviceSubgroupSizeControlFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSubgroupSizeControlFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceSubgroupSizeControlFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceSubgroupSizeControlFeatures
func (x PhysicalDeviceSubgroupSizeControlFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceSubgroupSizeControlFeatures) WithDefaultSType() PhysicalDeviceSubgroupSizeControlFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSubgroupSizeControlFeatures) WithSType(y StructureType) PhysicalDeviceSubgroupSizeControlFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceSubgroupSizeControlFeatures
func (x PhysicalDeviceSubgroupSizeControlFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSubgroupSizeControlFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceSubgroupSizeControlFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SubgroupSizeControl returns the value of subgroupSizeControl from VkPhysicalDeviceSubgroupSizeControlFeatures
func (x PhysicalDeviceSubgroupSizeControlFeatures) SubgroupSizeControl() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.subgroupSizeControl) 
	return *ptr
}

// WithSubgroupSizeControl sets the value for the SubgroupSizeControl on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSubgroupSizeControlFeatures) WithSubgroupSizeControl(y Bool32) PhysicalDeviceSubgroupSizeControlFeatures {
	x.subgroupSizeControl = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ComputeFullSubgroups returns the value of computeFullSubgroups from VkPhysicalDeviceSubgroupSizeControlFeatures
func (x PhysicalDeviceSubgroupSizeControlFeatures) ComputeFullSubgroups() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.computeFullSubgroups) 
	return *ptr
}

// WithComputeFullSubgroups sets the value for the ComputeFullSubgroups on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSubgroupSizeControlFeatures) WithComputeFullSubgroups(y Bool32) PhysicalDeviceSubgroupSizeControlFeatures {
	x.computeFullSubgroups = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// PhysicalDeviceSubgroupSizeControlProperties provides a go interface for VkPhysicalDeviceSubgroupSizeControlProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubgroupSizeControlProperties.html
type PhysicalDeviceSubgroupSizeControlProperties C.struct_VkPhysicalDeviceSubgroupSizeControlProperties

// SizeofPhysicalDeviceSubgroupSizeControlProperties is the memory size of a PhysicalDeviceSubgroupSizeControlProperties
var SizeofPhysicalDeviceSubgroupSizeControlProperties int = int(unsafe.Sizeof(PhysicalDeviceSubgroupSizeControlProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceSubgroupSizeControlProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceSubgroupSizeControlProperties) AsCPtr() *PhysicalDeviceSubgroupSizeControlProperties {
	clone := (*PhysicalDeviceSubgroupSizeControlProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceSubgroupSizeControlProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceSubgroupSizeControlPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceSubgroupSizeControlPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceSubgroupSizeControlPropertiesFreeCSlice(x []PhysicalDeviceSubgroupSizeControlProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceSubgroupSizeControlPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceSubgroupSizeControlPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceSubgroupSizeControlPropertiesMakeCSlice(x ...PhysicalDeviceSubgroupSizeControlProperties) []PhysicalDeviceSubgroupSizeControlProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSubgroupSizeControlProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceSubgroupSizeControlProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceSubgroupSizeControlProperties
func (x PhysicalDeviceSubgroupSizeControlProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceSubgroupSizeControlProperties) WithDefaultSType() PhysicalDeviceSubgroupSizeControlProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSubgroupSizeControlProperties) WithSType(y StructureType) PhysicalDeviceSubgroupSizeControlProperties {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceSubgroupSizeControlProperties
func (x PhysicalDeviceSubgroupSizeControlProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSubgroupSizeControlProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceSubgroupSizeControlProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// MinSubgroupSize returns the value of minSubgroupSize from VkPhysicalDeviceSubgroupSizeControlProperties
func (x PhysicalDeviceSubgroupSizeControlProperties) MinSubgroupSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.minSubgroupSize) 
	return *ptr
}

// MaxSubgroupSize returns the value of maxSubgroupSize from VkPhysicalDeviceSubgroupSizeControlProperties
func (x PhysicalDeviceSubgroupSizeControlProperties) MaxSubgroupSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxSubgroupSize) 
	return *ptr
}

// MaxComputeWorkgroupSubgroups returns the value of maxComputeWorkgroupSubgroups from VkPhysicalDeviceSubgroupSizeControlProperties
func (x PhysicalDeviceSubgroupSizeControlProperties) MaxComputeWorkgroupSubgroups() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxComputeWorkgroupSubgroups) 
	return *ptr
}

// RequiredSubgroupSizeStages returns the value of requiredSubgroupSizeStages from VkPhysicalDeviceSubgroupSizeControlProperties
func (x PhysicalDeviceSubgroupSizeControlProperties) RequiredSubgroupSizeStages() ShaderStageFlags {
	ptr := /* typedef */ (*ShaderStageFlags)(&x.requiredSubgroupSizeStages) 
	return *ptr
}

// PipelineShaderStageRequiredSubgroupSizeCreateInfo provides a go interface for VkPipelineShaderStageRequiredSubgroupSizeCreateInfo.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPipelineShaderStageRequiredSubgroupSizeCreateInfo.html
type PipelineShaderStageRequiredSubgroupSizeCreateInfo C.struct_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo

// SizeofPipelineShaderStageRequiredSubgroupSizeCreateInfo is the memory size of a PipelineShaderStageRequiredSubgroupSizeCreateInfo
var SizeofPipelineShaderStageRequiredSubgroupSizeCreateInfo int = int(unsafe.Sizeof(PipelineShaderStageRequiredSubgroupSizeCreateInfo{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PipelineShaderStageRequiredSubgroupSizeCreateInfo) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PipelineShaderStageRequiredSubgroupSizeCreateInfo) AsCPtr() *PipelineShaderStageRequiredSubgroupSizeCreateInfo {
	clone := (*PipelineShaderStageRequiredSubgroupSizeCreateInfo)(newCBlock(C.ulong(SizeofPipelineShaderStageRequiredSubgroupSizeCreateInfo)))
	*clone = x
	return clone
}

// PipelineShaderStageRequiredSubgroupSizeCreateInfoFreeCSlice releases the memory allocated by PipelineShaderStageRequiredSubgroupSizeCreateInfoMakeCSlice.
// It does not free pointers stored inside the slice.
func PipelineShaderStageRequiredSubgroupSizeCreateInfoFreeCSlice(x []PipelineShaderStageRequiredSubgroupSizeCreateInfo) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PipelineShaderStageRequiredSubgroupSizeCreateInfoMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PipelineShaderStageRequiredSubgroupSizeCreateInfoFreeCSlice must be called on the returned slice.
func PipelineShaderStageRequiredSubgroupSizeCreateInfoMakeCSlice(x ...PipelineShaderStageRequiredSubgroupSizeCreateInfo) []PipelineShaderStageRequiredSubgroupSizeCreateInfo {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPipelineShaderStageRequiredSubgroupSizeCreateInfo * len(x)
	dst := unsafe.Slice((*PipelineShaderStageRequiredSubgroupSizeCreateInfo)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPipelineShaderStageRequiredSubgroupSizeCreateInfo
func (x PipelineShaderStageRequiredSubgroupSizeCreateInfo) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PipelineShaderStageRequiredSubgroupSizeCreateInfo) WithDefaultSType() PipelineShaderStageRequiredSubgroupSizeCreateInfo {
	return x.WithSType(VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineShaderStageRequiredSubgroupSizeCreateInfo) WithSType(y StructureType) PipelineShaderStageRequiredSubgroupSizeCreateInfo {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPipelineShaderStageRequiredSubgroupSizeCreateInfo
func (x PipelineShaderStageRequiredSubgroupSizeCreateInfo) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PipelineShaderStageRequiredSubgroupSizeCreateInfo) WithPNext(y unsafe.Pointer) PipelineShaderStageRequiredSubgroupSizeCreateInfo {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// RequiredSubgroupSize returns the value of requiredSubgroupSize from VkPipelineShaderStageRequiredSubgroupSizeCreateInfo
func (x PipelineShaderStageRequiredSubgroupSizeCreateInfo) RequiredSubgroupSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.requiredSubgroupSize) 
	return *ptr
}

// PhysicalDeviceInlineUniformBlockFeatures provides a go interface for VkPhysicalDeviceInlineUniformBlockFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceInlineUniformBlockFeatures.html
type PhysicalDeviceInlineUniformBlockFeatures C.struct_VkPhysicalDeviceInlineUniformBlockFeatures

// SizeofPhysicalDeviceInlineUniformBlockFeatures is the memory size of a PhysicalDeviceInlineUniformBlockFeatures
var SizeofPhysicalDeviceInlineUniformBlockFeatures int = int(unsafe.Sizeof(PhysicalDeviceInlineUniformBlockFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceInlineUniformBlockFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceInlineUniformBlockFeatures) AsCPtr() *PhysicalDeviceInlineUniformBlockFeatures {
	clone := (*PhysicalDeviceInlineUniformBlockFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceInlineUniformBlockFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceInlineUniformBlockFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceInlineUniformBlockFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceInlineUniformBlockFeaturesFreeCSlice(x []PhysicalDeviceInlineUniformBlockFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceInlineUniformBlockFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceInlineUniformBlockFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceInlineUniformBlockFeaturesMakeCSlice(x ...PhysicalDeviceInlineUniformBlockFeatures) []PhysicalDeviceInlineUniformBlockFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceInlineUniformBlockFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceInlineUniformBlockFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceInlineUniformBlockFeatures
func (x PhysicalDeviceInlineUniformBlockFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceInlineUniformBlockFeatures) WithDefaultSType() PhysicalDeviceInlineUniformBlockFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceInlineUniformBlockFeatures) WithSType(y StructureType) PhysicalDeviceInlineUniformBlockFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceInlineUniformBlockFeatures
func (x PhysicalDeviceInlineUniformBlockFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceInlineUniformBlockFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceInlineUniformBlockFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// InlineUniformBlock returns the value of inlineUniformBlock from VkPhysicalDeviceInlineUniformBlockFeatures
func (x PhysicalDeviceInlineUniformBlockFeatures) InlineUniformBlock() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.inlineUniformBlock) 
	return *ptr
}

// WithInlineUniformBlock sets the value for the InlineUniformBlock on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceInlineUniformBlockFeatures) WithInlineUniformBlock(y Bool32) PhysicalDeviceInlineUniformBlockFeatures {
	x.inlineUniformBlock = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DescriptorBindingInlineUniformBlockUpdateAfterBind returns the value of descriptorBindingInlineUniformBlockUpdateAfterBind from VkPhysicalDeviceInlineUniformBlockFeatures
func (x PhysicalDeviceInlineUniformBlockFeatures) DescriptorBindingInlineUniformBlockUpdateAfterBind() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.descriptorBindingInlineUniformBlockUpdateAfterBind) 
	return *ptr
}

// WithDescriptorBindingInlineUniformBlockUpdateAfterBind sets the value for the DescriptorBindingInlineUniformBlockUpdateAfterBind on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceInlineUniformBlockFeatures) WithDescriptorBindingInlineUniformBlockUpdateAfterBind(y Bool32) PhysicalDeviceInlineUniformBlockFeatures {
	x.descriptorBindingInlineUniformBlockUpdateAfterBind = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// PhysicalDeviceInlineUniformBlockProperties provides a go interface for VkPhysicalDeviceInlineUniformBlockProperties.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceInlineUniformBlockProperties.html
type PhysicalDeviceInlineUniformBlockProperties C.struct_VkPhysicalDeviceInlineUniformBlockProperties

// SizeofPhysicalDeviceInlineUniformBlockProperties is the memory size of a PhysicalDeviceInlineUniformBlockProperties
var SizeofPhysicalDeviceInlineUniformBlockProperties int = int(unsafe.Sizeof(PhysicalDeviceInlineUniformBlockProperties{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceInlineUniformBlockProperties) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceInlineUniformBlockProperties) AsCPtr() *PhysicalDeviceInlineUniformBlockProperties {
	clone := (*PhysicalDeviceInlineUniformBlockProperties)(newCBlock(C.ulong(SizeofPhysicalDeviceInlineUniformBlockProperties)))
	*clone = x
	return clone
}

// PhysicalDeviceInlineUniformBlockPropertiesFreeCSlice releases the memory allocated by PhysicalDeviceInlineUniformBlockPropertiesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceInlineUniformBlockPropertiesFreeCSlice(x []PhysicalDeviceInlineUniformBlockProperties) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceInlineUniformBlockPropertiesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceInlineUniformBlockPropertiesFreeCSlice must be called on the returned slice.
func PhysicalDeviceInlineUniformBlockPropertiesMakeCSlice(x ...PhysicalDeviceInlineUniformBlockProperties) []PhysicalDeviceInlineUniformBlockProperties {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceInlineUniformBlockProperties * len(x)
	dst := unsafe.Slice((*PhysicalDeviceInlineUniformBlockProperties)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceInlineUniformBlockProperties
func (x PhysicalDeviceInlineUniformBlockProperties) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceInlineUniformBlockProperties) WithDefaultSType() PhysicalDeviceInlineUniformBlockProperties {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceInlineUniformBlockProperties) WithSType(y StructureType) PhysicalDeviceInlineUniformBlockProperties {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceInlineUniformBlockProperties
func (x PhysicalDeviceInlineUniformBlockProperties) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceInlineUniformBlockProperties) WithPNext(y unsafe.Pointer) PhysicalDeviceInlineUniformBlockProperties {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// MaxInlineUniformBlockSize returns the value of maxInlineUniformBlockSize from VkPhysicalDeviceInlineUniformBlockProperties
func (x PhysicalDeviceInlineUniformBlockProperties) MaxInlineUniformBlockSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxInlineUniformBlockSize) 
	return *ptr
}

// MaxPerStageDescriptorInlineUniformBlocks returns the value of maxPerStageDescriptorInlineUniformBlocks from VkPhysicalDeviceInlineUniformBlockProperties
func (x PhysicalDeviceInlineUniformBlockProperties) MaxPerStageDescriptorInlineUniformBlocks() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorInlineUniformBlocks) 
	return *ptr
}

// MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks returns the value of maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks from VkPhysicalDeviceInlineUniformBlockProperties
func (x PhysicalDeviceInlineUniformBlockProperties) MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks) 
	return *ptr
}

// MaxDescriptorSetInlineUniformBlocks returns the value of maxDescriptorSetInlineUniformBlocks from VkPhysicalDeviceInlineUniformBlockProperties
func (x PhysicalDeviceInlineUniformBlockProperties) MaxDescriptorSetInlineUniformBlocks() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetInlineUniformBlocks) 
	return *ptr
}

// MaxDescriptorSetUpdateAfterBindInlineUniformBlocks returns the value of maxDescriptorSetUpdateAfterBindInlineUniformBlocks from VkPhysicalDeviceInlineUniformBlockProperties
func (x PhysicalDeviceInlineUniformBlockProperties) MaxDescriptorSetUpdateAfterBindInlineUniformBlocks() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxDescriptorSetUpdateAfterBindInlineUniformBlocks) 
	return *ptr
}

// WriteDescriptorSetInlineUniformBlock provides a go interface for VkWriteDescriptorSetInlineUniformBlock.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkWriteDescriptorSetInlineUniformBlock.html
type WriteDescriptorSetInlineUniformBlock C.struct_VkWriteDescriptorSetInlineUniformBlock

// SizeofWriteDescriptorSetInlineUniformBlock is the memory size of a WriteDescriptorSetInlineUniformBlock
var SizeofWriteDescriptorSetInlineUniformBlock int = int(unsafe.Sizeof(WriteDescriptorSetInlineUniformBlock{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *WriteDescriptorSetInlineUniformBlock) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x WriteDescriptorSetInlineUniformBlock) AsCPtr() *WriteDescriptorSetInlineUniformBlock {
	clone := (*WriteDescriptorSetInlineUniformBlock)(newCBlock(C.ulong(SizeofWriteDescriptorSetInlineUniformBlock)))
	*clone = x
	return clone
}

// WriteDescriptorSetInlineUniformBlockFreeCSlice releases the memory allocated by WriteDescriptorSetInlineUniformBlockMakeCSlice.
// It does not free pointers stored inside the slice.
func WriteDescriptorSetInlineUniformBlockFreeCSlice(x []WriteDescriptorSetInlineUniformBlock) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// WriteDescriptorSetInlineUniformBlockMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. WriteDescriptorSetInlineUniformBlockFreeCSlice must be called on the returned slice.
func WriteDescriptorSetInlineUniformBlockMakeCSlice(x ...WriteDescriptorSetInlineUniformBlock) []WriteDescriptorSetInlineUniformBlock {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofWriteDescriptorSetInlineUniformBlock * len(x)
	dst := unsafe.Slice((*WriteDescriptorSetInlineUniformBlock)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkWriteDescriptorSetInlineUniformBlock
func (x WriteDescriptorSetInlineUniformBlock) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x WriteDescriptorSetInlineUniformBlock) WithDefaultSType() WriteDescriptorSetInlineUniformBlock {
	return x.WithSType(VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSetInlineUniformBlock) WithSType(y StructureType) WriteDescriptorSetInlineUniformBlock {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkWriteDescriptorSetInlineUniformBlock
func (x WriteDescriptorSetInlineUniformBlock) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSetInlineUniformBlock) WithPNext(y unsafe.Pointer) WriteDescriptorSetInlineUniformBlock {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// DataSize returns the value of dataSize from VkWriteDescriptorSetInlineUniformBlock
func (x WriteDescriptorSetInlineUniformBlock) DataSize() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.dataSize) 
	return *ptr
}

// WithDataSize sets the value for the DataSize on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSetInlineUniformBlock) WithDataSize(y uint32) WriteDescriptorSetInlineUniformBlock {
	x.dataSize = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PData returns the value of pData from VkWriteDescriptorSetInlineUniformBlock
func (x WriteDescriptorSetInlineUniformBlock) PData() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pData) 
	return *ptr
}

// WithPData sets the value for the PData on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x WriteDescriptorSetInlineUniformBlock) WithPData(y unsafe.Pointer) WriteDescriptorSetInlineUniformBlock {
	x.pData = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// PhysicalDeviceShaderDemoteToHelperInvocationFeatures provides a go interface for VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures.html
type PhysicalDeviceShaderDemoteToHelperInvocationFeatures C.struct_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures

// SizeofPhysicalDeviceShaderDemoteToHelperInvocationFeatures is the memory size of a PhysicalDeviceShaderDemoteToHelperInvocationFeatures
var SizeofPhysicalDeviceShaderDemoteToHelperInvocationFeatures int = int(unsafe.Sizeof(PhysicalDeviceShaderDemoteToHelperInvocationFeatures{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceShaderDemoteToHelperInvocationFeatures) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceShaderDemoteToHelperInvocationFeatures) AsCPtr() *PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
	clone := (*PhysicalDeviceShaderDemoteToHelperInvocationFeatures)(newCBlock(C.ulong(SizeofPhysicalDeviceShaderDemoteToHelperInvocationFeatures)))
	*clone = x
	return clone
}

// PhysicalDeviceShaderDemoteToHelperInvocationFeaturesFreeCSlice releases the memory allocated by PhysicalDeviceShaderDemoteToHelperInvocationFeaturesMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceShaderDemoteToHelperInvocationFeaturesFreeCSlice(x []PhysicalDeviceShaderDemoteToHelperInvocationFeatures) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceShaderDemoteToHelperInvocationFeaturesMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceShaderDemoteToHelperInvocationFeaturesFreeCSlice must be called on the returned slice.
func PhysicalDeviceShaderDemoteToHelperInvocationFeaturesMakeCSlice(x ...PhysicalDeviceShaderDemoteToHelperInvocationFeatures) []PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceShaderDemoteToHelperInvocationFeatures * len(x)
	dst := unsafe.Slice((*PhysicalDeviceShaderDemoteToHelperInvocationFeatures)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures
func (x PhysicalDeviceShaderDemoteToHelperInvocationFeatures) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceShaderDemoteToHelperInvocationFeatures) WithDefaultSType() PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderDemoteToHelperInvocationFeatures) WithSType(y StructureType) PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures
func (x PhysicalDeviceShaderDemoteToHelperInvocationFeatures) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderDemoteToHelperInvocationFeatures) WithPNext(y unsafe.Pointer) PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// ShaderDemoteToHelperInvocation returns the value of shaderDemoteToHelperInvocation from VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures
func (x PhysicalDeviceShaderDemoteToHelperInvocationFeatures) ShaderDemoteToHelperInvocation() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderDemoteToHelperInvocation) 
	return *ptr
}

// WithShaderDemoteToHelperInvocation sets the value for the ShaderDemoteToHelperInvocation on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceShaderDemoteToHelperInvocationFeatures) WithShaderDemoteToHelperInvocation(y Bool32) PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
	x.shaderDemoteToHelperInvocation = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// DeviceImageMemoryRequirements provides a go interface for VkDeviceImageMemoryRequirements.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceImageMemoryRequirements.html
type DeviceImageMemoryRequirements C.struct_VkDeviceImageMemoryRequirements

// SizeofDeviceImageMemoryRequirements is the memory size of a DeviceImageMemoryRequirements
var SizeofDeviceImageMemoryRequirements int = int(unsafe.Sizeof(DeviceImageMemoryRequirements{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceImageMemoryRequirements) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceImageMemoryRequirements) AsCPtr() *DeviceImageMemoryRequirements {
	clone := (*DeviceImageMemoryRequirements)(newCBlock(C.ulong(SizeofDeviceImageMemoryRequirements)))
	*clone = x
	return clone
}

// DeviceImageMemoryRequirementsFreeCSlice releases the memory allocated by DeviceImageMemoryRequirementsMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceImageMemoryRequirementsFreeCSlice(x []DeviceImageMemoryRequirements) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceImageMemoryRequirementsMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceImageMemoryRequirementsFreeCSlice must be called on the returned slice.
func DeviceImageMemoryRequirementsMakeCSlice(x ...DeviceImageMemoryRequirements) []DeviceImageMemoryRequirements {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceImageMemoryRequirements * len(x)
	dst := unsafe.Slice((*DeviceImageMemoryRequirements)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceImageMemoryRequirements
func (x DeviceImageMemoryRequirements) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DeviceImageMemoryRequirements) WithDefaultSType() DeviceImageMemoryRequirements {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceImageMemoryRequirements) WithSType(y StructureType) DeviceImageMemoryRequirements {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDeviceImageMemoryRequirements
func (x DeviceImageMemoryRequirements) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceImageMemoryRequirements) WithPNext(y unsafe.Pointer) DeviceImageMemoryRequirements {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// PCreateInfo returns the value of pCreateInfo from VkDeviceImageMemoryRequirements
func (x DeviceImageMemoryRequirements) PCreateInfo() *ImageCreateInfo {
	ptr := func(x **C.struct_VkImageCreateInfo) **ImageCreateInfo { /* Pointer */ c2g := (*ImageCreateInfo)(*x); return &c2g }(&x.pCreateInfo) 
	return *ptr
}

// WithPCreateInfo sets the value for the PCreateInfo on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceImageMemoryRequirements) WithPCreateInfo(y *ImageCreateInfo) DeviceImageMemoryRequirements {
	x.pCreateInfo = *(func(x **ImageCreateInfo) **C.struct_VkImageCreateInfo { /* Pointer */ g2c := (*C.struct_VkImageCreateInfo)(*x); return &g2c }(&y))
	return x
}

// PlaneAspect returns the value of planeAspect from VkDeviceImageMemoryRequirements
func (x DeviceImageMemoryRequirements) PlaneAspect() ImageAspectFlagBits {
	ptr := /* typedef */ (*ImageAspectFlagBits)(&x.planeAspect) 
	return *ptr
}

// WithPlaneAspect sets the value for the PlaneAspect on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceImageMemoryRequirements) WithPlaneAspect(y ImageAspectFlagBits) DeviceImageMemoryRequirements {
	x.planeAspect = *(/* typedef */ (*C.VkImageAspectFlagBits)(&y))
	return x
}

// CmdSetDepthBoundsTestEnable command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBoundsTestEnable.html
func (x CommandBufferFacade)CmdSetDepthBoundsTestEnable(depthBoundsTestEnable Bool32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkBool32)(&depthBoundsTestEnable)
	C.vkCmdSetDepthBoundsTestEnable(addrs, *p0, *p1)
	}

// CmdEndRendering command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndRendering.html
func (x CommandBufferFacade)CmdEndRendering() {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	C.vkCmdEndRendering(addrs, *p0)
	}

// CmdBlitImage2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBlitImage2.html
func (x CommandBufferFacade)CmdBlitImage2(pBlitImageInfo *BlitImageInfo2, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **BlitImageInfo2) **C.struct_VkBlitImageInfo2 { /* Pointer */ g2c := (*C.struct_VkBlitImageInfo2)(*x); return &g2c }(&pBlitImageInfo)
	C.vkCmdBlitImage2(addrs, *p0, *p1)
	}

// CmdCopyImageToBuffer2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImageToBuffer2.html
func (x CommandBufferFacade)CmdCopyImageToBuffer2(pCopyImageToBufferInfo *CopyImageToBufferInfo2, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **CopyImageToBufferInfo2) **C.struct_VkCopyImageToBufferInfo2 { /* Pointer */ g2c := (*C.struct_VkCopyImageToBufferInfo2)(*x); return &g2c }(&pCopyImageToBufferInfo)
	C.vkCmdCopyImageToBuffer2(addrs, *p0, *p1)
	}

// CmdCopyBufferToImage2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBufferToImage2.html
func (x CommandBufferFacade)CmdCopyBufferToImage2(pCopyBufferToImageInfo *CopyBufferToImageInfo2, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **CopyBufferToImageInfo2) **C.struct_VkCopyBufferToImageInfo2 { /* Pointer */ g2c := (*C.struct_VkCopyBufferToImageInfo2)(*x); return &g2c }(&pCopyBufferToImageInfo)
	C.vkCmdCopyBufferToImage2(addrs, *p0, *p1)
	}

// CmdCopyImage2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImage2.html
func (x CommandBufferFacade)CmdCopyImage2(pCopyImageInfo *CopyImageInfo2, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **CopyImageInfo2) **C.struct_VkCopyImageInfo2 { /* Pointer */ g2c := (*C.struct_VkCopyImageInfo2)(*x); return &g2c }(&pCopyImageInfo)
	C.vkCmdCopyImage2(addrs, *p0, *p1)
	}

// CmdCopyBuffer2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBuffer2.html
func (x CommandBufferFacade)CmdCopyBuffer2(pCopyBufferInfo *CopyBufferInfo2, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **CopyBufferInfo2) **C.struct_VkCopyBufferInfo2 { /* Pointer */ g2c := (*C.struct_VkCopyBufferInfo2)(*x); return &g2c }(&pCopyBufferInfo)
	C.vkCmdCopyBuffer2(addrs, *p0, *p1)
	}

// QueueSubmit2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueSubmit2.html
func (x QueueFacade)QueueSubmit2(submitCount uint32, pSubmits []SubmitInfo2, fence Fence, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkQueue)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&submitCount)
	p2 := func(x *[]SubmitInfo2) **C.struct_VkSubmitInfo2 { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkSubmitInfo2)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkSubmitInfo2)(unsafe.Pointer((&ptr))) }(&pSubmits)
	p3 := /* handle */ (*C.VkFence)(&fence)
	ret := C.vkQueueSubmit2(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CmdWriteTimestamp2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteTimestamp2.html
func (x CommandBufferFacade)CmdWriteTimestamp2(stage PipelineStageFlags2, queryPool QueryPool, query uint32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkPipelineStageFlags2)(&stage)
	p2 := /* handle */ (*C.VkQueryPool)(&queryPool)
	p3 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&query)
	C.vkCmdWriteTimestamp2(addrs, *p0, *p1, *p2, *p3)
	}

// CmdSetCullMode command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCullMode.html
func (x CommandBufferFacade)CmdSetCullMode(cullMode CullModeFlags, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkCullModeFlags)(&cullMode)
	C.vkCmdSetCullMode(addrs, *p0, *p1)
	}

// CmdSetFrontFace command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetFrontFace.html
func (x CommandBufferFacade)CmdSetFrontFace(frontFace FrontFace, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkFrontFace)(&frontFace)
	C.vkCmdSetFrontFace(addrs, *p0, *p1)
	}

// CmdSetPrimitiveTopology command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPrimitiveTopology.html
func (x CommandBufferFacade)CmdSetPrimitiveTopology(primitiveTopology PrimitiveTopology, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkPrimitiveTopology)(&primitiveTopology)
	C.vkCmdSetPrimitiveTopology(addrs, *p0, *p1)
	}

// CmdSetViewportWithCount command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportWithCount.html
func (x CommandBufferFacade)CmdSetViewportWithCount(viewportCount uint32, pViewports []Viewport, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&viewportCount)
	p2 := func(x *[]Viewport) **C.struct_VkViewport { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkViewport)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkViewport)(unsafe.Pointer((&ptr))) }(&pViewports)
	C.vkCmdSetViewportWithCount(addrs, *p0, *p1, *p2)
	}

// CmdSetScissorWithCount command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetScissorWithCount.html
func (x CommandBufferFacade)CmdSetScissorWithCount(scissorCount uint32, pScissors []Rect2D, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&scissorCount)
	p2 := func(x *[]Rect2D) **C.struct_VkRect2D { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkRect2D)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkRect2D)(unsafe.Pointer((&ptr))) }(&pScissors)
	C.vkCmdSetScissorWithCount(addrs, *p0, *p1, *p2)
	}

// CmdBindVertexBuffers2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindVertexBuffers2.html
func (x CommandBufferFacade)CmdBindVertexBuffers2(firstBinding uint32, bindingCount uint32, pBuffers []Buffer, pOffsets []DeviceSize, pSizes []DeviceSize, pStrides []DeviceSize, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&firstBinding)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&bindingCount)
	p3 := func(x *[]Buffer) **C.VkBuffer { /* Slice */ if len(*x) > 0 { slc := (*C.VkBuffer)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkBuffer)(unsafe.Pointer((&ptr))) }(&pBuffers)
	p4 := func(x *[]DeviceSize) **C.VkDeviceSize { /* Slice */ if len(*x) > 0 { slc := (*C.VkDeviceSize)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkDeviceSize)(unsafe.Pointer((&ptr))) }(&pOffsets)
	p5 := func(x *[]DeviceSize) **C.VkDeviceSize { /* Slice */ if len(*x) > 0 { slc := (*C.VkDeviceSize)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkDeviceSize)(unsafe.Pointer((&ptr))) }(&pSizes)
	p6 := func(x *[]DeviceSize) **C.VkDeviceSize { /* Slice */ if len(*x) > 0 { slc := (*C.VkDeviceSize)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkDeviceSize)(unsafe.Pointer((&ptr))) }(&pStrides)
	C.vkCmdBindVertexBuffers2(addrs, *p0, *p1, *p2, *p3, *p4, *p5, *p6)
	}

// CmdSetDepthTestEnable command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthTestEnable.html
func (x CommandBufferFacade)CmdSetDepthTestEnable(depthTestEnable Bool32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkBool32)(&depthTestEnable)
	C.vkCmdSetDepthTestEnable(addrs, *p0, *p1)
	}

// CmdSetDepthWriteEnable command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthWriteEnable.html
func (x CommandBufferFacade)CmdSetDepthWriteEnable(depthWriteEnable Bool32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkBool32)(&depthWriteEnable)
	C.vkCmdSetDepthWriteEnable(addrs, *p0, *p1)
	}

// CmdSetDepthCompareOp command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthCompareOp.html
func (x CommandBufferFacade)CmdSetDepthCompareOp(depthCompareOp CompareOp, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkCompareOp)(&depthCompareOp)
	C.vkCmdSetDepthCompareOp(addrs, *p0, *p1)
	}

// CmdBeginRendering command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRendering.html
func (x CommandBufferFacade)CmdBeginRendering(pRenderingInfo *RenderingInfo, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **RenderingInfo) **C.struct_VkRenderingInfo { /* Pointer */ g2c := (*C.struct_VkRenderingInfo)(*x); return &g2c }(&pRenderingInfo)
	C.vkCmdBeginRendering(addrs, *p0, *p1)
	}

// CmdSetStencilTestEnable command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilTestEnable.html
func (x CommandBufferFacade)CmdSetStencilTestEnable(stencilTestEnable Bool32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkBool32)(&stencilTestEnable)
	C.vkCmdSetStencilTestEnable(addrs, *p0, *p1)
	}

// CmdSetStencilOp command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilOp.html
func (x CommandBufferFacade)CmdSetStencilOp(faceMask StencilFaceFlags, failOp StencilOp, passOp StencilOp, depthFailOp StencilOp, compareOp CompareOp, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkStencilFaceFlags)(&faceMask)
	p2 := /* typedef */ (*C.VkStencilOp)(&failOp)
	p3 := /* typedef */ (*C.VkStencilOp)(&passOp)
	p4 := /* typedef */ (*C.VkStencilOp)(&depthFailOp)
	p5 := /* typedef */ (*C.VkCompareOp)(&compareOp)
	C.vkCmdSetStencilOp(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
	}

// CmdPipelineBarrier2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPipelineBarrier2.html
func (x CommandBufferFacade)CmdPipelineBarrier2(pDependencyInfo *DependencyInfo, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **DependencyInfo) **C.struct_VkDependencyInfo { /* Pointer */ g2c := (*C.struct_VkDependencyInfo)(*x); return &g2c }(&pDependencyInfo)
	C.vkCmdPipelineBarrier2(addrs, *p0, *p1)
	}

// CmdWaitEvents2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWaitEvents2.html
func (x CommandBufferFacade)CmdWaitEvents2(eventCount uint32, pEvents []Event, pDependencyInfos []DependencyInfo, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&eventCount)
	p2 := func(x *[]Event) **C.VkEvent { /* Slice */ if len(*x) > 0 { slc := (*C.VkEvent)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkEvent)(unsafe.Pointer((&ptr))) }(&pEvents)
	p3 := func(x *[]DependencyInfo) **C.struct_VkDependencyInfo { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkDependencyInfo)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkDependencyInfo)(unsafe.Pointer((&ptr))) }(&pDependencyInfos)
	C.vkCmdWaitEvents2(addrs, *p0, *p1, *p2, *p3)
	}

// CmdResetEvent2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResetEvent2.html
func (x CommandBufferFacade)CmdResetEvent2(event Event, stageMask PipelineStageFlags2, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkEvent)(&event)
	p2 := /* typedef */ (*C.VkPipelineStageFlags2)(&stageMask)
	C.vkCmdResetEvent2(addrs, *p0, *p1, *p2)
	}

// CmdSetEvent2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetEvent2.html
func (x CommandBufferFacade)CmdSetEvent2(event Event, pDependencyInfo *DependencyInfo, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* handle */ (*C.VkEvent)(&event)
	p2 := func(x **DependencyInfo) **C.struct_VkDependencyInfo { /* Pointer */ g2c := (*C.struct_VkDependencyInfo)(*x); return &g2c }(&pDependencyInfo)
	C.vkCmdSetEvent2(addrs, *p0, *p1, *p2)
	}

// GetPrivateData command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPrivateData.html
func (x DeviceFacade)GetPrivateData(objectType ObjectType, objectHandle uint64, privateDataSlot PrivateDataSlot, pData *uint64, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* typedef */ (*C.VkObjectType)(&objectType)
	p2 := func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&objectHandle)
	p3 := /* handle */ (*C.VkPrivateDataSlot)(&privateDataSlot)
	p4 := func(x **uint64) **C.uint64_t { /* Pointer */ g2c := (*C.uint64_t)(*x); return &g2c }(&pData)
	C.vkGetPrivateData(addrs, *p0, *p1, *p2, *p3, *p4)
	}

// SetPrivateData command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetPrivateData.html
func (x DeviceFacade)SetPrivateData(objectType ObjectType, objectHandle uint64, privateDataSlot PrivateDataSlot, data uint64, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* typedef */ (*C.VkObjectType)(&objectType)
	p2 := func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&objectHandle)
	p3 := /* handle */ (*C.VkPrivateDataSlot)(&privateDataSlot)
	p4 := func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&data)
	ret := C.vkSetPrivateData(addrs, *p0, *p1, *p2, *p3, *p4)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CmdSetRasterizerDiscardEnable command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRasterizerDiscardEnable.html
func (x CommandBufferFacade)CmdSetRasterizerDiscardEnable(rasterizerDiscardEnable Bool32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkBool32)(&rasterizerDiscardEnable)
	C.vkCmdSetRasterizerDiscardEnable(addrs, *p0, *p1)
	}

// CmdSetDepthBiasEnable command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBiasEnable.html
func (x CommandBufferFacade)CmdSetDepthBiasEnable(depthBiasEnable Bool32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkBool32)(&depthBiasEnable)
	C.vkCmdSetDepthBiasEnable(addrs, *p0, *p1)
	}

// CmdSetPrimitiveRestartEnable command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPrimitiveRestartEnable.html
func (x CommandBufferFacade)CmdSetPrimitiveRestartEnable(primitiveRestartEnable Bool32, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := /* typedef */ (*C.VkBool32)(&primitiveRestartEnable)
	C.vkCmdSetPrimitiveRestartEnable(addrs, *p0, *p1)
	}

// GetDeviceBufferMemoryRequirements command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceBufferMemoryRequirements.html
func (x DeviceFacade)GetDeviceBufferMemoryRequirements(pInfo *DeviceBufferMemoryRequirements, pMemoryRequirements *MemoryRequirements2, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DeviceBufferMemoryRequirements) **C.struct_VkDeviceBufferMemoryRequirements { /* Pointer */ g2c := (*C.struct_VkDeviceBufferMemoryRequirements)(*x); return &g2c }(&pInfo)
	p2 := func(x **MemoryRequirements2) **C.struct_VkMemoryRequirements2 { /* Pointer */ g2c := (*C.struct_VkMemoryRequirements2)(*x); return &g2c }(&pMemoryRequirements)
	C.vkGetDeviceBufferMemoryRequirements(addrs, *p0, *p1, *p2)
	}

// GetDeviceImageMemoryRequirements command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceImageMemoryRequirements.html
func (x DeviceFacade)GetDeviceImageMemoryRequirements(pInfo *DeviceImageMemoryRequirements, pMemoryRequirements *MemoryRequirements2, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DeviceImageMemoryRequirements) **C.struct_VkDeviceImageMemoryRequirements { /* Pointer */ g2c := (*C.struct_VkDeviceImageMemoryRequirements)(*x); return &g2c }(&pInfo)
	p2 := func(x **MemoryRequirements2) **C.struct_VkMemoryRequirements2 { /* Pointer */ g2c := (*C.struct_VkMemoryRequirements2)(*x); return &g2c }(&pMemoryRequirements)
	C.vkGetDeviceImageMemoryRequirements(addrs, *p0, *p1, *p2)
	}

// GetDeviceImageSparseMemoryRequirements command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceImageSparseMemoryRequirements.html
func (x DeviceFacade)GetDeviceImageSparseMemoryRequirements(pInfo *DeviceImageMemoryRequirements, pSparseMemoryRequirementCount *uint32, pSparseMemoryRequirements []SparseImageMemoryRequirements2, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DeviceImageMemoryRequirements) **C.struct_VkDeviceImageMemoryRequirements { /* Pointer */ g2c := (*C.struct_VkDeviceImageMemoryRequirements)(*x); return &g2c }(&pInfo)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pSparseMemoryRequirementCount)
	p3 := func(x *[]SparseImageMemoryRequirements2) **C.struct_VkSparseImageMemoryRequirements2 { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkSparseImageMemoryRequirements2)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkSparseImageMemoryRequirements2)(unsafe.Pointer((&ptr))) }(&pSparseMemoryRequirements)
	C.vkGetDeviceImageSparseMemoryRequirements(addrs, *p0, *p1, *p2, *p3)
	}

// DestroyPrivateDataSlot command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPrivateDataSlot.html
func (x DeviceFacade)DestroyPrivateDataSlot(privateDataSlot PrivateDataSlot, pAllocator *AllocationCallbacks, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkPrivateDataSlot)(&privateDataSlot)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	C.vkDestroyPrivateDataSlot(addrs, *p0, *p1, *p2)
	}

// CreatePrivateDataSlot command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreatePrivateDataSlot.html
func (x DeviceFacade)CreatePrivateDataSlot(pCreateInfo *PrivateDataSlotCreateInfo, pAllocator *AllocationCallbacks, pPrivateDataSlot *PrivateDataSlot, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **PrivateDataSlotCreateInfo) **C.struct_VkPrivateDataSlotCreateInfo { /* Pointer */ g2c := (*C.struct_VkPrivateDataSlotCreateInfo)(*x); return &g2c }(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p3 := func(x **PrivateDataSlot) **C.VkPrivateDataSlot { /* Pointer */ g2c := (*C.VkPrivateDataSlot)(*x); return &g2c }(&pPrivateDataSlot)
	ret := C.vkCreatePrivateDataSlot(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceToolProperties command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceToolProperties.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceToolProperties(pToolCount *uint32, pToolProperties []PhysicalDeviceToolProperties, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pToolCount)
	p2 := func(x *[]PhysicalDeviceToolProperties) **C.struct_VkPhysicalDeviceToolProperties { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkPhysicalDeviceToolProperties)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkPhysicalDeviceToolProperties)(unsafe.Pointer((&ptr))) }(&pToolProperties)
	ret := C.vkGetPhysicalDeviceToolProperties(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CmdResolveImage2 command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResolveImage2.html
func (x CommandBufferFacade)CmdResolveImage2(pResolveImageInfo *ResolveImageInfo2, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkCommandBuffer)(&x.H)
	p1 := func(x **ResolveImageInfo2) **C.struct_VkResolveImageInfo2 { /* Pointer */ g2c := (*C.struct_VkResolveImageInfo2)(*x); return &g2c }(&pResolveImageInfo)
	C.vkCmdResolveImage2(addrs, *p0, *p1)
	}

// SurfaceProtectedCapabilitiesKHR provides a go interface for VkSurfaceProtectedCapabilitiesKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceProtectedCapabilitiesKHR.html
type SurfaceProtectedCapabilitiesKHR C.struct_VkSurfaceProtectedCapabilitiesKHR

// SizeofSurfaceProtectedCapabilitiesKHR is the memory size of a SurfaceProtectedCapabilitiesKHR
var SizeofSurfaceProtectedCapabilitiesKHR int = int(unsafe.Sizeof(SurfaceProtectedCapabilitiesKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SurfaceProtectedCapabilitiesKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SurfaceProtectedCapabilitiesKHR) AsCPtr() *SurfaceProtectedCapabilitiesKHR {
	clone := (*SurfaceProtectedCapabilitiesKHR)(newCBlock(C.ulong(SizeofSurfaceProtectedCapabilitiesKHR)))
	*clone = x
	return clone
}

// SurfaceProtectedCapabilitiesKHRFreeCSlice releases the memory allocated by SurfaceProtectedCapabilitiesKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func SurfaceProtectedCapabilitiesKHRFreeCSlice(x []SurfaceProtectedCapabilitiesKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SurfaceProtectedCapabilitiesKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SurfaceProtectedCapabilitiesKHRFreeCSlice must be called on the returned slice.
func SurfaceProtectedCapabilitiesKHRMakeCSlice(x ...SurfaceProtectedCapabilitiesKHR) []SurfaceProtectedCapabilitiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSurfaceProtectedCapabilitiesKHR * len(x)
	dst := unsafe.Slice((*SurfaceProtectedCapabilitiesKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSurfaceProtectedCapabilitiesKHR
func (x SurfaceProtectedCapabilitiesKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SurfaceProtectedCapabilitiesKHR) WithDefaultSType() SurfaceProtectedCapabilitiesKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SurfaceProtectedCapabilitiesKHR) WithSType(y StructureType) SurfaceProtectedCapabilitiesKHR {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkSurfaceProtectedCapabilitiesKHR
func (x SurfaceProtectedCapabilitiesKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SurfaceProtectedCapabilitiesKHR) WithPNext(y unsafe.Pointer) SurfaceProtectedCapabilitiesKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SupportsProtected returns the value of supportsProtected from VkSurfaceProtectedCapabilitiesKHR
func (x SurfaceProtectedCapabilitiesKHR) SupportsProtected() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.supportsProtected) 
	return *ptr
}

// WithSupportsProtected sets the value for the SupportsProtected on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SurfaceProtectedCapabilitiesKHR) WithSupportsProtected(y Bool32) SurfaceProtectedCapabilitiesKHR {
	x.supportsProtected = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// SurfaceKHR is a Handle to a vulkan resource.
// SurfaceKHR is a child of Instance.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceKHR.html
type SurfaceKHR C.VkSurfaceKHR

// NullSurfaceKHR is a typed Null value for the SurfaceKHR type.
var NullSurfaceKHR SurfaceKHR


// PhysicalDeviceSurfaceInfo2KHR provides a go interface for VkPhysicalDeviceSurfaceInfo2KHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSurfaceInfo2KHR.html
type PhysicalDeviceSurfaceInfo2KHR C.struct_VkPhysicalDeviceSurfaceInfo2KHR

// SizeofPhysicalDeviceSurfaceInfo2KHR is the memory size of a PhysicalDeviceSurfaceInfo2KHR
var SizeofPhysicalDeviceSurfaceInfo2KHR int = int(unsafe.Sizeof(PhysicalDeviceSurfaceInfo2KHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDeviceSurfaceInfo2KHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDeviceSurfaceInfo2KHR) AsCPtr() *PhysicalDeviceSurfaceInfo2KHR {
	clone := (*PhysicalDeviceSurfaceInfo2KHR)(newCBlock(C.ulong(SizeofPhysicalDeviceSurfaceInfo2KHR)))
	*clone = x
	return clone
}

// PhysicalDeviceSurfaceInfo2KHRFreeCSlice releases the memory allocated by PhysicalDeviceSurfaceInfo2KHRMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDeviceSurfaceInfo2KHRFreeCSlice(x []PhysicalDeviceSurfaceInfo2KHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDeviceSurfaceInfo2KHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDeviceSurfaceInfo2KHRFreeCSlice must be called on the returned slice.
func PhysicalDeviceSurfaceInfo2KHRMakeCSlice(x ...PhysicalDeviceSurfaceInfo2KHR) []PhysicalDeviceSurfaceInfo2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDeviceSurfaceInfo2KHR * len(x)
	dst := unsafe.Slice((*PhysicalDeviceSurfaceInfo2KHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDeviceSurfaceInfo2KHR
func (x PhysicalDeviceSurfaceInfo2KHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDeviceSurfaceInfo2KHR) WithDefaultSType() PhysicalDeviceSurfaceInfo2KHR {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSurfaceInfo2KHR) WithSType(y StructureType) PhysicalDeviceSurfaceInfo2KHR {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDeviceSurfaceInfo2KHR
func (x PhysicalDeviceSurfaceInfo2KHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSurfaceInfo2KHR) WithPNext(y unsafe.Pointer) PhysicalDeviceSurfaceInfo2KHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Surface returns the value of surface from VkPhysicalDeviceSurfaceInfo2KHR
func (x PhysicalDeviceSurfaceInfo2KHR) Surface() SurfaceKHR {
	ptr := /* handle */ (*SurfaceKHR)(&x.surface) 
	return *ptr
}

// WithSurface sets the value for the Surface on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDeviceSurfaceInfo2KHR) WithSurface(y SurfaceKHR) PhysicalDeviceSurfaceInfo2KHR {
	x.surface = *(/* handle */ (*C.VkSurfaceKHR)(&y))
	return x
}

// SurfaceTransformFlagBitsKHR enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceTransformFlagBitsKHR.html
type SurfaceTransformFlagBitsKHR uint32

const (
	VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR SurfaceTransformFlagBitsKHR = (1 << 0)
	VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR SurfaceTransformFlagBitsKHR = (1 << 1)
	VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR SurfaceTransformFlagBitsKHR = (1 << 2)
	VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR SurfaceTransformFlagBitsKHR = (1 << 3)
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR SurfaceTransformFlagBitsKHR = (1 << 4)
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR SurfaceTransformFlagBitsKHR = (1 << 5)
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR SurfaceTransformFlagBitsKHR = (1 << 6)
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR SurfaceTransformFlagBitsKHR = (1 << 7)
	VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR SurfaceTransformFlagBitsKHR = (1 << 8)
)

var (
	reverseSurfaceTransformFlagBitsKHR map[SurfaceTransformFlagBitsKHR]string = map[SurfaceTransformFlagBitsKHR]string{ 
		VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR: "VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR",
		VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR: "VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR",
		VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR: "VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR",
		VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR: "VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR",
		VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR: "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR",
		VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR: "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR",
		VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR: "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR",
		VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR: "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR",
		VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR: "VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR",
	}
)
func (x SurfaceTransformFlagBitsKHR) String() string {
	if s, ok := reverseSurfaceTransformFlagBitsKHR[x]; ok {
		return s
	}
	return fmt.Sprintf("SurfaceTransformFlagBitsKHR=%d", x)
}

// SurfaceTransformFlagsKHR bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceTransformFlagsKHR.html
type SurfaceTransformFlagsKHR Flags

// CompositeAlphaFlagBitsKHR enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCompositeAlphaFlagBitsKHR.html
type CompositeAlphaFlagBitsKHR uint32

const (
	VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR CompositeAlphaFlagBitsKHR = (1 << 0)
	VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR CompositeAlphaFlagBitsKHR = (1 << 1)
	VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR CompositeAlphaFlagBitsKHR = (1 << 2)
	VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR CompositeAlphaFlagBitsKHR = (1 << 3)
)

var (
	reverseCompositeAlphaFlagBitsKHR map[CompositeAlphaFlagBitsKHR]string = map[CompositeAlphaFlagBitsKHR]string{ 
		VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR: "VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR",
		VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR: "VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR",
		VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR: "VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR",
		VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR: "VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR",
	}
)
func (x CompositeAlphaFlagBitsKHR) String() string {
	if s, ok := reverseCompositeAlphaFlagBitsKHR[x]; ok {
		return s
	}
	return fmt.Sprintf("CompositeAlphaFlagBitsKHR=%d", x)
}

// CompositeAlphaFlagsKHR bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkCompositeAlphaFlagsKHR.html
type CompositeAlphaFlagsKHR Flags

// SurfaceCapabilitiesKHR provides a go interface for VkSurfaceCapabilitiesKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceCapabilitiesKHR.html
type SurfaceCapabilitiesKHR C.struct_VkSurfaceCapabilitiesKHR

// SizeofSurfaceCapabilitiesKHR is the memory size of a SurfaceCapabilitiesKHR
var SizeofSurfaceCapabilitiesKHR int = int(unsafe.Sizeof(SurfaceCapabilitiesKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SurfaceCapabilitiesKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SurfaceCapabilitiesKHR) AsCPtr() *SurfaceCapabilitiesKHR {
	clone := (*SurfaceCapabilitiesKHR)(newCBlock(C.ulong(SizeofSurfaceCapabilitiesKHR)))
	*clone = x
	return clone
}

// SurfaceCapabilitiesKHRFreeCSlice releases the memory allocated by SurfaceCapabilitiesKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func SurfaceCapabilitiesKHRFreeCSlice(x []SurfaceCapabilitiesKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SurfaceCapabilitiesKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SurfaceCapabilitiesKHRFreeCSlice must be called on the returned slice.
func SurfaceCapabilitiesKHRMakeCSlice(x ...SurfaceCapabilitiesKHR) []SurfaceCapabilitiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSurfaceCapabilitiesKHR * len(x)
	dst := unsafe.Slice((*SurfaceCapabilitiesKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// MinImageCount returns the value of minImageCount from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) MinImageCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.minImageCount) 
	return *ptr
}

// MaxImageCount returns the value of maxImageCount from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) MaxImageCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxImageCount) 
	return *ptr
}

// CurrentExtent returns the value of currentExtent from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) CurrentExtent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.currentExtent) 
	return *ptr
}

// MinImageExtent returns the value of minImageExtent from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) MinImageExtent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.minImageExtent) 
	return *ptr
}

// MaxImageExtent returns the value of maxImageExtent from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) MaxImageExtent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.maxImageExtent) 
	return *ptr
}

// MaxImageArrayLayers returns the value of maxImageArrayLayers from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) MaxImageArrayLayers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.maxImageArrayLayers) 
	return *ptr
}

// SupportedTransforms returns the value of supportedTransforms from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) SupportedTransforms() SurfaceTransformFlagsKHR {
	ptr := /* typedef */ (*SurfaceTransformFlagsKHR)(&x.supportedTransforms) 
	return *ptr
}

// CurrentTransform returns the value of currentTransform from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) CurrentTransform() SurfaceTransformFlagBitsKHR {
	ptr := /* typedef */ (*SurfaceTransformFlagBitsKHR)(&x.currentTransform) 
	return *ptr
}

// SupportedCompositeAlpha returns the value of supportedCompositeAlpha from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) SupportedCompositeAlpha() CompositeAlphaFlagsKHR {
	ptr := /* typedef */ (*CompositeAlphaFlagsKHR)(&x.supportedCompositeAlpha) 
	return *ptr
}

// SupportedUsageFlags returns the value of supportedUsageFlags from VkSurfaceCapabilitiesKHR
func (x SurfaceCapabilitiesKHR) SupportedUsageFlags() ImageUsageFlags {
	ptr := /* typedef */ (*ImageUsageFlags)(&x.supportedUsageFlags) 
	return *ptr
}

// SurfaceCapabilities2KHR provides a go interface for VkSurfaceCapabilities2KHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceCapabilities2KHR.html
type SurfaceCapabilities2KHR C.struct_VkSurfaceCapabilities2KHR

// SizeofSurfaceCapabilities2KHR is the memory size of a SurfaceCapabilities2KHR
var SizeofSurfaceCapabilities2KHR int = int(unsafe.Sizeof(SurfaceCapabilities2KHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SurfaceCapabilities2KHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SurfaceCapabilities2KHR) AsCPtr() *SurfaceCapabilities2KHR {
	clone := (*SurfaceCapabilities2KHR)(newCBlock(C.ulong(SizeofSurfaceCapabilities2KHR)))
	*clone = x
	return clone
}

// SurfaceCapabilities2KHRFreeCSlice releases the memory allocated by SurfaceCapabilities2KHRMakeCSlice.
// It does not free pointers stored inside the slice.
func SurfaceCapabilities2KHRFreeCSlice(x []SurfaceCapabilities2KHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SurfaceCapabilities2KHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SurfaceCapabilities2KHRFreeCSlice must be called on the returned slice.
func SurfaceCapabilities2KHRMakeCSlice(x ...SurfaceCapabilities2KHR) []SurfaceCapabilities2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSurfaceCapabilities2KHR * len(x)
	dst := unsafe.Slice((*SurfaceCapabilities2KHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSurfaceCapabilities2KHR
func (x SurfaceCapabilities2KHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SurfaceCapabilities2KHR) WithDefaultSType() SurfaceCapabilities2KHR {
	return x.WithSType(VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SurfaceCapabilities2KHR) WithSType(y StructureType) SurfaceCapabilities2KHR {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkSurfaceCapabilities2KHR
func (x SurfaceCapabilities2KHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SurfaceCapabilities2KHR) WithPNext(y unsafe.Pointer) SurfaceCapabilities2KHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SurfaceCapabilities returns the value of surfaceCapabilities from VkSurfaceCapabilities2KHR
func (x SurfaceCapabilities2KHR) SurfaceCapabilities() SurfaceCapabilitiesKHR {
	ptr := /* typedef */ (*SurfaceCapabilitiesKHR)(&x.surfaceCapabilities) 
	return *ptr
}

// ColorSpaceKHR enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkColorSpaceKHR.html
type ColorSpaceKHR uint32

const (
	VK_COLOR_SPACE_SRGB_NONLINEAR_KHR ColorSpaceKHR = 0
	VK_COLORSPACE_SRGB_NONLINEAR_KHR ColorSpaceKHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR
)

var (
	reverseColorSpaceKHR map[ColorSpaceKHR]string = map[ColorSpaceKHR]string{ 
		VK_COLOR_SPACE_SRGB_NONLINEAR_KHR: "VK_COLOR_SPACE_SRGB_NONLINEAR_KHR",
	}
)
func (x ColorSpaceKHR) String() string {
	if s, ok := reverseColorSpaceKHR[x]; ok {
		return s
	}
	return fmt.Sprintf("ColorSpaceKHR=%d", x)
}

// SurfaceFormatKHR provides a go interface for VkSurfaceFormatKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceFormatKHR.html
type SurfaceFormatKHR C.struct_VkSurfaceFormatKHR

// SizeofSurfaceFormatKHR is the memory size of a SurfaceFormatKHR
var SizeofSurfaceFormatKHR int = int(unsafe.Sizeof(SurfaceFormatKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SurfaceFormatKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SurfaceFormatKHR) AsCPtr() *SurfaceFormatKHR {
	clone := (*SurfaceFormatKHR)(newCBlock(C.ulong(SizeofSurfaceFormatKHR)))
	*clone = x
	return clone
}

// SurfaceFormatKHRFreeCSlice releases the memory allocated by SurfaceFormatKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func SurfaceFormatKHRFreeCSlice(x []SurfaceFormatKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SurfaceFormatKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SurfaceFormatKHRFreeCSlice must be called on the returned slice.
func SurfaceFormatKHRMakeCSlice(x ...SurfaceFormatKHR) []SurfaceFormatKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSurfaceFormatKHR * len(x)
	dst := unsafe.Slice((*SurfaceFormatKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Format returns the value of format from VkSurfaceFormatKHR
func (x SurfaceFormatKHR) Format() Format {
	ptr := /* typedef */ (*Format)(&x.format) 
	return *ptr
}

// ColorSpace returns the value of colorSpace from VkSurfaceFormatKHR
func (x SurfaceFormatKHR) ColorSpace() ColorSpaceKHR {
	ptr := /* typedef */ (*ColorSpaceKHR)(&x.colorSpace) 
	return *ptr
}

// SurfaceFormat2KHR provides a go interface for VkSurfaceFormat2KHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSurfaceFormat2KHR.html
type SurfaceFormat2KHR C.struct_VkSurfaceFormat2KHR

// SizeofSurfaceFormat2KHR is the memory size of a SurfaceFormat2KHR
var SizeofSurfaceFormat2KHR int = int(unsafe.Sizeof(SurfaceFormat2KHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SurfaceFormat2KHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SurfaceFormat2KHR) AsCPtr() *SurfaceFormat2KHR {
	clone := (*SurfaceFormat2KHR)(newCBlock(C.ulong(SizeofSurfaceFormat2KHR)))
	*clone = x
	return clone
}

// SurfaceFormat2KHRFreeCSlice releases the memory allocated by SurfaceFormat2KHRMakeCSlice.
// It does not free pointers stored inside the slice.
func SurfaceFormat2KHRFreeCSlice(x []SurfaceFormat2KHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SurfaceFormat2KHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SurfaceFormat2KHRFreeCSlice must be called on the returned slice.
func SurfaceFormat2KHRMakeCSlice(x ...SurfaceFormat2KHR) []SurfaceFormat2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSurfaceFormat2KHR * len(x)
	dst := unsafe.Slice((*SurfaceFormat2KHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSurfaceFormat2KHR
func (x SurfaceFormat2KHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SurfaceFormat2KHR) WithDefaultSType() SurfaceFormat2KHR {
	return x.WithSType(VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SurfaceFormat2KHR) WithSType(y StructureType) SurfaceFormat2KHR {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkSurfaceFormat2KHR
func (x SurfaceFormat2KHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SurfaceFormat2KHR) WithPNext(y unsafe.Pointer) SurfaceFormat2KHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SurfaceFormat returns the value of surfaceFormat from VkSurfaceFormat2KHR
func (x SurfaceFormat2KHR) SurfaceFormat() SurfaceFormatKHR {
	ptr := /* typedef */ (*SurfaceFormatKHR)(&x.surfaceFormat) 
	return *ptr
}

// GetPhysicalDeviceSurfaceCapabilities2KHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceCapabilities2KHR.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceSurfaceCapabilities2KHR(pSurfaceInfo *PhysicalDeviceSurfaceInfo2KHR, pSurfaceCapabilities *SurfaceCapabilities2KHR, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceSurfaceInfo2KHR) **C.struct_VkPhysicalDeviceSurfaceInfo2KHR { /* Pointer */ g2c := (*C.struct_VkPhysicalDeviceSurfaceInfo2KHR)(*x); return &g2c }(&pSurfaceInfo)
	p2 := func(x **SurfaceCapabilities2KHR) **C.struct_VkSurfaceCapabilities2KHR { /* Pointer */ g2c := (*C.struct_VkSurfaceCapabilities2KHR)(*x); return &g2c }(&pSurfaceCapabilities)
	ret := C.vkGetPhysicalDeviceSurfaceCapabilities2KHR(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceSurfaceFormats2KHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceFormats2KHR.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceSurfaceFormats2KHR(pSurfaceInfo *PhysicalDeviceSurfaceInfo2KHR, pSurfaceFormatCount *uint32, pSurfaceFormats []SurfaceFormat2KHR, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **PhysicalDeviceSurfaceInfo2KHR) **C.struct_VkPhysicalDeviceSurfaceInfo2KHR { /* Pointer */ g2c := (*C.struct_VkPhysicalDeviceSurfaceInfo2KHR)(*x); return &g2c }(&pSurfaceInfo)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pSurfaceFormatCount)
	p3 := func(x *[]SurfaceFormat2KHR) **C.struct_VkSurfaceFormat2KHR { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkSurfaceFormat2KHR)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkSurfaceFormat2KHR)(unsafe.Pointer((&ptr))) }(&pSurfaceFormats)
	ret := C.vkGetPhysicalDeviceSurfaceFormats2KHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// PresentModeKHR enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentModeKHR.html
type PresentModeKHR uint32

const (
	VK_PRESENT_MODE_IMMEDIATE_KHR PresentModeKHR = 0
	VK_PRESENT_MODE_MAILBOX_KHR PresentModeKHR = 1
	VK_PRESENT_MODE_FIFO_KHR PresentModeKHR = 2
	VK_PRESENT_MODE_FIFO_RELAXED_KHR PresentModeKHR = 3
)

var (
	reversePresentModeKHR map[PresentModeKHR]string = map[PresentModeKHR]string{ 
		VK_PRESENT_MODE_IMMEDIATE_KHR: "VK_PRESENT_MODE_IMMEDIATE_KHR",
		VK_PRESENT_MODE_MAILBOX_KHR: "VK_PRESENT_MODE_MAILBOX_KHR",
		VK_PRESENT_MODE_FIFO_KHR: "VK_PRESENT_MODE_FIFO_KHR",
		VK_PRESENT_MODE_FIFO_RELAXED_KHR: "VK_PRESENT_MODE_FIFO_RELAXED_KHR",
	}
)
func (x PresentModeKHR) String() string {
	if s, ok := reversePresentModeKHR[x]; ok {
		return s
	}
	return fmt.Sprintf("PresentModeKHR=%d", x)
}

// DestroySurfaceKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySurfaceKHR.html
func (x InstanceFacade)DestroySurfaceKHR(surface SurfaceKHR, pAllocator *AllocationCallbacks, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkInstance)(&x.H)
	p1 := /* handle */ (*C.VkSurfaceKHR)(&surface)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	C.vkDestroySurfaceKHR(addrs, *p0, *p1, *p2)
	}

// GetPhysicalDeviceSurfaceSupportKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceSupportKHR.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceSurfaceSupportKHR(queueFamilyIndex uint32, surface SurfaceKHR, pSupported *Bool32, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&queueFamilyIndex)
	p2 := /* handle */ (*C.VkSurfaceKHR)(&surface)
	p3 := func(x **Bool32) **C.VkBool32 { /* Pointer */ g2c := (*C.VkBool32)(*x); return &g2c }(&pSupported)
	ret := C.vkGetPhysicalDeviceSurfaceSupportKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceSurfaceCapabilitiesKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceCapabilitiesKHR.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceSurfaceCapabilitiesKHR(surface SurfaceKHR, pSurfaceCapabilities *SurfaceCapabilitiesKHR, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* handle */ (*C.VkSurfaceKHR)(&surface)
	p2 := func(x **SurfaceCapabilitiesKHR) **C.struct_VkSurfaceCapabilitiesKHR { /* Pointer */ g2c := (*C.struct_VkSurfaceCapabilitiesKHR)(*x); return &g2c }(&pSurfaceCapabilities)
	ret := C.vkGetPhysicalDeviceSurfaceCapabilitiesKHR(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceSurfaceFormatsKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceFormatsKHR.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceSurfaceFormatsKHR(surface SurfaceKHR, pSurfaceFormatCount *uint32, pSurfaceFormats []SurfaceFormatKHR, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* handle */ (*C.VkSurfaceKHR)(&surface)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pSurfaceFormatCount)
	p3 := func(x *[]SurfaceFormatKHR) **C.struct_VkSurfaceFormatKHR { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkSurfaceFormatKHR)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkSurfaceFormatKHR)(unsafe.Pointer((&ptr))) }(&pSurfaceFormats)
	ret := C.vkGetPhysicalDeviceSurfaceFormatsKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceSurfacePresentModesKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfacePresentModesKHR.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceSurfacePresentModesKHR(surface SurfaceKHR, pPresentModeCount *uint32, pPresentModes []PresentModeKHR, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* handle */ (*C.VkSurfaceKHR)(&surface)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPresentModeCount)
	p3 := func(x *[]PresentModeKHR) **C.VkPresentModeKHR { /* Slice */ if len(*x) > 0 { slc := (*C.VkPresentModeKHR)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkPresentModeKHR)(unsafe.Pointer((&ptr))) }(&pPresentModes)
	ret := C.vkGetPhysicalDeviceSurfacePresentModesKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// SwapchainKHR is a Handle to a vulkan resource.
// SwapchainKHR is a child of SurfaceKHR.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainKHR.html
type SwapchainKHR C.VkSwapchainKHR

// NullSwapchainKHR is a typed Null value for the SwapchainKHR type.
var NullSwapchainKHR SwapchainKHR


// SwapchainCreateFlagBitsKHR enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateFlagBitsKHR.html
type SwapchainCreateFlagBitsKHR uint32

const (
	VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR SwapchainCreateFlagBitsKHR = (1 << 0)
	VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR SwapchainCreateFlagBitsKHR = (1 << 1)
)

var (
	reverseSwapchainCreateFlagBitsKHR map[SwapchainCreateFlagBitsKHR]string = map[SwapchainCreateFlagBitsKHR]string{ 
		VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR: "VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR",
		VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR: "VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR",
	}
)
func (x SwapchainCreateFlagBitsKHR) String() string {
	if s, ok := reverseSwapchainCreateFlagBitsKHR[x]; ok {
		return s
	}
	return fmt.Sprintf("SwapchainCreateFlagBitsKHR=%d", x)
}

// DeviceGroupPresentModeFlagBitsKHR enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupPresentModeFlagBitsKHR.html
type DeviceGroupPresentModeFlagBitsKHR uint32

const (
	VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR DeviceGroupPresentModeFlagBitsKHR = (1 << 0)
	VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR DeviceGroupPresentModeFlagBitsKHR = (1 << 1)
	VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR DeviceGroupPresentModeFlagBitsKHR = (1 << 2)
	VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR DeviceGroupPresentModeFlagBitsKHR = (1 << 3)
)

var (
	reverseDeviceGroupPresentModeFlagBitsKHR map[DeviceGroupPresentModeFlagBitsKHR]string = map[DeviceGroupPresentModeFlagBitsKHR]string{ 
		VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR: "VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR",
		VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR: "VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR",
		VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR: "VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR",
		VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR: "VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR",
	}
)
func (x DeviceGroupPresentModeFlagBitsKHR) String() string {
	if s, ok := reverseDeviceGroupPresentModeFlagBitsKHR[x]; ok {
		return s
	}
	return fmt.Sprintf("DeviceGroupPresentModeFlagBitsKHR=%d", x)
}

// DeviceGroupPresentModeFlagsKHR bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupPresentModeFlagsKHR.html
type DeviceGroupPresentModeFlagsKHR Flags

// SwapchainCreateFlagsKHR bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateFlagsKHR.html
type SwapchainCreateFlagsKHR Flags

// BindImageMemorySwapchainInfoKHR provides a go interface for VkBindImageMemorySwapchainInfoKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkBindImageMemorySwapchainInfoKHR.html
type BindImageMemorySwapchainInfoKHR C.struct_VkBindImageMemorySwapchainInfoKHR

// SizeofBindImageMemorySwapchainInfoKHR is the memory size of a BindImageMemorySwapchainInfoKHR
var SizeofBindImageMemorySwapchainInfoKHR int = int(unsafe.Sizeof(BindImageMemorySwapchainInfoKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *BindImageMemorySwapchainInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x BindImageMemorySwapchainInfoKHR) AsCPtr() *BindImageMemorySwapchainInfoKHR {
	clone := (*BindImageMemorySwapchainInfoKHR)(newCBlock(C.ulong(SizeofBindImageMemorySwapchainInfoKHR)))
	*clone = x
	return clone
}

// BindImageMemorySwapchainInfoKHRFreeCSlice releases the memory allocated by BindImageMemorySwapchainInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func BindImageMemorySwapchainInfoKHRFreeCSlice(x []BindImageMemorySwapchainInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// BindImageMemorySwapchainInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. BindImageMemorySwapchainInfoKHRFreeCSlice must be called on the returned slice.
func BindImageMemorySwapchainInfoKHRMakeCSlice(x ...BindImageMemorySwapchainInfoKHR) []BindImageMemorySwapchainInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofBindImageMemorySwapchainInfoKHR * len(x)
	dst := unsafe.Slice((*BindImageMemorySwapchainInfoKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkBindImageMemorySwapchainInfoKHR
func (x BindImageMemorySwapchainInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x BindImageMemorySwapchainInfoKHR) WithDefaultSType() BindImageMemorySwapchainInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemorySwapchainInfoKHR) WithSType(y StructureType) BindImageMemorySwapchainInfoKHR {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkBindImageMemorySwapchainInfoKHR
func (x BindImageMemorySwapchainInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemorySwapchainInfoKHR) WithPNext(y unsafe.Pointer) BindImageMemorySwapchainInfoKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Swapchain returns the value of swapchain from VkBindImageMemorySwapchainInfoKHR
func (x BindImageMemorySwapchainInfoKHR) Swapchain() SwapchainKHR {
	ptr := /* handle */ (*SwapchainKHR)(&x.swapchain) 
	return *ptr
}

// WithSwapchain sets the value for the Swapchain on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemorySwapchainInfoKHR) WithSwapchain(y SwapchainKHR) BindImageMemorySwapchainInfoKHR {
	x.swapchain = *(/* handle */ (*C.VkSwapchainKHR)(&y))
	return x
}

// ImageIndex returns the value of imageIndex from VkBindImageMemorySwapchainInfoKHR
func (x BindImageMemorySwapchainInfoKHR) ImageIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.imageIndex) 
	return *ptr
}

// WithImageIndex sets the value for the ImageIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x BindImageMemorySwapchainInfoKHR) WithImageIndex(y uint32) BindImageMemorySwapchainInfoKHR {
	x.imageIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// SwapchainCreateInfoKHR provides a go interface for VkSwapchainCreateInfoKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkSwapchainCreateInfoKHR.html
type SwapchainCreateInfoKHR C.struct_VkSwapchainCreateInfoKHR

// SizeofSwapchainCreateInfoKHR is the memory size of a SwapchainCreateInfoKHR
var SizeofSwapchainCreateInfoKHR int = int(unsafe.Sizeof(SwapchainCreateInfoKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *SwapchainCreateInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x SwapchainCreateInfoKHR) AsCPtr() *SwapchainCreateInfoKHR {
	clone := (*SwapchainCreateInfoKHR)(newCBlock(C.ulong(SizeofSwapchainCreateInfoKHR)))
	*clone = x
	return clone
}

// SwapchainCreateInfoKHRFreeCSlice releases the memory allocated by SwapchainCreateInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func SwapchainCreateInfoKHRFreeCSlice(x []SwapchainCreateInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// SwapchainCreateInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. SwapchainCreateInfoKHRFreeCSlice must be called on the returned slice.
func SwapchainCreateInfoKHRMakeCSlice(x ...SwapchainCreateInfoKHR) []SwapchainCreateInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofSwapchainCreateInfoKHR * len(x)
	dst := unsafe.Slice((*SwapchainCreateInfoKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x SwapchainCreateInfoKHR) WithDefaultSType() SwapchainCreateInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithSType(y StructureType) SwapchainCreateInfoKHR {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithPNext(y unsafe.Pointer) SwapchainCreateInfoKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) Flags() SwapchainCreateFlagsKHR {
	ptr := /* typedef */ (*SwapchainCreateFlagsKHR)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithFlags(y SwapchainCreateFlagsKHR) SwapchainCreateInfoKHR {
	x.flags = *(/* typedef */ (*C.VkSwapchainCreateFlagsKHR)(&y))
	return x
}

// Surface returns the value of surface from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) Surface() SurfaceKHR {
	ptr := /* handle */ (*SurfaceKHR)(&x.surface) 
	return *ptr
}

// WithSurface sets the value for the Surface on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithSurface(y SurfaceKHR) SwapchainCreateInfoKHR {
	x.surface = *(/* handle */ (*C.VkSurfaceKHR)(&y))
	return x
}

// MinImageCount returns the value of minImageCount from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) MinImageCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.minImageCount) 
	return *ptr
}

// WithMinImageCount sets the value for the MinImageCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithMinImageCount(y uint32) SwapchainCreateInfoKHR {
	x.minImageCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// ImageFormat returns the value of imageFormat from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) ImageFormat() Format {
	ptr := /* typedef */ (*Format)(&x.imageFormat) 
	return *ptr
}

// WithImageFormat sets the value for the ImageFormat on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithImageFormat(y Format) SwapchainCreateInfoKHR {
	x.imageFormat = *(/* typedef */ (*C.VkFormat)(&y))
	return x
}

// ImageColorSpace returns the value of imageColorSpace from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) ImageColorSpace() ColorSpaceKHR {
	ptr := /* typedef */ (*ColorSpaceKHR)(&x.imageColorSpace) 
	return *ptr
}

// WithImageColorSpace sets the value for the ImageColorSpace on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithImageColorSpace(y ColorSpaceKHR) SwapchainCreateInfoKHR {
	x.imageColorSpace = *(/* typedef */ (*C.VkColorSpaceKHR)(&y))
	return x
}

// ImageExtent returns the value of imageExtent from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) ImageExtent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.imageExtent) 
	return *ptr
}

// WithImageExtent sets the value for the ImageExtent on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithImageExtent(y Extent2D) SwapchainCreateInfoKHR {
	x.imageExtent = *(/* typedef */ (*C.struct_VkExtent2D)(&y))
	return x
}

// ImageArrayLayers returns the value of imageArrayLayers from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) ImageArrayLayers() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.imageArrayLayers) 
	return *ptr
}

// WithImageArrayLayers sets the value for the ImageArrayLayers on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithImageArrayLayers(y uint32) SwapchainCreateInfoKHR {
	x.imageArrayLayers = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// ImageUsage returns the value of imageUsage from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) ImageUsage() ImageUsageFlags {
	ptr := /* typedef */ (*ImageUsageFlags)(&x.imageUsage) 
	return *ptr
}

// WithImageUsage sets the value for the ImageUsage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithImageUsage(y ImageUsageFlags) SwapchainCreateInfoKHR {
	x.imageUsage = *(/* typedef */ (*C.VkImageUsageFlags)(&y))
	return x
}

// ImageSharingMode returns the value of imageSharingMode from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) ImageSharingMode() SharingMode {
	ptr := /* typedef */ (*SharingMode)(&x.imageSharingMode) 
	return *ptr
}

// WithImageSharingMode sets the value for the ImageSharingMode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithImageSharingMode(y SharingMode) SwapchainCreateInfoKHR {
	x.imageSharingMode = *(/* typedef */ (*C.VkSharingMode)(&y))
	return x
}

// QueueFamilyIndexCount returns the value of queueFamilyIndexCount from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) QueueFamilyIndexCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.queueFamilyIndexCount) 
	return *ptr
}

// WithQueueFamilyIndexCount sets the value for the QueueFamilyIndexCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithQueueFamilyIndexCount(y uint32) SwapchainCreateInfoKHR {
	x.queueFamilyIndexCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PQueueFamilyIndices returns the value of pQueueFamilyIndices from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) PQueueFamilyIndices() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */ slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pQueueFamilyIndices) 
	return *ptr
}

// WithPQueueFamilyIndices sets the value for the PQueueFamilyIndices on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines QueueFamilyIndexCount as the length of this field.
// QueueFamilyIndexCount is updated with the length of the new value.
func (x SwapchainCreateInfoKHR) WithPQueueFamilyIndices(y []uint32) SwapchainCreateInfoKHR {
	x.pQueueFamilyIndices = *(func(x *[]uint32) **C.uint32_t { /* Slice */ if len(*x) > 0 { slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.uint32_t)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithQueueFamilyIndexCount(uint32(len(y)))
}

// PreTransform returns the value of preTransform from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) PreTransform() SurfaceTransformFlagBitsKHR {
	ptr := /* typedef */ (*SurfaceTransformFlagBitsKHR)(&x.preTransform) 
	return *ptr
}

// WithPreTransform sets the value for the PreTransform on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithPreTransform(y SurfaceTransformFlagBitsKHR) SwapchainCreateInfoKHR {
	x.preTransform = *(/* typedef */ (*C.VkSurfaceTransformFlagBitsKHR)(&y))
	return x
}

// CompositeAlpha returns the value of compositeAlpha from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) CompositeAlpha() CompositeAlphaFlagBitsKHR {
	ptr := /* typedef */ (*CompositeAlphaFlagBitsKHR)(&x.compositeAlpha) 
	return *ptr
}

// WithCompositeAlpha sets the value for the CompositeAlpha on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithCompositeAlpha(y CompositeAlphaFlagBitsKHR) SwapchainCreateInfoKHR {
	x.compositeAlpha = *(/* typedef */ (*C.VkCompositeAlphaFlagBitsKHR)(&y))
	return x
}

// PresentMode returns the value of presentMode from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) PresentMode() PresentModeKHR {
	ptr := /* typedef */ (*PresentModeKHR)(&x.presentMode) 
	return *ptr
}

// WithPresentMode sets the value for the PresentMode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithPresentMode(y PresentModeKHR) SwapchainCreateInfoKHR {
	x.presentMode = *(/* typedef */ (*C.VkPresentModeKHR)(&y))
	return x
}

// Clipped returns the value of clipped from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) Clipped() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.clipped) 
	return *ptr
}

// WithClipped sets the value for the Clipped on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithClipped(y Bool32) SwapchainCreateInfoKHR {
	x.clipped = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// OldSwapchain returns the value of oldSwapchain from VkSwapchainCreateInfoKHR
func (x SwapchainCreateInfoKHR) OldSwapchain() SwapchainKHR {
	ptr := /* handle */ (*SwapchainKHR)(&x.oldSwapchain) 
	return *ptr
}

// WithOldSwapchain sets the value for the OldSwapchain on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x SwapchainCreateInfoKHR) WithOldSwapchain(y SwapchainKHR) SwapchainCreateInfoKHR {
	x.oldSwapchain = *(/* handle */ (*C.VkSwapchainKHR)(&y))
	return x
}

// PresentInfoKHR provides a go interface for VkPresentInfoKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentInfoKHR.html
type PresentInfoKHR C.struct_VkPresentInfoKHR

// SizeofPresentInfoKHR is the memory size of a PresentInfoKHR
var SizeofPresentInfoKHR int = int(unsafe.Sizeof(PresentInfoKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PresentInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PresentInfoKHR) AsCPtr() *PresentInfoKHR {
	clone := (*PresentInfoKHR)(newCBlock(C.ulong(SizeofPresentInfoKHR)))
	*clone = x
	return clone
}

// PresentInfoKHRFreeCSlice releases the memory allocated by PresentInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func PresentInfoKHRFreeCSlice(x []PresentInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PresentInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PresentInfoKHRFreeCSlice must be called on the returned slice.
func PresentInfoKHRMakeCSlice(x ...PresentInfoKHR) []PresentInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPresentInfoKHR * len(x)
	dst := unsafe.Slice((*PresentInfoKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPresentInfoKHR
func (x PresentInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PresentInfoKHR) WithDefaultSType() PresentInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_PRESENT_INFO_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PresentInfoKHR) WithSType(y StructureType) PresentInfoKHR {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPresentInfoKHR
func (x PresentInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PresentInfoKHR) WithPNext(y unsafe.Pointer) PresentInfoKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// WaitSemaphoreCount returns the value of waitSemaphoreCount from VkPresentInfoKHR
func (x PresentInfoKHR) WaitSemaphoreCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.waitSemaphoreCount) 
	return *ptr
}

// WithWaitSemaphoreCount sets the value for the WaitSemaphoreCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PresentInfoKHR) WithWaitSemaphoreCount(y uint32) PresentInfoKHR {
	x.waitSemaphoreCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PWaitSemaphores returns the value of pWaitSemaphores from VkPresentInfoKHR
func (x PresentInfoKHR) PWaitSemaphores() []Semaphore {
	ptr := func(x **C.VkSemaphore) *[]Semaphore { /* Slice */ slc := unsafe.Slice((*Semaphore)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pWaitSemaphores) 
	return *ptr
}

// WithPWaitSemaphores sets the value for the PWaitSemaphores on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines WaitSemaphoreCount as the length of this field.
// WaitSemaphoreCount is updated with the length of the new value.
func (x PresentInfoKHR) WithPWaitSemaphores(y []Semaphore) PresentInfoKHR {
	x.pWaitSemaphores = *(func(x *[]Semaphore) **C.VkSemaphore { /* Slice */ if len(*x) > 0 { slc := (*C.VkSemaphore)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkSemaphore)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithWaitSemaphoreCount(uint32(len(y)))
}

// SwapchainCount returns the value of swapchainCount from VkPresentInfoKHR
func (x PresentInfoKHR) SwapchainCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.swapchainCount) 
	return *ptr
}

// WithSwapchainCount sets the value for the SwapchainCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PresentInfoKHR) WithSwapchainCount(y uint32) PresentInfoKHR {
	x.swapchainCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PSwapchains returns the value of pSwapchains from VkPresentInfoKHR
func (x PresentInfoKHR) PSwapchains() []SwapchainKHR {
	ptr := func(x **C.VkSwapchainKHR) *[]SwapchainKHR { /* Slice */ slc := unsafe.Slice((*SwapchainKHR)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pSwapchains) 
	return *ptr
}

// WithPSwapchains sets the value for the PSwapchains on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines SwapchainCount as the length of this field.
// SwapchainCount is updated with the length of the new value.
func (x PresentInfoKHR) WithPSwapchains(y []SwapchainKHR) PresentInfoKHR {
	x.pSwapchains = *(func(x *[]SwapchainKHR) **C.VkSwapchainKHR { /* Slice */ if len(*x) > 0 { slc := (*C.VkSwapchainKHR)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkSwapchainKHR)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithSwapchainCount(uint32(len(y)))
}

// PImageIndices returns the value of pImageIndices from VkPresentInfoKHR
func (x PresentInfoKHR) PImageIndices() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */ slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pImageIndices) 
	return *ptr
}

// WithPImageIndices sets the value for the PImageIndices on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines SwapchainCount as the length of this field.
// SwapchainCount is updated with the length of the new value.
func (x PresentInfoKHR) WithPImageIndices(y []uint32) PresentInfoKHR {
	x.pImageIndices = *(func(x *[]uint32) **C.uint32_t { /* Slice */ if len(*x) > 0 { slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.uint32_t)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithSwapchainCount(uint32(len(y)))
}

// PResults returns the value of pResults from VkPresentInfoKHR
func (x PresentInfoKHR) PResults() []Result {
	ptr := func(x **C.VkResult) *[]Result { /* Slice */ slc := unsafe.Slice((*Result)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pResults) 
	return *ptr
}

// WithPResults sets the value for the PResults on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines SwapchainCount as the length of this field.
// SwapchainCount is updated with the length of the new value.
func (x PresentInfoKHR) WithPResults(y []Result) PresentInfoKHR {
	x.pResults = *(func(x *[]Result) **C.VkResult { /* Slice */ if len(*x) > 0 { slc := (*C.VkResult)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkResult)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithSwapchainCount(uint32(len(y)))
}

// DeviceGroupPresentCapabilitiesKHR provides a go interface for VkDeviceGroupPresentCapabilitiesKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupPresentCapabilitiesKHR.html
type DeviceGroupPresentCapabilitiesKHR C.struct_VkDeviceGroupPresentCapabilitiesKHR

// SizeofDeviceGroupPresentCapabilitiesKHR is the memory size of a DeviceGroupPresentCapabilitiesKHR
var SizeofDeviceGroupPresentCapabilitiesKHR int = int(unsafe.Sizeof(DeviceGroupPresentCapabilitiesKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceGroupPresentCapabilitiesKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceGroupPresentCapabilitiesKHR) AsCPtr() *DeviceGroupPresentCapabilitiesKHR {
	clone := (*DeviceGroupPresentCapabilitiesKHR)(newCBlock(C.ulong(SizeofDeviceGroupPresentCapabilitiesKHR)))
	*clone = x
	return clone
}

// DeviceGroupPresentCapabilitiesKHRFreeCSlice releases the memory allocated by DeviceGroupPresentCapabilitiesKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceGroupPresentCapabilitiesKHRFreeCSlice(x []DeviceGroupPresentCapabilitiesKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceGroupPresentCapabilitiesKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceGroupPresentCapabilitiesKHRFreeCSlice must be called on the returned slice.
func DeviceGroupPresentCapabilitiesKHRMakeCSlice(x ...DeviceGroupPresentCapabilitiesKHR) []DeviceGroupPresentCapabilitiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupPresentCapabilitiesKHR * len(x)
	dst := unsafe.Slice((*DeviceGroupPresentCapabilitiesKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceGroupPresentCapabilitiesKHR
func (x DeviceGroupPresentCapabilitiesKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DeviceGroupPresentCapabilitiesKHR) WithDefaultSType() DeviceGroupPresentCapabilitiesKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupPresentCapabilitiesKHR) WithSType(y StructureType) DeviceGroupPresentCapabilitiesKHR {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDeviceGroupPresentCapabilitiesKHR
func (x DeviceGroupPresentCapabilitiesKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupPresentCapabilitiesKHR) WithPNext(y unsafe.Pointer) DeviceGroupPresentCapabilitiesKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// PresentMask returns the value of presentMask from VkDeviceGroupPresentCapabilitiesKHR
func (x DeviceGroupPresentCapabilitiesKHR) PresentMask() []uint32 {
	ptr := func(x *[VK_MAX_DEVICE_GROUP_SIZE]C.uint32_t) *[]uint32 { /* Array */ slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), VK_MAX_DEVICE_GROUP_SIZE); return &slc }(&x.presentMask) 
	return *ptr
}

// Modes returns the value of modes from VkDeviceGroupPresentCapabilitiesKHR
func (x DeviceGroupPresentCapabilitiesKHR) Modes() DeviceGroupPresentModeFlagsKHR {
	ptr := /* typedef */ (*DeviceGroupPresentModeFlagsKHR)(&x.modes) 
	return *ptr
}

// DeviceGroupPresentInfoKHR provides a go interface for VkDeviceGroupPresentInfoKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupPresentInfoKHR.html
type DeviceGroupPresentInfoKHR C.struct_VkDeviceGroupPresentInfoKHR

// SizeofDeviceGroupPresentInfoKHR is the memory size of a DeviceGroupPresentInfoKHR
var SizeofDeviceGroupPresentInfoKHR int = int(unsafe.Sizeof(DeviceGroupPresentInfoKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceGroupPresentInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceGroupPresentInfoKHR) AsCPtr() *DeviceGroupPresentInfoKHR {
	clone := (*DeviceGroupPresentInfoKHR)(newCBlock(C.ulong(SizeofDeviceGroupPresentInfoKHR)))
	*clone = x
	return clone
}

// DeviceGroupPresentInfoKHRFreeCSlice releases the memory allocated by DeviceGroupPresentInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceGroupPresentInfoKHRFreeCSlice(x []DeviceGroupPresentInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceGroupPresentInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceGroupPresentInfoKHRFreeCSlice must be called on the returned slice.
func DeviceGroupPresentInfoKHRMakeCSlice(x ...DeviceGroupPresentInfoKHR) []DeviceGroupPresentInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupPresentInfoKHR * len(x)
	dst := unsafe.Slice((*DeviceGroupPresentInfoKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceGroupPresentInfoKHR
func (x DeviceGroupPresentInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DeviceGroupPresentInfoKHR) WithDefaultSType() DeviceGroupPresentInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupPresentInfoKHR) WithSType(y StructureType) DeviceGroupPresentInfoKHR {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDeviceGroupPresentInfoKHR
func (x DeviceGroupPresentInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupPresentInfoKHR) WithPNext(y unsafe.Pointer) DeviceGroupPresentInfoKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SwapchainCount returns the value of swapchainCount from VkDeviceGroupPresentInfoKHR
func (x DeviceGroupPresentInfoKHR) SwapchainCount() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.swapchainCount) 
	return *ptr
}

// WithSwapchainCount sets the value for the SwapchainCount on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupPresentInfoKHR) WithSwapchainCount(y uint32) DeviceGroupPresentInfoKHR {
	x.swapchainCount = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PDeviceMasks returns the value of pDeviceMasks from VkDeviceGroupPresentInfoKHR
func (x DeviceGroupPresentInfoKHR) PDeviceMasks() []uint32 {
	ptr := func(x **C.uint32_t) *[]uint32 { /* Slice */ slc := unsafe.Slice((*uint32)(unsafe.Pointer(x)), (1 << 31)); return &slc }(&x.pDeviceMasks) 
	return *ptr
}

// WithPDeviceMasks sets the value for the PDeviceMasks on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
// 
// The specification defines SwapchainCount as the length of this field.
// SwapchainCount is updated with the length of the new value.
func (x DeviceGroupPresentInfoKHR) WithPDeviceMasks(y []uint32) DeviceGroupPresentInfoKHR {
	x.pDeviceMasks = *(func(x *[]uint32) **C.uint32_t { /* Slice */ if len(*x) > 0 { slc := (*C.uint32_t)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.uint32_t)(unsafe.Pointer((&ptr))) }(&y))
	return x.WithSwapchainCount(uint32(len(y)))
}

// Mode returns the value of mode from VkDeviceGroupPresentInfoKHR
func (x DeviceGroupPresentInfoKHR) Mode() DeviceGroupPresentModeFlagBitsKHR {
	ptr := /* typedef */ (*DeviceGroupPresentModeFlagBitsKHR)(&x.mode) 
	return *ptr
}

// WithMode sets the value for the Mode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupPresentInfoKHR) WithMode(y DeviceGroupPresentModeFlagBitsKHR) DeviceGroupPresentInfoKHR {
	x.mode = *(/* typedef */ (*C.VkDeviceGroupPresentModeFlagBitsKHR)(&y))
	return x
}

// DeviceGroupSwapchainCreateInfoKHR provides a go interface for VkDeviceGroupSwapchainCreateInfoKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDeviceGroupSwapchainCreateInfoKHR.html
type DeviceGroupSwapchainCreateInfoKHR C.struct_VkDeviceGroupSwapchainCreateInfoKHR

// SizeofDeviceGroupSwapchainCreateInfoKHR is the memory size of a DeviceGroupSwapchainCreateInfoKHR
var SizeofDeviceGroupSwapchainCreateInfoKHR int = int(unsafe.Sizeof(DeviceGroupSwapchainCreateInfoKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DeviceGroupSwapchainCreateInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DeviceGroupSwapchainCreateInfoKHR) AsCPtr() *DeviceGroupSwapchainCreateInfoKHR {
	clone := (*DeviceGroupSwapchainCreateInfoKHR)(newCBlock(C.ulong(SizeofDeviceGroupSwapchainCreateInfoKHR)))
	*clone = x
	return clone
}

// DeviceGroupSwapchainCreateInfoKHRFreeCSlice releases the memory allocated by DeviceGroupSwapchainCreateInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DeviceGroupSwapchainCreateInfoKHRFreeCSlice(x []DeviceGroupSwapchainCreateInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DeviceGroupSwapchainCreateInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DeviceGroupSwapchainCreateInfoKHRFreeCSlice must be called on the returned slice.
func DeviceGroupSwapchainCreateInfoKHRMakeCSlice(x ...DeviceGroupSwapchainCreateInfoKHR) []DeviceGroupSwapchainCreateInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDeviceGroupSwapchainCreateInfoKHR * len(x)
	dst := unsafe.Slice((*DeviceGroupSwapchainCreateInfoKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDeviceGroupSwapchainCreateInfoKHR
func (x DeviceGroupSwapchainCreateInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DeviceGroupSwapchainCreateInfoKHR) WithDefaultSType() DeviceGroupSwapchainCreateInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupSwapchainCreateInfoKHR) WithSType(y StructureType) DeviceGroupSwapchainCreateInfoKHR {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDeviceGroupSwapchainCreateInfoKHR
func (x DeviceGroupSwapchainCreateInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupSwapchainCreateInfoKHR) WithPNext(y unsafe.Pointer) DeviceGroupSwapchainCreateInfoKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Modes returns the value of modes from VkDeviceGroupSwapchainCreateInfoKHR
func (x DeviceGroupSwapchainCreateInfoKHR) Modes() DeviceGroupPresentModeFlagsKHR {
	ptr := /* typedef */ (*DeviceGroupPresentModeFlagsKHR)(&x.modes) 
	return *ptr
}

// WithModes sets the value for the Modes on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DeviceGroupSwapchainCreateInfoKHR) WithModes(y DeviceGroupPresentModeFlagsKHR) DeviceGroupSwapchainCreateInfoKHR {
	x.modes = *(/* typedef */ (*C.VkDeviceGroupPresentModeFlagsKHR)(&y))
	return x
}

// AcquireNextImageInfoKHR provides a go interface for VkAcquireNextImageInfoKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkAcquireNextImageInfoKHR.html
type AcquireNextImageInfoKHR C.struct_VkAcquireNextImageInfoKHR

// SizeofAcquireNextImageInfoKHR is the memory size of a AcquireNextImageInfoKHR
var SizeofAcquireNextImageInfoKHR int = int(unsafe.Sizeof(AcquireNextImageInfoKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *AcquireNextImageInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x AcquireNextImageInfoKHR) AsCPtr() *AcquireNextImageInfoKHR {
	clone := (*AcquireNextImageInfoKHR)(newCBlock(C.ulong(SizeofAcquireNextImageInfoKHR)))
	*clone = x
	return clone
}

// AcquireNextImageInfoKHRFreeCSlice releases the memory allocated by AcquireNextImageInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func AcquireNextImageInfoKHRFreeCSlice(x []AcquireNextImageInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// AcquireNextImageInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. AcquireNextImageInfoKHRFreeCSlice must be called on the returned slice.
func AcquireNextImageInfoKHRMakeCSlice(x ...AcquireNextImageInfoKHR) []AcquireNextImageInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofAcquireNextImageInfoKHR * len(x)
	dst := unsafe.Slice((*AcquireNextImageInfoKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkAcquireNextImageInfoKHR
func (x AcquireNextImageInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x AcquireNextImageInfoKHR) WithDefaultSType() AcquireNextImageInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AcquireNextImageInfoKHR) WithSType(y StructureType) AcquireNextImageInfoKHR {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkAcquireNextImageInfoKHR
func (x AcquireNextImageInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AcquireNextImageInfoKHR) WithPNext(y unsafe.Pointer) AcquireNextImageInfoKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Swapchain returns the value of swapchain from VkAcquireNextImageInfoKHR
func (x AcquireNextImageInfoKHR) Swapchain() SwapchainKHR {
	ptr := /* handle */ (*SwapchainKHR)(&x.swapchain) 
	return *ptr
}

// WithSwapchain sets the value for the Swapchain on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AcquireNextImageInfoKHR) WithSwapchain(y SwapchainKHR) AcquireNextImageInfoKHR {
	x.swapchain = *(/* handle */ (*C.VkSwapchainKHR)(&y))
	return x
}

// Timeout returns the value of timeout from VkAcquireNextImageInfoKHR
func (x AcquireNextImageInfoKHR) Timeout() uint64 {
	ptr := func(x *C.uint64_t) *uint64 { /* Scalar */ c2g := uint64(*x); return &c2g }(&x.timeout) 
	return *ptr
}

// WithTimeout sets the value for the Timeout on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AcquireNextImageInfoKHR) WithTimeout(y uint64) AcquireNextImageInfoKHR {
	x.timeout = *(func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&y))
	return x
}

// Semaphore returns the value of semaphore from VkAcquireNextImageInfoKHR
func (x AcquireNextImageInfoKHR) Semaphore() Semaphore {
	ptr := /* handle */ (*Semaphore)(&x.semaphore) 
	return *ptr
}

// WithSemaphore sets the value for the Semaphore on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AcquireNextImageInfoKHR) WithSemaphore(y Semaphore) AcquireNextImageInfoKHR {
	x.semaphore = *(/* handle */ (*C.VkSemaphore)(&y))
	return x
}

// Fence returns the value of fence from VkAcquireNextImageInfoKHR
func (x AcquireNextImageInfoKHR) Fence() Fence {
	ptr := /* handle */ (*Fence)(&x.fence) 
	return *ptr
}

// WithFence sets the value for the Fence on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AcquireNextImageInfoKHR) WithFence(y Fence) AcquireNextImageInfoKHR {
	x.fence = *(/* handle */ (*C.VkFence)(&y))
	return x
}

// DeviceMask returns the value of deviceMask from VkAcquireNextImageInfoKHR
func (x AcquireNextImageInfoKHR) DeviceMask() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.deviceMask) 
	return *ptr
}

// WithDeviceMask sets the value for the DeviceMask on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x AcquireNextImageInfoKHR) WithDeviceMask(y uint32) AcquireNextImageInfoKHR {
	x.deviceMask = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// ImageSwapchainCreateInfoKHR provides a go interface for VkImageSwapchainCreateInfoKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkImageSwapchainCreateInfoKHR.html
type ImageSwapchainCreateInfoKHR C.struct_VkImageSwapchainCreateInfoKHR

// SizeofImageSwapchainCreateInfoKHR is the memory size of a ImageSwapchainCreateInfoKHR
var SizeofImageSwapchainCreateInfoKHR int = int(unsafe.Sizeof(ImageSwapchainCreateInfoKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *ImageSwapchainCreateInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x ImageSwapchainCreateInfoKHR) AsCPtr() *ImageSwapchainCreateInfoKHR {
	clone := (*ImageSwapchainCreateInfoKHR)(newCBlock(C.ulong(SizeofImageSwapchainCreateInfoKHR)))
	*clone = x
	return clone
}

// ImageSwapchainCreateInfoKHRFreeCSlice releases the memory allocated by ImageSwapchainCreateInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func ImageSwapchainCreateInfoKHRFreeCSlice(x []ImageSwapchainCreateInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// ImageSwapchainCreateInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. ImageSwapchainCreateInfoKHRFreeCSlice must be called on the returned slice.
func ImageSwapchainCreateInfoKHRMakeCSlice(x ...ImageSwapchainCreateInfoKHR) []ImageSwapchainCreateInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofImageSwapchainCreateInfoKHR * len(x)
	dst := unsafe.Slice((*ImageSwapchainCreateInfoKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkImageSwapchainCreateInfoKHR
func (x ImageSwapchainCreateInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x ImageSwapchainCreateInfoKHR) WithDefaultSType() ImageSwapchainCreateInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSwapchainCreateInfoKHR) WithSType(y StructureType) ImageSwapchainCreateInfoKHR {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkImageSwapchainCreateInfoKHR
func (x ImageSwapchainCreateInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSwapchainCreateInfoKHR) WithPNext(y unsafe.Pointer) ImageSwapchainCreateInfoKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Swapchain returns the value of swapchain from VkImageSwapchainCreateInfoKHR
func (x ImageSwapchainCreateInfoKHR) Swapchain() SwapchainKHR {
	ptr := /* handle */ (*SwapchainKHR)(&x.swapchain) 
	return *ptr
}

// WithSwapchain sets the value for the Swapchain on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x ImageSwapchainCreateInfoKHR) WithSwapchain(y SwapchainKHR) ImageSwapchainCreateInfoKHR {
	x.swapchain = *(/* handle */ (*C.VkSwapchainKHR)(&y))
	return x
}

// GetPhysicalDevicePresentRectanglesKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDevicePresentRectanglesKHR.html
func (x PhysicalDeviceFacade)GetPhysicalDevicePresentRectanglesKHR(surface SurfaceKHR, pRectCount *uint32, pRects []Rect2D, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* handle */ (*C.VkSurfaceKHR)(&surface)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pRectCount)
	p3 := func(x *[]Rect2D) **C.struct_VkRect2D { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkRect2D)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkRect2D)(unsafe.Pointer((&ptr))) }(&pRects)
	ret := C.vkGetPhysicalDevicePresentRectanglesKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// AcquireNextImage2KHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImage2KHR.html
func (x DeviceFacade)AcquireNextImage2KHR(pAcquireInfo *AcquireNextImageInfoKHR, pImageIndex *uint32, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **AcquireNextImageInfoKHR) **C.struct_VkAcquireNextImageInfoKHR { /* Pointer */ g2c := (*C.struct_VkAcquireNextImageInfoKHR)(*x); return &g2c }(&pAcquireInfo)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pImageIndex)
	ret := C.vkAcquireNextImage2KHR(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetDeviceGroupSurfacePresentModesKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceGroupSurfacePresentModesKHR.html
func (x DeviceFacade)GetDeviceGroupSurfacePresentModesKHR(surface SurfaceKHR, pModes *DeviceGroupPresentModeFlagsKHR, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkSurfaceKHR)(&surface)
	p2 := func(x **DeviceGroupPresentModeFlagsKHR) **C.VkDeviceGroupPresentModeFlagsKHR { /* Pointer */ g2c := (*C.VkDeviceGroupPresentModeFlagsKHR)(*x); return &g2c }(&pModes)
	ret := C.vkGetDeviceGroupSurfacePresentModesKHR(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetDeviceGroupPresentCapabilitiesKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceGroupPresentCapabilitiesKHR.html
func (x DeviceFacade)GetDeviceGroupPresentCapabilitiesKHR(pDeviceGroupPresentCapabilities *DeviceGroupPresentCapabilitiesKHR, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **DeviceGroupPresentCapabilitiesKHR) **C.struct_VkDeviceGroupPresentCapabilitiesKHR { /* Pointer */ g2c := (*C.struct_VkDeviceGroupPresentCapabilitiesKHR)(*x); return &g2c }(&pDeviceGroupPresentCapabilities)
	ret := C.vkGetDeviceGroupPresentCapabilitiesKHR(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// QueuePresentKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html
func (x QueueFacade)QueuePresentKHR(pPresentInfo *PresentInfoKHR, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkQueue)(&x.H)
	p1 := func(x **PresentInfoKHR) **C.struct_VkPresentInfoKHR { /* Pointer */ g2c := (*C.struct_VkPresentInfoKHR)(*x); return &g2c }(&pPresentInfo)
	ret := C.vkQueuePresentKHR(addrs, *p0, *p1)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// AcquireNextImageKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImageKHR.html
func (x DeviceFacade)AcquireNextImageKHR(swapchain SwapchainKHR, timeout uint64, semaphore Semaphore, fence Fence, pImageIndex *uint32, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkSwapchainKHR)(&swapchain)
	p2 := func(x *uint64) *C.uint64_t { /* Scalar */ g2c := C.uint64_t(*x); return &g2c }(&timeout)
	p3 := /* handle */ (*C.VkSemaphore)(&semaphore)
	p4 := /* handle */ (*C.VkFence)(&fence)
	p5 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pImageIndex)
	ret := C.vkAcquireNextImageKHR(addrs, *p0, *p1, *p2, *p3, *p4, *p5)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetSwapchainImagesKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSwapchainImagesKHR.html
func (x DeviceFacade)GetSwapchainImagesKHR(swapchain SwapchainKHR, pSwapchainImageCount *uint32, pSwapchainImages []Image, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkSwapchainKHR)(&swapchain)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pSwapchainImageCount)
	p3 := func(x *[]Image) **C.VkImage { /* Slice */ if len(*x) > 0 { slc := (*C.VkImage)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkImage)(unsafe.Pointer((&ptr))) }(&pSwapchainImages)
	ret := C.vkGetSwapchainImagesKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DestroySwapchainKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySwapchainKHR.html
func (x DeviceFacade)DestroySwapchainKHR(swapchain SwapchainKHR, pAllocator *AllocationCallbacks, ) {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := /* handle */ (*C.VkSwapchainKHR)(&swapchain)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	C.vkDestroySwapchainKHR(addrs, *p0, *p1, *p2)
	}

// CreateSwapchainKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSwapchainKHR.html
func (x DeviceFacade)CreateSwapchainKHR(pCreateInfo *SwapchainCreateInfoKHR, pAllocator *AllocationCallbacks, pSwapchain *SwapchainKHR, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x **SwapchainCreateInfoKHR) **C.struct_VkSwapchainCreateInfoKHR { /* Pointer */ g2c := (*C.struct_VkSwapchainCreateInfoKHR)(*x); return &g2c }(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p3 := func(x **SwapchainKHR) **C.VkSwapchainKHR { /* Pointer */ g2c := (*C.VkSwapchainKHR)(*x); return &g2c }(&pSwapchain)
	ret := C.vkCreateSwapchainKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DisplayKHR is a Handle to a vulkan resource.
// DisplayKHR is a child of PhysicalDevice.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayKHR.html
type DisplayKHR C.VkDisplayKHR

// NullDisplayKHR is a typed Null value for the DisplayKHR type.
var NullDisplayKHR DisplayKHR


// DisplayModeKHR is a Handle to a vulkan resource.
// DisplayModeKHR is a child of DisplayKHR.
// 
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModeKHR.html
type DisplayModeKHR C.VkDisplayModeKHR

// NullDisplayModeKHR is a typed Null value for the DisplayModeKHR type.
var NullDisplayModeKHR DisplayModeKHR


// DisplayPlaneAlphaFlagBitsKHR enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlaneAlphaFlagBitsKHR.html
type DisplayPlaneAlphaFlagBitsKHR uint32

const (
	VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR DisplayPlaneAlphaFlagBitsKHR = (1 << 0)
	VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR DisplayPlaneAlphaFlagBitsKHR = (1 << 1)
	VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR DisplayPlaneAlphaFlagBitsKHR = (1 << 2)
	VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR DisplayPlaneAlphaFlagBitsKHR = (1 << 3)
)

var (
	reverseDisplayPlaneAlphaFlagBitsKHR map[DisplayPlaneAlphaFlagBitsKHR]string = map[DisplayPlaneAlphaFlagBitsKHR]string{ 
		VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR: "VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR",
		VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR: "VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR",
		VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR: "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR",
		VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR: "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR",
	}
)
func (x DisplayPlaneAlphaFlagBitsKHR) String() string {
	if s, ok := reverseDisplayPlaneAlphaFlagBitsKHR[x]; ok {
		return s
	}
	return fmt.Sprintf("DisplayPlaneAlphaFlagBitsKHR=%d", x)
}

// DisplayModeCreateFlagsKHR bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModeCreateFlagsKHR.html
type DisplayModeCreateFlagsKHR Flags

// DisplayPlaneAlphaFlagsKHR bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlaneAlphaFlagsKHR.html
type DisplayPlaneAlphaFlagsKHR Flags

// DisplaySurfaceCreateFlagsKHR bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplaySurfaceCreateFlagsKHR.html
type DisplaySurfaceCreateFlagsKHR Flags

// DisplayPlanePropertiesKHR provides a go interface for VkDisplayPlanePropertiesKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlanePropertiesKHR.html
type DisplayPlanePropertiesKHR C.struct_VkDisplayPlanePropertiesKHR

// SizeofDisplayPlanePropertiesKHR is the memory size of a DisplayPlanePropertiesKHR
var SizeofDisplayPlanePropertiesKHR int = int(unsafe.Sizeof(DisplayPlanePropertiesKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayPlanePropertiesKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayPlanePropertiesKHR) AsCPtr() *DisplayPlanePropertiesKHR {
	clone := (*DisplayPlanePropertiesKHR)(newCBlock(C.ulong(SizeofDisplayPlanePropertiesKHR)))
	*clone = x
	return clone
}

// DisplayPlanePropertiesKHRFreeCSlice releases the memory allocated by DisplayPlanePropertiesKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayPlanePropertiesKHRFreeCSlice(x []DisplayPlanePropertiesKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayPlanePropertiesKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayPlanePropertiesKHRFreeCSlice must be called on the returned slice.
func DisplayPlanePropertiesKHRMakeCSlice(x ...DisplayPlanePropertiesKHR) []DisplayPlanePropertiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPlanePropertiesKHR * len(x)
	dst := unsafe.Slice((*DisplayPlanePropertiesKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// CurrentDisplay returns the value of currentDisplay from VkDisplayPlanePropertiesKHR
func (x DisplayPlanePropertiesKHR) CurrentDisplay() DisplayKHR {
	ptr := /* handle */ (*DisplayKHR)(&x.currentDisplay) 
	return *ptr
}

// CurrentStackIndex returns the value of currentStackIndex from VkDisplayPlanePropertiesKHR
func (x DisplayPlanePropertiesKHR) CurrentStackIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.currentStackIndex) 
	return *ptr
}

// DisplayModePropertiesKHR provides a go interface for VkDisplayModePropertiesKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModePropertiesKHR.html
type DisplayModePropertiesKHR C.struct_VkDisplayModePropertiesKHR

// SizeofDisplayModePropertiesKHR is the memory size of a DisplayModePropertiesKHR
var SizeofDisplayModePropertiesKHR int = int(unsafe.Sizeof(DisplayModePropertiesKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayModePropertiesKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayModePropertiesKHR) AsCPtr() *DisplayModePropertiesKHR {
	clone := (*DisplayModePropertiesKHR)(newCBlock(C.ulong(SizeofDisplayModePropertiesKHR)))
	*clone = x
	return clone
}

// DisplayModePropertiesKHRFreeCSlice releases the memory allocated by DisplayModePropertiesKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayModePropertiesKHRFreeCSlice(x []DisplayModePropertiesKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayModePropertiesKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayModePropertiesKHRFreeCSlice must be called on the returned slice.
func DisplayModePropertiesKHRMakeCSlice(x ...DisplayModePropertiesKHR) []DisplayModePropertiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayModePropertiesKHR * len(x)
	dst := unsafe.Slice((*DisplayModePropertiesKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// DisplayMode returns the value of displayMode from VkDisplayModePropertiesKHR
func (x DisplayModePropertiesKHR) DisplayMode() DisplayModeKHR {
	ptr := /* handle */ (*DisplayModeKHR)(&x.displayMode) 
	return *ptr
}

// Parameters returns the value of parameters from VkDisplayModePropertiesKHR
func (x DisplayModePropertiesKHR) Parameters() DisplayModeParametersKHR {
	ptr := /* typedef */ (*DisplayModeParametersKHR)(&x.parameters) 
	return *ptr
}

// DisplayPropertiesKHR provides a go interface for VkDisplayPropertiesKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPropertiesKHR.html
type DisplayPropertiesKHR C.struct_VkDisplayPropertiesKHR

// SizeofDisplayPropertiesKHR is the memory size of a DisplayPropertiesKHR
var SizeofDisplayPropertiesKHR int = int(unsafe.Sizeof(DisplayPropertiesKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayPropertiesKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayPropertiesKHR) AsCPtr() *DisplayPropertiesKHR {
	clone := (*DisplayPropertiesKHR)(newCBlock(C.ulong(SizeofDisplayPropertiesKHR)))
	*clone = x
	return clone
}

// DisplayPropertiesKHRFreeCSlice releases the memory allocated by DisplayPropertiesKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayPropertiesKHRFreeCSlice(x []DisplayPropertiesKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayPropertiesKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayPropertiesKHRFreeCSlice must be called on the returned slice.
func DisplayPropertiesKHRMakeCSlice(x ...DisplayPropertiesKHR) []DisplayPropertiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPropertiesKHR * len(x)
	dst := unsafe.Slice((*DisplayPropertiesKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// Display returns the value of display from VkDisplayPropertiesKHR
func (x DisplayPropertiesKHR) Display() DisplayKHR {
	ptr := /* handle */ (*DisplayKHR)(&x.display) 
	return *ptr
}

// DisplayName returns the value of displayName from VkDisplayPropertiesKHR
func (x DisplayPropertiesKHR) DisplayName() *byte {
	ptr := func(x **C.char) **byte { /* Pointer */ return (**byte)(unsafe.Pointer(x)) }(&x.displayName) 
	return *ptr
}

// PhysicalDimensions returns the value of physicalDimensions from VkDisplayPropertiesKHR
func (x DisplayPropertiesKHR) PhysicalDimensions() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.physicalDimensions) 
	return *ptr
}

// PhysicalResolution returns the value of physicalResolution from VkDisplayPropertiesKHR
func (x DisplayPropertiesKHR) PhysicalResolution() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.physicalResolution) 
	return *ptr
}

// SupportedTransforms returns the value of supportedTransforms from VkDisplayPropertiesKHR
func (x DisplayPropertiesKHR) SupportedTransforms() SurfaceTransformFlagsKHR {
	ptr := /* typedef */ (*SurfaceTransformFlagsKHR)(&x.supportedTransforms) 
	return *ptr
}

// PlaneReorderPossible returns the value of planeReorderPossible from VkDisplayPropertiesKHR
func (x DisplayPropertiesKHR) PlaneReorderPossible() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.planeReorderPossible) 
	return *ptr
}

// PersistentContent returns the value of persistentContent from VkDisplayPropertiesKHR
func (x DisplayPropertiesKHR) PersistentContent() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.persistentContent) 
	return *ptr
}

// DisplayModeCreateInfoKHR provides a go interface for VkDisplayModeCreateInfoKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModeCreateInfoKHR.html
type DisplayModeCreateInfoKHR C.struct_VkDisplayModeCreateInfoKHR

// SizeofDisplayModeCreateInfoKHR is the memory size of a DisplayModeCreateInfoKHR
var SizeofDisplayModeCreateInfoKHR int = int(unsafe.Sizeof(DisplayModeCreateInfoKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayModeCreateInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayModeCreateInfoKHR) AsCPtr() *DisplayModeCreateInfoKHR {
	clone := (*DisplayModeCreateInfoKHR)(newCBlock(C.ulong(SizeofDisplayModeCreateInfoKHR)))
	*clone = x
	return clone
}

// DisplayModeCreateInfoKHRFreeCSlice releases the memory allocated by DisplayModeCreateInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayModeCreateInfoKHRFreeCSlice(x []DisplayModeCreateInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayModeCreateInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayModeCreateInfoKHRFreeCSlice must be called on the returned slice.
func DisplayModeCreateInfoKHRMakeCSlice(x ...DisplayModeCreateInfoKHR) []DisplayModeCreateInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayModeCreateInfoKHR * len(x)
	dst := unsafe.Slice((*DisplayModeCreateInfoKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDisplayModeCreateInfoKHR
func (x DisplayModeCreateInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DisplayModeCreateInfoKHR) WithDefaultSType() DisplayModeCreateInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayModeCreateInfoKHR) WithSType(y StructureType) DisplayModeCreateInfoKHR {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDisplayModeCreateInfoKHR
func (x DisplayModeCreateInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayModeCreateInfoKHR) WithPNext(y unsafe.Pointer) DisplayModeCreateInfoKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkDisplayModeCreateInfoKHR
func (x DisplayModeCreateInfoKHR) Flags() DisplayModeCreateFlagsKHR {
	ptr := /* typedef */ (*DisplayModeCreateFlagsKHR)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayModeCreateInfoKHR) WithFlags(y DisplayModeCreateFlagsKHR) DisplayModeCreateInfoKHR {
	x.flags = *(/* typedef */ (*C.VkDisplayModeCreateFlagsKHR)(&y))
	return x
}

// Parameters returns the value of parameters from VkDisplayModeCreateInfoKHR
func (x DisplayModeCreateInfoKHR) Parameters() DisplayModeParametersKHR {
	ptr := /* typedef */ (*DisplayModeParametersKHR)(&x.parameters) 
	return *ptr
}

// WithParameters sets the value for the Parameters on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayModeCreateInfoKHR) WithParameters(y DisplayModeParametersKHR) DisplayModeCreateInfoKHR {
	x.parameters = *(/* typedef */ (*C.struct_VkDisplayModeParametersKHR)(&y))
	return x
}

// DisplayPlaneCapabilitiesKHR provides a go interface for VkDisplayPlaneCapabilitiesKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlaneCapabilitiesKHR.html
type DisplayPlaneCapabilitiesKHR C.struct_VkDisplayPlaneCapabilitiesKHR

// SizeofDisplayPlaneCapabilitiesKHR is the memory size of a DisplayPlaneCapabilitiesKHR
var SizeofDisplayPlaneCapabilitiesKHR int = int(unsafe.Sizeof(DisplayPlaneCapabilitiesKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayPlaneCapabilitiesKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayPlaneCapabilitiesKHR) AsCPtr() *DisplayPlaneCapabilitiesKHR {
	clone := (*DisplayPlaneCapabilitiesKHR)(newCBlock(C.ulong(SizeofDisplayPlaneCapabilitiesKHR)))
	*clone = x
	return clone
}

// DisplayPlaneCapabilitiesKHRFreeCSlice releases the memory allocated by DisplayPlaneCapabilitiesKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayPlaneCapabilitiesKHRFreeCSlice(x []DisplayPlaneCapabilitiesKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayPlaneCapabilitiesKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayPlaneCapabilitiesKHRFreeCSlice must be called on the returned slice.
func DisplayPlaneCapabilitiesKHRMakeCSlice(x ...DisplayPlaneCapabilitiesKHR) []DisplayPlaneCapabilitiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPlaneCapabilitiesKHR * len(x)
	dst := unsafe.Slice((*DisplayPlaneCapabilitiesKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SupportedAlpha returns the value of supportedAlpha from VkDisplayPlaneCapabilitiesKHR
func (x DisplayPlaneCapabilitiesKHR) SupportedAlpha() DisplayPlaneAlphaFlagsKHR {
	ptr := /* typedef */ (*DisplayPlaneAlphaFlagsKHR)(&x.supportedAlpha) 
	return *ptr
}

// MinSrcPosition returns the value of minSrcPosition from VkDisplayPlaneCapabilitiesKHR
func (x DisplayPlaneCapabilitiesKHR) MinSrcPosition() Offset2D {
	ptr := /* typedef */ (*Offset2D)(&x.minSrcPosition) 
	return *ptr
}

// MaxSrcPosition returns the value of maxSrcPosition from VkDisplayPlaneCapabilitiesKHR
func (x DisplayPlaneCapabilitiesKHR) MaxSrcPosition() Offset2D {
	ptr := /* typedef */ (*Offset2D)(&x.maxSrcPosition) 
	return *ptr
}

// MinSrcExtent returns the value of minSrcExtent from VkDisplayPlaneCapabilitiesKHR
func (x DisplayPlaneCapabilitiesKHR) MinSrcExtent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.minSrcExtent) 
	return *ptr
}

// MaxSrcExtent returns the value of maxSrcExtent from VkDisplayPlaneCapabilitiesKHR
func (x DisplayPlaneCapabilitiesKHR) MaxSrcExtent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.maxSrcExtent) 
	return *ptr
}

// MinDstPosition returns the value of minDstPosition from VkDisplayPlaneCapabilitiesKHR
func (x DisplayPlaneCapabilitiesKHR) MinDstPosition() Offset2D {
	ptr := /* typedef */ (*Offset2D)(&x.minDstPosition) 
	return *ptr
}

// MaxDstPosition returns the value of maxDstPosition from VkDisplayPlaneCapabilitiesKHR
func (x DisplayPlaneCapabilitiesKHR) MaxDstPosition() Offset2D {
	ptr := /* typedef */ (*Offset2D)(&x.maxDstPosition) 
	return *ptr
}

// MinDstExtent returns the value of minDstExtent from VkDisplayPlaneCapabilitiesKHR
func (x DisplayPlaneCapabilitiesKHR) MinDstExtent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.minDstExtent) 
	return *ptr
}

// MaxDstExtent returns the value of maxDstExtent from VkDisplayPlaneCapabilitiesKHR
func (x DisplayPlaneCapabilitiesKHR) MaxDstExtent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.maxDstExtent) 
	return *ptr
}

// DisplayModeParametersKHR provides a go interface for VkDisplayModeParametersKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModeParametersKHR.html
type DisplayModeParametersKHR C.struct_VkDisplayModeParametersKHR

// SizeofDisplayModeParametersKHR is the memory size of a DisplayModeParametersKHR
var SizeofDisplayModeParametersKHR int = int(unsafe.Sizeof(DisplayModeParametersKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayModeParametersKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayModeParametersKHR) AsCPtr() *DisplayModeParametersKHR {
	clone := (*DisplayModeParametersKHR)(newCBlock(C.ulong(SizeofDisplayModeParametersKHR)))
	*clone = x
	return clone
}

// DisplayModeParametersKHRFreeCSlice releases the memory allocated by DisplayModeParametersKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayModeParametersKHRFreeCSlice(x []DisplayModeParametersKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayModeParametersKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayModeParametersKHRFreeCSlice must be called on the returned slice.
func DisplayModeParametersKHRMakeCSlice(x ...DisplayModeParametersKHR) []DisplayModeParametersKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayModeParametersKHR * len(x)
	dst := unsafe.Slice((*DisplayModeParametersKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// VisibleRegion returns the value of visibleRegion from VkDisplayModeParametersKHR
func (x DisplayModeParametersKHR) VisibleRegion() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.visibleRegion) 
	return *ptr
}

// WithVisibleRegion sets the value for the VisibleRegion on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayModeParametersKHR) WithVisibleRegion(y Extent2D) DisplayModeParametersKHR {
	x.visibleRegion = *(/* typedef */ (*C.struct_VkExtent2D)(&y))
	return x
}

// RefreshRate returns the value of refreshRate from VkDisplayModeParametersKHR
func (x DisplayModeParametersKHR) RefreshRate() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.refreshRate) 
	return *ptr
}

// WithRefreshRate sets the value for the RefreshRate on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayModeParametersKHR) WithRefreshRate(y uint32) DisplayModeParametersKHR {
	x.refreshRate = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// DisplaySurfaceCreateInfoKHR provides a go interface for VkDisplaySurfaceCreateInfoKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplaySurfaceCreateInfoKHR.html
type DisplaySurfaceCreateInfoKHR C.struct_VkDisplaySurfaceCreateInfoKHR

// SizeofDisplaySurfaceCreateInfoKHR is the memory size of a DisplaySurfaceCreateInfoKHR
var SizeofDisplaySurfaceCreateInfoKHR int = int(unsafe.Sizeof(DisplaySurfaceCreateInfoKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplaySurfaceCreateInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplaySurfaceCreateInfoKHR) AsCPtr() *DisplaySurfaceCreateInfoKHR {
	clone := (*DisplaySurfaceCreateInfoKHR)(newCBlock(C.ulong(SizeofDisplaySurfaceCreateInfoKHR)))
	*clone = x
	return clone
}

// DisplaySurfaceCreateInfoKHRFreeCSlice releases the memory allocated by DisplaySurfaceCreateInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplaySurfaceCreateInfoKHRFreeCSlice(x []DisplaySurfaceCreateInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplaySurfaceCreateInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplaySurfaceCreateInfoKHRFreeCSlice must be called on the returned slice.
func DisplaySurfaceCreateInfoKHRMakeCSlice(x ...DisplaySurfaceCreateInfoKHR) []DisplaySurfaceCreateInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplaySurfaceCreateInfoKHR * len(x)
	dst := unsafe.Slice((*DisplaySurfaceCreateInfoKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DisplaySurfaceCreateInfoKHR) WithDefaultSType() DisplaySurfaceCreateInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithSType(y StructureType) DisplaySurfaceCreateInfoKHR {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithPNext(y unsafe.Pointer) DisplaySurfaceCreateInfoKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Flags returns the value of flags from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) Flags() DisplaySurfaceCreateFlagsKHR {
	ptr := /* typedef */ (*DisplaySurfaceCreateFlagsKHR)(&x.flags) 
	return *ptr
}

// WithFlags sets the value for the Flags on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithFlags(y DisplaySurfaceCreateFlagsKHR) DisplaySurfaceCreateInfoKHR {
	x.flags = *(/* typedef */ (*C.VkDisplaySurfaceCreateFlagsKHR)(&y))
	return x
}

// DisplayMode returns the value of displayMode from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) DisplayMode() DisplayModeKHR {
	ptr := /* handle */ (*DisplayModeKHR)(&x.displayMode) 
	return *ptr
}

// WithDisplayMode sets the value for the DisplayMode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithDisplayMode(y DisplayModeKHR) DisplaySurfaceCreateInfoKHR {
	x.displayMode = *(/* handle */ (*C.VkDisplayModeKHR)(&y))
	return x
}

// PlaneIndex returns the value of planeIndex from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) PlaneIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.planeIndex) 
	return *ptr
}

// WithPlaneIndex sets the value for the PlaneIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithPlaneIndex(y uint32) DisplaySurfaceCreateInfoKHR {
	x.planeIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// PlaneStackIndex returns the value of planeStackIndex from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) PlaneStackIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.planeStackIndex) 
	return *ptr
}

// WithPlaneStackIndex sets the value for the PlaneStackIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithPlaneStackIndex(y uint32) DisplaySurfaceCreateInfoKHR {
	x.planeStackIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// Transform returns the value of transform from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) Transform() SurfaceTransformFlagBitsKHR {
	ptr := /* typedef */ (*SurfaceTransformFlagBitsKHR)(&x.transform) 
	return *ptr
}

// WithTransform sets the value for the Transform on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithTransform(y SurfaceTransformFlagBitsKHR) DisplaySurfaceCreateInfoKHR {
	x.transform = *(/* typedef */ (*C.VkSurfaceTransformFlagBitsKHR)(&y))
	return x
}

// GlobalAlpha returns the value of globalAlpha from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) GlobalAlpha() float32 {
	ptr := func(x *C.float) *float32 { /* Scalar */ c2g := float32(*x); return &c2g }(&x.globalAlpha) 
	return *ptr
}

// WithGlobalAlpha sets the value for the GlobalAlpha on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithGlobalAlpha(y float32) DisplaySurfaceCreateInfoKHR {
	x.globalAlpha = *(func(x *float32) *C.float { /* Scalar */ g2c := C.float(*x); return &g2c }(&y))
	return x
}

// AlphaMode returns the value of alphaMode from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) AlphaMode() DisplayPlaneAlphaFlagBitsKHR {
	ptr := /* typedef */ (*DisplayPlaneAlphaFlagBitsKHR)(&x.alphaMode) 
	return *ptr
}

// WithAlphaMode sets the value for the AlphaMode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithAlphaMode(y DisplayPlaneAlphaFlagBitsKHR) DisplaySurfaceCreateInfoKHR {
	x.alphaMode = *(/* typedef */ (*C.VkDisplayPlaneAlphaFlagBitsKHR)(&y))
	return x
}

// ImageExtent returns the value of imageExtent from VkDisplaySurfaceCreateInfoKHR
func (x DisplaySurfaceCreateInfoKHR) ImageExtent() Extent2D {
	ptr := /* typedef */ (*Extent2D)(&x.imageExtent) 
	return *ptr
}

// WithImageExtent sets the value for the ImageExtent on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplaySurfaceCreateInfoKHR) WithImageExtent(y Extent2D) DisplaySurfaceCreateInfoKHR {
	x.imageExtent = *(/* typedef */ (*C.struct_VkExtent2D)(&y))
	return x
}

// CreateDisplayPlaneSurfaceKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDisplayPlaneSurfaceKHR.html
func (x InstanceFacade)CreateDisplayPlaneSurfaceKHR(pCreateInfo *DisplaySurfaceCreateInfoKHR, pAllocator *AllocationCallbacks, pSurface *SurfaceKHR, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkInstance)(&x.H)
	p1 := func(x **DisplaySurfaceCreateInfoKHR) **C.struct_VkDisplaySurfaceCreateInfoKHR { /* Pointer */ g2c := (*C.struct_VkDisplaySurfaceCreateInfoKHR)(*x); return &g2c }(&pCreateInfo)
	p2 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p3 := func(x **SurfaceKHR) **C.VkSurfaceKHR { /* Pointer */ g2c := (*C.VkSurfaceKHR)(*x); return &g2c }(&pSurface)
	ret := C.vkCreateDisplayPlaneSurfaceKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetDisplayPlaneCapabilitiesKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayPlaneCapabilitiesKHR.html
func (x PhysicalDeviceFacade)GetDisplayPlaneCapabilitiesKHR(mode DisplayModeKHR, planeIndex uint32, pCapabilities *DisplayPlaneCapabilitiesKHR, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* handle */ (*C.VkDisplayModeKHR)(&mode)
	p2 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&planeIndex)
	p3 := func(x **DisplayPlaneCapabilitiesKHR) **C.struct_VkDisplayPlaneCapabilitiesKHR { /* Pointer */ g2c := (*C.struct_VkDisplayPlaneCapabilitiesKHR)(*x); return &g2c }(&pCapabilities)
	ret := C.vkGetDisplayPlaneCapabilitiesKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// CreateDisplayModeKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDisplayModeKHR.html
func (x PhysicalDeviceFacade)CreateDisplayModeKHR(display DisplayKHR, pCreateInfo *DisplayModeCreateInfoKHR, pAllocator *AllocationCallbacks, pMode *DisplayModeKHR, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* handle */ (*C.VkDisplayKHR)(&display)
	p2 := func(x **DisplayModeCreateInfoKHR) **C.struct_VkDisplayModeCreateInfoKHR { /* Pointer */ g2c := (*C.struct_VkDisplayModeCreateInfoKHR)(*x); return &g2c }(&pCreateInfo)
	p3 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p4 := func(x **DisplayModeKHR) **C.VkDisplayModeKHR { /* Pointer */ g2c := (*C.VkDisplayModeKHR)(*x); return &g2c }(&pMode)
	ret := C.vkCreateDisplayModeKHR(addrs, *p0, *p1, *p2, *p3, *p4)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetDisplayModePropertiesKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayModePropertiesKHR.html
func (x PhysicalDeviceFacade)GetDisplayModePropertiesKHR(display DisplayKHR, pPropertyCount *uint32, pProperties []DisplayModePropertiesKHR, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* handle */ (*C.VkDisplayKHR)(&display)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPropertyCount)
	p3 := func(x *[]DisplayModePropertiesKHR) **C.struct_VkDisplayModePropertiesKHR { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkDisplayModePropertiesKHR)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkDisplayModePropertiesKHR)(unsafe.Pointer((&ptr))) }(&pProperties)
	ret := C.vkGetDisplayModePropertiesKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetDisplayPlaneSupportedDisplaysKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayPlaneSupportedDisplaysKHR.html
func (x PhysicalDeviceFacade)GetDisplayPlaneSupportedDisplaysKHR(planeIndex uint32, pDisplayCount *uint32, pDisplays []DisplayKHR, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&planeIndex)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pDisplayCount)
	p3 := func(x *[]DisplayKHR) **C.VkDisplayKHR { /* Slice */ if len(*x) > 0 { slc := (*C.VkDisplayKHR)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkDisplayKHR)(unsafe.Pointer((&ptr))) }(&pDisplays)
	ret := C.vkGetDisplayPlaneSupportedDisplaysKHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceDisplayPlanePropertiesKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayPlanePropertiesKHR.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceDisplayPlanePropertiesKHR(pPropertyCount *uint32, pProperties []DisplayPlanePropertiesKHR, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPropertyCount)
	p2 := func(x *[]DisplayPlanePropertiesKHR) **C.struct_VkDisplayPlanePropertiesKHR { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkDisplayPlanePropertiesKHR)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkDisplayPlanePropertiesKHR)(unsafe.Pointer((&ptr))) }(&pProperties)
	ret := C.vkGetPhysicalDeviceDisplayPlanePropertiesKHR(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceDisplayPropertiesKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayPropertiesKHR.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceDisplayPropertiesKHR(pPropertyCount *uint32, pProperties []DisplayPropertiesKHR, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPropertyCount)
	p2 := func(x *[]DisplayPropertiesKHR) **C.struct_VkDisplayPropertiesKHR { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkDisplayPropertiesKHR)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkDisplayPropertiesKHR)(unsafe.Pointer((&ptr))) }(&pProperties)
	ret := C.vkGetPhysicalDeviceDisplayPropertiesKHR(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DisplayModeProperties2KHR provides a go interface for VkDisplayModeProperties2KHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayModeProperties2KHR.html
type DisplayModeProperties2KHR C.struct_VkDisplayModeProperties2KHR

// SizeofDisplayModeProperties2KHR is the memory size of a DisplayModeProperties2KHR
var SizeofDisplayModeProperties2KHR int = int(unsafe.Sizeof(DisplayModeProperties2KHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayModeProperties2KHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayModeProperties2KHR) AsCPtr() *DisplayModeProperties2KHR {
	clone := (*DisplayModeProperties2KHR)(newCBlock(C.ulong(SizeofDisplayModeProperties2KHR)))
	*clone = x
	return clone
}

// DisplayModeProperties2KHRFreeCSlice releases the memory allocated by DisplayModeProperties2KHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayModeProperties2KHRFreeCSlice(x []DisplayModeProperties2KHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayModeProperties2KHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayModeProperties2KHRFreeCSlice must be called on the returned slice.
func DisplayModeProperties2KHRMakeCSlice(x ...DisplayModeProperties2KHR) []DisplayModeProperties2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayModeProperties2KHR * len(x)
	dst := unsafe.Slice((*DisplayModeProperties2KHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDisplayModeProperties2KHR
func (x DisplayModeProperties2KHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DisplayModeProperties2KHR) WithDefaultSType() DisplayModeProperties2KHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayModeProperties2KHR) WithSType(y StructureType) DisplayModeProperties2KHR {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDisplayModeProperties2KHR
func (x DisplayModeProperties2KHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayModeProperties2KHR) WithPNext(y unsafe.Pointer) DisplayModeProperties2KHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// DisplayModeProperties returns the value of displayModeProperties from VkDisplayModeProperties2KHR
func (x DisplayModeProperties2KHR) DisplayModeProperties() DisplayModePropertiesKHR {
	ptr := /* typedef */ (*DisplayModePropertiesKHR)(&x.displayModeProperties) 
	return *ptr
}

// DisplayPlaneInfo2KHR provides a go interface for VkDisplayPlaneInfo2KHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlaneInfo2KHR.html
type DisplayPlaneInfo2KHR C.struct_VkDisplayPlaneInfo2KHR

// SizeofDisplayPlaneInfo2KHR is the memory size of a DisplayPlaneInfo2KHR
var SizeofDisplayPlaneInfo2KHR int = int(unsafe.Sizeof(DisplayPlaneInfo2KHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayPlaneInfo2KHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayPlaneInfo2KHR) AsCPtr() *DisplayPlaneInfo2KHR {
	clone := (*DisplayPlaneInfo2KHR)(newCBlock(C.ulong(SizeofDisplayPlaneInfo2KHR)))
	*clone = x
	return clone
}

// DisplayPlaneInfo2KHRFreeCSlice releases the memory allocated by DisplayPlaneInfo2KHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayPlaneInfo2KHRFreeCSlice(x []DisplayPlaneInfo2KHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayPlaneInfo2KHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayPlaneInfo2KHRFreeCSlice must be called on the returned slice.
func DisplayPlaneInfo2KHRMakeCSlice(x ...DisplayPlaneInfo2KHR) []DisplayPlaneInfo2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPlaneInfo2KHR * len(x)
	dst := unsafe.Slice((*DisplayPlaneInfo2KHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDisplayPlaneInfo2KHR
func (x DisplayPlaneInfo2KHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DisplayPlaneInfo2KHR) WithDefaultSType() DisplayPlaneInfo2KHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPlaneInfo2KHR) WithSType(y StructureType) DisplayPlaneInfo2KHR {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDisplayPlaneInfo2KHR
func (x DisplayPlaneInfo2KHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPlaneInfo2KHR) WithPNext(y unsafe.Pointer) DisplayPlaneInfo2KHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Mode returns the value of mode from VkDisplayPlaneInfo2KHR
func (x DisplayPlaneInfo2KHR) Mode() DisplayModeKHR {
	ptr := /* handle */ (*DisplayModeKHR)(&x.mode) 
	return *ptr
}

// WithMode sets the value for the Mode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPlaneInfo2KHR) WithMode(y DisplayModeKHR) DisplayPlaneInfo2KHR {
	x.mode = *(/* handle */ (*C.VkDisplayModeKHR)(&y))
	return x
}

// PlaneIndex returns the value of planeIndex from VkDisplayPlaneInfo2KHR
func (x DisplayPlaneInfo2KHR) PlaneIndex() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.planeIndex) 
	return *ptr
}

// WithPlaneIndex sets the value for the PlaneIndex on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPlaneInfo2KHR) WithPlaneIndex(y uint32) DisplayPlaneInfo2KHR {
	x.planeIndex = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}

// DisplayPlaneCapabilities2KHR provides a go interface for VkDisplayPlaneCapabilities2KHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlaneCapabilities2KHR.html
type DisplayPlaneCapabilities2KHR C.struct_VkDisplayPlaneCapabilities2KHR

// SizeofDisplayPlaneCapabilities2KHR is the memory size of a DisplayPlaneCapabilities2KHR
var SizeofDisplayPlaneCapabilities2KHR int = int(unsafe.Sizeof(DisplayPlaneCapabilities2KHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayPlaneCapabilities2KHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayPlaneCapabilities2KHR) AsCPtr() *DisplayPlaneCapabilities2KHR {
	clone := (*DisplayPlaneCapabilities2KHR)(newCBlock(C.ulong(SizeofDisplayPlaneCapabilities2KHR)))
	*clone = x
	return clone
}

// DisplayPlaneCapabilities2KHRFreeCSlice releases the memory allocated by DisplayPlaneCapabilities2KHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayPlaneCapabilities2KHRFreeCSlice(x []DisplayPlaneCapabilities2KHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayPlaneCapabilities2KHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayPlaneCapabilities2KHRFreeCSlice must be called on the returned slice.
func DisplayPlaneCapabilities2KHRMakeCSlice(x ...DisplayPlaneCapabilities2KHR) []DisplayPlaneCapabilities2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPlaneCapabilities2KHR * len(x)
	dst := unsafe.Slice((*DisplayPlaneCapabilities2KHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDisplayPlaneCapabilities2KHR
func (x DisplayPlaneCapabilities2KHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DisplayPlaneCapabilities2KHR) WithDefaultSType() DisplayPlaneCapabilities2KHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPlaneCapabilities2KHR) WithSType(y StructureType) DisplayPlaneCapabilities2KHR {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDisplayPlaneCapabilities2KHR
func (x DisplayPlaneCapabilities2KHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPlaneCapabilities2KHR) WithPNext(y unsafe.Pointer) DisplayPlaneCapabilities2KHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// Capabilities returns the value of capabilities from VkDisplayPlaneCapabilities2KHR
func (x DisplayPlaneCapabilities2KHR) Capabilities() DisplayPlaneCapabilitiesKHR {
	ptr := /* typedef */ (*DisplayPlaneCapabilitiesKHR)(&x.capabilities) 
	return *ptr
}

// DisplayProperties2KHR provides a go interface for VkDisplayProperties2KHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayProperties2KHR.html
type DisplayProperties2KHR C.struct_VkDisplayProperties2KHR

// SizeofDisplayProperties2KHR is the memory size of a DisplayProperties2KHR
var SizeofDisplayProperties2KHR int = int(unsafe.Sizeof(DisplayProperties2KHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayProperties2KHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayProperties2KHR) AsCPtr() *DisplayProperties2KHR {
	clone := (*DisplayProperties2KHR)(newCBlock(C.ulong(SizeofDisplayProperties2KHR)))
	*clone = x
	return clone
}

// DisplayProperties2KHRFreeCSlice releases the memory allocated by DisplayProperties2KHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayProperties2KHRFreeCSlice(x []DisplayProperties2KHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayProperties2KHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayProperties2KHRFreeCSlice must be called on the returned slice.
func DisplayProperties2KHRMakeCSlice(x ...DisplayProperties2KHR) []DisplayProperties2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayProperties2KHR * len(x)
	dst := unsafe.Slice((*DisplayProperties2KHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDisplayProperties2KHR
func (x DisplayProperties2KHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DisplayProperties2KHR) WithDefaultSType() DisplayProperties2KHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayProperties2KHR) WithSType(y StructureType) DisplayProperties2KHR {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDisplayProperties2KHR
func (x DisplayProperties2KHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayProperties2KHR) WithPNext(y unsafe.Pointer) DisplayProperties2KHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// DisplayProperties returns the value of displayProperties from VkDisplayProperties2KHR
func (x DisplayProperties2KHR) DisplayProperties() DisplayPropertiesKHR {
	ptr := /* typedef */ (*DisplayPropertiesKHR)(&x.displayProperties) 
	return *ptr
}

// DisplayPlaneProperties2KHR provides a go interface for VkDisplayPlaneProperties2KHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPlaneProperties2KHR.html
type DisplayPlaneProperties2KHR C.struct_VkDisplayPlaneProperties2KHR

// SizeofDisplayPlaneProperties2KHR is the memory size of a DisplayPlaneProperties2KHR
var SizeofDisplayPlaneProperties2KHR int = int(unsafe.Sizeof(DisplayPlaneProperties2KHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayPlaneProperties2KHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayPlaneProperties2KHR) AsCPtr() *DisplayPlaneProperties2KHR {
	clone := (*DisplayPlaneProperties2KHR)(newCBlock(C.ulong(SizeofDisplayPlaneProperties2KHR)))
	*clone = x
	return clone
}

// DisplayPlaneProperties2KHRFreeCSlice releases the memory allocated by DisplayPlaneProperties2KHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayPlaneProperties2KHRFreeCSlice(x []DisplayPlaneProperties2KHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayPlaneProperties2KHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayPlaneProperties2KHRFreeCSlice must be called on the returned slice.
func DisplayPlaneProperties2KHRMakeCSlice(x ...DisplayPlaneProperties2KHR) []DisplayPlaneProperties2KHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPlaneProperties2KHR * len(x)
	dst := unsafe.Slice((*DisplayPlaneProperties2KHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDisplayPlaneProperties2KHR
func (x DisplayPlaneProperties2KHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DisplayPlaneProperties2KHR) WithDefaultSType() DisplayPlaneProperties2KHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPlaneProperties2KHR) WithSType(y StructureType) DisplayPlaneProperties2KHR {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDisplayPlaneProperties2KHR
func (x DisplayPlaneProperties2KHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPlaneProperties2KHR) WithPNext(y unsafe.Pointer) DisplayPlaneProperties2KHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// DisplayPlaneProperties returns the value of displayPlaneProperties from VkDisplayPlaneProperties2KHR
func (x DisplayPlaneProperties2KHR) DisplayPlaneProperties() DisplayPlanePropertiesKHR {
	ptr := /* typedef */ (*DisplayPlanePropertiesKHR)(&x.displayPlaneProperties) 
	return *ptr
}

// GetDisplayPlaneCapabilities2KHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayPlaneCapabilities2KHR.html
func (x PhysicalDeviceFacade)GetDisplayPlaneCapabilities2KHR(pDisplayPlaneInfo *DisplayPlaneInfo2KHR, pCapabilities *DisplayPlaneCapabilities2KHR, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **DisplayPlaneInfo2KHR) **C.struct_VkDisplayPlaneInfo2KHR { /* Pointer */ g2c := (*C.struct_VkDisplayPlaneInfo2KHR)(*x); return &g2c }(&pDisplayPlaneInfo)
	p2 := func(x **DisplayPlaneCapabilities2KHR) **C.struct_VkDisplayPlaneCapabilities2KHR { /* Pointer */ g2c := (*C.struct_VkDisplayPlaneCapabilities2KHR)(*x); return &g2c }(&pCapabilities)
	ret := C.vkGetDisplayPlaneCapabilities2KHR(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceDisplayProperties2KHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayProperties2KHR.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceDisplayProperties2KHR(pPropertyCount *uint32, pProperties []DisplayProperties2KHR, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPropertyCount)
	p2 := func(x *[]DisplayProperties2KHR) **C.struct_VkDisplayProperties2KHR { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkDisplayProperties2KHR)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkDisplayProperties2KHR)(unsafe.Pointer((&ptr))) }(&pProperties)
	ret := C.vkGetPhysicalDeviceDisplayProperties2KHR(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetPhysicalDeviceDisplayPlaneProperties2KHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayPlaneProperties2KHR.html
func (x PhysicalDeviceFacade)GetPhysicalDeviceDisplayPlaneProperties2KHR(pPropertyCount *uint32, pProperties []DisplayPlaneProperties2KHR, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPropertyCount)
	p2 := func(x *[]DisplayPlaneProperties2KHR) **C.struct_VkDisplayPlaneProperties2KHR { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkDisplayPlaneProperties2KHR)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkDisplayPlaneProperties2KHR)(unsafe.Pointer((&ptr))) }(&pProperties)
	ret := C.vkGetPhysicalDeviceDisplayPlaneProperties2KHR(addrs, *p0, *p1, *p2)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// GetDisplayModeProperties2KHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayModeProperties2KHR.html
func (x PhysicalDeviceFacade)GetDisplayModeProperties2KHR(display DisplayKHR, pPropertyCount *uint32, pProperties []DisplayModeProperties2KHR, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkPhysicalDevice)(&x.H)
	p1 := /* handle */ (*C.VkDisplayKHR)(&display)
	p2 := func(x **uint32) **C.uint32_t { /* Pointer */ g2c := (*C.uint32_t)(*x); return &g2c }(&pPropertyCount)
	p3 := func(x *[]DisplayModeProperties2KHR) **C.struct_VkDisplayModeProperties2KHR { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkDisplayModeProperties2KHR)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkDisplayModeProperties2KHR)(unsafe.Pointer((&ptr))) }(&pProperties)
	ret := C.vkGetDisplayModeProperties2KHR(addrs, *p0, *p1, *p2, *p3)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// DisplayPresentInfoKHR provides a go interface for VkDisplayPresentInfoKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkDisplayPresentInfoKHR.html
type DisplayPresentInfoKHR C.struct_VkDisplayPresentInfoKHR

// SizeofDisplayPresentInfoKHR is the memory size of a DisplayPresentInfoKHR
var SizeofDisplayPresentInfoKHR int = int(unsafe.Sizeof(DisplayPresentInfoKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *DisplayPresentInfoKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x DisplayPresentInfoKHR) AsCPtr() *DisplayPresentInfoKHR {
	clone := (*DisplayPresentInfoKHR)(newCBlock(C.ulong(SizeofDisplayPresentInfoKHR)))
	*clone = x
	return clone
}

// DisplayPresentInfoKHRFreeCSlice releases the memory allocated by DisplayPresentInfoKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func DisplayPresentInfoKHRFreeCSlice(x []DisplayPresentInfoKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// DisplayPresentInfoKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. DisplayPresentInfoKHRFreeCSlice must be called on the returned slice.
func DisplayPresentInfoKHRMakeCSlice(x ...DisplayPresentInfoKHR) []DisplayPresentInfoKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofDisplayPresentInfoKHR * len(x)
	dst := unsafe.Slice((*DisplayPresentInfoKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkDisplayPresentInfoKHR
func (x DisplayPresentInfoKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x DisplayPresentInfoKHR) WithDefaultSType() DisplayPresentInfoKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPresentInfoKHR) WithSType(y StructureType) DisplayPresentInfoKHR {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkDisplayPresentInfoKHR
func (x DisplayPresentInfoKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPresentInfoKHR) WithPNext(y unsafe.Pointer) DisplayPresentInfoKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// SrcRect returns the value of srcRect from VkDisplayPresentInfoKHR
func (x DisplayPresentInfoKHR) SrcRect() Rect2D {
	ptr := /* typedef */ (*Rect2D)(&x.srcRect) 
	return *ptr
}

// WithSrcRect sets the value for the SrcRect on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPresentInfoKHR) WithSrcRect(y Rect2D) DisplayPresentInfoKHR {
	x.srcRect = *(/* typedef */ (*C.struct_VkRect2D)(&y))
	return x
}

// DstRect returns the value of dstRect from VkDisplayPresentInfoKHR
func (x DisplayPresentInfoKHR) DstRect() Rect2D {
	ptr := /* typedef */ (*Rect2D)(&x.dstRect) 
	return *ptr
}

// WithDstRect sets the value for the DstRect on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPresentInfoKHR) WithDstRect(y Rect2D) DisplayPresentInfoKHR {
	x.dstRect = *(/* typedef */ (*C.struct_VkRect2D)(&y))
	return x
}

// Persistent returns the value of persistent from VkDisplayPresentInfoKHR
func (x DisplayPresentInfoKHR) Persistent() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.persistent) 
	return *ptr
}

// WithPersistent sets the value for the Persistent on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x DisplayPresentInfoKHR) WithPersistent(y Bool32) DisplayPresentInfoKHR {
	x.persistent = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// CreateSharedSwapchainsKHR command
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSharedSwapchainsKHR.html
func (x DeviceFacade)CreateSharedSwapchainsKHR(swapchainCount uint32, pCreateInfos []SwapchainCreateInfoKHR, pAllocator *AllocationCallbacks, pSwapchains []SwapchainKHR, ) Result {
	addrs := x.procs
	p0 := /* handle */ (*C.VkDevice)(&x.H)
	p1 := func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&swapchainCount)
	p2 := func(x *[]SwapchainCreateInfoKHR) **C.struct_VkSwapchainCreateInfoKHR { /* Slice */ if len(*x) > 0 { slc := (*C.struct_VkSwapchainCreateInfoKHR)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.struct_VkSwapchainCreateInfoKHR)(unsafe.Pointer((&ptr))) }(&pCreateInfos)
	p3 := func(x **AllocationCallbacks) **C.struct_VkAllocationCallbacks { /* Pointer */ g2c := (*C.struct_VkAllocationCallbacks)(*x); return &g2c }(&pAllocator)
	p4 := func(x *[]SwapchainKHR) **C.VkSwapchainKHR { /* Slice */ if len(*x) > 0 { slc := (*C.VkSwapchainKHR)(unsafe.Pointer(&((*x)[0]))); return &slc }; var ptr unsafe.Pointer; return (**C.VkSwapchainKHR)(unsafe.Pointer((&ptr))) }(&pSwapchains)
	ret := C.vkCreateSharedSwapchainsKHR(addrs, *p0, *p1, *p2, *p3, *p4)
	retPtr := /* typedef */ (*Result)(&ret)
	return *retPtr
}

// FormatFeatureFlagBits2KHR enum/enums
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatFeatureFlagBits2KHR.html
type FormatFeatureFlagBits2KHR uint32

// FormatFeatureFlags2KHR bitmask
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatFeatureFlags2KHR.html
type FormatFeatureFlags2KHR uint32

//FormatProperties3KHR is an alias to FormatProperties3.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkFormatProperties3KHR.html
//
// Deprecated: Most Aliases in the Vulkan spec are for compatibility purposes as extensions get
// promoted to features. If possible, update code to use the promoted name: FormatProperties3.
type FormatProperties3KHR = FormatProperties3
// PhysicalDevicePortabilitySubsetFeaturesKHR provides a go interface for VkPhysicalDevicePortabilitySubsetFeaturesKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html
type PhysicalDevicePortabilitySubsetFeaturesKHR C.struct_VkPhysicalDevicePortabilitySubsetFeaturesKHR

// SizeofPhysicalDevicePortabilitySubsetFeaturesKHR is the memory size of a PhysicalDevicePortabilitySubsetFeaturesKHR
var SizeofPhysicalDevicePortabilitySubsetFeaturesKHR int = int(unsafe.Sizeof(PhysicalDevicePortabilitySubsetFeaturesKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDevicePortabilitySubsetFeaturesKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) AsCPtr() *PhysicalDevicePortabilitySubsetFeaturesKHR {
	clone := (*PhysicalDevicePortabilitySubsetFeaturesKHR)(newCBlock(C.ulong(SizeofPhysicalDevicePortabilitySubsetFeaturesKHR)))
	*clone = x
	return clone
}

// PhysicalDevicePortabilitySubsetFeaturesKHRFreeCSlice releases the memory allocated by PhysicalDevicePortabilitySubsetFeaturesKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDevicePortabilitySubsetFeaturesKHRFreeCSlice(x []PhysicalDevicePortabilitySubsetFeaturesKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDevicePortabilitySubsetFeaturesKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDevicePortabilitySubsetFeaturesKHRFreeCSlice must be called on the returned slice.
func PhysicalDevicePortabilitySubsetFeaturesKHRMakeCSlice(x ...PhysicalDevicePortabilitySubsetFeaturesKHR) []PhysicalDevicePortabilitySubsetFeaturesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDevicePortabilitySubsetFeaturesKHR * len(x)
	dst := unsafe.Slice((*PhysicalDevicePortabilitySubsetFeaturesKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithDefaultSType() PhysicalDevicePortabilitySubsetFeaturesKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithSType(y StructureType) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithPNext(y unsafe.Pointer) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// ConstantAlphaColorBlendFactors returns the value of constantAlphaColorBlendFactors from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) ConstantAlphaColorBlendFactors() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.constantAlphaColorBlendFactors) 
	return *ptr
}

// WithConstantAlphaColorBlendFactors sets the value for the ConstantAlphaColorBlendFactors on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithConstantAlphaColorBlendFactors(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.constantAlphaColorBlendFactors = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// Events returns the value of events from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) Events() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.events) 
	return *ptr
}

// WithEvents sets the value for the Events on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithEvents(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.events = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ImageViewFormatReinterpretation returns the value of imageViewFormatReinterpretation from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) ImageViewFormatReinterpretation() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.imageViewFormatReinterpretation) 
	return *ptr
}

// WithImageViewFormatReinterpretation sets the value for the ImageViewFormatReinterpretation on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithImageViewFormatReinterpretation(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.imageViewFormatReinterpretation = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ImageViewFormatSwizzle returns the value of imageViewFormatSwizzle from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) ImageViewFormatSwizzle() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.imageViewFormatSwizzle) 
	return *ptr
}

// WithImageViewFormatSwizzle sets the value for the ImageViewFormatSwizzle on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithImageViewFormatSwizzle(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.imageViewFormatSwizzle = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ImageView2DOn3DImage returns the value of imageView2DOn3DImage from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) ImageView2DOn3DImage() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.imageView2DOn3DImage) 
	return *ptr
}

// WithImageView2DOn3DImage sets the value for the ImageView2DOn3DImage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithImageView2DOn3DImage(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.imageView2DOn3DImage = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// MultisampleArrayImage returns the value of multisampleArrayImage from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) MultisampleArrayImage() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.multisampleArrayImage) 
	return *ptr
}

// WithMultisampleArrayImage sets the value for the MultisampleArrayImage on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithMultisampleArrayImage(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.multisampleArrayImage = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// MutableComparisonSamplers returns the value of mutableComparisonSamplers from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) MutableComparisonSamplers() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.mutableComparisonSamplers) 
	return *ptr
}

// WithMutableComparisonSamplers sets the value for the MutableComparisonSamplers on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithMutableComparisonSamplers(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.mutableComparisonSamplers = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// PointPolygons returns the value of pointPolygons from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) PointPolygons() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.pointPolygons) 
	return *ptr
}

// WithPointPolygons sets the value for the PointPolygons on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithPointPolygons(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.pointPolygons = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// SamplerMipLodBias returns the value of samplerMipLodBias from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) SamplerMipLodBias() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.samplerMipLodBias) 
	return *ptr
}

// WithSamplerMipLodBias sets the value for the SamplerMipLodBias on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithSamplerMipLodBias(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.samplerMipLodBias = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// SeparateStencilMaskRef returns the value of separateStencilMaskRef from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) SeparateStencilMaskRef() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.separateStencilMaskRef) 
	return *ptr
}

// WithSeparateStencilMaskRef sets the value for the SeparateStencilMaskRef on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithSeparateStencilMaskRef(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.separateStencilMaskRef = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// ShaderSampleRateInterpolationFunctions returns the value of shaderSampleRateInterpolationFunctions from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) ShaderSampleRateInterpolationFunctions() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.shaderSampleRateInterpolationFunctions) 
	return *ptr
}

// WithShaderSampleRateInterpolationFunctions sets the value for the ShaderSampleRateInterpolationFunctions on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithShaderSampleRateInterpolationFunctions(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.shaderSampleRateInterpolationFunctions = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// TessellationIsolines returns the value of tessellationIsolines from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) TessellationIsolines() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.tessellationIsolines) 
	return *ptr
}

// WithTessellationIsolines sets the value for the TessellationIsolines on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithTessellationIsolines(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.tessellationIsolines = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// TessellationPointMode returns the value of tessellationPointMode from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) TessellationPointMode() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.tessellationPointMode) 
	return *ptr
}

// WithTessellationPointMode sets the value for the TessellationPointMode on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithTessellationPointMode(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.tessellationPointMode = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// TriangleFans returns the value of triangleFans from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) TriangleFans() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.triangleFans) 
	return *ptr
}

// WithTriangleFans sets the value for the TriangleFans on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithTriangleFans(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.triangleFans = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// VertexAttributeAccessBeyondStride returns the value of vertexAttributeAccessBeyondStride from VkPhysicalDevicePortabilitySubsetFeaturesKHR
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) VertexAttributeAccessBeyondStride() Bool32 {
	ptr := /* typedef */ (*Bool32)(&x.vertexAttributeAccessBeyondStride) 
	return *ptr
}

// WithVertexAttributeAccessBeyondStride sets the value for the VertexAttributeAccessBeyondStride on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetFeaturesKHR) WithVertexAttributeAccessBeyondStride(y Bool32) PhysicalDevicePortabilitySubsetFeaturesKHR {
	x.vertexAttributeAccessBeyondStride = *(/* typedef */ (*C.VkBool32)(&y))
	return x
}

// PhysicalDevicePortabilitySubsetPropertiesKHR provides a go interface for VkPhysicalDevicePortabilitySubsetPropertiesKHR.
// https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePortabilitySubsetPropertiesKHR.html
type PhysicalDevicePortabilitySubsetPropertiesKHR C.struct_VkPhysicalDevicePortabilitySubsetPropertiesKHR

// SizeofPhysicalDevicePortabilitySubsetPropertiesKHR is the memory size of a PhysicalDevicePortabilitySubsetPropertiesKHR
var SizeofPhysicalDevicePortabilitySubsetPropertiesKHR int = int(unsafe.Sizeof(PhysicalDevicePortabilitySubsetPropertiesKHR{}))

// Free releases the memory allocated by AsCPtr.
// It does not free pointers stored in the structure.
func (x *PhysicalDevicePortabilitySubsetPropertiesKHR) Free() {
	C.free(unsafe.Pointer(x))
}

// AsCPtr copies the object to the C heap and returns the pointer.
// Free must be explicitly called on the returned pointer.
func (x PhysicalDevicePortabilitySubsetPropertiesKHR) AsCPtr() *PhysicalDevicePortabilitySubsetPropertiesKHR {
	clone := (*PhysicalDevicePortabilitySubsetPropertiesKHR)(newCBlock(C.ulong(SizeofPhysicalDevicePortabilitySubsetPropertiesKHR)))
	*clone = x
	return clone
}

// PhysicalDevicePortabilitySubsetPropertiesKHRFreeCSlice releases the memory allocated by PhysicalDevicePortabilitySubsetPropertiesKHRMakeCSlice.
// It does not free pointers stored inside the slice.
func PhysicalDevicePortabilitySubsetPropertiesKHRFreeCSlice(x []PhysicalDevicePortabilitySubsetPropertiesKHR) {
	if len(x) > 0 {
		C.free(unsafe.Pointer(&x[0]))
	}
}

// PhysicalDevicePortabilitySubsetPropertiesKHRMakeCSlice allocates memory for the passed arguments on the C heap,
// copies their values to the allocated memory, and creates a slice around the
// C memory. PhysicalDevicePortabilitySubsetPropertiesKHRFreeCSlice must be called on the returned slice.
func PhysicalDevicePortabilitySubsetPropertiesKHRMakeCSlice(x ...PhysicalDevicePortabilitySubsetPropertiesKHR) []PhysicalDevicePortabilitySubsetPropertiesKHR {
	if len(x) == 0 {
		return nil
	}
	sz := SizeofPhysicalDevicePortabilitySubsetPropertiesKHR * len(x)
	dst := unsafe.Slice((*PhysicalDevicePortabilitySubsetPropertiesKHR)(newCBlock(C.ulong(sz))), len(x))
	copy(dst, x)
	return dst
}

// SType returns the value of sType from VkPhysicalDevicePortabilitySubsetPropertiesKHR
func (x PhysicalDevicePortabilitySubsetPropertiesKHR) SType() StructureType {
	ptr := /* typedef */ (*StructureType)(&x.sType) 
	return *ptr
}

// WithDefaultSType sets the value of SType to the value provided in the
// specification. This method only exists if there is a single value in the specification.
func (x PhysicalDevicePortabilitySubsetPropertiesKHR) WithDefaultSType() PhysicalDevicePortabilitySubsetPropertiesKHR {
	return x.WithSType(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR)
}

// WithSType sets the value for the SType on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetPropertiesKHR) WithSType(y StructureType) PhysicalDevicePortabilitySubsetPropertiesKHR {
	x.sType = *(/* typedef */ (*C.VkStructureType)(&y))
	return x
}

// PNext returns the value of pNext from VkPhysicalDevicePortabilitySubsetPropertiesKHR
func (x PhysicalDevicePortabilitySubsetPropertiesKHR) PNext() unsafe.Pointer {
	ptr := func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ c2g := unsafe.Pointer(*x); return &c2g }(&x.pNext) 
	return *ptr
}

// WithPNext sets the value for the PNext on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetPropertiesKHR) WithPNext(y unsafe.Pointer) PhysicalDevicePortabilitySubsetPropertiesKHR {
	x.pNext = *(func(x *unsafe.Pointer) *unsafe.Pointer { /* Scalar */ g2c := unsafe.Pointer(*x); return &g2c }(&y))
	return x
}

// MinVertexInputBindingStrideAlignment returns the value of minVertexInputBindingStrideAlignment from VkPhysicalDevicePortabilitySubsetPropertiesKHR
func (x PhysicalDevicePortabilitySubsetPropertiesKHR) MinVertexInputBindingStrideAlignment() uint32 {
	ptr := func(x *C.uint32_t) *uint32 { /* Scalar */ c2g := uint32(*x); return &c2g }(&x.minVertexInputBindingStrideAlignment) 
	return *ptr
}

// WithMinVertexInputBindingStrideAlignment sets the value for the MinVertexInputBindingStrideAlignment on the underlying C structure.
// It performs whatever conversions are necessary to match the C API.
func (x PhysicalDevicePortabilitySubsetPropertiesKHR) WithMinVertexInputBindingStrideAlignment(y uint32) PhysicalDevicePortabilitySubsetPropertiesKHR {
	x.minVertexInputBindingStrideAlignment = *(func(x *uint32) *C.uint32_t { /* Scalar */ g2c := C.uint32_t(*x); return &g2c }(&y))
	return x
}



func newCBlock(sz C.ulong) unsafe.Pointer {
	ptr := C.malloc(sz)
	C.memset(ptr, 0, sz)
	return ptr
}

func nullTerminatedBuffer(s string) *bytes.Buffer {
	var str bytes.Buffer
	var isNullTerminated bool
	for _, c := range ([]byte)(s) {
		if c == 0 {
			isNullTerminated = true
		}
		str.WriteByte(c)
		if isNullTerminated {
			break
		}
	}
	if !isNullTerminated {
		str.WriteByte(0)
	}
	return &str
}
